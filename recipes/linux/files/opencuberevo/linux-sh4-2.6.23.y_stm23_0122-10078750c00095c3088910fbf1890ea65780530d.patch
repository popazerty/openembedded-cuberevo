From 10078750c00095c3088910fbf1890ea65780530d Mon Sep 17 00:00:00 2001
From: Francesco Virlinzi <francesco.virlinzi@st.com>
Date: Wed, 18 Nov 2009 16:09:15 +0100
Subject: [PATCH] stm: clk: Clock LLA on 7106 (based on 7105)

This patch updates the clk LLA code of 7105 to
support the 7106 variant

Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
---
 arch/sh/kernel/cpu/sh4/clock-regs-stx7105.h |  229 ++---
 arch/sh/kernel/cpu/sh4/clock-stx7105.c      | 1338 +++++++++++++--------------
 arch/sh/kernel/cpu/sh4/clock-stx7105.h      |   77 +-
 3 files changed, 760 insertions(+), 884 deletions(-)

diff --git a/arch/sh/kernel/cpu/sh4/clock-regs-stx7105.h b/arch/sh/kernel/cpu/sh4/clock-regs-stx7105.h
index 9ea67ad..5731dfa 100644
--- a/arch/sh/kernel/cpu/sh4/clock-regs-stx7105.h
+++ b/arch/sh/kernel/cpu/sh4/clock-regs-stx7105.h
@@ -1,171 +1,112 @@
-/*******************************************************************************
+/*****************************************************************************
  *
  * File name   : clock-regs-stx7105.h
  * Description : Low Level API - Base addresses & register definitions.
  *
  * COPYRIGHT (C) 2009 STMicroelectronics - All Rights Reserved
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
+ * License V2 _ONLY_.  See linux/COPYING for more information.
  *
-*******************************************************************************/
-
-#ifndef __CLOCK_LLA_7105REGS_H
-#define __CLOCK_LLA_7105REGS_H
-
-#define CKGA_BASE_ADDRESS	       0xFE213000
-#define CKGB_BASE_ADDRESS	       0xFE000000
-#define CKGC_BASE_ADDRESS	       0xFE210000
-#define SYSCFG_BASE_ADDRESS	     0xFE001000
-#define PIO5_BASE_ADDRESS	       0xFD025000
-
-#define PIO_BASE_ADDRESS(bank)	  0xFD025000
-
-
-/* --- SYSTEM CONFIG registers ( 0xfe001000 ) ------------------------------- */
-#define SYSCONF_DEVICEID	       0x00
-#define SYSCONF_EXTRADEVICEID	  0x04
-#define SYSCONF_STA0		   0x08
-#define SYSCONF_STA(x)			(SYSCONF_STA0 + (x) * 4)
-
-#define SYSCONF_CFG00		  0x100
-#define SYSCONF_CFG(x)			(SYSCONF_CFG00 + (x) * 4)
-
-
-/* --- CKGA registers ( hardware specific ) --------------------------------- */
-#define CKGA_PLL0_CFG		 0x000
-#define CKGA_PLL1_CFG		 0x004
-#define CKGA_POWER_CFG		      0x010
-#define CKGA_CLKOPSRC_SWITCH_CFG      0x014
-#define CKGA_OSC_ENABLE_FB	    0x018
-#define CKGA_PLL0_ENABLE_FB	   0x01c
-#define CKGA_PLL1_ENABLE_FB	   0x020
-#define CKGA_CLKOPSRC_SWITCH_CFG2     0x024
-
-#define CKGA_CLKOBS_MUX1_CFG	  0x030
-#define CKGA_CLKOBS_MASTER_MAXCOUNT   0x034
-#define CKGA_CLKOBS_CMD	       0x038
-#define CKGA_CLKOBS_STATUS	    0x03c
-#define CKGA_CLKOBS_SLAVE0_COUNT      0x040
-#define CKGA_OSCMUX_DEBUG	     0x044
-#define CKGA_CLKOBS_MUX2_CFG	  0x048
-#define CKGA_LOW_POWER_CTRL	   0x04C
-
-#define CKGA_OSC_DIV0_CFG	     0x800
+ *****************************************************************************/
+
+#ifndef __CLOCK_LLA_REGS_H
+#define __CLOCK_LLA_REGS_H
+
+/* --- Base addresses ---------------------------------------- */
+#define CKGA_BASE_ADDRESS		0xFE213000
+#define CKGB_BASE_ADDRESS		0xFE000000
+#define CKGC_BASE_ADDRESS		0xFE210000
+#define SYSCFG_BASE_ADDRESS		0xFE001000
+
+#define PIO5_BASE_ADDRESS		0xFD025000
+#define PIO_BASE_ADDRESS(bank)		0xFD025000
+
+/* --- SYSTEM CONFIG registers (0xfe001000) ------------------------------- */
+#define SYSCONF_DEVICEID		0x00
+#define SYSCONF_EXTRADEVICEID		0x04
+
+/* --- CKGA registers (hardware specific) ----------------------------------- */
+#define CKGA_PLL0_CFG			0x000
+#define CKGA_PLL1_CFG			0x004
+#define CKGA_POWER_CFG			0x010
+#define CKGA_CLKOPSRC_SWITCH_CFG	0x014
+#define CKGA_OSC_ENABLE_FB		0x018
+#define CKGA_PLL0_ENABLE_FB		0x01c
+#define CKGA_PLL1_ENABLE_FB		0x020
+#define CKGA_CLKOPSRC_SWITCH_CFG2	0x024
+
+#define CKGA_CLKOBS_MUX1_CFG		0x030
+#define CKGA_CLKOBS_MASTER_MAXCOUNT	0x034
+#define CKGA_CLKOBS_CMD			0x038
+#define CKGA_CLKOBS_STATUS		0x03c
+#define CKGA_CLKOBS_SLAVE0_COUNT	0x040
+#define CKGA_OSCMUX_DEBUG		0x044
+#define CKGA_CLKOBS_MUX2_CFG		0x048
+#define CKGA_LOW_POWER_CTRL		0x04C
+
+#define CKGA_OSC_DIV0_CFG		0x800
 #define CKGA_OSC_DIV_CFG(x)		(CKGA_OSC_DIV0_CFG + (x) * 4)
 
-#define CKGA_PLL0HS_DIV0_CFG	  0x900
+#define CKGA_PLL0HS_DIV0_CFG		0x900
 #define CKGA_PLL0HS_DIV_CFG(x)		(CKGA_PLL0HS_DIV0_CFG + (x) * 4)
 
-#define CKGA_PLL0LS_DIV0_CFG	  0xA00
+#define CKGA_PLL0LS_DIV0_CFG		0xA00
 #define CKGA_PLL0LS_DIV_CFG(x)		(CKGA_PLL0LS_DIV0_CFG + (x) * 4)
 
-#define CKGA_PLL1_DIV0_CFG	    0xB00
+#define CKGA_PLL1_DIV0_CFG		0xB00
 #define CKGA_PLL1_DIV_CFG(x)		(CKGA_PLL1_DIV0_CFG + (x) * 4)
 
-
-/* --- CKGB registers ( hardware specific ) --------------------------------- */
-#define CKGB_LOCK	       0x010
-#define CKGB_FS0_CTRL	   0x014
-#define CKGB_FS0_MD1	    0x018
-#define CKGB_FS0_PE1	    0x01c
-#define CKGB_FS0_EN_PRG1	0x020
-#define CKGB_FS0_SDIV1	  0x024
-#define CKGB_FS0_MD2	    0x028
-#define CKGB_FS0_PE2	    0x02c
-#define CKGB_FS0_EN_PRG2	0x030
-#define CKGB_FS0_SDIV2	  0x034
-#define CKGB_FS0_MD3	    0x038
-#define CKGB_FS0_PE3	    0x03c
-#define CKGB_FS0_EN_PRG3	0x040
-#define CKGB_FS0_SDIV3	  0x044
-#define CKGB_FS0_MD4	    0x048
-#define CKGB_FS0_PE4	    0x04c
-#define CKGB_FS0_EN_PRG4	0x050
-#define CKGB_FS0_SDIV4	  0x054
-#define CKGB_FS0_CLKOUT_CTRL    0x058
-
-#define CKGB_FS1_CTRL	   0x05c
-#define CKGB_FS1_MD1	    0x060
-#define CKGB_FS1_PE1	    0x064
-#define CKGB_FS1_EN_PRG1	0x068
-#define CKGB_FS1_SDIV1	  0x06c
-#define CKGB_FS1_MD2	    0x070
-#define CKGB_FS1_PE2	    0x074
-#define CKGB_FS1_EN_PRG2	0x078
-#define CKGB_FS1_SDIV2	  0x07c
-#define CKGB_FS1_MD3	    0x080
-#define CKGB_FS1_PE3	    0x084
-#define CKGB_FS1_EN_PRG3	0x088
-#define CKGB_FS1_SDIV3	  0x08c
-#define CKGB_FS1_MD4	    0x090
-#define CKGB_FS1_PE4	    0x094
-#define CKGB_FS1_EN_PRG4	0x098
-#define CKGB_FS1_SDIV4	  0x09c
-#define CKGB_FS1_CLKOUT_CTRL    0x0a0
+/* --- CKGB registers (hardware specific) ----------------------------------- */
+#define CKGB_LOCK		0x010
+#define CKGB_FS0_CTRL		0x014
+#define CKGB_FS1_CTRL		0x05c
+#define CKGB_FS0_CLKOUT_CTRL	0x058
+#define CKGB_FS1_CLKOUT_CTRL	0x0a0
 #define CKGB_DISPLAY_CFG	0x0a4
-#define CKGB_FS_SELECT	  0x0a8
-#define CKGB_POWER_DOWN	 0x0ac
-#define CKGB_POWER_ENABLE       0x0b0
-#define CKGB_OUT_CTRL	   0x0b4
+#define CKGB_FS_SELECT		0x0a8
+#define CKGB_POWER_DOWN		0x0ac
+#define CKGB_POWER_ENABLE    0x0b0
+#define CKGB_OUT_CTRL		0x0b4
 #define CKGB_CRISTAL_SEL	0x0b8
 
+/*
+ * both bank and channel counts from _zero_
+ */
+#define CKGB_FS_MD(_bank, _channel)		\
+	(0x18 + (_channel) * 0x10 + (_bank) * 0x48)
+
+#define CKGB_FS_PE(bk, ch)	(0x4 + CKGB_FS_MD(bk, ch))
+#define CKGB_FS_EN_PRG(bk, ch)	(0x4 + CKGB_FS_PE(bk, ch))
+#define CKGB_FS_SDIV(bk, ch)	(0x4 + CKGB_FS_EN_PRG(bk, ch))
+
 
 /* --- Audio CFG registers (0xfd601000) ------------------------------------- */
-#define CKGC_FS0_CFG	0x00000000
-#define CKGC_FS0_MD1	0x00000010
-#define CKGC_FS0_PE1	0x00000014
-#define CKGC_FS0_SDIV1      0x00000018
-#define CKGC_FS0_EN_PRG1    0x0000001c
-#define CKGC_FS0_MD2	0x00000020
-#define CKGC_FS0_PE2	0x00000024
-#define CKGC_FS0_SDIV2      0x00000028
-#define CKGC_FS0_EN_PRG2    0x0000002c
-#define CKGC_FS0_MD3	0x00000030
-#define CKGC_FS0_PE3	0x00000034
-#define CKGC_FS0_SDIV3      0x00000038
-#define CKGC_FS0_EN_PRG3    0x0000003c
-#define CKGC_FS0_MD4	0x00000040
-#define CKGC_FS0_PE4	0x00000044
-#define CKGC_FS0_SDIV4      0x00000048
-#define CKGC_FS0_EN_PRG4    0x0000004c
-
-#define CKGC_FS1_CFG	0x00000100
-#define CKGC_FS1_MD1	0x00000110
-#define CKGC_FS1_PE1	0x00000114
-#define CKGC_FS1_SDIV1      0x00000118
-#define CKGC_FS1_EN_PRG1    0x0000011c
-#define CKGC_FS1_MD2	0x00000120
-#define CKGC_FS1_PE2	0x00000124
-#define CKGC_FS1_SDIV2      0x00000128
-#define CKGC_FS1_EN_PRG2    0x0000012c
-#define CKGC_FS1_MD3	0x00000130
-#define CKGC_FS1_PE3	0x00000134
-#define CKGC_FS1_SDIV3      0x00000138
-#define CKGC_FS1_EN_PRG3    0x0000013c
-#define CKGC_FS1_MD4	0x00000140
-#define CKGC_FS1_PE4	0x00000144
-#define CKGC_FS1_SDIV4      0x00000148
-#define CKGC_FS1_EN_PRG4    0x0000014c
-
-#define AUDCFG_IOMUX_CTRL       0x00000200
-#define AUDCFG_HDMI_CTRL	0x00000204
+#define CKGC_FS0_CFG		0x00000000
+#define CKGC_FS1_CFG		0x00000100
 
-#define AUDCFG_RECOVERY_CTRL    0x00000208
+#define CKGC_FS_MD(_bank, _channel)		\
+		(0x10 + 0x100 * (_bank) + 0x10 * (_channel))
+#define CKGC_FS_PE(bk, ch)	(0x4 + CKGC_FS_MD(bk, ch))
+#define CKGC_FS_SDIV(bk, ch)	(0x8 + CKGC_FS_MD(bk, ch))
+#define CKGC_FS_EN_PRG(bk, ch)	(0xc + CKGC_FS_MD(bk, ch))
 
-#define AUDCFG_ADAC0_CTRL       0x00000400
-#define AUDCFG_ADAC1_CTRL       0x00000500
+#define AUDCFG_IOMUX_CTRL	0x00000200
+#define AUDCFG_HDMI_CTRL	0x00000204
+
+#define AUDCFG_RECOVERY_CTRL 0x00000208
 
+#define AUDCFG_ADAC0_CTRL    0x00000400
+#define AUDCFG_ADAC1_CTRL    0x00000500
 
-/* --- PIO registers (  ) ------------------------------- */
+/* --- PIO registers () ------------------------------- */
 #define	 PIO_CLEAR_PnC0		0x28
 #define	 PIO_CLEAR_PnC1		0x38
 #define	 PIO_CLEAR_PnC2		0x48
-#define	 PIO_PnC0		      0x20
-#define	 PIO_PnC1		      0x30
-#define	 PIO_PnC2		      0x40
-#define	 PIO_SET_PnC0		  0x24
-#define	 PIO_SET_PnC1		  0x34
-#define	 PIO_SET_PnC2		  0x44
-
-#endif  /* End __CLOCK_LLA_7105REGS_H */
-
+#define	 PIO_PnC0		0x20
+#define	 PIO_PnC1		0x30
+#define	 PIO_PnC2		0x40
+#define	 PIO_SET_PnC0		0x24
+#define	 PIO_SET_PnC1		0x34
+#define	 PIO_SET_PnC2		0x44
+
+#endif				/* End __CLOCK_LLA_REGS_H */
diff --git a/arch/sh/kernel/cpu/sh4/clock-stx7105.c b/arch/sh/kernel/cpu/sh4/clock-stx7105.c
index 6891b3a..73329fc 100644
--- a/arch/sh/kernel/cpu/sh4/clock-stx7105.c
+++ b/arch/sh/kernel/cpu/sh4/clock-stx7105.c
@@ -1,17 +1,22 @@
-/*******************************************************************************
+/*****************************************************************************
  *
  * File name   : clock-stx7105.c
- * Description : Low Level API - 7105 specific implementation
+ * Description : Low Level API - HW specific implementation
  *
  * COPYRIGHT (C) 2009 STMicroelectronics - All Rights Reserved
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
-
-*******************************************************************************/
+ * License V2 _ONLY_.  See linux/COPYING for more information.
+ *
+ *****************************************************************************/
 
 /* ----- Modification history (most recent first)----
+13/oct/09 fabrice.charpentier@st.com
+	  Introducing clk_pll800_get_rate() & clk_pll1600_get_rate().
+24/aug/09 fabrice.charpentier@st.com
+	  Updates + realigned on 7111.
+09/aug/09 fabrice.charpentier@st.com
+	  Updates for Linux compliancy and bug fixes.
 10/jul/09 francesco.virlinzi@st.com
-
 09/jul/09 fabrice.charpentier@st.com
 	  Revisited to make it more Linux compliant + bug fixes.
 07/may/09 Suvrat
@@ -23,7 +28,6 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/stm/clk.h>
-#include <linux/pm.h>
 #include <linux/io.h>
 #include "clock-stx7105.h"
 #include "clock-regs-stx7105.h"
@@ -38,12 +42,12 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *src_p);
 static int clkgenc_set_parent(clk_t *clk_p, clk_t *src_p);
 static int clkgend_set_parent(clk_t *clk_p, clk_t *src_p);
 static int clkgene_set_parent(clk_t *clk_p, clk_t *src_p);
-static int clkgena_set_rate(clk_t *clk_p, U32 freq);
-static int clkgenb_set_rate(clk_t *clk_p, U32 freq);
-static int clkgenc_set_rate(clk_t *clk_p, U32 freq);
-static int clkgena_set_div(clk_t *clk_p, U32 * div_p);
-static int clkgenb_set_div(clk_t *clk_p, U32 * div_p);
-static int clkgenb_set_fsclock(clk_t *clk_p, U32 freq);
+static int clkgena_set_rate(clk_t *clk_p, unsigned long freq);
+static int clkgenb_set_rate(clk_t *clk_p, unsigned long freq);
+static int clkgenc_set_rate(clk_t *clk_p, unsigned long freq);
+static int clkgena_set_div(clk_t *clk_p, unsigned long *div_p);
+static int clkgenb_set_div(clk_t *clk_p, unsigned long *div_p);
+static int clkgenb_set_fsclock(clk_t *clk_p, unsigned long freq);
 static int clkgena_recalc(clk_t *clk_p);
 static int clkgenb_recalc(clk_t *clk_p);
 static int clkgenc_recalc(clk_t *clk_p);
@@ -64,49 +68,37 @@ static int clkgend_init(clk_t *clk_p);
 static int clkgene_init(clk_t *clk_p);
 
 /* Per boards top input clocks. mb680 currently identical */
-static U32 SYSCLKIN = 30;	/* osc */
-static U32 SYSCLKALT = 30;	/* Alternate  osc */
-struct fsyn_regs {
-	unsigned long md, pe, sdiv, prog;
-};
+#define SYSCLKIN 	30	/* osc */
+#define SYSCLKALT	30	/* Alternate osc */
 
-static struct fsyn_regs clkgenb_regs[] = {
-	{CKGB_FS0_MD1, CKGB_FS0_PE1, CKGB_FS0_SDIV1, CKGB_FS0_EN_PRG1},
-	{CKGB_FS0_MD2, CKGB_FS0_PE2, CKGB_FS0_SDIV2, CKGB_FS0_EN_PRG2},
-	{CKGB_FS0_MD3, CKGB_FS0_PE3, CKGB_FS0_SDIV3, CKGB_FS0_EN_PRG3},
-	{CKGB_FS0_MD4, CKGB_FS0_PE4, CKGB_FS0_SDIV4, CKGB_FS0_EN_PRG4},
-	{CKGB_FS1_MD1, CKGB_FS1_PE1, CKGB_FS1_SDIV1, CKGB_FS1_EN_PRG1},
-	{CKGB_FS1_MD2, CKGB_FS1_PE2, CKGB_FS1_SDIV2, CKGB_FS1_EN_PRG2},
-	{CKGB_FS1_MD3, CKGB_FS1_PE3, CKGB_FS1_SDIV3, CKGB_FS1_EN_PRG3},
-	{CKGB_FS1_MD4, CKGB_FS1_PE4, CKGB_FS1_SDIV4, CKGB_FS1_EN_PRG4},
+static const unsigned long clkgena_offset_regs[] = {
+	CKGA_OSC_DIV0_CFG,
+	0, /* dummy */
+	CKGA_PLL0HS_DIV0_CFG,
+	CKGA_PLL0LS_DIV0_CFG,
+	CKGA_PLL1_DIV0_CFG
 };
 
-static struct fsyn_regs clkgenc_regs[] = {
-	{CKGC_FS0_MD1, CKGC_FS0_PE1, CKGC_FS0_SDIV1, CKGC_FS0_EN_PRG1},
-	{CKGC_FS0_MD2, CKGC_FS0_PE2, CKGC_FS0_SDIV2, CKGC_FS0_EN_PRG2},
-	{CKGC_FS0_MD3, CKGC_FS0_PE3, CKGC_FS0_SDIV3, CKGC_FS0_EN_PRG3},
-	{CKGC_FS0_MD4, CKGC_FS0_PE4, CKGC_FS0_SDIV4, CKGC_FS0_EN_PRG4}
-};
 
 /* Possible operations registration.
    Operations are usually grouped by clockgens due to specific HW
    implementation.
 
-   Name, Desc, init, set_parent, set_rate, recalc, enable, disable,
+   name, desc, init, set_parent, set_rate, recalc, enable, disable,
    observe, measure
 
    where
-     Name: MUST be the same one declared with REGISTER_CLK (ops field).
-     Desc: Clockgen group short description. Ex: "clockgen A", "USB", "LMI"
-     init: Clockgen init function (read HW to identify parent & compute rate).
-     set_parent: Parent/src setup function.
-     set_rate: Clockgen frequency setup function.
-     enable: Clockgen enable function.
-     disable: Clockgen disable function.
-     observe: Clockgen observation function.
-     recalc: Clockgen frequency recompute function. Called when parent
-	     clock changed.
-     measure: Clockgen measure function (when HW available).
+  name: MUST be the same one declared with REGISTER_CLK (ops field).
+  desc: Clock group short description. Ex: "clockgen A", "USB", "LMI"
+  init: Clock init function (read HW to identify parent & compute rate).
+  set_parent: Parent/src setup function.
+  set_rate: Clock group frequency setup function.
+  enable: Clock group enable function.
+  disable: Clock group disable function.
+  observe: Clock group observation function.
+  recalc: Clock group frequency recompute function. Called when parent
+	  clock changed.
+  measure: Clockgen measure function (when HW available).
 
    Note: If no capability, put NULL instead of function name.
    Note: All functions should return 'clk_err_t'. */
@@ -121,56 +113,56 @@ REGISTER_OPS(Top,
 	NULL,
 	NULL,
 	NULL,	/* No measure function */
-	NULL	/* No observation point */
+	NULL		/* No observation point */
 );
 REGISTER_OPS(clkgena,
-	     "clockgen A",
-	     clkgena_init,
-	     clkgena_set_parent,
-	     clkgena_set_rate,
-	     clkgena_recalc,
-	     clkgena_enable,
-	     clkgena_disable,
-	     clkgena_observe,
-	     clkgena_get_measure,
-	     "TRIGGEROUT"
+	"Clockgen A",
+	clkgena_init,
+	clkgena_set_parent,
+	clkgena_set_rate,
+	clkgena_recalc,
+	clkgena_enable,
+	clkgena_disable,
+	clkgena_observe,
+	clkgena_get_measure,
+	"TRIGGEROUT"
 );
 REGISTER_OPS(clkgenb,
-	     "clockgen B/Video",
-	     clkgenb_init,
-	     clkgenb_set_parent,
-	     clkgenb_set_rate,
-	     clkgenb_recalc,
-	     clkgenb_enable,
-	     clkgenb_disable,
-	     clkgena_observe,
-	     clkgena_get_measure,
-	     "SYSCLKOUT"
+	"Clockgen B/Video",
+	clkgenb_init,
+	clkgenb_set_parent,
+	clkgenb_set_rate,
+	clkgenb_recalc,
+	clkgenb_enable,
+	clkgenb_disable,
+	clkgenb_observe,
+	NULL,	/* No measure function */
+	"SYSCLKOUT"
 );
 REGISTER_OPS(clkgenc,
-	     "clockgen C/Audio",
-	     clkgenc_init,
-	     clkgenc_set_parent,
-	     clkgenc_set_rate,
-	     clkgenc_recalc,
-	     clkgenc_enable,
-	     clkgenc_disable,
-	     NULL,
-	     NULL,
-	     "PIO13[7]");
+	"Clockgen C/Audio",
+	clkgenc_init,
+	clkgenc_set_parent,
+	clkgenc_set_rate,
+	clkgenc_recalc,
+	clkgenc_enable,
+	clkgenc_disable,
+	NULL,
+	NULL,
+	"PIO13[7]"
+);
 REGISTER_OPS(clkgend,
-	     "clockgen D/LMI",
-	     clkgend_init,
-	     clkgend_set_parent,
-	     NULL,
-	     clkgend_recalc,
-	     NULL,
-	     NULL,
-	     NULL,
-	     NULL,
-	     "PIO6[2]"
+	"Clockgen D/LMI",
+	clkgend_init,
+	clkgend_set_parent,
+	NULL,
+	clkgend_recalc,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	"PIO6[2]"
 );
-
 REGISTER_OPS(clkgene,
 	"USB",
 	clkgene_init,
@@ -186,8 +178,7 @@ REGISTER_OPS(clkgene,
 
 /* Physical clocks description */
 clk_t clk_clocks[] = {
-	/*	    ClkID	       Ops	 Nominalfreq   Flags */
-
+	/*              ClkID          Ops     Nominalfreq   Flags */
 	/* Top level clocks */
 	REGISTER_CLK(CLK_SYS, &Top, 0,
 		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
@@ -197,16 +188,22 @@ clk_t clk_clocks[] = {
 	/* Clockgen A */
 	REGISTER_CLK(CLKA_REF, &clkgena, 0,
 		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
-	REGISTER_CLK(CLKA_PLL0HS, &clkgena, 900000000, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKA_PLL0LS, &clkgena, 450000000, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKA_PLL1, &clkgena, 800000000, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKA_OSC, &clkgena, 0, CLK_RATE_PROPAGATES),
+	REGISTER_CLK_P(CLKA_PLL0, &clkgena, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKA_REF]),
+	REGISTER_CLK_P(CLKA_PLL0HS, &clkgena, 900000000,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKA_PLL0]),
+	REGISTER_CLK_P(CLKA_PLL0LS, &clkgena, 450000000,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKA_PLL0]),
+	REGISTER_CLK_P(CLKA_PLL1, &clkgena, 800000000,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKA_REF]),
 
 	REGISTER_CLK(CLKA_IC_STNOC, &clkgena, 400000000, 0),
 	REGISTER_CLK(CLKA_FDMA0, &clkgena, 400000000, 0),
 	REGISTER_CLK(CLKA_FDMA1, &clkgena, 400000000, 0),
-	REGISTER_CLK(CLKA_ST40_ICK, &clkgena, 450000000, 0),
-	REGISTER_CLK(CLKA_IC_IF_100, &clkgena, 100000000, 0),
+	REGISTER_CLK(CLKA_ETH1_PHY, &clkgena, 50000000, 0),
+
+	REGISTER_CLK(CLKA_ST40_ICK, &clkgena, 450000000, CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLKA_IC_IF_100, &clkgena, 100000000, CLK_ALWAYS_ENABLED),
 	REGISTER_CLK(CLKA_LX_DMU_CPU, &clkgena, 450000000, 0),
 	REGISTER_CLK(CLKA_LX_AUD_CPU, &clkgena, 450000000, 0),
 	REGISTER_CLK(CLKA_IC_BDISP_200, &clkgena, 200000000, 0),
@@ -215,77 +212,109 @@ clk_t clk_clocks[] = {
 	REGISTER_CLK(CLKA_DISP_PIPE_200, &clkgena, 200000000, 0),
 	REGISTER_CLK(CLKA_BLIT_PROC, &clkgena, 266666666, 0),
 	REGISTER_CLK(CLKA_IC_DELTA_200, &clkgena, 266666666, 0),
-	REGISTER_CLK(CLKA_ETH_PHY, &clkgena, 25000000, 0),
+	REGISTER_CLK(CLKA_ETH0_PHY, &clkgena, 50000000, 0),
 	REGISTER_CLK(CLKA_PCI, &clkgena, 66666666, 0),
 	REGISTER_CLK(CLKA_EMI_MASTER, &clkgena, 100000000, 0),
 	REGISTER_CLK(CLKA_IC_COMPO_200, &clkgena, 200000000, 0),
-	REGISTER_CLK(CLKA_IC_IF_200, &clkgena, 200000000, 0),
-
+	REGISTER_CLK(CLKA_IC_IF_200, &clkgena, 200000000, CLK_ALWAYS_ENABLED),
 	/* Clockgen B */
 	REGISTER_CLK(CLKB_REF, &clkgenb, 0,
-		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
-	REGISTER_CLK(CLKB_FS0, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS0_CH1, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS0_CH2, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS0_CH3, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS0_CH4, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS1, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS1_CH1, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS1_CH2, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS1_CH3, &clkgenb, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKB_FS1_CH4, &clkgenb, 0, CLK_RATE_PROPAGATES),
-
-	REGISTER_CLK(CLKB_TMDS_HDMI, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_656_1, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_PIX_HD, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_DISP_HD, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_656, &clkgenb, 0, 0),
+		CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK_P(CLKB_FS0, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_REF]),
+	REGISTER_CLK_P(CLKB_FS1, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_REF]),
+	REGISTER_CLK_P(CLKB_FS0_CH1, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS0]),
+	REGISTER_CLK_P(CLKB_FS0_CH2, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS0]),
+	REGISTER_CLK_P(CLKB_FS0_CH3, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS0]),
+	REGISTER_CLK_P(CLKB_FS0_CH4, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS0]),
+	REGISTER_CLK_P(CLKB_FS1_CH1, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS1]),
+	REGISTER_CLK_P(CLKB_FS1_CH2, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS1]),
+	REGISTER_CLK_P(CLKB_FS1_CH3, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS1]),
+	REGISTER_CLK_P(CLKB_FS1_CH4, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS1]),
+
+	REGISTER_CLK_P(CLKB_TMDS_HDMI, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH1]),
+
+	REGISTER_CLK_P(CLKB_656_1, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH1]),
+
+	REGISTER_CLK(CLKB_PIX_HD, &clkgenb, 0, CLK_RATE_PROPAGATES),
+
+	REGISTER_CLK_P(CLKB_DISP_HD, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH1]),
+	REGISTER_CLK_P(CLKB_656_0, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH1]),
+
 	REGISTER_CLK(CLKB_GDP3, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_DISP_ID, &clkgenb, 0, CLK_RATE_PROPAGATES),
+	REGISTER_CLK_P(CLKB_DISP_ID, &clkgenb, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKB_FS1_CH1]),
 	REGISTER_CLK(CLKB_PIX_SD, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_DVP, &clkgenb, 0, 0),
 	REGISTER_CLK(CLKB_PIX_FROM_DVP, &clkgenb, 0, 0),
+	REGISTER_CLK(CLKB_DVP, &clkgenb, 0, 0),
 
-	REGISTER_CLK(CLKB_PP, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_LPC, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_DSS, &clkgenb, 0, 0),
-	REGISTER_CLK(CLKB_DAA, &clkgenb, 0, 0),
+	REGISTER_CLK_P(CLKB_DSS, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH1]),
+	REGISTER_CLK_P(CLKB_DAA, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH3]),
+	REGISTER_CLK_P(CLKB_SPARE04, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS0_CH4]),
+/*
+ * linux fixes the clk->name on the fly during the boot
+ * before the clock is registered
+ */
+	REGISTER_CLK_P(CLKB_SPARE12, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS1_CH2]),
 
-	REGISTER_CLK(CLKB_SPARE12, &clkgenb, 0, 0),
+	REGISTER_CLK_P(CLKB_PP, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS1_CH3]),
+	REGISTER_CLK_P(CLKB_LPC, &clkgenb, 0,
+		0, &clk_clocks[CLKB_FS1_CH4]),
 
 	/* Clockgen C (AUDIO) */
 	REGISTER_CLK(CLKC_REF, &clkgenc, 0,
 		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
-	REGISTER_CLK(CLKC_FS0, &clkgenc, 0, CLK_RATE_PROPAGATES),
-	REGISTER_CLK(CLKC_FS0_CH1, &clkgenc, 0, 0),
-	REGISTER_CLK(CLKC_FS0_CH2, &clkgenc, 0, 0),
-	REGISTER_CLK(CLKC_FS0_CH3, &clkgenc, 0, 0),
-	REGISTER_CLK(CLKC_FS0_CH4, &clkgenc, 0, 0),
+	REGISTER_CLK_P(CLKC_FS0, &clkgenc, 0,
+		CLK_RATE_PROPAGATES, &clk_clocks[CLKC_REF]),
+	REGISTER_CLK_P(CLKC_FS0_CH1, &clkgenc, 0,
+		0, &clk_clocks[CLKC_FS0]),
+	REGISTER_CLK_P(CLKC_FS0_CH2, &clkgenc, 0,
+		0, &clk_clocks[CLKC_FS0]),
+	REGISTER_CLK_P(CLKC_FS0_CH3, &clkgenc, 0,
+		0, &clk_clocks[CLKC_FS0]),
+	REGISTER_CLK_P(CLKC_FS0_CH4, &clkgenc, 0,
+		0, &clk_clocks[CLKC_FS0]),
 
 	/* Clockgen D (LMI) */
 	REGISTER_CLK(CLKD_REF, &clkgend, 30000000,
 		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
-	REGISTER_CLK(CLKD_LMI2X, &clkgend, 800000000, 0),
+	REGISTER_CLK_P(CLKD_LMI2X, &clkgend, 800000000,
+		0, &clk_clocks[CLKD_REF]),
+
 	/* Clockgen E (USB), not really a clockgen */
-	REGISTER_CLK(CLKE_REF, &clkgene, 30000000, CLK_ALWAYS_ENABLED)
+	REGISTER_CLK(CLKE_REF, &clkgene, 30000000, CLK_ALWAYS_ENABLED),
 
-/*
- * Not used in Linux
- *	REGISTER_CLK(CLK_LAST, NULL, 0, 0)	* Always keep this last item
- */
 };
 
-GENERIC_LINUX_CLKS(clk_clocks[CLKA_ST40_ICK],	/* sh4_clk parent    */
+GENERIC_LINUX_CLKS(clk_clocks[CLKA_ST40_ICK],	/* sh4_clk parent */
 		   clk_clocks[CLKA_IC_IF_100],	/* module_clk parent */
 		   clk_clocks[CLKA_IC_IF_100]);	/* comms_clk parent  */
 
-SYSCONF(1, 1, 0, 1);
-SYSCONF(2, 6, 0, 0);
-SYSCONF(2, 11, 1, 8);
-SYSCONF(2, 11, 9, 11);
-SYSCONF(2, 40, 0, 1);
-SYSCONF(2, 40, 2, 3);
-
+SYSCONF(SYS_STA, 1, 0, 1);
+SYSCONF(SYS_CFG, 6, 0, 0);
+SYSCONF(SYS_CFG, 11, 1, 8);
+SYSCONF(SYS_CFG, 11, 9, 11);
+SYSCONF(SYS_CFG, 24, 4, 4);
+SYSCONF(SYS_CFG, 40, 0, 1);
+SYSCONF(SYS_CFG, 40, 2, 3);
 /*
  * The Linux clk_init function
  */
@@ -293,15 +322,22 @@ int __init clk_init(void)
 {
 	int i;
 
-	SYSCONF_CLAIM(1, 1, 0, 1);
-	SYSCONF_CLAIM(2, 6, 0, 0);
-	SYSCONF_CLAIM(2, 11, 1, 8);
-	SYSCONF_CLAIM(2, 11, 9, 11);
-	SYSCONF_CLAIM(2, 40, 0, 1);
-	SYSCONF_CLAIM(2, 40, 2, 3);
+	SYSCONF_CLAIM(SYS_STA, 1, 0, 1);
+	SYSCONF_CLAIM(SYS_CFG, 6, 0, 0);
+	SYSCONF_CLAIM(SYS_CFG, 11, 1, 8);
+	SYSCONF_CLAIM(SYS_CFG, 11, 9, 11);
+	SYSCONF_CLAIM(SYS_CFG, 24, 4, 4);
+	SYSCONF_CLAIM(SYS_CFG, 40, 0, 1);
+	SYSCONF_CLAIM(SYS_CFG, 40, 2, 3);
+
+/*
+ *	manage 7105 vs 7106 configuration
+ */
+	if (cpu_data->type != CPU_STX7105)
+		strcpy(clk_clocks[CLKB_SPARE12].name, "CLKB_MMC");
 
 	for (i = 0; i < ARRAY_SIZE(clk_clocks); ++i)
-		if (clk_clocks[i].name && !clk_register(&clk_clocks[i]))
+		if (!clk_register(&clk_clocks[i]))
 			clk_enable(&clk_clocks[i]);
 
 	REGISTER_GENERIC_LINUX_CLKS();
@@ -309,13 +345,6 @@ int __init clk_init(void)
 	return 0;
 }
 
-static U32 clkgena_offset_regs[] = {
-	CKGA_OSC_DIV0_CFG,
-	CKGA_PLL0HS_DIV0_CFG,
-	CKGA_PLL0LS_DIV0_CFG,
-	CKGA_PLL1_DIV0_CFG
-};
-
 /******************************************************************************
 Top level clocks group
 ******************************************************************************/
@@ -323,15 +352,13 @@ Top level clocks group
 /* ========================================================================
    Name:	clkgentop_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgentop_init(clk_t *clk_p)
 {
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
-
-	clk_p->parent = NULL;
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Top recalc function */
 	switch (clk_p->id) {
@@ -341,12 +368,9 @@ static int clkgentop_init(clk_t *clk_p)
 	case CLK_SYSALT:
 		clk_p->rate = SYSCLKALT * 1000000;
 		break;
-	default:
-		clk_p->rate = 0;
-		break;
 	}
 
-	return (CLK_ERR_NONE);
+	return 0;
 }
 
 /******************************************************************************
@@ -354,16 +378,16 @@ CLOCKGEN A (CPU+interco+comms) clocks group
 ******************************************************************************/
 
 /* ========================================================================
-Name:	clkgena_get_index
+Name:	  clkgena_get_index
 Description: Returns index of given clockgenA clock and source reg infos
-Returns:     idx==-1 if error, else >=0
+Returns:  idx==-1 if error, else >=0
 ======================================================================== */
 
-static int clkgena_get_index(clk_id_t clkid, U32 *srcreg, int *shift)
+static int clkgena_get_index(int clkid, unsigned long *srcreg, int *shift)
 {
 	int idx;
 
-	/* Warning: This functions assumes clock IDs are perfectly
+	/* Warning: This function assumes clock IDs are perfectly
 	   following real implementation order. Each "hole" has therefore
 	   to be filled with "CLKx_NOT_USED" */
 	if (clkid < CLKA_IC_STNOC || clkid > CLKA_IC_IF_200)
@@ -383,27 +407,29 @@ static int clkgena_get_index(clk_id_t clkid, U32 *srcreg, int *shift)
 		*shift = (idx - 16) * 2;
 	}
 
-	return (idx);
+	return idx;
 }
 
 /* ========================================================================
    Name:	clkgena_set_parent
    Description: Set clock source for clockgenA when possible
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgena_set_parent(clk_t *clk_p, clk_t *src_p)
 {
-	U32 clk_src, val;
-	int idx;
-	U32 srcreg;
-	int shift;
+	unsigned long clk_src, val;
+	int idx, shift;
+	unsigned long srcreg;
 
 	if (!clk_p || !src_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id < CLKA_IC_STNOC)
+		return CLK_ERR_BAD_PARAMETER;
 
 	switch (src_p->id) {
-	case CLKA_OSC:
+	case CLKA_REF:
 		clk_src = 0;
 		break;
 	case CLKA_PLL0LS:
@@ -414,73 +440,71 @@ static int clkgena_set_parent(clk_t *clk_p, clk_t *src_p)
 		clk_src = 2;
 		break;
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
 	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
 	if (idx == -1)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	val = CLK_READ(CKGA_BASE_ADDRESS + srcreg) & ~(0x3 << shift);
 	val = val | (clk_src << shift);
 	CLK_WRITE(CKGA_BASE_ADDRESS + srcreg, val);
 
 	clk_p->parent = &clk_clocks[src_p->id];
-	clkgena_recalc(clk_p);
 
-	return (0);
+	return clkgena_recalc(clk_p);
 }
 
 /* ========================================================================
    Name:	clkgena_identify_parent
    Description: Identify parent clock for clockgen A clocks.
-   Returns:     Pointer on parent 'clk_t' structure.
+   Returns:  Pointer on parent 'clk_t' structure.
    ======================================================================== */
 
 static int clkgena_identify_parent(clk_t *clk_p)
 {
 	int idx;
-	U32 src_sel;
-	U32 srcreg;
+	unsigned long src_sel;
+	unsigned long srcreg;
 	int shift;
 
-	clk_p->parent = NULL;
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
-	switch (clk_p->id) {
-	case CLKA_REF:
-		src_sel = SYSCONF_READ(1, 1, 0, 1);
+	if (clk_p->id == CLKA_REF) {
+		src_sel = SYSCONF_READ(SYS_STA, 1, 0, 1);
 		switch (src_sel) {
 		case 0:
-			clk_p->parent = &clk_clocks[CLK_SYS];	/* OSC FE */
+			clk_p->parent = &clk_clocks[CLK_SYS];
 			break;
 		case 1:
-			clk_p->parent = &clk_clocks[CLK_SYSALT]; /* OSC USB */
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
 			break;
 		default:
 			break;
 		}
-		return (0);
-
-	case CLKA_PLL0LS:/* PLLs of clockgen A all sourced from CLKA_REF */
-	case CLKA_PLL0HS:
-	case CLKA_PLL1:
-		clk_p->parent = &clk_clocks[CLKA_REF];
-		return (0);
+		clk_p->rate = clk_p->parent->rate;
+		return 0;
 	}
 
+	if (clk_p->id < CLKA_IC_STNOC)
+		/* statically initialized */
+		return 0;
+
 	/* Which divider to setup ? */
 	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
 	if (idx == -1)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Identifying source */
 	src_sel = (CLK_READ(CKGA_BASE_ADDRESS + srcreg) >> shift) & 0x3;
 	switch (src_sel) {
 	case 0:
-		clk_p->parent = &clk_clocks[CLKA_OSC];
+		clk_p->parent = &clk_clocks[CLKA_REF];
 		break;
 	case 1:
-		if (idx <= 3)
+		if (clk_p->id < CLKA_ST40_ICK)
 			clk_p->parent = &clk_clocks[CLKA_PLL0HS];
 		else
 			clk_p->parent = &clk_clocks[CLKA_PLL0LS];
@@ -494,55 +518,104 @@ static int clkgena_identify_parent(clk_t *clk_p)
 		break;
 	}
 
-	return (0);
+	return 0;
+}
+
+/* ========================================================================
+   Name:	clkgena_xable_pll
+   Description: Enable/disable PLL
+   Returns:  'clk_err_t' error code
+   ======================================================================== */
+
+static int clkgena_xable_pll(clk_t *clk_p, int enable)
+{
+	unsigned long val;
+	int bit, data;
+
+	bit = (clk_p->id == CLKA_PLL0 ? 0 : 1);
+
+	val = CLK_READ(CKGA_BASE_ADDRESS + CKGA_POWER_CFG);
+	if (enable) {
+		val &= ~(1 << bit);
+		CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_POWER_CFG, val);
+		if (clk_p->id == CLKA_PLL0) {
+			clk_p->rate = clk_p->parent->rate;
+			return 0;
+		}
+		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL1_CFG);
+		clk_p->rate = clk_pll800_freq(clk_p->parent->rate, data);
+	} else {
+		val |= (1 << bit);
+		clk_p->rate = 0;
+		CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_POWER_CFG, val);
+	}
+
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgena_enable
-   Description: enable clock
-   Returns:     'clk_err_t' error code
+   Description: Enable clock
+   Returns:  'clk_err_t' error code
    ======================================================================== */
 
 static int clkgena_enable(clk_t *clk_p)
 {
-	int ret;
+	int err;
+	int data;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
+
 	if (!clk_p->parent)
-		/* Unsupported. Need to use set_parent() first. */
-		return (CLK_ERR_BAD_PARAMETER);
+		/* Unsupported. Init must be called first. */
+		return CLK_ERR_BAD_PARAMETER;
 
-	ret = clkgena_set_parent(clk_p, clk_p->parent);
-	/* set_parent() is performing also a recalc() */
+	/* PLL power up */
+	if (clk_p->id == CLKA_PLL0 || clk_p->id == CLKA_PLL1)
+		return clkgena_xable_pll(clk_p, 1);
 
-	return ret;
+	if (clk_p->id == CLKA_PLL0HS || clk_p->id == CLKA_PLL0LS) {
+		if (!clk_p->parent->rate)
+			return -1;
+		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL0_CFG);
+		clk_p->rate = clk_pll1600_freq(clk_p->parent->rate, data);
+		if (clk_p->id == CLKA_PLL0LS)
+			clk_p->rate /= 2;
+		return 0;
+	}
+	err = clkgena_set_parent(clk_p, clk_p->parent);
+	/* clkgena_set_parent() is performing also a recalc() */
+
+	return err;
 }
 
 /* ========================================================================
    Name:	clkgena_disable
-   Description: disable clock
-   Returns:     'clk_err_t' error code
+   Description: Disable clock
+   Returns:  'clk_err_t' error code
    ======================================================================== */
 
 static int clkgena_disable(clk_t *clk_p)
 {
-	U32 val;
+	unsigned long val;
 	int idx;
-	U32 srcreg;
+	unsigned long srcreg;
 	int shift;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
-	/* IC_IF_100, IC_IF_200, and CPU cannot be disabled */
-	if ((clk_p->id == CLKA_IC_IF_100) || (clk_p->id == CLKA_IC_IF_200)
-	    || (clk_p->id == CLKA_ST40_ICK))
-		return (0);
+	/* PLL power down */
+	if (clk_p->id == CLKA_PLL0 || clk_p->id == CLKA_PLL1)
+		return clkgena_xable_pll(clk_p, 0);
+
+	if (clk_p->id == CLKA_PLL0HS || clk_p->id == CLKA_PLL0LS)
+		return CLK_ERR_BAD_PARAMETER;
 
 	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
 	if (idx == -1)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Disabling clock */
 	val = CLK_READ(CKGA_BASE_ADDRESS + srcreg) & ~(0x3 << shift);
@@ -550,7 +623,7 @@ static int clkgena_disable(clk_t *clk_p)
 	CLK_WRITE(CKGA_BASE_ADDRESS + srcreg, val);
 	clk_p->rate = 0;
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
@@ -558,32 +631,29 @@ static int clkgena_disable(clk_t *clk_p)
    Description: Set divider ratio for clockgenA when possible
    ======================================================================== */
 
-static int clkgena_set_div(clk_t *clk_p, U32 *div_p)
+static int clkgena_set_div(clk_t *clk_p, unsigned long *div_p)
 {
 	int idx;
-	U32 div_cfg = 0;
-	U32 srcreg, offset;
+	unsigned long div_cfg = 0;
+	unsigned long srcreg, offset;
 	int shift;
 
 	if (!clk_p || !clk_p->parent)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Computing divider config */
-	if (*div_p == 1)
-		div_cfg = 0x00;
-	else
-		div_cfg = (*div_p - 1) & 0x1F;
+	div_cfg = (*div_p - 1) & 0x1F;
 
 	/* Which divider to setup ? */
 	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
 	if (idx == -1)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Now according to parent, let's write divider ratio */
-	offset = clkgena_offset_regs[clk_p->parent->id - CLKA_OSC];
+	offset = clkgena_offset_regs[clk_p->parent->id - CLKA_REF];
 	CLK_WRITE(CKGA_BASE_ADDRESS + offset + (4 * idx), div_cfg);
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
@@ -591,54 +661,50 @@ static int clkgena_set_div(clk_t *clk_p, U32 *div_p)
    Description: Set clock frequency
    ======================================================================== */
 
-static int clkgena_set_rate(clk_t *clk_p, U32 freq)
+static int clkgena_set_rate(clk_t *clk_p, unsigned long freq)
 {
-	U32 div;
+	unsigned long div;
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
-	if ((clk_p->id < CLKA_PLL0HS) || (clk_p->id > CLKA_IC_IF_200)
-	    || (clk_p->id == CLKA_NOT_USED3))
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
+
+	/* PLL set rate: to be completed */
+	if (clk_p->id == CLKA_PLL0 || clk_p->id == CLKA_PLL1)
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* We need a parent for these clocks */
 	if (!clk_p->parent)
-		return (CLK_ERR_INTERNAL);
+		return CLK_ERR_INTERNAL;
 
 	div = clk_p->parent->rate / freq;
 	err = clkgena_set_div(clk_p, &div);
 	if (err == 0)
 		clk_p->rate = clk_p->parent->rate / div;
 
-	return (0);
+	return err;
 }
 
 /* ========================================================================
    Name:	clkgena_recalc
    Description: Get CKGA programmed clocks frequencies
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgena_recalc(clk_t *clk_p)
 {
-	U32 data, ratio;
+	unsigned long data, ratio;
 	int idx;
-	U32 srcreg, offset;
+	unsigned long srcreg, offset;
 	int shift;
 
-	if (clk_p == NULL)
-		return (CLK_ERR_BAD_PARAMETER);
-	if (clk_p->parent == NULL)
-		return (CLK_ERR_INTERNAL);
-
-	/* Cleaning structure first */
-	clk_p->rate = 0;
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Reading clock programmed value */
-
 	switch (clk_p->id) {
 	case CLKA_REF:		/* Clockgen A reference clock */
+	case CLKA_PLL0:	/* Not a clock but a PLL id. Therefore out=in */
 		clk_p->rate = clk_p->parent->rate;
 		break;
 
@@ -647,9 +713,8 @@ static int clkgena_recalc(clk_t *clk_p)
 		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL0_CFG);
 		clk_p->rate = clk_pll1600_freq(clk_p->parent->rate, data);
 		if (clk_p->id == CLKA_PLL0LS)
-			clk_p->rate = clk_p->rate / 2;
+			clk_p->rate /= 2;
 		break;
-
 	case CLKA_PLL1:
 		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL1_CFG);
 		clk_p->rate = clk_pll800_freq(clk_p->parent->rate, data);
@@ -658,43 +723,41 @@ static int clkgena_recalc(clk_t *clk_p)
 	default:
 		idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
 		if (idx == -1)
-			return (CLK_ERR_BAD_PARAMETER);
+			return CLK_ERR_BAD_PARAMETER;
 
 		/* Now according to source, let's get divider ratio */
-		offset = clkgena_offset_regs[clk_p->parent->id - CLKA_OSC];
+		offset = clkgena_offset_regs[clk_p->parent->id - CLKA_REF];
 		data = CLK_READ(CKGA_BASE_ADDRESS + offset + (4 * idx));
 
-		if ((data & 0x1F) == 0)	/* div by 1 ? */
-			ratio = 1;
-		else
-			ratio = (data & 0x1F) + 1;
+		ratio = (data & 0x1F) + 1;
 
 		clk_p->rate = clk_p->parent->rate / ratio;
 		break;
 	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgena_observe
    Description: allows to observe a clock on a SYSACLK_OUT
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgena_observe(clk_t *clk_p, unsigned long *div_p)
 {
-	U32 src = 0;
-	U32 divcfg;
+	unsigned long src = 0;
+	unsigned long divcfg;
 	/* WARNING: the obs_table[] must strictly follows clockgen enum order
-	   taking into account any "holes" (CLKA_NOT_USED) filled with -1 */
-	U32 obs_table[] =
-	    { 0x8, 0x9, 0xa, 0xffffffff, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11,
+	 * taking into account any "holes" (CLKA_NOTUSED) filled with
+	 * 0xffffffff */
+	static const unsigned long obs_table[] = {
+		0x8, 0x9, 0xa, 0xffffffff, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11,
 		0x12, 0x13, 0x14, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
 	};
 
 	if (!clk_p || !div_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	if (clk_p->id < CLKA_IC_STNOC || clk_p->id > CLKA_IC_IF_200)
 		return CLK_ERR_BAD_PARAMETER;
 
@@ -721,24 +784,23 @@ static int clkgena_observe(clk_t *clk_p, unsigned long *div_p)
 /* ========================================================================
    Name:	clkgena_get_measure
    Description: Use internal HW feature (when avail.) to measure clock
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static unsigned long clkgena_get_measure(clk_t *clk_p)
 {
-	U32 src, data;
-	U32 measure;
+	unsigned long src, data;
+	unsigned long measure;
 	/* WARNING: the measure_table[] must strictly follows clockgen enum
 	 * order taking into account any "holes" (CLKA_NOT_USED) filled with
-	 * -1
-	 */
-	U32 measure_table[] =
-	    { 0x8, 0x9, 0xa, 0xffffffff, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11,
+	 * 0xffffffff */
+	static const unsigned long measure_table[] = {
+		0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11,
 		0x12, 0x13, 0x14, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
 	};
 
 	if (!clk_p)
-		return (0);
+		return 0;
 	if (clk_p->id < CLKA_IC_STNOC || clk_p->id > CLKA_IC_IF_200)
 		return 0;
 
@@ -746,7 +808,6 @@ static unsigned long clkgena_get_measure(clk_t *clk_p)
 	measure = 0;
 
 	/* Loading the MAX Count 1000 in 30MHz Oscillator Counter */
-	/* poke #FE213034 #3E8     */
 	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_MASTER_MAXCOUNT, 0x3E8);
 	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_CMD, 3);
 
@@ -758,7 +819,6 @@ static unsigned long clkgena_get_measure(clk_t *clk_p)
 
 	while (1) {
 		mdelay(10);
-
 		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_CLKOBS_STATUS);
 		if (data & 1)
 			break;	/* IT */
@@ -768,27 +828,30 @@ static unsigned long clkgena_get_measure(clk_t *clk_p)
 	data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_CLKOBS_SLAVE0_COUNT);
 	measure = 30 * data * 1000;
 
-	/* poke #FE213038 #3 */
 	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_CMD, 3);
 
-	return (measure);
+	return measure;
 }
 
 /* ========================================================================
    Name:	clkgena_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgena_init(clk_t *clk_p)
 {
-	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+	int err = 0;
 
-	clkgena_identify_parent(clk_p);
-	clkgena_recalc(clk_p);
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
-	return (0);
+	err = clkgena_identify_parent(clk_p);
+/*
+	if (!err)
+		err = clkgena_recalc(clk_p);
+*/
+	return err;
 }
 
 /******************************************************************************
@@ -806,17 +869,17 @@ static void clkgenb_lock(void)
 }
 
 /* ========================================================================
-   Name:	clkgenb_enable_fsyn
+   Name:	clkgenb_xable_fsyn
    Description: enable/disable FSYN
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
-static int clkgenb_enable_fsyn(clk_t *clk_p, U32 enable)
+static int clkgenb_xable_fsyn(clk_t *clk_p, unsigned long enable)
 {
-	U32 val, clkout, ctrl;
+	unsigned long val, clkout, ctrl;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	if (clk_p->id == CLKB_FS0) {
 		clkout = CKGB_FS0_CLKOUT_CTRL;
 		ctrl = CKGB_FS0_CTRL;
@@ -824,130 +887,133 @@ static int clkgenb_enable_fsyn(clk_t *clk_p, U32 enable)
 		clkout = CKGB_FS1_CLKOUT_CTRL;
 		ctrl = CKGB_FS1_CTRL;
 	} else
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	clkgenb_unlock();
 
 	/* Powering down/up digital part */
 	val = CLK_READ(CKGB_BASE_ADDRESS + clkout);
-	if (enable) {
-		CLK_WRITE(CKGB_BASE_ADDRESS + clkout, val | 0xF);
-	} else {
-		CLK_WRITE(CKGB_BASE_ADDRESS + clkout, val & ~0xF);
-	}
+	if (enable)
+		val |= 0xF;
+	else
+		val &= ~0xF;
+	CLK_WRITE(CKGB_BASE_ADDRESS + clkout, val);
 
 	/* Powering down/up analog part */
 	val = CLK_READ(CKGB_BASE_ADDRESS + ctrl);
 	if (enable) {
-		CLK_WRITE(CKGB_BASE_ADDRESS + ctrl, val | (1 << 4));
+		val |= (1 << 4);
 		clk_p->rate = clk_p->parent->rate;
 	} else {
-		CLK_WRITE(CKGB_BASE_ADDRESS + ctrl, val & ~(1 << 4));
+		val &= ~(1 << 4);
 		clk_p->rate = 0;
 	}
 
+	CLK_WRITE(CKGB_BASE_ADDRESS + ctrl, val);
 	clkgenb_lock();
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
-   Name:	clkgenb_enable_clock
-   Description: enable/disable clock (Clockgen B)
-   Returns:     0=NO error
+   Name:	clkgenb_xable_clock
+   Description: Enable/disable clock (Clockgen B)
+   Returns:  0=NO error
    ======================================================================== */
+
 struct gen_utility {
-	U32 clk_id;
-	U32 info;
+	unsigned long clk_id;
+	unsigned long info;
 };
 
-static int clkgenb_enable_clock(clk_t *clk_p, U32 enable)
+static int clkgenb_xable_clock(clk_t *clk_p, unsigned long enable)
 {
-	U32 bit, power;
-	U32 i;
-	static struct gen_utility enable_clock[] = {
+	unsigned long bit, power;
+	unsigned long i;
+	static const struct gen_utility enable_clock[] = {
 		{CLKB_DAA, 0}, {CLKB_DSS, 1},
 		{CLKB_PIX_HD, 3}, {CLKB_DISP_HD, 4}, {CLKB_TMDS_HDMI, 5},
-		{CLKB_656, 6}, {CLKB_GDP3, 7},
+		{CLKB_656_0, 6}, {CLKB_GDP3, 7},
 		{CLKB_DISP_ID, 8}, {CLKB_PIX_SD, 9},
 		{CLKB_656_1, 10}, {CLKB_PP, 12},
 		{CLKB_LPC, 13},
 	};
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
-	for (i = 0; i < 12; ++i)
+		return CLK_ERR_BAD_PARAMETER;
+
+	for (i = 0; i < ARRAY_SIZE(enable_clock); ++i)
 		if (enable_clock[i].clk_id == clk_p->id)
 			break;
-	if (i == 12)
-		return (CLK_ERR_BAD_PARAMETER);
+	if (i == ARRAY_SIZE(enable_clock))
+		return CLK_ERR_BAD_PARAMETER;
 	bit = enable_clock[i].info;
 
 	power = CLK_READ(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE);
 	clkgenb_unlock();
 	if (enable) {
-		CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE,
-			  power | (1 << bit));
+		power |= (1 << bit);
 		clkgenb_recalc(clk_p);
 	} else {
-		CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE,
-			  power & ~(1 << bit));
+		power &= ~(1 << bit);
 		clk_p->rate = 0;
 	}
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE, power);
 	clkgenb_lock();
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_enable
    Description: enable clock or FSYN (clockgen B)
-   Returns:     O=NO error
+   Returns:  O=NO error
    ======================================================================== */
 
 static int clkgenb_enable(clk_t *clk_p)
 {
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
-	if ((clk_p->id == CLKB_FS0) || (clk_p->id == CLKB_FS1))
-		return (clkgenb_enable_fsyn(clk_p, 1));
+	if (clk_p->id == CLKB_FS0 || clk_p->id == CLKB_FS1)
+		return clkgenb_xable_fsyn(clk_p, 1);
 
-	return (clkgenb_enable_clock(clk_p, 1));
+	return clkgenb_xable_clock(clk_p, 1);
 }
 
 /* ========================================================================
    Name:	clkgenb_disable
-   Description: disable clock
-   Returns:     O=NO error
+   Description: Disable clock
+   Returns:  O=NO error
    ======================================================================== */
 
 static int clkgenb_disable(clk_t *clk_p)
 {
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
-	if ((clk_p->id == CLKB_FS0) || (clk_p->id == CLKB_FS1))
-		return (clkgenb_enable_fsyn(clk_p, 0));
+	if (clk_p->id == CLKB_FS0 || clk_p->id == CLKB_FS1)
+		return clkgenb_xable_fsyn(clk_p, 0);
 
-	return (clkgenb_enable_clock(clk_p, 0));
+	return clkgenb_xable_clock(clk_p, 0);
 }
 
 /* ========================================================================
    Name:	clkgenb_set_parent
    Description: Set clock source for clockgenB when possible
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	U32 set = 0;		/* Each bit set to 1 will be SETTED */
-	U32 reset = 0;		/* Each bit set to 1 will be RESETTED */
-	U32 reg;		/* Register address */
-	U32 val;
+	unsigned long set = 0;	/* Each bit set to 1 will be SETTED */
+	unsigned long reset = 0;	/* Each bit set to 1 will be RESETTED */
+	unsigned long reg;	/* Register address */
+	unsigned long val;
 
 	if (!clk_p || !parent_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
+	reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 	switch (clk_p->id) {
 	case CLKB_REF:
 		switch (parent_p->id) {
@@ -967,7 +1033,6 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 			reset = 1 << 0;
 		else
 			set = 1 << 0;
-		reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 		break;
 
 	case CLKB_PIX_SD:
@@ -975,7 +1040,6 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 			reset = 1 << 1;
 		else
 			set = 1 << 1;
-		reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 		break;
 
 	case CLKB_DVP:
@@ -986,7 +1050,6 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 			set = 0x3 << 2;
 		} else
 			reset = 1 << 3;
-		reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 		break;
 
 	case CLKB_PIP:
@@ -996,14 +1059,14 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 		else if (parent_p->id == CLKB_DISP_HD)
 			val = 1;
 		else
-			return (CLK_ERR_BAD_PARAMETER);
-		SYSCONF_WRITE(2, 6, 0, 0, val);
+			return CLK_ERR_BAD_PARAMETER;
+		SYSCONF_WRITE(SYS_CFG, 6, 0, 0, val);
 		clk_p->parent = parent_p;
 		/* Special case since config done thru sys_conf register */
-		return (0);
+		return 0;
 
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
 	clkgenb_unlock();
@@ -1013,9 +1076,7 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
 	CLK_WRITE(reg, val);
 	clkgenb_lock();
 	clk_p->parent = parent_p;
-	clkgenb_recalc(clk_p);
-
-	return (0);
+	return clkgenb_recalc(clk_p);
 }
 
 /* ========================================================================
@@ -1023,90 +1084,84 @@ static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
    Description: Set clock frequency
    ======================================================================== */
 
-static int clkgenb_set_rate(clk_t *clk_p, U32 freq)
+static int clkgenb_set_rate(clk_t *clk_p, unsigned long freq)
 {
-	U32 div;
+	unsigned long div;
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
-	switch (clk_p->id) {
-	case CLKB_FS0_CH1:
-	case CLKB_FS0_CH2:
-	case CLKB_FS0_CH3:
-	case CLKB_FS0_CH4:
-	case CLKB_FS1_CH1:
-	case CLKB_FS1_CH2:
-	case CLKB_FS1_CH3:
-	case CLKB_FS1_CH4:
+	if ((clk_p->id >= CLKB_FS0_CH1) && (clk_p->id <= CLKB_FS1_CH4))
 		/* clkgenb_set_fsclock() is updating clk_p->rate */
-		return (clkgenb_set_fsclock(clk_p, freq));
-	default:
-		break;
-	}
+		return clkgenb_set_fsclock(clk_p, freq);
 
 	if (!clk_p->parent) {
 		/* A parent is expected to these clocks */
-		return (CLK_ERR_INTERNAL);
+		return CLK_ERR_INTERNAL;
 	}
 	div = clk_p->parent->rate / freq;
 	err = clkgenb_set_div(clk_p, &div);
 	if (err == 0)
 		clk_p->rate = freq;
 
-	return (err);
+	return err;
 }
 
 /* ========================================================================
    Name:	clkgenb_set_fsclock
    Description: Set FS clock
-   Returns:     0=NO error
+   Returns:  'clk_err_t' error code
    ======================================================================== */
 
-static int clkgenb_set_fsclock(clk_t *clk_p, U32 freq)
+static int clkgenb_set_fsclock(clk_t *clk_p, unsigned long freq)
 {
 	int md, pe, sdiv;
-	struct fsyn_regs *regs;
+	int bank, channel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
+
 	if (!clk_p->parent)
-		return (CLK_ERR_INTERNAL);
+		return CLK_ERR_INTERNAL;
+
+	if (clk_p->id < CLKB_FS0_CH1 || clk_p->id > CLKB_FS1_CH4)
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Computing FSyn params. Should be common function with FSyn type */
-	if ((clk_fsyn_get_params(clk_p->parent->rate, freq, &md, &pe, &sdiv))
-	    != 0)
+	if ((clk_fsyn_get_params(clk_p->parent->rate, freq, &md, &pe, &sdiv)) !=
+	    0)
 		return CLK_ERR_BAD_PARAMETER;
 
-	regs = &clkgenb_regs[clk_p->id - CLKB_FS0_CH1];
+	bank = (clk_p->id - CLKB_FS0_CH1) / 4;
+	channel = (clk_p->id - CLKB_FS0_CH1) % 4;
 
 	clkgenb_unlock();
-	CLK_WRITE(CKGB_BASE_ADDRESS + regs->md, md);
-	CLK_WRITE(CKGB_BASE_ADDRESS + regs->pe, pe);
-	CLK_WRITE(CKGB_BASE_ADDRESS + regs->sdiv, sdiv);
-	CLK_WRITE(CKGB_BASE_ADDRESS + regs->prog, 0x1);
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_FS_MD(bank, channel), md);
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_FS_PE(bank, channel), pe);
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_FS_SDIV(bank, channel), sdiv);
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_FS_EN_PRG(bank, channel), 0x1);
 	clkgenb_lock();
 	clk_p->rate = freq;
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_set_div
    Description: Set divider ratio for clockgenB when possible
-   Returns:     0=NO error
+   Returns:  'clk_err_t' error code
    ======================================================================== */
 
-static int clkgenb_set_div(clk_t *clk_p, U32 *div_p)
+static int clkgenb_set_div(clk_t *clk_p, unsigned long *div_p)
 {
-	U32 set = 0;		/* Each bit set to 1 will be SETTED */
-	U32 reset = 0;		/* Each bit set to 1 will be RESETTED */
-	U32 reg;
-	U32 val;
+	unsigned long set = 0;	/* Each bit set to 1 will be SETTED */
+	unsigned long reset = 0;	/* Each bit set to 1 will be RESETTED */
+	unsigned long reg;
+	unsigned long val;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	reg = CKGB_DISPLAY_CFG;
 	switch (clk_p->id) {
@@ -1166,7 +1221,7 @@ static int clkgenb_set_div(clk_t *clk_p, U32 *div_p)
 			break;
 		}
 		break;
-	case CLKB_656:
+	case CLKB_656_0:
 		switch (*div_p) {
 		case 2:
 			reset = 0x3 << 6;
@@ -1235,7 +1290,7 @@ static int clkgenb_set_div(clk_t *clk_p, U32 *div_p)
 		}
 		break;
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
 	val = CLK_READ(CKGB_BASE_ADDRESS + reg);
@@ -1245,46 +1300,53 @@ static int clkgenb_set_div(clk_t *clk_p, U32 *div_p)
 	CLK_WRITE(CKGB_BASE_ADDRESS + reg, val);
 	clkgenb_lock();
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_observe
    Description: Allows to observe a clock on a PIO5_2
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgenb_observe(clk_t *clk_p, unsigned long *div_p)
 {
-	U32 i, out0, out1 = 0;
+	unsigned long i, out0, out1 = 0;
 
-	static struct gen_utility observe_table[] = {
-		{CLKB_TMDS_HDMI, 1}, {CLKB_656, 2},
+	static const struct gen_utility observe_table[] = {
+		{CLKB_TMDS_HDMI, 1}, {CLKB_656_1, 15},
 		{CLKB_PIX_HD, 3}, {CLKB_DISP_HD, 4},
-		{CLKB_656, 5}, {CLKB_GDP3, 6},
+		{CLKB_656_0, 5}, {CLKB_GDP3, 6},
 		{CLKB_DISP_ID, 7}, {CLKB_PIX_SD, 8},
-		{CLKB_DSS, 9}, {CLKB_DAA, 10},
-		{CLKB_SPARE12, 11}, {CLKB_LPC, 13},
-		{CLKB_DVP, 14}, {CLKB_PP, 22}
+		{CLKB_DVP, 14}, {CLKB_DSS, 9},
+		{CLKB_DAA, 10}, {CLKB_LPC, 13},
+		/* Clocks available thru mux 1 */
+		{CLKB_PP, 11}, {CLKB_MMC, 14}
 	};
 
 	if (!clk_p)
 		return CLK_ERR_BAD_PARAMETER;
 
-	if (clk_p->id == CLKB_PP)
-		out1 = 11;
-
-	for (i = 0; i < 14; ++i)
+	for (i = 0; i < ARRAY_SIZE(observe_table); ++i)
 		if (observe_table[i].clk_id == clk_p->id)
 			break;
-	if (i == 14)
-		return CLK_ERR_BAD_PARAMETER;
-	out0 = observe_table[i].info;
+	if (i == ARRAY_SIZE(observe_table))
+		return CLK_ERR_BAD_PARAMETER;	/* Not found */
+
+	if (clk_p->id == CLKB_PP || clk_p->id == CLKB_MMC) {
+		out1 = observe_table[i].info;
+		out0 = 12;
+	} else
+		out0 = observe_table[i].info;
 
+	/* Selecting clock for observation */
 	clkgenb_unlock();
 	CLK_WRITE((CKGB_BASE_ADDRESS + CKGB_OUT_CTRL), (out1 << 4) | out0);
 	clkgenb_lock();
 
+	/* Enabling SYSCLOCKOUT */
+	SYSCONF_WRITE(SYS_CFG, 24, 4, 4, 1);
+
 	/* No possible predivider on clockgen B */
 	*div_p = 1;
 
@@ -1293,66 +1355,47 @@ static int clkgenb_observe(clk_t *clk_p, unsigned long *div_p)
 
 /* ========================================================================
    Name:	clkgenb_fsyn_recalc
-   Description: Check FSYN to see if channel is active or disabled/standbye
-		If enabled, the clk_p->rate value is updated accordingly.
-   Returns:     Error code.
+   Description: Check FSYN & channels status... active, disabled, standbye
+		'clk_p->rate' is updated accordingly.
+   Returns:  Error code.
    ======================================================================== */
 
 static int clkgenb_fsyn_recalc(clk_t *clk_p)
 {
-	U32 val, clkout, ctrl, bit;
-	U32 pe, md, sdiv;
-	struct fsyn_regs *regs = NULL;
+	unsigned long val, clkout, ctrl, bit;
+	unsigned long pe, md, sdiv;
+	int bank, channel;
 
-	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+	if (!clk_p || !clk_p->parent)
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Which FSYN control registers to use ? */
 	switch (clk_p->id) {
 	case CLKB_FS0:
-	case CLKB_FS0_CH1:
-	case CLKB_FS0_CH2:
-	case CLKB_FS0_CH3:
-	case CLKB_FS0_CH4:
+	case CLKB_FS0_CH1...CLKB_FS0_CH4:
 		clkout = CKGB_FS0_CLKOUT_CTRL;
 		ctrl = CKGB_FS0_CTRL;
 		break;
 	case CLKB_FS1:
-	case CLKB_FS1_CH1:
-	case CLKB_FS1_CH2:
-	case CLKB_FS1_CH3:
-	case CLKB_FS1_CH4:
+	case CLKB_FS1_CH1...CLKB_FS1_CH4:
 		clkout = CKGB_FS1_CLKOUT_CTRL;
 		ctrl = CKGB_FS1_CTRL;
 		break;
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
 	/* Is FSYN analog part UP ? */
 	val = CLK_READ(CKGB_BASE_ADDRESS + ctrl);
 	if ((val & (1 << 4)) == 0) {	/* NO. Analog part is powered down */
 		clk_p->rate = 0;
-		return (0);
+		return 0;
 	}
 
 	/* Is FSYN digital part UP ? */
 	switch (clk_p->id) {
-	case CLKB_FS0_CH1:
-	case CLKB_FS1_CH1:
-		bit = 0;
-		break;
-	case CLKB_FS0_CH2:
-	case CLKB_FS1_CH2:
-		bit = 1;
-		break;
-	case CLKB_FS0_CH3:
-	case CLKB_FS1_CH3:
-		bit = 2;
-		break;
-	case CLKB_FS0_CH4:
-	case CLKB_FS1_CH4:
-		bit = 3;
+	case CLKB_FS0_CH1 ... CLKB_FS1_CH4:
+		bit = (clk_p->id - CLKB_FS0_CH1) % 4;
 		break;
 	default:
 		bit = 99;
@@ -1360,10 +1403,10 @@ static int clkgenb_fsyn_recalc(clk_t *clk_p)
 	}
 	if (bit != 99) {
 		val = CLK_READ(CKGB_BASE_ADDRESS + clkout);
-		 /* NO: digital part is powered down */
 		if ((val & (1 << bit)) == 0) {
+			/* Digital standbye */
 			clk_p->rate = 0;
-			return (0);
+			return 0;
 		}
 	}
 
@@ -1376,50 +1419,47 @@ static int clkgenb_fsyn_recalc(clk_t *clk_p)
 		break;
 
 	case CLKB_FS0_CH1...CLKB_FS1_CH4:
-		regs = &clkgenb_regs[clk_p->id - CLKB_FS0_CH1];
+		bank = (clk_p->id - CLKB_FS0_CH1) / 4;
+		channel = (clk_p->id - CLKB_FS0_CH1) % 4;
+		pe = CLK_READ(CKGB_BASE_ADDRESS + CKGB_FS_PE(bank, channel));
+		md = CLK_READ(CKGB_BASE_ADDRESS + CKGB_FS_MD(bank, channel));
+		sdiv = CLK_READ(CKGB_BASE_ADDRESS +
+			CKGB_FS_SDIV(bank, channel));
+		clk_p->rate = clk_fsyn_get_rate(clk_p->parent->rate,
+					pe, md, sdiv);
 		break;
 	}
 
-	if (regs) {
-		pe = CLK_READ(CKGB_BASE_ADDRESS + regs->pe);
-		md = CLK_READ(CKGB_BASE_ADDRESS + regs->md);
-		sdiv = CLK_READ(CKGB_BASE_ADDRESS + regs->sdiv);
-		clk_p->rate =
-		    clk_fsyn_get_rate(clk_p->parent->rate, pe, md, sdiv);
-	}
-
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_recalc
    Description: Get CKGB clocks frequencies function
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 /* Check clock enable value for clockgen B.
    Returns: 1=RUNNING, 0=DISABLED */
-static int clkgenb_is_running(U32 power, int bit)
+static int clkgenb_is_running(unsigned long power, int bit)
 {
 	if (power & (1 << bit))
-		return (1);
+		return 1;
 
-	return (0);
+	return 0;
 }
 
 static int clkgenb_recalc(clk_t *clk_p)
 {
-	U32 displaycfg, powerdown, fs_sel, power;
-	static unsigned int tab2481[] = { 2, 4, 8, 1 };
-	static unsigned int tab2482[] = { 2, 4, 8, 2 };
+	unsigned long displaycfg, powerdown, fs_sel, power;
+	static const unsigned int tab2481[] = { 2, 4, 8, 1 };
+	static const unsigned int tab2482[] = { 2, 4, 8, 2 };
 
-	if (clk_p == NULL)
-		return (CLK_ERR_BAD_PARAMETER);
-	if (clk_p->parent == NULL)
-		return (CLK_ERR_INTERNAL);	/* parent_p clock is unknown */
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
-	/* Cleaning structure first */
-	clk_p->rate = 0;
+	if (!clk_p->parent)
+		return CLK_ERR_INTERNAL;	/* parent_p clock is unknown */
 
 	/* Read mux */
 	displaycfg = CLK_READ(CKGB_BASE_ADDRESS + CKGB_DISPLAY_CFG);
@@ -1428,21 +1468,11 @@ static int clkgenb_recalc(clk_t *clk_p)
 	power = CLK_READ(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE);
 
 	switch (clk_p->id) {
-	case CLKB_REF:
-		clk_p->rate = clk_p->parent->rate;
-		break;
 
 	case CLKB_FS0:		/* FSyn 0 power control */
-	case CLKB_FS0_CH1:	/* FS0 clock 1 */
-	case CLKB_FS0_CH2:	/* FS0 clock 2 */
-	case CLKB_FS0_CH3:	/* FS0 clock 3 */
-	case CLKB_FS0_CH4:	/* FS0 clock 4 */
 	case CLKB_FS1:		/* FSyn 1 power control */
-	case CLKB_FS1_CH1:	/* FS1 clock 1 */
-	case CLKB_FS1_CH2:	/* FS1 clock 2 */
-	case CLKB_FS1_CH3:	/* FS1 clock 3 */
-	case CLKB_FS1_CH4:	/* FS1 clock 4 */
-		return (clkgenb_fsyn_recalc(clk_p));
+	case CLKB_FS0_CH1...CLKB_FS1_CH4:
+		return clkgenb_fsyn_recalc(clk_p);
 
 	case CLKB_TMDS_HDMI:	/* tmds_hdmi_clk */
 		if (powerdown & (1 << 1))
@@ -1485,7 +1515,7 @@ static int clkgenb_recalc(clk_t *clk_p)
 			clk_p->rate = 0;
 		break;
 
-	case CLKB_656:		/* ccir656_clk */
+	case CLKB_656_0:	/* ccir656_clk */
 		if (powerdown & (1 << 5))
 			clk_p->rate = clk_p->parent->rate / 1024;
 		else
@@ -1576,14 +1606,6 @@ static int clkgenb_recalc(clk_t *clk_p)
 			clk_p->rate = clk_p->parent->rate;
 		break;
 
-	case CLKB_SPARE04:
-		clk_p->rate = clk_p->parent->rate;
-		break;
-
-	case CLKB_SPARE12:
-		clk_p->rate = clk_p->parent->rate;
-		break;
-
 	case CLKB_PP:
 		if (!clkgenb_is_running(power, 12))
 			clk_p->rate = 0;
@@ -1598,30 +1620,33 @@ static int clkgenb_recalc(clk_t *clk_p)
 			clk_p->rate = clk_p->parent->rate / 1024;
 		break;
 
+	case CLKB_SPARE04:
+	case CLKB_MMC:
 	case CLKB_PIP:
+	case CLKB_REF:
 		clk_p->rate = clk_p->parent->rate;
 		break;
 
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_identify_parent
    Description: Identify parent clock
-   Returns:     clk_err_t
+   Returns:  clk_err_t
    ======================================================================== */
 
 static int clkgenb_identify_parent(clk_t *clk_p)
 {
-	U32 sel, fs_sel;
-	U32 displaycfg;
+	unsigned long sel, fs_sel;
+	unsigned long displaycfg;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	fs_sel = CLK_READ(CKGB_BASE_ADDRESS + CKGB_FS_SELECT);
 
@@ -1641,61 +1666,30 @@ static int clkgenb_identify_parent(clk_t *clk_p)
 		}
 		break;
 
-	case CLKB_FS0:		/* FSyn 0 */
-	case CLKB_FS1:		/* FSyn 1 */
-		clk_p->parent = &clk_clocks[CLKB_REF];
-		break;
-	case CLKB_FS0_CH1:	/* FS0 clock 1 */
-	case CLKB_FS0_CH2:	/* FS0 clock 2 */
-	case CLKB_FS0_CH3:	/* FS0 clock 3 */
-	case CLKB_FS0_CH4:	/* FS0 clock 4 */
-		clk_p->parent = &clk_clocks[CLKB_FS0];
-		break;
-	case CLKB_FS1_CH1:	/* FS1 clock 1 */
-	case CLKB_FS1_CH2:	/* FS1 clock 2 */
-	case CLKB_FS1_CH3:	/* FS1 clock 3 */
-	case CLKB_FS1_CH4:	/* FS1 clock 4 */
-		clk_p->parent = &clk_clocks[CLKB_FS1];
-		break;
-
-	case CLKB_TMDS_HDMI:	/* tmds_hdmi_clk */
-	case CLKB_656_1:	/* pix_hdmi */
-	case CLKB_DISP_HD:	/* disp_hd */
-	case CLKB_656:		/* ccir656_clk */
-		clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
-		break;
-
 	case CLKB_PIX_HD:	/* pix_hd */
 		displaycfg = CLK_READ(CKGB_BASE_ADDRESS + CKGB_DISPLAY_CFG);
-		if (displaycfg & (1 << 14)) {	/* pix_hd source = FSYN1 */
+		if (displaycfg & (1 << 14))	/* pix_hd source = FSYN1 */
 			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
-		} else {	/* pix_hd source = FSYN0 */
+		else 	/* pix_hd source = FSYN0 */
 			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
-		}
-		break;
-
-	case CLKB_DISP_ID:	/* disp_id */
-		clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
 		break;
 
 	case CLKB_PIX_SD:	/* pix_sd */
-		if (fs_sel & 0x2) {
+		if (fs_sel & 0x2)
 			/* source is FS1 */
 			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
-		} else {
+		else
 			/* source is FS0 */
 			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
-		}
 		break;
 
 	case CLKB_GDP3:	/* gdp3_clk */
-		if (fs_sel & 0x1) {
+		if (fs_sel & 0x1)
 			/* source is FS1 */
 			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
-		} else {
+		else
 			/* source is FS0 */
 			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
-		}
 		break;
 
 	case CLKB_DVP:		/* CKGB_DVP */
@@ -1713,41 +1707,15 @@ static int clkgenb_identify_parent(clk_t *clk_p)
 		}
 		break;
 
-	case CLKB_DSS:
-		clk_p->parent = &clk_clocks[CLKB_FS0_CH2];
-		break;
-
-	case CLKB_DAA:
-		clk_p->parent = &clk_clocks[CLKB_FS0_CH3];
-		break;
-
-	case CLKB_SPARE04:
-		clk_p->parent = &clk_clocks[CLKB_FS0_CH4];
-		break;
-
-	case CLKB_SPARE12:
-		clk_p->parent = &clk_clocks[CLKB_FS1_CH2];
-		break;
-
-	case CLKB_PP:
-		clk_p->parent = &clk_clocks[CLKB_FS1_CH3];
-		break;
-
-	case CLKB_LPC:
-		clk_p->parent = &clk_clocks[CLKB_FS1_CH4];
-		break;
-
-	default:
-		return (CLK_ERR_BAD_PARAMETER);
 	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenb_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgenb_init(clk_t *clk_p)
@@ -1755,13 +1723,13 @@ static int clkgenb_init(clk_t *clk_p)
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	err = clkgenb_identify_parent(clk_p);
 	if (err == 0)
 		err = clkgenb_recalc(clk_p);
 
-	return (err);
+	return err;
 }
 
 /******************************************************************************
@@ -1771,17 +1739,17 @@ CLOCKGEN C (audio)
 /* ========================================================================
    Name:	clkgenc_fsyn_recalc
    Description: Get CKGC FSYN clocks frequencies function
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgenc_fsyn_recalc(clk_t *clk_p)
 {
-	U32 cfg, dig_bit, en_bit;
-	U32 pe, md, sdiv;
-	struct fsyn_regs *regs;
+	unsigned long cfg, dig_bit, en_bit;
+	unsigned long pe, md, sdiv;
+	int channel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Cleaning structure first */
 	clk_p->rate = 0;
@@ -1790,121 +1758,104 @@ static int clkgenc_fsyn_recalc(clk_t *clk_p)
 	cfg = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG);
 	if (!(cfg & (1 << 14))) {	/* Analog power down */
 		clk_p->rate = 0;
-		return (0);
+		return 0;
 	}
 
-	/* Is FSYN digital part UP & enabled ? */
-	switch (clk_p->id) {
-	case CLKC_FS0:
+	if (clk_p->id == CLKC_REF)
+		return 0;
+	if (clk_p->id == CLKC_FS0) {
 		clk_p->rate = clk_p->parent->rate;
-		return (0);
-	case CLKC_FS0_CH1:
-		dig_bit = 10;
-		en_bit = 6;
-		regs = &clkgenc_regs[0];
-		break;
-	case CLKC_FS0_CH2:
-		dig_bit = 11;
-		en_bit = 7;
-		regs = &clkgenc_regs[1];
-		break;
-	case CLKC_FS0_CH3:
-		dig_bit = 12;
-		en_bit = 8;
-		regs = &clkgenc_regs[2];
-		break;
-	case CLKC_FS0_CH4:
-		dig_bit = 13;
-		en_bit = 9;
-		regs = &clkgenc_regs[3];
-		break;
-	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return 0;
 	}
+
+	dig_bit = 10 + (clk_p->id - CLKC_FS0_CH1);
+	en_bit = 6 + (clk_p->id - CLKC_FS0_CH1);
+
 	if ((cfg & (1 << dig_bit)) == 0) {	/* digital part in standbye */
 		clk_p->rate = 0;
-		return (0);
+		return 0;
 	}
 	if ((cfg & (1 << en_bit)) == 0) {	/* disabled */
 		clk_p->rate = 0;
-		return (0);
+		return 0;
 	}
 
 	/* FSYN up & running.
 	   Computing frequency */
-
-	pe = CLK_READ(CKGC_BASE_ADDRESS + regs->pe);
-	md = CLK_READ(CKGC_BASE_ADDRESS + regs->md);
-	sdiv = CLK_READ(CKGC_BASE_ADDRESS + regs->sdiv);
+	channel = (clk_p->id - CLKC_FS0_CH1) % 4;
+	pe = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS_PE(0, channel));
+	md = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS_MD(0, channel));
+	sdiv = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS_SDIV(0, channel));
 	clk_p->rate = clk_fsyn_get_rate(clk_p->parent->rate, pe, md, sdiv);
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenc_recalc
    Description: Get CKGC clocks frequencies function
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgenc_recalc(clk_t *clk_p)
 {
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	switch (clk_p->id) {
 	case CLKC_REF:
 		clk_p->rate = clk_p->parent->rate;
 		break;
 
-	case CLKC_FS0:		/* FSyn 0 power control */
-	case CLKC_FS0_CH1:	/* FS0 clock 1 */
-	case CLKC_FS0_CH2:	/* FS0 clock 2 */
-	case CLKC_FS0_CH3:	/* FS0 clock 3 */
-	case CLKC_FS0_CH4:	/* FS0 clock 4 */
-		return (clkgenc_fsyn_recalc(clk_p));
+	case CLKC_FS0:		/* FSyn 0 power control => output=input */
+	case CLKC_FS0_CH1...CLKC_FS0_CH4:	/* FS0 clocks */
+		return clkgenc_fsyn_recalc(clk_p);
 	default:
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenc_set_rate
    Description: Set CKGC clocks frequencies
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
-static int clkgenc_set_rate(clk_t *clk_p, U32 freq)
+static int clkgenc_set_rate(clk_t *clk_p, unsigned long freq)
 {
 	int md, pe, sdiv;
-	U32 ref;
-	U32 reg_value = 0;
-	struct fsyn_regs *regs;
-	static U32 set_rate_table[] = { 0x06, 0x0A, 0x012, 0x022 };
+	unsigned long ref;
+	unsigned long reg_value = 0;
+	int channel;
+	static const unsigned long set_rate_table[] =
+	    { 0x06, 0x0A, 0x012, 0x022 };
+
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id < CLKC_FS0_CH1 || clk_p->id > CLKC_FS0_CH4)
+		return CLK_ERR_BAD_PARAMETER;
 
 	ref = clk_p->parent->rate;
 
 	/* Computing FSyn params. Should be common function with FSyn type */
-	if ((clk_fsyn_get_params(ref, freq, &md, &pe, &sdiv)) != 0)
+	if (clk_fsyn_get_params(ref, freq, &md, &pe, &sdiv))
 		return CLK_ERR_BAD_PARAMETER;
 
 	reg_value = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG);
-
-	regs = &clkgenc_regs[clk_p->id - CLKC_FS0_CH1];
+	channel = (clk_p->id - CLKC_FS0_CH1) % 4;
 	reg_value |= set_rate_table[clk_p->id - CLKC_FS0_CH1];
 
 	/* Select FS clock only for the clock specified */
 	CLK_WRITE(CKGC_BASE_ADDRESS + CKGC_FS0_CFG, reg_value);
 
-	CLK_WRITE(CKGC_BASE_ADDRESS + regs->pe, pe);
-	CLK_WRITE(CKGC_BASE_ADDRESS + regs->md, md);
-	CLK_WRITE(CKGC_BASE_ADDRESS + regs->sdiv, sdiv);
-	CLK_WRITE(CKGC_BASE_ADDRESS + regs->prog, 0x01);
-	CLK_WRITE(CKGC_BASE_ADDRESS + regs->prog, 0x00);
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGB_FS_PE(0, channel), pe);
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGB_FS_MD(0, channel), md);
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGB_FS_SDIV(0, channel), sdiv);
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGB_FS_EN_PRG(0, channel), 0x01);
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGB_FS_EN_PRG(0, channel), 0x00);
 
 	clk_p->rate = freq;
 
@@ -1914,18 +1865,17 @@ static int clkgenc_set_rate(clk_t *clk_p, U32 freq)
 /* ========================================================================
    Name:	clkgenc_identify_parent
    Description: Identify parent clock
-   Returns:     clk_err_t
+   Returns:  clk_err_t
    ======================================================================== */
 
 static int clkgenc_identify_parent(clk_t *clk_p)
 {
-	U32 sel;
+	unsigned long sel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
-	switch (clk_p->id) {
-	case CLKC_REF:
+	if (clk_p->id == CLKC_REF) {
 		sel = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG) >> 23;
 		switch (sel & 0x3) {
 		case 0:
@@ -1938,38 +1888,23 @@ static int clkgenc_identify_parent(clk_t *clk_p)
 			clk_p->parent = NULL;
 			break;
 		}
-		break;
-
-	case CLKC_FS0:
-		clk_p->parent = &clk_clocks[CLKC_REF];
-		break;
-	case CLKC_FS0_CH1:
-	case CLKC_FS0_CH2:
-	case CLKC_FS0_CH3:
-	case CLKC_FS0_CH4:
-		clk_p->parent = &clk_clocks[CLKC_REF];
-		break;
-
-	default:
-		clk_p->parent = NULL;
-		break;
 	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgenc_set_parent
    Description: Set parent clock
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgenc_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	U32 sel, data;
+	unsigned long sel, data;
 
 	if (!clk_p || !parent_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	if (clk_p->id == CLKC_REF) {
 		switch (parent_p->id) {
@@ -1980,7 +1915,7 @@ static int clkgenc_set_parent(clk_t *clk_p, clk_t *parent_p)
 			sel = 2;
 			break;
 		default:
-			return (CLK_ERR_BAD_PARAMETER);
+			return CLK_ERR_BAD_PARAMETER;
 		}
 		data =
 		    CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG) & ~(0x3 << 23);
@@ -1989,15 +1924,13 @@ static int clkgenc_set_parent(clk_t *clk_p, clk_t *parent_p)
 	} else
 		clk_p->parent = &clk_clocks[CLKC_REF];
 
-	clkgenc_recalc(clk_p);
-
-	return (CLK_ERR_BAD_PARAMETER);
+	return clkgenc_recalc(clk_p);
 }
 
 /* ========================================================================
    Name:	clkgenc_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgenc_init(clk_t *clk_p)
@@ -2005,28 +1938,30 @@ static int clkgenc_init(clk_t *clk_p)
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	err = clkgenc_identify_parent(clk_p);
 	if (err == 0)
 		err = clkgenc_recalc(clk_p);
 
-	return (err);
+	return err;
 }
 
 /* ========================================================================
    Name:	clkgenc_enable
    Description: enable clock
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
-static U32 clkgenc_enable_table[] = { 0x440, 0x880, 0x1100, 0x2200 };
+
+static const unsigned long clkgenc_enable_table[] =
+    { 0x440, 0x880, 0x1100, 0x2200 };
 
 static int clkgenc_enable(clk_t *clk_p)
 {
-	U32 reg_value = 0;
+	unsigned long reg_value = 0;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	reg_value = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG);
 	reg_value |= clkgenc_enable_table[clk_p->id - CLKC_FS0_CH1];
@@ -2038,20 +1973,18 @@ static int clkgenc_enable(clk_t *clk_p)
 		CLK_WRITE(CKGC_BASE_ADDRESS + CKGC_FS0_CFG, reg_value);
 	}
 
-	clkgenc_recalc(clk_p);
-
-	return 0;
-
+	return clkgenc_recalc(clk_p);
 }
 
 /* ========================================================================
    Name:	clkgenc_disable
    Description: disable clock
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
+
 static int clkgenc_disable(clk_t *clk_p)
 {
-	U32 reg_value = 0;
+	unsigned long reg_value = 0;
 
 	reg_value = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG);
 	reg_value &= ~clkgenc_enable_table[clk_p->id - CLKC_FS0_CH1];
@@ -2066,7 +1999,6 @@ static int clkgenc_disable(clk_t *clk_p)
 	clk_p->rate = 0;
 
 	return 0;
-
 }
 
 /******************************************************************************
@@ -2076,12 +2008,15 @@ CLOCKGEN D (LMI)
 /* ========================================================================
    Name:	clkgend_recalc
    Description: Get CKGD (LMI) clocks frequencies (in Hz)
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgend_recalc(clk_t *clk_p)
 {
-	U32 rdiv, ddiv;
+	unsigned long rdiv, ddiv;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
 	/* Cleaning structure first */
 	clk_p->rate = 0;
@@ -2089,31 +2024,31 @@ static int clkgend_recalc(clk_t *clk_p)
 	if (clk_p->id == CLKD_REF)
 		clk_p->rate = clk_p->parent->rate;
 	else if (clk_p->id == CLKD_LMI2X) {
-		rdiv = SYSCONF_READ(2, 11, 9, 11);
-		ddiv = SYSCONF_READ(2, 11, 1, 8);
+		rdiv = SYSCONF_READ(SYS_CFG, 11, 9, 11);
+		ddiv = SYSCONF_READ(SYS_CFG, 11, 1, 8);
 		clk_p->rate =
 		    (((clk_p->parent->rate / 1000000) * ddiv) / rdiv) * 1000000;
 	} else
-		return (CLK_ERR_BAD_PARAMETER);	/* Unknown clock */
+		return CLK_ERR_BAD_PARAMETER;	/* Unknown clock */
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgend_identify_parent
    Description: Identify parent clock
-   Returns:     clk_err_t
+   Returns:  clk_err_t
    ======================================================================== */
 
 static int clkgend_identify_parent(clk_t *clk_p)
 {
-	U32 sel;
+	unsigned long sel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	if (clk_p->id == CLKD_REF) {
-		sel = SYSCONF_READ(2, 40, 0, 1);
+		sel = SYSCONF_READ(SYS_CFG, 40, 0, 1);
 		switch (sel) {
 		case 0:
 			clk_p->parent = &clk_clocks[CLK_SYSALT];
@@ -2125,24 +2060,23 @@ static int clkgend_identify_parent(clk_t *clk_p)
 			clk_p->parent = NULL;
 			break;
 		}
-	} else
-		clk_p->parent = &clk_clocks[CLKD_REF];
+	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgend_set_parent
    Description: Set parent clock
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgend_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	U32 sel;
+	unsigned long sel;
 
 	if (!clk_p || !parent_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	if (clk_p->id == CLKD_REF) {
 		switch (parent_p->id) {
@@ -2153,22 +2087,19 @@ static int clkgend_set_parent(clk_t *clk_p, clk_t *parent_p)
 			sel = 1;
 			break;
 		default:
-			return (CLK_ERR_BAD_PARAMETER);
+			return CLK_ERR_BAD_PARAMETER;
 		}
-		SYSCONF_WRITE(2, 40, 0, 1, sel);
+		SYSCONF_WRITE(SYS_CFG, 40, 0, 1, sel);
 		clk_p->parent = parent_p;
-	} else
-		clk_p->parent = &clk_clocks[CLKD_REF];
-
-	clkgend_recalc(clk_p);
+	}
 
-	return (0);
+	return clkgend_recalc(clk_p);
 }
 
 /* ========================================================================
    Name:	clkgend_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgend_init(clk_t *clk_p)
@@ -2176,13 +2107,13 @@ static int clkgend_init(clk_t *clk_p)
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	err = clkgend_identify_parent(clk_p);
 	if (err == 0)
 		err = clkgend_recalc(clk_p);
 
-	return (err);
+	return err;
 }
 
 /******************************************************************************
@@ -2192,7 +2123,7 @@ CLOCKGEN E (USB)
 /* ========================================================================
    Name:	clkgene_recalc
    Description: Get CKGE (USB) clocks frequencies (in Hz)
-   Returns:     0=NO error
+   Returns:  0=NO error
    ======================================================================== */
 
 static int clkgene_recalc(clk_t *clk_p)
@@ -2203,26 +2134,26 @@ static int clkgene_recalc(clk_t *clk_p)
 	if (clk_p->id == CLKE_REF)
 		clk_p->rate = clk_p->parent->rate;
 	else
-		return (CLK_ERR_BAD_PARAMETER);	/* Unknown clock */
+		return CLK_ERR_BAD_PARAMETER;	/* Unknown clock */
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgene_identify_parent
    Description: Identify parent clock
-   Returns:     clk_err_t
+   Returns:  clk_err_t
    ======================================================================== */
 
 static int clkgene_identify_parent(clk_t *clk_p)
 {
-	U32 sel;
+	unsigned long sel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	if (clk_p->id == CLKE_REF) {
-		sel = SYSCONF_READ(2, 40, 2, 3);
+		sel = SYSCONF_READ(SYS_CFG, 40, 2, 3);
 		switch (sel) {
 		case 0:
 			clk_p->parent = &clk_clocks[CLK_SYS];
@@ -2234,24 +2165,23 @@ static int clkgene_identify_parent(clk_t *clk_p)
 			clk_p->parent = NULL;
 			break;
 		}
-	} else
-		clk_p->parent = &clk_clocks[CLKE_REF];
+	}
 
-	return (0);
+	return 0;
 }
 
 /* ========================================================================
    Name:	clkgene_set_parent
    Description: Change parent clock
-   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   Returns:  Pointer on parent 'clk_t' structure, or NULL (none or error)
    ======================================================================== */
 
 static int clkgene_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	U32 sel;
+	unsigned long sel;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	if (clk_p->id == CLKE_REF) {
 		switch (parent_p->id) {
@@ -2262,22 +2192,20 @@ static int clkgene_set_parent(clk_t *clk_p, clk_t *parent_p)
 			sel = 1;
 			break;
 		default:
-			return (CLK_ERR_BAD_PARAMETER);
+			return CLK_ERR_BAD_PARAMETER;
 		}
-		SYSCONF_WRITE(2, 40, 2, 3, sel);
+		SYSCONF_WRITE(SYS_CFG, 40, 2, 3, sel);
 		clk_p->parent = parent_p;
 	} else
-		return (CLK_ERR_BAD_PARAMETER);
-
-	clkgene_recalc(clk_p);
+		return CLK_ERR_BAD_PARAMETER;
 
-	return (0);
+	return clkgene_recalc(clk_p);
 }
 
 /* ========================================================================
    Name:	clkgene_init
    Description: Read HW status to initialize 'clk_t' structure.
-   Returns:     'clk_err_t' error code.
+   Returns:  'clk_err_t' error code.
    ======================================================================== */
 
 static int clkgene_init(clk_t *clk_p)
@@ -2285,11 +2213,11 @@ static int clkgene_init(clk_t *clk_p)
 	int err;
 
 	if (!clk_p)
-		return (CLK_ERR_BAD_PARAMETER);
+		return CLK_ERR_BAD_PARAMETER;
 
 	err = clkgene_identify_parent(clk_p);
 	if (err == 0)
 		err = clkgene_recalc(clk_p);
 
-	return (err);
+	return err;
 }
diff --git a/arch/sh/kernel/cpu/sh4/clock-stx7105.h b/arch/sh/kernel/cpu/sh4/clock-stx7105.h
index 42d1768..9138280 100644
--- a/arch/sh/kernel/cpu/sh4/clock-stx7105.h
+++ b/arch/sh/kernel/cpu/sh4/clock-stx7105.h
@@ -1,30 +1,36 @@
-/************************************************************************
- * CLOCK driver
- * Low Level API - 7105 specific implementation
- * (C) F. Charpentier, 2008-09
+/*****************************************************************************
+ *
+ * File name   : clock-stx7105.h
+ * Description : Low Level API - Clocks identifiers
+ * Component   : STCLOCK
+ * Module      :
+ *
+ * COPYRIGHT (C) 2009 STMicroelectronics - All Rights Reserved
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
-************************************************************************/
+ * License V2 _ONLY_.  See linux/COPYING for more information.
+ *
+ *****************************************************************************/
 
-/* Clocks identifier list */
-typedef enum
+enum
 {
     /* Top level clocks */
-    CLK_SYS,	   /* SYSA_CLKIN/FE input clock */
-    CLK_SYSALT,	 /* Optional alternate input clock */
+    CLK_SYS,           /* SYSA_CLKIN/FE input clock */
+    CLK_SYSALT,         /* Optional alternate input clock */
 
     /* Clockgen A */
-    CLKA_REF,	   /* Clockgen A reference clock */
-    CLKA_OSC,
-    CLKA_PLL0HS,	/* PLL0 HS output */
-    CLKA_PLL0LS,	/* PLL0 LS output */
-    CLKA_PLL1,
+    CLKA_REF,           /* Clockgen A reference clock = OSC clock */
+    CLKA_PLL0,          /* PLL0 power control */
+    CLKA_PLL0HS,        /* PLL0 HS output */
+    CLKA_PLL0LS,        /* PLL0 LS output */
+    CLKA_PLL1,          /* PLL1 power control & output clock */
+
 
     CLKA_IC_STNOC,      /* HS[0] */
     CLKA_FDMA0,
     CLKA_FDMA1,
-    CLKA_NOT_USED3,     /* HS[3], NOT used */
-    CLKA_ST40_ICK,
+    CLKA_ETH1_PHY,      /* HS[3] */
+
+    CLKA_ST40_ICK,      /* LS[4] */
     CLKA_IC_IF_100,
     CLKA_LX_DMU_CPU,
     CLKA_LX_AUD_CPU,
@@ -33,17 +39,17 @@ typedef enum
     CLKA_IC_TS_200,
     CLKA_DISP_PIPE_200,
     CLKA_BLIT_PROC,
-    CLKA_IC_DELTA_200,
-    CLKA_ETH_PHY,
+    CLKA_IC_DELTA_200,  /* Same clock than CLKA_BLIT_PROC */
+    CLKA_ETH0_PHY,
     CLKA_PCI,
     CLKA_EMI_MASTER,
     CLKA_IC_COMPO_200,
     CLKA_IC_IF_200,
 
     /* Clockgen B */
-    CLKB_REF,	   /* Clockgen B reference clock */
-    CLKB_FS0,	   /* FSYN 0 power control */
-    CLKB_FS1,	   /* FSYN 1 power control */
+    CLKB_REF,           /* Clockgen B reference clock */
+    CLKB_FS0,           /* FSYN 0 power control */
+    CLKB_FS1,           /* FSYN 1 power control */
     CLKB_FS0_CH1,
     CLKB_FS0_CH2,
     CLKB_FS0_CH3,
@@ -55,40 +61,41 @@ typedef enum
 
     CLKB_TMDS_HDMI,
     CLKB_656_1,
-
     CLKB_PIX_HD,
     CLKB_DISP_HD,
-    CLKB_656,
+    CLKB_656_0,
     CLKB_GDP3,
     CLKB_DISP_ID,
     CLKB_PIX_SD,
-    CLKB_DVP,
     CLKB_PIX_FROM_DVP,
-
+    CLKB_DVP,
     CLKB_PP,
     CLKB_LPC,
     CLKB_DSS,
     CLKB_DAA,
-    CLKB_PIP,	   /* NOT in clockgenB.
-		    * Sourced from clk_disp_sd or clk_disp_hd
-		    */
-
+    /* NOT in clockgenB. Sourced from clk_disp_sd or clk_disp_hd */
+    CLKB_PIP,
     CLKB_SPARE04,       /* Spare FS0, CH4 */
-    CLKB_SPARE12,       /* Spare FS1, CH2 */
+/*
+ * the 7105 has a not used channel in the FS_1_ch_2 while
+ * the 7106 uses this channel as CLK_MMC
+ */
+    CLKB_SPARE12,		/* Spare FS1, CH2 on 7105	*/
+    CLKB_MMC = CLKB_SPARE12,	/* CLK_MMC on 7106		*/
 
     /* Clockgen C (Audio) */
     CLKC_REF,
-    CLKC_FS0,	   /* FSYN 0 power control */
+    CLKC_FS0,           /* FSYN 0 power control */
     CLKC_FS0_CH1,
     CLKC_FS0_CH2,
     CLKC_FS0_CH3,
     CLKC_FS0_CH4,
 
     /* Clockgen D */
-    CLKD_REF,	   /* Clockgen D reference clock */
+    CLKD_REF,           /* Clockgen D reference clock */
     CLKD_LMI2X,
 
     /* Clockgen E = USB PHY */
-    CLKE_REF,	   /* Clockgen E reference clock */
+    CLKE_REF,           /* Clockgen E reference clock */
 
-} clk_id_t;
+};
-- 
1.6.0.6

