(New) ALSA implementation for STx710x and STx7200. 

Version 4, released for kernel 0106.

!!! It is still a alpha version, with a lot of functionality lacking !!!
 
TODO:

* I2S to SPDIF converter implementation (for STx7109 now)
* plugable DACs environment (with generic implementation of GPIO & I2C controlled DAC drivers)
* playback synchronisation features
* ALSA documentation (website)
* driver test plan
* HDMI output router control (PCM/SPDIF switch)
* advanced SPDIF player features (controls for repetition periods, User data) and Channel status bits etc.)
* FDMA-powered SPDIF formatting
* proper usage of BPA2
* PM (resume/suspend)
* calculation of captured PCM sampling rate
* some hardware settings clarification
* some optimisations
 
Changelog: 

Version 4
* fixed major problem with 16-bit samples playback using PCM player
* fixed fsynth adjustement value rounding bug
* minor code clean-ups

Version 3
* driver builds as a module now (it even works ;-)
* fsynth adjustment capabilities implemented and exposed as controls
* some minor code clean-ups

Version 2 
* release for 2.6.23.1_stm23_104 kernel 
* error paths implemented 
* <bpa2.h> is used now instead of <bigphysmem.h> 
* FDMA initiator to be used is defined in platform device configuration now 
* SPDIF player default oversampling changed from 256 to 128 
* code compiles now for 710x SoCs and cb101 board ;-) 
 
Version 1 
* initial internal release for 2.6.23.1_stm23_0102 kernel 
 
Signed-off-by: Pawel MOLL <pawel.moll@st.com> 

Index: linux-2.6.23-stm/arch/sh/boards/st/cb101/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/boards/st/cb101/setup.c
+++ linux-2.6.23-stm/arch/sh/boards/st/cb101/setup.c
@@ -186,12 +186,20 @@ static struct platform_device *cb101_dev
 	&cb101_phy_device,
 };
 
+struct plat_audio_config left_justified_format = {
+	.pcm_format = PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED |
+			PLAT_STM_AUDIO__DATA_SIZE_24_BITS,
+	.oversampling = 256,
+};
+
 static int __init device_init(void)
 {
 	stx7200_configure_ssc(&ssc_private_info);
 	stx7200_configure_usb();
+	stx7200_configure_audio(&left_justified_format, NULL, NULL,
+			NULL, NULL, NULL);
 	stx7200_configure_ethernet(0, 0, 0, 0);
-        stx7200_configure_lirc();
+	stx7200_configure_lirc();
 	stx7200_configure_nand(&cb101_nand_config[0]);
 	stx7200_configure_nand(&cb101_nand_config[1]);
 
Index: linux-2.6.23-stm/arch/sh/boards/st/hms1/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/boards/st/hms1/setup.c
+++ linux-2.6.23-stm/arch/sh/boards/st/hms1/setup.c
@@ -98,6 +98,7 @@ static int __init hms1_device_init(void)
 	stx7100_configure_ssc(&ssc_private_info);
 	stx7100_configure_usb();
 	stx7100_configure_pata(3, IRL1_IRQ);
+	stx7100_configure_audio(NULL, NULL, NULL);
 
 	vpp_pio = stpio_request_pin(2,5, "VPP", STPIO_OUT);
 
Index: linux-2.6.23-stm/arch/sh/boards/st/mb442/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/boards/st/mb442/setup.c
+++ linux-2.6.23-stm/arch/sh/boards/st/mb442/setup.c
@@ -155,6 +155,7 @@ static int __init device_init(void)
 	stx7100_configure_usb();
 	stx7100_configure_lirc();
 	stx7100_configure_pata(3, IRL1_IRQ);
+	stx7100_configure_audio(NULL, NULL, NULL);
 
 	phy_reset_pin = stpio_request_set_pin(2, 4, "ste100p_reset",
 					      STPIO_OUT, 1);
Index: linux-2.6.23-stm/arch/sh/boards/st/mb448/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/boards/st/mb448/setup.c
+++ linux-2.6.23-stm/arch/sh/boards/st/mb448/setup.c
@@ -143,6 +143,7 @@ static int __init device_init(void)
 	stx7100_configure_ssc(&ssc_private_info);
 	stx7100_configure_usb();
 	stx7100_configure_ethernet(0, 0, 0);
+	stx7100_configure_audio(NULL, NULL, NULL);
 
 	vpp_pio = stpio_request_pin(2,7, "VPP", STPIO_OUT);
 
Index: linux-2.6.23-stm/arch/sh/boards/st/mb519/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/boards/st/mb519/setup.c
+++ linux-2.6.23-stm/arch/sh/boards/st/mb519/setup.c
@@ -215,6 +215,13 @@ static struct platform_device *mb519_dev
 	&mb519_phy_devices[1],
 };
 
+struct plat_audio_config i2s_format = {
+	/* Actually this is a default value, but let's treat it as an example */
+	.pcm_format = PLAT_STM_AUDIO__FORMAT_I2S |
+			PLAT_STM_AUDIO__DATA_SIZE_24_BITS,
+	.oversampling = 256,
+};
+
 static int __init device_init(void)
 {
 	unsigned int epld_rev;
@@ -229,11 +236,17 @@ static int __init device_init(void)
 	stx7200_configure_pwm(&pwm_private_info);
 	stx7200_configure_ssc(&ssc_private_info);
 	stx7200_configure_usb();
+	stx7200_configure_audio(&i2s_format, /* PCM reader data */
+				NULL, /* PCM player 0 */
+				NULL, /* PCM player 1 */
+				&i2s_format, /* PCM player 2 */
+				&i2s_format, /* PCM player 3 */
+				NULL); /* HDMI PCM player */
 	stx7200_configure_ethernet(0, 0, 1, 0);
 	// stx7200_configure_ethernet(1, 0, 1, 1);
-        stx7200_configure_lirc();
+	stx7200_configure_lirc();
 	stx7200_configure_nand(&mb519_nand_config);
-        
+
 	return platform_add_devices(mb519_devices, ARRAY_SIZE(mb519_devices));
 }
 arch_initcall(device_init);
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stb7100.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stb7100.c
@@ -804,6 +804,258 @@ static int __init stb7100_add_asc(void)
 }
 arch_initcall(stb7100_add_asc);
 
+/* Audio subsystem resources ----------------------------------------------- */
+
+/* Audio IO controls */
+
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs", /* sound/stm/audio_outputs.c */
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210200,
+			.end   = 0x19210203,
+		},
+	},
+};
+
+/* Frequency synthesizer */
+
+static struct platform_device fsynth = {
+	.name          = "fsynth", /* sound/stm/fsynth.c */
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210000,
+			.end   = 0x1921003f,
+		},
+	},
+};
+
+/* Internal DAC */
+
+static struct platform_device dac_internal = {
+	.name          = "dac_internal", /* sound/stm/dac_internal.c */
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210100,
+			.end   = 0x19210103,
+		},
+	},
+};
+
+/* PCM reader */
+
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader", /* sound/stm/pcm_reader.c */
+	.id            = -1,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18102000,
+			.end   = 0x18102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 146,
+			.end   = 146,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 1,
+			.end = 1,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			/* SOC version dependant,
+			 * see stx7100_configure_audio() function */
+		},
+	},
+};
+
+/* PCM players */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 0,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101000,
+			.end   = 0x18101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 144,
+			.end   = 144,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 1,
+			.end = 1,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			/* SOC version dependant,
+			 * see stx7100_configure_audio() function */
+		},
+	},
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 1,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101800,
+			.end   = 0x18101827,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 145,
+			.end   = 145,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 1,
+			.end = 1,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			/* SOC version dependant,
+			 * see stx7100_configure_audio() function */
+		},
+	},
+};
+
+/* SPDIF player */
+
+static struct platform_device spdif_player = {
+	.name          = "spdif_player", /* sound/stm/spdif_player.c */
+	.id            = -1,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103000,
+			.end   = 0x1810303f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 147,
+			.end   = 147,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 1,
+			.end = 1,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			/* SOC version dependant,
+			 * see stx7100_configure_audio() function */
+		},
+	},
+};
+
+/* Additional output devices */
+
+static struct platform_device i2s_spdif_converter = {
+	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103000,
+			.end   = 0x18103223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 142,
+			.end   = 142,
+		},
+	},
+};
+
+/* Audio subsystem runtime setup */
+
+static void __init set_resource(struct platform_device *device,
+	 unsigned int type, const char *name, unsigned int value)
+{
+	int i;
+
+	for (i = 0; i < device->num_resources; i++) {
+		struct resource *resource = &device->resource[i];
+
+		if (resource->flags == type &&
+				strcmp(resource->name, name) == 0) {
+			resource->start = value;
+			resource->end = value;
+		}
+	}
+}
+
+static struct platform_device *audio_devices[] __initdata = {
+	&audio_outputs,
+	&fsynth,
+	&pcm_reader,
+	&pcm_player_0,
+	&pcm_player_1,
+	&dac_internal,
+	&spdif_player,
+	&i2s_spdif_converter,
+};
+
+void __init stx7100_configure_audio(struct plat_audio_config *pcm_reader_config,
+		struct plat_audio_config *pcm_player_0_config,
+		struct plat_audio_config *pcm_player_1_config)
+{
+	pcm_reader.dev.platform_data = pcm_reader_config;
+	pcm_player_0.dev.platform_data = pcm_player_0_config;
+	pcm_player_1.dev.platform_data = pcm_player_1_config;
+	if (chip_7109) {
+		set_resource(&pcm_player_0, IORESOURCE_DMA, "request_line",
+				STB7109_FDMA_REQ_PCM_0);
+		set_resource(&pcm_player_1, IORESOURCE_DMA, "request_line",
+				STB7109_FDMA_REQ_PCM_1);
+		set_resource(&spdif_player, IORESOURCE_DMA, "request_line",
+				STB7109_FDMA_REQ_SPDIF);
+		set_resource(&pcm_reader, IORESOURCE_DMA, "request_line",
+				STB7109_FDMA_REQ_PCM_READ);
+	} else {
+		set_resource(&pcm_player_0, IORESOURCE_DMA, "request_line",
+				STB7100_FDMA_REQ_PCM_0);
+		set_resource(&pcm_player_1, IORESOURCE_DMA, "request_line",
+				STB7100_FDMA_REQ_PCM_1);
+		set_resource(&spdif_player, IORESOURCE_DMA, "request_line",
+				STB7100_FDMA_REQ_SPDIF);
+		set_resource(&pcm_reader, IORESOURCE_DMA, "request_line",
+				STB7100_FDMA_REQ_PCM_READ);
+	}
+	platform_add_devices(audio_devices, ARRAY_SIZE(audio_devices));
+}
+
+
 /* Early resources (sysconf and PIO) --------------------------------------- */
 
 static struct platform_device sysconf_device = {
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stx7200.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/sh4/setup-stx7200.c
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stx7200.c
@@ -925,6 +925,446 @@ static int __init stb7200_add_asc(void)
 }
 arch_initcall(stb7200_add_asc);
 
+/* Audio subsystem resources ----------------------------------------------- */
+
+/* Audio outputs control */
+
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs", /* sound/stm/audio_outputs.c */
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601200,
+			.end   = 0xfd60120b,
+		},
+	}
+};
+
+/* Frequency synthesizers */
+
+static struct platform_device fsynth_0 = {
+	.name          = "fsynth", /* sound/stm/fsynth.c */
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601000,
+			.end   = 0xfd60104f,
+		},
+	},
+};
+
+static struct platform_device fsynth_1 = {
+	.name          = "fsynth", /* sound/stm/fsynth.c */
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601100,
+			.end   = 0xfd60114f,
+		},
+	},
+};
+
+/* PCM reader */
+
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader", /* sound/stm/pcm_reader.c */
+	.id            = -1,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd100000,
+			.end   = 0xfd100027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(38),
+			.end   = ILC_IRQ(38),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_PCMIN,
+			.end   = STB7200_FDMA_REQ_PCMIN,
+		},
+	},
+};
+
+/* Internal DACs */
+
+static struct platform_device dac_internal_0 = {
+	.name          = "dac_internal", /* sound/stm/dac_internal.c */
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601400,
+			.end   = 0xfd601403,
+		},
+	},
+};
+
+static struct platform_device dac_internal_1 = {
+	.name          = "dac_internal", /* sound/stm/dac_internal.c */
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601500,
+			.end   = 0xfd601503,
+		},
+	},
+};
+
+/* PCM players connected to internal DACs */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 0,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd101000,
+			.end   = 0xfd101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(39),
+			.end   = ILC_IRQ(39),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_PCM0,
+			.end   = STB7200_FDMA_REQ_PCM0,
+		},
+	},
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 1,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd102000,
+			.end   = 0xfd102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(40),
+			.end   = ILC_IRQ(40),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_PCM1,
+			.end   = STB7200_FDMA_REQ_PCM1,
+		},
+	},
+};
+
+/* PCM players with digital outputs */
+
+static struct platform_device pcm_player_2 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 2,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd103000,
+			.end   = 0xfd103027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(41),
+			.end   = ILC_IRQ(41),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_PCM2,
+			.end   = STB7200_FDMA_REQ_PCM2,
+		},
+	},
+};
+
+static struct platform_device pcm_player_3 = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 3,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104000,
+			.end   = 0xfd104027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(42),
+			.end   = ILC_IRQ(42),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_PCM3,
+			.end   = STB7200_FDMA_REQ_PCM3,
+		},
+	},
+};
+
+/* SPDIF player */
+
+static struct platform_device spdif_player = {
+	.name          = "spdif_player", /* sound/stm/spdif_player.c */
+	.id            = 0,
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105000,
+			.end   = 0xfd10503f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(37),
+			.end   = ILC_IRQ(37),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_SPDIF,
+			.end   = STB7200_FDMA_REQ_SPDIF,
+		}
+	},
+};
+
+/* HDMI output devices
+ * Please note that "HDTVOutBaseAddress" (0xFD10C000) from page 54 of
+ * "7200 Programming Manual, Volume 2" is wrong. The correct HDMI players
+ * subsystem base address is "HDMIPlayerBaseAddress" (0xFD106000) from
+ * page 488 of the manual. */
+
+static struct platform_device hdmi_pcm_player = {
+	.name          = "pcm_player", /* sound/stm/pcm_player.c */
+	.id            = 4, /* HDMI PCM player is no. 4 */
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd106d00,
+			.end   = 0xfd106d27,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(62),
+			.end   = ILC_IRQ(62),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_HDMI_PCM,
+			.end   = STB7200_FDMA_REQ_HDMI_PCM,
+		},
+	},
+};
+
+static struct platform_device hdmi_spdif_player = {
+	.name          = "spdif_player", /* sound/stm/spdif_player.c */
+	.id            = 1, /* HDMI SPDIF player is no. 1 */
+	.num_resources = 4,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd106c00,
+			.end   = 0xfd106c3f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(63),
+			.end   = ILC_IRQ(63),
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "initiator",
+			.start = 0,
+			.end = 0,
+		},
+		{
+			.flags = IORESOURCE_DMA,
+			.name = "request_line",
+			.start = STB7200_FDMA_REQ_HDMI_SPDIF,
+			.end   = STB7200_FDMA_REQ_HDMI_SPDIF,
+		}
+	},
+};
+
+static struct platform_device hdmi_i2s_spdif_converter_0 = {
+	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107000,
+			.end   = 0xfd107223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(64),
+			.end   = ILC_IRQ(64),
+		}
+	},
+};
+
+static struct platform_device hdmi_i2s_spdif_converter_1 = {
+	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107400,
+			.end   = 0xfd107623,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(65),
+			.end   = ILC_IRQ(65),
+		}
+	},
+};
+
+static struct platform_device hdmi_i2s_spdif_converter_2 = {
+	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107800,
+			.end   = 0xfd107a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(66),
+			.end   = ILC_IRQ(66),
+		}
+	},
+};
+
+static struct platform_device hdmi_i2s_spdif_converter_3 = {
+	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107c00,
+			.end   = 0xfd107e23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(67),
+			.end   = ILC_IRQ(67),
+		}
+	},
+};
+
+static struct platform_device *audio_devices[] __initdata = {
+	&audio_outputs,
+	&fsynth_0,
+	&fsynth_1,
+	&pcm_reader,
+	&dac_internal_0,
+	&dac_internal_1,
+	&pcm_player_0,
+	&pcm_player_1,
+	&pcm_player_2,
+	&pcm_player_3,
+	&spdif_player,
+	&hdmi_pcm_player,
+	&hdmi_spdif_player,
+	&hdmi_i2s_spdif_converter_0,
+	&hdmi_i2s_spdif_converter_1,
+	&hdmi_i2s_spdif_converter_2,
+	&hdmi_i2s_spdif_converter_3,
+};
+
+void __init stx7200_configure_audio(struct plat_audio_config *pcm_reader_config,
+		struct plat_audio_config *pcm_player_0_config,
+		struct plat_audio_config *pcm_player_1_config,
+		struct plat_audio_config *pcm_player_2_config,
+		struct plat_audio_config *pcm_player_3_config,
+		struct plat_audio_config *hdmi_pcm_player_config)
+{
+	/* Cut 2.0 presumably will bring something new into the matter,
+	 * so above configuration must be checked! */
+	WARN_ON(chip_revision > 1);
+
+	pcm_reader.dev.platform_data = pcm_reader_config;
+	pcm_player_0.dev.platform_data = pcm_player_0_config;
+	pcm_player_1.dev.platform_data = pcm_player_1_config;
+	pcm_player_2.dev.platform_data = pcm_player_2_config;
+	pcm_player_3.dev.platform_data = pcm_player_3_config;
+	hdmi_pcm_player.dev.platform_data = hdmi_pcm_player_config;
+
+	platform_add_devices(audio_devices, ARRAY_SIZE(audio_devices));
+}
+
 /* Early resources (sysconf and PIO) --------------------------------------- */
 
 static struct platform_device sysconf_device = {
Index: linux-2.6.23-stm/include/linux/stm/registers.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers.h
+++ linux-2.6.23-stm/include/linux/stm/registers.h
@@ -89,6 +89,7 @@ static inline void regfield_poke(void *b
 
 #include <linux/stm/registers/aud_pcmin.h>
 #include <linux/stm/registers/aud_pcmout.h>
+#include <linux/stm/registers/aud_spdif.h>
 #include <linux/stm/registers/audcfg.h>
 #include <linux/stm/registers/audcfg_adac.h>
 #include <linux/stm/registers/audcfg_fsyn.h>
Index: linux-2.6.23-stm/include/linux/stm/registers/aud_pcmin.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/aud_pcmin.h
+++ linux-2.6.23-stm/include/linux/stm/registers/aud_pcmin.h
@@ -3,128 +3,169 @@
 
 
 
-#define AUD_PCMIN__RST 0x00
+#define AUD_PCMIN_RST 0x00
 
-#define AUD_PCMIN__RST__RSTP__SHIFT 0
-#define AUD_PCMIN__RST__RSTP__MASK  0x00000001
+#define AUD_PCMIN_RST__RSTP__SHIFT          0
+#define AUD_PCMIN_RST__RSTP__MASK           0x1
+#define AUD_PCMIN_RST__RSTP__VALUE__RUNNING 0x0
+#define AUD_PCMIN_RST__RSTP__VALUE__RESET   0x1
 
 
 
-#define AUD_PCMIN__DATA 0x04
+#define AUD_PCMIN_DATA 0x04
 
-#define AUD_PCMIN__DATA__DATA__SHIFT 0
-#define AUD_PCMIN__DATA__DATA__MASK  0xffffffff
+#define AUD_PCMIN_DATA__DATA__SHIFT 0
+#define AUD_PCMIN_DATA__DATA__MASK  0xffffffff
 
 
 
-#define AUD_PCMIN__ITS 0x08
+#define AUD_PCMIN_ITS 0x08
 
-#define AUD_PCMIN__ITS__OVF__SHIFT 0
-#define AUD_PCMIN__ITS__OVF__MASK  0x00000001
+#define AUD_PCMIN_ITS__OVF__SHIFT          0
+#define AUD_PCMIN_ITS__OVF__MASK           0x1
+#define AUD_PCMIN_ITS__OVF__VALUE__PENDING 0x1
 
-#define AUD_PCMIN__ITS__VSYNC__SHIFT 1
-#define AUD_PCMIN__ITS__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_ITS__VSYNC__SHIFT          1
+#define AUD_PCMIN_ITS__VSYNC__MASK           0x1
+#define AUD_PCMIN_ITS__VSYNC__VALUE__PENDING 0x1
 
 
 
-#define AUD_PCMIN__ITS_CLR 0x0c
+#define AUD_PCMIN_ITS_CLR 0x0c
 
-#define AUD_PCMIN__ITS_CLR__OVF__SHIFT 0
-#define AUD_PCMIN__ITS_CLR__OVF__MASK  0x00000001
+#define AUD_PCMIN_ITS_CLR__OVF__SHIFT        0
+#define AUD_PCMIN_ITS_CLR__OVF__MASK         0x1
+#define AUD_PCMIN_ITS_CLR__OVF__VALUE__CLEAR 0x1
 
-#define AUD_PCMIN__ITS_CLR__VSYNC__SHIFT 1
-#define AUD_PCMIN__ITS_CLR__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_ITS_CLR__VSYNC__SHIFT       1
+#define AUD_PCMIN_ITS_CLR__VSYNC__MASK        0x1
+#define AUD_PCMIN_ITS_CLR__VSYNC__VALUE_CLEAR 0x1
 
 
 
-#define AUD_PCMIN__IT_EN 0x10
+#define AUD_PCMIN_IT_EN 0x10
 
-#define AUD_PCMIN__IT_EN__OVF__SHIFT 0
-#define AUD_PCMIN__IT_EN__OVF__MASK  0x00000001
+#define AUD_PCMIN_IT_EN__OVF__SHIFT           0
+#define AUD_PCMIN_IT_EN__OVF__MASK            0x1
+#define AUD_PCMIN_IT_EN__OVF__VALUE__DISABLED 0x0
+#define AUD_PCMIN_IT_EN__OVF__VALUE__ENABLED  0x1
 
-#define AUD_PCMIN__IT_EN__VSYNC__SHIFT 1
-#define AUD_PCMIN__IT_EN__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_IT_EN__VSYNC__SHIFT           1
+#define AUD_PCMIN_IT_EN__VSYNC__MASK            0x1
+#define AUD_PCMIN_IT_EN__VSYNC__VALUE__DISABLED 0x0
+#define AUD_PCMIN_IT_EN__VSYNC__VALUE__ENABLED  0x1
 
 
 
-#define AUD_PCMIN__IT_EN_SET 0x14
+#define AUD_PCMIN_IT_EN_SET 0x14
 
-#define AUD_PCMIN__IT_EN_SET__OVF__SHIFT 0
-#define AUD_PCMIN__IT_EN_SET__OVF__MASK  0x00000001
+#define AUD_PCMIN_IT_EN_SET__OVF__SHIFT      0
+#define AUD_PCMIN_IT_EN_SET__OVF__MASK       0x1
+#define AUD_PCMIN_IT_EN_SET__OVF__VALUE__SET 0x1
 
-#define AUD_PCMIN__IT_EN_SET__VSYNC__SHIFT 1
-#define AUD_PCMIN__IT_EN_SET__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_IT_EN_SET__VSYNC__SHIFT      1
+#define AUD_PCMIN_IT_EN_SET__VSYNC__MASK       0x1
+#define AUD_PCMIN_IT_EN_SET__VSYNC__VALUE__SET 0x1
 
 
 
-#define AUD_PCMIN__IT_EN_CLR 0x18
+#define AUD_PCMIN_IT_EN_CLR 0x18
 
-#define AUD_PCMIN__IT_EN_CLR__OVF__SHIFT 0
-#define AUD_PCMIN__IT_EN_CLR__OVF__MASK  0x00000001
+#define AUD_PCMIN_IT_EN_CLR__OVF__SHIFT        0
+#define AUD_PCMIN_IT_EN_CLR__OVF__MASK         0x1
+#define AUD_PCMIN_IT_EN_CLR__OVF__VALUE__CLEAR 0x1
 
-#define AUD_PCMIN__IT_EN_CLR__VSYNC__SHIFT 1
-#define AUD_PCMIN__IT_EN_CLR__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_IT_EN_CLR__VSYNC__SHIFT        1
+#define AUD_PCMIN_IT_EN_CLR__VSYNC__MASK         0x1
+#define AUD_PCMIN_IT_EN_CLR__VSYNC__VALUE__CLEAR 0x1
 
 
 
-#define AUD_PCMIN__CTRL 0x1c
+#define AUD_PCMIN_CTRL 0x1c
 
-#define AUD_PCMIN__CTRL__MODE__SHIFT 0
-#define AUD_PCMIN__CTRL__MODE__MASK  0x00000003
+#define AUD_PCMIN_CTRL__MODE__SHIFT       0
+#define AUD_PCMIN_CTRL__MODE__MASK        0x3
+#define AUD_PCMIN_CTRL__MODE__VALUE__OFF  0x0
+#define AUD_PCMIN_CTRL__MODE__VALUE__PCM  0x2
+#define AUD_PCMIN_CTRL__MODE__VALUE__CD   0x3
 
-#define AUD_PCMIN__CTRL__MEM_FMT__SHIFT 2
-#define AUD_PCMIN__CTRL__MEM_FMT__MASK  0x00000001
+#define AUD_PCMIN_CTRL__MEM_FMT__SHIFT                  2
+#define AUD_PCMIN_CTRL__MEM_FMT__MASK                   0x1
+#define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
+#define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
 
-#define AUD_PCMIN__CTRL__RND__SHIFT 3
-#define AUD_PCMIN__CTRL__RND__MASK  0x00000001
+#define AUD_PCMIN_CTRL__RND__SHIFT                   3
+#define AUD_PCMIN_CTRL__RND__MASK                    0x1
+#define AUD_PCMIN_CTRL__RND__VALUE__NO_ROUNDING      0x0
+#define AUD_PCMIN_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
 
-#define AUD_PCMIN__CTRL__NUM_FRAMES__SHIFT 4
-#define AUD_PCMIN__CTRL__NUM_FRAMES__MASK  0x0fffffff
+#define AUD_PCMIN_CTRL__NUM_FRAMES__SHIFT 4
+#define AUD_PCMIN_CTRL__NUM_FRAMES__MASK  0xfffffff
 
 
 
 
-#define AUD_PCMIN__STA 0x20
+#define AUD_PCMIN_STA 0x20
 
-#define AUD_PCMIN__STA__RUN_STOP__SHIFT 0
-#define AUD_PCMIN__STA__RUN_STOP__MASK  0x00000001
+#define AUD_PCMIN_STA__RUN_STOP__SHIFT          0
+#define AUD_PCMIN_STA__RUN_STOP__MASK           0x1
+#define AUD_PCMIN_STA__RUN_STOP__VALUE__STOPPED 0x0
+#define AUD_PCMIN_STA__RUN_STOP__VALUE__RUNNING 0x1
 
-#define AUD_PCMIN__STA__OVF__SHIFT 1
-#define AUD_PCMIN__STA__OVF__MASK  0x00000001
+#define AUD_PCMIN_STA__OVF__SHIFT                    1
+#define AUD_PCMIN_STA__OVF__MASK                     0x1
+#define AUD_PCMIN_STA__OVF__VALUE__OVERFLOW_DETECTED 0x1
 
-#define AUD_PCMIN__STA__SAMPL_CNT__SHIFT 2
-#define AUD_PCMIN__STA__SAMPL_CNT__MASK  0x0000ffff
+#define AUD_PCMIN_STA__SAMPL_CNT__SHIFT 2
+#define AUD_PCMIN_STA__SAMPL_CNT__MASK  0xffff
 
-#define AUD_PCMIN__STA__VSYNC__SHIFT 18
-#define AUD_PCMIN__STA__VSYNC__MASK  0x00000001
+#define AUD_PCMIN_STA__VSYNC__SHIFT 18
+#define AUD_PCMIN_STA__VSYNC__MASK  0x1
 
-#define AUD_PCMIN__STA__NFRAMES__SHIFT 19
-#define AUD_PCMIN__STA__NFRAMES__MASK  0x00000001
+#define AUD_PCMIN_STA__NFRAMES__SHIFT       19
+#define AUD_PCMIN_STA__NFRAMES__MASK        0x1
+#define AUD_PCMIN_STA__NFRAMES__VALUE__DONE 0x1
 
 
 
-#define AUD_PCMIN__FMT 0x24
+#define AUD_PCMIN_FMT 0x24
 
-#define AUD_PCMIN__FMT__NBIT__SHIFT 0
-#define AUD_PCMIN__FMT__NBIT__MASK  0x00000001
+#define AUD_PCMIN_FMT__NBIT__SHIFT          0
+#define AUD_PCMIN_FMT__NBIT__MASK           0x1
+#define AUD_PCMIN_FMT__NBIT__VALUE__32_BITS 0x0
+#define AUD_PCMIN_FMT__NBIT__VALUE__16_BITS 0x1
 
-#define AUD_PCMIN__FMT__DATA_SIZE__SHIFT 1
-#define AUD_PCMIN__FMT__DATA_SIZE__MASK  0x00000003
+#define AUD_PCMIN_FMT__DATA_SIZE__SHIFT          1
+#define AUD_PCMIN_FMT__DATA_SIZE__MASK           0x3
+#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__24_BITS 0x0
+#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__20_BITS 0x1
+#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__18_BITS 0x2
+#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__16_BITS 0x3
 
-#define AUD_PCMIN__FMT__LR_POL__SHIFT 3
-#define AUD_PCMIN__FMT__LR_POL__MASK  0x00000001
+#define AUD_PCMIN_FMT__LR_POL__SHIFT            3
+#define AUD_PCMIN_FMT__LR_POL__MASK             0x1
+#define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_LOW  0x0
+#define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
 
-#define AUD_PCMIN__FMT__SCLK_EDGE__SHIFT 4
-#define AUD_PCMIN__FMT__SCLK_EDG__MASK  0x00000001
+#define AUD_PCMIN_FMT__SCLK_EDGE__SHIFT          4
+#define AUD_PCMIN_FMT__SCLK_EDGE__MASK           0x1
+#define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__RISING  0x0
+#define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__FALLING 0x1
 
-#define AUD_PCMIN__FMT__PADDING__SHIFT 5
-#define AUD_PCMIN__FMT__PADDING__MASK  0x00000001
+#define AUD_PCMIN_FMT__PADDING__SHIFT                5
+#define AUD_PCMIN_FMT__PADDING__MASK                 0x1
+#define AUD_PCMIN_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
+#define AUD_PCMIN_FMT__PADDING__VALUE__NO_DELAY      0x1
 
-#define AUD_PCMIN__FMT__ALIGN__SHIFT 6
-#define AUD_PCMIN__FMT__ALIGN__MASK  0x00000001
+#define AUD_PCMIN_FMT__ALIGN__SHIFT        6
+#define AUD_PCMIN_FMT__ALIGN__MASK         0x1
+#define AUD_PCMIN_FMT__ALIGN__VALUE__RIGHT 0x0
+#define AUD_PCMIN_FMT__ALIGN__VALUE__LEFT  0x1
 
-#define AUD_PCMIN__FMT__ORDER__SHIFT 7
-#define AUD_PCMIN__FMT__ORDER__MASK  0x00000001
+#define AUD_PCMIN_FMT__ORDER__SHIFT            7
+#define AUD_PCMIN_FMT__ORDER__MASK             0x1
+#define AUD_PCMIN_FMT__ORDER__VALUE__LSB_FIRST 0x0
+#define AUD_PCMIN_FMT__ORDER__VALUE__MSB_FIRST 0x1
 
 
 
Index: linux-2.6.23-stm/include/linux/stm/registers/aud_pcmout.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/aud_pcmout.h
+++ linux-2.6.23-stm/include/linux/stm/registers/aud_pcmout.h
@@ -109,7 +109,7 @@
 #define AUD_PCMOUT_CTRL__SPDIF_LAT__VALUE__WAIT_FOR_SPDIF 0x1
 
 #define AUD_PCMOUT_CTRL__NSAMPLE__SHIFT 13
-#define AUD_PCMOUT_CTRL__NSAMPLE__MASK  0x0007ffff
+#define AUD_PCMOUT_CTRL__NSAMPLE__MASK  0x7ffff
 
 
 
@@ -120,9 +120,9 @@
 #define AUD_PCMOUT_STA__RUN_STOP__VALUE__STOPPED 0x0
 #define AUD_PCMOUT_STA__RUN_STOP__VALUE__RUNNING 0x1
 
-#define AUD_PCMOUT_STA__UNF__SHIFT                     1
-#define AUD_PCMOUT_STA__UNF__MASK                      0x1
-#define AUD_PCMOUT_STA__UNF__VALUE__UNDERFLOW_DETECTED 0x1
+#define AUD_PCMOUT_STA__UNF__SHIFT           1
+#define AUD_PCMOUT_STA__UNF__MASK            0x1
+#define AUD_PCMOUT_STA__UNF__VALUE__DETECTED 0x1
 
 #define AUD_PCMOUT_STA__NSAMPLE__SHIFT       2
 #define AUD_PCMOUT_STA__NSAMPLE__MASK        0x1
Index: linux-2.6.23-stm/include/linux/stm/registers/aud_spdif.h
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/include/linux/stm/registers/aud_spdif.h
@@ -0,0 +1,316 @@
+#ifndef __STM_REGISTERS_AUD_SPDIF_H
+#define __STM_REGISTERS_AUD_SPDIF_H
+
+
+
+#define AUD_SPDIF_RST 0x00
+
+#define AUD_SPDIF_RST__SRSTP__SHIFT          0
+#define AUD_SPDIF_RST__SRSTP__MASK           0x1
+#define AUD_SPDIF_RST__SRSTP__VALUE__RUNNING 0x0
+#define AUD_SPDIF_RST__SRSTP__VALUE__RESET   0x1
+
+
+
+#define AUD_SPDIF_DATA 0x04
+
+#define AUD_SPDIF_DATA__DATA__SHIFT 0
+#define AUD_SPDIF_DATA__DATA__MASK  0xffffffff
+
+
+
+#define AUD_SPDIF_ITS 0x08
+
+#define AUD_SPDIF_ITS__UNF__SHIFT          0
+#define AUD_SPDIF_ITS__UNF__MASK           0x1
+#define AUD_SPDIF_ITS__UNF__VALUE__PENDING 0x1
+
+#define AUD_SPDIF_ITS__EOBURST__SHIFT          1
+#define AUD_SPDIF_ITS__EOBURST__MASK           0x1
+#define AUD_SPDIF_ITS__EOBURST__VALUE__PENDING 0x1
+
+#define AUD_SPDIF_ITS__EOBLOCK__SHIFT          2
+#define AUD_SPDIF_ITS__EOBLOCK__MASK           0x1
+#define AUD_SPDIF_ITS__EOBLOCK__VALUE__PENDING 0x1
+
+#define AUD_SPDIF_ITS__EOLATENCY__SHIFT          3
+#define AUD_SPDIF_ITS__EOLATENCY__MASK           0x1
+#define AUD_SPDIF_ITS__EOLATENCY__VALUE__PENDING 0x1
+
+#define AUD_SPDIF_ITS__EOPD__SHIFT          4
+#define AUD_SPDIF_ITS__EOPD__MASK           0x1
+#define AUD_SPDIF_ITS__EOPD__VALUE__PENDING 0x1
+
+#define AUD_SPDIF_ITS__NSAMPLE__SHIFT          5
+#define AUD_SPDIF_ITS__NSAMPLE__MASK           0x1
+#define AUD_SPDIF_ITS__NSAMPLE__VALUE__PENDING 0x1
+
+
+
+#define AUD_SPDIF_ITS_CLR 0x0c
+
+#define AUD_SPDIF_ITS_CLR__UNF__SHIFT        0
+#define AUD_SPDIF_ITS_CLR__UNF__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__UNF__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_ITS_CLR__EOBURST__SHIFT        1
+#define AUD_SPDIF_ITS_CLR__EOBURST__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__EOBURST__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_ITS_CLR__EOBLOCK__SHIFT        2
+#define AUD_SPDIF_ITS_CLR__EOBLOCK__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__EOBLOCK__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_ITS_CLR__EOLATENCY__SHIFT        3
+#define AUD_SPDIF_ITS_CLR__EOLATENCY__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__EOLATENCY__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_ITS_CLR__EOPD__SHIFT        4
+#define AUD_SPDIF_ITS_CLR__EOPD__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__EOPD__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_ITS_CLR__NSAMPLE__SHIFT        5
+#define AUD_SPDIF_ITS_CLR__NSAMPLE__MASK         0x1
+#define AUD_SPDIF_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
+
+
+
+#define AUD_SPDIF_IT_EN 0x10
+
+#define AUD_SPDIF_IT_EN__UNF__SHIFT           0
+#define AUD_SPDIF_IT_EN__UNF__MASK            0x1
+#define AUD_SPDIF_IT_EN__UNF__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__UNF__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_IT_EN__EOBURST__SHIFT           1
+#define AUD_SPDIF_IT_EN__EOBURST__MASK            0x1
+#define AUD_SPDIF_IT_EN__EOBURST__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__EOBURST__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_IT_EN__EOBLOCK__SHIFT           2
+#define AUD_SPDIF_IT_EN__EOBLOCK__MASK            0x1
+#define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_IT_EN__EOLATENCY__SHIFT           3
+#define AUD_SPDIF_IT_EN__EOLATENCY__MASK            0x1
+#define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__ENABLED 0x1
+
+#define AUD_SPDIF_IT_EN__EOPD__SHIFT           4
+#define AUD_SPDIF_IT_EN__EOPD__MASK            0x1
+#define AUD_SPDIF_IT_EN__EOPD__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__EOPD__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_IT_EN__NSAMPLE__SHIFT           5
+#define AUD_SPDIF_IT_EN__NSAMPLE__MASK            0x1
+#define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__DISABLED 0x0
+#define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__ENABLED  0x1
+
+
+
+#define AUD_SPDIF_IT_EN_SET 0x14
+
+#define AUD_SPDIF_IT_EN_SET__UNF__SHIFT      0
+#define AUD_SPDIF_IT_EN_SET__UNF__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__UNF__VALUE__SET 0x1
+
+#define AUD_SPDIF_IT_EN_SET__EOBURST__SHIFT      1
+#define AUD_SPDIF_IT_EN_SET__EOBURST__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__EOBURST__VALUE__SET 0x1
+
+#define AUD_SPDIF_IT_EN_SET__EOBLOCK__SHIFT      2
+#define AUD_SPDIF_IT_EN_SET__EOBLOCK__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__EOBLOCK__VALUE__SET 0x1
+
+#define AUD_SPDIF_IT_EN_SET__EOLATENCY__SHIFT      3
+#define AUD_SPDIF_IT_EN_SET__EOLATENCY__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__EOLATENCY__VALUE__SET 0x1
+
+#define AUD_SPDIF_IT_EN_SET__EOPD__SHIFT      4
+#define AUD_SPDIF_IT_EN_SET__EOPD__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__EOPD__VALUE__SET 0x1
+
+#define AUD_SPDIF_IT_EN_SET__NSAMPLE__SHIFT      5
+#define AUD_SPDIF_IT_EN_SET__NSAMPLE__MASK       0x1
+#define AUD_SPDIF_IT_EN_SET__NSAMPLE__VALUE__SET 0x1
+
+
+
+#define AUD_SPDIF_IT_EN_CLR 0x18
+
+#define AUD_SPDIF_IT_EN_CLR__UNF__SHIFT        0
+#define AUD_SPDIF_IT_EN_CLR__UNF__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__UNF__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_IT_EN_CLR__EOBURST__SHIFT        1
+#define AUD_SPDIF_IT_EN_CLR__EOBURST__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__EOBURST__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__SHIFT        2
+#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__SHIFT        3
+#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_IT_EN_CLR__EOPD__SHIFT        4
+#define AUD_SPDIF_IT_EN_CLR__EOPD__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__EOPD__VALUE__CLEAR 0x1
+
+#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__SHIFT        5
+#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__MASK         0x1
+#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__VALUE__CLEAR 0x1
+
+
+
+#define AUD_SPDIF_CTRL 0x1c
+
+#define AUD_SPDIF_CTRL__MODE__SHIFT                    0
+#define AUD_SPDIF_CTRL__MODE__MASK                     0x7
+#define AUD_SPDIF_CTRL__MODE__VALUE__OFF               0x0
+#define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PCM_NULL     0x1
+#define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PAUSE_BURSTS 0x2
+#define AUD_SPDIF_CTRL__MODE__VALUE__PCM               0x3
+#define AUD_SPDIF_CTRL__MODE__VALUE__ENCODED           0x4
+
+#define AUD_SPDIF_CTRL__IDLE__SHIFT         3
+#define AUD_SPDIF_CTRL__IDLE__MASK          0x1
+#define AUD_SPDIF_CTRL__IDLE__VALUE__NORMAL 0x0
+#define AUD_SPDIF_CTRL__IDLE__VALUE__IDLE   0x1
+
+#define AUD_SPDIF_CTRL__RND__SHIFT                   4
+#define AUD_SPDIF_CTRL__RND__MASK                    0x1
+#define AUD_SPDIF_CTRL__RND__VALUE__NO_ROUNDING      0x0
+#define AUD_SPDIF_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
+
+#define AUD_SPDIF_CTRL__CLK_DIV__SHIFT 5
+#define AUD_SPDIF_CTRL__CLK_DIV__MASK  0xff
+
+#define AUD_SPDIF_CTRL__STUFFING__SHIFT           14
+#define AUD_SPDIF_CTRL__STUFFING__MASK            0x1
+#define AUD_SPDIF_CTRL__STUFFING__VALUE__SOFTWARE 0x0
+#define AUD_SPDIF_CTRL__STUFFING__VALUE__HARDWARE 0x1
+
+#define AUD_SPDIF_CTRL__MEMREAD__SHIFT 15
+#define AUD_SPDIF_CTRL__MEMREAD__MASK  0x1ffff
+
+
+
+#define AUD_SPDIF_STA 0x20
+
+#define AUD_SPDIF_STA__RUN_STOP__SHIFT          0
+#define AUD_SPDIF_STA__RUN_STOP__MASK           0x1
+#define AUD_SPDIF_STA__RUN_STOP__VALUE__STOPPED 0x0
+#define AUD_SPDIF_STA__RUN_STOP__VALUE__RUNNING 0x1
+
+#define AUD_SPDIF_STA__UNF__SHIFT           1
+#define AUD_SPDIF_STA__UNF__MASK            0x1
+#define AUD_SPDIF_STA__UNF__VALUE__DETECTED 0x1
+
+#define AUD_SPDIF_STA__EOBURST__SHIFT      2
+#define AUD_SPDIF_STA__EOBURST__MASK       0x1
+#define AUD_SPDIF_STA__EOBURST__VALUE__END 0x1
+
+#define AUD_SPDIF_STA__EOBLOCK__SHIFT      3
+#define AUD_SPDIF_STA__EOBLOCK__MASK       0x1
+#define AUD_SPDIF_STA__EOBLOCK__VALUE__END 0x1
+
+#define AUD_SPDIF_STA__EOLATENCY__SHIFT                         4
+#define AUD_SPDIF_STA__EOLATENCY__MASK                          0x1
+#define AUD_SPDIF_STA__EOLATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
+
+#define AUD_SPDIF_STA__PDDATA__SHIFT       5
+#define AUD_SPDIF_STA__PDDATA__MASK        0x1
+#define AUD_SPDIF_STA__PDDATA__VALUE__SENT 0x1
+
+#define AUD_SPDIF_STA__NSAMPLE__SHIFT       6
+#define AUD_SPDIF_STA__NSAMPLE__MASK        0x1
+#define AUD_SPDIF_STA__NSAMPLE__VALUE__DONE 0x1
+
+#define AUD_SPDIF_STA__PABIT__SHIFT       7
+#define AUD_SPDIF_STA__PABIT__MASK        0xff
+
+#define AUD_SPDIF_STA__PDPAUSE__SHIFT       5
+#define AUD_SPDIF_STA__PDPAUSE__MASK        0x1
+#define AUD_SPDIF_STA__PDPAUSE__VALUE__SENT 0x1
+
+
+
+#define AUD_SPDIF_PA_PB 0x24
+
+#define AUD_SPDIF_PA_PB__PB__SHIFT 0
+#define AUD_SPDIF_PA_PB__PB__MASK  0xffff
+
+#define AUD_SPDIF_PA_PB__PA__SHIFT 16
+#define AUD_SPDIF_PA_PB__PA__MASK  0xffff
+
+
+
+#define AUD_SPDIF_PC_PD 0x28
+
+#define AUD_SPDIF_PC_PD__PD__SHIFT 0
+#define AUD_SPDIF_PC_PD__PD__MASK  0xffff
+
+#define AUD_SPDIF_PC_PD__PC__SHIFT 16
+#define AUD_SPDIF_PC_PD__PC__MASK  0xffff
+
+
+
+
+#define AUD_SPDIF_CL1 0x2c
+
+#define AUD_SPDIF_CL1__CL1__SHIFT 0
+#define AUD_SPDIF_CL1__CL1__MASK  0xffffffff
+
+
+
+#define AUD_SPDIF_CR1 0x30
+
+#define AUD_SPDIF_CR1__CR1__SHIFT 0
+#define AUD_SPDIF_CR1__CR1__MASK  0xffffffff
+
+
+
+#define AUD_SPDIF_CL2_CR2_UV 0x34
+
+#define AUD_SPDIF_CL2_CR2_UV__CL2__SHIFT 0
+#define AUD_SPDIF_CL2_CR2_UV__CL2__MASK  0xf
+
+#define AUD_SPDIF_CL2_CR2_UV__CR2__SHIFT 8
+#define AUD_SPDIF_CL2_CR2_UV__CR2__MASK  0xf
+
+#define AUD_SPDIF_CL2_CR2_UV__RV__SHIFT  16
+#define AUD_SPDIF_CL2_CR2_UV__RV__MASK   0x1
+
+#define AUD_SPDIF_CL2_CR2_UV__RU__SHIFT  17
+#define AUD_SPDIF_CL2_CR2_UV__RU__MASK   0x1
+
+#define AUD_SPDIF_CL2_CR2_UV__LV__SHIFT  18
+#define AUD_SPDIF_CL2_CR2_UV__LV__MASK   0x1
+
+#define AUD_SPDIF_CL2_CR2_UV__LU__SHIFT  19
+#define AUD_SPDIF_CL2_CR2_UV__LU__MASK   0x1
+
+
+
+#define AUD_SPDIF_PAU_LAT 0x38
+
+#define AUD_SPDIF_PAU_LAT__LAT__SHIFT 0
+#define AUD_SPDIF_PAU_LAT__LAT__MASK  0xffff
+
+#define AUD_SPDIF_PAU_LAT__NPD_BURST__SHIFT 16
+#define AUD_SPDIF_PAU_LAT__NPD_BURST__MASK  0xffff
+
+
+
+#define AUD_SPDIF_BST_FL 0x3c
+
+#define AUD_SPDIF_BST_FL__DBURST__SHIFT 0
+#define AUD_SPDIF_BST_FL__DBURST__MASK  0xffff
+
+#define AUD_SPDIF_BST_FL__PDBURST__SHIFT 16
+#define AUD_SPDIF_BST_FL__PDBURST__MASK  0xffff
+
+#endif
Index: linux-2.6.23-stm/include/linux/stm/registers/audcfg.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/audcfg.h
+++ linux-2.6.23-stm/include/linux/stm/registers/audcfg.h
@@ -7,7 +7,7 @@
 #include <linux/stm/registers/stx710x/audcfg.h>
 #endif
 
-#if CONFIG_CPU_SUBTYPE_STX7200
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
 #include <linux/stm/registers/stx7200/audcfg.h>
 #endif
 
Index: linux-2.6.23-stm/include/linux/stm/registers/audcfg_fsyn.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/audcfg_fsyn.h
+++ linux-2.6.23-stm/include/linux/stm/registers/audcfg_fsyn.h
@@ -52,12 +52,12 @@
 #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__BAD_REFERENCE       0x2
 #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_BAD_REFERENCE  0x3
 
-#if CONFIG_CPU_SUBTYPE_STX7200
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
 #define AUDCFG_FSYN_CFG__TST_CLK_SEL__SHIFT 18
 #define AUDCFG_FSYN_CFG__TST_CLK_SEL__MASK  0x3
 #endif
 
-#if CONFIG_CPU_SUBTYPE_STX7200
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
 #define AUDCFG_FSYN_CFG__TST_PCMDAT__SHIFT 20
 #define AUDCFG_FSYN_CFG__TST_PCMDAT__MASK  0xf
 #endif
@@ -65,7 +65,7 @@
 #ifdef CONFIG_CPU_SUBTYPE_STB7100
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
 #endif
-#if CONFIG_CPU_SUBTYPE_STX7200
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               24
 #endif
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
Index: linux-2.6.23-stm/include/linux/stm/registers/stx710x/audcfg.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/stx710x/audcfg.h
+++ linux-2.6.23-stm/include/linux/stm/registers/stx710x/audcfg.h
@@ -5,20 +5,30 @@
 
 #define AUDCFG_IO_CTRL 0x00
 
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT 0
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK  0x00000001
-
-#define AUDCFG_IO_CTRL__DATA0_EN__SHIFT 1
-#define AUDCFG_IO_CTRL__DATA0_EN__MASK  0x00000001
-
-#define AUDCFG_IO_CTRL__DATA1_EN__SHIFT 2
-#define AUDCFG_IO_CTRL__DATA1_EN__MASK  0x00000001
-
-#define AUDCFG_IO_CTRL__SPDIF_EN__SHIFT 3
-#define AUDCFG_IO_CTRL__SPDIF_EN__MASK  0x00000001
-
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__SHIFT 4
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__MASK  0x00000001
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__DATA0_EN__SHIFT         1
+#define AUDCFG_IO_CTRL__DATA0_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__DATA0_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__DATA0_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__DATA1_EN__SHIFT         2
+#define AUDCFG_IO_CTRL__DATA1_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__DATA1_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__DATA1_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__SPDIF_EN__SHIFT          3
+#define AUDCFG_IO_CTRL__SPDIF_EN__MASK           0x1
+#define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__DISABLE 0x0
+#define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__ENABLE  0x1
+
+#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__SHIFT               4
+#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__MASK                0x1
+#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__PCM_PLAYER   0x0
+#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__SPDIF_PLAYER 0x1
 
 
 
Index: linux-2.6.23-stm/include/linux/stm/registers/stx7200/audcfg.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/registers/stx7200/audcfg.h
+++ linux-2.6.23-stm/include/linux/stm/registers/stx7200/audcfg.h
@@ -7,8 +7,8 @@
 
 #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__SHIFT         0
 #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__MASK          0x1
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__INPUT  0x1
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x0
+#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
 
 #define AUDCFG_IOMUX_CTRL__DATA0_EN__SHIFT         1
 #define AUDCFG_IOMUX_CTRL__DATA0_EN__MASK          0x1
@@ -39,10 +39,10 @@
 #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__PCM_PLAYERS 0x0
 #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__HDMI        0x1
 
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__SHIFT       1
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__MASK        0x1
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_PCM   0x0
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_SPDIF 0x1
+#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__SHIFT              1
+#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__MASK               0x1
+#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_PCM_PLAYER   0x0
+#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_SPDIF_PLAYER 0x1
 
 
 
Index: linux-2.6.23-stm/include/linux/stm/soc.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/soc.h
+++ linux-2.6.23-stm/include/linux/stm/soc.h
@@ -111,6 +111,42 @@ struct nand_config_data {
 						/* 0 : otherwise		*/
 };
 
+
+
+/* Audio subsystem board level configuration -
+ * PCM formats & additional ALSA controls */
+struct plat_audio_config {
+	/* PCM format configuration - logical sum of PLAT_STM_AUDIO__*
+	 * flags listed below */
+	unsigned long pcm_format;
+
+	/* Required oversampling value (leave 0 to get default 256 ;-) */
+	unsigned int oversampling;
+};
+
+/* If CUSTOM bit is defined the rest of pcm_format will be treated
+ * as a AUD_PCMOUT_FMT register content and mirrored there; this
+ * is not recommended - be aware of chips differences (eg. hardware
+ * bug of inverted SCLK_EDGE on 7100 and _some_ cuts of 7109...) */
+#define PLAT_STM_AUDIO__CUSTOM          0x80000000
+/* Select data size & digital serial audio format; note that 0 describes
+ * I2S 24 bits mode, which is actually default :-) */
+#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS 0x00000000
+#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS 0x00000001
+#define PLAT_STM_AUDIO__DATA_SIZE_24_BITS       0x00000000
+#define PLAT_STM_AUDIO__DATA_SIZE_20_BITS       0x00000010
+#define PLAT_STM_AUDIO__DATA_SIZE_18_BITS       0x00000020
+#define PLAT_STM_AUDIO__DATA_SIZE_16_BITS       0x00000030
+#define PLAT_STM_AUDIO__FORMAT_I2S              0x00000000
+#define PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED   0x00000100
+#define PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED  0x00000200
+/* Bit masks for above settings */
+#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK    0x0000000f
+#define PLAT_STM_AUDIO__DATA_SIZE_MASK          0x000000f0
+#define PLAT_STM_AUDIO__FORMAT_MASK             0x00000f00
+
+
+
 void stx7100_early_device_init(void);
 void stb7100_configure_asc(const int *ascs, int num_ascs, int console);
 void sysconf_early_init(struct platform_device *pdev);
@@ -120,10 +156,12 @@ void stx7100_configure_sata(void);
 void stx7100_configure_pwm(struct plat_stm_pwm_data *data);
 void stx7100_configure_ssc(struct plat_ssc_data *data);
 void stx7100_configure_usb(void);
-void stx7100_configure_alsa(void);
 void stx7100_configure_ethernet(int rmii_mode, int ext_clk, int phy_bus);
 void stx7100_configure_lirc(void);
 void stx7100_configure_pata(int bank, int irq);
+void stx7100_configure_audio(struct plat_audio_config *pcm_reader_config,
+		struct plat_audio_config *pcm_player_0_config,
+		struct plat_audio_config *pcm_player_1_config);
 
 void stx7200_early_device_init(void);
 void stx7200_configure_asc(const int *ascs, int num_ascs, int console);
@@ -135,5 +173,11 @@ void stx7200_configure_ethernet(int mac,
 				int phy_bus);
 void stx7200_configure_lirc(void);
 void stx7200_configure_nand(struct nand_config_data *data);
+void stx7200_configure_audio(struct plat_audio_config *pcm_reader_config,
+		struct plat_audio_config *pcm_player_0_config,
+		struct plat_audio_config *pcm_player_1_config,
+		struct plat_audio_config *pcm_player_2_config,
+		struct plat_audio_config *pcm_player_3_config,
+		struct plat_audio_config *hdmi_pcm_player_config);
 
 #endif /* __LINUX_ST_SOC_H */
Index: linux-2.6.23-stm/sound/soc/Kconfig
===================================================================
--- linux-2.6.23-stm.orig/sound/soc/Kconfig
+++ linux-2.6.23-stm/sound/soc/Kconfig
@@ -32,4 +32,7 @@ source "sound/soc/sh/Kconfig"
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
+# STMicroelectronics' SoCs support
+source "sound/soc/stm/Kconfig"
+
 endmenu
Index: linux-2.6.23-stm/sound/soc/Makefile
===================================================================
--- linux-2.6.23-stm.orig/sound/soc/Makefile
+++ linux-2.6.23-stm/sound/soc/Makefile
@@ -2,3 +2,5 @@ snd-soc-core-objs := soc-core.o soc-dapm
 
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/ at91/ pxa/ s3c24xx/ sh/
+
+obj-$(CONFIG_SND_STM)   += stm/
\ No newline at end of file
Index: linux-2.6.23-stm/sound/soc/stm/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/Kconfig
@@ -0,0 +1,11 @@
+config SND_STM
+	tristate "STMicroelectronics SoCs support"
+	depends on SND
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200
+	select SND_PCM
+	select STM_DMA
+	help
+	  Say Y here for ALSA support on the STx710x & STx7200 families.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-stm.o
\ No newline at end of file
Index: linux-2.6.23-stm/sound/soc/stm/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_SND_STM) += snd-stm.o
+snd-stm-y := init.o common.o synchro.o
+snd-stm-$(CONFIG_CPU_SUBTYPE_STB7100) += stx710x.o
+snd-stm-$(CONFIG_CPU_SUBTYPE_STX7200) += stx7200.o
+snd-stm-y += audio_outputs.o dac.o dac_internal.o fsynth.o
+snd-stm-y += i2s-spdif_converter.o pcm_player.o pcm_reader.o spdif_player.o
Index: linux-2.6.23-stm/sound/soc/stm/audio_outputs.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/audio_outputs.c
@@ -0,0 +1,265 @@
+/*
+ *   STx7200 System-on-Chip audio outputs control driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 1 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Audio control instance structure
+ */
+
+struct snd_stm_audio_outputs {
+	struct resource *mem_region;
+
+	void *base;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_audio_outputs_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_audio_outputs *audio_outputs = entry->private_data;
+
+	snd_assert(audio_outputs, return);
+	snd_stm_magic_assert(audio_outputs, return);
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
+			REGISTER_PEEK(audio_outputs->base, AUDCFG_IO_CTRL));
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+	snd_iprintf(buffer, "AUDCFG_IOMUX_CTRL (offset 0x00) = 0x%08x\n",
+			REGISTER_PEEK(audio_outputs->base, AUDCFG_IOMUX_CTRL));
+	snd_iprintf(buffer, "AUDCFG_HDMI_CTRL (offset 0x04) = 0x%08x\n",
+			REGISTER_PEEK(audio_outputs->base, AUDCFG_HDMI_CTRL));
+	snd_iprintf(buffer, "AUDCFG_RECOVERY_CTRL (offset 0x08) = 0x%08x\n",
+			REGISTER_PEEK(audio_outputs->base,
+			AUDCFG_RECOVERY_CTRL));
+#endif
+}
+
+static int snd_stm_audio_outputs_register(struct snd_device *snd_device)
+{
+	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
+
+	snd_assert(audio_outputs, return -EINVAL);
+	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+
+	/* Enable audio outputs */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, ENABLE) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, ENABLE) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, OUTPUT));
+#endif
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&audio_outputs->proc_entry, "audio_outputs",
+			snd_stm_audio_outputs_dump_registers, audio_outputs);
+
+	return 0;
+}
+
+static int snd_stm_audio_outputs_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
+
+	snd_assert(audio_outputs, return -EINVAL);
+	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(audio_outputs->proc_entry);
+
+	/* Disable audio outputs */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, DISABLE) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, DISABLE) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, INPUT));
+#endif
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_audio_outputs_ops = {
+	.dev_register = snd_stm_audio_outputs_register,
+	.dev_disconnect = snd_stm_audio_outputs_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_component *component;
+	struct snd_stm_audio_outputs *audio_outputs;
+	const char *card_id;
+	struct snd_card *card;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	audio_outputs = kzalloc(sizeof(*audio_outputs), GFP_KERNEL);
+	if (!audio_outputs) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(audio_outputs);
+
+	result = snd_stm_memory_request(pdev, &audio_outputs->mem_region,
+			&audio_outputs->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	if (result == 0)
+		card = snd_stm_cards_get(card_id);
+	else
+		card = snd_stm_cards_default(&card_id);
+	snd_assert(card, return -EINVAL);
+	snd_printd("Audio output controls will be a member of a card '%s'\n",
+		card_id);
+
+	/* Register HDMI route control */
+
+	/* TODO */
+
+
+	/* ALSA component */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, audio_outputs,
+			&snd_stm_audio_outputs_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, audio_outputs);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
+error_memory_request:
+	snd_stm_magic_clear(audio_outputs);
+	kfree(audio_outputs);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_audio_outputs_remove(struct platform_device *pdev)
+{
+	struct snd_stm_audio_outputs *audio_outputs =
+			platform_get_drvdata(pdev);
+
+	snd_assert(audio_outputs, return -EINVAL);
+	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+
+	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
+
+	snd_stm_magic_clear(audio_outputs);
+	kfree(audio_outputs);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_audio_outputs_driver = {
+	.driver = {
+		.name = "audio_outputs",
+	},
+	.probe = snd_stm_audio_outputs_probe,
+	.remove = snd_stm_audio_outputs_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_audio_outputs_init(void)
+{
+	return platform_driver_register(&snd_stm_audio_outputs_driver);
+}
+
+void snd_stm_audio_outputs_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_audio_outputs_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/common.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/common.c
@@ -0,0 +1,543 @@
+/*
+ *   Helpful ;-) routines for STMicroelectronics' SoCs audio drivers
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/stm/soc.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+
+#undef TRACE
+#include "common.h"
+
+
+
+/*
+ * Cards management
+ */
+
+static struct snd_card *snd_stm_cards[SNDRV_CARDS];
+static struct snd_card *snd_stm_default;
+
+/* Card list initialization/cleanup */
+
+int __init snd_stm_cards_init(const char *driver, struct snd_stm_card *cards,
+		int num_cards)
+{
+	int result = 0;
+	int i;
+
+	for (i = 0; i < num_cards; i++) {
+		int card = cards[i].index;
+
+		snd_stm_cards[card] = snd_card_new(card, cards[i].id,
+				THIS_MODULE, 0);
+		if (snd_stm_cards[card] == NULL) {
+			snd_stm_cards_free();
+			result = -ENOMEM;
+			break;
+		}
+
+		if (snd_stm_default == NULL)
+			snd_stm_default = snd_stm_cards[i];
+
+		strcpy(snd_stm_cards[card]->driver, driver);
+		strcpy(snd_stm_cards[card]->shortname, cards[i].short_name);
+		strcpy(snd_stm_cards[card]->longname, cards[i].long_name);
+
+		snd_printd("Card %d ('%s') created:\n", card, cards[i].id);
+		snd_printd("- driver: %s,\n", snd_stm_cards[card]->driver);
+		snd_printd("- short name: %s,\n",
+				snd_stm_cards[card]->shortname);
+		snd_printd("- long name: %s.\n", snd_stm_cards[card]->longname);
+	}
+
+	return result;
+}
+
+int __init snd_stm_cards_register(void)
+{
+	int result = -ENODEV;
+	int i;
+
+	for (i = 0; i < SNDRV_CARDS; i++) {
+		if (snd_stm_cards[i]) {
+			result = snd_card_register(snd_stm_cards[i]);
+			if (result < 0) {
+				snd_stm_cards_free();
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+void snd_stm_cards_free(void)
+{
+	int i;
+
+	for (i = 0; i < SNDRV_CARDS; i++) {
+		if (snd_stm_cards[i]) {
+			snd_card_free(snd_stm_cards[i]);
+			snd_stm_cards[i] = NULL;
+		}
+	}
+}
+
+/* Card list access */
+
+struct snd_card __init *snd_stm_cards_get(const char *id)
+{
+	int i;
+
+	for (i = 0; i < SNDRV_CARDS; i++)
+		if (snd_stm_cards[i] &&
+				strcmp(snd_stm_cards[i]->id, id) == 0)
+			return snd_stm_cards[i];
+
+	snd_stm_printe("Unknown card %s requested!\n", id);
+	return NULL;
+}
+
+struct snd_card __init *snd_stm_cards_default(const char **id)
+{
+	if (snd_stm_default && id)
+		*id = snd_stm_default->id;
+
+	return snd_stm_default;
+}
+
+
+
+/*
+ * Components management
+ */
+
+static struct snd_stm_component *snd_stm_components;
+static int snd_stm_num_components;
+
+int __init snd_stm_components_init(struct snd_stm_component *components,
+		int num_components)
+{
+	snd_stm_components = components;
+	snd_stm_num_components = num_components;
+
+	return 0;
+}
+
+struct snd_stm_component __init *snd_stm_components_get(const char *bus_id)
+{
+	int i;
+
+	for (i = 0; i < snd_stm_num_components; i++)
+		if (strcmp(snd_stm_components[i].bus_id, bus_id) == 0)
+			return &snd_stm_components[i];
+
+	return NULL;
+}
+
+static int snd_stm_bus_id_match(struct device *device, void *bus_id)
+{
+	return strcmp(device->bus_id, bus_id) == 0;
+}
+
+struct device __init *snd_stm_device_get(const char *bus_id)
+{
+	return bus_find_device(&platform_bus_type, NULL,
+			(void *)bus_id, snd_stm_bus_id_match);
+}
+
+
+
+/*
+ * Component capabilities access
+ */
+
+int __init snd_stm_cap_set(struct snd_stm_component *component,
+		const char *name, union snd_stm_value value)
+{
+	int result = -1;
+	int i;
+
+	for (i = 0; i < component->num_caps; i++)
+		if (strcmp(name, component->caps[i].name) == 0) {
+			component->caps[i].value = value;
+			result = 0;
+			break;
+		}
+
+	return result;
+}
+
+int __init snd_stm_cap_get(struct snd_stm_component *component,
+		const char *name, union snd_stm_value *value)
+{
+	int result = -1;
+	int i;
+
+	for (i = 0; i < component->num_caps; i++)
+		if (strcmp(name, component->caps[i].name) == 0) {
+			*value = component->caps[i].value;
+			result = 0;
+			break;
+		}
+
+	return result;
+}
+
+int __init snd_stm_cap_get_number(struct snd_stm_component *component,
+		const char *name, int *number)
+{
+	union snd_stm_value value;
+	int result = snd_stm_cap_get(component, name, &value);
+
+	*number = value.number;
+	return result;
+}
+
+int __init snd_stm_cap_get_string(struct snd_stm_component *component,
+		const char *name, const char **string)
+{
+	union snd_stm_value value;
+	int result = snd_stm_cap_get(component, name, &value);
+
+	*string = value.string;
+	return result;
+}
+
+int __init snd_stm_cap_get_range(struct snd_stm_component *component,
+		const char *name, int *from, int *to)
+{
+	union snd_stm_value value;
+	int result = snd_stm_cap_get(component, name, &value);
+
+	*from = value.range.from;
+	*to = value.range.to;
+	return result;
+}
+
+int __init snd_stm_cap_get_list(struct snd_stm_component *component,
+		const char *name, int **numbers, int *len)
+{
+	union snd_stm_value value;
+	int result = snd_stm_cap_get(component, name, &value);
+
+	*numbers = value.list.numbers;
+	*len = value.list.len;
+	return result;
+}
+
+
+
+/*
+ * Resources management
+ */
+
+int __init snd_stm_memory_request(struct platform_device *pdev,
+		struct resource **mem_region, void **base_address)
+{
+	struct resource *resource;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to"
+				" platform_get_resource(IORESOURCE_MEM)!\n");
+		return -ENODEV;
+	}
+
+	*mem_region = request_mem_region(resource->start,
+			resource->end - resource->start + 1, pdev->name);
+	if (!*mem_region) {
+		snd_stm_printe("Failed request_mem_region(0x%08x,"
+				" 0x%08x, '%s')!\n", resource->start,
+				resource->end - resource->start + 1,
+				pdev->name);
+		return -EBUSY;
+	}
+	snd_printd("Memory region: 0x%08x-0x%08x\n",
+			(*mem_region)->start, (*mem_region)->end);
+
+	*base_address = ioremap(resource->start,
+			resource->end - resource->start + 1);
+	if (!*base_address) {
+		release_resource(*mem_region);
+		snd_stm_printe("Failed ioremap!\n");
+		return -EINVAL;
+	}
+
+	snd_stm_printt("Base address is 0x%p.\n", base_address);
+
+	return 0;
+}
+
+void snd_stm_memory_release(struct resource *mem_region,
+		void *base_address)
+{
+	iounmap(base_address);
+	release_resource(mem_region);
+}
+
+int  __init snd_stm_irq_request(struct platform_device *pdev,
+		unsigned int *irq, irq_handler_t handler, void *dev_id)
+{
+	struct resource *resource;
+	int result;
+
+	resource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to "
+				"platform_get_resource(IORESOURCE_IRQ)!\n");
+		return -ENODEV;
+	}
+	snd_printd("IRQ: %u\n", resource->start);
+
+	*irq = resource->start;
+
+	result = request_irq(*irq, handler, IRQF_DISABLED, pdev->name, dev_id);
+	if (result != 0) {
+		snd_stm_printe("Failed request_irq!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int __init snd_stm_fdma_request(struct platform_device *pdev,
+		int *channel, struct stm_dma_req **request,
+		struct stm_dma_req_config *config)
+{
+	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
+	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
+	static const char *fdma_cap_hb[] = { STM_DMA_CAP_HIGH_BW, NULL };
+	struct resource *resource;
+
+	*channel = request_dma_bycap(fdmac_id, fdma_cap_lb, pdev->name);
+	if (*channel < 0) {
+		*channel = request_dma_bycap(fdmac_id, fdma_cap_hb, pdev->name);
+		if (*channel < 0) {
+			snd_stm_printe("Failed to request_dma_bycap()==%d!\n",
+					*channel);
+			return -ENODEV;
+		}
+	}
+	snd_printd("FDMA channel: %d\n", *channel);
+
+	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
+			"initiator");
+	if (!resource) {
+		snd_stm_printe("Failed to platform_get_resource"
+				"(IORESOURCE_DMA, initiator)!\n");
+		return -ENODEV;
+	}
+	snd_printd("FDMA initiator: %u\n", resource->start);
+	config->initiator = resource->start;
+
+	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
+			"request_line");
+	if (!resource) {
+		snd_stm_printe("Failed to platform_get_resource"
+				"(IORESOURCE_DMA, request_line)!\n");
+		return -ENODEV;
+	}
+	snd_printd("FDMA request line: %u\n", resource->start);
+
+	*request = dma_req_config(*channel, resource->start, config);
+	if (!*request) {
+		snd_stm_printe("Failed to dma_req_config!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void snd_stm_fdma_release(unsigned int channel,
+		struct stm_dma_req *request)
+{
+	dma_req_free(channel, request);
+	free_dma(channel);
+}
+
+
+
+/*
+ * ALSA procfs additional entries
+ */
+
+static struct snd_info_entry *snd_stm_info_root;
+
+int __init snd_stm_info_init(void)
+{
+	int result = 0;
+
+	snd_stm_info_root = snd_info_create_module_entry(THIS_MODULE,
+			"stm", NULL);
+	if (snd_stm_info_root) {
+		snd_stm_info_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		if (snd_info_register(snd_stm_info_root) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(snd_stm_info_root);
+		}
+	} else {
+		result = -ENOMEM;
+	}
+
+	return result;
+}
+
+void snd_stm_info_cleanup(void)
+{
+	if (snd_stm_info_root)
+		snd_info_free_entry(snd_stm_info_root);
+}
+
+int snd_stm_info_register(struct snd_info_entry **entry,
+		const char *name,
+		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
+		void *private_data)
+{
+	int result = 0;
+
+	*entry = snd_info_create_module_entry(THIS_MODULE, name,
+			snd_stm_info_root);
+	if (*entry) {
+		(*entry)->c.text.read = read;
+		(*entry)->private_data = private_data;
+		if (snd_info_register(*entry) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(*entry);
+		}
+	} else {
+		result = -EINVAL;
+	}
+	return result;
+}
+
+void snd_stm_info_unregister(struct snd_info_entry *entry)
+{
+	if (entry)
+		snd_info_free_entry(entry);
+}
+
+
+
+/*
+ * PCM buffer memory mapping
+ */
+
+static struct page *snd_stm_mmap_nopage(struct vm_area_struct *area,
+		unsigned long address, int *type)
+{
+	/* No VMA expanding here! */
+	return NOPAGE_SIGBUS;
+}
+
+static struct vm_operations_struct snd_stm_mmap_vm_ops = {
+	.open =   snd_pcm_mmap_data_open,
+	.close =  snd_pcm_mmap_data_close,
+	.nopage = snd_stm_mmap_nopage,
+};
+
+int snd_stm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long map_offset = area->vm_pgoff << PAGE_SHIFT;
+	unsigned long phys_addr = runtime->dma_addr + map_offset;
+	unsigned long map_size = area->vm_end - area->vm_start;
+	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
+			runtime->dma_bytes % PAGE_SIZE;
+
+	snd_stm_printt("snd_stm_pcm_mmap(substream=0x%p)\n",
+			substream);
+
+	snd_stm_printt("Mmaping %lu bytes starting from 0x%08lx "
+			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
+			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
+			phys_addr, runtime->dma_addr, runtime->dma_bytes,
+			area->vm_pgoff, area->vm_start, area->vm_end);
+
+	if (map_size > phys_size) {
+		snd_stm_printe("Trying to perform mmap larger than buffer!\n");
+		return -EINVAL;
+	}
+
+	area->vm_ops = &snd_stm_mmap_vm_ops;
+	area->vm_private_data = substream;
+	area->vm_flags |= VM_RESERVED;
+	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+
+	if (remap_pfn_range(area, area->vm_start, phys_addr >> PAGE_SHIFT,
+			map_size, area->vm_page_prot) != 0) {
+		snd_stm_printe("Can't remap buffer!\n");
+		return -EAGAIN;
+	}
+
+	/* Must be called implicitly here... */
+	snd_pcm_mmap_data_open(area);
+
+	return 0;
+}
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+
+
+/*
+ * Debug features
+ */
+
+/* Memory dump function */
+
+void snd_stm_hex_dump(void *data, int size)
+{
+	unsigned char *buffer = data;
+	char line[57];
+	int i;
+
+	for (i = 0; i < size; i++) {
+		if (i % 16 == 0)
+			sprintf(line, "%p", data + i);
+		sprintf(line + 8 + ((i % 16) * 3), " %02x", *buffer++);
+		if (i % 16 == 15 || i == size - 1)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+}
Index: linux-2.6.23-stm/sound/soc/stm/common.h
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/common.h
@@ -0,0 +1,302 @@
+/*
+ * STMicroelectronics' System-on-Chips audio subsystem commons
+ */
+
+#ifndef __SOUND_STM_COMMON_H
+#define __SOUND_STM_COMMON_H
+
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/control.h>
+
+
+
+/*
+ * Audio DAC control interface
+ */
+
+int snd_stm_dac_get_config(struct device *device,
+		unsigned long *pcm_format, unsigned int *oversampling);
+int snd_stm_dac_shut_down(struct device *device);
+int snd_stm_dac_wake_up(struct device *device);
+int snd_stm_dac_mute(struct device *device);
+int snd_stm_dac_unmute(struct device *device);
+
+
+
+/*
+ * Audio frequency synthesizer interface
+ */
+
+int snd_stm_fsynth_set_frequency(struct device *device, int channel,
+		int frequency);
+
+int snd_stm_fsynth_add_adjustement_ctl(struct device *device, int channel,
+		struct snd_card *card, int card_device);
+
+
+
+/*
+ * Buffer memory mapping operation
+ */
+
+int snd_stm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area);
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+
+
+
+/*
+ * Cards management
+ */
+
+/* Card description */
+
+struct snd_stm_card {
+	int index;              /* card number */
+	const char *id;         /* unique, 15 chars max (plus '\0' as 16th) */
+	const char *short_name; /* 31 chars max (plus '\0' as 32nd) */
+	const char *long_name;  /* 79 chars max (plus '\0' as 80th) */
+};
+
+/* Card list initialization/cleanup */
+
+int __init snd_stm_cards_init(const char *device, struct snd_stm_card *cards,
+		int num_cards);
+int __init snd_stm_cards_register(void);
+void snd_stm_cards_free(void);
+
+/* Card list access */
+
+struct snd_card __init *snd_stm_cards_get(const char *id);
+struct snd_card __init *snd_stm_cards_default(const char **id);
+
+
+
+/*
+ * Components
+ *
+ * Note that all component data and functions are marked
+ * as a __init/__datainit, so are automatically cleaned
+ * after initialization. THEY ARE NOT STATIC DATA!
+ */
+
+/* Component description */
+
+struct snd_stm_component {
+	const char *bus_id;
+	const char *short_name;
+	int num_caps;
+	struct snd_stm_cap *caps;
+};
+
+/* Components list initialization */
+
+int __init snd_stm_components_init(struct snd_stm_component *components,
+		int num_components);
+
+/* Component & device access */
+
+struct snd_stm_component __init *snd_stm_components_get(const char *bus_id);
+struct device __init *snd_stm_device_get(const char *bus_id);
+
+/* Component capabilities description */
+
+union snd_stm_value {
+	int number;
+	const char *string;
+	struct {
+		int from;
+		int to;
+	} range;
+	struct {
+		int *numbers;
+		int len;
+	} list;
+};
+
+struct snd_stm_cap {
+	const char *name;
+	union snd_stm_value value;
+};
+
+/* Capabilities access */
+
+int __init snd_stm_cap_set(struct snd_stm_component *component,
+		const char *name, union snd_stm_value value);
+int __init snd_stm_cap_get(struct snd_stm_component *component,
+		const char *name, union snd_stm_value *value);
+
+int __init snd_stm_cap_get_number(struct snd_stm_component *component,
+		const char *name, int *number);
+int __init snd_stm_cap_get_string(struct snd_stm_component *component,
+		const char *name, const char **string);
+int __init snd_stm_cap_get_range(struct snd_stm_component *component,
+		const char *name, int *from, int *to);
+int __init snd_stm_cap_get_list(struct snd_stm_component *component,
+		const char *name, int **numbers, int *len);
+
+
+
+/*
+ * ALSA procfs additional entries
+ */
+
+int __init snd_stm_info_init(void);
+void snd_stm_info_cleanup(void);
+
+int snd_stm_info_register(struct snd_info_entry **entry,
+		const char *name,
+		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
+		void *private_data);
+void snd_stm_info_unregister(struct snd_info_entry *entry);
+
+
+
+/*
+ * Resources management
+ */
+
+int __init snd_stm_memory_request(struct platform_device *pdev,
+		struct resource **mem_region, void **base_address);
+void snd_stm_memory_release(struct resource *mem_region,
+		void *base_address);
+
+int __init snd_stm_irq_request(struct platform_device *pdev,
+		unsigned int *irq, irq_handler_t handler, void *dev_id);
+#define snd_stm_irq_release(irq, dev_id) free_irq(irq, dev_id)
+
+int __init snd_stm_fdma_request(struct platform_device *pdev,
+		int *channel, struct stm_dma_req **request,
+		struct stm_dma_req_config *config);
+void snd_stm_fdma_release(unsigned int channel,
+		struct stm_dma_req *request);
+
+
+
+/*
+ * Drivers initialization/cleanup
+ */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+int __init snd_stm_stx710x_init(void);
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+int __init snd_stm_stx7200_init(void);
+#endif
+
+int __init snd_stm_audio_outputs_init(void);
+void snd_stm_audio_outputs_cleanup(void);
+
+int __init snd_stm_fsynth_init(void);
+void snd_stm_fsynth_cleanup(void);
+
+int __init snd_stm_dac_internal_init(void);
+void snd_stm_dac_internal_cleanup(void);
+
+int __init snd_stm_i2s_spdif_converter_init(void);
+void snd_stm_i2s_spdif_converter_cleanup(void);
+
+int __init snd_stm_pcm_player_init(void);
+void snd_stm_pcm_player_cleanup(void);
+
+int __init snd_stm_pcm_reader_init(void);
+void snd_stm_pcm_reader_cleanup(void);
+
+int __init snd_stm_spdif_player_init(void);
+void snd_stm_spdif_player_cleanup(void);
+
+int __init snd_stm_synchro_init(void);
+void snd_stm_synchro_cleanup(void);
+
+
+
+/*
+ * Debug features
+ */
+
+/* Memory dump function */
+
+void snd_stm_hex_dump(void *data, int size);
+
+
+
+/* Trace debug messages
+ * - even more debugs than with CONFIG_SND_DEBUG ;-)
+ * - enables snd_printd when CONFIG_SND_DEBUG is not defined :-)
+ * - define TRACE _before_ including common.h to enable in selected
+ *   submodule; alternatively you can change following "#ifdef TRACE"
+ *   to "#if 1" to force verbose output in all STM submodules. */
+
+#ifdef TRACE
+
+#	ifndef CONFIG_SND_DEBUG
+#		undef snd_printd
+#		define snd_printd(format, args...) \
+				snd_printk(KERN_INFO format, ## args)
+#	endif
+
+#	define snd_stm_printt(format, args...) \
+			snd_printd(format, ## args)
+
+#else
+
+#	define snd_stm_printt(...)
+
+#endif
+
+/* Error debug messages */
+
+#define snd_stm_printe(format, args...) \
+		snd_printk(KERN_ERR format, ## args)
+
+/* Magic value checking in device structures
+ * - define MAGIC as a unique value _before_ including
+ *   common.h to enable in selected submodule; alternatively you can
+ *   change following "#ifdef MAGIC" to "#if 1" to force magic
+ *   checking in all STM submodules. */
+
+#ifdef MAGIC
+
+	enum snd_stm_magic {
+		snd_stm_magic_good = 0x600da15a + MAGIC,
+		snd_stm_magic_bad  = 0xbaada15a + MAGIC
+	};
+
+#	define snd_stm_magic_field \
+			enum snd_stm_magic __magic
+#	define snd_stm_magic_set(object) \
+			(object)->__magic = snd_stm_magic_good
+#	define snd_stm_magic_clear(object) \
+			(object)->__magic = snd_stm_magic_bad
+#	define snd_stm_magic_assert(object, args...) \
+			snd_assert((object)->__magic == snd_stm_magic_good, \
+					## args)
+
+#else
+
+#	define snd_stm_magic_field
+#	define snd_stm_magic_set(object)
+#	define snd_stm_magic_clear(object)
+#	define snd_stm_magic_assert(object, args...)
+
+#endif
+
+
+
+#endif
Index: linux-2.6.23-stm/sound/soc/stm/dac.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/dac.c
@@ -0,0 +1,82 @@
+/*
+ *   STMicroelectronics System-on-Chips' DAC abstraction layer
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 2 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Audio DAC public interface implementation
+ */
+
+int snd_stm_dac_internal_get_config(struct device *device,
+		unsigned long *pcm_format, unsigned int *oversampling);
+int snd_stm_dac_internal_shut_down(struct device *device);
+int snd_stm_dac_internal_wake_up(struct device *device);
+int snd_stm_dac_internal_mute(struct device *device);
+int snd_stm_dac_internal_unmute(struct device *device);
+
+
+
+/* Gets PCM format required by DAC as described in <linux/stm/soc.h> */
+int snd_stm_dac_get_config(struct device *device,
+		unsigned long *pcm_format, unsigned int *oversampling)
+{
+	/* TODO */
+	return snd_stm_dac_internal_get_config(device, pcm_format,
+			oversampling);
+}
+
+int snd_stm_dac_shut_down(struct device *device)
+{
+	/* TODO */
+	return snd_stm_dac_internal_shut_down(device);;
+}
+
+int snd_stm_dac_wake_up(struct device *device)
+{
+	/* TODO */
+	return snd_stm_dac_internal_wake_up(device);
+}
+
+int snd_stm_dac_mute(struct device *device)
+{
+	/* TODO */
+	return snd_stm_dac_internal_mute(device);
+}
+
+int snd_stm_dac_unmute(struct device *device)
+{
+	return snd_stm_dac_internal_unmute(device);
+}
Index: linux-2.6.23-stm/sound/soc/stm/dac_internal.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/dac_internal.c
@@ -0,0 +1,361 @@
+/*
+ *   STMicroelectronics System-on-Chips' internal audio DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+
+#undef TRACE   /* See common.h debug features */
+#define MAGIC 3 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define PCM_FORMAT \
+		(PLAT_STM_AUDIO__FORMAT_I2S | \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
+		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
+
+#define OVERSAMPLING 256
+
+
+
+/*
+ * Audio DAC instance structure
+ */
+
+struct snd_stm_dac_internal {
+	const char *bus_id;
+
+	struct resource *mem_region;
+
+	void *base;
+
+	/* Master DAC - must be waked up before the slave is etc. */
+	struct device *master;
+
+	/* TODO: add "waked up" counter */
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+
+
+
+/*
+ * Audio DAC public interface implementation
+ */
+
+/* Gets PCM format required by DAC as described in <linux/stm/soc.h> */
+int snd_stm_dac_internal_get_config(struct device *device,
+		unsigned long *pcm_format, unsigned int *oversampling)
+{
+	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	*pcm_format = PCM_FORMAT;
+	*oversampling = OVERSAMPLING;
+
+	return 0;
+}
+
+int snd_stm_dac_internal_wake_up(struct device *device)
+{
+	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	if (dac_internal->master)
+		snd_stm_dac_wake_up(dac_internal->master);
+
+	snd_stm_printt("Waking up DAC '%s' (still muted)\n",
+			dac_internal->bus_id);
+	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, NORMAL) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, NORMAL) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, NORMAL) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, NORMAL));
+
+	return 0;
+}
+
+int snd_stm_dac_internal_shut_down(struct device *device)
+{
+	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	if (dac_internal->master)
+		snd_stm_dac_shut_down(dac_internal->master);
+
+	snd_stm_printt("Setting DAC '%s' into reset mode.\n",
+			dac_internal->bus_id);
+	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
+
+	return 0;
+}
+
+int snd_stm_dac_internal_mute(struct device *device)
+{
+	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	snd_stm_printt("Muting DAC '%s'.\n", dac_internal->bus_id);
+
+	REGFIELD_SET(dac_internal->base, AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE);
+
+	return 0;
+}
+
+int snd_stm_dac_internal_unmute(struct device *device)
+{
+	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	snd_stm_printt("Unmuting DAC '%s'.\n", dac_internal->bus_id);
+
+	REGFIELD_SET(dac_internal->base, AUDCFG_ADAC_CTRL, SOFTMUTE, NORMAL);
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_dac_internal_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_dac_internal *dac_internal = entry->private_data;
+
+	snd_assert(dac_internal, return);
+	snd_stm_magic_assert(dac_internal, return);
+
+	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
+			REGISTER_PEEK(dac_internal->base, AUDCFG_ADAC_CTRL));
+}
+
+static int snd_stm_dac_internal_register(struct snd_device *snd_device)
+{
+	struct snd_stm_dac_internal *dac_internal = snd_device->device_data;
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	/* Initialize DAC as muted and shut down */
+
+	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&dac_internal->proc_entry, dac_internal->bus_id,
+			snd_stm_dac_internal_dump_registers, dac_internal);
+
+	return 0;
+}
+
+static int snd_stm_dac_internal_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_dac_internal *dac_internal = snd_device->device_data;
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(dac_internal->proc_entry);
+
+	/* Power done & mute mode, just to be sure :-) */
+
+	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_dac_internal_ops = {
+	.dev_register = snd_stm_dac_internal_register,
+	.dev_disconnect = snd_stm_dac_internal_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_dac_internal_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_component *component;
+	struct snd_stm_dac_internal *dac_internal;
+	const char *card_id;
+	struct snd_card *card;
+	const char *master_bus_id = NULL;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	dac_internal = kzalloc(sizeof(*dac_internal), GFP_KERNEL);
+	if (!dac_internal) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(dac_internal);
+	dac_internal->bus_id = pdev->dev.bus_id;
+
+	result = snd_stm_memory_request(pdev, &dac_internal->mem_region,
+			&dac_internal->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	if (result == 0)
+		card = snd_stm_cards_get(card_id);
+	else
+		card = snd_stm_cards_default(&card_id);
+	snd_assert(card, return -EINVAL);
+	snd_printd("DAC will be a member of a card '%s'\n", card_id);
+
+	result = snd_stm_cap_get_string(component, "master_bus_id",
+			&master_bus_id);
+	if (result == 0) {
+		dac_internal->master = snd_stm_device_get(master_bus_id);
+
+		snd_assert(dac_internal->master, return -EINVAL);
+		snd_printd("This DAC is %s's slave.\n", master_bus_id);
+	}
+
+	/* ALSA component */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, dac_internal,
+			&snd_stm_dac_internal_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, dac_internal);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(dac_internal->mem_region, dac_internal->base);
+error_memory_request:
+	snd_stm_magic_clear(dac_internal);
+	kfree(dac_internal);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_dac_internal_remove(struct platform_device *pdev)
+{
+	struct snd_stm_dac_internal *dac_internal = platform_get_drvdata(pdev);
+
+	snd_assert(dac_internal, return -EINVAL);
+	snd_stm_magic_assert(dac_internal, return -EINVAL);
+
+	snd_stm_memory_release(dac_internal->mem_region, dac_internal->base);
+
+	snd_stm_magic_clear(dac_internal);
+	kfree(dac_internal);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_dac_internal_driver = {
+	.driver = {
+		.name = "dac_internal",
+	},
+	.probe = snd_stm_dac_internal_probe,
+	.remove = snd_stm_dac_internal_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_dac_internal_init(void)
+{
+	return platform_driver_register(&snd_stm_dac_internal_driver);
+}
+
+void snd_stm_dac_internal_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_dac_internal_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/fsynth.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/fsynth.c
@@ -0,0 +1,746 @@
+/*
+ *   STMicroelectronics System-on-Chips' audio oversampling frequency
+ *   synthesizers driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Authors: Pawel MOLL <pawel.moll@st.com>
+ *            Daniel THOMPSON <daniel.thompson@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <asm/div64.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 4 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Hardware constants
+ */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#	define CHANNELS 3
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#	define CHANNELS 4
+#endif
+
+/* PLL inside the synthesizer multiplies input frequency
+ * (which is 30MHz in our case) by 8... */
+#define PLL_FREQ 8 * 30 * 1000 * 1000
+
+
+
+/*
+ * Audio frequency synthesizer structures
+ */
+
+struct snd_stm_fsynth_channel {
+	struct snd_stm_fsynth *fsynth;
+
+	int frequency;  /* Nominal */
+	int adjustment; /* Actual (achieved) */
+};
+
+struct snd_stm_fsynth {
+	const char *bus_id;
+
+	struct resource *mem_region;
+
+	void *base;
+
+	int channels_from, channels_to;
+	struct snd_stm_fsynth_channel channels[CHANNELS];
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Toolbox
+ */
+
+/* Return the number of set bits in x. */
+static unsigned int population(unsigned int x)
+{
+	/* This is the traditional branch-less algorithm for population count */
+	x = x - ((x >> 1) & 0x55555555);
+	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
+	x = (x + (x >> 4)) & 0x0f0f0f0f;
+	x = x + (x << 8);
+	x = x + (x << 16);
+
+	return x >> 24;
+}
+
+/* Return the index of the most significant set in x.
+ * The results are 'undefined' is x is 0 (0xffffffff as it happens
+ * but this is a mere side effect of the algorithm. */
+static unsigned int most_significant_set_bit(unsigned int x)
+{
+	/* propagate the MSSB right until all bits smaller than MSSB are set */
+	x = x | (x >> 1);
+	x = x | (x >> 2);
+	x = x | (x >> 4);
+	x = x | (x >> 8);
+	x = x | (x >> 16);
+
+	/* now count the number of set bits [clz is population(~x)] */
+	return population(x) - 1;
+}
+
+/* Solve the frequency synthesiser equations to provide a specified output
+ * frequency.
+ *
+ * The approach taken to solve the equation is to solve for sdiv assuming
+ * maximal values for md and one greater than maximal pe (-16 and 32768
+ * respectively) before rounding down. Once sdiv is selected we can
+ * solve for md by assuming maximal pe and rounding down. With these
+ * values pe can trivially be calculated.
+ *
+ * The function is implemented entirely with integer calculations making
+ * it suitable for use within the Linux kernel.
+ *
+ * The magic numbers within the function are derived from the Fsynth equation
+ * which is as follows:
+ *
+ * <pre>
+ *                                  32768*Fpll
+ * #1: Fout = ------------------------------------------------------
+ *                            md                        (md + 1)
+ *            (sdiv*((pe*(1 + --)) - ((pe - 32768)*(1 + --------))))
+ *                            32                           32
+ * </pre>
+ *
+ * Where:
+ *
+ *  - Fpll and Fout are frequencies in Hz
+ *  - sdiv is power of 2 between 1 and 8
+ *  - md is an integer between -1 and -16
+ *  - pe is an integer between 0 and 32767
+ *
+ * This simplifies to:
+ *
+ * <pre>
+ *                       1048576*Fpll
+ * #2: Fout = ----------------------------------
+ *            (sdiv*(1081344 - pe + (32768*md)))
+ * </pre>
+ *
+ * Rearranging:
+ *
+ * <pre>
+ *                 1048576*Fpll
+ * #3: predivide = ------------ = (sdiv*(1081344 - pe + (32768*md)))
+ *                     Fout
+ * </pre>
+ *
+ * If solve for sdiv and let pe = 32768 and md = -16 we get:
+ *
+ * <pre>
+ *                     predivide            predivide
+ * #4: sdiv = --------------------------- = ---------
+ *            (1081344 - pe + (32768*md))     524288
+ * </pre>
+ *
+ * Returning to eqn. #3, solving for md and let pe = 32768 we get:
+ *
+ * <pre>
+ *           predivide                    predivide
+ *          (--------- - 1081344 + pe)   (--------- - 1048576)
+ *             sdiv                         sdiv
+ * #5: md = -------------------------- = ---------------------
+ *                    32768                      32768
+
+ * </pre>
+ *
+ * Finally we return to #3 and rearrange for pe:
+ *
+ * <pre>
+ *              predivide
+ * #6: pe = -1*(--------- - 1081344 - (32768*md))
+ *                sdiv
+ * </pre>
+ *
+ */
+static int solve_fsynth_eqn(unsigned int Fpll, unsigned int Fout,
+		unsigned int *sdivp, int *mdp, unsigned int *pep)
+{
+	unsigned long long p, q;
+	unsigned int predivide;
+	int preshift; /* always +ve but used in subtraction */
+	unsigned int sdiv;
+	int md;
+	unsigned int pe = 1 << 14;
+
+	/* pre-divide the frequencies */
+	p = 1048576ull * Fpll;		/* <<20? */
+	q = Fout;
+
+	predivide = (unsigned int)div64_64(p, q);
+
+	/* determine an appropriate value for the output divider using eqn. #4
+	 * with md = -16 and pe = 32768 (and round down) */
+	sdiv = predivide / 524288;
+	if (sdiv > 1) {
+		/* sdiv = fls(sdiv) - 1; // this doesn't work
+		 * for some unknown reason */
+		sdiv = most_significant_set_bit(sdiv);
+	} else
+		sdiv = 1;
+
+	/* pre-shift a common sub-expression of later calculations */
+	preshift = predivide >> sdiv;
+
+	/* determine an appropriate value for the coarse selection using eqn. #5
+	 * with pe = 32768 (and round down which for signed values means away
+	 * from zero) */
+	md = ((preshift - 1048576) / 32768) - 1;	/* >>15? */
+
+	/* calculate a value for pe that meets the output target */
+	pe = -1 * (preshift - 1081344 - (32768 * md));	/* <<15? */
+
+	/* finally give sdiv its true hardware form */
+	sdiv--;
+
+	/* special case for 58593.75Hz and harmonics...
+	 * can't quite seem to get the rounding right */
+	if (md == -17 && pe == 0) {
+		md = -16;
+		pe = 32767;
+	}
+
+	/* update the outgoing arguments */
+	*sdivp = sdiv;
+	*mdp = md;
+	*pep = pe;
+
+	snd_stm_printt("SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
+
+	/* return 0 if all variables meet their contraints */
+	return (sdiv <= 7 && -16 <= md && md <= -1 && pe <= 32767) ? 0 : -1;
+}
+
+/*
+ *                   1048576*Fpll
+ * Fout = ----------------------------------
+ *        (sdiv*(1081344 - pe + (32768*md)))
+ *
+ * Fpll is premultiplied by 8
+ * Fout needs dividing by 256 to get real frequency
+ *
+ * small error compared to double based original
+ * i.e. for 44100 (11289600) it reports 11289610 instead of 11289610.36
+ */
+static int get_fsynth_output(unsigned int Fpll,
+		unsigned int sdiv, int md, unsigned int pe)
+{
+	long long p, q, r, s, t, u;
+
+	p = 1048576ll * Fpll;
+	q = 32768 * md;
+	r = 1081344 - pe;
+	s = r + q;
+	t = (1 << (sdiv + 1)) * s;
+	u = div64_64(p, t);
+
+	return (int)u;
+}
+
+static int snd_stm_fsynth_channel_configure(struct snd_stm_fsynth *fsynth,
+		int channel, int frequency, int adjustment)
+{
+	int result;
+	unsigned int sdiv;
+	int md;
+	unsigned int pe;
+	int frequency_adjusted, frequency_achieved, adjustment_achieved;
+	int delta;
+
+	snd_stm_printt("snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
+			"frequency=%d, adjustment=%d)\n", fsynth, channel,
+			frequency, adjustment);
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	/*             a
+	 * F = f + --------- * f = f + d
+	 *          1000000
+	 *
+	 *         a
+	 * d = --------- * f
+	 *      1000000
+	 *
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency to be set in synthesizer
+	 *   d - delta (difference) between f and F
+	 */
+	if (adjustment < 0) {
+		/* div64_64 operates on unsigned values... */
+		delta = -1;
+		adjustment = -adjustment;
+	} else {
+		delta = 1;
+	}
+	/* 500000 ppm is 0.5, which is used to round up values */
+	delta *= (int)div64_64((uint64_t)frequency * (uint64_t)adjustment +
+			500000, 1000000);
+	frequency_adjusted = frequency + delta;
+
+	snd_stm_printt("Setting %s channel %d to frequency %d.\n",
+			fsynth->bus_id, channel,
+			frequency_adjusted);
+
+	result = solve_fsynth_eqn(PLL_FREQ, frequency_adjusted,
+			&sdiv, &md, &pe);
+	if (result < 0) {
+		snd_stm_printe("Frequency %d can't be generated!\n",
+				frequency_adjusted);
+		return -EINVAL;
+	}
+
+	snd_stm_printt("SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
+			(unsigned int)md & AUDCFG_FSYN_MD__MD__MASK, pe);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_IGNORED);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_SDIV, channel,
+			SDIV, sdiv);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_MD, channel,
+			MD, (unsigned int)md & AUDCFG_FSYN_MD__MD__MASK);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_PE, channel,
+			PE, pe);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_USED);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_IGNORED);
+
+	/*             a                    a
+	 * F = f + --------- * f   =>   --------- * f = F - f   ==>
+	 *          1000000              1000000
+	 *
+	 *           a        F - f               F - f
+	 * ==>   --------- = -------   ==>   a = ------- * 1000000
+	 *        1000000       f                   f
+	 *
+	 * F = f + d   ==>   d = F - f
+	 *
+	 *      f + d - f               d
+	 * a = ----------- * 1000000 = --- * 1000000
+	 *          f                   f
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency actually being generated by fsynch
+	 *   d - delta between F and f
+	 */
+	frequency_achieved = get_fsynth_output(PLL_FREQ, sdiv, md, pe);
+	delta = frequency_achieved - frequency;
+	if (delta < 0) {
+		/* div64_64 operates on unsigned values... */
+		delta = -delta;
+		adjustment_achieved = -1;
+	} else {
+		adjustment_achieved = 1;
+	}
+	/* frequency/2 is added to round up result */
+	adjustment_achieved *= (int)div64_64((uint64_t)delta * 1000000 +
+			frequency / 2, frequency);
+
+	snd_stm_printt("Nominal frequency is %d, actual frequency is %d, "
+			"(%d ppm difference).\n", frequency,
+			frequency_achieved, adjustment_achieved);
+
+	/* Save this informations for future generations ;-) */
+	fsynth->channels[channel].frequency = frequency;
+	fsynth->channels[channel].adjustment = adjustment_achieved;
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_fsynth_adjustment_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = -1000000;
+	uinfo->value.integer.max = 1000000;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth_channel->fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
+
+	ucontrol->value.integer.value[0] = fsynth_channel->adjustment;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	int result;
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+	struct snd_stm_fsynth *fsynth;
+	int channel;
+	int old_adjustement;
+
+	snd_stm_printt("snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+
+	fsynth = fsynth_channel->fsynth;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	channel = fsynth_channel - fsynth_channel->fsynth->channels;
+	old_adjustement = fsynth_channel->adjustment;
+
+	result = snd_stm_fsynth_channel_configure(fsynth, channel,
+			fsynth_channel->frequency,
+			ucontrol->value.integer.value[0]);
+
+	if (result < 0)
+		return -EINVAL;
+
+	return old_adjustement != fsynth_channel->adjustment;
+}
+
+static struct snd_kcontrol_new __initdata snd_stm_fsynth_adjustment_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Playback Oversampling Freq. Adjustment",
+	.info = snd_stm_fsynth_adjustment_info,
+	.get = snd_stm_fsynth_adjustment_get,
+	.put = snd_stm_fsynth_adjustment_put,
+};
+
+
+
+/*
+ * Audio frequency synthesizer public interface implementation
+ */
+
+int snd_stm_fsynth_set_frequency(struct device *device, int channel,
+		int frequency)
+{
+	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
+
+	snd_stm_printt("snd_stm_fsynth_set_frequency(device=%p, channel=%d, "
+			"frequency=%d)\n", device, channel, frequency);
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	return snd_stm_fsynth_channel_configure(fsynth, channel, frequency, 0);
+}
+
+int __init snd_stm_fsynth_add_adjustement_ctl(struct device *device,
+		int channel, struct snd_card *card, int card_device)
+{
+	int result;
+	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
+
+	snd_stm_printt("snd_stm_fsynth_add_control(device=%p, channel=%d, "
+			"card=%p, card_device=%d)\n", device, channel,
+			card, card_device);
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	snd_stm_fsynth_adjustment_ctl.device = card_device;
+	result = snd_ctl_add(card, snd_ctl_new1(&snd_stm_fsynth_adjustment_ctl,
+			&fsynth->channels[channel]));
+	/* TODO: index per card */
+	snd_stm_fsynth_adjustment_ctl.index++;
+
+	return result;
+}
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r, n) \
+		snd_iprintf(buffer, "AUDCFG_FSYN%d_%s (offset 0x%02x) " \
+				"= 0x%08x\n", n, __stringify(r), \
+				AUDCFG_FSYN_##r(n), \
+				REGISTER_PEEK_N(fsynth->base, \
+				AUDCFG_FSYN_##r, n))
+
+static void snd_stm_fsynth_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_fsynth *fsynth = entry->private_data;
+	int i;
+
+	snd_assert(fsynth, return);
+	snd_stm_magic_assert(fsynth, return);
+
+	snd_iprintf(buffer, "AUDCFG_FSYN_CFG (offset 0x00) = 0x%08x\n",
+			REGISTER_PEEK(fsynth->base, AUDCFG_FSYN_CFG));
+
+	for (i = 0; i < CHANNELS; i++) {
+		DUMP_REGISTER(MD, i);
+		DUMP_REGISTER(PE, i);
+		DUMP_REGISTER(SDIV, i);
+		DUMP_REGISTER(PROGEN, i);
+	}
+}
+
+static int snd_stm_fsynth_register(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	/* Initialize & reset synthesizer */
+
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RESET);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		snd_printd("Enabling synthesizer '%s' channel %d\n",
+				fsynth->bus_id, i);
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, PCM_CLK_SEL,
+				FSYNTH(i));
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, ENABLED(i));
+#endif
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, ACTIVE(i));
+	}
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, NORMAL);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NDIV, 27_30_MHZ);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, BW_SEL, GOOD_REFERENCE);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, REF_CLK_IN, 30_MHZ_CLOCK);
+
+	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
+	barrier();
+
+	/* Unreset ;-) it now */
+
+	REGFIELD_SET(fsynth->base, AUDCFG_FSYN_CFG, RSTP, RUNNING);
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&fsynth->proc_entry, fsynth->bus_id,
+			snd_stm_fsynth_dump_registers, fsynth);
+
+	return 0;
+}
+
+static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(fsynth->proc_entry);
+
+	/* Disable synthesizer */
+
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RUNNING);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, DISABLED(i));
+#endif
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, STANDBY(i));
+	}
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, POWER_DOWN);
+
+	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_fsynth_ops = {
+	.dev_register = snd_stm_fsynth_register,
+	.dev_disconnect = snd_stm_fsynth_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_component *component;
+	struct snd_stm_fsynth *fsynth;
+	const char *card_id;
+	struct snd_card *card;
+	int i;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	fsynth = kzalloc(sizeof(*fsynth), GFP_KERNEL);
+	if (!fsynth) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(fsynth);
+	fsynth->bus_id = pdev->dev.bus_id;
+	for (i = 0; i < CHANNELS; i++)
+		fsynth->channels[i].fsynth = fsynth;
+
+	result = snd_stm_memory_request(pdev, &fsynth->mem_region,
+			&fsynth->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	if (result == 0)
+		card = snd_stm_cards_get(card_id);
+	else
+		card = snd_stm_cards_default(&card_id);
+	snd_assert(card, return -EINVAL);
+	snd_printd("This frequency synthesizer will be a member "
+			"of a card '%s'\n", card_id);
+
+	result = snd_stm_cap_get_range(component, "channels",
+			&fsynth->channels_from, &fsynth->channels_to);
+	snd_assert(result == 0, return -EINVAL);
+	snd_assert(fsynth->channels_from < fsynth->channels_to,
+			return -EINVAL);
+	snd_assert(fsynth->channels_from >= 0, return -EINVAL);
+	snd_assert(fsynth->channels_to < CHANNELS, return -EINVAL);
+
+	snd_printd("Used synthesizer channels: %d to %d\n",
+			fsynth->channels_from, fsynth->channels_to);
+
+	/* ALSA component */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, fsynth,
+			&snd_stm_fsynth_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, fsynth);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+error_memory_request:
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_fsynth_remove(struct platform_device *pdev)
+{
+	struct snd_stm_fsynth *fsynth = platform_get_drvdata(pdev);
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_fsynth_driver = {
+	.driver = {
+		.name = "fsynth",
+	},
+	.probe = snd_stm_fsynth_probe,
+	.remove = snd_stm_fsynth_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_fsynth_init(void)
+{
+	return platform_driver_register(&snd_stm_fsynth_driver);
+}
+
+void snd_stm_fsynth_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_fsynth_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/i2s-spdif_converter.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/i2s-spdif_converter.c
@@ -0,0 +1,41 @@
+/*
+ *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 5 /* See common.h debug features */
+#include "common.h"
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_i2s_spdif_converter_init(void)
+{
+	return 0;
+}
+
+void snd_stm_i2s_spdif_converter_cleanup(void)
+{
+}
Index: linux-2.6.23-stm/sound/soc/stm/init.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/init.c
@@ -0,0 +1,151 @@
+/*
+ *   STMicrolectronics System-on-Chips' audio subsystem driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#undef TRACE
+#include "common.h"
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio subsystem");
+MODULE_LICENSE("GPL");
+
+static int __init alsa_card_stm_init(void)
+{
+	int result;
+
+	snd_printd("=== STM ALSA driver is initializing...\n");
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	result = snd_stm_stx710x_init();
+#endif
+#ifdef CONFIG_CPU_SUBTYPE_STX7200
+	result = snd_stm_stx7200_init();
+#endif
+	if (result != 0)
+		goto error_soc;
+
+	result = snd_stm_info_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize procfs info entries!\n");
+		goto error_info;
+	}
+	result = snd_stm_audio_outputs_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize audio outputs!\n");
+		goto error_audio_outputs;
+	}
+	result = snd_stm_fsynth_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize frequency synthesizer!\n");
+		goto error_fsynth;
+	}
+	result = snd_stm_dac_internal_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize internal DACs!\n");
+		goto error_dac_internal;
+	}
+	result = snd_stm_synchro_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize synchronisation routines!\n");
+		goto error_synchro;
+	}
+	result = snd_stm_i2s_spdif_converter_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize I2S to SPDIF converter!\n");
+		goto error_i2s_spdif_converter;
+	}
+	result = snd_stm_pcm_player_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize PCM player!\n");
+		goto error_pcm_player;
+	}
+	result = snd_stm_pcm_reader_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize PCM reader!\n");
+		goto error_pcm_reader;
+	}
+	result = snd_stm_spdif_player_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize SPDIF player!\n");
+		goto error_spdif_player;
+	}
+
+	/* Cards should be created by SoC-specific initialization
+	 * function (snd_stm_stxXXXX_init) */
+	result = snd_stm_cards_register();
+	if (result != 0) {
+		snd_stm_printe("Can't register ALSA cards!\n");
+		goto error_cards;
+	}
+
+	snd_printd("=== Success!\n");
+
+	return result;
+
+error_cards:
+	snd_stm_spdif_player_cleanup();
+error_spdif_player:
+	snd_stm_pcm_reader_cleanup();
+error_pcm_reader:
+	snd_stm_pcm_player_cleanup();
+error_pcm_player:
+	snd_stm_i2s_spdif_converter_cleanup();
+error_i2s_spdif_converter:
+	snd_stm_synchro_cleanup();
+error_synchro:
+	snd_stm_dac_internal_cleanup();
+error_dac_internal:
+	snd_stm_fsynth_cleanup();
+error_fsynth:
+	snd_stm_audio_outputs_cleanup();
+error_audio_outputs:
+	snd_stm_info_cleanup();
+error_info:
+	snd_stm_cards_free();
+error_soc:
+	return result;
+}
+
+static void __exit alsa_card_stm_exit(void)
+{
+	snd_printd("=== STM ALSA driver cleanup.\n");
+
+	snd_stm_cards_free();
+
+	snd_stm_spdif_player_cleanup();
+	snd_stm_pcm_reader_cleanup();
+	snd_stm_pcm_player_cleanup();
+	snd_stm_i2s_spdif_converter_cleanup();
+	snd_stm_synchro_cleanup();
+	snd_stm_dac_internal_cleanup();
+	snd_stm_fsynth_cleanup();
+	snd_stm_audio_outputs_cleanup();
+	snd_stm_info_cleanup();
+}
+
+module_init(alsa_card_stm_init)
+module_exit(alsa_card_stm_exit)
Index: linux-2.6.23-stm/sound/soc/stm/pcm_player.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/pcm_player.c
@@ -0,0 +1,1166 @@
+/*
+ *   STMicroelectronics System-on-Chips' PCM player driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *           Mark Glaisher
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/bpa2.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/info.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 5 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define INIT_SAMPLING_RATE 32000
+
+#define DEFAULT_OVERSAMPLING 256
+#define DEFAULT_FORMAT \
+		(PLAT_STM_AUDIO__FORMAT_I2S | \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
+		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
+
+/* The sample count field (NSAMPLES in CTRL register) is 19 bits wide */
+#define MAX_SAMPLES_PER_PERIOD ((1 << 19) - 1)
+
+#define MAX_CHANNELS 10
+
+
+
+/*
+ * PCM player instance definition
+ */
+
+struct snd_stm_pcm_player {
+	/* System informations */
+	const char *name;
+	const char *bus_id;
+	struct snd_pcm *pcm;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	int fdma_channel;
+	struct stm_dma_req *fdma_request;
+
+	/* Environment settings */
+	struct device *fsynth;
+	int fsynth_channel;
+	struct device *dac;
+	struct snd_pcm_hw_constraint_list channels_constraint;
+	unsigned int channels_constraint_list[MAX_CHANNELS / 2];
+
+	/* Board-specific settings */
+	unsigned long format;
+	unsigned int oversampling;
+
+	/* Value of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
+	 * actually means "data clocking on the falling edge" -
+	 * STx7100 and _some_ cuts of STx7109 have this value
+	 * inverted than datasheets claim... (specs say 1) */
+	int sclk_edge_falling;
+
+	/* Workaround for L/R swap problem (see further) */
+	int lr_pol;
+
+	/* Runtime data */
+	void *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	struct stm_dma_params fdma_params;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Playing engine implementation
+ */
+
+static irqreturn_t snd_stm_pcm_player_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_pcm_player *pcm_player = dev_id;
+	unsigned int status;
+
+	snd_stm_printt("snd_stm_pcm_player_irq_handler(irq=%d, dev_id=0x%p)\n",
+			irq, dev_id);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = REGISTER_PEEK(pcm_player->base, AUD_PCMOUT_ITS);
+	REGISTER_POKE(pcm_player->base, AUD_PCMOUT_ITS_CLR, status);
+	preempt_enable();
+
+	/* Underflow? */
+	if (unlikely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, UNF, PENDING))) {
+		snd_stm_printe("Underflow detected in PCM player '%s'!\n",
+				pcm_player->bus_id);
+		result = IRQ_HANDLED;
+	}
+
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, NSAMPLE, PENDING)))
+		do {
+			snd_assert(pcm_player->substream, break);
+
+			snd_stm_printt("Period elapsed ('%s')\n",
+					pcm_player->bus_id);
+			snd_pcm_period_elapsed(pcm_player->substream);
+
+			result = IRQ_HANDLED;
+		} while (0);
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+static struct snd_pcm_hardware snd_stm_pcm_player_hw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S16_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_192000),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 10,
+
+	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note 1: that these value must be also calculated not to exceed
+	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
+	 * Note 2: for 16/16-bits data this counter is a "frames counter",
+	 * not "samples counter" (two channels are read as one word).
+	 * Note 3: period_bytes_min defines minimum time between period
+	 * (NSAMPLE) interrupts... Keep it large enough not to kill
+	 * the system... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_pcm_player_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_player_open(substream=0x%p)\n", substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	result = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_CHANNELS,
+			&pcm_player->channels_constraint);
+	if (result < 0) {
+		snd_stm_printe("Can't set channels constraint!\n");
+		return result;
+	}
+
+	/* It is better when buffer size is an integer multiple of period
+	 * size... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	runtime->hw = snd_stm_pcm_player_hw;
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_player_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes;
+
+	snd_stm_printt("snd_stm_pcm_player_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Allocate buffer */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	pcm_player->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
+	if (!pcm_player->buffer) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, pcm_player->bus_id);
+		return -ENOMEM;
+	}
+
+	runtime->dma_addr = virt_to_phys(pcm_player->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", pcm_player->bus_id,
+			pcm_player->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
+	/* Configure FDMA transfer */
+
+	dma_params_init(&pcm_player->fdma_params, MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	dma_params_DIM_1_x_0(&pcm_player->fdma_params);
+
+	dma_params_req(&pcm_player->fdma_params, pcm_player->fdma_request);
+
+	dma_params_addrs(&pcm_player->fdma_params, runtime->dma_addr,
+			pcm_player->fifo_phys_address, buffer_bytes);
+
+	result = dma_compile_list(pcm_player->fdma_channel,
+				&pcm_player->fdma_params, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for player"
+				" '%s'!\n", pcm_player->bus_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (pcm_player->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_player->bus_id,
+				pcm_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
+		pcm_player->buffer = NULL;
+
+		/* Dispose FDMA parameters */
+
+		dma_params_free(&pcm_player->fdma_params);
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int bits_in_output_frame;
+
+	snd_stm_printt("snd_stm_pcm_player_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+
+	/* Configure SPDIF synchronisation */
+
+	/* TODO */
+
+	/* Set up frequency synthesizer */
+
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth,
+			pcm_player->fsynth_channel,
+			runtime->rate * pcm_player->oversampling);
+
+	/* Configure PCM player frequency divider
+	 *
+	 *             Fdacclk             Fs * oversampling
+	 * divider = ----------- = ------------------------------- =
+	 *            2 * Fsclk     2 * Fs * bits_in_output_frame
+	 *
+	 *                  oversampling
+	 *         = --------------------------
+	 *            2 * bits_in_output_frame
+	 * where:
+	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
+	 *               MCLK (master clock), "system clock" etc.
+	 *   - Fsclk - frequency of SCLK (serial clock) aka BICK (bit clock)
+	 *   - Fs - sampling rate (frequency)
+	 *   - bits_in_output_frame - number of bits in output signal _frame_
+	 *                (32 or 64, depending on NBIT field of FMT register)
+	 */
+
+	switch (pcm_player->format & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
+	case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
+		bits_in_output_frame = 64;
+		break;
+	case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
+		bits_in_output_frame = 32;
+		break;
+	default:
+		snd_assert(0, return -EINVAL);
+		break;
+	}
+
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, CLK_DIV,
+			pcm_player->oversampling / (2 * bits_in_output_frame));
+
+	/* Configure data memory format & NSAMPLE interrupt */
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* One data word contains two samples */
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
+				MEM_FMT, 16_BITS_16_BITS);
+
+		/* Workaround for a problem with L/R channels swap in case of
+		 * 16/16 memory model: PCM player expects left channel data in
+		 * word's upper two bytes, but due to little endianess
+		 * character of our memory there is right channel data there;
+		 * the workaround is to invert L/R signal, however it is
+		 * cheating, because in such case channel phases are shifted
+		 * by one sample...
+		 * (ask me for more details if above is not clear ;-)
+		 * TODO this somehow better... */
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
+				!pcm_player->lr_pol);
+
+		/* One word if fifo is two samples (two channels...) */
+
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
+				runtime->period_size * runtime->channels / 2);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
+		 * left than zeros"... ;-) */
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
+				MEM_FMT, 16_BITS_0_BITS);
+
+		/* In x/0 bits memory mode there is no problem with
+		 * L/R polarity */
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
+				pcm_player->lr_pol);
+
+		/* One word of data is one sample, so period size
+		 * times channels */
+
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
+				runtime->period_size * runtime->channels);
+		break;
+
+	default:
+		snd_assert(0, return -EINVAL);
+		break;
+	}
+
+	/* Number of channels... */
+
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
+			return -EINVAL);
+
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, NUM_CH,
+			runtime->channels / 2);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_start(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_player_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Un-reset PCM player */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RUNNING);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(pcm_player->fdma_channel,
+			&pcm_player->fdma_params);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
+				pcm_player->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch PCM player */
+
+	pcm_player->substream = substream;
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
+
+	/* Enable player interrupts */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, NSAMPLE, SET);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, UNF, SET);
+
+	/* Wake up & unmute DAC */
+
+	if (pcm_player->dac) {
+		snd_stm_dac_wake_up(pcm_player->dac);
+		snd_stm_dac_unmute(pcm_player->dac);
+	}
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_player_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Mute & shutdown DAC */
+
+	if (pcm_player->dac) {
+		snd_stm_dac_mute(pcm_player->dac);
+		snd_stm_dac_shut_down(pcm_player->dac);
+	}
+
+	/* Disable interrupts */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, NSAMPLE, CLEAR);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, UNF, CLEAR);
+
+	/* Stop PCM player */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, OFF);
+	pcm_player->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(pcm_player->fdma_channel);
+
+	/* Reset PCM player */
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_pause(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_player_pause(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* "Mute" player
+	 * Documentation describes this mode in a wrong way - data is _not_
+	 * consumed in the "mute" mode, so it is actually a "pause" mode */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, MUTE);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_release(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+		snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_player_release(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* "Unmute" player */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printt("snd_stm_pcm_player_trigger(substream=0x%p,"
+			" command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_pcm_player_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_pcm_player_stop(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return snd_stm_pcm_player_pause(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return snd_stm_pcm_player_release(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_pcm_player_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printt("snd_stm_pcm_player_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(pcm_player->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+static struct snd_pcm_ops snd_stm_pcm_player_pcm_ops = {
+	.open =      snd_stm_pcm_player_open,
+	.close =     snd_stm_pcm_player_close,
+	.mmap =      snd_stm_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_pcm_player_hw_params,
+	.hw_free =   snd_stm_pcm_player_hw_free,
+	.prepare =   snd_stm_pcm_player_prepare,
+	.trigger =   snd_stm_pcm_player_trigger,
+	.pointer =   snd_stm_pcm_player_pointer,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_PCMOUT_%s (offset 0x%02x) =" \
+				" 0x%08x\n", __stringify(r), \
+				AUD_PCMOUT_##r, \
+				REGISTER_PEEK(pcm_player->base, \
+				AUD_PCMOUT_##r))
+
+static void snd_stm_pcm_player_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_pcm_player *pcm_player = entry->private_data;
+
+	snd_assert(pcm_player, return);
+	snd_stm_magic_assert(pcm_player, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(FMT);
+}
+
+static int snd_stm_pcm_player_register(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_pcm_player_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Set a default clock frequency running for each device.
+	 * Not doing this can lead to clocks not starting correctly later,
+	 * for reasons that cannot be explained at this time. */
+	/* TODO: Check it, maybe obsolete now */
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth,
+			pcm_player->fsynth_channel,
+			INIT_SAMPLING_RATE * pcm_player->oversampling);
+
+	/* Initialize hardware (format etc.) */
+
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, RND, NO_ROUNDING);
+
+	if (pcm_player->format & PLAT_STM_AUDIO__CUSTOM) {
+		/* Custom format settings... Well, you asked for it! ;-) */
+		REGISTER_POKE(pcm_player->base, AUD_PCMOUT_CTRL,
+				pcm_player->format & !PLAT_STM_AUDIO__CUSTOM);
+	} else {
+		/* Number of bits per subframe (which is one channel sample)
+		 * on output - it determines serial clock frequency, which is
+		 * 64 times sampling rate for 32 bits subframe (2 channels 32
+		 * bits each means 64 bits per frame) and 32 times sampling
+		 * rate for 16 bits subframe
+		 * (you know why now, don't you? :-) */
+
+		switch (pcm_player->format &
+				PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
+		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					NBIT, 32_BITS);
+			break;
+		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					NBIT, 16_BITS);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+
+		/* Datasheet says: "The recommended configuration is to set
+		 * the PCM player fifo threshold that triggers the FDMA
+		 * request to 40 bytes (at least 80 bytes available) and
+		 * to configured the FDMA to perform a 80 bytes store
+		 * operation when servicing a dma request." My understanding
+		 * of "FIFO cell" is "4 bytes" ;-), so the value should be 20.
+		 * Surprisingly experiments suggest using something
+		 * like 10... */
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+				DMA_REQ_TRIG_LMT, 10);
+
+		/* Number of meaningful bits in subframe -
+		 * the rest are just zeros */
+
+		switch (pcm_player->format & PLAT_STM_AUDIO__DATA_SIZE_MASK) {
+		case PLAT_STM_AUDIO__DATA_SIZE_24_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 24_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_20_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 20_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_18_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 18_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_16_BITS:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 16_BITS);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+
+		/* Serial audio interface format - for detailed explanation
+		 * see ie.:
+		 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				ORDER, MSB_FIRST);
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+				SCLK_EDGE, pcm_player->sclk_edge_falling);
+		switch (pcm_player->format & PLAT_STM_AUDIO__FORMAT_MASK) {
+		case PLAT_STM_AUDIO__FORMAT_I2S:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					ALIGN, LEFT);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					PADDING, 1_CYCLE_DELAY);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					LR_POL, LEFT_LOW);
+			break;
+		case PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					ALIGN, LEFT);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					PADDING, NO_DELAY);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					LR_POL, LEFT_HIGH);
+			break;
+		case PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED:
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					ALIGN, RIGHT);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					PADDING, NO_DELAY);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					LR_POL, LEFT_HIGH);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+	}
+
+	/* Workaround for 16/16 memory format L/R channels swap (see above) */
+	pcm_player->lr_pol = REGFIELD_PEEK(pcm_player->base, AUD_PCMOUT_FMT,
+			LR_POL);
+
+	/* This combination is forbidden - please use 384 * Fs oversampling
+	 * frequency instead */
+	snd_assert(!(pcm_player->oversampling == 192 && (pcm_player->format &
+			PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS)),
+			return -EINVAL);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&pcm_player->proc_entry, pcm_player->bus_id,
+			snd_stm_pcm_player_dump_registers, pcm_player);
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_pcm_player_unregister(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_stm_info_unregister(pcm_player->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_pcm_player_ops = {
+	.dev_register = snd_stm_pcm_player_register,
+	.dev_disconnect = snd_stm_pcm_player_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+#define FORMAT_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "custom" : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_I2S ? "I2S, " : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED ? \
+		"left justified, " : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED ? \
+		"right justified, " : \
+	"")
+
+#define DATA_SIZE_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "" : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_24_BITS ? \
+		"24 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_20_BITS ? \
+		"20 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_18_BITS ? \
+		"18 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_16_BITS ? \
+		"16 bits data, " : \
+	"")
+
+#define OUTPUT_SUBFRAME_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "" : \
+	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS ? \
+		"32 bits output subframe" : \
+	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS ? \
+		"16 bits output subframe" : \
+	"")
+
+static struct stm_dma_req_config snd_stm_pcm_player_fdma_request_config = {
+	.rw        = REQ_CONFIG_WRITE,
+	.opcode    = REQ_CONFIG_OPCODE_4,
+	.count     = 1,
+	.increment = 0,
+	.hold_off  = 0,
+	/* .initiator value is defined in platform device resources */
+};
+
+static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct plat_audio_config *config = pdev->dev.platform_data;
+	struct snd_stm_component *component;
+	struct snd_stm_pcm_player *pcm_player;
+	struct snd_card *card;
+	int card_device;
+	int *channels_list;
+	int channels_list_len;
+	const char *card_id;
+	const char *fsynth_bus_id;
+	const char *dac_bus_id;
+	int i;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
+	if (!pcm_player) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(pcm_player);
+	pcm_player->bus_id = pdev->dev.bus_id;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &pcm_player->mem_region,
+			&pcm_player->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	pcm_player->fifo_phys_address = pcm_player->mem_region->start +
+		AUD_PCMOUT_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
+			pcm_player->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &pcm_player->irq,
+			snd_stm_pcm_player_irq_handler, pcm_player);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &pcm_player->fdma_channel,
+			&pcm_player->fdma_request,
+			&snd_stm_pcm_player_fdma_request_config);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* Get component caps */
+
+	snd_printd("Player's name is '%s'\n", component->short_name);
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	snd_assert(result == 0, return -EINVAL);
+	card = snd_stm_cards_get(card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Player will be a member of a card '%s'...\n", card_id);
+
+	result = snd_stm_cap_get_number(component, "card_device",
+			&card_device);
+	snd_assert(result == 0, return -EINVAL);
+	snd_printd("... as a PCM device no %d.\n", card_device);
+
+	result = snd_stm_cap_get_list(component, "channels", &channels_list,
+			&channels_list_len);
+	snd_assert(result == 0, return -EINVAL);
+	memcpy(pcm_player->channels_constraint_list, channels_list,
+			sizeof(*channels_list) * channels_list_len);
+	pcm_player->channels_constraint.list =
+		pcm_player->channels_constraint_list;
+	pcm_player->channels_constraint.count =
+		(unsigned int)channels_list_len;
+	pcm_player->channels_constraint.mask = 0;
+	for (i = 0; i < channels_list_len; i++)
+		snd_printd("Player capable of playing %d-channels PCM.\n",
+				channels_list[i]);
+
+	result = snd_stm_cap_get_string(component, "fsynth_bus_id",
+			&fsynth_bus_id);
+	snd_assert(result == 0, return -EINVAL);
+	pcm_player->fsynth = snd_stm_device_get(fsynth_bus_id);
+	snd_assert(pcm_player->fsynth, return -EINVAL);
+	result = snd_stm_cap_get_number(component, "fsynth_channel",
+			&pcm_player->fsynth_channel);
+	snd_assert(result == 0, return -EINVAL);
+	snd_printd("Player clocked by channel %d of synthesizer %s.\n",
+			pcm_player->fsynth_channel, fsynth_bus_id);
+
+	if (snd_stm_cap_get_string(component, "dac_bus_id", &dac_bus_id) == 0) {
+		pcm_player->dac = snd_stm_device_get(dac_bus_id);
+		snd_assert(pcm_player->dac, return -EINVAL);
+		snd_printd("Player connected to DAC %s.\n", dac_bus_id);
+	} else {
+		pcm_player->dac = NULL;
+	}
+
+	if (snd_stm_cap_get_number(component, "sclk_edge_falling",
+				&pcm_player->sclk_edge_falling) < 0)
+		pcm_player->sclk_edge_falling =
+			AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING;
+
+	snd_printd("Player's SCLK_EDGE == %d means falling edge...\n",
+			pcm_player->sclk_edge_falling);
+
+	/* Board-specific configuration */
+
+	if (pcm_player->dac) {
+		/* If player is connected to an internal DAC just
+		 * ask it about required format instead of looking
+		 * for user-specified one */
+		result = snd_stm_dac_get_config(pcm_player->dac,
+				&pcm_player->format,
+				&pcm_player->oversampling);
+		snd_assert(result == 0, return -EINVAL);
+		snd_printd("Using DAC-defined PCM format (%s%s%s)"
+				" and oversampling (%u).\n",
+				FORMAT_STRING(pcm_player->format),
+				DATA_SIZE_STRING(pcm_player->format),
+				OUTPUT_SUBFRAME_STRING(pcm_player->format),
+				pcm_player->oversampling);
+	} else if (config) {
+		pcm_player->format = config->pcm_format;
+		pcm_player->oversampling = config->oversampling;
+		snd_printd("Using board specific PCM format (%s%s%s, 0x%08lx)"
+				" and oversampling (%u).\n",
+				FORMAT_STRING(pcm_player->format),
+				DATA_SIZE_STRING(pcm_player->format),
+				OUTPUT_SUBFRAME_STRING(pcm_player->format),
+				pcm_player->format,
+				pcm_player->oversampling);
+	} else {
+		pcm_player->format = DEFAULT_FORMAT;
+		pcm_player->oversampling = DEFAULT_OVERSAMPLING;
+		snd_printd("Using default PCM format (%s%s%s)"
+				" and oversampling (%u).\n",
+				FORMAT_STRING(pcm_player->format),
+				DATA_SIZE_STRING(pcm_player->format),
+				OUTPUT_SUBFRAME_STRING(pcm_player->format),
+				pcm_player->oversampling);
+	}
+	/* Allowed oversampling values */
+	snd_assert(pcm_player->oversampling == 128 ||
+			pcm_player->oversampling == 192 ||
+			pcm_player->oversampling == 256 ||
+			pcm_player->oversampling == 384 ||
+			pcm_player->oversampling == 512 ||
+			pcm_player->oversampling == 768,
+			return -EINVAL);
+
+	/* Preallocate buffer */
+
+	/* TODO */
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_player,
+			&snd_stm_pcm_player_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, card_device, 1, 0, &pcm_player->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	pcm_player->pcm->private_data = pcm_player;
+	strcpy(pcm_player->pcm->name, component->short_name);
+
+	snd_pcm_set_ops(pcm_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_stm_pcm_player_pcm_ops);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth,
+			pcm_player->fsynth_channel, card, card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add ALSA control!\n");
+		goto error_controls;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, pcm_player);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_controls:
+error_pcm:
+	snd_device_free(card, pcm_player);
+error_device:
+	snd_stm_fdma_release(pcm_player->fdma_channel,
+			pcm_player->fdma_request);
+error_fdma_request:
+	snd_stm_irq_release(pcm_player->irq, pcm_player);
+error_irq_request:
+	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
+error_memory_request:
+	snd_stm_magic_clear(pcm_player);
+	kfree(pcm_player);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_player_remove(struct platform_device *pdev)
+{
+	struct snd_stm_pcm_player *pcm_player = platform_get_drvdata(pdev);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	snd_stm_fdma_release(pcm_player->fdma_channel,
+			pcm_player->fdma_request);
+	snd_stm_irq_release(pcm_player->irq, pcm_player);
+	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
+
+	snd_stm_magic_clear(pcm_player);
+	kfree(pcm_player);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_pcm_player_driver = {
+	.driver = {
+		.name = "pcm_player",
+	},
+	.probe = snd_stm_pcm_player_probe,
+	.remove = snd_stm_pcm_player_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_pcm_player_init(void)
+{
+	return platform_driver_register(&snd_stm_pcm_player_driver);
+}
+
+void snd_stm_pcm_player_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_pcm_player_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/pcm_reader.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/pcm_reader.c
@@ -0,0 +1,1018 @@
+/*
+ *   STMicroelectronics System-on-Chips' PCM reader driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/bpa2.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/info.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 6 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define DEFAULT_FORMAT \
+		(PLAT_STM_AUDIO__FORMAT_I2S | \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
+		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
+
+#define MAX_CHANNELS 10
+
+
+
+/*
+ * PCM reader instance definition
+ */
+
+struct snd_stm_pcm_reader {
+	/* System informations */
+	const char *name;
+	const char *bus_id;
+	struct snd_pcm *pcm;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	int fdma_channel;
+	struct stm_dma_req *fdma_request;
+
+	/* Environment settings */
+	struct snd_pcm_hw_constraint_list channels_constraint;
+	unsigned int channels_constraint_list[MAX_CHANNELS / 2];
+
+	/* Board-specific settings */
+	unsigned long format;
+	unsigned int oversampling;
+
+	/* Workaround for L/R swap problem (see further) */
+	int lr_pol;
+
+	/* Runtime data */
+	void *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	struct stm_dma_params *fdma_params_list;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Capturing engine implementation
+ */
+
+static irqreturn_t snd_stm_pcm_reader_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_pcm_reader *pcm_reader = dev_id;
+	unsigned int status;
+
+	snd_stm_printt("snd_stm_pcm_reader_irq_handler(irq=%d, dev_id=0x%p)\n",
+			irq, dev_id);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_ITS);
+	REGISTER_POKE(pcm_reader->base, AUD_PCMIN_ITS_CLR, status);
+	preempt_enable();
+
+	/* Overflow? */
+	if (unlikely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, OVF, PENDING))) {
+		snd_stm_printe("Overflow detected in PCM reader '%s'!\n",
+				pcm_reader->bus_id);
+		get_dma_residue(pcm_reader->fdma_channel);
+		result = IRQ_HANDLED;
+	}
+
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, VSYNC, PENDING))) {
+		snd_stm_printt("Vsync interrupt detected by '%s'!\n",
+				pcm_reader->bus_id);
+		/* TODO: Calculate sampling frequency */
+		result = IRQ_HANDLED;
+	}
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+static void snd_stm_pcm_reader_callback_node_done(unsigned long param)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			(struct snd_stm_pcm_reader *)param;
+
+	snd_stm_printt("snd_stm_pcm_reader_callback_node_done(param=0x%lx)\n",
+			param);
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	/* This function will be called after stopping FDMA as well
+	 * and in this moment ALSA is already shut down... */
+	if (pcm_reader->substream) {
+		snd_stm_printt("Period elapsed ('%s')\n", pcm_reader->bus_id);
+		snd_pcm_period_elapsed(pcm_reader->substream);
+	}
+}
+
+static void snd_stm_pcm_reader_callback_node_error(unsigned long param)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			(struct snd_stm_pcm_reader *)param;
+
+	snd_stm_printt("snd_stm_pcm_reader_callback_node_error(param=0x%lx)\n",
+			param);
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	snd_stm_printe("Error during FDMA transfer in reader '%s'!\n",
+			pcm_reader->bus_id);
+}
+
+static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER),
+#if 0
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S16_LE),
+#else
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
+#endif
+
+	/* Keep in mind that we are working in slave mode, so sampling
+	 * rate is determined by external components... */
+	.rates		= (SNDRV_PCM_RATE_CONTINUOUS),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 10,
+
+	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note: period_bytes_min defines minimum time between FDMA transfer
+	 * interrupts... Keep it large enough not to kill the system... */
+
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_pcm_reader_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_reader_open(substream=0x%p)\n", substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	result = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_CHANNELS,
+			&pcm_reader->channels_constraint);
+	if (result < 0) {
+		snd_stm_printe("Can't set channels constraint!\n");
+		return result;
+	}
+
+	/* Buffer size must be an integer multiple of a period size to use
+	 * FDMA nodes as periods... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	runtime->hw = snd_stm_pcm_reader_hw;
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_reader_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes, period_bytes, periods;
+	int i;
+
+	snd_stm_printt("snd_stm_pcm_reader_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Get the numbers... */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	periods = params_periods(hw_params);
+	period_bytes = buffer_bytes / periods;
+	snd_assert(periods * period_bytes == buffer_bytes, return -EINVAL);
+
+	/* Allocate buffer */
+
+	pcm_reader->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
+	if (!pcm_reader->buffer) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, pcm_reader->bus_id);
+		return -ENOMEM;
+	}
+
+	runtime->dma_addr = virt_to_phys(pcm_reader->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", pcm_reader->bus_id,
+			pcm_reader->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
+	/* Configure FDMA transfer (one node per period) */
+
+	pcm_reader->fdma_params_list =
+			kmalloc(sizeof(*pcm_reader->fdma_params_list) *
+					periods, GFP_KERNEL);
+	if (!pcm_reader->fdma_params_list) {
+		/* TODO: move to BPA2 (see above) */
+		snd_stm_printe("Can't allocate %d bytes for FDMA parameters "
+				"list!\n", sizeof(*pcm_reader->fdma_params_list)
+				* periods);
+		bigphysarea_free(runtime->dma_area, runtime->dma_bytes);
+		return -ENOMEM;
+	}
+
+	snd_stm_printt("Configuring FDMA transfer nodes:\n");
+
+	for (i = 0; i < periods; i++) {
+		dma_params_init(&pcm_reader->fdma_params_list[i], MODE_PACED,
+				STM_DMA_LIST_CIRC);
+
+		if (i > 0)
+			dma_params_link(&pcm_reader->fdma_params_list[i - 1],
+					(&pcm_reader->fdma_params_list[i]));
+
+		dma_params_comp_cb(&pcm_reader->fdma_params_list[i],
+				snd_stm_pcm_reader_callback_node_done,
+				(unsigned long)pcm_reader,
+				STM_DMA_CB_CONTEXT_ISR);
+
+		dma_params_err_cb(&pcm_reader->fdma_params_list[i],
+				snd_stm_pcm_reader_callback_node_error,
+				(unsigned long)pcm_reader,
+				STM_DMA_CB_CONTEXT_ISR);
+
+		/* Get callback every time a node is completed */
+		dma_params_interrupts(&pcm_reader->fdma_params_list[i],
+				STM_DMA_NODE_COMP_INT);
+
+		dma_params_DIM_0_x_1(&pcm_reader->fdma_params_list[i]);
+
+		dma_params_req(&pcm_reader->fdma_params_list[i],
+				pcm_reader->fdma_request);
+
+		snd_stm_printt("- %d: %d bytes from 0x%08x\n", i, period_bytes,
+				runtime->dma_addr + i * period_bytes);
+
+		dma_params_addrs(&pcm_reader->fdma_params_list[i],
+				pcm_reader->fifo_phys_address,
+				runtime->dma_addr + i * period_bytes,
+				period_bytes);
+	}
+
+	result = dma_compile_list(pcm_reader->fdma_channel,
+				pcm_reader->fdma_params_list, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for"
+				" reader '%s'!\n", pcm_reader->bus_id);
+		bigphysarea_free(runtime->dma_area, runtime->dma_bytes);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+		kfree(pcm_reader->fdma_params_list);
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (pcm_reader->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_reader->bus_id,
+				pcm_reader->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
+		pcm_reader->buffer = NULL;
+
+		/* Dispose FDMA parameters (whole list) */
+		dma_params_free(pcm_reader->fdma_params_list);
+		kfree(pcm_reader->fdma_params_list);
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_reader_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Configure data memory format */
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
+				MEM_FMT, 16_BITS_16_BITS);
+
+		/* Workaround for a problem with L/R channels swap in case of
+		 * 16/16 memory model: PCM puts left channel data in
+		 * word's upper two bytes, but due to little endianess
+		 * character of our memory it will be interpreted as right
+		 * channel data...  The workaround is to invert L/R signal,
+		 * however it is cheating, because in such case channel
+		 * phases are shifted by one sample...
+		 * (ask me for more details if above is not clear ;-)
+		 * TODO this somehow better... */
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL,
+				!pcm_reader->lr_pol);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
+		 * left than zeros"... ;-) */
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
+				MEM_FMT, 16_BITS_0_BITS);
+
+		/* In x/0 bits memory mode there is no problem with
+		 * L/R polarity */
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL,
+				pcm_reader->lr_pol);
+			break;
+
+	default:
+		snd_assert(0, return -EINVAL);
+		break;
+	}
+
+	/* Number of channels... */
+
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
+			return -EINVAL);
+
+	/* Will be here in 7200 cut 2.0... */
+#if 0
+	REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, NUM_CH,
+			runtime->channels / 2);
+#endif
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_reader_start(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_reader_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Un-reset PCM reader */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RUNNING);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(pcm_reader->fdma_channel,
+			pcm_reader->fdma_params_list);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for reader '%s'!\n",
+				pcm_reader->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch PCM reader */
+
+	pcm_reader->substream = substream;
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, PCM);
+
+	/* Enable reader interrupts */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, VSYNC, SET);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, OVF, SET);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_reader_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_pcm_reader_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Disable interrupts */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, VSYNC, CLEAR);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, OVF, CLEAR);
+
+	/* Stop PCM reader */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, OFF);
+	pcm_reader->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(pcm_reader->fdma_channel);
+
+	/* Reset PCM reader */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printt("snd_stm_pcm_reader_trigger(substream=0x%p,"
+		       "command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_pcm_reader_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_pcm_reader_stop(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_pcm_reader_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printt("snd_stm_pcm_reader_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(pcm_reader->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+static struct snd_pcm_ops snd_stm_pcm_reader_pcm_ops = {
+	.open =      snd_stm_pcm_reader_open,
+	.close =     snd_stm_pcm_reader_close,
+	.mmap =      snd_stm_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_pcm_reader_hw_params,
+	.hw_free =   snd_stm_pcm_reader_hw_free,
+	.prepare =   snd_stm_pcm_reader_prepare,
+	.trigger =   snd_stm_pcm_reader_trigger,
+	.pointer =   snd_stm_pcm_reader_pointer,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_PCMIN_%s (offset 0x%02x) = 0x%08x\n", \
+				__stringify(r), AUD_PCMIN_##r, \
+				REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_##r))
+
+static void snd_stm_pcm_reader_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_pcm_reader *pcm_reader = entry->private_data;
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(FMT);
+}
+
+static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_pcm_reader_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Initialize hardware (format etc.) */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, RND, NO_ROUNDING);
+
+	if (pcm_reader->format & PLAT_STM_AUDIO__CUSTOM) {
+		/* Custom format settings... Well, you asked for it! ;-) */
+		REGISTER_POKE(pcm_reader->base, AUD_PCMIN_CTRL,
+				pcm_reader->format & !PLAT_STM_AUDIO__CUSTOM);
+	} else {
+		/* Number of bits per subframe (which is one channel sample)
+		 * on input. */
+
+		switch (pcm_reader->format &
+				PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
+		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					NBIT, 32_BITS);
+			break;
+		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					NBIT, 16_BITS);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+
+		/* Number of meaningful bits in subframe -
+		 * the rest are ignored */
+
+		switch (pcm_reader->format & PLAT_STM_AUDIO__DATA_SIZE_MASK) {
+		case PLAT_STM_AUDIO__DATA_SIZE_24_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					DATA_SIZE, 24_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_20_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					DATA_SIZE, 20_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_18_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					DATA_SIZE, 18_BITS);
+			break;
+		case PLAT_STM_AUDIO__DATA_SIZE_16_BITS:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					DATA_SIZE, 16_BITS);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+
+		/* Serial audio interface format -
+		 * for detailed explanation see ie.
+		 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				ORDER, MSB_FIRST);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				SCLK_EDGE, RISING);
+		switch (pcm_reader->format & PLAT_STM_AUDIO__FORMAT_MASK) {
+		case PLAT_STM_AUDIO__FORMAT_I2S:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					ALIGN, LEFT);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					PADDING, 1_CYCLE_DELAY);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					LR_POL, LEFT_LOW);
+			break;
+		case PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					ALIGN, LEFT);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					PADDING, NO_DELAY);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					LR_POL, LEFT_HIGH);
+			break;
+		case PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED:
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					ALIGN, RIGHT);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					PADDING, NO_DELAY);
+			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+					LR_POL, LEFT_HIGH);
+			break;
+		default:
+			snd_assert(0, return -EINVAL);
+			break;
+		}
+	}
+
+	/* Workaround for 16/16 memory format L/R channels swap (see above) */
+	pcm_reader->lr_pol = REGFIELD_PEEK(pcm_reader->base,
+			AUD_PCMIN_FMT, LR_POL);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&pcm_reader->proc_entry, pcm_reader->bus_id,
+			snd_stm_pcm_reader_dump_registers, pcm_reader);
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_pcm_reader_unregister(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_stm_info_unregister(pcm_reader->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_pcm_reader_ops = {
+	.dev_register = snd_stm_pcm_reader_register,
+	.dev_disconnect = snd_stm_pcm_reader_disconnect,
+};
+
+
+
+/*
+ * Driver initialization
+ */
+
+#define FORMAT_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "custom" : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_I2S ? "I2S, " : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED ? \
+		"left justified, " : \
+	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
+		PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED ? \
+		"right justified, " : \
+	"")
+
+#define DATA_SIZE_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "" : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_24_BITS ? \
+		"24 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_20_BITS ? \
+		"20 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_18_BITS ? \
+		"18 bits data, " : \
+	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
+		PLAT_STM_AUDIO__DATA_SIZE_16_BITS ? \
+		"16 bits data, " : \
+	"")
+
+#define OUTPUT_SUBFRAME_STRING(f) \
+	((f & PLAT_STM_AUDIO__CUSTOM) == \
+		PLAT_STM_AUDIO__CUSTOM ? "" : \
+	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS ? \
+		"32 bits output subframe" : \
+	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
+		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS ? \
+		"16 bits output subframe" : \
+	"")
+
+static struct stm_dma_req_config snd_stm_pcm_reader_fdma_request_config = {
+	.rw        = REQ_CONFIG_READ,
+	.opcode    = REQ_CONFIG_OPCODE_4,
+	.count     = 1,
+	.increment = 0,
+	.hold_off  = 0,
+	/* .initiator value is defined in platform device resources */
+};
+
+static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct plat_audio_config *config = pdev->dev.platform_data;
+	struct snd_stm_component *component;
+	struct snd_stm_pcm_reader *pcm_reader;
+	struct snd_card *card;
+	int card_device;
+	int *channels_list;
+	int channels_list_len;
+	const char *card_id;
+	int i;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
+	if (!pcm_reader) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(pcm_reader);
+	pcm_reader->bus_id = pdev->dev.bus_id;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &pcm_reader->mem_region,
+			&pcm_reader->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	pcm_reader->fifo_phys_address = pcm_reader->mem_region->start +
+		AUD_PCMIN_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
+			pcm_reader->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &pcm_reader->irq,
+			snd_stm_pcm_reader_irq_handler, pcm_reader);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &pcm_reader->fdma_channel,
+			&pcm_reader->fdma_request,
+			&snd_stm_pcm_reader_fdma_request_config);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* Get component caps */
+
+	snd_printd("Reader's name is '%s'\n", component->short_name);
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	snd_assert(result == 0, return -EINVAL);
+	card = snd_stm_cards_get(card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Reader will be a member of a card '%s'...\n", card_id);
+
+	result = snd_stm_cap_get_number(component, "card_device",
+			&card_device);
+	snd_assert(result == 0, return -EINVAL);
+	snd_printd("... as a PCM device no %d.\n", card_device);
+
+	result = snd_stm_cap_get_list(component, "channels", &channels_list,
+			&channels_list_len);
+	snd_assert(result == 0, return -EINVAL);
+	memcpy(pcm_reader->channels_constraint_list, channels_list,
+			sizeof(*channels_list) * channels_list_len);
+	pcm_reader->channels_constraint.list =
+			pcm_reader->channels_constraint_list;
+	pcm_reader->channels_constraint.count =
+		(unsigned int)channels_list_len;
+	pcm_reader->channels_constraint.mask = 0;
+	for (i = 0; i < channels_list_len; i++)
+		snd_printd("Reader capable of capturing %d-channels PCM.\n",
+				channels_list[i]);
+
+	/* Board-specific configuration */
+
+	if (config) {
+		pcm_reader->format = config->pcm_format;
+		snd_printd("Using board specific PCM format"
+				" (%s%s%s, 0x%08lx).\n",
+				FORMAT_STRING(pcm_reader->format),
+				DATA_SIZE_STRING(pcm_reader->format),
+				OUTPUT_SUBFRAME_STRING(pcm_reader->format),
+				pcm_reader->format);
+	} else {
+		pcm_reader->format = DEFAULT_FORMAT;
+		snd_printd("Using default PCM format (%s%s%s).\n",
+				FORMAT_STRING(pcm_reader->format),
+				DATA_SIZE_STRING(pcm_reader->format),
+				OUTPUT_SUBFRAME_STRING(pcm_reader->format));
+	}
+
+	/* Preallocate buffer */
+
+	/* TODO */
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_reader,
+			&snd_stm_pcm_reader_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, card_device, 0, 1, &pcm_reader->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	pcm_reader->pcm->private_data = pcm_reader;
+	strcpy(pcm_reader->pcm->name, component->short_name);
+
+	snd_pcm_set_ops(pcm_reader->pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_stm_pcm_reader_pcm_ops);
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, pcm_reader);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_pcm:
+	snd_device_free(card, pcm_reader);
+error_device:
+	snd_stm_fdma_release(pcm_reader->fdma_channel,
+			pcm_reader->fdma_request);
+error_fdma_request:
+	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
+error_irq_request:
+	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
+error_memory_request:
+	snd_stm_magic_clear(pcm_reader);
+	kfree(pcm_reader);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_reader_remove(struct platform_device *pdev)
+{
+	struct snd_stm_pcm_reader *pcm_reader = platform_get_drvdata(pdev);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	snd_stm_fdma_release(pcm_reader->fdma_channel,
+			pcm_reader->fdma_request);
+	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
+	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
+
+	snd_stm_magic_clear(pcm_reader);
+	kfree(pcm_reader);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_pcm_reader_driver = {
+	.driver = {
+		.name = "pcm_reader",
+	},
+	.probe = snd_stm_pcm_reader_probe,
+	.remove = snd_stm_pcm_reader_remove,
+};
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_pcm_reader_init(void)
+{
+	return platform_driver_register(&snd_stm_pcm_reader_driver);
+}
+
+void snd_stm_pcm_reader_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_pcm_reader_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/spdif_player.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/spdif_player.c
@@ -0,0 +1,1397 @@
+/*
+ *   STMicroelectronics System-on-Chips' SPDIF player driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/bpa2.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 8 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define INIT_SAMPLING_RATE 32000
+
+#define DEFAULT_OVERSAMPLING 128
+
+/* The sample count field (MEMREAD in CTRL register) is 17 bits wide */
+#define MAX_SAMPLES_PER_PERIOD ((1 << 17) - 1)
+
+
+
+/*
+ * SPDIF player instance definition
+ */
+
+enum snd_stm_spdif_player_input_mode {
+	SNDRV_STM_SPDIF_INPUT_MODE_NORMAL,
+	SNDRV_STM_SPDIF_INPUT_MODE_RAW
+};
+
+enum snd_stm_spdif_player_encoding_mode {
+	SNDRV_STM_SPDIF_ENCODING_MODE_PCM,
+	SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED
+};
+
+struct snd_stm_spdif_player {
+	/* System informations */
+	const char *name;
+	const char *bus_id;
+	struct snd_pcm *pcm;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	int fdma_channel;
+	struct stm_dma_req *fdma_request;
+
+	/* Environment settings */
+	struct device *fsynth;
+	int fsynth_channel;
+
+	/* Board-specific settings */
+	unsigned int oversampling;
+
+	/* Default configuration */
+	enum snd_stm_spdif_player_input_mode input_mode_default;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode_default;
+	spinlock_t modes_default_lock; /* Protects above two enums */
+	struct snd_aes_iec958 vuc_default;
+	spinlock_t vuc_default_lock; /* Protects vuc_default */
+
+	/* Runtime data */
+	void *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	struct stm_dma_params fdma_params;
+	struct snd_aes_iec958 vuc_stream;
+	spinlock_t vuc_stream_lock; /* Protects vuc_stream */
+	enum snd_stm_spdif_player_input_mode input_mode;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode;
+	struct snd_aes_iec958 vuc;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Playing engine implementation
+ */
+
+static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_spdif_player *spdif_player = dev_id;
+	unsigned int status;
+
+	snd_stm_printt("snd_stm_spdif_player_irq_handler(irq=%d, "
+			"dev_id=0x%p)\n", irq, dev_id);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = REGISTER_PEEK(spdif_player->base, AUD_SPDIF_ITS);
+	REGISTER_POKE(spdif_player->base, AUD_SPDIF_ITS_CLR, status);
+	preempt_enable();
+
+	/* Underflow? */
+	if (unlikely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, UNF, PENDING))) {
+		snd_stm_printe("Underflow detected in SPDIF player '%s'!\n",
+				spdif_player->bus_id);
+		result = IRQ_HANDLED;
+	}
+
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, NSAMPLE, PENDING)))
+		do {
+			snd_assert(spdif_player->substream, break);
+
+			snd_stm_printt("Period elapsed ('%s')\n",
+					spdif_player->bus_id);
+			snd_pcm_period_elapsed(spdif_player->substream);
+
+			result = IRQ_HANDLED;
+		} while (0);
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+/* In normal mode we are preparing SPDIF formating "manually".
+ * It means:
+ * 1. A lot of parsing...
+ * 2. MMAPing is impossible...
+ * 3. We can handle different formats and use ALSA standard
+ *    structure for channel status & user data: snd_aes_iec958 */
+static struct snd_pcm_hardware snd_stm_spdif_player_hw_normal = {
+	.info		= (SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S24_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000),
+	.rate_min	= 32000,
+	.rate_max	= 48000,
+
+	.channels_min	= 2,
+	.channels_max	= 2,
+
+	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note 1: that these value must be also calculated not to exceed
+	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
+	 * Note 2: period_bytes_min defines minimum time between period
+	 * (NSAMPLE) interrupts... Keep it large enough not to kill
+	 * the system... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+/* In raw mode SPDIF formatting must be prepared by user. Every sample
+ * (one channel) is a 32 bits word containing up to 24 bits of data
+ * and 4 SPDIF control bits: V(alidty flag), U(ser data), C(hannel status),
+ * P(arity bit):
+ *
+ *      +---------------+---------------+---------------+---------------+
+ *      |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
+ * bit: |1|0|9|8|6|7|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
+ *      +---------------+---------------+---------------+-------+-------+
+ *      |M                                             L|       |       |
+ *      |S          sample data (up to 24 bits)        S|0|0|0|0|V|U|C|0|
+ *      |B                                             B|       |       |
+ *      +-----------------------------------------------+-------+-------+
+ *
+ * SPDIF player sends subframe's sync preamble first (thanks at least
+ * for this ;-)), than data starting from LSB (so samples smaller than
+ * 24 bits should be aligned to MSB and have zeros as LSBs), than VUC bits
+ * and finally adds a parity bit (thanks again ;-).
+ */
+static struct snd_pcm_hardware snd_stm_spdif_player_hw_raw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000),
+	.rate_min	= 32000,
+	.rate_max	= 48000,
+
+	.channels_min	= 2,
+	.channels_max	= 2,
+
+	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* See above... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_spdif_player_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_open(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Get default data */
+
+	spin_lock(&spdif_player->vuc_default_lock);
+	spdif_player->vuc_stream = spdif_player->vuc_default;
+	spin_unlock(&spdif_player->vuc_default_lock);
+
+	spin_lock(&spdif_player->modes_default_lock);
+	spdif_player->encoding_mode = spdif_player->encoding_mode_default;
+	spdif_player->input_mode = spdif_player->input_mode_default;
+	spin_unlock(&spdif_player->modes_default_lock);
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	/* It is better when buffer size is an integer multiple of period
+	 * size... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	if (spdif_player->input_mode == SNDRV_STM_SPDIF_INPUT_MODE_NORMAL)
+		runtime->hw = snd_stm_spdif_player_hw_normal;
+	else
+		runtime->hw = snd_stm_spdif_player_hw_raw;
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_spdif_player_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes;
+
+	snd_stm_printt("snd_stm_spdif_player_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Allocate buffer */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	spdif_player->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
+	if (!spdif_player->buffer) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, spdif_player->bus_id);
+		return -ENOMEM;
+	}
+
+	runtime->dma_addr = virt_to_phys(spdif_player->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", spdif_player->bus_id,
+			spdif_player->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
+	/* Configure FDMA transfer */
+
+	/* TODO: try to use SPDIF FMDA channel */
+
+	dma_params_init(&spdif_player->fdma_params, MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	dma_params_DIM_1_x_0(&spdif_player->fdma_params);
+
+	dma_params_req(&spdif_player->fdma_params, spdif_player->fdma_request);
+
+	dma_params_addrs(&spdif_player->fdma_params, runtime->dma_addr,
+			spdif_player->fifo_phys_address, buffer_bytes);
+
+	result = dma_compile_list(spdif_player->fdma_channel,
+				&spdif_player->fdma_params, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for player"
+				" '%s'!\n", spdif_player->bus_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (spdif_player->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", spdif_player->bus_id,
+				spdif_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
+		spdif_player->buffer = NULL;
+
+		/* Dispose FDMA parameters */
+
+		dma_params_free(&spdif_player->fdma_params);
+	}
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+
+	/* Configure SPDIF-PCM synchronisation */
+
+	/* TODO */
+
+	/* Set up frequency synthesizer */
+
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth,
+			spdif_player->fsynth_channel,
+			runtime->rate * spdif_player->oversampling);
+
+	/* Configure SPDIF player frequency divider
+	 *
+	 *                        Fdacclk
+	 * divider = ------------------------------- =
+	 *            2 * Fs * bits_in_output_frame
+	 *
+	 *            Fs * oversampling     oversampling
+	 *         = ------------------- = --------------
+	 *            2 * Fs * (32 * 2)         128
+	 * where:
+	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
+	 *               MCLK (master clock), "system clock" etc.
+	 *   - Fs - sampling rate (frequency)
+	 */
+
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, CLK_DIV,
+			spdif_player->oversampling / 128);
+
+	/* Configure NSAMPLE interrupt (in samples,
+	 * so period size times channels) */
+
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, MEMREAD,
+			runtime->period_size * 2);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
+		*substream)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_spdif_player_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Un-reset SPDIF player */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RUNNING);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(spdif_player->fdma_channel,
+			&spdif_player->fdma_params);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
+				spdif_player->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch SPDIF player */
+
+	spdif_player->substream = substream;
+
+	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
+	else
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
+
+	/* Enable player interrupts */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, NSAMPLE, SET);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, UNF, SET);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_spdif_player_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Disable interrupts */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, NSAMPLE, CLEAR);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, UNF, CLEAR);
+
+	/* Stop SPDIF player */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, OFF);
+	spdif_player->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(spdif_player->fdma_channel);
+
+	/* Reset SPDIF player */
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_pause(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_spdif_player_pause(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* "Mute" player
+	 * Documentation describes this mode in a wrong way - data is _not_
+	 * consumed in the "mute" mode, so it is actually a "pause" mode */
+
+	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
+				MUTE_PCM_NULL);
+	else
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
+				MUTE_PAUSE_BURSTS);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_release(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+
+	snd_stm_printt("snd_stm_spdif_player_release(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* "Unmute" player */
+
+	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
+	else
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printt("snd_stm_spdif_player_trigger(substream=0x%p,"
+			" command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_spdif_player_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_spdif_player_stop(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return snd_stm_spdif_player_pause(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return snd_stm_spdif_player_release(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_spdif_player_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printt("snd_stm_spdif_player_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(spdif_player->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+#define GET_SAMPLE(kernel_var, user_ptr, memory_format) \
+	do { \
+		__get_user(kernel_var, (memory_format __user *)user_ptr); \
+		(*((memory_format __user **)&user_ptr))++; \
+	} while (0);
+
+static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
+		int channel, snd_pcm_uframes_t pos,
+		void __user *buf, snd_pcm_uframes_t count)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_copy(substream=0x%p, channel=%d,"
+			" pos=%lu, buf=0x%p, count=%lu)\n", substream,
+			channel, pos, buf, count);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+
+	if (spdif_player->input_mode == SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
+		unsigned long *hwbuf = (unsigned long *)(runtime->dma_area +
+				frames_to_bytes(runtime, pos));
+		int i;
+
+		if (!access_ok(VERIFY_READ, buf, frames_to_bytes(runtime,
+						count)))
+			return -EFAULT;
+
+		snd_stm_printt("Formatting SPDIF frame (format=%d)\n",
+				runtime->format);
+
+#if 0
+		{
+			unsigned char data[64];
+
+			copy_from_user(data, buf, 64);
+
+			snd_stm_printt("Input:\n");
+			snd_stm_hex_dump(data, 64);
+		}
+#endif
+
+		for (i = 0; i < count; i++) {
+			unsigned long left_subframe, right_subframe;
+
+			switch (runtime->format) {
+			case SNDRV_PCM_FORMAT_S32_LE:
+				GET_SAMPLE(left_subframe, buf, u32);
+				GET_SAMPLE(right_subframe, buf, u32);
+				break;
+			case SNDRV_PCM_FORMAT_S24_LE:
+				/* 24-bits sample are in lower 3 bytes,
+				 * while we want them in upper 3... ;-) */
+				GET_SAMPLE(left_subframe, buf, u32);
+				left_subframe <<= 8;
+				GET_SAMPLE(right_subframe, buf, u32);
+				right_subframe <<= 8;
+				break;
+			default:
+				snd_assert(0, return -EINVAL);
+				break;
+			}
+
+			/* TODO: VUC bits, now just 000... */
+			left_subframe &= ~0x03;
+			right_subframe &= ~0x03;
+
+			*(hwbuf++) = left_subframe;
+			*(hwbuf++) = right_subframe;
+		}
+
+#if 0
+		snd_stm_printt("Output:\n");
+		snd_stm_hex_dump(runtime->dma_area +
+				frames_to_bytes(runtime, pos), 64);
+#endif
+		dma_cache_wback(runtime->dma_area +
+				frames_to_bytes(runtime, pos),
+				frames_to_bytes(runtime, count));
+	} else {
+		/* RAW mode */
+		if (copy_from_user(runtime->dma_area +
+				frames_to_bytes(runtime, pos), buf,
+				frames_to_bytes(runtime, count)) != 0)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_silence(struct snd_pcm_substream *substream,
+		int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_silence(substream=0x%p, "
+			"channel=%d, pos=%lu, count=%lu)\n",
+			substream, channel, pos, count);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+
+	snd_assert(0, return -EINVAL); /* Not implemented yet */
+	/* TODO	*/
+
+	return 0;
+}
+
+static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
+	.open =      snd_stm_spdif_player_open,
+	.close =     snd_stm_spdif_player_close,
+	.mmap =      snd_stm_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_spdif_player_hw_params,
+	.hw_free =   snd_stm_spdif_player_hw_free,
+	.prepare =   snd_stm_spdif_player_prepare,
+	.trigger =   snd_stm_spdif_player_trigger,
+	.pointer =   snd_stm_spdif_player_pointer,
+	.copy =      snd_stm_spdif_player_copy,
+	.silence =   snd_stm_spdif_player_silence,
+};
+
+
+
+/*
+ * ALSA controls
+ */
+
+/* "Main switch" - controls IDLE mode of SPDIF player */
+
+static int snd_stm_spdif_player_ctl_switch_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_switch_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	ucontrol->value.integer.value[0] =
+			(REGFIELD_PEEK(spdif_player->base, AUD_SPDIF_CTRL,
+			IDLE) == AUD_SPDIF_CTRL__IDLE__VALUE__NORMAL);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_switch_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_switch_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	if (ucontrol->value.integer.value[0])
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
+	else
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, IDLE);
+
+	return changed;
+}
+
+/* "Raw Data" switch controls data input mode - "RAW" means that played
+ * data are already properly formated (VUC bits); in "normal" mode
+ * this data will be added by driver according to setting passed in\
+ * following controls */
+
+static int snd_stm_spdif_player_ctl_raw_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(spdif_player->modes_default_lock);
+	ucontrol->value.integer.value[0] = (spdif_player->input_mode_default
+			== SNDRV_STM_SPDIF_INPUT_MODE_RAW);
+	spin_unlock(spdif_player->modes_default_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_raw_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	enum snd_stm_spdif_player_input_mode input_mode;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	if (ucontrol->value.integer.value[0])
+		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_RAW;
+	else
+		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_NORMAL;
+
+	spin_lock(spdif_player->modes_default_lock);
+	changed = (input_mode != spdif_player->input_mode_default);
+	spdif_player->input_mode_default = input_mode;
+	spin_unlock(spdif_player->modes_default_lock);
+
+	return changed;
+}
+
+/* "Encoded Data" switch selects linear PCM or encoded operation of
+ * SPDIF player - the difference is in generating mute data; PCM mode
+ * will generate NULL data, encoded - pause bursts */
+
+static int snd_stm_spdif_player_ctl_encoded_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(spdif_player->modes_default_lock);
+	ucontrol->value.integer.value[0] = (spdif_player->encoding_mode_default
+			== SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED);
+	spin_unlock(spdif_player->modes_default_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_encoded_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	if (ucontrol->value.integer.value[0])
+		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED;
+	else
+		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_PCM;
+
+	spin_lock(spdif_player->modes_default_lock);
+	changed = (encoding_mode != spdif_player->encoding_mode_default);
+	spdif_player->encoding_mode_default = encoding_mode;
+	spin_unlock(spdif_player->modes_default_lock);
+
+	return changed;
+}
+
+/* Three following controls are valid for encoded mode only - they
+ * control IEC 61937 preamble and data burst periods (see mentioned
+ * standard for more informations) */
+
+static int snd_stm_spdif_player_ctl_preamble_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = 16;
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_preamble_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_preamble_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return changed;
+}
+
+static int snd_stm_spdif_player_ctl_repetition_info(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xffff;
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_audio_repetition_get(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_audio_repetition_put(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return changed;
+}
+
+static int snd_stm_spdif_player_ctl_pause_repetition_get(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_pause_repetition_put(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* TODO */
+
+	return changed;
+}
+
+static struct snd_kcontrol_new __initdata snd_stm_spdif_player_ctls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, SWITCH),
+		.info = snd_stm_ctl_boolean_info,
+		.get = snd_stm_spdif_player_ctl_switch_get,
+		.put = snd_stm_spdif_player_ctl_switch_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Raw Data ", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_boolean_info,
+		.get = snd_stm_spdif_player_ctl_raw_get,
+		.put = snd_stm_spdif_player_ctl_raw_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Encoded Data ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_boolean_info,
+		.get = snd_stm_spdif_player_ctl_encoded_get,
+		.put = snd_stm_spdif_player_ctl_encoded_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Preamble ", PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_preamble_info,
+		.get = snd_stm_spdif_player_ctl_preamble_get,
+		.put = snd_stm_spdif_player_ctl_preamble_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Audio Burst Period ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_repetition_info,
+		.get = snd_stm_spdif_player_ctl_audio_repetition_get,
+		.put = snd_stm_spdif_player_ctl_audio_repetition_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Pause Burst Period ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_repetition_info,
+		.get = snd_stm_spdif_player_ctl_pause_repetition_get,
+		.put = snd_stm_spdif_player_ctl_pause_repetition_put,
+	}
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_SPDIF_%s (offset 0x%02x) =" \
+				" 0x%08x\n", __stringify(r), \
+				AUD_SPDIF_##r, \
+				REGISTER_PEEK(spdif_player->base, \
+				AUD_SPDIF_##r))
+
+static void snd_stm_spdif_player_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_spdif_player *spdif_player = entry->private_data;
+
+	snd_assert(spdif_player, return);
+	snd_stm_magic_assert(spdif_player, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(PA_PB);
+	DUMP_REGISTER(PC_PD);
+	DUMP_REGISTER(CL1);
+	DUMP_REGISTER(CR1);
+	DUMP_REGISTER(CL2_CR2_UV);
+	DUMP_REGISTER(PAU_LAT);
+	DUMP_REGISTER(BST_FL);
+}
+
+static int snd_stm_spdif_player_register(struct snd_device *snd_device)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_spdif_player_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Set a default clock frequency running for each device.
+	 * Not doing this can lead to clocks not starting correctly later,
+	 * for reasons that cannot be explained at this time. */
+	/* TODO: Check it, maybe obsolete now */
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth,
+			spdif_player->fsynth_channel,
+			INIT_SAMPLING_RATE * spdif_player->oversampling);
+
+	/* Initialize hardware (format etc.) */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, RND, NO_ROUNDING);
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
+
+	/* Hardware stuffing is not implemented yet... */
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, STUFFING, SOFTWARE);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&spdif_player->proc_entry, spdif_player->bus_id,
+			snd_stm_spdif_player_dump_registers, spdif_player);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
+
+	snd_stm_printt("snd_stm_spdif_player_unregister(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_stm_info_unregister(spdif_player->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_spdif_player_ops = {
+	.dev_register = snd_stm_spdif_player_register,
+	.dev_disconnect = snd_stm_spdif_player_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static struct stm_dma_req_config snd_stm_spdif_player_fdma_request_config = {
+	.rw        = REQ_CONFIG_WRITE,
+	.opcode    = REQ_CONFIG_OPCODE_4,
+	.count     = 1,
+	.increment = 0,
+	.hold_off  = 0,
+	/* .initiator value is defined in platform device resources */
+};
+
+static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct plat_audio_config *config = pdev->dev.platform_data;
+	struct snd_stm_component *component;
+	struct snd_stm_spdif_player *spdif_player;
+	struct snd_card *card;
+	int card_device;
+	const char *card_id;
+	const char *fsynth_bus_id;
+	int i;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	component = snd_stm_components_get(pdev->dev.bus_id);
+	snd_assert(component, return -EINVAL);
+
+	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
+	if (!spdif_player) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(spdif_player);
+	spdif_player->bus_id = pdev->dev.bus_id;
+
+	spin_lock_init(&spdif_player->modes_default_lock);
+	spin_lock_init(&spdif_player->vuc_default_lock);
+	spin_lock_init(&spdif_player->vuc_stream_lock);
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &spdif_player->mem_region,
+			&spdif_player->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	spdif_player->fifo_phys_address = spdif_player->mem_region->start +
+		AUD_SPDIF_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
+			spdif_player->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &spdif_player->irq,
+			snd_stm_spdif_player_irq_handler, spdif_player);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &spdif_player->fdma_channel,
+			&spdif_player->fdma_request,
+			&snd_stm_spdif_player_fdma_request_config);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* Get component caps */
+
+	snd_printd("Player's name is '%s'\n", component->short_name);
+
+	result = snd_stm_cap_get_string(component, "card_id", &card_id);
+	snd_assert(result == 0, return -EINVAL);
+	card = snd_stm_cards_get(card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Player will be a member of a card '%s'...\n", card_id);
+
+	result = snd_stm_cap_get_number(component, "card_device",
+			&card_device);
+	snd_assert(result == 0, return -EINVAL);
+	snd_printd("... as a PCM device no %d.\n", card_device);
+
+	result = snd_stm_cap_get_string(component, "fsynth_bus_id",
+			&fsynth_bus_id);
+	snd_assert(result == 0, return -EINVAL);
+	spdif_player->fsynth = snd_stm_device_get(fsynth_bus_id);
+	snd_assert(spdif_player->fsynth, return -EINVAL);
+	result = snd_stm_cap_get_number(component, "fsynth_channel",
+			&spdif_player->fsynth_channel);
+	snd_assert(result == 0, return -EINVAL);
+	snd_printd("Player clocked by channel %d of synthesizer %s.\n",
+			spdif_player->fsynth_channel, fsynth_bus_id);
+
+	/* Board-specific configuration */
+
+	if (config) {
+		spdif_player->oversampling = config->oversampling;
+	} else {
+		spdif_player->oversampling = DEFAULT_OVERSAMPLING;
+	}
+	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
+	 * so oversampling 192x is forbidden, use ie. 384x instead) */
+	snd_assert(spdif_player->oversampling == 128 ||
+			spdif_player->oversampling == 256 ||
+			spdif_player->oversampling == 384 ||
+			spdif_player->oversampling == 512 ||
+			spdif_player->oversampling == 768,
+			return -EINVAL);
+
+	/* Default VUC data - consumer, PCM linear, no copyright */
+	/* TODO: make it configurable per board */
+	spdif_player->vuc_default.status[0] = IEC958_AES0_CON_NOT_COPYRIGHT;
+	/* All the rest is zeros, which is fine for us :-) */
+
+	/* Preallocate buffer */
+
+	/* TODO */
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, spdif_player,
+			&snd_stm_spdif_player_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, card_device, 1, 0,
+			&spdif_player->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	spdif_player->pcm->private_data = spdif_player;
+	strcpy(spdif_player->pcm->name, component->short_name);
+
+	snd_pcm_set_ops(spdif_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_stm_spdif_player_spdif_ops);
+
+	/* Create ALSA controls */
+
+	result = 0;
+	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
+		snd_stm_spdif_player_ctls[i].device = card_device;
+		result |= snd_ctl_add(card,
+				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
+				spdif_player));
+		/* TODO: index per card */
+		snd_stm_spdif_player_ctls[i].index++;
+	}
+	result |= snd_stm_fsynth_add_adjustement_ctl(spdif_player->fsynth,
+			spdif_player->fsynth_channel, card, card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA controls!\n");
+		goto error_controls;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, spdif_player);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_controls:
+error_pcm:
+	snd_device_free(card, spdif_player);
+error_device:
+	snd_stm_fdma_release(spdif_player->fdma_channel,
+			spdif_player->fdma_request);
+error_fdma_request:
+	snd_stm_irq_release(spdif_player->irq, spdif_player);
+error_irq_request:
+	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
+error_memory_request:
+	snd_stm_magic_clear(spdif_player);
+	kfree(spdif_player);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_spdif_player_remove(struct platform_device *pdev)
+{
+	struct snd_stm_spdif_player *spdif_player = platform_get_drvdata(pdev);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	snd_stm_fdma_release(spdif_player->fdma_channel,
+			spdif_player->fdma_request);
+	snd_stm_irq_release(spdif_player->irq, spdif_player);
+	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
+
+	snd_stm_magic_clear(spdif_player);
+	kfree(spdif_player);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_spdif_player_driver = {
+	.driver = {
+		.name = "spdif_player",
+	},
+	.probe = snd_stm_spdif_player_probe,
+	.remove = snd_stm_spdif_player_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_spdif_player_init(void)
+{
+	return platform_driver_register(&snd_stm_spdif_player_driver);
+}
+
+void snd_stm_spdif_player_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_spdif_player_driver);
+}
Index: linux-2.6.23-stm/sound/soc/stm/stx710x.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/stx710x.c
@@ -0,0 +1,345 @@
+/*
+ *   STMicrolectronics STx7100 SoC description
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#undef TRACE
+#include "common.h"
+
+
+
+/*
+ * ALSA cards list and descriptions
+ */
+
+static struct snd_stm_card __initdata snd_stm_stx710x_cards[] = {
+	{
+		.index = 0,
+		.id = "PCM",
+		.short_name = "PCM output",
+		.long_name = "Digital audio output (PCM player 0)",
+	},
+	{
+		.index = 1,
+		.id = "ANALOG",
+		.short_name = "Analog output",
+		.long_name = "Analog audio output (PCM player 1)",
+	},
+	{
+		.index = 2,
+		.id = "SPDIF",
+		.short_name = "SPDIF output",
+		.long_name = "SPDIF audio output",
+	},
+	{
+		.index = 4,
+		.id = "INPUT",
+		.short_name = "PCM input",
+		.long_name = "Digital audio input (PCM reader)",
+	}
+};
+
+
+
+/*
+ * SoC audio components description
+ */
+
+enum { audio_outputs, fsynth, pcm_reader, dac_internal,
+	pcm_player_0, pcm_player_1,
+	spdif_player, i2s_spdif_converter };
+
+static struct snd_stm_component __initdata snd_stm_stx710x_components[] = {
+
+	/* Audio outputs control */
+
+	[audio_outputs] = {
+		.bus_id = "audio_outputs",
+		.short_name = "Audio outputs control",
+		.num_caps = 0,
+	},
+
+	/* Frequency synthesizer */
+
+	[fsynth] = {
+		.bus_id = "fsynth",
+		.short_name = "Frequency synthesizer",
+		.num_caps = 1,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.range.from = 0,
+				.value.range.to = 2,
+			},
+		},
+	},
+
+	/* PCM reader */
+
+	[pcm_reader] = {
+		.bus_id = "pcm_reader",
+		.short_name = "PCM reader",
+		.num_caps = 3,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int []) { 2 },
+				.value.list.len     = 1,
+			},
+			{
+				.name = "card_id",
+				.value.string = "INPUT",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+		},
+	},
+
+	/* Internal audio DACs */
+
+	[dac_internal] = {
+		.bus_id = "dac_internal",
+		.short_name = "Internal DAC",
+		.num_caps = 0,
+	},
+
+	/* PCM players */
+
+	[pcm_player_0] = {
+		.bus_id = "pcm_player.0",
+		.short_name = "PCM player #0",
+		.num_caps = 6,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				/* SOC version dependant, see function below */
+			},
+			{
+				.name = "card_id",
+				.value.string = "PCM",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 0,
+			},
+			{
+				.name = "sclk_edge_falling",
+				/* SOC version dependant, see function below */
+			},
+		},
+	},
+
+	[pcm_player_1] = {
+		.bus_id = "pcm_player.1",
+		.short_name = "PCM player #1",
+		.num_caps = 6,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int []) { 2 },
+				.value.list.len = 1,
+			},
+			{
+				.name = "card_id",
+				.value.string = "ANALOG",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 1,
+			},
+			{
+				.name = "dac_bus_id",
+				.value.string = "dac_internal",
+			},
+		},
+	},
+
+	/* SPDIF player */
+
+	[spdif_player] = {
+		.bus_id = "spdif_player",
+		.short_name = "SPDIF player",
+		.num_caps = 4,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "card_id",
+				.value.string = "SPDIF",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name         = "fsynth_bus_id",
+				.value.string = "fsynth",
+			},
+			{
+				.name         = "fsynth_channel",
+				.value.number = 2,
+			},
+		},
+	},
+
+	/* HDMI output */
+
+	[i2s_spdif_converter] = {
+		.bus_id = "i2s-spdif_conv",
+		.short_name = "I2S to SPDIF converter",
+		.num_caps = 0,
+	},
+};
+
+
+
+/*
+ * Initialization and runtime configuration
+ */
+
+static union snd_stm_value __initdata number_0 = { .number = 0 };
+static union snd_stm_value __initdata number_1 = { .number = 0 };
+static union snd_stm_value __initdata list_2  = {
+	.list.len = 1,
+	.list.numbers = (int []) { 2 }
+};
+static union snd_stm_value __initdata list_2_10 = {
+	.list.len = 5,
+	.list.numbers = (int []) { 2, 4, 6, 8, 10 }
+};
+
+int __init snd_stm_stx710x_init(void)
+{
+	int result;
+	const char *soc_type;
+	/* To have lines shorter than 80 chars... */
+	struct snd_stm_component *components = snd_stm_stx710x_components;
+
+	switch (cpu_data->type) {
+	case CPU_STB7100:
+		soc_type = "STx7100";
+
+		/* STx7100 PCM players have small hardware bug - bit SCLK_EDGE
+		 * in AUD_PCMOUT_FMT register has opposite meaning than stated
+		 * in datasheet - 0 means that PCM serial output is clocked
+		 * (changed) during falling SCLK edge (which is usually what
+		 * we want ;-) */
+		snd_stm_cap_set(&components[pcm_player_0],
+				"sclk_edge_falling", number_0);
+		snd_stm_cap_set(&components[pcm_player_1],
+				"sclk_edge_falling", number_0);
+
+		if (cpu_data->cut_major < 3) {
+
+			/* STx7100 cut < 3.0 */
+
+			/* Hardware bug again - in early 7100s player ignored
+			 * NUM_CH setting in AUD_PCMOUT_FMT register */
+			snd_stm_cap_set(&components[pcm_player_0],
+					"channels", list_2_10);
+			snd_stm_cap_set(&components[pcm_player_1],
+					"channels", list_2_10);
+		} else {
+
+			/* STx7100 cut >= 3.0 */
+
+			snd_stm_cap_set(&components[pcm_player_0],
+					"channels", list_2_10);
+			snd_stm_cap_set(&components[pcm_player_1],
+					"channels", list_2);
+		}
+		break;
+
+	case CPU_STB7109:
+		soc_type = "STx7109";
+
+		snd_stm_cap_set(&components[pcm_player_0],
+				"channels", list_2_10);
+		snd_stm_cap_set(&components[pcm_player_1],
+				"channels", list_2);
+
+		if (cpu_data->cut_major < 3) {
+
+			/* STx7109 cut < 3.0 */
+
+			/* PCM players of early 7109s have small hardware bug -
+			 * bit SCLK_EDGE in AUD_PCMOUT_FMT register has
+			 * opposite meaning than stated in datasheet - 0 means
+			 * that PCM serial output is clocked (changed) during
+			 * falling SCLK edge (which is usually what we
+			 * want ;-) */
+			snd_stm_cap_set(&components[pcm_player_0],
+					"sclk_edge_falling", number_0);
+			snd_stm_cap_set(&components[pcm_player_1],
+					"sclk_edge_falling", number_0);
+		} else {
+
+			/* STx7109 cut >= 3.0 */
+
+			snd_stm_cap_set(&components[pcm_player_0],
+					"sclk_edge_falling", number_1);
+			snd_stm_cap_set(&components[pcm_player_1],
+					"sclk_edge_falling", number_1);
+		}
+
+		break;
+
+	default:
+		/* Unknown CPU! */
+		snd_assert(0, return -EINVAL);
+		break;
+	}
+
+	result = snd_stm_cards_init(soc_type,
+			snd_stm_stx710x_cards,
+			ARRAY_SIZE(snd_stm_stx710x_cards));
+
+	if (result == 0) {
+		result = snd_stm_components_init(snd_stm_stx710x_components,
+				ARRAY_SIZE(snd_stm_stx710x_components));
+
+		if (result < 0)
+			snd_stm_cards_free();
+	}
+
+	return result;
+}
Index: linux-2.6.23-stm/sound/soc/stm/stx7200.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/stx7200.c
@@ -0,0 +1,425 @@
+/*
+ *   STMicrolectronics STx7200 SoC description
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#undef TRACE
+#include "common.h"
+
+
+
+/*
+ * ALSA cards list and descriptions
+ */
+
+struct snd_stm_card __initdata snd_stm_stx7200_cards[] = {
+	{
+		.index = 0,
+		.id = "PCM",
+		.short_name = "PCM outputs",
+		.long_name = "Digital audio outputs (PCM players 2 and 3)",
+	},
+	{
+		.index = 1,
+		.id = "ANALOG",
+		.short_name = "Analog outputs",
+		.long_name = "Analog audio outputs (PCM players 0 and 1)",
+	},
+	{
+		.index = 2,
+		.id = "SPDIF",
+		.short_name = "SPDIF output",
+		.long_name = "SPDIF audio output",
+	},
+	{
+		.index = 3,
+		.id = "HDMI",
+		.short_name = "HDMI output",
+		.long_name = "HDMI audio output (dedicated PCM "
+				"and SPDIF players)",
+	},
+	{
+		.index = 4,
+		.id = "INPUT",
+		.short_name = "PCM input",
+		.long_name = "Digital audio input (PCM reader)",
+	}
+};
+
+
+
+/*
+ * SoC audio components description
+ */
+
+enum { audio_outputs, fsynth_0, fsynth_1, pcm_reader,
+	dac_internal_0, dac_internal_1, pcm_player_0,
+	pcm_player_1, pcm_player_2, pcm_player_3, spdif_player,
+	hdmi_pcm_player, hdmi_spdif_player, hdmi_i2s_spdif_converter_0,
+	hdmi_i2s_spdif_converter_1, hdmi_i2s_spdif_converter_2,
+	hdmi_i2s_spdif_converter_3 };
+
+struct snd_stm_component __initdata snd_stm_stx7200_components[] = {
+
+	/* Audio outputs control */
+
+	[audio_outputs] = {
+		.bus_id = "audio_outputs",
+		.short_name = "Audio outputs control",
+		.num_caps = 0,
+	},
+
+	/* Frequency synthesizers */
+
+	[fsynth_0] = {
+		.bus_id = "fsynth.0",
+		.short_name = "Frequency synthesizer #0",
+		.num_caps = 1,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.range.from = 0,
+				.value.range.to = 3,
+			},
+		},
+	},
+
+	[fsynth_1] = {
+		.bus_id = "fsynth.1",
+		.short_name = "Frequency synthesizer #1",
+		.num_caps = 1,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.range.from = 2,
+				.value.range.to = 3,
+			},
+		},
+	},
+
+	/* PCM reader */
+
+	[pcm_reader] = {
+		.bus_id = "pcm_reader",
+		.short_name = "PCM reader",
+		.num_caps = 3,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int []) { 2 },
+				.value.list.len     = 1,
+			},
+			{
+				.name = "card_id",
+				.value.string = "INPUT",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+		},
+	},
+
+	/* Internal audio DACs */
+
+	[dac_internal_0] = {
+		.bus_id = "dac_internal.0",
+		.short_name = "Internal DAC (master)",
+		.num_caps = 0,
+	},
+
+	[dac_internal_1] = {
+		.bus_id = "dac_internal.1",
+		.short_name = "Internal DAC (slave)",
+		.num_caps = 1,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "master_bus_id",
+				.value.string = "dac_internal.0",
+			},
+		},
+	},
+
+	/* PCM players */
+
+	[pcm_player_0] = {
+		.bus_id = "pcm_player.0",
+		.short_name = "PCM player #0",
+		.num_caps = 6,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int []) { 2 },
+				.value.list.len     = 1,
+			},
+			{
+				.name = "card_id",
+				.value.string = "ANALOG",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.0",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 0,
+			},
+			{
+				.name = "dac_bus_id",
+				.value.string = "dac_internal.0",
+			},
+		},
+	},
+
+	[pcm_player_1] = {
+		.bus_id = "pcm_player.1",
+		.short_name = "PCM player #1",
+		.num_caps = 6,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int[]) { 2, 4, 6 },
+				.value.list.len = 3,
+			},
+			{
+				.name = "card_id",
+				.value.string = "ANALOG",
+			},
+			{
+				.name = "card_device",
+				.value.number = 1,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.0",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 1,
+			},
+			{
+				.name = "dac_bus_id",
+				.value.string = "dac_internal.1",
+			},
+		},
+	},
+
+	[pcm_player_2] = {
+		.bus_id = "pcm_player.2",
+		.short_name = "PCM player #2",
+		.num_caps = 5,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int[]) { 2, 4, 6, 8 },
+				.value.list.len     = 4,
+			},
+			{
+				.name = "card_id",
+				.value.string = "PCM",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.0",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 2,
+			},
+		},
+	},
+
+	[pcm_player_3] = {
+		.bus_id = "pcm_player.3",
+		.short_name = "PCM player #3",
+		.num_caps = 5,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int[]){ 2, 4, 6, 8, 10 },
+				.value.list.len = 5,
+			},
+			{
+				.name = "card_id",
+				.value.string = "PCM",
+			},
+			{
+				.name = "card_device",
+				.value.number = 1,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.0",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 3,
+			},
+		},
+	},
+
+	/* SPDIF player */
+
+	[spdif_player] = {
+		.bus_id = "spdif_player.0",
+		.short_name = "SPDIF player",
+		.num_caps = 4,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "card_id",
+				.value.string = "SPDIF",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.1",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 3,
+			},
+		},
+	},
+
+	/* HDMI players */
+
+	[hdmi_pcm_player] = {
+		.bus_id = "pcm_player.4",
+		.short_name = "PCM player HDMI",
+		.num_caps = 5,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "channels",
+				.value.list.numbers = (int[]) { 2, 4, 6, 8 },
+				.value.list.len     = 4,
+			},
+			{
+				.name = "card_id",
+				.value.string = "HDMI",
+			},
+			{
+				.name = "card_device",
+				.value.number = 0,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.1",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 2,
+			},
+		},
+	},
+
+	[hdmi_spdif_player] = {
+		.bus_id = "spdif_player.1",
+		.short_name = "SPDIF player HDMI",
+		.num_caps = 4,
+		.caps = (struct snd_stm_cap[]) {
+			{
+				.name = "card_id",
+				.value.string = "HDMI",
+			},
+			{
+				.name = "card_device",
+				.value.number = 1,
+			},
+			{
+				.name = "fsynth_bus_id",
+				.value.string = "fsynth.1",
+			},
+			{
+				.name = "fsynth_channel",
+				.value.number = 2,
+			},
+		},
+	},
+
+	/* I2S to SPDIF converters (HDMI output) */
+
+#if 0 /* Disabled till cut 2.0 */
+	[hdmi_i2s_spdif_converter_0] = {
+		.bus_id = "i2s-spdif_conv.0",
+		.short_name = "I2S to SPDIF converter",
+		.num_caps = 0,
+	},
+
+	[hdmi_i2s_spdif_converter_1] = {
+		.bus_id = "i2s-spdif_conv.1",
+		.short_name = "I2S to SPDIF converter",
+		.num_caps = 0,
+	},
+
+	[hdmi_i2s_spdif_converter_2] = {
+		.bus_id = "i2s-spdif_conv.2",
+		.short_name = "I2S to SPDIF converter",
+		.num_caps = 0,
+	},
+
+	[hdmi_i2s_spdif_converter_3] = {
+		.bus_id = "i2s-spdif_conv.3",
+		.short_name = "I2S to SPDIF converter",
+		.num_caps = 0,
+	},
+#endif
+};
+
+
+
+/*
+ * Initialization and runtime configuration
+ */
+
+int __init snd_stm_stx7200_init(void)
+{
+	int result = 0;
+
+	result = snd_stm_cards_init("STx7200",
+			snd_stm_stx7200_cards,
+			ARRAY_SIZE(snd_stm_stx7200_cards));
+
+	if (result == 0) {
+		result = snd_stm_components_init(snd_stm_stx7200_components,
+				ARRAY_SIZE(snd_stm_stx7200_components));
+
+		if (result < 0)
+			snd_stm_cards_free();
+	}
+
+	return result;
+}
Index: linux-2.6.23-stm/sound/soc/stm/synchro.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/sound/soc/stm/synchro.c
@@ -0,0 +1,41 @@
+/*
+ *   Audio playback synchronization routines for STMicroelectronics' SoCs
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 9 /* See common.h debug features */
+#include "common.h"
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_synchro_init(void)
+{
+	return 0;
+}
+
+void snd_stm_synchro_cleanup(void)
+{
+}
