===================================================
This patch adds the new KGDB 2.4 in the EAR Kernel.
===================================================

It is based on the latest development KGDB version.
It also contains:
core-lite.patch  Rev: 1.125
core.patch       Rev: 1.40
eth.patch        Rev: 1.58
module.patch     Rev: 1.22
netpoll_pass_skb_to_rx_hook.patch Rev: 1.3
sh-lite.patch    Rev: 1.28
sysrq_bugfix.patch Rev: 1.6

Finally It fixes all the BUGs found in the previous KGDB version (added in the Kernel Distro-2.0):
 - ^C issue
 - Early entry point for the STM platforms
 - "info threads" GDB command
 - kernel debugger support in the stasc driver

arch/sh/Kconfig.debug
arch/sh/kernel/cpu/sh3/ex.S
arch/sh/kernel/cpu/sh4/ex.S
arch/sh/kernel/entry.S
arch/sh/kernel/kgdb.c
arch/sh/kernel/kgdb_jmp.S
arch/sh/kernel/kgdb-jmp.S
arch/sh/kernel/kgdb_stub.c
arch/sh/kernel/Makefile
arch/sh/kernel/setup.c 
arch/sh/kernel/time.c 
arch/sh/kernel/traps.c
arch/sh/Makefile
arch/sh/mm/extable.c
arch/sh/mm/fault.c
arch/sh/mm/fault-nommu.c
Documentation/DocBook/kgdb.tmpl
Documentation/DocBook/Makefile
drivers/char/keyboard.c
drivers/net/kgdboe.c
drivers/net/Makefile
drivers/net/smc91x.c
drivers/serial/stasc.c
include/asm-sh/kgdb.h
include/dwarf2-defs.h
include/kgdb.h
include/module.h
include/netpoll.h
kernel/kgdb.c
kernel/Makefile
kernel/module.c
kernel/pid.c
kernel/sched.c
kernel/softlockup.c
kernel/timer.c
lib/Kconfig.debug
MAINTAINERS
net/core/netpoll.c

Signed-off by Giuseppe Cavallaro <peppe.cavallaro@st.com>

diff -uprN -X  linux-orig/arch/sh/Kconfig.debug linux-kgdb/arch/sh/Kconfig.debug
--- linux-orig/arch/sh/Kconfig.debug	2006-08-31 13:42:13.000000000 +0000
+++ linux-kgdb/arch/sh/Kconfig.debug	2006-09-01 08:52:51.000000000 +0000
@@ -30,100 +30,6 @@ config EARLY_PRINTK
 	  when the kernel may crash or hang before the serial console is
 	  initialised. If unsure, say N.
 
-config KGDB
-	bool "Include KGDB kernel debugger"
-	select FRAME_POINTER
-	help
-	  Include in-kernel hooks for kgdb, the Linux kernel source level
-	  debugger.  See <http://kgdb.sourceforge.net/> for more information.
-	  Unless you are intending to debug the kernel, say N here.
-
-menu "KGDB configuration options"
-	depends on KGDB
-
-config MORE_COMPILE_OPTIONS
-	bool "Add any additional compile options"
-	help
-	  If you want to add additional CFLAGS to the kernel build, enable this
-	  option and then enter what you would like to add in the next question.
-	  Note however that -g is already appended with the selection of KGDB.
-
-config COMPILE_OPTIONS
-	string "Additional compile arguments"
-	depends on MORE_COMPILE_OPTIONS
-
-config KGDB_NMI
-	bool "Enter KGDB on NMI"
-	default n
-
-config KGDB_THREAD
-	bool "Include KGDB thread support"
-	default y
-
-config SH_KGDB_CONSOLE
-	bool "Console messages through GDB"
-	default n
-
-config KGDB_SYSRQ
-	bool "Allow SysRq 'G' to enter KGDB"
-	default y
-
-config KGDB_KERNEL_ASSERTS
-	bool "Include KGDB kernel assertions"
-	default n
-
-comment "Serial port setup"
-
-config KGDB_DEFPORT
-	int "Port number (ttySCn)"
-	default "1"
-
-config KGDB_DEFBAUD
-	int "Baud rate"
-	default "115200"
-
-choice
-	prompt "Parity"
-	depends on KGDB
-	default KGDB_DEFPARITY_N
-
-config KGDB_DEFPARITY_N
-	bool "None"
-
-config KGDB_DEFPARITY_E
-	bool "Even"
-
-config KGDB_DEFPARITY_O
-	bool "Odd"
-
-endchoice
-
-choice
-	prompt "Data bits"
-	depends on KGDB
-	default KGDB_DEFBITS_8
-
-config KGDB_DEFBITS_8
-	bool "8"
-
-config KGDB_DEFBITS_7
-	bool "7"
-
-endchoice
-
-config DEBUG_STACK_USAGE
-	bool "Enable stack utilization instrumentation"
-	help
-	  Enables the display of the minimum amount of free stack which each
-	  task has ever had available in the sysrq-T and sysrq-P debug output.
-
-	  This option will slow down process creation somewhat.
-
-config DEBUG_STACKOVERFLOW
-	bool "Stack Overflow Detection Support"
-
-endmenu
-
 config 4KSTACKS
 	depends on CPU_SH4 && EXPERIMENTAL
         bool "Use 4Kb for kernel stacks instead of 8Kb (EXPERIMENTAL)"
diff -uprN -X  linux-orig/arch/sh/kernel/cpu/sh3/ex.S linux-kgdb/arch/sh/kernel/cpu/sh3/ex.S
--- linux-orig/arch/sh/kernel/cpu/sh3/ex.S	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/cpu/sh3/ex.S	2006-09-01 08:34:39.000000000 +0000
@@ -43,7 +43,7 @@ ENTRY(exception_handling_table)
 	.long	exception_error	! reserved_instruction (filled by trap_init) /* 180 */
 	.long	exception_error	! illegal_slot_instruction (filled by trap_init) /*1A0*/
 ENTRY(nmi_slot)
-#if defined (CONFIG_KGDB_NMI)
+#if defined (CONFIG_KGDB)
 	.long	debug_enter	/* 1C0 */	! Allow trap to debugger
 #else
 	.long	exception_none	/* 1C0 */	! Not implemented yet
diff -uprN -X  linux-orig/arch/sh/kernel/cpu/sh4/ex.S linux-kgdb/arch/sh/kernel/cpu/sh4/ex.S
--- linux-orig/arch/sh/kernel/cpu/sh4/ex.S	2006-08-31 13:42:05.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/cpu/sh4/ex.S	2006-09-01 08:34:39.000000000 +0000
@@ -47,7 +47,7 @@ ENTRY(exception_handling_table)
 	.long	exception_error	! reserved_instruction (filled by trap_init) /* 180 */
 	.long	exception_error	! illegal_slot_instruction (filled by trap_init) /*1A0*/
 ENTRY(nmi_slot)
-#if defined (CONFIG_KGDB_NMI)
+#if defined (CONFIG_KGDB)
 	.long	debug_enter	/* 1C0 */	! Allow trap to debugger
 #else
 	.long	exception_none	/* 1C0 */	! Not implemented yet
diff -uprN -X  linux-orig/arch/sh/kernel/entry.S linux-kgdb/arch/sh/kernel/entry.S
--- linux-orig/arch/sh/kernel/entry.S	2006-08-31 13:42:05.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/entry.S	2006-09-01 09:00:42.000000000 +0000
@@ -58,7 +58,7 @@
 ENOSYS = 38
 EINVAL = 22
 
-#if defined(CONFIG_KGDB_NMI)
+#if defined(CONFIG_KGDB)
 NMI_VEC = 0x1c0			! Must catch early for debounce
 #endif
 
@@ -211,31 +211,33 @@ call_dae:
 2:	.long   do_address_error
 #endif /* CONFIG_MMU */
 
-#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_KGDB)
 ! Handle kernel debug if either kgdb (SW) or gdb-stub (FW) is present.
 ! If both are configured, handle the debug traps (breakpoints) in SW,
 ! but still allow BIOS traps to FW.
 
 	.align	2
 debug_kernel:
-#if defined(CONFIG_SH_STANDARD_BIOS) && defined(CONFIG_SH_KGDB)
+#if defined(CONFIG_SH_STANDARD_BIOS) && defined(CONFIG_KGDB)
 	/* Force BIOS call to FW (debug_trap put TRA in r8) */
 	mov	r8,r0
 	shlr2	r0
 	cmp/eq	#0x3f,r0
 	bt	debug_kernel_fw
-#endif /* CONFIG_SH_STANDARD_BIOS && CONFIG_SH_KGDB */
+#endif /* CONFIG_SH_STANDARD_BIOS && CONFIG_KGDB */
 
-debug_enter:		
-#if defined(CONFIG_SH_KGDB)
+	.align 2
+	.globl debug_enter
+debug_enter:
+#if defined(CONFIG_KGDB)
 	/* Jump to kgdb, pass stacked regs as arg */
 debug_kernel_sw:
 	mov.l	3f, r0
 	jmp	@r0
 	 mov	r15, r4
 	.align	2
-3:	.long	kgdb_handle_exception
-#endif /* CONFIG_SH_KGDB */
+3:	.long	kgdb_exception_handler
+#endif /* CONFIG_KGDB */
 
 #if defined(CONFIG_SH_STANDARD_BIOS)
 	/* Unwind the stack and jmp to the debug entry */
@@ -277,12 +279,12 @@ debug_kernel_fw:
 2:	.long	gdb_vbr_vector
 #endif /* CONFIG_SH_STANDARD_BIOS */
 
-#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_KGDB */
 
 
 	.align	2
-debug_trap:	
-#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+debug_trap:
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_KGDB)
 	mov	#OFF_SR, r0
 	mov.l	@(r0,r15), r0		! get status register
 	shll	r0
@@ -609,9 +611,9 @@ skip_restore:
 6:	or	k0, k2			! Set the IMASK-bits
 	ldc	k2, ssr
 	!
-#if defined(CONFIG_KGDB_NMI)
+#if defined(CONFIG_KGDB)
 	! Clear in_nmi
-	mov.l	6f, k0
+	mov.l	8f, k0
 	mov	#0, k1
 	mov.b	k1, @k0
 #endif
@@ -628,6 +630,9 @@ ret_from_exception_end:
 4:	.long	do_syscall_trace
 5:	.long	0x00001000	! DSP
 7:	.long	0x30000000
+#if defined(CONFIG_KGDB)
+8:      .long   in_nmi
+#endif
 9:
 __INV_IMASK:
 	.long	0xffffff0f	! ~(IMASK)
@@ -732,7 +737,7 @@ tlb_miss:
 interrupt:
 	mov.l	2f, k2
 	mov.l	3f, k3
-#if defined(CONFIG_KGDB_NMI)
+#if defined(CONFIG_KGDB)
 	! Debounce (filter nested NMI)
 	mov.l	@k2, k0
 	mov.l	5f, k1
@@ -747,7 +752,7 @@ interrupt:
 5:	.long	NMI_VEC
 6:	.long	in_nmi
 0:
-#endif /* defined(CONFIG_KGDB_NMI) */
+#endif /* defined(CONFIG_KGDB) */
 	bra	handle_exception
 	 mov.l	@k2, k2
 
diff -uprN -X  linux-orig/arch/sh/kernel/kgdb.c linux-kgdb/arch/sh/kernel/kgdb.c
--- linux-orig/arch/sh/kernel/kgdb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/kgdb.c	2006-09-22 13:24:51.418252000 +0000
@@ -0,0 +1,475 @@
+/*
+ * arch/sh/kernel/kgdb.c
+ *
+ * Contains SH-specific low-level support for KGDB.
+ * 
+ * Containes extracts from code by Glenn Engel, Jim Kingdon,
+ * David Grothe <dave@gcom.com>, Tigran Aivazian <tigran@sco.com>,
+ * Amit S. Kale <akale@veritas.com>,  William Gatliff <bgat@open-widgets.com>,
+ * Ben Lee, Steve Chamberlain and Benoit Miller <fulg@iname.com>, 
+ * Henry Bell <henry.bell@st.com> and Jeremy Siegel <jsiegel@mvista.com>
+ *
+ * Maintainer: Tom Rini <trini@kernel.crashing.org>
+ *
+ * 2004 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <linux/kgdb.h>
+
+#include <asm/system.h>
+#include <asm/current.h>
+#include <asm/signal.h>
+#include <asm/pgtable.h>
+#include <asm/ptrace.h>
+
+extern void per_cpu_trap_init(void);
+extern atomic_t cpu_doing_single_step;
+
+/* Function pointers for linkage */
+static struct kgdb_regs trap_registers;
+
+/* Globals. */
+char in_nmi;			/* Set during NMI to prevent reentry */
+
+/* In order to get the right status of the machine before entering
+   in the debugger session the registers structure is maintained in a
+   kgdb internal pointer.
+   For example, using the serial connection through the STASC port,
+   before calling the synchronous breakpoint, the current register
+   status is saved in the kgdb_regs_valid pointer. */
+struct pt_regs *kgdb_regs_valid;
+static struct kgdb_regs kgdb_trap_regs;
+
+/* KGDB early access monitor */
+unsigned int kgdb_hwclk_flag = 0;
+
+#ifdef CONFIG_KGDB_ST_DCU
+unsigned int kgdb_via_dcu;
+#endif
+
+/* TRA differs sh3/4 */
+#if defined(CONFIG_CPU_SH3)
+#define TRA 0xffffffd0
+#elif defined(CONFIG_CPU_SH4)
+#define TRA 0xff000020
+#endif
+
+/* Macros for single step instruction identification */
+#define OPCODE_BT(op)         (((op) & 0xff00) == 0x8900)
+#define OPCODE_BF(op)         (((op) & 0xff00) == 0x8b00)
+#define OPCODE_BTF_DISP(op)   (((op) & 0x80) ? (((op) | 0xffffff80) << 1) : \
+			      (((op) & 0x7f ) << 1))
+#define OPCODE_BFS(op)        (((op) & 0xff00) == 0x8f00)
+#define OPCODE_BTS(op)        (((op) & 0xff00) == 0x8d00)
+#define OPCODE_BRA(op)        (((op) & 0xf000) == 0xa000)
+#define OPCODE_BRA_DISP(op)   (((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
+			      (((op) & 0x7ff) << 1))
+#define OPCODE_BRAF(op)       (((op) & 0xf0ff) == 0x0023)
+#define OPCODE_BRAF_REG(op)   (((op) & 0x0f00) >> 8)
+#define OPCODE_BSR(op)        (((op) & 0xf000) == 0xb000)
+#define OPCODE_BSR_DISP(op)   (((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
+			      (((op) & 0x7ff) << 1))
+#define OPCODE_BSRF(op)       (((op) & 0xf0ff) == 0x0003)
+#define OPCODE_BSRF_REG(op)   (((op) >> 8) & 0xf)
+#define OPCODE_JMP(op)        (((op) & 0xf0ff) == 0x402b)
+#define OPCODE_JMP_REG(op)    (((op) >> 8) & 0xf)
+#define OPCODE_JSR(op)        (((op) & 0xf0ff) == 0x400b)
+#define OPCODE_JSR_REG(op)    (((op) >> 8) & 0xf)
+#define OPCODE_RTS(op)        ((op) == 0xb)
+#define OPCODE_RTE(op)        ((op) == 0x2b)
+
+#define SR_T_BIT_MASK           0x1
+#define STEP_OPCODE             0xc320
+#define BIOS_CALL_TRAP          0x3f
+
+/* Exception codes as per SH-4 core manual */
+#define ADDRESS_ERROR_LOAD_VEC   7
+#define ADDRESS_ERROR_STORE_VEC  8
+#define TRAP_VEC                 11
+#define INVALID_INSN_VEC         12
+#define INVALID_SLOT_VEC         13
+#define NMI_VEC                  14
+#define SERIAL_BREAK_VEC         58
+
+void clk_init(void);
+
+/* Misc static */
+static int stepped_address;
+static short stepped_opcode;
+
+/* Translate SH-3/4 exception numbers to unix-like signal values */
+static int compute_signal(const int excep_code)
+{
+	switch (excep_code) {
+	case INVALID_INSN_VEC:
+	case INVALID_SLOT_VEC:
+		return SIGILL;
+	case ADDRESS_ERROR_LOAD_VEC:
+	case ADDRESS_ERROR_STORE_VEC:
+		return SIGSEGV;
+	case SERIAL_BREAK_VEC:
+	case NMI_VEC:
+		return SIGINT;
+	default:
+		/* Act like it was a break/trap. */
+		return SIGTRAP;
+	}
+}
+
+/*
+ * Translate the registers of the system into the format that GDB wants.  Since
+ * we use a local structure to store things, instead of getting them out
+ * of pt_regs, we can just do a memcpy.
+ */
+void regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *ign)
+{
+	memcpy(gdb_regs, &trap_registers, sizeof(trap_registers));
+}
+
+asmlinkage void ret_from_fork(void);
+void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
+{
+	int count;
+	int vbr_val;
+	struct pt_regs *kregs; 
+	unsigned long *tregs;
+
+	if ( p == NULL )
+		return;
+
+#if 0
+	printk ("\n>>> KGDB: THREAD info:\np->thread.pc 0x%lx\n", p->thread.pc);
+	printk ("p->thread.sp 0x%lx\n", p->thread.sp);
+	show_stack(p, NULL);
+#endif
+
+	__asm__ __volatile__ ("stc vbr, %0":"=r"(vbr_val));
+
+	/* A new fork has pt_regs on the stack from a fork() call (?????) */
+        if (p->thread.pc == (unsigned long)ret_from_fork) {
+                kregs = (struct pt_regs*)p->thread.sp;
+		for (count = 0; count < 16; count++)
+			*(gdb_regs++) = kregs->regs[count];
+
+                *(gdb_regs++) = kregs->pc;
+                *(gdb_regs++) = kregs->pr;
+                *(gdb_regs++) = kregs->gbr;
+                *(gdb_regs++) = vbr_val;
+                *(gdb_regs++) = kregs->mach;
+                *(gdb_regs++) = kregs->macl;
+                *(gdb_regs++) = kregs->sr;
+                return;
+        }
+
+	/*
+	 * Otherwise we have to collect the thread registers from the stack
+	 * built by switch function (see include/asm-sh/system.h)
+	 *
+	 * NOTE:
+	 * the stack frame for the thread is:
+	 * 	r14, ... r8, PR, GBR
+	 * while the "frame" sent to GDB is: 
+	 *      r0, ... r15, PR, GBR, VBR, MACH, MACHL, SR
+	 */
+	tregs = (unsigned long *) p->thread.sp;
+
+	/* r0-r7 ("scratch" registers) */
+	for (count = 0; count < 8; count++)
+		*(gdb_regs++) = 0xdeadbeef;
+
+	/* r8-r14 (switch stack registers) */
+	tregs+=6;
+	for (count = 0; count < 7; count++)
+		*(gdb_regs++) = *(tregs--);
+	tregs+=8;
+
+	*(gdb_regs++) = p->thread.sp; 	/* r15 */
+	*(gdb_regs++) = p->thread.pc;
+	*(gdb_regs++) = *tregs++; 	/* PR */
+	*(gdb_regs++) = *tregs++; 	/* GBR */
+	*(gdb_regs++) = vbr_val;
+	*(gdb_regs++) = 0xdeadbeef;  	/* MACH: scratch   */
+	*(gdb_regs++) = 0xdeadbeef;  	/* MACHL: scratch  */
+	*(gdb_regs++) = SR_FD; 	     	/* Status Register */
+	return;
+}
+
+/*
+ * Translate the registers values that GDB has given us back into the
+ * format of the system.  See the comment above about memcpy.
+ */
+void gdb_regs_to_regs(unsigned long *gdb_regs, struct pt_regs *ign)
+{
+	memcpy(&trap_registers, gdb_regs, sizeof(trap_registers));
+}
+
+/* Calculate the new address for after a step */
+static short *get_step_address(void)
+{
+	short op = *(short *) trap_registers.pc;
+	long addr;
+
+	/* BT */
+	if (OPCODE_BT(op)) {
+		if (trap_registers.sr & SR_T_BIT_MASK)
+			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
+		else
+			addr = trap_registers.pc + 2;
+	}
+
+	/* BTS */
+	else if (OPCODE_BTS(op)) {
+		if (trap_registers.sr & SR_T_BIT_MASK)
+			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
+		else
+			addr = trap_registers.pc + 4;	/* Not in delay slot */
+	}
+
+	/* BF */
+	else if (OPCODE_BF(op)) {
+		if (!(trap_registers.sr & SR_T_BIT_MASK))
+			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
+		else
+			addr = trap_registers.pc + 2;
+	}
+
+	/* BFS */
+	else if (OPCODE_BFS(op)) {
+		if (!(trap_registers.sr & SR_T_BIT_MASK))
+			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
+		else
+			addr = trap_registers.pc + 4;	/* Not in delay slot */
+	}
+
+	/* BRA */
+	else if (OPCODE_BRA(op))
+		addr = trap_registers.pc + 4 + OPCODE_BRA_DISP(op);
+
+	/* BRAF */
+	else if (OPCODE_BRAF(op))
+		addr = trap_registers.pc + 4
+		    + trap_registers.regs[OPCODE_BRAF_REG(op)];
+
+	/* BSR */
+	else if (OPCODE_BSR(op))
+		addr = trap_registers.pc + 4 + OPCODE_BSR_DISP(op);
+
+	/* BSRF */
+	else if (OPCODE_BSRF(op))
+		addr = trap_registers.pc + 4
+		    + trap_registers.regs[OPCODE_BSRF_REG(op)];
+
+	/* JMP */
+	else if (OPCODE_JMP(op))
+		addr = trap_registers.regs[OPCODE_JMP_REG(op)];
+
+	/* JSR */
+	else if (OPCODE_JSR(op))
+		addr = trap_registers.regs[OPCODE_JSR_REG(op)];
+
+	/* RTS */
+	else if (OPCODE_RTS(op))
+		addr = trap_registers.pr;
+
+	/* RTE */
+	else if (OPCODE_RTE(op))
+		addr = trap_registers.regs[15];
+
+	/* Other */
+	else
+		addr = trap_registers.pc + 2;
+
+	kgdb_flush_icache_range(addr, addr + 2);
+	return (short *) addr;
+}
+
+/* The command loop, read and act on requests */
+int kgdb_arch_handle_exception(int exVector, int signo, int err_code,
+		char *remcom_in_buffer, char *remcom_out_buffer,
+		struct pt_regs *ign)
+{
+	unsigned long addr;
+	char *ptr = &remcom_in_buffer[1];
+
+	/* Examine first char of buffer to see what we need to do */
+	switch (remcom_in_buffer[0]) {
+	case 'c':	/* Continue at address AA..AA (optional) */
+	case 's':	/* Step one instruction from AA..AA */
+		/* Try to read optional parameter, PC unchanged if none */
+		if (kgdb_hex2long(&ptr, &addr))
+			trap_registers.pc = addr;
+
+		atomic_set(&cpu_doing_single_step, -1);
+		if (remcom_in_buffer[0] == 's') {
+			/* Replace the instruction immediately after the
+			 * current instruction (i.e. next in the expected
+			 * flow of control) with a trap instruction, so that
+			 * returning will cause only a single instruction to
+			 * be executed. Note that this model is slightly
+			 * broken for instructions with delay slots
+			 * (e.g. B[TF]S, BSR, BRA etc), where both the branch
+			 * and the instruction in the delay slot will be
+			 * executed.
+			 */
+			/* Determine where the target instruction will send
+			 * us to */
+			unsigned short *next_addr = get_step_address();
+			stepped_address = (int)next_addr;
+
+			/* Replace it */
+			stepped_opcode = *(short *)next_addr;
+			*next_addr = STEP_OPCODE;
+
+			/* Flush and return */
+			kgdb_flush_icache_range((long)next_addr,
+					(long)next_addr + 2);
+			if (kgdb_contthread)
+				atomic_set(&cpu_doing_single_step,
+						smp_processor_id());
+		}
+		return 0;
+	}
+	return -1;
+}
+
+/*
+ * When an exception has occured, we are called.  We need to set things
+ * up so that we can call kgdb_handle_exception to handle requests from
+ * the remote GDB.
+ */
+void kgdb_exception_handler(struct pt_regs *regs)
+{
+	int excep_code, vbr_val;
+	int trapa_value = *(volatile unsigned long *)(TRA);
+	int count;
+
+
+	if(kgdb_regs_valid != NULL){
+		/* Copy kernel regs (from stack) */
+		for (count = 0; count < 16; count++)
+			trap_registers.regs[count] = kgdb_regs_valid->regs[count];
+		trap_registers.pc = kgdb_regs_valid->pc;
+		trap_registers.pr = kgdb_regs_valid->pr;
+		trap_registers.sr = kgdb_regs_valid->sr;
+		trap_registers.gbr = kgdb_regs_valid->gbr;
+		trap_registers.mach = kgdb_regs_valid->mach;
+		trap_registers.macl = kgdb_regs_valid->macl;
+		trap_registers.vbr = 0xdeadbeef;
+
+		/* In any case, we need to save the regs structure, in order
+		   to guarantee a coherent status when the debugger session is
+		   closed. */
+		for (count = 0; count < 16; count++)
+			kgdb_trap_regs.regs[count] = regs->regs[count];
+		kgdb_trap_regs.pc = regs->pc;
+		kgdb_trap_regs.pr = regs->pr;
+		kgdb_trap_regs.sr = regs->sr;
+		kgdb_trap_regs.gbr = regs->gbr;
+		kgdb_trap_regs.mach = regs->mach;
+		kgdb_trap_regs.macl = regs->macl;
+
+		__asm__ __volatile__("stc vbr, %0":"=r"(vbr_val));
+		kgdb_trap_regs.vbr = vbr_val;
+	}else {
+		/* Copy kernel regs (from stack) */
+		for (count = 0; count < 16; count++)
+			trap_registers.regs[count] = regs->regs[count];
+		trap_registers.pc = regs->pc;
+		trap_registers.pr = regs->pr;
+		trap_registers.sr = regs->sr;
+		trap_registers.gbr = regs->gbr;
+		trap_registers.mach = regs->mach;
+		trap_registers.macl = regs->macl;
+
+		__asm__ __volatile__("stc vbr, %0":"=r"(vbr_val));
+		trap_registers.vbr = vbr_val;
+	}
+	/* Get the execption code. */
+	__asm__ __volatile__("stc r2_bank, %0":"=r"(excep_code));
+	excep_code >>= 5;
+
+	/* If we got an NMI, and KGDB is not yet initialized, call
+	 * breakpoint() to try and initialize everything for us. */
+	if (excep_code == NMI_VEC && !kgdb_initialized) {
+		breakpoint();
+		return;
+	}
+
+	/* TRAP_VEC exception indicates a software trap inserted in place of
+	 * code by GDB so back up PC by one instruction, as this instruction
+	 * will later be replaced by its original one.  Do NOT do this for
+	 * trap 0xff, since that indicates a compiled-in breakpoint which
+	 * will not be replaced (and we would retake the trap forever) */
+	if ((excep_code == TRAP_VEC) && (trapa_value != (0xff << 2))) {
+		trap_registers.pc -= 2;
+	}
+	/* If we have been single-stepping, put back the old instruction.
+	 * We use stepped_address in case we have stopped more than one
+	 * instruction away. */
+	if (stepped_opcode != 0) {
+		*(short*)stepped_address = stepped_opcode;
+		kgdb_flush_icache_range(stepped_address, stepped_address + 2);
+	}
+	stepped_opcode = 0;
+
+	/* Call the stub to do the processing.  Note that not everything we
+	 * need to send back and forth lives in pt_regs. */
+	if(kgdb_regs_valid != NULL) {
+		kgdb_handle_exception(excep_code, compute_signal(excep_code), 0, kgdb_regs_valid);
+	} else
+		kgdb_handle_exception(excep_code, compute_signal(excep_code), 0, regs);
+
+	if(kgdb_regs_valid != NULL){
+		kgdb_regs_valid = NULL;
+		trap_registers = kgdb_trap_regs;
+	}
+
+	/* Copy back the (maybe modified) registers */
+	for (count = 0; count < 16; count++)
+		regs->regs[count] = trap_registers.regs[count];
+	regs->pc = trap_registers.pc;
+	regs->pr = trap_registers.pr;
+	regs->sr = trap_registers.sr;
+	regs->gbr = trap_registers.gbr;
+	regs->mach = trap_registers.mach;
+	regs->macl = trap_registers.macl;
+
+	vbr_val = trap_registers.vbr;
+	__asm__ __volatile__("ldc %0, vbr": :"r"(vbr_val));
+}
+
+int __init kgdb_arch_init(void)
+{
+	kgdb_regs_valid = NULL;
+
+	if (!kgdb_hwclk_flag) {
+		clk_init();
+		kgdb_hwclk_flag = 1; 
+	}
+	per_cpu_trap_init();
+
+	return 0;
+}
+
+struct kgdb_arch arch_kgdb_ops = {
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#ifdef CONFIG_CPU_SUBTYPE_ST40
+	.gdb_bpt_instr = { 0x32, 0xc3 },
+#else
+	.gdb_bpt_instr = { 0xff, 0xc3 },
+#endif
+#else
+	.gdb_bpt_instr = { 0xc3, 0xff },
+#endif
+};
diff -uprN -X  linux-orig/arch/sh/kernel/kgdb_jmp.S linux-kgdb/arch/sh/kernel/kgdb_jmp.S
--- linux-orig/arch/sh/kernel/kgdb_jmp.S	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/kgdb_jmp.S	1970-01-01 00:00:00.000000000 +0000
@@ -1,33 +0,0 @@
-#include <linux/linkage.h>
-
-ENTRY(setjmp)
-	add	#(9*4), r4
-	sts.l	pr, @-r4
-	mov.l	r15, @-r4
-	mov.l	r14, @-r4
-	mov.l	r13, @-r4
-	mov.l	r12, @-r4
-	mov.l	r11, @-r4
-	mov.l	r10, @-r4
-	mov.l	r9, @-r4
-	mov.l	r8, @-r4
-	rts
-	 mov	#0, r0
-
-ENTRY(longjmp)
-	mov.l	@r4+, r8
-	mov.l	@r4+, r9
-	mov.l	@r4+, r10
-	mov.l	@r4+, r11
-	mov.l	@r4+, r12
-	mov.l	@r4+, r13
-	mov.l	@r4+, r14
-	mov.l	@r4+, r15
-	lds.l	@r4+, pr
-	mov	r5, r0
-	tst	r0, r0
-	bf	1f
-	mov	#1, r0	! in case val==0
-1:	rts
-	 nop
-
diff -uprN -X  linux-orig/arch/sh/kernel/kgdb-jmp.S linux-kgdb/arch/sh/kernel/kgdb-jmp.S
--- linux-orig/arch/sh/kernel/kgdb-jmp.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/kgdb-jmp.S	2006-09-01 08:34:38.000000000 +0000
@@ -0,0 +1,32 @@
+#include <linux/linkage.h>
+
+ENTRY(kgdb_fault_setjmp)
+	add	#(9*4), r4
+	sts.l	pr, @-r4
+	mov.l	r15, @-r4
+	mov.l	r14, @-r4
+	mov.l	r13, @-r4
+	mov.l	r12, @-r4
+	mov.l	r11, @-r4
+	mov.l	r10, @-r4
+	mov.l	r9, @-r4
+	mov.l	r8, @-r4
+	rts
+	 mov	#0, r0
+
+ENTRY(kgdb_fault_longjmp)
+	mov.l	@r4+, r8
+	mov.l	@r4+, r9
+	mov.l	@r4+, r10
+	mov.l	@r4+, r11
+	mov.l	@r4+, r12
+	mov.l	@r4+, r13
+	mov.l	@r4+, r14
+	mov.l	@r4+, r15
+	lds.l	@r4+, pr
+	mov	r5, r0
+	tst	r0, r0
+	bf	1f
+	mov	#1, r0
+1:	rts
+	 nop
diff -uprN -X  linux-orig/arch/sh/kernel/kgdb_stub.c linux-kgdb/arch/sh/kernel/kgdb_stub.c
--- linux-orig/arch/sh/kernel/kgdb_stub.c	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/kgdb_stub.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1468 +0,0 @@
-/*
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Containes extracts from code by Glenn Engel, Jim Kingdon,
- * David Grothe <dave@gcom.com>, Tigran Aivazian <tigran@sco.com>,
- * Amit S. Kale <akale@veritas.com>,  William Gatliff <bgat@open-widgets.com>,
- * Ben Lee, Steve Chamberlain and Benoit Miller <fulg@iname.com>.
- * 
- * This version by Henry Bell <henry.bell@st.com>
- * Minor modifications by Jeremy Siegel <jsiegel@mvista.com>
- * 
- * Contains low-level support for remote debug using GDB. 
- *
- * To enable debugger support, two things need to happen. A call to
- * set_debug_traps() is necessary in order to allow any breakpoints
- * or error conditions to be properly intercepted and reported to gdb.
- * A breakpoint also needs to be generated to begin communication.  This
- * is most easily accomplished by a call to breakpoint() which does
- * a trapa if the initialisation phase has been successfully completed.
- *
- * In this case, set_debug_traps() is not used to "take over" exceptions;
- * other kernel code is modified instead to enter the kgdb functions here
- * when appropriate (see entry.S for breakpoint traps and NMI interrupts,
- * see traps.c for kernel error exceptions).
- *
- * The following gdb commands are supported:
- *
- *    Command       Function                               Return value
- *
- *    g             return the value of the CPU registers  hex data or ENN
- *    G             set the value of the CPU registers     OK or ENN
- *
- *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
- *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
- *    XAA..AA,LLLL: Same, but data is binary (not hex)     OK or ENN
- *
- *    c             Resume at current address              SNN   ( signal NN)
- *    cAA..AA       Continue at address AA..AA             SNN
- *    CNN;          Resume at current address with signal  SNN
- *    CNN;AA..AA    Resume at address AA..AA with signal   SNN
- *
- *    s             Step one instruction                   SNN
- *    sAA..AA       Step one instruction from AA..AA       SNN
- *    SNN;          Step one instruction with signal       SNN
- *    SNNAA..AA     Step one instruction from AA..AA w/NN  SNN
- *
- *    k             kill (Detach GDB)
- *
- *    d             Toggle debug flag
- *    D             Detach GDB 
- *
- *    Hct           Set thread t for operations,           OK or ENN
- *                  c = 'c' (step, cont), c = 'g' (other
- *                  operations)
- *
- *    qC            Query current thread ID                QCpid
- *    qfThreadInfo  Get list of current threads (first)    m<id>
- *    qsThreadInfo   "    "  "     "      "   (subsequent)
- *    qOffsets      Get section offsets                  Text=x;Data=y;Bss=z
- * 
- *    TXX           Find if thread XX is alive             OK or ENN
- *    ?             What was the last sigval ?             SNN   (signal NN)
- *    O             Output to GDB console
- *
- * Remote communication protocol.
- *
- *    A debug packet whose contents are <data> is encapsulated for
- *    transmission in the form:
- *
- *       $ <data> # CSUM1 CSUM2
- *
- *       <data> must be ASCII alphanumeric and cannot include characters
- *       '$' or '#'.  If <data> starts with two characters followed by
- *       ':', then the existing stubs interpret this as a sequence number.
- *
- *       CSUM1 and CSUM2 are ascii hex representation of an 8-bit 
- *       checksum of <data>, the most significant nibble is sent first.
- *       the hex digits 0-9,a-f are used.
- *
- *    Receiver responds with:
- *
- *       +       - if CSUM is correct and ready for next packet
- *       -       - if CSUM is incorrect
- *
- * Responses can be run-length encoded to save space.  A '*' means that
- * the next character is an ASCII encoding giving a repeat count which
- * stands for that many repititions of the character preceding the '*'.
- * The encoding is n+29, yielding a printable character where n >=3 
- * (which is where RLE starts to win).  Don't use an n > 126. 
- *
- * So "0* " means the same as "0000".
- */
-
-#include <linux/string.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/smp.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/linkage.h>
-#include <linux/init.h>
-
-#ifdef CONFIG_SH_KGDB_CONSOLE
-#include <linux/console.h>
-#endif
-
-#include <asm/system.h>
-#include <asm/current.h>
-#include <asm/signal.h>
-#include <asm/pgtable.h>
-#include <asm/ptrace.h>
-#include <asm/kgdb.h>
-#include <asm/io.h>
-
-/* Function pointers for linkage */
-kgdb_debug_hook_t *kgdb_debug_hook;
-kgdb_bus_error_hook_t *kgdb_bus_err_hook;
-
-int (*kgdb_getchar)(void);
-void (*kgdb_putchar)(int);
-
-static void put_debug_char(int c)
-{
-	if (!kgdb_putchar)
-		return;
-	(*kgdb_putchar)(c);
-}
-static int get_debug_char(void)
-{
-	if (!kgdb_getchar)
-		return -1;
-	return (*kgdb_getchar)();
-}
-
-/* Num chars in in/out bound buffers, register packets need NUMREGBYTES * 2 */
-#define BUFMAX 1024
-#define NUMREGBYTES (MAXREG*4)
-#define OUTBUFMAX (NUMREGBYTES*2+512)
-
-enum regs {
-	R0 = 0, R1,  R2,  R3,   R4,   R5,  R6, R7,
-	R8, R9, R10, R11, R12,  R13,  R14, R15,
-	PC, PR, GBR, VBR, MACH, MACL, SR,
-	/*  */
-	MAXREG
-};
-
-static unsigned int registers[MAXREG];
-struct kgdb_regs trap_registers;
-
-char kgdb_in_gdb_mode;
-char in_nmi;			/* Set during NMI to prevent reentry */
-int kgdb_nofault;		/* Boolean to ignore bus errs (i.e. in GDB) */
-int kgdb_enabled = 1;		/* Default to enabled, cmdline can disable */
-int kgdb_halt;
-
-/* Exposed for user access */
-struct task_struct *kgdb_current;
-unsigned int kgdb_g_imask;
-int kgdb_trapa_val;
-int kgdb_excode;
-
-/* Default values for SCI (can override via kernel args in setup.c) */
-#ifndef CONFIG_KGDB_DEFPORT
-#define CONFIG_KGDB_DEFPORT 1
-#endif
-
-#ifndef CONFIG_KGDB_DEFBAUD
-#define CONFIG_KGDB_DEFBAUD 115200
-#endif
-
-#if defined(CONFIG_KGDB_DEFPARITY_E)
-#define CONFIG_KGDB_DEFPARITY 'E'
-#elif defined(CONFIG_KGDB_DEFPARITY_O)
-#define CONFIG_KGDB_DEFPARITY 'O'
-#else /* CONFIG_KGDB_DEFPARITY_N */
-#define CONFIG_KGDB_DEFPARITY 'N'
-#endif
-
-#ifdef CONFIG_KGDB_DEFBITS_7
-#define CONFIG_KGDB_DEFBITS '7'
-#else /* CONFIG_KGDB_DEFBITS_8 */
-#define CONFIG_KGDB_DEFBITS '8'
-#endif
-
-/* SCI/UART settings, used in kgdb_console_setup() */
-int  kgdb_portnum = CONFIG_KGDB_DEFPORT;
-int  kgdb_baud = CONFIG_KGDB_DEFBAUD;
-char kgdb_parity = CONFIG_KGDB_DEFPARITY;
-char kgdb_bits = CONFIG_KGDB_DEFBITS;
-
-/* Jump buffer for setjmp/longjmp */
-static jmp_buf rem_com_env;
-
-/* TRA differs sh3/4 */
-#if defined(CONFIG_CPU_SH3)
-#define TRA 0xffffffd0
-#elif defined(CONFIG_CPU_SH4)
-#define TRA 0xff000020
-#endif
-
-/* Macros for single step instruction identification */
-#define OPCODE_BT(op)         (((op) & 0xff00) == 0x8900)
-#define OPCODE_BF(op)         (((op) & 0xff00) == 0x8b00)
-#define OPCODE_BTF_DISP(op)   (((op) & 0x80) ? (((op) | 0xffffff80) << 1) : \
-			      (((op) & 0x7f ) << 1))
-#define OPCODE_BFS(op)        (((op) & 0xff00) == 0x8f00)
-#define OPCODE_BTS(op)        (((op) & 0xff00) == 0x8d00)
-#define OPCODE_BRA(op)        (((op) & 0xf000) == 0xa000)
-#define OPCODE_BRA_DISP(op)   (((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
-			      (((op) & 0x7ff) << 1))
-#define OPCODE_BRAF(op)       (((op) & 0xf0ff) == 0x0023)
-#define OPCODE_BRAF_REG(op)   (((op) & 0x0f00) >> 8)
-#define OPCODE_BSR(op)        (((op) & 0xf000) == 0xb000)
-#define OPCODE_BSR_DISP(op)   (((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
-			      (((op) & 0x7ff) << 1))
-#define OPCODE_BSRF(op)       (((op) & 0xf0ff) == 0x0003)
-#define OPCODE_BSRF_REG(op)   (((op) >> 8) & 0xf)
-#define OPCODE_JMP(op)        (((op) & 0xf0ff) == 0x402b)
-#define OPCODE_JMP_REG(op)    (((op) >> 8) & 0xf)
-#define OPCODE_JSR(op)        (((op) & 0xf0ff) == 0x400b)
-#define OPCODE_JSR_REG(op)    (((op) >> 8) & 0xf)
-#define OPCODE_RTS(op)        ((op) == 0xb)
-#define OPCODE_RTE(op)        ((op) == 0x2b)
-
-#define SR_T_BIT_MASK           0x1
-#define STEP_OPCODE             0xc320
-#define BIOS_CALL_TRAP          0x3f
-
-/* Exception codes as per SH-4 core manual */
-#define ADDRESS_ERROR_LOAD_VEC   7
-#define ADDRESS_ERROR_STORE_VEC  8
-#define TRAP_VEC                 11
-#define INVALID_INSN_VEC         12
-#define INVALID_SLOT_VEC         13
-#define NMI_VEC                  14
-#define USER_BREAK_VEC           15
-#define SERIAL_BREAK_VEC         58
-
-/* Misc static */
-static int stepped_address;
-static short stepped_opcode;
-static char in_buffer[BUFMAX];
-static char out_buffer[OUTBUFMAX];
-
-static void kgdb_to_gdb(const char *s);
-
-#ifdef CONFIG_KGDB_THREAD
-static struct task_struct *trapped_thread;
-static struct task_struct *current_thread;
-typedef unsigned char threadref[8];
-#define BUF_THREAD_ID_SIZE 16
-#endif
-
-
-/* Convert ch to hex */
-static int hex(const char ch)
-{
-	if ((ch >= 'a') && (ch <= 'f'))
-		return (ch - 'a' + 10);
-	if ((ch >= '0') && (ch <= '9'))
-		return (ch - '0');
-	if ((ch >= 'A') && (ch <= 'F'))
-		return (ch - 'A' + 10);
-	return (-1);
-}
-
-/* Convert the memory pointed to by mem into hex, placing result in buf.
-   Returns a pointer to the last char put in buf (null) */
-static char *mem_to_hex(const char *mem, char *buf, const int count)
-{
-	int i;
-	int ch;
-	unsigned short s_val;
-	unsigned long l_val;
-
-	/* Check for 16 or 32 */
-	if (count == 2 && ((long) mem & 1) == 0) {
-		s_val = *(unsigned short *) mem;
-		mem = (char *) &s_val;
-	} else if (count == 4 && ((long) mem & 3) == 0) {
-		l_val = *(unsigned long *) mem;
-		mem = (char *) &l_val;
-	}
-	for (i = 0; i < count; i++) {
-		ch = *mem++;
-		*buf++ = highhex(ch);
-		*buf++ = lowhex(ch);
-	}
-	*buf = 0;
-	return (buf);
-}
-
-/* Convert the hex array pointed to by buf into binary, to be placed in mem.
-   Return a pointer to the character after the last byte written */
-static char *hex_to_mem(const char *buf, char *mem, const int count)
-{
-	int i;
-	unsigned char ch;
-
-	for (i = 0; i < count; i++) {
-		ch = hex(*buf++) << 4;
-		ch = ch + hex(*buf++);
-		*mem++ = ch;
-	}
-	return (mem);
-}
-
-/* While finding valid hex chars, convert to an integer, then return it */
-static int hex_to_int(char **ptr, int *int_value)
-{
-	int num_chars = 0;
-	int hex_value;
-
-	*int_value = 0;
-
-	while (**ptr) {
-		hex_value = hex(**ptr);
-		if (hex_value >= 0) {
-			*int_value = (*int_value << 4) | hex_value;
-			num_chars++;
-		} else
-			break;
-		(*ptr)++;
-	}
-	return num_chars;
-}
-
-/*  Copy the binary array pointed to by buf into mem.  Fix $, #,
-    and 0x7d escaped with 0x7d.  Return a pointer to the character 
-    after the last byte written. */
-static char *ebin_to_mem(const char *buf, char *mem, int count)
-{
-	for (; count > 0; count--, buf++) {
-		if (*buf == 0x7d)
-			*mem++ = *(++buf) ^ 0x20;
-		else
-			*mem++ = *buf;
-	}
-	return mem;
-}
-
-/* Pack a hex byte */
-static char *pack_hex_byte(char *pkt, int byte)
-{
-	*pkt++ = hexchars[(byte >> 4) & 0xf];
-	*pkt++ = hexchars[(byte & 0xf)];
-	return pkt;
-}
-
-#ifdef CONFIG_KGDB_THREAD
-
-/* Pack a thread ID */
-static char *pack_threadid(char *pkt, threadref * id)
-{
-	char *limit;
-	unsigned char *altid;
-
-	altid = (unsigned char *) id;
-
-	limit = pkt + BUF_THREAD_ID_SIZE;
-	while (pkt < limit)
-		pkt = pack_hex_byte(pkt, *altid++);
-	return pkt;
-}
-
-/* Convert an integer into our threadref */
-static void int_to_threadref(threadref * id, const int value)
-{
-	unsigned char *scan = (unsigned char *) id;
-	int i = 4;
-
-	while (i--)
-		*scan++ = 0;
-
-	*scan++ = (value >> 24) & 0xff;
-	*scan++ = (value >> 16) & 0xff;
-	*scan++ = (value >> 8) & 0xff;
-	*scan++ = (value & 0xff);
-}
-
-/* Return a task structure ptr for a particular pid */
-static struct task_struct *get_thread(int pid)
-{
-	struct task_struct *thread;
-
-	/* Use PID_MAX w/gdb for pid 0 */
-	if (pid == PID_MAX) pid = 0;
-
-	/* First check via PID */
-	thread = find_task_by_pid(pid);
-
-	if (thread)
-		return thread;
-
-	/* Start at the start */
-	thread = init_tasks[0];
-
-	/* Walk along the linked list of tasks */
-	do {
-		if (thread->pid == pid)
-			return thread;
-		thread = thread->next_task;
-	} while (thread != init_tasks[0]);
-
-	return NULL;
-}
-
-#endif /* CONFIG_KGDB_THREAD */
-
-/* Scan for the start char '$', read the packet and check the checksum */
-static void get_packet(char *buffer, int buflen)
-{
-	unsigned char checksum;
-	unsigned char xmitcsum;
-	int i;
-	int count;
-	char ch;
-
-	do {
-		/* Ignore everything until the start character */
-		while ((ch = get_debug_char()) != '$');
-
-		checksum = 0;
-		xmitcsum = -1;
-		count = 0;
-
-		/* Now, read until a # or end of buffer is found */
-		while (count < (buflen - 1)) {
-			ch = get_debug_char();
-
-			if (ch == '#')
-				break;
-
-			checksum = checksum + ch;
-			buffer[count] = ch;
-			count = count + 1;
-		}
-
-		buffer[count] = 0;
-
-		/* Continue to read checksum following # */
-		if (ch == '#') {
-			xmitcsum = hex(get_debug_char()) << 4;
-			xmitcsum += hex(get_debug_char());
-
-			/* Checksum */
-			if (checksum != xmitcsum)
-				put_debug_char('-');	/* Failed checksum */
-			else {
-				/* Ack successful transfer */
-				put_debug_char('+');
-
-				/* If a sequence char is present, reply 
-				   the sequence ID */
-				if (buffer[2] == ':') {
-					put_debug_char(buffer[0]);
-					put_debug_char(buffer[1]);
-
-					/* Remove sequence chars from buffer */
-					count = strlen(buffer);
-					for (i = 3; i <= count; i++)
-						buffer[i - 3] = buffer[i];
-				}
-			}
-		}
-	}
-	while (checksum != xmitcsum);	/* Keep trying while we fail */
-}
-
-/* Send the packet in the buffer with run-length encoding */
-static void put_packet(char *buffer)
-{
-	int checksum;
-	char *src;
-	int runlen;
-	int encode;
-
-	do {
-		src = buffer;
-		put_debug_char('$');
-		checksum = 0;
-
-		/* Continue while we still have chars left */
-		while (*src) {
-			/* Check for runs up to 99 chars long */
-			for (runlen = 1; runlen < 99; runlen++) {
-				if (src[0] != src[runlen])
-					break;
-			}
-
-			if (runlen > 3) {
-				/* Got a useful amount, send encoding */
-				encode = runlen + ' ' - 4;
-				put_debug_char(*src);   checksum += *src;
-				put_debug_char('*');    checksum += '*';
-				put_debug_char(encode); checksum += encode;
-				src += runlen;
-			} else {
-				/* Otherwise just send the current char */
-				put_debug_char(*src);   checksum += *src;
-				src += 1;
-			}
-		}
-
-		/* '#' Separator, put high and low components of checksum */
-		put_debug_char('#');
-		put_debug_char(highhex(checksum));
-		put_debug_char(lowhex(checksum));
-	}
-	while ((get_debug_char()) != '+');	/* While no ack */
-}
-
-/* A bus error has occurred - perform a longjmp to return execution and
-   allow handling of the error */
-static void kgdb_handle_bus_error(void)
-{
-	longjmp(rem_com_env, 1);
-}
-
-/* Translate SH-3/4 exception numbers to unix-like signal values */
-static int compute_signal(const int excep_code)
-{
-	int sigval;
-
-	switch (excep_code) {
-
-	case INVALID_INSN_VEC:
-	case INVALID_SLOT_VEC:
-		sigval = SIGILL;
-		break;
-	case ADDRESS_ERROR_LOAD_VEC:
-	case ADDRESS_ERROR_STORE_VEC:
-		sigval = SIGSEGV;
-		break;
-
-	case SERIAL_BREAK_VEC:
-	case NMI_VEC:
-		sigval = SIGINT;
-		break;
-
-	case USER_BREAK_VEC:
-	case TRAP_VEC:
-		sigval = SIGTRAP;
-		break;
-
-	default:
-		sigval = SIGBUS;	/* "software generated" */
-		break;
-	}
-
-	return (sigval);
-}
-
-/* Make a local copy of the registers passed into the handler (bletch) */
-static void kgdb_regs_to_gdb_regs(const struct kgdb_regs *regs,
-				  int *gdb_regs)
-{
-	gdb_regs[R0] = regs->regs[R0];
-	gdb_regs[R1] = regs->regs[R1];
-	gdb_regs[R2] = regs->regs[R2];
-	gdb_regs[R3] = regs->regs[R3];
-	gdb_regs[R4] = regs->regs[R4];
-	gdb_regs[R5] = regs->regs[R5];
-	gdb_regs[R6] = regs->regs[R6];
-	gdb_regs[R7] = regs->regs[R7];
-	gdb_regs[R8] = regs->regs[R8];
-	gdb_regs[R9] = regs->regs[R9];
-	gdb_regs[R10] = regs->regs[R10];
-	gdb_regs[R11] = regs->regs[R11];
-	gdb_regs[R12] = regs->regs[R12];
-	gdb_regs[R13] = regs->regs[R13];
-	gdb_regs[R14] = regs->regs[R14];
-	gdb_regs[R15] = regs->regs[R15];
-	gdb_regs[PC] = regs->pc;
-	gdb_regs[PR] = regs->pr;
-	gdb_regs[GBR] = regs->gbr;
-	gdb_regs[MACH] = regs->mach;
-	gdb_regs[MACL] = regs->macl;
-	gdb_regs[SR] = regs->sr;
-	gdb_regs[VBR] = regs->vbr;
-}
-
-/* Copy local gdb registers back to kgdb regs, for later copy to kernel */
-static void gdb_regs_to_kgdb_regs(const int *gdb_regs,
-				  struct kgdb_regs *regs)
-{
-	regs->regs[R0] = gdb_regs[R0];
-	regs->regs[R1] = gdb_regs[R1];
-	regs->regs[R2] = gdb_regs[R2];
-	regs->regs[R3] = gdb_regs[R3];
-	regs->regs[R4] = gdb_regs[R4];
-	regs->regs[R5] = gdb_regs[R5];
-	regs->regs[R6] = gdb_regs[R6];
-	regs->regs[R7] = gdb_regs[R7];
-	regs->regs[R8] = gdb_regs[R8];
-	regs->regs[R9] = gdb_regs[R9];
-	regs->regs[R10] = gdb_regs[R10];
-	regs->regs[R11] = gdb_regs[R11];
-	regs->regs[R12] = gdb_regs[R12];
-	regs->regs[R13] = gdb_regs[R13];
-	regs->regs[R14] = gdb_regs[R14];
-	regs->regs[R15] = gdb_regs[R15];
-	regs->pc = gdb_regs[PC];
-	regs->pr = gdb_regs[PR];
-	regs->gbr = gdb_regs[GBR];
-	regs->mach = gdb_regs[MACH];
-	regs->macl = gdb_regs[MACL];
-	regs->sr = gdb_regs[SR];
-	regs->vbr = gdb_regs[VBR];
-}
-
-#ifdef CONFIG_KGDB_THREAD
-/* Make a local copy of registers from the specified thread */
-asmlinkage void ret_from_fork(void);
-static void thread_regs_to_gdb_regs(const struct task_struct *thread,
-				    int *gdb_regs)
-{
-	int regno;
-	int *tregs;
-
-	/* Initialize to zero */
-	for (regno = 0; regno < MAXREG; regno++)
-		gdb_regs[regno] = 0;
-
-	/* Just making sure... */
-	if (thread == NULL)
-		return;
-
-	/* A new fork has pt_regs on the stack from a fork() call */
-	if (thread->thread.pc == (unsigned long)ret_from_fork) {
-
-		int vbr_val;
-		struct pt_regs *kregs;
-		kregs = (struct pt_regs*)thread->thread.sp;
-
-		gdb_regs[R0] = kregs->regs[R0];
-		gdb_regs[R1] = kregs->regs[R1];
-		gdb_regs[R2] = kregs->regs[R2];
-		gdb_regs[R3] = kregs->regs[R3];
-		gdb_regs[R4] = kregs->regs[R4];
-		gdb_regs[R5] = kregs->regs[R5];
-		gdb_regs[R6] = kregs->regs[R6];
-		gdb_regs[R7] = kregs->regs[R7];
-		gdb_regs[R8] = kregs->regs[R8];
-		gdb_regs[R9] = kregs->regs[R9];
-		gdb_regs[R10] = kregs->regs[R10];
-		gdb_regs[R11] = kregs->regs[R11];
-		gdb_regs[R12] = kregs->regs[R12];
-		gdb_regs[R13] = kregs->regs[R13];
-		gdb_regs[R14] = kregs->regs[R14];
-		gdb_regs[R15] = kregs->regs[R15];
-		gdb_regs[PC] = kregs->pc;
-		gdb_regs[PR] = kregs->pr;
-		gdb_regs[GBR] = kregs->gbr;
-		gdb_regs[MACH] = kregs->mach;
-		gdb_regs[MACL] = kregs->macl;
-		gdb_regs[SR] = kregs->sr;
-
-		asm("stc vbr, %0":"=r"(vbr_val));
-		gdb_regs[VBR] = vbr_val;
-		return;
-	}
-
-	/* Otherwise, we have only some registers from switch_to() */
-	tregs = (int *)thread->thread.sp;
-	gdb_regs[R15] = (int)tregs;
-	gdb_regs[R14] = *tregs++;
-	gdb_regs[R13] = *tregs++;
-	gdb_regs[R12] = *tregs++;
-	gdb_regs[R11] = *tregs++;
-	gdb_regs[R10] = *tregs++;
-	gdb_regs[R9] = *tregs++;
-	gdb_regs[R8] = *tregs++;
-	gdb_regs[PR] = *tregs++;
-	gdb_regs[GBR] = *tregs++;
-	gdb_regs[PC] = thread->thread.pc;
-}
-#endif /* CONFIG_KGDB_THREAD */
-
-/* Calculate the new address for after a step */
-static short *get_step_address(void)
-{
-	short op = *(short *) trap_registers.pc;
-	long addr;
-
-	/* BT */
-	if (OPCODE_BT(op)) {
-		if (trap_registers.sr & SR_T_BIT_MASK)
-			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = trap_registers.pc + 2;
-	}
-
-	/* BTS */
-	else if (OPCODE_BTS(op)) {
-		if (trap_registers.sr & SR_T_BIT_MASK)
-			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = trap_registers.pc + 4;	/* Not in delay slot */
-	}
-
-	/* BF */
-	else if (OPCODE_BF(op)) {
-		if (!(trap_registers.sr & SR_T_BIT_MASK))
-			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = trap_registers.pc + 2;
-	}
-
-	/* BFS */
-	else if (OPCODE_BFS(op)) {
-		if (!(trap_registers.sr & SR_T_BIT_MASK))
-			addr = trap_registers.pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = trap_registers.pc + 4;	/* Not in delay slot */
-	}
-
-	/* BRA */
-	else if (OPCODE_BRA(op))
-		addr = trap_registers.pc + 4 + OPCODE_BRA_DISP(op);
-
-	/* BRAF */
-	else if (OPCODE_BRAF(op))
-		addr = trap_registers.pc + 4
-		    + trap_registers.regs[OPCODE_BRAF_REG(op)];
-
-	/* BSR */
-	else if (OPCODE_BSR(op))
-		addr = trap_registers.pc + 4 + OPCODE_BSR_DISP(op);
-
-	/* BSRF */
-	else if (OPCODE_BSRF(op))
-		addr = trap_registers.pc + 4
-		    + trap_registers.regs[OPCODE_BSRF_REG(op)];
-
-	/* JMP */
-	else if (OPCODE_JMP(op))
-		addr = trap_registers.regs[OPCODE_JMP_REG(op)];
-
-	/* JSR */
-	else if (OPCODE_JSR(op))
-		addr = trap_registers.regs[OPCODE_JSR_REG(op)];
-
-	/* RTS */
-	else if (OPCODE_RTS(op))
-		addr = trap_registers.pr;
-
-	/* RTE */
-	else if (OPCODE_RTE(op))
-		addr = trap_registers.regs[15];
-
-	/* Other */
-	else
-		addr = trap_registers.pc + 2;
-
-	kgdb_flush_icache_range(addr, addr + 2);
-	return (short *) addr;
-}
-
-/* Set up a single-step.  Replace the instruction immediately after the 
-   current instruction (i.e. next in the expected flow of control) with a
-   trap instruction, so that returning will cause only a single instruction
-   to be executed. Note that this model is slightly broken for instructions
-   with delay slots (e.g. B[TF]S, BSR, BRA etc), where both the branch
-   and the instruction in the delay slot will be executed. */
-static void do_single_step(void)
-{
-	unsigned short *addr = 0;
-
-	/* Determine where the target instruction will send us to */
-	addr = get_step_address();
-	stepped_address = (int)addr;
-
-	/* Replace it */
-	stepped_opcode = *(short *)addr;
-	*addr = STEP_OPCODE;
-
-	/* Flush and return */
-	kgdb_flush_icache_range((long) addr, (long) addr + 2);
-	return;
-}
-
-/* Undo a single step */
-static void undo_single_step(void)
-{
-	/* If we have stepped, put back the old instruction */
-	/* Use stepped_address in case we stopped elsewhere */
-	if (stepped_opcode != 0) {
-		*(short*)stepped_address = stepped_opcode;
-		kgdb_flush_icache_range(stepped_address, stepped_address + 2);
-	}
-	stepped_opcode = 0;
-}
-
-/* Send a signal message */
-static void send_signal_msg(const int signum)
-{
-#ifndef CONFIG_KGDB_THREAD
-	out_buffer[0] = 'S';
-	out_buffer[1] = highhex(signum);
-	out_buffer[2] = lowhex(signum);
-	out_buffer[3] = 0;
-	put_packet(out_buffer);
-#else /* CONFIG_KGDB_THREAD */
-	int threadid;
-	threadref thref;
-	char *out = out_buffer;
-	const char *tstring = "thread";
-
-	*out++ = 'T';
-	*out++ = highhex(signum);
-	*out++ = lowhex(signum);
-
-	while (*tstring) {
-		*out++ = *tstring++;
-	}
-	*out++ = ':';
-
-	threadid = trapped_thread->pid;
-	if (threadid == 0) threadid = PID_MAX;
-	int_to_threadref(&thref, threadid);
-	pack_threadid(out, &thref);
-	out += BUF_THREAD_ID_SIZE;
-	*out++ = ';';
-
-	*out = 0;
-	put_packet(out_buffer);
-#endif /* CONFIG_KGDB_THREAD */
-}
-
-/* Reply that all was well */
-static void send_ok_msg(void)
-{
-	strcpy(out_buffer, "OK");
-	put_packet(out_buffer);
-}
-
-/* Reply that an error occurred */
-static void send_err_msg(void)
-{
-	strcpy(out_buffer, "E01");
-	put_packet(out_buffer);
-}
-
-/* Empty message indicates unrecognised command */
-static void send_empty_msg(void)
-{
-	put_packet("");
-}
-
-/* Read memory due to 'm' message */
-static void read_mem_msg(void)
-{
-	char *ptr;
-	int addr;
-	int length;
-
-	/* Jmp, disable bus error handler */
-	if (setjmp(rem_com_env) == 0) {
-
-		kgdb_nofault = 1;
-
-		/* Walk through, have m<addr>,<length> */
-		ptr = &in_buffer[1];
-		if (hex_to_int(&ptr, &addr) && (*ptr++ == ','))
-			if (hex_to_int(&ptr, &length)) {
-				ptr = 0;
-				if (length * 2 > OUTBUFMAX)
-					length = OUTBUFMAX / 2;
-				mem_to_hex((char *) addr, out_buffer, length);
-			}
-		if (ptr)
-			send_err_msg();
-		else
-			put_packet(out_buffer);
-	} else
-		send_err_msg();
-
-	/* Restore bus error handler */
-	kgdb_nofault = 0;
-}
-
-/* Write memory due to 'M' or 'X' message */
-static void write_mem_msg(int binary)
-{
-	char *ptr;
-	int addr;
-	int length;
-
-	if (setjmp(rem_com_env) == 0) {
-
-		kgdb_nofault = 1;
-
-		/* Walk through, have M<addr>,<length>:<data> */
-		ptr = &in_buffer[1];
-		if (hex_to_int(&ptr, &addr) && (*ptr++ == ','))
-			if (hex_to_int(&ptr, &length) && (*ptr++ == ':')) {
-				if (binary)
-					ebin_to_mem(ptr, (char*)addr, length);
-				else
-					hex_to_mem(ptr, (char*)addr, length);
-				kgdb_flush_icache_range(addr, addr + length);
-				ptr = 0;
-				send_ok_msg();
-			}
-		if (ptr)
-			send_err_msg();
-	} else
-		send_err_msg();
-
-	/* Restore bus error handler */
-	kgdb_nofault = 0;
-}
-
-/* Continue message  */
-static void continue_msg(void)
-{
-	/* Try to read optional parameter, PC unchanged if none */
-	char *ptr = &in_buffer[1];
-	int addr;
-
-	if (hex_to_int(&ptr, &addr))
-		trap_registers.pc = addr;
-}
-
-/* Continue message with signal */
-static void continue_with_sig_msg(void)
-{
-	int signal;
-	char *ptr = &in_buffer[1];
-	int addr;
-
-	/* Report limitation */
-	kgdb_to_gdb("Cannot force signal in kgdb, continuing anyway.\n");
-
-	/* Signal */
-	hex_to_int(&ptr, &signal);
-	if (*ptr == ';')
-		ptr++;
-
-	/* Optional address */
-	if (hex_to_int(&ptr, &addr))
-		trap_registers.pc = addr;
-}
-
-/* Step message */
-static void step_msg(void)
-{
-	continue_msg();
-	do_single_step();
-}
-
-/* Step message with signal */
-static void step_with_sig_msg(void)
-{
-	continue_with_sig_msg();
-	do_single_step();
-}
-
-/* Send register contents */
-static void send_regs_msg(void)
-{
-#ifdef CONFIG_KGDB_THREAD
-	if (!current_thread)
-		kgdb_regs_to_gdb_regs(&trap_registers, registers);
-	else
-		thread_regs_to_gdb_regs(current_thread, registers);
-#else
-	kgdb_regs_to_gdb_regs(&trap_registers, registers);
-#endif
-
-	mem_to_hex((char *) registers, out_buffer, NUMREGBYTES);
-	put_packet(out_buffer);
-}
-
-/* Set register contents - currently can't set other thread's registers */
-static void set_regs_msg(void)
-{
-#ifdef CONFIG_KGDB_THREAD
-	if (!current_thread) {
-#endif
-		kgdb_regs_to_gdb_regs(&trap_registers, registers);
-		hex_to_mem(&in_buffer[1], (char *) registers, NUMREGBYTES);
-		gdb_regs_to_kgdb_regs(registers, &trap_registers);
-		send_ok_msg();
-#ifdef CONFIG_KGDB_THREAD
-	} else
-		send_err_msg();
-#endif
-}
-
-
-#ifdef CONFIG_KGDB_THREAD
-
-/* Set the status for a thread */
-void set_thread_msg(void)
-{
-	int threadid;
-	struct task_struct *thread = NULL;
-	char *ptr;
-
-	switch (in_buffer[1]) {
-
-       	/* To select which thread for gG etc messages, i.e. supported */
-	case 'g':
-
-		ptr = &in_buffer[2];
-		hex_to_int(&ptr, &threadid);
-		thread = get_thread(threadid);
-
-		/* If we haven't found it */
-		if (!thread) {
-			send_err_msg();
-			break;
-		}
-
-		/* Set current_thread (or not) */
-		if (thread == trapped_thread)
-			current_thread = NULL;
-		else
-			current_thread = thread;
-		send_ok_msg();
-		break;
-
-	/* To select which thread for cCsS messages, i.e. unsupported */
-	case 'c':
-		send_ok_msg();
-		break;
-
-	default:
-		send_empty_msg();
-		break;
-	}
-}
-
-/* Is a thread alive? */
-static void thread_status_msg(void)
-{
-	char *ptr;
-	int threadid;
-	struct task_struct *thread = NULL;
-
-	ptr = &in_buffer[1];
-	hex_to_int(&ptr, &threadid);
-	thread = get_thread(threadid);
-	if (thread)
-		send_ok_msg();
-	else
-		send_err_msg();
-}
-/* Send the current thread ID */
-static void thread_id_msg(void)
-{
-	int threadid;
-	threadref thref;
-
-	out_buffer[0] = 'Q';
-	out_buffer[1] = 'C';
-
-	if (current_thread)
-		threadid = current_thread->pid;
-	else if (trapped_thread)
-		threadid = trapped_thread->pid;
-	else /* Impossible, but just in case! */
-	{
-		send_err_msg();
-		return;
-	}
-
-	/* Translate pid 0 to PID_MAX for gdb */
-	if (threadid == 0) threadid = PID_MAX;
-
-	int_to_threadref(&thref, threadid);
-	pack_threadid(out_buffer + 2, &thref);
-	out_buffer[2 + BUF_THREAD_ID_SIZE] = '\0';
-	put_packet(out_buffer);
-}
-
-/* Send thread info */
-static void thread_info_msg(void)
-{
-	struct task_struct *thread = NULL;
-	int threadid;
-	char *pos;
-	threadref thref;
-
-	/* Start with 'm' */
-	out_buffer[0] = 'm';
-	pos = &out_buffer[1];
-
-	/* For all possible thread IDs - this will overrun if > 44 threads! */
-	/* Start at 1 and include PID_MAX (since GDB won't use pid 0...) */
-	for (threadid = 1; threadid <= PID_MAX; threadid++) {
-
-		read_lock(&tasklist_lock);
-		thread = get_thread(threadid);
-		read_unlock(&tasklist_lock);
-
-		/* If it's a valid thread */
-		if (thread) {
-			int_to_threadref(&thref, threadid);
-			pack_threadid(pos, &thref);
-			pos += BUF_THREAD_ID_SIZE;
-			*pos++ = ',';
-		}
-	}
-	*--pos = 0;		/* Lose final comma */
-	put_packet(out_buffer);
-
-}
-
-/* Return printable info for gdb's 'info threads' command */
-static void thread_extra_info_msg(void)
-{
-	int threadid;
-	struct task_struct *thread = NULL;
-	char buffer[20], *ptr;
-	int i;
-
-	/* Extract thread ID */
-	ptr = &in_buffer[17];
-	hex_to_int(&ptr, &threadid);
-	thread = get_thread(threadid);
-
-	/* If we don't recognise it, say so */
-	if (thread == NULL)
-		strcpy(buffer, "(unknown)");
-	else
-		strcpy(buffer, thread->comm);
-
-	/* Construct packet */
-	for (i = 0, ptr = out_buffer; buffer[i]; i++)
-		ptr = pack_hex_byte(ptr, buffer[i]);
-
-	if (thread->thread.pc == (unsigned long)ret_from_fork) {
-		strcpy(buffer, "<new fork>");
-		for (i = 0; buffer[i]; i++)
-			ptr = pack_hex_byte(ptr, buffer[i]);
-	}
-
-	*ptr = '\0';
-	put_packet(out_buffer);
-}
-
-/* Handle all qFooBarBaz messages - have to use an if statement as
-   opposed to a switch because q messages can have > 1 char id. */
-static void query_msg(void)
-{
-	const char *q_start = &in_buffer[1];
-
-	/* qC = return current thread ID */
-	if (strncmp(q_start, "C", 1) == 0)
-		thread_id_msg();
-
-	/* qfThreadInfo = query all threads (first) */
-	else if (strncmp(q_start, "fThreadInfo", 11) == 0)
-		thread_info_msg();
-
-	/* qsThreadInfo = query all threads (subsequent). We know we have sent
-	   them all after the qfThreadInfo message, so there are no to send */
-	else if (strncmp(q_start, "sThreadInfo", 11) == 0)
-		put_packet("l");	/* el = last */
-
-	/* qThreadExtraInfo = supply printable information per thread */
-	else if (strncmp(q_start, "ThreadExtraInfo", 15) == 0)
-		thread_extra_info_msg();
-
-	/* Unsupported - empty message as per spec */
-	else
-		send_empty_msg();
-}
-#endif /* CONFIG_KGDB_THREAD */
-
-/*
- * Bring up the ports..
- */
-static int kgdb_serial_setup(void)
-{
-	extern int kgdb_console_setup(struct console *co, char *options);
-	struct console dummy;
-
-	kgdb_console_setup(&dummy, 0);
-
-	return 0;
-}
-
-/* The command loop, read and act on requests */
-static void kgdb_command_loop(const int excep_code, const int trapa_value)
-{
-	int sigval;
-
-	if (excep_code == NMI_VEC) {
-#ifndef CONFIG_KGDB_NMI
-		KGDB_PRINTK("Ignoring unexpected NMI?\n");
-		return;
-#else /* CONFIG_KGDB_NMI */
-		if (!kgdb_enabled) {
-			kgdb_enabled = 1;
-			kgdb_init();
-		}
-#endif /* CONFIG_KGDB_NMI */
-	}
-
-	/* Ignore if we're disabled */
-	if (!kgdb_enabled)
-		return;
-
-#ifdef CONFIG_KGDB_THREAD
-	/* Until GDB specifies a thread */
-	current_thread = NULL;
-	trapped_thread = current;
-#endif
-
-	/* Enter GDB mode (e.g. after detach) */
-	if (!kgdb_in_gdb_mode) {
-		/* Do serial setup, notify user, issue preemptive ack */
-		kgdb_serial_setup();
-		KGDB_PRINTK("Waiting for GDB (on %s%d at %d baud)\n",
-			    (kgdb_porttype ? kgdb_porttype->name : ""),
-			    kgdb_portnum, kgdb_baud);
-		kgdb_in_gdb_mode = 1;
-		put_debug_char('+');
-	}
-
-	/* Reply to host that an exception has occurred */
-	sigval = compute_signal(excep_code);
-	send_signal_msg(sigval);
-
-	/* TRAP_VEC exception indicates a software trap inserted in place of
-	   code by GDB so back up PC by one instruction, as this instruction
-	   will later be replaced by its original one.  Do NOT do this for
-	   trap 0xff, since that indicates a compiled-in breakpoint which
-	   will not be replaced (and we would retake the trap forever) */
-	if ((excep_code == TRAP_VEC) && (trapa_value != (0xff << 2))) {
-		trap_registers.pc -= 2;
-	}
-
-	/* Undo any stepping we may have done */
-	undo_single_step();
-
-	while (1) {
-
-		out_buffer[0] = 0;
-		get_packet(in_buffer, BUFMAX);
-
-		/* Examine first char of buffer to see what we need to do */
-		switch (in_buffer[0]) {
-
-		case '?':	/* Send which signal we've received */
-			send_signal_msg(sigval);
-			break;
-
-		case 'g':	/* Return the values of the CPU registers */
-			send_regs_msg();
-			break;
-
-		case 'G':	/* Set the value of the CPU registers */
-			set_regs_msg();
-			break;
-
-		case 'm':	/* Read LLLL bytes address AA..AA */
-			read_mem_msg();
-			break;
-
-		case 'M':	/* Write LLLL bytes address AA..AA, ret OK */
-			write_mem_msg(0);	/* 0 = data in hex */
-			break;
-
-		case 'X':	/* Write LLLL bytes esc bin address AA..AA */
-			if (kgdb_bits == '8')
-				write_mem_msg(1); /* 1 = data in binary */
-			else
-				send_empty_msg();
-			break;
-
-		case 'C':	/* Continue, signum included, we ignore it */
-			continue_with_sig_msg();
-			return;
-
-		case 'c':	/* Continue at address AA..AA (optional) */
-			continue_msg();
-			return;
-
-		case 'S':	/* Step, signum included, we ignore it */
-			step_with_sig_msg();
-			return;
-
-		case 's':	/* Step one instruction from AA..AA */
-			step_msg();
-			return;
-
-#ifdef CONFIG_KGDB_THREAD
-
-		case 'H':	/* Task related */
-			set_thread_msg();
-			break;
-
-		case 'T':	/* Query thread status */
-			thread_status_msg();
-			break;
-
-		case 'q':	/* Handle query - currently thread-related */
-			query_msg();
-			break;
-#endif
-
-		case 'k':	/* 'Kill the program' with a kernel ? */
-			break;
-
-		case 'D':	/* Detach from program, send reply OK */
-			kgdb_in_gdb_mode = 0;
-			send_ok_msg();
-			get_debug_char();
-			return;
-
-		default:
-			send_empty_msg();
-			break;
-		}
-	}
-}
-
-/* There has been an exception, most likely a breakpoint. */
-void kgdb_handle_exception(struct pt_regs *regs)
-{
-	int excep_code, vbr_val;
-	int count;
-	int trapa_value = ctrl_inl(TRA);
-
-	/* Copy kernel regs (from stack) */
-	for (count = 0; count < 16; count++)
-		trap_registers.regs[count] = regs->regs[count];
-	trap_registers.pc = regs->pc;
-	trap_registers.pr = regs->pr;
-	trap_registers.sr = regs->sr;
-	trap_registers.gbr = regs->gbr;
-	trap_registers.mach = regs->mach;
-	trap_registers.macl = regs->macl;
-
-	asm("stc vbr, %0":"=r"(vbr_val));
-	trap_registers.vbr = vbr_val;
-
-	/* Get excode for command loop call, user access */
-	asm("stc r2_bank, %0":"=r"(excep_code));
-	kgdb_excode = excep_code;
-
-	/* Other interesting environment items for reference */
-	asm("stc r6_bank, %0":"=r"(kgdb_g_imask));
-	kgdb_current = current;
-	kgdb_trapa_val = trapa_value;
-
-	/* Act on the exception */
-	kgdb_command_loop(excep_code >> 5, trapa_value);
-
-	kgdb_current = NULL;
-
-	/* Copy back the (maybe modified) registers */
-	for (count = 0; count < 16; count++)
-		regs->regs[count] = trap_registers.regs[count];
-	regs->pc = trap_registers.pc;
-	regs->pr = trap_registers.pr;
-	regs->sr = trap_registers.sr;
-	regs->gbr = trap_registers.gbr;
-	regs->mach = trap_registers.mach;
-	regs->macl = trap_registers.macl;
-
-	vbr_val = trap_registers.vbr;
-	asm("ldc %0, vbr": :"r"(vbr_val));
-
-	return;
-}
-
-/* Trigger a breakpoint by function */
-void breakpoint(void)
-{
-	if (!kgdb_enabled) {
-		kgdb_enabled = 1;
-		kgdb_init();
-	}
-	BREAKPOINT();
-}
-
-/* Initialise the KGDB data structures and serial configuration */
-int kgdb_init(void)
-{
-	if (!kgdb_enabled)
-		return 1;
-
-	in_nmi = 0;
-	kgdb_nofault = 0;
-	stepped_opcode = 0;
-	kgdb_in_gdb_mode = 0;
-
-	if (kgdb_serial_setup() != 0) {
-		KGDB_PRINTK("serial setup error\n");
-		return -1;
-	}
-
-	/* Init ptr to exception handler */
-	kgdb_debug_hook = kgdb_handle_exception;
-	kgdb_bus_err_hook = kgdb_handle_bus_error;
-
-	/* Enter kgdb now if requested, or just report init done */
-	if (kgdb_halt) {
-		kgdb_in_gdb_mode = 1;
-		put_debug_char('+');
-		breakpoint();
-	}
-	else
-	{
-		KGDB_PRINTK("stub is initialized.\n");
-	}
-
-	return 0;
-}
-
-/* Make function available for "user messages"; console will use it too. */
-
-char gdbmsgbuf[BUFMAX];
-#define MAXOUT ((BUFMAX-2)/2)
-
-static void kgdb_msg_write(const char *s, unsigned count)
-{
-	int i;
-	int wcount;
-	char *bufptr;
-
-	/* 'O'utput */
-	gdbmsgbuf[0] = 'O';
-
-	/* Fill and send buffers... */
-	while (count > 0) {
-		bufptr = gdbmsgbuf + 1;
-
-		/* Calculate how many this time */
-		wcount = (count > MAXOUT) ? MAXOUT : count;
-		
-		/* Pack in hex chars */
-		for (i = 0; i < wcount; i++)
-			bufptr = pack_hex_byte(bufptr, s[i]);
-		*bufptr = '\0';
-
-		/* Move up */
-		s += wcount;
-		count -= wcount;
-
-		/* Write packet */
-		put_packet(gdbmsgbuf);
-	}
-}
-
-static void kgdb_to_gdb(const char *s)
-{
-	kgdb_msg_write(s, strlen(s));
-}
-
-#ifdef CONFIG_SH_KGDB_CONSOLE
-void kgdb_console_write(struct console *co, const char *s, unsigned count)
-{
-	/* Bail if we're not talking to GDB */
-	if (!kgdb_in_gdb_mode)
-		return;
-
-	kgdb_msg_write(s, count);
-}
-#endif
diff -uprN -X  linux-orig/arch/sh/kernel/Makefile linux-kgdb/arch/sh/kernel/Makefile
--- linux-orig/arch/sh/kernel/Makefile	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/Makefile	2006-09-01 08:34:39.000000000 +0000
@@ -13,7 +13,7 @@ obj-y				+= cpu/ timers/
 obj-$(CONFIG_SMP)		+= smp.o
 obj-$(CONFIG_CF_ENABLER)	+= cf-enabler.o
 obj-$(CONFIG_SH_STANDARD_BIOS)	+= sh_bios.o
-obj-$(CONFIG_SH_KGDB)		+= kgdb_stub.o kgdb_jmp.o
+obj-$(CONFIG_KGDB)		+= kgdb.o kgdb-jmp.o
 obj-$(CONFIG_SH_CPU_FREQ)	+= cpufreq.o
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
diff -uprN -X  linux-orig/arch/sh/kernel/setup.c linux-kgdb/arch/sh/kernel/setup.c
--- linux-orig/arch/sh/kernel/setup.c	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/setup.c	2006-09-01 08:34:39.000000000 +0000
@@ -28,10 +28,6 @@
 #include <asm/setup.h>
 #include <asm/clock.h>
 
-#ifdef CONFIG_SH_KGDB
-#include <asm/kgdb.h>
-static int kgdb_parse_options(char *options);
-#endif
 extern void * __rd_start, * __rd_end;
 /*
  * Machine setup..
@@ -531,93 +527,3 @@ struct seq_operations cpuinfo_op = {
 	.show	= show_cpuinfo,
 };
 #endif /* CONFIG_PROC_FS */
-
-#ifdef CONFIG_SH_KGDB
-/*
- * Parse command-line kgdb options.  By default KGDB is enabled,
- * entered on error (or other action) using default serial info.
- * The command-line option can include a serial port specification
- * and an action to override default or configured behavior.
- */
-struct kgdb_sermap kgdb_sci_sermap =
-{ "ttySC", 5, kgdb_sci_setup, NULL };
-
-struct kgdb_sermap *kgdb_serlist = &kgdb_sci_sermap;
-struct kgdb_sermap *kgdb_porttype = &kgdb_sci_sermap;
-
-void kgdb_register_sermap(struct kgdb_sermap *map)
-{
-	struct kgdb_sermap *last;
-
-	for (last = kgdb_serlist; last->next; last = last->next)
-		;
-	last->next = map;
-	if (!map->namelen) {
-		map->namelen = strlen(map->name);
-	}
-}
-
-static int __init kgdb_parse_options(char *options)
-{
-	char c;
-	int baud;
-
-	/* Check for port spec (or use default) */
-
-	/* Determine port type and instance */
-	if (!memcmp(options, "tty", 3)) {
-		struct kgdb_sermap *map = kgdb_serlist;
-
-		while (map && memcmp(options, map->name, map->namelen))
-			map = map->next;
-
-		if (!map) {
-			KGDB_PRINTK("unknown port spec in %s\n", options);
-			return -1;
-		}
-
-		kgdb_porttype = map;
-		kgdb_serial_setup = map->setup_fn;
-		kgdb_portnum = options[map->namelen] - '0';
-		options += map->namelen + 1;
-
-		options = (*options == ',') ? options+1 : options;
-
-		/* Read optional parameters (baud/parity/bits) */
-		baud = simple_strtoul(options, &options, 10);
-		if (baud != 0) {
-			kgdb_baud = baud;
-
-			c = toupper(*options);
-			if (c == 'E' || c == 'O' || c == 'N') {
-				kgdb_parity = c;
-				options++;
-			}
-
-			c = *options;
-			if (c == '7' || c == '8') {
-				kgdb_bits = c;
-				options++;
-			}
-			options = (*options == ',') ? options+1 : options;
-		}
-	}
-
-	/* Check for action specification */
-	if (!memcmp(options, "halt", 4)) {
-		kgdb_halt = 1;
-		options += 4;
-	} else if (!memcmp(options, "disabled", 8)) {
-		kgdb_enabled = 0;
-		options += 8;
-	}
-
-	if (*options) {
-                KGDB_PRINTK("ignored unknown options: %s\n", options);
-		return 0;
-	}
-	return 1;
-}
-__setup("kgdb=", kgdb_parse_options);
-#endif /* CONFIG_SH_KGDB */
-
diff -uprN -X  linux-orig/arch/sh/kernel/time.c linux-kgdb/arch/sh/kernel/time.c
--- linux-orig/arch/sh/kernel/time.c	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/time.c	2006-09-06 12:34:21.552688000 +0000
@@ -195,8 +195,15 @@ void __init time_init(void)
 	if (board_time_init)
 		board_time_init();
 
+#ifdef CONFIG_KGDB
+	if (!kgdb_hwclk_flag){
+		clk_init();
+		kgdb_hwclk_flag = 1;
+	}
+#else
 	clk_init();
 
+#endif
 	if (rtc_sh_get_time) {
 		rtc_sh_get_time(&xtime);
 	} else {
@@ -213,12 +220,4 @@ void __init time_init(void)
 	 */
 	sys_timer = get_sys_timer();
 	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
-
-#if defined(CONFIG_SH_KGDB)
-	/*
-	 * Set up kgdb as requested. We do it here because the serial
-	 * init uses the timer vars we just set up for figuring baud.
-	 */
-	kgdb_init();
-#endif
 }
diff -uprN -X  linux-orig/arch/sh/kernel/traps.c linux-kgdb/arch/sh/kernel/traps.c
--- linux-orig/arch/sh/kernel/traps.c	2006-08-31 13:42:11.000000000 +0000
+++ linux-kgdb/arch/sh/kernel/traps.c	2006-09-01 12:13:34.000000000 +0000
@@ -34,16 +34,12 @@
 #include <asm/atomic.h>
 #include <asm/processor.h>
 #include <asm/sections.h>
+#include <linux/kgdb.h>
 
-#ifdef CONFIG_SH_KGDB
-#include <asm/kgdb.h>
-#define CHK_REMOTE_DEBUG(regs)                 	\
-{       					\
-	if (kgdb_debug_hook && !user_mode(regs))\
-		(*kgdb_debug_hook)(regs);       \
-}
+#ifndef CONFIG_KGDB
+#define kgdb_exception_handler(r)
 #else
-#define CHK_REMOTE_DEBUG(regs)
+extern void kgdb_exception_handler(struct pt_regs *regs);
 #endif
 
 #ifdef CONFIG_CPU_SH2
@@ -68,10 +64,10 @@ void die(const char * str, struct pt_reg
 {
 	static int die_counter;
 
+        kgdb_exception_handler(regs);
 	console_verbose();
 	spin_lock_irq(&die_lock);
 	printk("%s: %04lx [#%d]\n", str, err & 0xffff, ++die_counter);
-	CHK_REMOTE_DEBUG(regs);
 	show_regs(regs);
 	spin_unlock_irq(&die_lock);
 	do_exit(SIGSEGV);
@@ -588,7 +584,7 @@ asmlinkage void do_reserved_inst(unsigne
 	local_irq_enable();
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = TRAP_RESERVED_INST;
-	CHK_REMOTE_DEBUG(regs);
+	kgdb_exception_handler(regs);
 	force_sig(SIGILL, tsk);
 	die_if_no_fixup("reserved instruction", regs, error_code);
 }
@@ -660,7 +656,7 @@ asmlinkage void do_illegal_slot_inst(uns
 	local_irq_enable();
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = TRAP_RESERVED_INST;
-	CHK_REMOTE_DEBUG(regs);
+	kgdb_exception_handler(regs);
 	force_sig(SIGILL, tsk);
 	die_if_no_fixup("illegal slot instruction", regs, error_code);
 }
diff -uprN -X  linux-orig/arch/sh/Makefile linux-kgdb/arch/sh/Makefile
--- linux-orig/arch/sh/Makefile	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/Makefile	2006-09-01 08:34:38.000000000 +0000
@@ -43,7 +43,6 @@ cflags-$(CONFIG_CPU_SH4)		+= -m4 \
 cflags-$(CONFIG_CPU_SH4A)		+= $(call cc-option,-m4a-nofpu,)
 
 cflags-$(CONFIG_SH_DSP)			+= -Wa,-dsp
-cflags-$(CONFIG_SH_KGDB)		+= -g
 
 cflags-$(CONFIG_MORE_COMPILE_OPTIONS)	+= \
 	$(shell echo $(CONFIG_COMPILE_OPTIONS) | sed -e 's/"//g')
diff -uprN -X  linux-orig/arch/sh/mm/extable.c linux-kgdb/arch/sh/mm/extable.c
--- linux-orig/arch/sh/mm/extable.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/arch/sh/mm/extable.c	2006-09-01 08:34:38.000000000 +0000
@@ -6,6 +6,7 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/kgdb.h>
 #include <asm/uaccess.h>
 
 int fixup_exception(struct pt_regs *regs)
@@ -17,6 +18,12 @@ int fixup_exception(struct pt_regs *regs
 		regs->pc = fixup->fixup;
 		return 1;
 	}
+#ifdef CONFIG_KGDB
+	if (atomic_read(&debugger_active) && kgdb_may_fault)
+		/* Restore our previous state. */
+		kgdb_fault_longjmp(kgdb_fault_jmp_regs);
+		/* Never reached. */
+#endif
 
 	return 0;
 }
diff -uprN -X  linux-orig/arch/sh/mm/fault.c linux-kgdb/arch/sh/mm/fault.c
--- linux-orig/arch/sh/mm/fault.c	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/arch/sh/mm/fault.c	2006-09-06 07:51:10.161353000 +0000
@@ -16,7 +16,6 @@
 #include <linux/hardirq.h>
 #include <asm/system.h>
 #include <asm/mmu_context.h>
-#include <asm/kgdb.h>
 
 extern void die(const char *,struct pt_regs *,long);
 
@@ -33,11 +32,6 @@ asmlinkage void do_page_fault(struct pt_
 	struct vm_area_struct * vma;
 	unsigned long page;
 
-#ifdef CONFIG_SH_KGDB
-	if (kgdb_nofault && kgdb_bus_err_hook)
-		kgdb_bus_err_hook();
-#endif
-
 	tsk = current;
 	mm = tsk->mm;
 
@@ -141,6 +135,7 @@ no_context:
 	}
 	die("Oops", regs, writeaccess);
 	do_exit(SIGKILL);
+	dump_stack();
 
 /*
  * We ran out of memory, or some other thing happened to us that made
@@ -201,11 +196,6 @@ asmlinkage int __do_page_fault(struct pt
 	spinlock_t *ptl;
 	int ret = 1;
 
-#ifdef CONFIG_SH_KGDB
-	if (kgdb_nofault && kgdb_bus_err_hook)
-		kgdb_bus_err_hook();
-#endif
-
 	/*
 	 * We don't take page faults for P1, P2, and parts of P4, these
 	 * are always mapped, whether it be due to legacy behaviour in
diff -uprN -X  linux-orig/arch/sh/mm/fault-nommu.c linux-kgdb/arch/sh/mm/fault-nommu.c
--- linux-orig/arch/sh/mm/fault-nommu.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/arch/sh/mm/fault-nommu.c	2006-09-01 08:34:38.000000000 +0000
@@ -29,10 +29,6 @@
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 
-#if defined(CONFIG_SH_KGDB)
-#include <asm/kgdb.h>
-#endif
-
 extern void die(const char *,struct pt_regs *,long);
 
 /*
@@ -43,11 +39,6 @@ extern void die(const char *,struct pt_r
 asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long writeaccess,
 			      unsigned long address)
 {
-#if defined(CONFIG_SH_KGDB)
-	if (kgdb_nofault && kgdb_bus_err_hook)
-		kgdb_bus_err_hook();
-#endif
-
 	/*
 	 * Oops. The kernel tried to access some bad page. We'll have to
 	 * terminate things with extreme prejudice.
@@ -69,11 +60,6 @@ asmlinkage void do_page_fault(struct pt_
 asmlinkage int __do_page_fault(struct pt_regs *regs, unsigned long writeaccess,
 			       unsigned long address)
 {
-#if defined(CONFIG_SH_KGDB)
-	if (kgdb_nofault && kgdb_bus_err_hook)
-		kgdb_bus_err_hook();
-#endif
-
 	if (address >= TASK_SIZE)
 		return 1;
 
diff -uprN -X  linux-orig/Documentation/DocBook/kgdb.tmpl linux-kgdb/Documentation/DocBook/kgdb.tmpl
--- linux-orig/Documentation/DocBook/kgdb.tmpl	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/Documentation/DocBook/kgdb.tmpl	2006-09-01 08:34:38.000000000 +0000
@@ -0,0 +1,250 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
+	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
+
+<book id="kgdbInternals">
+ <bookinfo>
+  <title>KGDB Internals</title>
+
+  <authorgroup>
+   <author>
+    <firstname>Tom</firstname>
+    <surname>Rini</surname>
+    <affiliation>
+     <address>
+      <email>trini@kernel.crashing.org</email>
+     </address>
+    </affiliation>
+   </author>
+  </authorgroup>
+
+  <authorgroup>
+   <author>
+    <firstname>Amit S.</firstname>
+    <surname>Kale</surname>
+    <affiliation>
+     <address>
+      <email>amitkale@linsyssoft.com</email>
+     </address>
+    </affiliation>
+   </author>
+  </authorgroup>
+
+  <copyright>
+   <year>2004-2005</year>
+   <holder>MontaVista Software, Inc.</holder>
+  </copyright>
+  <copyright>
+   <year>2004</year>
+   <holder>Amit S. Kale</holder>
+  </copyright>
+
+  <legalnotice>
+   <para>
+   This file is licensed under the terms of the GNU General Public License
+   version 2. This program is licensed "as is" without any warranty of any
+   kind, whether express or implied.
+   </para>
+
+  </legalnotice>
+ </bookinfo>
+
+<toc></toc>
+  <chapter id="Introduction">
+    <title>Introduction</title>
+    <para>
+    kgdb is a source level debugger for linux kernel. It is used along
+    with gdb to debug a linux kernel. Kernel developers can debug a kernel
+    similar to application programs with the use of kgdb. It makes it
+    possible to place breakpoints in kernel code, step through the code
+    and observe variables.
+    </para>
+    <para>
+    Two machines are required for using kgdb. One of these machines is a
+    development machine and the other is a test machine. The machines are
+    typically connected through a serial line, a null-modem cable which
+    connects their serial ports.  It is also possible however, to use an
+    ethernet connection between the machines.  The kernel to be debugged
+    runs on the test machine. gdb runs on the development machine. The
+    serial line or ethernet connection is used by gdb to communicate to
+    the kernel being debugged.
+    </para>
+  </chapter>
+  <chapter id="CompilingAKernel">
+    <title>Compiling a kernel</title>
+    <para>
+    To enable <symbol>CONFIG_KGDB</symbol>, look under the "Kernel debugging"
+    and then select "KGDB: kernel debugging with remote gdb".
+    </para>
+    <para>
+    The first choice for I/O is <symbol>CONFIG_KGDB_ONLY_MODULES</symbol>.
+    This means that you will only be able to use KGDB after loading a
+    kernel module that defines how you want to be able to talk with
+    KGDB.  There are two other choices (more on some architectures) that
+    can be enabled as modules later, if not picked here.
+    </para>
+    <para>The first of these is <symbol>CONFIG_KGDB_8250_NOMODULE</symbol>.
+    This has sub-options such as <symbol>CONFIG_KGDB_SIMPLE_SERIAL</symbol>
+    which toggles choosing the serial port by ttyS number or by specifying
+    a port and IRQ number.
+    </para>
+    <para>
+    The second of these choices on most systems for I/O is
+    <symbol>CONFIG_KGDBOE</symbol>. This requires that the machine to be
+    debugged has an ethernet card which supports the netpoll API, such as
+    the cards supported by <symbol>CONFIG_E100</symbol>.  There are no
+    sub-options for this, but a kernel command line option is required.
+    </para>
+  </chapter>
+  <chapter id="BootingTheKernel">
+    <title>Booting the kernel</title>
+    <para>
+    The Kernel command line option <constant>kgdbwait</constant> makes kgdb
+    wait for gdb connection during booting of a kernel.  If the
+    <symbol>CONFIG_KGDB_8250</symbol> driver is used (or if applicable,
+    another serial driver) this breakpoint will happen very early on, before
+    console output.  If you wish to change serial port information and you
+    have enabled both <symbol>CONFIG_KGDB_8250</symbol> and
+    <symbol>CONFIG_KGDB_SIMPLE_SERIAL</symbol> then you must pass the option
+    <constant>kgdb8250=&lt;io or mmio&gt;,&lt;address&gt;,&lt;baud
+    rate&gt;,&lt;irq&gt;</constant> before <constant>kgdbwait</constant>.
+    The values <constant>io</constant> or <constant>mmio</constant> refer to
+    if the address being passed next needs to be memory mapped
+    (<constant>mmio</constant>) or not. The <constant>address</constant> must
+    be passed in hex and is the hardware address and will be remapped if
+    passed as <constant>mmio</constant>. The value
+    <constant>baud rate</constant> and <constant>irq</constant> are base-10.
+    The supported values for <constant>baud rate</constant> are
+    <constant>9600</constant>, <constant>19200</constant>,
+    <constant>38400</constant>, <constant>57600</constant>, and
+    <constant>115200</constant>.
+    </para>
+    <para>
+    To have KGDB stop the kernel and wait, with the compiled values for the
+    serial driver, pass in: <constant>kgdbwait</constant>.
+    </para>
+    <para>
+    To specify the values of the SH SCI(F) serial port at boot:
+    <constant>kgdbsci=0,115200</constant>.
+    </para>
+    <para>
+    To specify the values of the serial port at boot:
+    <constant>kgdb8250=io,3f8,115200,3</constant>.
+    On IA64 this could also be:
+    <constant>kgdb8250=mmio,0xff5e0000,115200,74</constant>
+    And to have KGDB also stop the kernel and wait for GDB to connect, pass in
+    <constant>kgdbwait</constant> after this arguement.
+    </para>
+    <para>
+    To configure the <symbol>CONFIG_KGDBOE</symbol> driver, pass in
+    <constant>kgdboe=[src-port]@&lt;src-ip&gt;/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]</constant>
+    where:
+    <itemizedlist>
+      <listitem><para>src-port (optional): source for UDP packets (defaults to <constant>6443</constant>)</para></listitem>
+      <listitem><para>src-ip: source IP to use (interface address)</para></listitem>
+      <listitem><para>dev (optional): network interface (<constant>eth0</constant>)</para></listitem>
+      <listitem><para>tgt-port (optional): port GDB will use (defaults to <constant>6442</constant>)</para></listitem>
+      <listitem><para>tgt-ip: IP address GDB will be connecting from</para></listitem>
+      <listitem><para>tgt-macaddr (optional): ethernet MAC address for logging agent (default is broadcast)</para></listitem>
+    </itemizedlist>
+    </para>
+    <para>
+    The <symbol>CONFIG_KGDBOE</symbol> driver can be reconfigured at run
+    time, if <symbol>CONFIG_SYSFS</symbol> and
+    <symbol>CONFIG_MODULES</symbol> by echo'ing a new config string to
+    <constant>/sys/module/kgdboe/parameter/kgdboe</constant>.  The
+    driver can be unconfigured with the special string
+    <constant>not_configured</constant>.
+    </para>
+  </chapter>
+  <chapter id="ConnectingGDB">
+  <title>Connecting gdb</title>
+    <para>
+    If you have used any of the methods to have KGDB stop and create
+    an initial breakpoint described in the previous chapter, kgdb prints
+    the message "Waiting for connection from remote gdb..." on the console
+    and waits for connection from gdb. At this point you connect gdb to kgdb.
+    </para>
+    <para>
+    Example (serial):
+    </para>
+    <programlisting>
+    % gdb ./vmlinux
+    (gdb) set remotebaud 115200
+    (gdb) target remote /dev/ttyS0
+    </programlisting>
+    <para>
+    Example (ethernet):
+    </para>
+    <programlisting>
+    % gdb ./vmlinux
+    (gdb) target remote udp:192.168.2.2:6443
+    </programlisting>
+    <para>
+    Once connected, you can debug a kernel the way you would debug an
+    application program.
+    </para>
+  </chapter>
+  <chapter id="ArchitectureNotes">
+    <title>Architecture specific notes</title>
+      <para>
+      SuperH: The NMI switch found on some boards can be used to trigger an
+      initial breakpoint.  Subsequent triggers do nothing.  If console
+      is enabled on the SCI(F) serial port, and that is the port being used
+      for KGDB, then you must trigger a breakpoint via sysrq, NMI, or
+      some other method prior to connecting, or echo a control-c to the
+      serial port.  Also, to use the SCI(F) port for KGDB, the
+      <symbol>CONFIG_SERIAL_SH_SCI</symbol> driver must be enabled.
+      </para>
+  </chapter>
+  <chapter id="CommonBackEndReq">
+    <title>The common backend (required)</title>
+      <para>
+      There are a few flags which must be set on every architecture in
+      their &lt;asm/kgdb.h&gt; file.  These are:
+      <itemizedlist>
+        <listitem>
+	  <para>
+	  NUMREGBYTES: The size in bytes of all of the registers, so
+	  that we can ensure they will all fit into a packet.
+	  </para>
+	  <para>
+	  BUFMAX: The size in bytes of the buffer GDB will read into.
+	  This must be larger than NUMREGBYTES.
+	  </para>
+	  <para>
+	  CACHE_FLUSH_IS_SAFE: Set to one if it always safe to call
+	  flush_cache_range or flush_icache_range.  On some architectures,
+	  these functions may not be safe to call on SMP since we keep other
+	  CPUs in a holding pattern.
+	  </para>
+	</listitem>
+      </itemizedlist>
+      </para>
+      <para>
+      There are also the following functions for the common backend,
+      found in kernel/kgdb.c that must be supplied by the
+      architecture-specific backend.  No weak version of these is provided.
+      </para>
+!Iinclude/linux/kgdb.h
+  </chapter>
+  <chapter id="CommonBackEndOpt">
+    <title>The common backend (optional)</title>
+      <para>
+      These functions are part of the common backend, found in kernel/kgdb.c
+      and are optionally implemented.  Some functions (with _hw_ in the name)
+      end up being required on arches which use hardware breakpoints.
+      </para>
+!Ikernel/kgdb.c
+  </chapter>
+  <chapter id="DriverSpecificFunctions">
+    <title>Driver-Specific Functions</title>
+      <para>
+      Some of the I/O drivers have additional functions that can be
+      called, that are specific to the driver.  Calls from other places
+      to these functions must be wrapped in #ifdefs for the driver in
+      question.
+      </para>
+!Idrivers/serial/8250_kgdb.c
+   </chapter>
+</book>
diff -uprN -X  linux-orig/Documentation/DocBook/Makefile linux-kgdb/Documentation/DocBook/Makefile
--- linux-orig/Documentation/DocBook/Makefile	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/Documentation/DocBook/Makefile	2006-09-01 08:34:22.000000000 +0000
@@ -10,7 +10,8 @@ DOCBOOKS := wanbook.xml z8530book.xml mc
 	    kernel-hacking.xml kernel-locking.xml deviceiobook.xml \
 	    procfs-guide.xml writing_usb_driver.xml \
 	    kernel-api.xml journal-api.xml lsm.xml usb.xml \
-	    gadget.xml libata.xml mtdnand.xml librs.xml rapidio.xml
+	    gadget.xml libata.xml mtdnand.xml librs.xml rapidio.xml \
+	    kgdb.xml
 
 ###
 # The build process is as follows (targets):
diff -uprN -X  linux-orig/drivers/char/keyboard.c linux-kgdb/drivers/char/keyboard.c
--- linux-orig/drivers/char/keyboard.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/drivers/char/keyboard.c	2006-09-04 11:16:14.000000000 +0000
@@ -1167,6 +1167,7 @@ static void kbd_keycode(unsigned int key
 	}
 	if (sysrq_down && down && !rep) {
 		handle_sysrq(kbd_sysrq_xlate[keycode], regs, tty);
+		sysrq_down = 0;		/* In case we miss the 'up' event. */
 		return;
 	}
 #endif
diff -uprN -X  linux-orig/drivers/net/kgdboe.c linux-kgdb/drivers/net/kgdboe.c
--- linux-orig/drivers/net/kgdboe.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/drivers/net/kgdboe.c	2006-09-06 13:58:10.593803000 +0000
@@ -0,0 +1,314 @@
+/*
+ * drivers/net/kgdboe.c
+ *
+ * A network interface for GDB.
+ * Based upon 'gdbserial' by David Grothe <dave@gcom.com>
+ * and Scott Foehner <sfoehner@engr.sgi.com>
+ *
+ * Maintainers: Amit S. Kale <amitkale@linsyssoft.com> and
+ * 		Tom Rini <trini@kernel.crashing.org>
+ *
+ * 2004 (c) Amit S. Kale <amitkale@linsyssoft.com>
+ * 2004-2005 (c) MontaVista Software, Inc.
+ * 2005 (c) Wind River Systems, Inc.
+ *
+ * Contributors at various stages not listed above:
+ * San Mehat <nettwerk@biodome.org>, Robert Walsh <rjwalsh@durables.org>,
+ * wangdi <wangdi@clusterfs.com>, Matt Mackall <mpm@selenic.com>,
+ * Pavel Machek <pavel@suse.cz>, Jason Wessel <jason.wessel@windriver.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/kgdb.h>
+#include <linux/netpoll.h>
+#include <linux/init.h>
+
+#include <asm/atomic.h>
+
+#define IN_BUF_SIZE 512		/* power of 2, please */
+#define NOT_CONFIGURED_STRING "not_configured"
+#define OUT_BUF_SIZE 30		/* We don't want to send too big of a packet. */
+#define MAX_KGDBOE_CONFIG_STR 256
+
+static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
+static int in_head, in_tail, out_count;
+static atomic_t in_count;
+/* 0 = unconfigured, 1 = netpoll options parsed, 2 = fully configured. */
+static int configured;
+static struct kgdb_io local_kgdb_io_ops;
+static int use_dynamic_mac;
+
+MODULE_DESCRIPTION("KGDB driver for network interfaces");
+MODULE_LICENSE("GPL");
+static char config[MAX_KGDBOE_CONFIG_STR] = NOT_CONFIGURED_STRING;
+static struct kparam_string kps = {
+	.string = config,
+	.maxlen = MAX_KGDBOE_CONFIG_STR,
+};
+
+struct pt_regs *kgdboe_regs_pointer;
+/* We can save the "pt_regs" value at hardware interrupt and pass that
+   in during the tasklet run.
+   Some architectures, like the ST40, supports this enhancement. */
+static void kgdboe_set_registers(void)
+{
+#ifdef CONFIG_CPU_SUBTYPE_ST40
+        validate_kregs(kgdboe_regs_pointer);
+#endif
+        kgdboe_regs_pointer = NULL;
+}
+
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len,
+		    struct sk_buff *skb)
+{
+	int i;
+
+	np->remote_port = port;
+
+	/* Copy the MAC address if we need to. */
+	if (use_dynamic_mac) {
+		memcpy(np->remote_mac, eth_hdr(skb)->h_source,
+				sizeof(np->remote_mac));
+		use_dynamic_mac = 0;
+	}
+#if 0
+	/*
+	 * This could be GDB trying to attach.  But it could also be GDB
+	 * finishing up a session, with kgdb_connected=0 but GDB sending
+	 * an ACK for the final packet.  To make sure we don't try and
+	 * make a breakpoint when GDB is leaving, make sure that if
+	 * !kgdb_connected the only len == 1 packet we allow is ^C.
+	 */
+	if (!kgdb_connected && (len != 1 || msg[0] == 3) &&
+	    !atomic_read(&kgdb_setting_breakpoint)) {
+		tasklet_schedule(&kgdb_tasklet_breakpoint);
+	}
+#endif
+	if (!netpoll_trap() && len == 8 && !strncmp(msg, "$Hc-1#09", 8)){
+                kgdboe_set_registers();
+                tasklet_schedule(&kgdb_tasklet_breakpoint);
+        }
+
+	for (i = 0; i < len; i++) {
+		if (msg[i] == 3){
+                        kgdboe_set_registers();
+			tasklet_schedule(&kgdb_tasklet_breakpoint);
+		}
+
+		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
+			/* buffer overflow, clear it */
+			in_head = in_tail = 0;
+			atomic_set(&in_count, 0);
+			break;
+		}
+		in_buf[in_head++] = msg[i];
+		in_head &= (IN_BUF_SIZE - 1);
+		atomic_inc(&in_count);
+	}
+}
+
+static struct netpoll np = {
+	.dev_name = "eth0",
+	.name = "kgdboe",
+	.rx_hook = rx_hook,
+	.local_port = 6443,
+	.remote_port = 6442,
+	.remote_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
+};
+
+static void eth_pre_exception_handler(void)
+{
+	/* Increment the module count when the debugger is active */
+	if (!kgdb_connected)
+		try_module_get(THIS_MODULE);
+	netpoll_set_trap(1);
+}
+
+static void eth_post_exception_handler(void)
+{
+	/* decrement the module count when the debugger detaches */
+	if (!kgdb_connected)
+		module_put(THIS_MODULE);
+	netpoll_set_trap(0);
+}
+
+static int eth_get_char(void)
+{
+	int chr;
+
+	while (atomic_read(&in_count) == 0)
+		netpoll_poll(&np);
+
+	chr = in_buf[in_tail++];
+	in_tail &= (IN_BUF_SIZE - 1);
+	atomic_dec(&in_count);
+	return chr;
+}
+
+static void eth_flush_buf(void)
+{
+	if (out_count && np.dev) {
+		netpoll_send_udp(&np, out_buf, out_count);
+		memset(out_buf, 0, sizeof(out_buf));
+		out_count = 0;
+	}
+}
+
+static void eth_put_char(u8 chr)
+{
+	out_buf[out_count++] = chr;
+	if (out_count == OUT_BUF_SIZE)
+		eth_flush_buf();
+}
+
+static int option_setup(char *opt)
+{
+	char opt_scratch[MAX_KGDBOE_CONFIG_STR];
+
+	/* If we're being given a new configuration, copy it in. */
+	if (opt != config)
+		strcpy(config, opt);
+	/* But work on a copy as netpoll_parse_options will eat it. */
+	strcpy(opt_scratch, opt);
+	configured = !netpoll_parse_options(&np, opt_scratch);
+
+	use_dynamic_mac = 1;
+
+	return 0;
+}
+__setup("kgdboe=", option_setup);
+
+/* With our config string set by some means, configure kgdboe. */
+static int configure_kgdboe(void)
+{
+	/* Try out the string. */
+	option_setup(config);
+
+	if (!configured) {
+		printk(KERN_ERR "kgdboe: configuration incorrect - kgdboe not "
+		       "loaded.\n");
+		printk(KERN_ERR "  Usage: kgdboe=[src-port]@[src-ip]/[dev],"
+				"[tgt-port]@<tgt-ip>/<tgt-macaddr>\n");
+		return -EINVAL;
+	}
+
+	/* Bring it up. */
+	if (netpoll_setup(&np)) {
+		printk(KERN_ERR "kgdboe: netpoll_setup failed kgdboe failed\n");
+		return -EINVAL;
+	}
+
+	if (kgdb_register_io_module(&local_kgdb_io_ops)) {
+		netpoll_cleanup(&np);
+		return -EINVAL;
+	}
+
+	configured = 2;
+
+	return 0;
+}
+
+static int init_kgdboe(void)
+{
+	int ret;
+
+	/* Already done? */
+	if (configured == 2)
+		return 0;
+
+	/* OK, go ahead and do it. */
+	ret = configure_kgdboe();
+
+	if (configured == 2)
+		printk(KERN_INFO "kgdboe: debugging over ethernet enabled\n");
+
+	return ret;
+}
+
+static void cleanup_kgdboe(void)
+{
+	netpoll_cleanup(&np);
+	configured = 0;
+	kgdb_unregister_io_module(&local_kgdb_io_ops);
+}
+
+static int param_set_kgdboe_var(const char *kmessage, struct kernel_param *kp)
+{
+	char kmessage_save[MAX_KGDBOE_CONFIG_STR];
+	int msg_len = strlen(kmessage);
+
+	if (msg_len + 1 > MAX_KGDBOE_CONFIG_STR) {
+		printk(KERN_ERR "%s: string doesn't fit in %u chars.\n",
+		       kp->name, MAX_KGDBOE_CONFIG_STR - 1);
+		return -ENOSPC;
+	}
+
+	if (kgdb_connected) {
+		printk(KERN_ERR "kgdboe: Cannot reconfigure while KGDB is "
+				"connected.\n");
+		return 0;
+	}
+
+	/* Start the reconfiguration process by saving the old string */
+	strncpy(kmessage_save, config, sizeof(kmessage_save));
+
+
+	/* Copy in the new param and strip out invalid characters so we
+	 * can optionally specify the MAC.
+	 */
+	strncpy(config, kmessage, sizeof(config));
+	msg_len--;
+	while (msg_len > 0 &&
+			(config[msg_len] < ',' || config[msg_len] > 'f')) {
+		config[msg_len] = '\0';
+		msg_len--;
+	}
+
+	/* Check to see if we are unconfiguring the io module and that it
+	 * was in a fully configured state, as this is the only time that
+	 * netpoll_cleanup should get called
+	 */
+	if (configured == 2 && strcmp(config, NOT_CONFIGURED_STRING) == 0) {
+		printk(KERN_INFO "kgdboe: reverting to unconfigured state\n");
+		cleanup_kgdboe();
+		return 0;
+	} else
+		/* Go and configure with the new params. */
+		configure_kgdboe();
+
+	if (configured == 2)
+		return 0;
+
+	/* If the new string was invalid, revert to the previous state, which
+	 * is at a minimum not_configured. */
+	strncpy(config, kmessage_save, sizeof(config));
+	if (strcmp(kmessage_save, NOT_CONFIGURED_STRING) != 0) {
+		printk(KERN_INFO "kgdboe: reverting to prior configuration\n");
+		/* revert back to the original config */
+		strncpy(config, kmessage_save, sizeof(config));
+		configure_kgdboe();
+	}
+	return 0;
+}
+
+static struct kgdb_io local_kgdb_io_ops = {
+	.read_char = eth_get_char,
+	.write_char = eth_put_char,
+	.init = init_kgdboe,
+	.flush = eth_flush_buf,
+	.pre_exception = eth_pre_exception_handler,
+	.post_exception = eth_post_exception_handler
+};
+
+module_init(init_kgdboe);
+module_exit(cleanup_kgdboe);
+module_param_call(kgdboe, param_set_kgdboe_var, param_get_string, &kps, 0644);
+MODULE_PARM_DESC(kgdboe, " kgdboe=[src-port]@[src-ip]/[dev],"
+		 "[tgt-port]@<tgt-ip>/<tgt-macaddr>\n");
diff -uprN -X  linux-orig/drivers/net/Makefile linux-kgdb/drivers/net/Makefile
--- linux-orig/drivers/net/Makefile	2006-08-31 13:42:13.000000000 +0000
+++ linux-kgdb/drivers/net/Makefile	2006-09-01 08:37:39.000000000 +0000
@@ -213,6 +213,7 @@ obj-$(CONFIG_ENP2611_MSF_NET) += ixp2000
 obj-$(CONFIG_STMPHYLIB) += stmphy/
 
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
+obj-$(CONFIG_KGDBOE) += kgdboe.o
 
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
diff -uprN -X  linux-orig/drivers/net/smc91x.c linux-kgdb/drivers/net/smc91x.c
--- linux-orig/drivers/net/smc91x.c	2006-08-31 13:42:06.000000000 +0000
+++ linux-kgdb/drivers/net/smc91x.c	2006-09-11 09:46:43.409270000 +0000
@@ -89,6 +89,10 @@ static const char version[] =
 
 #include <asm/io.h>
 
+#ifdef CONFIG_KGDBOE
+#include <asm/kgdb.h>
+#endif
+
 #include "smc91x.h"
 
 #ifdef CONFIG_ISA
@@ -1295,6 +1299,9 @@ static irqreturn_t smc_interrupt(int irq
 
 	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
 
+#ifdef CONFIG_KGDBOE
+        kgdboe_regs_pointer = regs;
+#endif
 	spin_lock(&lp->lock);
 
 	/* A preamble may be used when there is a potential race
diff -uprN -X  linux-orig/drivers/serial/stasc.c linux-kgdb/drivers/serial/stasc.c
--- linux-orig/drivers/serial/stasc.c	2006-08-31 13:42:13.000000000 +0000
+++ linux-kgdb/drivers/serial/stasc.c	2006-09-06 08:18:39.438277000 +0000
@@ -27,9 +27,12 @@
 #include <asm/bitops.h>
 #include <asm/clock.h>
 
-#ifdef CONFIG_SH_KGDB
+#ifdef CONFIG_KGDB
+#include <linux/kgdb.h>
+#ifdef CONFIG_KGDB_ST_ASC
 #include <asm/kgdb.h>
 #endif
+#endif
 
 #ifdef CONFIG_SH_STANDARD_BIOS
 #include <asm/sh_bios.h>
@@ -44,6 +47,27 @@ static struct asc_port asc_ports[ASC_NPO
 static struct console serial_console;
 static struct uart_port *serial_console_port = 0;
 #endif
+#ifdef CONFIG_KGDB_ST_ASC
+/* Speed of the UART. */
+#if defined(CONFIG_KGDB_9600BAUD)
+static int kgdbasc_baud = 9600;
+#elif defined(CONFIG_KGDB_19200BAUD)
+static int kgdbasc_baud = 19200;
+#elif defined(CONFIG_KGDB_38400BAUD)
+static int kgdbasc_baud = 38400;
+#elif defined(CONFIG_KGDB_57600BAUD)
+static int kgdbasc_baud = 57600;
+#else
+static int kgdbasc_baud = 115200;
+#endif
+
+#if defined(CONFIG_KGDB_TTYS1)
+static int kgdbasc_ttyAS = 1;
+#else
+static int kgdbasc_ttyAS = 0;
+#endif
+#define KGDBPORT asc_ports[kgdbasc_ttyAS]
+#endif
 
 /*---- Forward function declarations---------------------------*/
 static int  asc_request_irq(struct uart_port *);
@@ -59,17 +83,6 @@ static void serial_console_write (struct
 static int __init serial_console_setup (struct console *, char *);
 #endif
 
-#ifdef CONFIG_SH_KGDB
-int kgdb_asc_setup(void);
-static void kgdb_put_char(struct uart_port *port, char c);
-static struct asc_port *kgdb_asc_port;
-#ifdef CONFIG_SH_KGDB_CONSOLE
-static struct console kgdb_console;
-static struct tty_driver *kgdb_console_device(struct console *, int *);
-static int __init kgdb_console_setup(struct console *, char *);
-#endif
-#endif
-
 /*---- Inline function definitions ---------------------------*/
 
 /* Some simple utility functions to enable and disable interrupts.
@@ -380,21 +393,6 @@ static struct console serial_console = {
 };
 #endif
 
-#ifdef CONFIG_SH_KGDB
-#ifdef CONFIG_SH_KGDB_CONSOLE
-/* The console structure for KGDB */
-static struct console kgdb_console= {
-	.name		= "ttyAS",
-	.device		= kgdb_console_device,
-	.write		= kgdb_console_write,
-	.setup		= kgdb_console_setup,
-	.flags		= CON_PRINTBUFFER | CON_ENABLED,
-	.index		= -1,
-	.data		= &asc_uart_driver,
-};
-#endif
-#endif
-
 /*----------------------------------------------------------------------*/
 
 /* This sections contains code to support the use of the ASC as a
@@ -612,7 +610,15 @@ static inline void asc_receive_chars(str
 				continue;
 			tty_insert_flip_char(tty, c & 0xff, flag);
 		}
-
+#if defined(CONFIG_KGDB_ST_ASC)
+                if (port->line == KGDBPORT.port.line) {
+                        if ((strncmp(tty->buf.head->char_buf_ptr,
+			     "$Hc-1#09",8) == 0)) {
+                                breakpoint();
+                                return;
+                        }
+                }
+#endif
 		if (overrun) {
 			port->icount.overrun++;
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
@@ -626,17 +632,41 @@ static inline void asc_receive_chars(str
 		tty_flip_buffer_push(tty);
 	}
 }
+/*
+ * The BRK_STATUS value has been calculated looking the status
+ * value into asc_interrupt function. When, on the system serial console,
+ * a <break> command is sent (for example "^af" using, under linux host,
+ * the minicom tool) the status is 0x57.
+ * In this case, the ASCx_STA register has: the RXBUFFFULL bit = 1
+ * (RX FIFO not empty), the Transmitter empty flag = 1, there is not
+ * a parity error and the FRAMEERROR bit is 1 (stop bit not found).
+ */
+#define BRK_STATUS 0x57
 
 static irqreturn_t asc_interrupt(int irq, void *ptr, struct pt_regs *regs)
 {
 	struct uart_port *port = ptr;
 	unsigned long status;
 
+#if defined(CONFIG_KGDB_ST_ASC)
+        /* To be Fixed: it seems that on a lot of ST40 platforms the breakpoint
+           condition is not checked without this delay. Problably this problem
+           depends of an invalid port speed configuration.
+         */
+        udelay(1000);
+#endif
+
 	status = asc_in (port, STA);
 	if (status & ASC_STA_RBF) {
 		/* Receive FIFO not empty */
 		asc_receive_chars(port, regs);
 	}
+#if defined(CONFIG_KGDB_ST_ASC)
+        if ((port->line == KGDBPORT.port.line) && (status == BRK_STATUS)){
+                validate_kregs(regs);
+                breakpoint();
+        }
+#endif
 
 	if ((status & ASC_STA_THE) && (asc_in(port, INTEN) & ASC_INTEN_THE)) {
 		/* Transmitter FIFO at least half empty */
@@ -715,7 +745,7 @@ module_exit(asc_exit);
 
 /*----------------------------------------------------------------------*/
 
-#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+#if defined(CONFIG_SH_STANDARD_BIOS)
 
 static int get_char(struct uart_port *port)
 {
@@ -772,7 +802,7 @@ put_string (struct uart_port *port, cons
 {
 	int i;
 	const unsigned char *p = buffer;
-#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+#if defined(CONFIG_SH_STANDARD_BIOS)
 	int checksum;
 	int usegdb=0;
 
@@ -782,10 +812,6 @@ put_string (struct uart_port *port, cons
 	 */
 	usegdb |= sh_bios_in_gdb_mode();
 #endif
-#ifdef CONFIG_SH_KGDB
-	usegdb |= (kgdb_in_gdb_mode && (port == &kgdb_asc_port->port));
-#endif
-
 	if (usegdb) {
 	    /*  $<packet info>#<checksum>. */
 	    do {
@@ -809,7 +835,7 @@ put_string (struct uart_port *port, cons
 		put_char(port, lowhex(checksum));
 	    } while  (get_char(port) != '+');
 	} else
-#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+#endif /* CONFIG_SH_STANDARD_BIOS */
 
 	for (i = 0; i < count; i++) {
 		if (*p == 10)
@@ -869,132 +895,129 @@ serial_console_write (struct console *co
 	put_string (serial_console_port, s, count);
 }
 
-/*----------------------------------------------------------------------*/
-/* KGDB ASC functions */
-
-#ifdef CONFIG_SH_KGDB
-/* write a char */
-static void kgdb_put_char(struct uart_port *port, char c)
+console_initcall(asc_console_init);
+/*----------------------*
+* KGDB Main Functions  *
+*--------------------- */
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_KGDB_ST_ASC)
+static int get_char_for_gdb(struct uart_port *port)
 {
-	unsigned long flags;
-	unsigned long status;
+        int c;
+        unsigned long status, flags;
 
-	local_irq_save(flags);
+        local_irq_save(flags);
 
-	do {
-		status = asc_in (port, STA);
-	} while (status & ASC_STA_TF);
+        do {
+                status = asc_in(port, STA);
+        } while (! (status & ASC_STA_RBF));
 
-	asc_out (port, TXBUF, c);
+        c = asc_in(port, RXBUF);
+        local_irq_restore(flags);
 
-	local_irq_restore(flags);
+        return c;
 }
-
-/* Called from stub to put a character */
-static void kgdb_asc_putchar(int c)
+#endif
+#ifdef CONFIG_KGDB_ST_ASC
+static int kgdbasc_read_char(void)
 {
-        kgdb_put_char(&kgdb_asc_port->port, c);
+        return get_char_for_gdb(&KGDBPORT.port);
 }
 
-/* Called from stub to get a character, i.e. is blocking */
-static int kgdb_asc_getchar(void)
+/* Called from kgdbstub.c to put a character, just a wrapper */
+static void kgdbasc_write_char(u8 c)
 {
-	return get_char(&kgdb_asc_port->port);
+        put_char(&KGDBPORT.port, c);
 }
 
-/* Initialise the KGDB serial port.
-   Called from stub to setup the debug port
-*/
-int kgdb_asc_setup(void)
+static irqreturn_t kgdbasc_interrupt(int irq, void *ptr, struct pt_regs *regs)
 {
-	int cflag = CREAD | HUPCL | CLOCAL | CSTOPB;
+        /*
+        * If  there is some other CPU in KGDB then this is a
+        * spurious interrupt. so return without even checking a byte
+        */
+        if (atomic_read(&debugger_active))
+                return IRQ_NONE;
 
-	if ((kgdb_portnum < 0) || (kgdb_portnum >= ASC_NPORTS))
-	{
-		printk (KERN_ERR "%s invalid ASC port number\n", __FUNCTION__);
-		return -1;
-	}
-
-        kgdb_asc_port = &asc_ports[kgdb_portnum];
-
-	switch (kgdb_baud) {
-        case 115200:
-                cflag |= B115200;
-                break;
-	case 57600:
-                cflag |= B57600;
-                break;
-        case 38400:
-                cflag |= B38400;
-                break;
-        case 19200:
-                cflag |= B19200;
-                break;
-	case 9600:
-		cflag = B9600;
-		break;
-        default:
-                cflag |= B115200;
-                kgdb_baud = 115200;
-		printk (KERN_WARNING "%s: force the kgdb baud as %d\n",
-				      __FUNCTION__, kgdb_baud);
-                break;
+        validate_kregs(regs);
+        breakpoint();
+        return IRQ_HANDLED;
+}
+static void __init kgdbasc_lateinit(void)
+{
+        if ( serial_console_port->line != KGDBPORT.port.line) {
+                if (request_irq(KGDBPORT.port.irq, kgdbasc_interrupt,
+                        SA_INTERRUPT, "asc", &KGDBPORT.port)) {
+                        printk(KERN_ERR "kgdb asc: cannot allocate irq.\n");
+                        return;
+                }
+                asc_enable_rx_interrupts(&KGDBPORT.port);
         }
+        return;
+}
+/*
+* We use the normal init routine to setup the port, so we can't be
+* in here too early.
+*/
+static int kgdbasc_init(void)
+{
+        struct termios termios;
 
-	switch (kgdb_bits) {
-        case '7':
-                cflag |= CS7;
-                break;
-        default:
-        case '8':
-                cflag |= CS8;
-                break;
-        }
+        memset(&termios, 0, sizeof(struct termios));
 
-        switch (kgdb_parity) {
-        case 'O':
-                cflag |= PARODD;
-                break;
-        case 'E':
-                cflag |= PARENB;
-                break;
+        termios.c_cflag = CREAD | HUPCL | CLOCAL | CS8;
+        switch (kgdbasc_baud) {
+                case 9600:
+                        termios.c_cflag |= B9600;
+                        break;
+                case 19200:
+                        termios.c_cflag |= B19200;
+                        break;
+                case 38400:
+                        termios.c_cflag |= B38400;
+                        break;
+                case 57600:
+                        termios.c_cflag |= B57600;
+                        break;
+                case 115200:
+                        termios.c_cflag |= B115200;
+                        break;
         }
-        kgdb_cflag = cflag;
-        asc_set_termios_cflag(kgdb_asc_port, kgdb_cflag, kgdb_baud);
-
-	/* Setup complete: initialize function pointers */
-	kgdb_getchar = kgdb_asc_getchar;
-	kgdb_putchar = kgdb_asc_putchar;
-
+        asc_set_termios_cflag(&KGDBPORT, termios.c_cflag, kgdbasc_baud);
         return 0;
 }
+struct kgdb_io kgdb_io_ops = {
+        .read_char = kgdbasc_read_char,
+        .write_char = kgdbasc_write_char,
+        .init = kgdbasc_init,
+        .late_init = kgdbasc_lateinit,
+};
 
-#ifdef CONFIG_SH_KGDB_CONSOLE
-/* Create a console device */
-static struct tty_driver *kgdb_console_device(struct console *co, int *index)
+/*
+* Syntax for this cmdline option is "kgdbasc=ttyno,baudrate".
+*/
+static int __init
+kgdbasc_opt(char *str)
 {
-	struct uart_driver *p = co->data;
-	*index = co->index;
-	return p->tty_driver;
-}
+        /* We might have anywhere from 1 to 3 ports. */
+        if (*str < '0' || *str > ASC_NPORTS + '0')
+                goto errout;
+        kgdbasc_ttyAS = *str - '0';
+        str++;
+        if (*str != ',')
+                goto errout;
+        str++;
+        kgdbasc_baud = simple_strtoul(str, &str, 10);
+        if (kgdbasc_baud != 9600 && kgdbasc_baud != 19200 &&
+                kgdbasc_baud != 38400 && kgdbasc_baud != 57600 &&
+                kgdbasc_baud != 115200)
+                        goto errout;
 
-/* Set up the KGDB console */
-static int __init kgdb_console_setup(struct console *co, char *options)
-{
-        /* NB we ignore 'options' because we've already done the setup */
-        co->cflag = kgdb_cflag;
         return 0;
-}
 
-#ifdef CONFIG_KGDB_DEFTYPE_ASC
-/* Register the KGDB console so we get messages (d'oh!) */
-int __init kgdb_console_init(void)
-{
-        register_console(&kgdb_console);
-	return 0;
+errout:
+        printk(KERN_ERR "Invalid syntax for option kgdbasc=\n");
+        return 1;
 }
-console_initcall(kgdb_console_init);
-#endif
-#endif /* CONFIG_SH_KGDB_CONSOLE */
-#endif /* CONFIG_SH_KGDB */
-console_initcall(asc_console_init);
+early_param("kgdbasc", kgdbasc_opt);
+#endif /* CONFIG_KGDB_ST_ASC */
+
diff -uprN -X  linux-orig/include/asm-sh/kgdb.h linux-kgdb/include/asm-sh/kgdb.h
--- linux-orig/include/asm-sh/kgdb.h	2006-08-31 13:42:11.000000000 +0000
+++ linux-kgdb/include/asm-sh/kgdb.h	2006-09-28 14:39:04.012716000 +0000
@@ -2,94 +2,39 @@
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
- * Based on original code by Glenn Engel, Jim Kingdon,
- * David Grothe <dave@gcom.com>, Tigran Aivazian, <tigran@sco.com> and
- * Amit S. Kale <akale@veritas.com>
- * 
- * Super-H port based on sh-stub.c (Ben Lee and Steve Chamberlain) by
- * Henry Bell <henry.bell@st.com>
- * 
- * Header file for low-level support for remote debug using GDB. 
+ * Based on a file that was modified or based on files by: Glenn Engel,
+ * Jim Kingdon, David Grothe <dave@gcom.com>, Tigran Aivazian <tigran@sco.com>,
+ * Amit S. Kale <akale@veritas.com>, sh-stub.c from Ben Lee and
+ * Steve Chamberlain, Henry Bell <henry.bell@st.com>
+ *
+ * Maintainer: Tom Rini <trini@kernel.crashing.org>
  *
  */
 
 #ifndef __KGDB_H
 #define __KGDB_H
 
-#include <asm/ptrace.h>
-
-struct console;
+/* Based on sh-gdb.c from gdb-6.1, Glenn
+     Engel at HP  Ben Lee and Steve Chamberlain */
+#define NUMREGBYTES	112	/* 92 */
+#define NUMCRITREGBYTES (9 << 2)
+#define BUFMAX		400
 
-/* Same as pt_regs but has vbr in place of syscall_nr */
+#ifndef __ASSEMBLY__
 struct kgdb_regs {
         unsigned long regs[16];
         unsigned long pc;
         unsigned long pr;
-        unsigned long sr;
         unsigned long gbr;
+        unsigned long vbr;
         unsigned long mach;
         unsigned long macl;
-        unsigned long vbr;
-};
-
-/* State info */
-extern char kgdb_in_gdb_mode;
-extern int kgdb_done_init;
-extern int kgdb_enabled;
-extern int kgdb_nofault;	/* Ignore bus errors (in gdb mem access) */
-extern int kgdb_halt;		/* Execute initial breakpoint at startup */
-extern char in_nmi;		/* Debounce flag to prevent NMI reentry*/
-
-/* SCI */
-extern int kgdb_portnum;
-extern int kgdb_baud;
-extern char kgdb_parity;
-extern char kgdb_bits;
-extern int kgdb_console_setup(struct console *, char *);
-
-/* Init and interface stuff */
-extern int kgdb_init(void);
-extern int (*kgdb_serial_setup)(void);
-extern int (*kgdb_getchar)(void);
-extern void (*kgdb_putchar)(int);
-
-struct kgdb_sermap {
-	char *name;
-	int namelen;
-	int (*setup_fn)(struct console *, char *);
-	struct kgdb_sermap *next;
+        unsigned long sr;
 };
-extern void kgdb_register_sermap(struct kgdb_sermap *map);
-extern struct kgdb_sermap *kgdb_porttype;
 
-/* Trap functions */
-typedef void (kgdb_debug_hook_t)(struct pt_regs *regs); 
-typedef void (kgdb_bus_error_hook_t)(void);
-extern kgdb_debug_hook_t  *kgdb_debug_hook;
-extern kgdb_bus_error_hook_t *kgdb_bus_err_hook;
-
-extern void breakpoint(void);
-
-/* Console */
-struct console;
-void kgdb_console_write(struct console *co, const char *s, unsigned count);
-void kgdb_console_init(void);
-
-/* Prototypes for jmp fns */
-#define _JBLEN 9
-typedef        int jmp_buf[_JBLEN];
-extern void    longjmp(jmp_buf __jmpb, int __retval);
-extern int     setjmp(jmp_buf __jmpb);
-
-/* Variadic macro to print our own message to the console */
-#define KGDB_PRINTK(...) printk("KGDB: " __VA_ARGS__)
-
-/* Forced breakpoint */
-#define BREAKPOINT() do {                                     \
-  if (kgdb_enabled) {                                         \
-    asm volatile("trapa   #0xff");                            \
-  }                                                           \
-} while (0)
+#define BREAKPOINT()		asm("trapa #0xff");
+#define BREAK_INSTR_SIZE	2
+#define CACHE_FLUSH_IS_SAFE	1
 
 /* KGDB should be able to flush all kernel text space */
 #if defined(CONFIG_CPU_SH4)
@@ -102,45 +47,25 @@ extern int     setjmp(jmp_buf __jmpb);
 #else
 #define kgdb_flush_icache_range(start, end)	do { } while (0)
 #endif
+#endif				/* !__ASSEMBLY__ */
+extern struct pt_regs *kgdb_regs_valid;
 
-/* Kernel assert macros */
-#ifdef CONFIG_KGDB_KERNEL_ASSERTS
-
-/* Predefined conditions */
-#define KA_VALID_ERRNO(errno) ((errno) > 0 && (errno) <= EMEDIUMTYPE)
-#define KA_VALID_PTR_ERR(ptr) KA_VALID_ERRNO(-PTR_ERR(ptr))
-#define KA_VALID_KPTR(ptr)  (!(ptr) || \
-              ((void *)(ptr) >= (void *)PAGE_OFFSET &&  \
-               (void *)(ptr) < ERR_PTR(-EMEDIUMTYPE)))
-#define KA_VALID_PTRORERR(errptr) \
-               (KA_VALID_KPTR(errptr) || KA_VALID_PTR_ERR(errptr))
-#define KA_HELD_GKL()  (current->lock_depth >= 0)
-
-/* The actual assert */
-#define KGDB_ASSERT(condition, message) do {                   \
-       if (!(condition) && (kgdb_enabled)) {                   \
-               KGDB_PRINTK("Assertion failed at %s:%d: %s\n",  \
-                                  __FILE__, __LINE__, message);\
-               BREAKPOINT();                                   \
-       }                                                       \
-} while (0)
-#else
-#define KGDB_ASSERT(condition, message)
-#endif
-
-/* Taken from sh-stub.c of GDB 4.18 */
-static const char hexchars[] = "0123456789abcdef";
-
-/* Get high hex bits */
-static inline char highhex(const int x)
+static inline void validate_kregs(struct pt_regs *regs)
 {
-	return hexchars[(x >> 4) & 0xf];
+	if (regs != NULL)
+		kgdb_regs_valid = regs;
+	else
+		kgdb_regs_valid = NULL;
+	return;
 }
 
-/* Get low hex bits */
-static inline char lowhex(const int x)
-{
-	return hexchars[x & 0xf];
-}
+#ifdef CONFIG_KGDBOE
+extern struct pt_regs *kgdboe_regs_pointer;
+#endif
+
+/* In order to guarantee the early KGDB initialization
+   for the STM platforms, we need to anticipate the board 
+   clock setting. */
+extern unsigned int kgdb_hwclk_flag;
 
 #endif
diff -uprN -X  linux-orig/include/linux/dwarf2-defs.h linux-kgdb/include/linux/dwarf2-defs.h
--- linux-orig/include/linux/dwarf2-defs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/include/linux/dwarf2-defs.h	2006-09-07 08:32:33.805021000 +0000
@@ -0,0 +1,515 @@
+#ifndef  _ELF_DWARF_H
+/* Machine generated from dwarf2.h by scripts/dwarfh.awk */
+#define _ELF_DWARF2_H
+#define DW_TAG_padding	 0x00
+#define DW_TAG_array_type	 0x01
+#define DW_TAG_class_type	 0x02
+#define DW_TAG_entry_point	 0x03
+#define DW_TAG_enumeration_type	 0x04
+#define DW_TAG_formal_parameter	 0x05
+#define DW_TAG_imported_declaration	 0x08
+#define DW_TAG_label	 0x0a
+#define DW_TAG_lexical_block	 0x0b
+#define DW_TAG_member	 0x0d
+#define DW_TAG_pointer_type	 0x0f
+#define DW_TAG_reference_type	 0x10
+#define DW_TAG_compile_unit	 0x11
+#define DW_TAG_string_type	 0x12
+#define DW_TAG_structure_type	 0x13
+#define DW_TAG_subroutine_type	 0x15
+#define DW_TAG_typedef	 0x16
+#define DW_TAG_union_type	 0x17
+#define DW_TAG_unspecified_parameters	 0x18
+#define DW_TAG_variant	 0x19
+#define DW_TAG_common_block	 0x1a
+#define DW_TAG_common_inclusion	 0x1b
+#define DW_TAG_inheritance	 0x1c
+#define DW_TAG_inlined_subroutine	 0x1d
+#define DW_TAG_module	 0x1e
+#define DW_TAG_ptr_to_member_type	 0x1f
+#define DW_TAG_set_type	 0x20
+#define DW_TAG_subrange_type	 0x21
+#define DW_TAG_with_stmt	 0x22
+#define DW_TAG_access_declaration	 0x23
+#define DW_TAG_base_type	 0x24
+#define DW_TAG_catch_block	 0x25
+#define DW_TAG_const_type	 0x26
+#define DW_TAG_constant	 0x27
+#define DW_TAG_enumerator	 0x28
+#define DW_TAG_file_type	 0x29
+#define DW_TAG_friend	 0x2a
+#define DW_TAG_namelist	 0x2b
+#define DW_TAG_namelist_item	 0x2c
+#define DW_TAG_packed_type	 0x2d
+#define DW_TAG_subprogram	 0x2e
+#define DW_TAG_template_type_param	 0x2f
+#define DW_TAG_template_value_param	 0x30
+#define DW_TAG_thrown_type	 0x31
+#define DW_TAG_try_block	 0x32
+#define DW_TAG_variant_part	 0x33
+#define DW_TAG_variable	 0x34
+#define DW_TAG_volatile_type	 0x35
+#define DW_TAG_dwarf_procedure	 0x36
+#define DW_TAG_restrict_type	 0x37
+#define DW_TAG_interface_type	 0x38
+#define DW_TAG_namespace	 0x39
+#define DW_TAG_imported_module	 0x3a
+#define DW_TAG_unspecified_type	 0x3b
+#define DW_TAG_partial_unit	 0x3c
+#define DW_TAG_imported_unit	 0x3d
+#define DW_TAG_MIPS_loop	 0x4081
+#define DW_TAG_HP_array_descriptor	 0x4090
+#define DW_TAG_format_label	 0x4101
+#define DW_TAG_function_template	 0x4102
+#define DW_TAG_class_template	 0x4103
+#define DW_TAG_GNU_BINCL	 0x4104
+#define DW_TAG_GNU_EINCL	 0x4105
+#define DW_TAG_upc_shared_type	 0x8765
+#define DW_TAG_upc_strict_type	 0x8766
+#define DW_TAG_upc_relaxed_type	 0x8767
+#define DW_TAG_PGI_kanji_type	 0xA000
+#define DW_TAG_PGI_interface_block	 0xA020
+#define DW_TAG_lo_user	0x4080
+#define DW_TAG_hi_user	0xffff
+#define DW_children_no   0
+#define	DW_children_yes  1
+#define DW_FORM_addr	 0x01
+#define DW_FORM_block2	 0x03
+#define DW_FORM_block4	 0x04
+#define DW_FORM_data2	 0x05
+#define DW_FORM_data4	 0x06
+#define DW_FORM_data8	 0x07
+#define DW_FORM_string	 0x08
+#define DW_FORM_block	 0x09
+#define DW_FORM_block1	 0x0a
+#define DW_FORM_data1	 0x0b
+#define DW_FORM_flag	 0x0c
+#define DW_FORM_sdata	 0x0d
+#define DW_FORM_strp	 0x0e
+#define DW_FORM_udata	 0x0f
+#define DW_FORM_ref_addr	 0x10
+#define DW_FORM_ref1	 0x11
+#define DW_FORM_ref2	 0x12
+#define DW_FORM_ref4	 0x13
+#define DW_FORM_ref8	 0x14
+#define DW_FORM_ref_udata	 0x15
+#define DW_FORM_indirect	 0x16
+#define DW_AT_sibling	 0x01
+#define DW_AT_location	 0x02
+#define DW_AT_name	 0x03
+#define DW_AT_ordering	 0x09
+#define DW_AT_subscr_data	 0x0a
+#define DW_AT_byte_size	 0x0b
+#define DW_AT_bit_offset	 0x0c
+#define DW_AT_bit_size	 0x0d
+#define DW_AT_element_list	 0x0f
+#define DW_AT_stmt_list	 0x10
+#define DW_AT_low_pc	 0x11
+#define DW_AT_high_pc	 0x12
+#define DW_AT_language	 0x13
+#define DW_AT_member	 0x14
+#define DW_AT_discr	 0x15
+#define DW_AT_discr_value	 0x16
+#define DW_AT_visibility	 0x17
+#define DW_AT_import	 0x18
+#define DW_AT_string_length	 0x19
+#define DW_AT_common_reference	 0x1a
+#define DW_AT_comp_dir	 0x1b
+#define DW_AT_const_value	 0x1c
+#define DW_AT_containing_type	 0x1d
+#define DW_AT_default_value	 0x1e
+#define DW_AT_inline	 0x20
+#define DW_AT_is_optional	 0x21
+#define DW_AT_lower_bound	 0x22
+#define DW_AT_producer	 0x25
+#define DW_AT_prototyped	 0x27
+#define DW_AT_return_addr	 0x2a
+#define DW_AT_start_scope	 0x2c
+#define DW_AT_stride_size	 0x2e
+#define DW_AT_upper_bound	 0x2f
+#define DW_AT_abstract_origin	 0x31
+#define DW_AT_accessibility	 0x32
+#define DW_AT_address_class	 0x33
+#define DW_AT_artificial	 0x34
+#define DW_AT_base_types	 0x35
+#define DW_AT_calling_convention	 0x36
+#define DW_AT_count	 0x37
+#define DW_AT_data_member_location	 0x38
+#define DW_AT_decl_column	 0x39
+#define DW_AT_decl_file	 0x3a
+#define DW_AT_decl_line	 0x3b
+#define DW_AT_declaration	 0x3c
+#define DW_AT_discr_list	 0x3d
+#define DW_AT_encoding	 0x3e
+#define DW_AT_external	 0x3f
+#define DW_AT_frame_base	 0x40
+#define DW_AT_friend	 0x41
+#define DW_AT_identifier_case	 0x42
+#define DW_AT_macro_info	 0x43
+#define DW_AT_namelist_items	 0x44
+#define DW_AT_priority	 0x45
+#define DW_AT_segment	 0x46
+#define DW_AT_specification	 0x47
+#define DW_AT_static_link	 0x48
+#define DW_AT_type	 0x49
+#define DW_AT_use_location	 0x4a
+#define DW_AT_variable_parameter	 0x4b
+#define DW_AT_virtuality	 0x4c
+#define DW_AT_vtable_elem_location	 0x4d
+#define DW_AT_allocated	 0x4e
+#define DW_AT_associated	 0x4f
+#define DW_AT_data_location	 0x50
+#define DW_AT_stride	 0x51
+#define DW_AT_entry_pc	 0x52
+#define DW_AT_use_UTF8	 0x53
+#define DW_AT_extension	 0x54
+#define DW_AT_ranges	 0x55
+#define DW_AT_trampoline	 0x56
+#define DW_AT_call_column	 0x57
+#define DW_AT_call_file	 0x58
+#define DW_AT_call_line	 0x59
+#define DW_AT_MIPS_fde	 0x2001
+#define DW_AT_MIPS_loop_begin	 0x2002
+#define DW_AT_MIPS_tail_loop_begin	 0x2003
+#define DW_AT_MIPS_epilog_begin	 0x2004
+#define DW_AT_MIPS_loop_unroll_factor	 0x2005
+#define DW_AT_MIPS_software_pipeline_depth	 0x2006
+#define DW_AT_MIPS_linkage_name	 0x2007
+#define DW_AT_MIPS_stride	 0x2008
+#define DW_AT_MIPS_abstract_name	 0x2009
+#define DW_AT_MIPS_clone_origin	 0x200a
+#define DW_AT_MIPS_has_inlines	 0x200b
+#define DW_AT_HP_block_index	 0x2000
+#define DW_AT_HP_unmodifiable	 0x2001
+#define DW_AT_HP_actuals_stmt_list	 0x2010
+#define DW_AT_HP_proc_per_section	 0x2011
+#define DW_AT_HP_raw_data_ptr	 0x2012
+#define DW_AT_HP_pass_by_reference	 0x2013
+#define DW_AT_HP_opt_level	 0x2014
+#define DW_AT_HP_prof_version_id	 0x2015
+#define DW_AT_HP_opt_flags	 0x2016
+#define DW_AT_HP_cold_region_low_pc	 0x2017
+#define DW_AT_HP_cold_region_high_pc	 0x2018
+#define DW_AT_HP_all_variables_modifiable	 0x2019
+#define DW_AT_HP_linkage_name	 0x201a
+#define DW_AT_HP_prof_flags	 0x201b
+#define DW_AT_sf_names	 0x2101
+#define DW_AT_src_info	 0x2102
+#define DW_AT_mac_info	 0x2103
+#define DW_AT_src_coords	 0x2104
+#define DW_AT_body_begin	 0x2105
+#define DW_AT_body_end	 0x2106
+#define DW_AT_GNU_vector	 0x2107
+#define DW_AT_VMS_rtnbeg_pd_address	 0x2201
+#define DW_AT_upc_threads_scaled	 0x3210
+#define DW_AT_PGI_lbase	 0x3a00
+#define DW_AT_PGI_soffset	 0x3a01
+#define DW_AT_PGI_lstride	 0x3a02
+#define DW_AT_lo_user	0x2000	/* Implementation-defined range start.  */
+#define DW_AT_hi_user	0x3ff0	/* Implementation-defined range end.  */
+#define DW_OP_addr	 0x03
+#define DW_OP_deref	 0x06
+#define DW_OP_const1u	 0x08
+#define DW_OP_const1s	 0x09
+#define DW_OP_const2u	 0x0a
+#define DW_OP_const2s	 0x0b
+#define DW_OP_const4u	 0x0c
+#define DW_OP_const4s	 0x0d
+#define DW_OP_const8u	 0x0e
+#define DW_OP_const8s	 0x0f
+#define DW_OP_constu	 0x10
+#define DW_OP_consts	 0x11
+#define DW_OP_dup	 0x12
+#define DW_OP_drop	 0x13
+#define DW_OP_over	 0x14
+#define DW_OP_pick	 0x15
+#define DW_OP_swap	 0x16
+#define DW_OP_rot	 0x17
+#define DW_OP_xderef	 0x18
+#define DW_OP_abs	 0x19
+#define DW_OP_and	 0x1a
+#define DW_OP_div	 0x1b
+#define DW_OP_minus	 0x1c
+#define DW_OP_mod	 0x1d
+#define DW_OP_mul	 0x1e
+#define DW_OP_neg	 0x1f
+#define DW_OP_not	 0x20
+#define DW_OP_or	 0x21
+#define DW_OP_plus	 0x22
+#define DW_OP_plus_uconst	 0x23
+#define DW_OP_shl	 0x24
+#define DW_OP_shr	 0x25
+#define DW_OP_shra	 0x26
+#define DW_OP_xor	 0x27
+#define DW_OP_bra	 0x28
+#define DW_OP_eq	 0x29
+#define DW_OP_ge	 0x2a
+#define DW_OP_gt	 0x2b
+#define DW_OP_le	 0x2c
+#define DW_OP_lt	 0x2d
+#define DW_OP_ne	 0x2e
+#define DW_OP_skip	 0x2f
+#define DW_OP_lit0	 0x30
+#define DW_OP_lit1	 0x31
+#define DW_OP_lit2	 0x32
+#define DW_OP_lit3	 0x33
+#define DW_OP_lit4	 0x34
+#define DW_OP_lit5	 0x35
+#define DW_OP_lit6	 0x36
+#define DW_OP_lit7	 0x37
+#define DW_OP_lit8	 0x38
+#define DW_OP_lit9	 0x39
+#define DW_OP_lit10	 0x3a
+#define DW_OP_lit11	 0x3b
+#define DW_OP_lit12	 0x3c
+#define DW_OP_lit13	 0x3d
+#define DW_OP_lit14	 0x3e
+#define DW_OP_lit15	 0x3f
+#define DW_OP_lit16	 0x40
+#define DW_OP_lit17	 0x41
+#define DW_OP_lit18	 0x42
+#define DW_OP_lit19	 0x43
+#define DW_OP_lit20	 0x44
+#define DW_OP_lit21	 0x45
+#define DW_OP_lit22	 0x46
+#define DW_OP_lit23	 0x47
+#define DW_OP_lit24	 0x48
+#define DW_OP_lit25	 0x49
+#define DW_OP_lit26	 0x4a
+#define DW_OP_lit27	 0x4b
+#define DW_OP_lit28	 0x4c
+#define DW_OP_lit29	 0x4d
+#define DW_OP_lit30	 0x4e
+#define DW_OP_lit31	 0x4f
+#define DW_OP_reg0	 0x50
+#define DW_OP_reg1	 0x51
+#define DW_OP_reg2	 0x52
+#define DW_OP_reg3	 0x53
+#define DW_OP_reg4	 0x54
+#define DW_OP_reg5	 0x55
+#define DW_OP_reg6	 0x56
+#define DW_OP_reg7	 0x57
+#define DW_OP_reg8	 0x58
+#define DW_OP_reg9	 0x59
+#define DW_OP_reg10	 0x5a
+#define DW_OP_reg11	 0x5b
+#define DW_OP_reg12	 0x5c
+#define DW_OP_reg13	 0x5d
+#define DW_OP_reg14	 0x5e
+#define DW_OP_reg15	 0x5f
+#define DW_OP_reg16	 0x60
+#define DW_OP_reg17	 0x61
+#define DW_OP_reg18	 0x62
+#define DW_OP_reg19	 0x63
+#define DW_OP_reg20	 0x64
+#define DW_OP_reg21	 0x65
+#define DW_OP_reg22	 0x66
+#define DW_OP_reg23	 0x67
+#define DW_OP_reg24	 0x68
+#define DW_OP_reg25	 0x69
+#define DW_OP_reg26	 0x6a
+#define DW_OP_reg27	 0x6b
+#define DW_OP_reg28	 0x6c
+#define DW_OP_reg29	 0x6d
+#define DW_OP_reg30	 0x6e
+#define DW_OP_reg31	 0x6f
+#define DW_OP_breg0	 0x70
+#define DW_OP_breg1	 0x71
+#define DW_OP_breg2	 0x72
+#define DW_OP_breg3	 0x73
+#define DW_OP_breg4	 0x74
+#define DW_OP_breg5	 0x75
+#define DW_OP_breg6	 0x76
+#define DW_OP_breg7	 0x77
+#define DW_OP_breg8	 0x78
+#define DW_OP_breg9	 0x79
+#define DW_OP_breg10	 0x7a
+#define DW_OP_breg11	 0x7b
+#define DW_OP_breg12	 0x7c
+#define DW_OP_breg13	 0x7d
+#define DW_OP_breg14	 0x7e
+#define DW_OP_breg15	 0x7f
+#define DW_OP_breg16	 0x80
+#define DW_OP_breg17	 0x81
+#define DW_OP_breg18	 0x82
+#define DW_OP_breg19	 0x83
+#define DW_OP_breg20	 0x84
+#define DW_OP_breg21	 0x85
+#define DW_OP_breg22	 0x86
+#define DW_OP_breg23	 0x87
+#define DW_OP_breg24	 0x88
+#define DW_OP_breg25	 0x89
+#define DW_OP_breg26	 0x8a
+#define DW_OP_breg27	 0x8b
+#define DW_OP_breg28	 0x8c
+#define DW_OP_breg29	 0x8d
+#define DW_OP_breg30	 0x8e
+#define DW_OP_breg31	 0x8f
+#define DW_OP_regx	 0x90
+#define DW_OP_fbreg	 0x91
+#define DW_OP_bregx	 0x92
+#define DW_OP_piece	 0x93
+#define DW_OP_deref_size	 0x94
+#define DW_OP_xderef_size	 0x95
+#define DW_OP_nop	 0x96
+#define DW_OP_push_object_address	 0x97
+#define DW_OP_call2	 0x98
+#define DW_OP_call4	 0x99
+#define DW_OP_call_ref	 0x9a
+#define DW_OP_GNU_push_tls_address	 0xe0
+#define DW_OP_HP_unknown	 0xe0
+#define DW_OP_HP_is_value	 0xe1
+#define DW_OP_HP_fltconst4	 0xe2
+#define DW_OP_HP_fltconst8	 0xe3
+#define DW_OP_HP_mod_range	 0xe4
+#define DW_OP_HP_unmod_range	 0xe5
+#define DW_OP_HP_tls	 0xe6
+#define DW_OP_lo_user	0xe0	/* Implementation-defined range start.  */
+#define DW_OP_hi_user	0xff	/* Implementation-defined range end.  */
+#define DW_ATE_void	 0x0
+#define DW_ATE_address	 0x1
+#define DW_ATE_boolean	 0x2
+#define DW_ATE_complex_float	 0x3
+#define DW_ATE_float	 0x4
+#define DW_ATE_signed	 0x5
+#define DW_ATE_signed_char	 0x6
+#define DW_ATE_unsigned	 0x7
+#define DW_ATE_unsigned_char	 0x8
+#define DW_ATE_imaginary_float	 0x9
+#define DW_ATE_HP_float80	 0x80
+#define DW_ATE_HP_complex_float80	 0x81
+#define DW_ATE_HP_float128	 0x82
+#define DW_ATE_HP_complex_float128	 0x83
+#define DW_ATE_HP_floathpintel	 0x84
+#define DW_ATE_HP_imaginary_float80	 0x85
+#define DW_ATE_HP_imaginary_float128	 0x86
+#define	DW_ATE_lo_user 0x80
+#define	DW_ATE_hi_user 0xff
+#define DW_ORD_row_major	 0
+#define DW_ORD_col_major	 1
+#define DW_ACCESS_public	 1
+#define DW_ACCESS_protected	 2
+#define DW_ACCESS_private	 3
+#define DW_VIS_local	 1
+#define DW_VIS_exported	 2
+#define DW_VIS_qualified	 3
+#define DW_VIRTUALITY_none	 0
+#define DW_VIRTUALITY_virtual	 1
+#define DW_VIRTUALITY_pure_virtual	 2
+#define DW_ID_case_sensitive	 0
+#define DW_ID_up_case	 1
+#define DW_ID_down_case	 2
+#define DW_ID_case_insensitive	 3
+#define DW_CC_normal	 0x1
+#define DW_CC_program	 0x2
+#define DW_CC_nocall	 0x3
+#define DW_CC_lo_user 0x40
+#define DW_CC_hi_user 0xff
+#define DW_INL_not_inlined	 0
+#define DW_INL_inlined	 1
+#define DW_INL_declared_not_inlined	 2
+#define DW_INL_declared_inlined	 3
+#define DW_DSC_label	 0
+#define DW_DSC_range	 1
+#define DW_LNS_extended_op	 0
+#define DW_LNS_copy	 1
+#define DW_LNS_advance_pc	 2
+#define DW_LNS_advance_line	 3
+#define DW_LNS_set_file	 4
+#define DW_LNS_set_column	 5
+#define DW_LNS_negate_stmt	 6
+#define DW_LNS_set_basic_block	 7
+#define DW_LNS_const_add_pc	 8
+#define DW_LNS_fixed_advance_pc	 9
+#define DW_LNS_set_prologue_end	 10
+#define DW_LNS_set_epilogue_begin	 11
+#define DW_LNS_set_isa	 12
+#define DW_LNE_end_sequence	 1
+#define DW_LNE_set_address	 2
+#define DW_LNE_define_file	 3
+#define DW_LNE_HP_negate_is_UV_update	 0x11
+#define DW_LNE_HP_push_context	 0x12
+#define DW_LNE_HP_pop_context	 0x13
+#define DW_LNE_HP_set_file_line_column	 0x14
+#define DW_LNE_HP_set_routine_name	 0x15
+#define DW_LNE_HP_set_sequence	 0x16
+#define DW_LNE_HP_negate_post_semantics	 0x17
+#define DW_LNE_HP_negate_function_exit	 0x18
+#define DW_LNE_HP_negate_front_end_logical	 0x19
+#define DW_LNE_HP_define_proc	 0x20
+#define DW_CFA_advance_loc	 0x40
+#define DW_CFA_offset	 0x80
+#define DW_CFA_restore	 0xc0
+#define DW_CFA_nop	 0x00
+#define DW_CFA_set_loc	 0x01
+#define DW_CFA_advance_loc1	 0x02
+#define DW_CFA_advance_loc2	 0x03
+#define DW_CFA_advance_loc4	 0x04
+#define DW_CFA_offset_extended	 0x05
+#define DW_CFA_restore_extended	 0x06
+#define DW_CFA_undefined	 0x07
+#define DW_CFA_same_value	 0x08
+#define DW_CFA_register	 0x09
+#define DW_CFA_remember_state	 0x0a
+#define DW_CFA_restore_state	 0x0b
+#define DW_CFA_def_cfa	 0x0c
+#define DW_CFA_def_cfa_register	 0x0d
+#define DW_CFA_def_cfa_offset	 0x0e
+#define DW_CFA_def_cfa_expression	 0x0f
+#define DW_CFA_expression	 0x10
+#define DW_CFA_offset_extended_sf	 0x11
+#define DW_CFA_def_cfa_sf	 0x12
+#define DW_CFA_def_cfa_offset_sf	 0x13
+#define DW_CFA_MIPS_advance_loc8	 0x1d
+#define DW_CFA_GNU_window_save	 0x2d
+#define DW_CFA_GNU_args_size	 0x2e
+#define DW_CFA_GNU_negative_offset_extended	 0x2f
+#define DW_CIE_ID	  0xffffffff
+#define DW_CIE_VERSION	  1
+#define DW_CFA_extended   0
+#define DW_CFA_lo_user    0x1c
+#define DW_CFA_hi_user    0x3f
+#define DW_CHILDREN_no		     0x00
+#define DW_CHILDREN_yes		     0x01
+#define DW_ADDR_none		0
+#define DW_LANG_C89	 0x0001
+#define DW_LANG_C	 0x0002
+#define DW_LANG_Ada83	 0x0003
+#define DW_LANG_C_plus_plus	 0x0004
+#define DW_LANG_Cobol74	 0x0005
+#define DW_LANG_Cobol85	 0x0006
+#define DW_LANG_Fortran77	 0x0007
+#define DW_LANG_Fortran90	 0x0008
+#define DW_LANG_Pascal83	 0x0009
+#define DW_LANG_Modula2	 0x000a
+#define DW_LANG_Java	 0x000b
+#define DW_LANG_C99	 0x000c
+#define DW_LANG_Ada95	 0x000d
+#define DW_LANG_Fortran95	 0x000e
+#define DW_LANG_Mips_Assembler	 0x8001
+#define DW_LANG_Upc	 0x8765
+#define DW_LANG_lo_user 0x8000	/* Implementation-defined range start.  */
+#define DW_LANG_hi_user 0xffff	/* Implementation-defined range start.  */
+#define DW_MACINFO_define	 1
+#define DW_MACINFO_undef	 2
+#define DW_MACINFO_start_file	 3
+#define DW_MACINFO_end_file	 4
+#define DW_MACINFO_vendor_ext	 255
+#define DW_EH_PE_absptr		0x00
+#define DW_EH_PE_omit		0xff
+#define DW_EH_PE_uleb128	0x01
+#define DW_EH_PE_udata2		0x02
+#define DW_EH_PE_udata4		0x03
+#define DW_EH_PE_udata8		0x04
+#define DW_EH_PE_sleb128	0x09
+#define DW_EH_PE_sdata2		0x0A
+#define DW_EH_PE_sdata4		0x0B
+#define DW_EH_PE_sdata8		0x0C
+#define DW_EH_PE_signed		0x08
+#define DW_EH_PE_pcrel		0x10
+#define DW_EH_PE_textrel	0x20
+#define DW_EH_PE_datarel	0x30
+#define DW_EH_PE_funcrel	0x40
+#define DW_EH_PE_aligned	0x50
+#define DW_EH_PE_indirect	0x80
+#endif
diff -uprN -X  linux-orig/include/linux/kgdb.h linux-kgdb/include/linux/kgdb.h
--- linux-orig/include/linux/kgdb.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/include/linux/kgdb.h	2006-09-04 11:07:31.773815000 +0000
@@ -0,0 +1,274 @@
+/*
+ * include/linux/kgdb.h
+ *
+ * This provides the hooks and functions that KGDB needs to share between
+ * the core, I/O and arch-specific portions.
+ *
+ * Author: Amit Kale <amitkale@linsyssoft.com> and
+ *         Tom Rini <trini@kernel.crashing.org>
+ *
+ * 2001-2004 (c) Amit S. Kale and 2003-2005 (c) MontaVista Software, Inc.
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifdef __KERNEL__
+#ifndef _KGDB_H_
+#define _KGDB_H_
+
+#include <asm/atomic.h>
+
+#ifdef CONFIG_KGDB
+#include <asm/kgdb.h>
+#include <linux/serial_8250.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+struct tasklet_struct;
+struct pt_regs;
+struct task_struct;
+struct uart_port;
+
+#ifdef CONFIG_KGDB_CONSOLE
+extern struct console kgdbcons;
+#endif
+
+/* To enter the debugger explicitly. */
+extern void breakpoint(void);
+extern int kgdb_connected;
+extern int kgdb_may_fault;
+extern struct tasklet_struct kgdb_tasklet_breakpoint;
+
+extern atomic_t kgdb_setting_breakpoint;
+extern atomic_t cpu_doing_single_step;
+extern atomic_t kgdb_sync_softlockup[NR_CPUS];
+
+extern struct task_struct *kgdb_usethread, *kgdb_contthread;
+
+enum kgdb_bptype {
+	bp_breakpoint = '0',
+	bp_hardware_breakpoint,
+	bp_write_watchpoint,
+	bp_read_watchpoint,
+	bp_access_watchpoint
+};
+
+enum kgdb_bpstate {
+	bp_none = 0,
+	bp_removed,
+	bp_set,
+	bp_active
+};
+
+struct kgdb_bkpt {
+	unsigned long bpt_addr;
+	unsigned char saved_instr[BREAK_INSTR_SIZE];
+	enum kgdb_bptype type;
+	enum kgdb_bpstate state;
+};
+
+/* The maximum number of KGDB I/O modules that can be loaded */
+#define MAX_KGDB_IO_HANDLERS 3
+
+#ifndef MAX_BREAKPOINTS
+#define MAX_BREAKPOINTS		1000
+#endif
+
+#define KGDB_HW_BREAKPOINT	1
+
+/* Required functions. */
+/**
+ *	regs_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	Convert the pt_regs in @regs into the format for registers that
+ *	GDB expects, stored in @gdb_regs.
+ */
+extern void regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/**
+ *	sleeping_regs_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@p: The &struct task_struct of the desired process.
+ *
+ *	Convert the register values of the sleeping process in @p to
+ *	the format that GDB expects.
+ *	This function is called when kgdb does not have access to the
+ *	&struct pt_regs and therefore it should fill the gdb registers
+ *	@gdb_regs with what has	been saved in &struct thread_struct
+ *	thread field during switch_to.
+ */
+extern void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs,
+					struct task_struct *p);
+
+/**
+ *	gdb_regs_to_regs - Convert GDB regs to ptrace regs.
+ *	@gdb_regs: A pointer to hold the registers we've recieved from GDB.
+ *	@regs: A pointer to a &struct pt_regs to hold these values in.
+ *
+ *	Convert the GDB regs in @gdb_regs into the pt_regs, and store them
+ *	in @regs.
+ */
+extern void gdb_regs_to_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/**
+ *	kgdb_arch_handle_exception - Handle architecture specific GDB packets.
+ *	@vector: The error vector of the exception that happened.
+ *	@signo: The signal number of the exception that happened.
+ *	@err_code: The error code of the exception that happened.
+ *	@remcom_in_buffer: The buffer of the packet we have read.
+ *	@remcom_out_buffer: The buffer, of %BUFMAX to write a packet into.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	This function MUST handle the 'c' and 's' command packets,
+ *	as well packets to set / remove a hardware breakpoint, if used.
+ *	If there are additional packets which the hardware needs to handle,
+ *	they are handled here.  The code should return -1 if it wants to
+ *	process more packets, and a %0 or %1 if it wants to exit from the
+ *	kgdb hook.
+ */
+extern int kgdb_arch_handle_exception(int vector, int signo, int err_code,
+				      char *remcom_in_buffer,
+				      char *remcom_out_buffer,
+				      struct pt_regs *regs);
+
+#ifndef JMP_REGS_ALIGNMENT
+#define JMP_REGS_ALIGNMENT
+#endif
+
+extern unsigned long kgdb_fault_jmp_regs[];
+
+/**
+ *	kgdb_fault_setjmp - Store state in case we fault.
+ *	@curr_context: An array to store state into.
+ *
+ *	Certain functions may try and access memory, and in doing so may
+ *	cause a fault.  When this happens, we trap it, restore state to
+ *	this call, and let ourself know that something bad has happened.
+ */
+extern asmlinkage int kgdb_fault_setjmp(unsigned long *curr_context);
+
+/**
+ *	kgdb_fault_longjmp - Restore state when we have faulted.
+ *	@curr_context: The previously stored state.
+ *
+ *	When something bad does happen, this function is called to
+ *	restore the known good state, and set the return value to 1, so
+ *	we know something bad happened.
+ */
+extern asmlinkage void kgdb_fault_longjmp(unsigned long *curr_context);
+
+/* Optional functions. */
+extern int kgdb_arch_init(void);
+extern void kgdb_disable_hw_debug(struct pt_regs *regs);
+extern void kgdb_post_master_code(struct pt_regs *regs, int e_vector,
+				  int err_code);
+extern void kgdb_roundup_cpus(unsigned long flags);
+extern int kgdb_set_hw_break(unsigned long addr);
+extern int kgdb_remove_hw_break(unsigned long addr);
+extern void kgdb_remove_all_hw_break(void);
+extern void kgdb_correct_hw_break(void);
+extern void kgdb_shadowinfo(struct pt_regs *regs, char *buffer,
+			    unsigned threadid);
+extern struct task_struct *kgdb_get_shadow_thread(struct pt_regs *regs,
+						  int threadid);
+extern struct pt_regs *kgdb_shadow_regs(struct pt_regs *regs, int threadid);
+extern int kgdb_validate_break_address(unsigned long addr);
+extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
+extern int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle);
+
+/**
+ * struct kgdb_arch - Desribe architecture specific values.
+ * @gdb_bpt_instr: The instruction to trigger a breakpoint.
+ * @flags: Flags for the breakpoint, currently just %KGDB_HW_BREAKPOINT.
+ * @shadowth: A value of %1 indicates we shadow information on processes.
+ * @set_breakpoint: Allow an architecture to specify how to set a software
+ * breakpoint.
+ * @remove_breakpoint: Allow an architecture to specify how to remove a
+ * software breakpoint.
+ * @set_hw_breakpoint: Allow an architecture to specify how to set a hardware
+ * breakpoint.
+ * @remove_hw_breakpoint: Allow an architecture to specify how to remove a
+ * hardware breakpoint.
+ *
+ * The @shadowth flag is an option to shadow information not retrievable by
+ * gdb otherwise.  This is deprecated in favor of a binutils which supports
+ * CFI macros.
+ */
+struct kgdb_arch {
+	unsigned char gdb_bpt_instr[BREAK_INSTR_SIZE];
+	unsigned long flags;
+	unsigned shadowth;
+	int (*set_breakpoint) (unsigned long, char *);
+	int (*remove_breakpoint)(unsigned long, char *);
+	int (*set_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
+	int (*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
+};
+
+/* Thread reference */
+typedef unsigned char threadref[8];
+
+/**
+ * struct kgdb_io - Desribe the interface for an I/O driver to talk with KGDB.
+ * @read_char: Pointer to a function that will return one char.
+ * @write_char: Pointer to a function that will write one char.
+ * @flush: Pointer to a function that will flush any pending writes.
+ * @init: Pointer to a function that will initialize the device.
+ * @late_init: Pointer to a function that will do any setup that has
+ * other dependencies.
+ * @pre_exception: Pointer to a function that will do any prep work for
+ * the I/O driver.
+ * @post_exception: Pointer to a function that will do any cleanup work
+ * for the I/O driver.
+ *
+ * The @init and @late_init function pointers allow for an I/O driver
+ * such as a serial driver to fully initialize the port with @init and
+ * be called very early, yet safely call request_irq() later in the boot
+ * sequence.
+ *
+ * @init is allowed to return a non-0 return value to indicate failure.
+ * If this is called early on, then KGDB will try again when it would call
+ * @late_init.  If it has failed later in boot as well, the user will be
+ * notified.
+ */
+struct kgdb_io {
+	int (*read_char) (void);
+	void (*write_char) (u8);
+	void (*flush) (void);
+	int (*init) (void);
+	void (*late_init) (void);
+	void (*pre_exception) (void);
+	void (*post_exception) (void);
+};
+
+extern struct kgdb_io kgdb_io_ops;
+extern struct kgdb_arch arch_kgdb_ops;
+extern int kgdb_initialized;
+
+extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
+extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
+
+extern void __init kgdb8250_add_port(int i, struct uart_port *serial_req);
+extern void __init kgdb8250_add_platform_port(int i, struct plat_serial8250_port *serial_req);
+
+extern int kgdb_hex2long(char **ptr, long *long_val);
+extern char *kgdb_mem2hex(char *mem, char *buf, int count);
+extern char *kgdb_hex2mem(char *buf, char *mem, int count);
+extern int kgdb_get_mem(char *addr, unsigned char *buf, int count);
+extern int kgdb_set_mem(char *addr, unsigned char *buf, int count);
+
+int kgdb_isremovedbreak(unsigned long addr);
+int kgdb_skipexception(int exception, struct pt_regs *regs);
+
+extern int kgdb_handle_exception(int ex_vector, int signo, int err_code,
+				struct pt_regs *regs);
+extern void kgdb_nmihook(int cpu, void *regs);
+extern int debugger_step;
+extern atomic_t debugger_active;
+#else
+/* Stubs for when KGDB is not set. */
+static const atomic_t debugger_active = ATOMIC_INIT(0);
+#endif				/* CONFIG_KGDB */
+#endif				/* _KGDB_H_ */
+#endif				/* __KERNEL__ */
diff -uprN -X  linux-orig/include/linux/module.h linux-kgdb/include/linux/module.h
--- linux-orig/include/linux/module.h	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/include/linux/module.h	2006-09-01 08:35:47.000000000 +0000
@@ -214,8 +214,17 @@ enum module_state
 	MODULE_STATE_LIVE,
 	MODULE_STATE_COMING,
 	MODULE_STATE_GOING,
+ 	MODULE_STATE_GONE,
 };
 
+#ifdef CONFIG_KGDB
+#define MAX_SECTNAME 31
+struct mod_section {
+       void *address;
+       char name[MAX_SECTNAME + 1];
+};
+#endif
+
 /* Similar stuff for section attributes. */
 #define MODULE_SECT_NAME_LEN 32
 struct module_sect_attr
@@ -243,6 +252,13 @@ struct module
 	/* Unique handle for this module */
 	char name[MODULE_NAME_LEN];
 
+#ifdef CONFIG_KGDB
+	/* keep kgdb info at the begining so that gdb doesn't have a chance to
+	 * miss out any fields */
+	unsigned long num_sections;
+	struct mod_section *mod_sections;
+#endif
+
 	/* Sysfs stuff. */
 	struct module_kobject mkobj;
 	struct module_param_attrs *param_attrs;
diff -uprN -X  linux-orig/include/linux/netpoll.h linux-kgdb/include/linux/netpoll.h
--- linux-orig/include/linux/netpoll.h	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/include/linux/netpoll.h	2006-09-01 08:34:22.000000000 +0000
@@ -17,7 +17,7 @@ struct netpoll;
 struct netpoll {
 	struct net_device *dev;
 	char dev_name[16], *name;
-	void (*rx_hook)(struct netpoll *, int, char *, int);
+	void (*rx_hook)(struct netpoll *, int, char *, int, struct sk_buff *);
 	void (*drop)(struct sk_buff *skb);
 	u32 local_ip, remote_ip;
 	u16 local_port, remote_port;
diff -uprN -X  linux-orig/kernel/kgdb.c linux-kgdb/kernel/kgdb.c
--- linux-orig/kernel/kgdb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-kgdb/kernel/kgdb.c	2006-09-06 12:40:21.414202000 +0000
@@ -0,0 +1,1973 @@
+/*
+ * kernel/kgdb.c
+ *
+ * Maintainer: Tom Rini <trini@kernel.crashing.org>
+ *
+ * Copyright (C) 2000-2001 VERITAS Software Corporation.
+ * Copyright (C) 2002-2004 Timesys Corporation
+ * Copyright (C) 2003-2004 Amit S. Kale <amitkale@linsyssoft.com>
+ * Copyright (C) 2004 Pavel Machek <pavel@suse.cz>
+ * Copyright (C) 2004-2005 Tom Rini <trini@kernel.crashing.org>
+ * Copyright (C) 2004-2006 LinSysSoft Technologies Pvt. Ltd.
+ * Copyright (C) 2005 Wind River Systems, Inc.
+ *
+ * Contributors at various stages not listed above:
+ *  Jason Wessel ( jason.wessel@windriver.com )
+ *  George Anzinger <george@mvista.com>
+ *  Anurekh Saxena (anurekh.saxena@timesys.com)
+ *  Lake Stevens Instrument Division (Glenn Engel)
+ *  Jim Kingdon, Cygnus Support.
+ *
+ * Original KGDB stub: David Grothe <dave@gcom.com>,
+ * Tigran Aivazian <tigran@sco.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/threads.h>
+#include <linux/reboot.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/uaccess.h>
+#include <linux/kgdb.h>
+#include <asm/atomic.h>
+#include <linux/notifier.h>
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/sched.h>
+#include <asm/byteorder.h>
+
+extern int pid_max;
+extern int pidhash_init_done;
+void force_pidhash_init(void);
+
+/* How many times to count all of the waiting CPUs */
+#define ROUNDUP_WAIT		640000	/* Arbitrary, increase if needed. */
+#define BUF_THREAD_ID_SIZE	16
+
+/*
+ * kgdb_initialized with a value of 1 indicates that kgdb is setup and is
+ * all ready to serve breakpoints and other kernel exceptions.  A value of
+ * -1 indicates that we have tried to initialize early, and need to try
+ * again later.
+ */
+int kgdb_initialized;
+/* Is a host GDB connected to us? */
+int kgdb_connected;
+/* Could we be about to try and access a bad memory location? If so we
+ * also need to flag this has happend. */
+int kgdb_may_fault;
+/* All the KGDB handlers are installed */
+int kgdb_from_module_registered = 0;
+
+/* We provide a kgdb_io_ops structure that may be overriden. */
+struct kgdb_io __attribute__ ((weak)) kgdb_io_ops;
+
+static struct kgdb_io kgdb_io_ops_prev[MAX_KGDB_IO_HANDLERS];
+static int kgdb_io_handler_cnt = 0;
+
+/* Export the following symbols for use with kernel modules */
+EXPORT_SYMBOL(kgdb_io_ops);
+EXPORT_SYMBOL(kgdb_tasklet_breakpoint);
+EXPORT_SYMBOL(kgdb_connected);
+EXPORT_SYMBOL(kgdb_register_io_module);
+EXPORT_SYMBOL(kgdb_unregister_io_module);
+EXPORT_SYMBOL(debugger_active);
+
+/*
+ * Holds information about breakpoints in a kernel. These breakpoints are
+ * added and removed by gdb.
+ */
+struct kgdb_bkpt kgdb_break[MAX_BREAKPOINTS];
+
+struct kgdb_arch *kgdb_ops = &arch_kgdb_ops;
+
+static const char hexchars[] = "0123456789abcdef";
+
+static spinlock_t slavecpulocks[NR_CPUS];
+static atomic_t procindebug[NR_CPUS];
+atomic_t kgdb_setting_breakpoint;
+EXPORT_SYMBOL(kgdb_setting_breakpoint);
+struct task_struct *kgdb_usethread, *kgdb_contthread;
+
+int debugger_step;
+atomic_t debugger_active;
+
+/* Our I/O buffers. */
+static char remcom_in_buffer[BUFMAX];
+static char remcom_out_buffer[BUFMAX];
+/* Storage for the registers, in GDB format. */
+static unsigned long gdb_regs[(NUMREGBYTES + sizeof(unsigned long) - 1) /
+			      sizeof(unsigned long)];
+/* Storage of registers for handling a fault. */
+unsigned long kgdb_fault_jmp_regs[NUMCRITREGBYTES / sizeof(unsigned long)]
+ JMP_REGS_ALIGNMENT;
+static int kgdb_notify_reboot(struct notifier_block *this,
+				unsigned long code ,void *x);
+struct debuggerinfo_struct {
+	void *debuggerinfo;
+	struct task_struct *task;
+} kgdb_info[NR_CPUS];
+
+/* to keep track of the CPU which is doing the single stepping*/
+atomic_t cpu_doing_single_step = ATOMIC_INIT(-1);
+
+atomic_t  kgdb_sync_softlockup[NR_CPUS] = {ATOMIC_INIT(0)};
+
+/* reboot notifier block */
+static struct notifier_block kgdb_reboot_notifier = {
+	.notifier_call  = kgdb_notify_reboot,
+	.next           = NULL,
+	.priority       = INT_MAX,
+};
+
+/**
+ *	kgdb_arch_init - Perform any architecture specific initalization.
+ *
+ *	RETURN:
+ *	The return value is ignored.
+ *
+ *	This function will handle the initalization of any architecture
+ *	specific hooks.
+ */
+int __attribute__ ((weak))
+    kgdb_arch_init(void)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_disable_hw_debug - Disable hardware debugging while we in kgdb.
+ *	@regs: Current &struct pt_regs.
+ *
+ *	This function will be called if the particular architecture must
+ *	disable hardware debugging while it is processing gdb packets or
+ *	handling exception.
+ */
+void __attribute__ ((weak))
+    kgdb_disable_hw_debug(struct pt_regs *regs)
+{
+}
+
+/*
+ * Skip an int3 exception when it occurs after a breakpoint has been
+ * removed. Backtrack eip by 1 since the int3 would have caused it to
+ * increment by 1.
+ */
+int __attribute__ ((weak))
+	kgdb_skipexception(int exception, struct pt_regs *regs)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_set_hw_break - Set a hardware breakpoint at @addr.
+ *	@addr: The address to set a hardware breakpoint at.
+ */
+int __attribute__ ((weak))
+    kgdb_set_hw_break(unsigned long addr)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_remove_hw_break - Remove a hardware breakpoint at @addr.
+ *	@addr: The address to remove a hardware breakpoint from.
+ */
+int __attribute__ ((weak))
+    kgdb_remove_hw_break(unsigned long addr)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_remove_all_hw_break - Clear all hardware breakpoints.
+ */
+void __attribute__ ((weak))
+    kgdb_remove_all_hw_break(void)
+{
+}
+
+/**
+ *	kgdb_correct_hw_break - Correct hardware breakpoints.
+ *
+ *	A hook to allow for changes to the hardware breakpoint, called
+ *	after a single step (s) or continue (c) packet, and once we're about
+ *	to let the kernel continue running.
+ *
+ *	This is used to set the hardware breakpoint registers for all the
+ *	slave cpus on an SMP configuration. This must be called after any
+ *	changes are made to the hardware breakpoints (such as by a single
+ *	step (s) or continue (c) packet. This is only required on
+ *	architectures that support SMP and every processor has its own set
+ *	of breakpoint registers.
+ */
+void __attribute__ ((weak))
+    kgdb_correct_hw_break(void)
+{
+}
+
+/**
+ *	kgdb_post_master_code - Save error vector/code numbers.
+ *	@regs: Original pt_regs.
+ *	@e_vector: Original error vector.
+ *	@err_code: Original error code.
+ *
+ *	This is needed on architectures which support SMP and KGDB.
+ *	This function is called after all the slave cpus have been put
+ *	to a know spin state and the master CPU has control over KGDB.
+ */
+
+void __attribute__ ((weak))
+    kgdb_post_master_code(struct pt_regs *regs, int e_vector, int err_code)
+{
+}
+
+/**
+ * 	kgdb_roundup_cpus - Get other CPUs into a holding pattern
+ * 	@flags: Current IRQ state
+ *
+ * 	On SMP systems, we need to get the attention of the other CPUs
+ * 	and get them be in a known state.  This should do what is needed
+ * 	to get the other CPUs to call kgdb_wait(). Note that on some arches,
+ *	the NMI approach is not used for rounding up all the CPUs. For example,
+ *	in case of MIPS, smp_call_function() is used to roundup CPUs. In
+ *	this case, we have to make sure that interrupts are enabled before
+ *	calling smp_call_function(). The argument to this function is
+ *	the flags that will be used when restoring the interrupts. There is
+ *	local_irq_save() call before kgdb_roundup_cpus().
+ */
+void __attribute__ ((weak))
+    kgdb_roundup_cpus(unsigned long flags)
+{
+}
+
+/**
+ *	kgdb_shadowinfo - Get shadowed information on @threadid.
+ *	@regs: The &struct pt_regs of the current process.
+ *	@buffer: A buffer of %BUFMAX size.
+ *	@threadid: The thread id of the shadowed process to get information on.
+ */
+void __attribute__ ((weak))
+    kgdb_shadowinfo(struct pt_regs *regs, char *buffer, unsigned threadid)
+{
+}
+
+/**
+ *	kgdb_get_shadow_thread - Get the shadowed &task_struct of @threadid.
+ *	@regs: The &struct pt_regs of the current thread.
+ *	@threadid: The thread id of the shadowed process to get information on.
+ *
+ *	RETURN:
+ *	This returns a pointer to the &struct task_struct of the shadowed
+ *	thread, @threadid.
+ */
+struct task_struct __attribute__ ((weak))
+    * kgdb_get_shadow_thread(struct pt_regs *regs, int threadid)
+{
+	return NULL;
+}
+
+/**
+ *	kgdb_shadow_regs - Return the shadowed registers of @threadid.
+ *	@regs: The &struct pt_regs of the current thread.
+ *	@threadid: The thread id we want the &struct pt_regs for.
+ *
+ *	RETURN:
+ *	The a pointer to the &struct pt_regs of the shadowed thread @threadid.
+ */
+struct pt_regs __attribute__ ((weak))
+    * kgdb_shadow_regs(struct pt_regs *regs, int threadid)
+{
+	return NULL;
+}
+
+int __attribute__ ((weak))
+     kgdb_validate_break_address(unsigned long addr)
+{
+	int error = 0;
+	char tmp_variable[BREAK_INSTR_SIZE];
+	error = kgdb_get_mem((char *)addr, tmp_variable, BREAK_INSTR_SIZE);
+	return error;
+}
+
+int __attribute__ ((weak))
+     kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr)
+{
+	int error = 0;
+	if ((error = kgdb_get_mem((char *)addr,
+		saved_instr, BREAK_INSTR_SIZE)) < 0)
+			return error;
+
+	if ((error = kgdb_set_mem((char *)addr, kgdb_ops->gdb_bpt_instr,
+		BREAK_INSTR_SIZE)) < 0)
+			return error;
+	return 0;
+}
+
+int __attribute__ ((weak))
+     kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle)
+{
+
+	int error = 0;
+	if ((error =kgdb_set_mem((char *)addr, (char *)bundle,
+		BREAK_INSTR_SIZE)) < 0)
+			return error;
+	return 0;
+}
+
+static int hex(char ch)
+{
+	if ((ch >= 'a') && (ch <= 'f'))
+		return (ch - 'a' + 10);
+	if ((ch >= '0') && (ch <= '9'))
+		return (ch - '0');
+	if ((ch >= 'A') && (ch <= 'F'))
+		return (ch - 'A' + 10);
+	return (-1);
+}
+
+/* scan for the sequence $<data>#<checksum>	*/
+static void get_packet(char *buffer)
+{
+	unsigned char checksum;
+	unsigned char xmitcsum;
+	int count;
+	char ch;
+	if (!kgdb_io_ops.read_char)
+		return;
+	do {
+		/* Spin and wait around for the start character, ignore all
+		 * other characters */
+		while ((ch = (kgdb_io_ops.read_char())) != '$') ;
+		kgdb_connected = 1;
+		checksum = 0;
+		xmitcsum = -1;
+
+		count = 0;
+
+		/* now, read until a # or end of buffer is found */
+		while (count < (BUFMAX - 1)) {
+			ch = kgdb_io_ops.read_char();
+			if (ch == '#')
+				break;
+			checksum = checksum + ch;
+			buffer[count] = ch;
+			count = count + 1;
+		}
+		buffer[count] = 0;
+
+		if (ch == '#') {
+			xmitcsum = hex(kgdb_io_ops.read_char()) << 4;
+			xmitcsum += hex(kgdb_io_ops.read_char());
+
+			if (checksum != xmitcsum)
+				/* failed checksum */
+				kgdb_io_ops.write_char('-');
+			else
+				/* successful transfer */
+				kgdb_io_ops.write_char('+');
+			if (kgdb_io_ops.flush)
+				kgdb_io_ops.flush();
+		}
+	} while (checksum != xmitcsum);
+}
+
+/*
+ * Send the packet in buffer.
+ * Check for gdb connection if asked for.
+ */
+static void put_packet(char *buffer)
+{
+	unsigned char checksum;
+	int count;
+	char ch;
+
+	if (!kgdb_io_ops.write_char)
+		return;
+	/* $<packet info>#<checksum>. */
+	while (1) {
+		kgdb_io_ops.write_char('$');
+		checksum = 0;
+		count = 0;
+
+		while ((ch = buffer[count])) {
+			kgdb_io_ops.write_char(ch);
+			checksum += ch;
+			count++;
+		}
+
+		kgdb_io_ops.write_char('#');
+		kgdb_io_ops.write_char(hexchars[checksum >> 4]);
+		kgdb_io_ops.write_char(hexchars[checksum % 16]);
+		if (kgdb_io_ops.flush)
+			kgdb_io_ops.flush();
+
+		/* Now see what we get in reply. */
+		ch = kgdb_io_ops.read_char();
+
+		if (ch == 3)
+			ch = kgdb_io_ops.read_char();
+
+		/* If we get an ACK, we are done. */
+		if (ch == '+')
+			return;
+
+		/* If we get the start of another packet, this means
+		 * that GDB is attempting to reconnect.  We will NAK
+		 * the packet being sent, and stop trying to send this
+		 * packet. */
+		if (ch == '$') {
+			kgdb_io_ops.write_char('-');
+			if (kgdb_io_ops.flush)
+				kgdb_io_ops.flush();
+			return;
+		}
+	}
+}
+
+/*
+ * convert the memory pointed to by mem into hex, placing result in buf
+ * return a pointer to the last char put in buf (null). May return an error.
+ */
+char *kgdb_mem2hex(char *mem, char *buf, int count)
+{
+	kgdb_may_fault = 1;
+	if ((kgdb_fault_setjmp(kgdb_fault_jmp_regs)) != 0) {
+		kgdb_may_fault = 0;
+		return ERR_PTR(-EINVAL);
+	}
+	/* Accessing some registers in a single load instruction is
+	 * required to avoid bad side effects for some I/O registers.
+	 */
+	if ((count == 2) && (((long)mem & 1) == 0)) {
+		unsigned short tmp_s = *(unsigned short *)mem;
+		mem += 2;
+#ifdef __BIG_ENDIAN
+		*buf++ = hexchars[(tmp_s >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_s >> 8) & 0xf];
+		*buf++ = hexchars[(tmp_s >> 4) & 0xf];
+		*buf++ = hexchars[tmp_s & 0xf];
+#else
+		*buf++ = hexchars[(tmp_s >> 4) & 0xf];
+		*buf++ = hexchars[tmp_s & 0xf];
+		*buf++ = hexchars[(tmp_s >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_s >> 8) & 0xf];
+#endif
+	} else if ((count == 4) && (((long)mem & 3) == 0)) {
+		unsigned long tmp_l = *(unsigned int *)mem;
+		mem += 4;
+#ifdef __BIG_ENDIAN
+		*buf++ = hexchars[(tmp_l >> 28) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 24) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 20) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 16) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 8) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 4) & 0xf];
+		*buf++ = hexchars[tmp_l & 0xf];
+#else
+		*buf++ = hexchars[(tmp_l >> 4) & 0xf];
+		*buf++ = hexchars[tmp_l & 0xf];
+		*buf++ = hexchars[(tmp_l >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 8) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 20) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 16) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 28) & 0xf];
+		*buf++ = hexchars[(tmp_l >> 24) & 0xf];
+#endif
+#ifdef CONFIG_64BIT
+	} else if ((count == 8) && (((long)mem & 7) == 0)) {
+		unsigned long long tmp_ll = *(unsigned long long *)mem;
+		mem += 8;
+#ifdef __BIG_ENDIAN
+		*buf++ = hexchars[(tmp_ll >> 60) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 56) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 52) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 48) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 44) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 40) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 36) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 32) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 28) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 24) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 20) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 16) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 8) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 4) & 0xf];
+		*buf++ = hexchars[tmp_ll & 0xf];
+#else
+		*buf++ = hexchars[(tmp_ll >> 4) & 0xf];
+		*buf++ = hexchars[tmp_ll & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 12) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 8) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 20) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 16) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 28) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 24) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 36) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 32) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 44) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 40) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 52) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 48) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 60) & 0xf];
+		*buf++ = hexchars[(tmp_ll >> 56) & 0xf];
+#endif
+#endif
+	} else {
+		while (count-- > 0) {
+			unsigned char ch = *mem++;
+			*buf++ = hexchars[ch >> 4];
+			*buf++ = hexchars[ch & 0xf];
+		}
+	}
+	kgdb_may_fault = 0;
+	*buf = 0;
+	return (buf);
+}
+
+/*
+ * Copy the binary array pointed to by buf into mem.  Fix $, #, and
+ * 0x7d escaped with 0x7d.  Return a pointer to the character after
+ * the last byte written.
+ */
+static char *kgdb_ebin2mem(char *buf, char *mem, int count)
+{
+	kgdb_may_fault = 1;
+	if ((kgdb_fault_setjmp(kgdb_fault_jmp_regs)) != 0) {
+		kgdb_may_fault = 0;
+		return ERR_PTR(-EINVAL);
+	}
+	for (; count > 0; count--, buf++) {
+		if (*buf == 0x7d)
+			*mem++ = *(++buf) ^ 0x20;
+		else
+			*mem++ = *buf;
+	}
+	kgdb_may_fault = 0;
+	return mem;
+}
+
+/*
+ * convert the hex array pointed to by buf into binary to be placed in mem
+ * return a pointer to the character AFTER the last byte written
+ * May return an error.
+ */
+char *kgdb_hex2mem(char *buf, char *mem, int count)
+{
+	kgdb_may_fault = 1;
+	if ((kgdb_fault_setjmp(kgdb_fault_jmp_regs)) != 0) {
+		kgdb_may_fault = 0;
+		return ERR_PTR(-EINVAL);
+	}
+	if ((count == 2) && (((long)mem & 1) == 0)) {
+		unsigned short tmp_s = 0;
+#ifdef __BIG_ENDIAN
+		tmp_s |= hex(*buf++) << 12;
+		tmp_s |= hex(*buf++) << 8;
+		tmp_s |= hex(*buf++) << 4;
+		tmp_s |= hex(*buf++);
+#else
+		tmp_s |= hex(*buf++) << 4;
+		tmp_s |= hex(*buf++);
+		tmp_s |= hex(*buf++) << 12;
+		tmp_s |= hex(*buf++) << 8;
+#endif
+		*(unsigned short *)mem = tmp_s;
+		mem += 2;
+	} else if ((count == 4) && (((long)mem & 3) == 0)) {
+		unsigned long tmp_l = 0;
+#ifdef __BIG_ENDIAN
+		tmp_l |= hex(*buf++) << 28;
+		tmp_l |= hex(*buf++) << 24;
+		tmp_l |= hex(*buf++) << 20;
+		tmp_l |= hex(*buf++) << 16;
+		tmp_l |= hex(*buf++) << 12;
+		tmp_l |= hex(*buf++) << 8;
+		tmp_l |= hex(*buf++) << 4;
+		tmp_l |= hex(*buf++);
+#else
+		tmp_l |= hex(*buf++) << 4;
+		tmp_l |= hex(*buf++);
+		tmp_l |= hex(*buf++) << 12;
+		tmp_l |= hex(*buf++) << 8;
+		tmp_l |= hex(*buf++) << 20;
+		tmp_l |= hex(*buf++) << 16;
+		tmp_l |= hex(*buf++) << 28;
+		tmp_l |= hex(*buf++) << 24;
+#endif
+		*(unsigned long *)mem = tmp_l;
+		mem += 4;
+	} else {
+		int i;
+		for (i = 0; i < count; i++) {
+			unsigned char ch = hex(*buf++) << 4;
+			ch |= hex(*buf++);
+			*mem++ = ch;
+		}
+	}
+	kgdb_may_fault = 0;
+	return (mem);
+}
+
+/*
+ * While we find nice hex chars, build a long_val.
+ * Return number of chars processed.
+ */
+int kgdb_hex2long(char **ptr, long *long_val)
+{
+	int hex_val, num = 0;
+
+	*long_val = 0;
+
+	while (**ptr) {
+		hex_val = hex(**ptr);
+		if (hex_val >= 0) {
+			*long_val = (*long_val << 4) | hex_val;
+			num++;
+		} else
+			break;
+
+		(*ptr)++;
+	}
+
+	return (num);
+}
+
+/* Write memory due to an 'M' or 'X' packet. */
+static char *write_mem_msg(int binary)
+{
+	char *ptr = &remcom_in_buffer[1];
+	unsigned long addr, length;
+
+	if (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&
+	    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {
+		if (binary)
+			ptr = kgdb_ebin2mem(ptr, (char *)addr, length);
+		else
+			ptr = kgdb_hex2mem(ptr, (char *)addr, length);
+		if (CACHE_FLUSH_IS_SAFE)
+			flush_icache_range(addr, addr + length + 1);
+		if (IS_ERR(ptr))
+			return ptr;
+		return NULL;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+static inline char *pack_hex_byte(char *pkt, int byte)
+{
+	*pkt++ = hexchars[(byte >> 4) & 0xf];
+	*pkt++ = hexchars[(byte & 0xf)];
+	return pkt;
+}
+
+static inline void error_packet(char *pkt, int error)
+{
+	error = -error;
+	pkt[0] = 'E';
+	pkt[1] = hexchars[(error / 10)];
+	pkt[2] = hexchars[(error % 10)];
+	pkt[3] = '\0';
+}
+
+static char *pack_threadid(char *pkt, threadref * id)
+{
+	char *limit;
+	unsigned char *altid;
+
+	altid = (unsigned char *)id;
+	limit = pkt + BUF_THREAD_ID_SIZE;
+	while (pkt < limit)
+		pkt = pack_hex_byte(pkt, *altid++);
+
+	return pkt;
+}
+
+void int_to_threadref(threadref * id, int value)
+{
+	unsigned char *scan;
+	int i = 4;
+
+	scan = (unsigned char *)id;
+	while (i--)
+		*scan++ = 0;
+	*scan++ = (value >> 24) & 0xff;
+	*scan++ = (value >> 16) & 0xff;
+	*scan++ = (value >> 8) & 0xff;
+	*scan++ = (value & 0xff);
+}
+
+static struct task_struct *getthread(struct pt_regs *regs, int tid)
+{
+	if (!pidhash_init_done)
+                return current;
+
+/*	if (last_pid != 0)
+		return current;
+*/
+	if (num_online_cpus() &&
+	    (tid >= pid_max + num_online_cpus() + kgdb_ops->shadowth))
+		return NULL;
+
+	if (kgdb_ops->shadowth && (tid >= pid_max + num_online_cpus()))
+		return kgdb_get_shadow_thread(regs, tid - pid_max -
+					      num_online_cpus());
+
+	if (tid >= pid_max)
+		return idle_task(tid - pid_max);
+
+	if (!tid)
+		return NULL;
+
+	return find_task_by_pid(tid);
+}
+
+#ifdef CONFIG_SMP
+static void kgdb_wait(struct pt_regs *regs)
+{
+	unsigned long flags;
+	int processor;
+
+	local_irq_save(flags);
+	processor = smp_processor_id();
+	kgdb_info[processor].debuggerinfo = regs;
+	kgdb_info[processor].task = current;
+	atomic_set(&procindebug[processor], 1);
+	atomic_set(&kgdb_sync_softlockup[smp_processor_id()], 1);
+
+	/* Wait till master processor goes completely into the debugger.
+	 * FIXME: this looks racy */
+	while (!atomic_read(&procindebug[atomic_read(&debugger_active) - 1])) {
+		int i = 10;	/* an arbitrary number */
+
+		while (--i)
+			cpu_relax();
+	}
+
+	/* Wait till master processor is done with debugging */
+	spin_lock(&slavecpulocks[processor]);
+
+	/* This has been taken from x86 kgdb implementation and
+	 * will be needed by architectures that have SMP support
+	 */
+	kgdb_correct_hw_break();
+
+	kgdb_info[processor].debuggerinfo = NULL;
+	kgdb_info[processor].task = NULL;
+
+	/* Signal the master processor that we are done */
+	atomic_set(&procindebug[processor], 0);
+	spin_unlock(&slavecpulocks[processor]);
+	local_irq_restore(flags);
+}
+#endif
+
+int kgdb_get_mem(char *addr, unsigned char *buf, int count)
+{
+	kgdb_may_fault = 1;
+	if ((kgdb_fault_setjmp(kgdb_fault_jmp_regs)) != 0) {
+		kgdb_may_fault = 0;
+		return -EINVAL;
+	}
+	while (count) {
+		if ((unsigned long)addr < TASK_SIZE)
+			return -EINVAL;
+		*buf++ = *addr++;
+		count--;
+	}
+	kgdb_may_fault = 0;
+	return 0;
+}
+
+int kgdb_set_mem(char *addr, unsigned char *buf, int count)
+{
+	kgdb_may_fault = 1;
+	if ((kgdb_fault_setjmp(kgdb_fault_jmp_regs)) != 0) {
+		kgdb_may_fault = 0;
+		return -EINVAL;
+	}
+	while (count) {
+		if ((unsigned long)addr < TASK_SIZE)
+			return -EINVAL;
+		*addr++ = *buf++;
+		count--;
+	}
+	kgdb_may_fault = 0;
+	return 0;
+}
+int kgdb_activate_sw_breakpoints(void)
+{
+	int i;
+	int error = 0;
+	unsigned long addr;
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if (kgdb_break[i].state != bp_set)
+			continue;
+		addr = kgdb_break[i].bpt_addr;
+		if ((error = kgdb_arch_set_breakpoint(addr,
+					kgdb_break[i].saved_instr)))
+			return error;
+#if 0
+		if (CACHE_FLUSH_IS_SAFE) {
+			if (current->mm && addr < TASK_SIZE)
+				flush_cache_range(current->mm->mmap_cache,
+						addr, addr + BREAK_INSTR_SIZE);
+			else
+				flush_icache_range(addr, addr +
+						BREAK_INSTR_SIZE);
+		}
+#endif
+
+		kgdb_break[i].state = bp_active;
+        }
+	return 0;
+}
+
+static int kgdb_set_sw_break(unsigned long addr)
+{
+	int i, breakno = -1;
+	int error = 0;
+	if ((error = kgdb_validate_break_address(addr)) < 0)
+		return error;
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if ((kgdb_break[i].state == bp_set) &&
+			(kgdb_break[i].bpt_addr == addr))
+			return -EEXIST;
+	}
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if (kgdb_break[i].state == bp_removed &&
+				kgdb_break[i].bpt_addr == addr) {
+			breakno = i;
+			break;
+		}
+	}
+
+	if (breakno == -1) {
+		for (i = 0; i < MAX_BREAKPOINTS; i++) {
+			if (kgdb_break[i].state == bp_none) {
+				breakno = i;
+				break;
+			}
+		}
+	}
+	if (breakno == -1)
+		return -E2BIG;
+
+	kgdb_break[breakno].state = bp_set;
+	kgdb_break[breakno].type = bp_breakpoint;
+	kgdb_break[breakno].bpt_addr = addr;
+
+	return 0;
+}
+
+int kgdb_deactivate_sw_breakpoints(void)
+{
+	int i;
+	int error = 0;
+	unsigned long addr;
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if (kgdb_break[i].state != bp_active)
+			continue;
+		addr = kgdb_break[i].bpt_addr;
+		if ((error = kgdb_arch_remove_breakpoint(addr,
+					kgdb_break[i].saved_instr)))
+			return error;
+
+		if (CACHE_FLUSH_IS_SAFE && current->mm &&
+				addr < TASK_SIZE)
+			flush_cache_range(current->mm->mmap_cache,
+					addr, addr + BREAK_INSTR_SIZE);
+		else if (CACHE_FLUSH_IS_SAFE)
+			flush_icache_range(addr,
+					addr + BREAK_INSTR_SIZE);
+		kgdb_break[i].state = bp_set;
+	}
+	return 0;
+}
+
+static int kgdb_remove_sw_break(unsigned long addr)
+{
+	int i;
+
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if ((kgdb_break[i].state == bp_set) &&
+			(kgdb_break[i].bpt_addr == addr)) {
+			kgdb_break[i].state = bp_removed;
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int kgdb_isremovedbreak(unsigned long addr)
+{
+	int i;
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if ((kgdb_break[i].state == bp_removed) &&
+			(kgdb_break[i].bpt_addr == addr)) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int remove_all_break(void)
+{
+	int i;
+	int error;
+	unsigned long addr;
+
+	/* Clear memory breakpoints. */
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if (kgdb_break[i].state != bp_set)
+			continue;
+		addr = kgdb_break[i].bpt_addr;
+		if ((error = kgdb_arch_remove_breakpoint(addr,
+					kgdb_break[i].saved_instr)))
+			return error;
+		kgdb_break[i].state = bp_removed;
+	}
+
+	/* Clear hardware breakpoints. */
+	kgdb_remove_all_hw_break();
+
+	return 0;
+}
+
+static inline int shadow_pid(int realpid)
+{
+	if (realpid) {
+		return realpid;
+	}
+	return pid_max + smp_processor_id();
+}
+
+static char gdbmsgbuf[BUFMAX + 1];
+static void kgdb_msg_write(const char *s, int len)
+{
+	int i;
+	int wcount;
+	char *bufptr;
+
+	/* 'O'utput */
+	gdbmsgbuf[0] = 'O';
+
+	/* Fill and send buffers... */
+	while (len > 0) {
+		bufptr = gdbmsgbuf + 1;
+
+		/* Calculate how many this time */
+		if ((len << 1) > (BUFMAX - 2))
+			wcount = (BUFMAX - 2) >> 1;
+		else
+			wcount = len;
+
+		/* Pack in hex chars */
+		for (i = 0; i < wcount; i++)
+			bufptr = pack_hex_byte(bufptr, s[i]);
+		*bufptr = '\0';
+
+		/* Move up */
+		s += wcount;
+		len -= wcount;
+
+		/* Write packet */
+		put_packet(gdbmsgbuf);
+	}
+}
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ *
+ * Locking hierarchy:
+ *	interface locks, if any (begin_session)
+ *	kgdb lock (debugger_active)
+ *
+ * Note that since we can be in here prior to our cpumask being filled
+ * out, we err on the side of caution and loop over NR_CPUS instead
+ * of a for_each_online_cpu.
+ *
+ */
+int kgdb_handle_exception(int ex_vector, int signo, int err_code,
+			  struct pt_regs *linux_regs)
+{
+	unsigned long length, addr;
+	char *ptr;
+	unsigned long flags;
+	unsigned i;
+	long threadid;
+	threadref thref;
+	struct task_struct *thread = NULL;
+	unsigned procid;
+	int numshadowth = num_online_cpus() + kgdb_ops->shadowth;
+	long kgdb_usethreadid = 0;
+	int error = 0, all_cpus_synced = 0;
+	struct pt_regs *shadowregs;
+	int processor = smp_processor_id();
+	void *local_debuggerinfo;
+
+	/* Panic on recursive debugger calls. */
+	if (atomic_read(&debugger_active) == smp_processor_id() + 1)
+		return 0;
+
+      acquirelock:
+
+	/* Call the I/O drivers pre_exception routine if the I/O
+	 * driver defined one
+	 */
+	if (kgdb_io_ops.pre_exception)
+		kgdb_io_ops.pre_exception();
+
+	/*
+	 * Interrupts will be restored by the 'trap return' code, except when
+	 * single stepping.
+	 */
+	local_irq_save(flags);
+
+	/* Hold debugger_active */
+	procid = smp_processor_id();
+
+	while (cmpxchg(&atomic_read(&debugger_active), 0, (procid + 1)) != 0) {
+		int i = 25;	/* an arbitrary number */
+
+		while (--i)
+			cpu_relax();
+
+		if (atomic_read(&cpu_doing_single_step) != -1 &&
+				atomic_read(&cpu_doing_single_step) != procid)
+			udelay(1);
+	}
+
+	atomic_set(&kgdb_sync_softlockup[smp_processor_id()], 1);
+
+	/*
+	 * Don't enter if the last instance of the exception handler wanted to
+	 * come into the debugger again.
+	 */
+	if (atomic_read(&cpu_doing_single_step) != -1 &&
+	    atomic_read(&cpu_doing_single_step) != procid) {
+		atomic_set(&debugger_active, 0);
+		local_irq_restore(flags);
+		goto acquirelock;
+	}
+
+	/*
+	* Don't enter if we have hit a removed breakpoint.
+	*/
+	if (kgdb_skipexception(ex_vector, linux_regs))
+		goto kgdb_restore;
+
+	kgdb_info[processor].debuggerinfo = linux_regs;
+	kgdb_info[processor].task = current;
+
+	kgdb_disable_hw_debug(linux_regs);
+
+	if (!debugger_step || !kgdb_contthread)
+		for (i = 0; i < NR_CPUS; i++)
+			spin_lock(&slavecpulocks[i]);
+
+	/* Make sure we get the other CPUs */
+	if (!debugger_step || !kgdb_contthread)
+		kgdb_roundup_cpus(flags);
+
+	/* spin_lock code is good enough as a barrier so we don't
+	 * need one here */
+	atomic_set(&procindebug[processor], 1);
+
+	/* Wait a reasonable time for the other CPUs to be notified and
+	 * be waiting for us.  Very early on this could be imperfect
+	 * as num_online_cpus() could be 0.*/
+	for (i = 0; i < ROUNDUP_WAIT; i++) {
+		int cpu, num = 0;
+		for (cpu = 0; cpu < NR_CPUS; cpu++) {
+			if (atomic_read(&procindebug[cpu]))
+				num++;
+		}
+		if (num >= num_online_cpus()) {
+			all_cpus_synced = 1;
+			break;
+		}
+	}
+
+	/* Clear the out buffer. */
+	memset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));
+
+	/* Master processor is completely in the debugger */
+	kgdb_post_master_code(linux_regs, ex_vector, err_code);
+	kgdb_deactivate_sw_breakpoints();
+	debugger_step = 0;
+	kgdb_contthread = NULL;
+
+	if (kgdb_connected) {
+		/* If we're still unable to roundup all of the CPUs,
+		 * send an 'O' packet informing the user again. */
+		if (!all_cpus_synced)
+			kgdb_msg_write("Not all CPUs have been synced for "
+				       "KGDB\n", 39);
+		/* Reply to host that an exception has occurred */
+		ptr = remcom_out_buffer;
+		*ptr++ = 'T';
+		*ptr++ = hexchars[(signo >> 4) % 16];
+		*ptr++ = hexchars[signo % 16];
+		ptr += strlen(strcpy(ptr, "thread:"));
+		int_to_threadref(&thref, shadow_pid(current->pid));
+		ptr = pack_threadid(ptr, &thref);
+		*ptr++ = ';';
+
+		put_packet(remcom_out_buffer);
+	}
+
+	kgdb_usethread = kgdb_info[processor].task;
+	kgdb_usethreadid = shadow_pid(kgdb_info[processor].task->pid);
+
+	while (kgdb_io_ops.read_char) {
+		char *bpt_type;
+		error = 0;
+
+		/* Clear the out buffer. */
+		memset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));
+
+		get_packet(remcom_in_buffer);
+
+		switch (remcom_in_buffer[0]) {
+		case '?':
+			/* We know that this packet is only sent
+			 * during initial connect.  So to be safe,
+			 * we clear out our breakpoints now incase
+			 * GDB is reconnecting. */
+			remove_all_break();
+			/* Also, if we haven't been able to roundup all
+			 * CPUs, send an 'O' packet informing the user
+			 * as much.  Only need to do this once. */
+			if (!all_cpus_synced)
+				kgdb_msg_write("Not all CPUs have been "
+					       "synced for KGDB\n", 39);
+			remcom_out_buffer[0] = 'S';
+			remcom_out_buffer[1] = hexchars[signo >> 4];
+			remcom_out_buffer[2] = hexchars[signo % 16];
+			break;
+
+		case 'g':	/* return the value of the CPU registers */
+			thread = kgdb_usethread;
+
+			if (!thread) {
+				thread = kgdb_info[processor].task;
+				local_debuggerinfo =
+				    kgdb_info[processor].debuggerinfo;
+			} else {
+				local_debuggerinfo = NULL;
+				for (i = 0; i < NR_CPUS; i++) {
+					/* Try to find the task on some other
+					 * or possibly this node if we do not
+					 * find the matching task then we try
+					 * to approximate the results.
+					 */
+					if (thread == kgdb_info[i].task)
+						local_debuggerinfo =
+						    kgdb_info[i].debuggerinfo;
+				}
+			}
+
+			/* All threads that don't have debuggerinfo should be
+			 * in __schedule() sleeping, since all other CPUs
+			 * are in kgdb_wait, and thus have debuggerinfo. */
+			if (kgdb_ops->shadowth &&
+			    kgdb_usethreadid >= pid_max + num_online_cpus()) {
+				shadowregs = kgdb_shadow_regs(linux_regs,
+							      kgdb_usethreadid -
+							      pid_max -
+							      num_online_cpus
+							      ());
+				if (!shadowregs) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				regs_to_gdb_regs(gdb_regs, shadowregs);
+			} else if (local_debuggerinfo)
+				regs_to_gdb_regs(gdb_regs, local_debuggerinfo);
+			else {
+				/* Pull stuff saved during
+				 * switch_to; nothing else is
+				 * accessible (or even particularly relevant).
+				 * This should be enough for a stack trace. */
+				sleeping_thread_to_gdb_regs(gdb_regs, thread);
+			}
+			kgdb_mem2hex((char *)gdb_regs, remcom_out_buffer,
+				     NUMREGBYTES);
+			break;
+
+			/* set the value of the CPU registers - return OK */
+		case 'G':
+			kgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs,
+				     NUMREGBYTES);
+
+			if (kgdb_usethread && kgdb_usethread != current)
+				error_packet(remcom_out_buffer, -EINVAL);
+			else {
+				gdb_regs_to_regs(gdb_regs, linux_regs);
+				strcpy(remcom_out_buffer, "OK");
+			}
+			break;
+
+			/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
+		case 'm':
+			ptr = &remcom_in_buffer[1];
+			if (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&
+			    kgdb_hex2long(&ptr, &length) > 0) {
+				if (IS_ERR(ptr = kgdb_mem2hex((char *)addr,
+							      remcom_out_buffer,
+							      length)))
+					error_packet(remcom_out_buffer,
+						     PTR_ERR(ptr));
+			} else
+				error_packet(remcom_out_buffer, -EINVAL);
+			break;
+
+			/* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */
+		case 'M':
+			if (IS_ERR(ptr = write_mem_msg(0)))
+				error_packet(remcom_out_buffer, PTR_ERR(ptr));
+			else
+				strcpy(remcom_out_buffer, "OK");
+			break;
+			/* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */
+		case 'X':
+			if (IS_ERR(ptr = write_mem_msg(1)))
+				error_packet(remcom_out_buffer, PTR_ERR(ptr));
+			else
+				strcpy(remcom_out_buffer, "OK");
+			break;
+
+			/* kill or detach. KGDB should treat this like a
+			 * continue.
+			 */
+		case 'D':
+			if ((error = remove_all_break()) < 0) {
+				error_packet(remcom_out_buffer, error);
+			} else {
+				strcpy(remcom_out_buffer, "OK");
+				kgdb_connected = 0;
+			}
+			put_packet(remcom_out_buffer);
+			goto default_handle;
+
+		case 'k':
+			/* Don't care about error from remove_all_break */
+			remove_all_break();
+			kgdb_connected = 0;
+			goto default_handle;
+
+			/* Reboot */
+		case 'R':
+			/* For now, only honor R0 */
+			if (strcmp(remcom_in_buffer, "R0") == 0) {
+				printk(KERN_CRIT "Executing reboot\n");
+				strcpy(remcom_out_buffer, "OK");
+				put_packet(remcom_out_buffer);
+				emergency_sync();
+				/* Execution should not return from
+				 * machine_restart()
+				 */
+				machine_restart(NULL);
+				kgdb_connected = 0;
+				goto default_handle;
+			}
+
+			/* query */
+		case 'q':
+			switch (remcom_in_buffer[1]) {
+			case 's':
+			case 'f':
+				if (memcmp(remcom_in_buffer + 2, "ThreadInfo",
+					   10)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+
+				/*
+				 * If we have not yet completed in
+				 * pidhash_init() there isn't much we
+				 * can give back.
+				 */
+				/*if (last_pid != 0) {*/
+				if (!pidhash_init_done) {
+					if (remcom_in_buffer[1] == 'f')
+						strcpy(remcom_out_buffer,
+						       "m0000000000000001");
+					break;
+				}
+
+				if (remcom_in_buffer[1] == 'f') {
+					threadid = 1;
+				}
+				remcom_out_buffer[0] = 'm';
+				ptr = remcom_out_buffer + 1;
+				for (i = 0; i < 17 && threadid < pid_max +
+				     numshadowth; threadid++) {
+					thread = getthread(linux_regs,
+							   threadid);
+					if (thread) {
+						int_to_threadref(&thref,
+								 threadid);
+						pack_threadid(ptr, &thref);
+						ptr += 16;
+						*(ptr++) = ',';
+						i++;
+					}
+				}
+				*(--ptr) = '\0';
+				break;
+
+			case 'C':
+				/* Current thread id */
+				strcpy(remcom_out_buffer, "QC");
+
+				threadid = shadow_pid(current->pid);
+
+				int_to_threadref(&thref, threadid);
+				pack_threadid(remcom_out_buffer + 2, &thref);
+				break;
+			case 'T':
+				if (memcmp(remcom_in_buffer + 1,
+					   "ThreadExtraInfo,", 16)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				threadid = 0;
+				ptr = remcom_in_buffer + 17;
+				kgdb_hex2long(&ptr, &threadid);
+				if (!getthread(linux_regs, threadid)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				if (threadid < pid_max) {
+					kgdb_mem2hex(getthread(linux_regs,
+							       threadid)->comm,
+						     remcom_out_buffer, 16);
+				} else if (threadid >= pid_max +
+					   num_online_cpus()) {
+					kgdb_shadowinfo(linux_regs,
+							remcom_out_buffer,
+							threadid - pid_max -
+							num_online_cpus());
+				} else {
+					static char tmpstr[23 +
+							   BUF_THREAD_ID_SIZE];
+					sprintf(tmpstr, "Shadow task %d"
+						" for pid 0",
+						(int)(threadid - pid_max));
+					kgdb_mem2hex(tmpstr, remcom_out_buffer,
+						     strlen(tmpstr));
+				}
+				break;
+			}
+			break;
+
+			/* task related */
+		case 'H':
+			switch (remcom_in_buffer[1]) {
+			case 'g':
+				ptr = &remcom_in_buffer[2];
+				kgdb_hex2long(&ptr, &threadid);
+				thread = getthread(linux_regs, threadid);
+				if (!thread && threadid > 0) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				kgdb_usethread = thread;
+				kgdb_usethreadid = threadid;
+				strcpy(remcom_out_buffer, "OK");
+				break;
+
+			case 'c':
+				ptr = &remcom_in_buffer[2];
+				kgdb_hex2long(&ptr, &threadid);
+				if (!threadid) {
+					kgdb_contthread = NULL;
+				} else {
+					thread = getthread(linux_regs,
+							   threadid);
+					if (!thread && threadid > 0) {
+						error_packet(remcom_out_buffer,
+							     -EINVAL);
+						break;
+					}
+					kgdb_contthread = thread;
+				}
+				strcpy(remcom_out_buffer, "OK");
+				break;
+			}
+			break;
+
+			/* Query thread status */
+		case 'T':
+			ptr = &remcom_in_buffer[1];
+			kgdb_hex2long(&ptr, &threadid);
+			thread = getthread(linux_regs, threadid);
+			if (thread)
+				strcpy(remcom_out_buffer, "OK");
+			else
+				error_packet(remcom_out_buffer, -EINVAL);
+			break;
+		/* Since GDB-5.3, it's been drafted that '0' is a software
+		 * breakpoint, '1' is a hardware breakpoint, so let's do
+		 * that.
+		 */
+		case 'z':
+		case 'Z':
+			bpt_type = &remcom_in_buffer[1];
+			ptr = &remcom_in_buffer[2];
+
+			if (kgdb_ops->set_hw_breakpoint && *bpt_type >= '1') {
+				/* Unsupported */
+				if (*bpt_type > '4')
+					break;
+			} else if (*bpt_type != '0' && *bpt_type != '1')
+				/* Unsupported. */
+				break;
+			/* Test if this is a hardware breakpoint, and
+			 * if we support it. */
+			if (*bpt_type == '1' &&
+			    !kgdb_ops->flags & KGDB_HW_BREAKPOINT)
+				/* Unsupported. */
+				break;
+
+			if (*(ptr++) != ',') {
+				error_packet(remcom_out_buffer, -EINVAL);
+				break;
+			} else if (kgdb_hex2long(&ptr, &addr)) {
+				if (*(ptr++) != ',' ||
+				    !kgdb_hex2long(&ptr, &length)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+			} else {
+				error_packet(remcom_out_buffer, -EINVAL);
+				break;
+			}
+
+			if (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')
+				error = kgdb_set_sw_break(addr);
+			else if (remcom_in_buffer[0] == 'Z' && *bpt_type == '1')
+				error = kgdb_set_hw_break(addr);
+			else if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')
+				error = kgdb_remove_sw_break(addr);
+			else if (remcom_in_buffer[0] == 'z' && *bpt_type == '1')
+				error = kgdb_remove_hw_break(addr);
+			else if (remcom_in_buffer[0] == 'Z')
+				error = kgdb_ops->set_hw_breakpoint(addr,
+								    (int)length,
+								    *bpt_type);
+			else if (remcom_in_buffer[0] == 'z')
+				error = kgdb_ops->remove_hw_breakpoint(addr,
+								       (int)
+								       length,
+								       *bpt_type);
+
+			if (error == 0)
+				strcpy(remcom_out_buffer, "OK");
+			else
+				error_packet(remcom_out_buffer, error);
+
+			break;
+		case 'c':
+		case 's':
+			if (kgdb_contthread && kgdb_contthread != current) {
+				/* Can't switch threads in kgdb */
+				error_packet(remcom_out_buffer, -EINVAL);
+				break;
+			}
+			kgdb_activate_sw_breakpoints();
+			/* Followthrough to default processing */
+		default:
+		      default_handle:
+			error = kgdb_arch_handle_exception(ex_vector, signo,
+							   err_code,
+							   remcom_in_buffer,
+							   remcom_out_buffer,
+							   linux_regs);
+
+			if (error >= 0 || remcom_in_buffer[0] == 'D' ||
+			    remcom_in_buffer[0] == 'k')
+				goto kgdb_exit;
+
+		}		/* switch */
+
+		/* reply to the request */
+		put_packet(remcom_out_buffer);
+	}
+
+      kgdb_exit:
+	/* Call the I/O driver's post_exception routine if the I/O
+	 * driver defined one.
+	 */
+	if (kgdb_io_ops.post_exception)
+		kgdb_io_ops.post_exception();
+
+	kgdb_info[processor].debuggerinfo = NULL;
+	kgdb_info[processor].task = NULL;
+	atomic_set(&procindebug[processor], 0);
+
+	if (!debugger_step || !kgdb_contthread) {
+		for (i = 0; i < NR_CPUS; i++)
+			spin_unlock(&slavecpulocks[i]);
+		/* Wait till all the processors have quit
+		 * from the debugger. */
+		for (i = 0; i < NR_CPUS; i++) {
+			while (atomic_read(&procindebug[i])) {
+				int j = 10;	/* an arbitrary number */
+
+				while (--j)
+					cpu_relax();
+			}
+		}
+	}
+
+#ifdef CONFIG_SMP
+	/* This delay has a real purpose.  The problem is that if you
+	 * are single-stepping, you are sending an NMI to all the
+	 * other processors to stop them.  Interrupts come in, but
+	 * don't get handled.  Then you let them go just long enough
+	 * to get into their interrupt routines and use up some stack.
+	 * You stop them again, and then do the same thing.  After a
+	 * while you blow the stack on the other processors.  This
+	 * delay gives some time for interrupts to be cleared out on
+	 * the other processors.
+	 */
+	if (debugger_step)
+		mdelay(2);
+#endif
+kgdb_restore:
+	/* Free debugger_active */
+	atomic_set(&debugger_active, 0);
+	local_irq_restore(flags);
+
+	return error;
+}
+
+/*
+ * GDB places a breakpoint at this function to know dynamically
+ * loaded objects. It's not defined static so that only one instance with this
+ * name exists in the kernel.
+ */
+
+int module_event(struct notifier_block *self, unsigned long val, void *data)
+{
+	return 0;
+}
+
+static struct notifier_block kgdb_module_load_nb = {
+	.notifier_call = module_event,
+};
+
+void kgdb_nmihook(int cpu, void *regs)
+{
+#ifdef CONFIG_SMP
+	if (!atomic_read(&procindebug[cpu]) && atomic_read(&debugger_active) != (cpu + 1))
+		kgdb_wait((struct pt_regs *)regs);
+#endif
+}
+
+/*
+ * This is called when a panic happens.  All we need to do is
+ * breakpoint().
+ */
+static int kgdb_panic_notify(struct notifier_block *self, unsigned long cmd,
+			     void *ptr)
+{
+	breakpoint();
+
+	return 0;
+}
+
+static struct notifier_block kgdb_panic_notifier = {
+	.notifier_call = kgdb_panic_notify,
+};
+
+/*
+ * Initialization that needs to be done in either of our entry points.
+ */
+static void __init kgdb_internal_init(void)
+{
+	int i;
+
+	/* Initialize our spinlocks. */
+	for (i = 0; i < NR_CPUS; i++)
+		spin_lock_init(&slavecpulocks[i]);
+
+	for (i = 0; i < MAX_BREAKPOINTS; i++)
+		kgdb_break[i].state = bp_none;
+
+	/* Initialize the I/O handles */
+	memset(&kgdb_io_ops_prev, 0, sizeof(kgdb_io_ops_prev));
+
+	/* We can't do much if this fails */
+	register_module_notifier(&kgdb_module_load_nb);
+
+	kgdb_initialized = 1;
+}
+
+static void kgdb_register_for_panic(void)
+{
+	/* Register for panics(). */
+	/* The registration is done in the kgdb_register_for_panic
+	 * routine because KGDB should not try to handle a panic when
+	 * there are no kgdb_io_ops setup. It is assumed that the
+	 * kgdb_io_ops are setup at the time this method is called.
+	 */
+	if (!kgdb_from_module_registered) {
+		atomic_notifier_chain_register(&panic_notifier_list,
+					&kgdb_panic_notifier);
+		kgdb_from_module_registered = 1;
+	}
+}
+
+static void kgdb_unregister_for_panic(void)
+{
+	/* When this routine is called KGDB should unregister from the
+	 * panic handler and clean up, making sure it is not handling any
+	 * break exceptions at the time.
+	 */
+	if (kgdb_from_module_registered) {
+		kgdb_from_module_registered = 0;
+		atomic_notifier_chain_unregister(&panic_notifier_list,
+					  &kgdb_panic_notifier);
+	}
+}
+
+int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops)
+{
+
+	if (kgdb_connected) {
+		printk(KERN_ERR "kgdb: Cannot load I/O module while KGDB "
+		       "connected.\n");
+		return -EINVAL;
+	}
+
+	/* Save the old values so they can be restored */
+	if (kgdb_io_handler_cnt >= MAX_KGDB_IO_HANDLERS) {
+		printk(KERN_ERR "kgdb: No more I/O handles available.\n");
+		return -EINVAL;
+	}
+
+	/* Check to see if there is an existing driver and if so save its
+	 * values.  Also check to make sure the same driver was not trying
+	 * to re-register.
+	 */
+	if (kgdb_io_ops.read_char != NULL &&
+        kgdb_io_ops.read_char != local_kgdb_io_ops->read_char) {
+		memcpy(&kgdb_io_ops_prev[kgdb_io_handler_cnt],
+		       &kgdb_io_ops, sizeof(struct kgdb_io));
+		kgdb_io_handler_cnt++;
+	}
+
+	/* Initialize the io values for this module */
+	memcpy(&kgdb_io_ops, local_kgdb_io_ops, sizeof(struct kgdb_io));
+
+	/* Make the call to register kgdb if is not initialized */
+	kgdb_register_for_panic();
+
+	return 0;
+}
+
+void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops)
+{
+	int i;
+
+	/* Unregister KGDB if there were no other prior io hooks, else
+	 * restore the io hooks.
+	 */
+	if (kgdb_io_handler_cnt > 0 && kgdb_io_ops_prev[0].read_char != NULL) {
+		/* First check if the hook that is in use is the one being
+		 * removed */
+		if (kgdb_io_ops.read_char == local_kgdb_io_ops->read_char) {
+			/* Set 'i' to the value of where the list should be
+			 * shifed */
+			i = kgdb_io_handler_cnt - 1;
+			memcpy(&kgdb_io_ops, &kgdb_io_ops_prev[i],
+			       sizeof(struct kgdb_io));
+		} else {
+			/* Simple case to remove an entry for an I/O handler
+			 * that is not in use */
+			for (i = 0; i < kgdb_io_handler_cnt; i++) {
+				if (kgdb_io_ops_prev[i].read_char ==
+				    local_kgdb_io_ops->read_char)
+					break;
+			}
+		}
+
+		/* Shift all the entries in the handler array so it is
+		 * ordered from oldest to newest.
+		 */
+		kgdb_io_handler_cnt--;
+		for (; i < kgdb_io_handler_cnt; i++) {
+			memcpy(&kgdb_io_ops_prev[i], &kgdb_io_ops_prev[i + 1],
+			       sizeof(struct kgdb_io));
+		}
+		/* Handle the case if we are on the last element and set it
+		 * to NULL; */
+		memset(&kgdb_io_ops_prev[kgdb_io_handler_cnt], 0,
+				sizeof(struct kgdb_io));
+
+		if (kgdb_connected)
+			printk(KERN_ERR "kgdb: WARNING: I/O method changed "
+			       "while kgdb was connected state.\n");
+	} else {
+		/* KGDB is no longer able to communicate out, so
+		 * unregister our hooks and reset state. */
+		kgdb_unregister_for_panic();
+		if (kgdb_connected) {
+			printk(KERN_CRIT "kgdb: I/O module was unloaded while "
+					"a debugging session was running.  "
+					"KGDB will be reset.\n");
+			if (remove_all_break() < 0)
+				printk(KERN_CRIT "kgdb: Reset failed.\n");
+			kgdb_connected = 0;
+		}
+		memset(&kgdb_io_ops, 0, sizeof(struct kgdb_io));
+	}
+}
+
+/*
+ * There are times we need to call a tasklet to cause a breakpoint
+ * as calling breakpoint() at that point might be fatal.  We have to
+ * check that the exception stack is setup, as tasklets may be scheduled
+ * prior to this.  When that happens, it is up to the architecture to
+ * schedule this when it is safe to run.
+ */
+static void kgdb_tasklet_bpt(unsigned long ing)
+{
+	breakpoint();
+}
+
+DECLARE_TASKLET(kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0);
+
+/*
+ * This function can be called very early, either via early_param() or
+ * an explicit breakpoint() early on.
+ */
+static void __init kgdb_early_entry(void)
+{
+	/* Let the architecture do any setup that it needs to. */
+	kgdb_arch_init();
+
+	/* Now try the I/O. */
+	/* For early entry kgdb_io_ops.init must be defined */
+	if (!kgdb_io_ops.init || kgdb_io_ops.init()) {
+		/* Try again later. */
+		kgdb_initialized = -1;
+		return;
+	}
+
+	/* Finish up. */
+	kgdb_internal_init();
+
+	/* KGDB can assume that if kgdb_io_ops.init was defined that the
+	 * panic registion should be performed at this time. This means
+	 * kgdb_io_ops.init did not come from a kernel module and was
+	 * initialized statically by a built in.
+	 */
+	if (kgdb_io_ops.init)
+		kgdb_register_for_panic();
+}
+
+/*
+ * This function will always be invoked to make sure that KGDB will grab
+ * what it needs to so that if something happens while the system is
+ * running, KGDB will get involved.  If kgdb_early_entry() has already
+ * been invoked, there is little we need to do.
+ */
+static int __init kgdb_late_entry(void)
+{
+	int need_break = 0;
+
+	/* If kgdb_initialized is -1 then we were passed kgdbwait. */
+	if (kgdb_initialized == -1)
+		need_break = 1;
+	/*
+	 * If we haven't tried to initialize KGDB yet, we need to call
+	 * kgdb_arch_init before moving onto the I/O.
+	 */
+	if (!kgdb_initialized)
+		kgdb_arch_init();
+
+	if (kgdb_initialized != 1) {
+		if (kgdb_io_ops.init && kgdb_io_ops.init()) {
+			/* When KGDB allows I/O via modules and the core
+			 * I/O init fails KGDB must default to defering the
+			 * I/O setup, and appropriately print an error about
+			 * it.
+			 */
+			printk(KERN_ERR "kgdb: Could not setup core I/O "
+			       "for KGDB.\n");
+			printk(KERN_INFO "kgdb: Defering I/O setup to kernel "
+			       "module.\n");
+			memset(&kgdb_io_ops, 0, sizeof(struct kgdb_io));
+		}
+
+		kgdb_internal_init();
+
+		/* KGDB can assume that if kgdb_io_ops.init was defined that
+		 * panic registion should be performed at this time. This means
+		 * kgdb_io_ops.init did not come from a kernel module and was
+		 * initialized statically by a built in.
+		 */
+		if (kgdb_io_ops.init)
+			kgdb_register_for_panic();
+	}
+
+	/* Registering to reboot notifier list*/
+	register_reboot_notifier(&kgdb_reboot_notifier);
+
+	/* Now do any late init of the I/O. */
+	if (kgdb_io_ops.late_init)
+		kgdb_io_ops.late_init();
+
+	if (need_break) {
+		printk(KERN_CRIT "kgdb: Waiting for connection from remote"
+		       " gdb...\n");
+		breakpoint();
+	}
+
+	return 0;
+}
+
+late_initcall(kgdb_late_entry);
+
+/*
+ * This function will generate a breakpoint exception.  It is used at the
+ * beginning of a program to sync up with a debugger and can be used
+ * otherwise as a quick means to stop program execution and "break" into
+ * the debugger.
+ */
+void breakpoint(void)
+{
+	if (kgdb_initialized != 1) {
+		kgdb_early_entry();
+		if (kgdb_initialized == 1)
+			printk(KERN_CRIT "Waiting for connection from remote "
+			       "gdb...\n");
+		else {
+			printk(KERN_CRIT "KGDB cannot initialize I/O yet.\n");
+			return;
+		}
+	}
+
+	atomic_set(&kgdb_setting_breakpoint, 1);
+	wmb();
+	BREAKPOINT();
+	wmb();
+	atomic_set(&kgdb_setting_breakpoint, 0);
+}
+
+EXPORT_SYMBOL(breakpoint);
+
+#ifdef CONFIG_MAGIC_SYSRQ
+static void sysrq_handle_gdb(int key, struct pt_regs *pt_regs,
+			     struct tty_struct *tty)
+{
+	printk("Entering GDB stub\n");
+	breakpoint();
+}
+static struct sysrq_key_op sysrq_gdb_op = {
+	.handler = sysrq_handle_gdb,
+	.help_msg = "Gdb",
+	.action_msg = "GDB",
+};
+
+static int gdb_register_sysrq(void)
+{
+	printk("Registering GDB sysrq handler\n");
+	register_sysrq_key('g', &sysrq_gdb_op);
+	return 0;
+}
+
+module_init(gdb_register_sysrq);
+#endif
+
+static int kgdb_notify_reboot(struct notifier_block *this,
+                            unsigned long code, void *x)
+{
+
+	unsigned long flags;
+
+	/* If we're debugging, or KGDB has not connected, don't try
+	 * and print. */
+	if (!kgdb_connected || atomic_read(&debugger_active) != 0)
+		return 0;
+	if ((code == SYS_RESTART) || (code == SYS_HALT) || (code == SYS_POWER_OFF)){
+		local_irq_save(flags);
+		put_packet("X00");
+		local_irq_restore(flags);
+	}
+	return NOTIFY_DONE;
+}
+
+#ifdef CONFIG_KGDB_CONSOLE
+void kgdb_console_write(struct console *co, const char *s, unsigned count)
+{
+	unsigned long flags;
+
+	/* If we're debugging, or KGDB has not connected, don't try
+	 * and print. */
+	if (!kgdb_connected || atomic_read(&debugger_active) != 0)
+		return;
+
+	local_irq_save(flags);
+	kgdb_msg_write(s, count);
+	local_irq_restore(flags);
+}
+
+struct console kgdbcons = {
+	.name = "kgdb",
+	.write = kgdb_console_write,
+	.flags = CON_PRINTBUFFER | CON_ENABLED,
+};
+static int __init kgdb_console_init(void)
+{
+	register_console(&kgdbcons);
+	return 0;
+}
+
+console_initcall(kgdb_console_init);
+#endif
+
+static int __init opt_kgdb_enter(char *str)
+{
+	/* We've already done this by an explicit breakpoint() call. */
+	if (kgdb_initialized)
+		return 0;
+
+	if (!pidhash_init_done)
+		force_pidhash_init();
+
+	/* Call breakpoint() which will take care of init. */
+	breakpoint();
+
+	return 0;
+}
+
+early_param("kgdbwait", opt_kgdb_enter);
diff -uprN -X  linux-orig/kernel/Makefile linux-kgdb/kernel/Makefile
--- linux-orig/kernel/Makefile	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/kernel/Makefile	2006-09-01 08:34:22.000000000 +0000
@@ -32,6 +32,7 @@ obj-$(CONFIG_STOP_MACHINE) += stop_machi
 obj-$(CONFIG_AUDIT) += audit.o auditfilter.o
 obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
 obj-$(CONFIG_KPROBES) += kprobes.o
+obj-$(CONFIG_KGDB) += kgdb.o
 obj-$(CONFIG_SYSFS) += ksysfs.o
 obj-$(CONFIG_DETECT_SOFTLOCKUP) += softlockup.o
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
diff -uprN -X  linux-orig/kernel/module.c linux-kgdb/kernel/module.c
--- linux-orig/kernel/module.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/kernel/module.c	2006-09-01 08:35:47.000000000 +0000
@@ -63,6 +63,7 @@ static DEFINE_SPINLOCK(modlist_lock);
 /* List of modules, protected by module_mutex AND modlist_lock */
 static DEFINE_MUTEX(module_mutex);
 static LIST_HEAD(modules);
+static DECLARE_MUTEX(notify_mutex);
 
 static BLOCKING_NOTIFIER_HEAD(module_notify_list);
 
@@ -644,6 +645,12 @@ sys_delete_module(const char __user *nam
 	if (ret != 0)
 		goto out;
 
+	down(&notify_mutex);
+	blocking_notifier_call_chain(&module_notify_list, MODULE_STATE_GOING,
+        			mod);
+	up(&notify_mutex);
+
+
 	/* Never wait if forced. */
 	if (!forced && module_refcount(mod) != 0)
 		wait_for_zero_refcount(mod);
@@ -656,6 +663,11 @@ sys_delete_module(const char __user *nam
 	}
 	free_module(mod);
 
+	down(&notify_mutex);
+	blocking_notifier_call_chain(&module_notify_list, MODULE_STATE_GONE,
+			NULL);
+	up(&notify_mutex);
+
  out:
 	mutex_unlock(&module_mutex);
 	return ret;
@@ -1054,6 +1066,11 @@ static void free_module(struct module *m
 	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
 
+#ifdef CONFIG_KGDB
+	/* kgdb info */
+	vfree(mod->mod_sections);
+#endif
+
 	/* Module unload stuff */
 	module_unload_free(mod);
 
@@ -1320,6 +1337,31 @@ static void setup_modinfo(struct module 
 	}
 }
 
+#ifdef CONFIG_KGDB
+int add_modsects (struct module *mod, Elf_Ehdr *hdr, Elf_Shdr *sechdrs, const
+                char *secstrings)
+{
+        int i;
+
+        mod->num_sections = hdr->e_shnum - 1;
+        mod->mod_sections = vmalloc((hdr->e_shnum - 1)*
+		sizeof (struct mod_section));
+
+        if (mod->mod_sections == NULL) {
+                return -ENOMEM;
+        }
+
+        for (i = 1; i < hdr->e_shnum; i++) {
+                mod->mod_sections[i - 1].address = (void *)sechdrs[i].sh_addr;
+                strncpy(mod->mod_sections[i - 1].name, secstrings +
+                                sechdrs[i].sh_name, MAX_SECTNAME);
+                mod->mod_sections[i - 1].name[MAX_SECTNAME] = '\0';
+	}
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_KALLSYMS
 int is_exported(const char *name, const struct module *mod)
 {
@@ -1692,6 +1734,12 @@ static struct module *load_module(void _
 
 	add_kallsyms(mod, sechdrs, symindex, strindex, secstrings);
 
+#ifdef CONFIG_KGDB
+        if ((err = add_modsects(mod, hdr, sechdrs, secstrings)) < 0) {
+                goto nomodsectinfo;
+        }
+#endif
+
 	err = module_finalize(hdr, sechdrs, mod);
 	if (err < 0)
 		goto cleanup;
@@ -1747,6 +1795,11 @@ static struct module *load_module(void _
  arch_cleanup:
 	module_arch_cleanup(mod);
  cleanup:
+
+#ifdef CONFIG_KGDB
+nomodsectinfo:
+       vfree(mod->mod_sections);
+#endif
 	module_unload_free(mod);
 	module_free(mod, mod->module_init);
  free_core:
@@ -1818,6 +1871,10 @@ sys_init_module(void __user *umod,
 		/* Init routine failed: abort.  Try to protect us from
                    buggy refcounters. */
 		mod->state = MODULE_STATE_GOING;
+		down(&notify_mutex);
+		blocking_notifier_call_chain(&module_notify_list, MODULE_STATE_GOING,
+				mod);
+		up(&notify_mutex);
 		synchronize_sched();
 		if (mod->unsafe)
 			printk(KERN_ERR "%s: module is now stuck!\n",
diff -uprN -X  linux-orig/kernel/pid.c linux-kgdb/kernel/pid.c
--- linux-orig/kernel/pid.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/kernel/pid.c	2006-09-06 12:19:59.839071000 +0000
@@ -301,11 +301,31 @@ struct pid *find_get_pid(pid_t nr)
  * machine.  From a minimum of 16 slots up to 4096 slots at one gigabyte or
  * more.
  */
+#ifdef CONFIG_KGDB
+int pidhash_init_done = 0;
+
+void __init pidhash_init(void);
+
+void force_pidhash_init(void)
+{
+	/* if KGDB starts early, we need to force the 
+	   pidhash initialization. For example that allows you 
+	   to get the thread information at this time. */
+	pidhash_init();
+	pidhash_init_done = 1;
+}
+#endif
+
 void __init pidhash_init(void)
 {
 	int i, pidhash_size;
 	unsigned long megabytes = nr_kernel_pages >> (20 - PAGE_SHIFT);
 
+#ifdef CONFIG_KGDB
+	if (pidhash_init_done)
+		return;
+#endif
+
 	pidhash_shift = max(4, fls(megabytes * 4));
 	pidhash_shift = min(12, pidhash_shift);
 	pidhash_size = 1 << pidhash_shift;
@@ -323,6 +343,7 @@ void __init pidhash_init(void)
 
 void __init pidmap_init(void)
 {
+//#ifndef CONFIG_KGDB
 	pidmap_array->page = (void *)get_zeroed_page(GFP_KERNEL);
 	/* Reserve PID 0. We never call free_pidmap(0) */
 	set_bit(0, pidmap_array->page);
@@ -331,4 +352,5 @@ void __init pidmap_init(void)
 	pid_cachep = kmem_cache_create("pid", sizeof(struct pid),
 					__alignof__(struct pid),
 					SLAB_PANIC, NULL, NULL);
+//#endif
 }
diff -uprN -X  linux-orig/kernel/sched.c linux-kgdb/kernel/sched.c
--- linux-orig/kernel/sched.c	2006-08-31 13:42:04.000000000 +0000
+++ linux-kgdb/kernel/sched.c	2006-09-01 08:34:22.000000000 +0000
@@ -50,6 +50,7 @@
 #include <linux/times.h>
 #include <linux/acct.h>
 #include <linux/kprobes.h>
+#include <linux/kgdb.h>
 #include <asm/tlb.h>
 
 #include <asm/unistd.h>
@@ -6163,6 +6164,9 @@ void __might_sleep(char *file, int line)
 #if defined(in_atomic)
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
+	if (atomic_read(&debugger_active))
+		return;
+
 	if ((in_atomic() || irqs_disabled()) &&
 	    system_state == SYSTEM_RUNNING && !oops_in_progress) {
 		if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
diff -uprN -X  linux-orig/kernel/softlockup.c linux-kgdb/kernel/softlockup.c
--- linux-orig/kernel/softlockup.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/kernel/softlockup.c	2006-09-01 08:35:52.000000000 +0000
@@ -13,6 +13,7 @@
 #include <linux/kthread.h>
 #include <linux/notifier.h>
 #include <linux/module.h>
+#include <linux/kgdb.h>
 
 static DEFINE_SPINLOCK(print_lock);
 
@@ -37,6 +38,9 @@ static struct notifier_block panic_block
 void touch_softlockup_watchdog(void)
 {
 	per_cpu(touch_timestamp, raw_smp_processor_id()) = jiffies;
+#ifdef CONFIG_KGDB
+	atomic_set(&kgdb_sync_softlockup[raw_smp_processor_id()], 0);
+#endif
 }
 EXPORT_SYMBOL(touch_softlockup_watchdog);
 
diff -uprN -X  linux-orig/kernel/timer.c linux-kgdb/kernel/timer.c
--- linux-orig/kernel/timer.c	2006-06-18 01:49:35.000000000 +0000
+++ linux-kgdb/kernel/timer.c	2006-09-01 08:35:52.000000000 +0000
@@ -34,6 +34,7 @@
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
 #include <linux/delay.h>
+#include <linux/kgdb.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -906,7 +907,11 @@ static void run_timer_softirq(struct sof
  */
 void run_local_timers(void)
 {
+	int this_cpu = smp_processor_id();
 	raise_softirq(TIMER_SOFTIRQ);
+#ifdef CONFIG_KGDB
+	if(!atomic_read(&kgdb_sync_softlockup[this_cpu]))
+#endif
 	softlockup_tick();
 }
 
diff -uprN -X  linux-orig/lib/Kconfig.debug linux-kgdb/lib/Kconfig.debug
--- linux-orig/lib/Kconfig.debug	2006-08-31 13:42:11.000000000 +0000
+++ linux-kgdb/lib/Kconfig.debug	2006-09-21 07:16:01.528464000 +0000
@@ -223,3 +223,122 @@ config RCU_TORTURE_TEST
 	  at boot time (you probably don't).
 	  Say M if you want the RCU torture tests to build as a module.
 	  Say N if you are unsure.
+
+config WANT_EXTRA_DEBUG_INFORMATION
+	bool
+	select DEBUG_INFO
+	select FRAME_POINTER if X86
+	default n
+
+config KGDB
+	bool "KGDB: kernel debugging with remote gdb"
+	select WANT_EXTRA_DEBUG_INFORMATION
+	depends on DEBUG_KERNEL
+	help
+	  If you say Y here, it will be possible to remotely debug the
+	  kernel using gdb. It is strongly suggested that you enable
+	  DEBUG_INFO, and if available on your platform, FRAME_POINTER.
+	  Documentation of kernel debugger available at
+	  http://kgdb.sourceforge.net as well as in DocBook form
+	  in Documentation/DocBook/.  If unsure, say N.
+
+config KGDB_CONSOLE
+	bool "KGDB: Console messages through gdb"
+	depends on KGDB
+	  help
+	    If you say Y here, console messages will appear through gdb.
+	    Other consoles such as tty or ttyS will continue to work as usual.
+	    Note, that if you use this in conjunction with KGDBOE, if the
+	    ethernet driver runs into an error condition during use with KGDB
+	    it is possible to hit an infinite recusrion, causing the kernel
+	    to crash, and typically reboot.  For this reason, it is preferable
+	    to use NETCONSOLE in conjunction with KGDBOE instead of
+	    KGDB_CONSOLE.
+
+choice
+	prompt "Method for KGDB communication"
+	depends on KGDB
+	default KGDB_ST_DCU
+	help
+	  There are a number of different ways in which you can communicate
+	  with KGDB.  The most common is via serial, with the 8250 driver
+	  (should your hardware have an 8250, or ns1655x style uart).
+	  Another option is to use the NETPOLL framework and UDP, should
+	  your ethernet card support this.  Other options may exist.
+	  You can elect to have one core I/O driver that is built into the
+	  kernel for debugging as the kernel is booting, or using only
+	  kernel modules.
+
+config KGDB_ST_DCU
+        bool "KGDB: On ST DCU interface"
+        depends on CPU_SUBTYPE_ST40
+        help
+	  It is a new method available for the STM architectures.
+          It uses the Micro-connect interface as communication port.
+
+config KGDBOE
+        bool "KGDB: On ethernet"
+        select NETPOLL
+        select NETPOLL_TRAP
+        select NETPOLL_RX
+        help
+          Uses the NETPOLL API to communicate with the host GDB via UDP.
+          In order for this to work, the ethernet interface specified must
+          support the NETPOLL API, and this must be initialized at boot.
+          See the documentation for syntax.
+
+config KGDB_ST_ASC
+        bool "KGDB: On ST ASC port"
+        depends on SERIAL_ST_ASC
+        help
+          Uses the ASC port found on the STM boards.
+
+endchoice
+
+config KGDB_SIMPLE_SERIAL
+	bool "Simple selection of KGDB serial port"
+	depends on KGDB_8250 || KGDB_SH_SCI || KGDB_ST_ASC
+	help
+	  If you say Y here, you will only have to pick the baud rate
+	  and serial port (ttyS) that you wish to use for KGDB.  If you
+	  say N, you will have provide the I/O port and IRQ number.  Note
+	  that if your serial ports are iomapped, such as on ia64, then
+	  you must say Y here.  If in doubt, say Y.
+
+choice
+	depends on KGDB_8250 || KGDB_SH_SCI || KGDB_ST_ASC
+    	prompt "Debug serial port BAUD"
+	default KGDB_115200BAUD
+	help
+	  gdb and the kernel stub need to agree on the baud rate to be
+	  used.  Standard rates from 9600 to 115200 are allowed, and this
+	  may be overridden via the commandline.
+
+config KGDB_9600BAUD
+	bool "9600"
+
+config KGDB_19200BAUD
+	bool "19200"
+
+config KGDB_38400BAUD
+	bool "38400"
+
+config KGDB_57600BAUD
+	bool "57600"
+
+config KGDB_115200BAUD
+	bool "115200"
+endchoice
+
+choice
+	prompt "Serial port for KGDB"
+	depends on KGDB_SIMPLE_SERIAL
+	default KGDB_TTYS0
+
+config KGDB_TTYS0
+	bool "ttyS0"
+
+config KGDB_TTYS1
+	bool "ttyS1"
+
+endchoice
diff -uprN -X  linux-orig/MAINTAINERS linux-kgdb/MAINTAINERS
--- linux-orig/MAINTAINERS	2006-08-31 13:42:03.000000000 +0000
+++ linux-kgdb/MAINTAINERS	2006-09-01 08:34:22.000000000 +0000
@@ -1616,6 +1616,15 @@ L:	linux-kernel@vger.kernel.org
 L:	fastboot@osdl.org
 S:	Maintained
 
+KGDB
+P:	Tom Rini
+P:	Amit S. Kale
+M:	trini@kernel.crashing.org
+M:	amitkale@linsyssoft.com
+W:	http://sourceforge.net/projects/kgdb
+L:	kgdb-bugreport@lists.sourceforge.net
+S:	Maintained
+
 KPROBES
 P:	Prasanna S Panchamukhi
 M:	prasanna@in.ibm.com
diff -uprN -X  linux-orig/net/core/netpoll.c linux-kgdb/net/core/netpoll.c
--- linux-orig/net/core/netpoll.c	2006-08-31 13:42:11.000000000 +0000
+++ linux-kgdb/net/core/netpoll.c	2006-09-01 08:34:22.000000000 +0000
@@ -509,7 +509,8 @@ int __netpoll_rx(struct sk_buff *skb)
 
 	np->rx_hook(np, ntohs(uh->source),
 		    (char *)(uh+1),
-		    ulen - sizeof(struct udphdr));
+		    ulen - sizeof(struct udphdr),
+		    skb);
 
 	kfree_skb(skb);
 	return 1;
Binary files linux-orig/vmlinux.kgdb and linux-kgdb/vmlinux.kgdb differ
