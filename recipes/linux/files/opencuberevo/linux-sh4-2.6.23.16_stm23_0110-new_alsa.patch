commit 9e35b20f37cfc6331d14ebbfa3686145cf8e1454
Author: Pawel Moll <pawel.moll@st.com>
Date:   Fri May 9 10:46:50 2008 +0100

    Major rework of ALSA driver.
    
    - Moved back to sound/stm directory.
    - Registers database removed from include/linux/stm/registers*.
    - All PCM devices are now members of one card
      (with dynamically allocated minors).
    - Platform drivers are separated.
    - IP drivers are runtime-configurable now.
    - 7200 cut 2.0 is supported.
    - A lot of minor fixes.
    
    (linux-sh4-2.6.23.16_stm23_0110-new_alsa.patch)
    
    Signed-off-by: Pawel Moll <pawel.moll@st.com>

diff --git a/include/linux/stm/registers.h b/include/linux/stm/registers.h
deleted file mode 100644
index fd752de..0000000
--- a/include/linux/stm/registers.h
+++ /dev/null
@@ -1,100 +0,0 @@
-#ifndef __LINUX_STM_REGISTERS_H
-#define __LINUX_STM_REGISTERS_H
-
-#include <asm/io.h>
-
-
-
-/* Register access macros */
-
-#define REGISTER_PEEK(base, reg) \
-		readl(base + reg)
-
-#define REGISTER_PEEK_N(base, reg, n) \
-		readl(base + reg(n))
-
-#define REGISTER_POKE(base, reg, u32value) \
-		writel(u32value, base + reg)
-
-#define REGISTER_POKE_N(base, reg, n, u32value) \
-		writel(u32value, base + reg(n))
-
-
-
-/* Field raw access macros */
-
-#define REGFIELD_PEEK(base, reg, field) \
-		regfield_peek(base, reg, reg##__##field##__SHIFT, \
-				reg##__##field##__MASK)
-
-#define REGFIELD_PEEK_N(base, reg, n, field) \
-		regfield_peek(base, reg(n), reg##__##field##__SHIFT, \
-				reg##__##field##__MASK)
-
-#define REGFIELD_POKE(base, reg, field, u32value) \
-		regfield_poke(base, reg, reg##__##field##__SHIFT, \
-				reg##__##field##__MASK, u32value)
-
-#define REGFIELD_POKE_N(base, reg, n, field, u32value) \
-		regfield_poke(base, reg(n), reg##__##field##__SHIFT, \
-				reg##__##field##__MASK, u32value)
-
-
-
-/* Field named values access macro */
-
-#define REGFIELD_SET(base, reg, field, valuename) \
-		regfield_poke(base, reg, reg##__##field##__SHIFT, \
-				reg##__##field##__MASK, reg##__##field##__VALUE__##valuename)
-
-#define REGFIELD_SET_N(base, reg, n, field, valuename) \
-		regfield_poke(base, reg(n), reg##__##field##__SHIFT, \
-				reg##__##field##__MASK, reg##__##field##__VALUE__##valuename)
-
-
-
-/* Bitmask generator macros */
-
-#define REGFIELD_MASK(reg, field) \
-		(reg##__##field##__MASK << reg##__##field##__SHIFT)
-
-#define REGFIELD_VALUE(reg, field, valuename) \
-		(reg##__##field##__VALUE__##valuename << reg##__##field##__SHIFT)
-
-
-
-/* Register fields runtime access */
-
-static inline unsigned long regfield_peek(void *base, unsigned long offset,
-		int shift, unsigned long mask)
-{
-	return ((readl(base + offset) >> shift) & mask);
-}
-
-static inline void regfield_poke(void *base, unsigned long offset,
-		int shift, unsigned long mask, unsigned long value)
-{
-	writel(((readl(base + offset) & ~(mask << shift)) |
-				((value & mask) << shift)), base + offset);
-}
-
-
-
-/* COMMs registers definitions */
-
-#include <linux/stm/registers/asc.h>
-#include <linux/stm/registers/pwm.h>
-
-/* Audio registers definitions */
-
-#include <linux/stm/registers/aud_pcmin.h>
-#include <linux/stm/registers/aud_pcmout.h>
-#include <linux/stm/registers/aud_spdif.h>
-#include <linux/stm/registers/aud_spdifpc.h>
-#include <linux/stm/registers/audcfg.h>
-#include <linux/stm/registers/audcfg_adac.h>
-#include <linux/stm/registers/audcfg_fsyn.h>
-
-
-
-#endif
diff --git a/include/linux/stm/registers/asc.h b/include/linux/stm/registers/asc.h
deleted file mode 100644
index 55e58bc..0000000
--- a/include/linux/stm/registers/asc.h
+++ /dev/null
@@ -1,350 +0,0 @@
-#ifndef __STM_REGISTERS_ASC_H
-#define __STM_REGISTERS_ASC_H
-
-
-
-/* ASC baudrate generator */
-
-#define ASC_BAUDRATE 0x00 /* RW, reset value: 1 */
-/* This register is the dual function baudrate generator and reload value register. A read
- * from this register returns the content of the 16-bit counter/accumulator; writing to it
- * updates the 16-bit reload register.
- * If bit ASC_CTRL.RUN is 1, then any value written in the ASC_BaudRate register
- * is immediately copied to the timer. However, if the RUN bit is 0 when the register is
- * written, then the timer is not reloaded until the first comms clock cycle after the RUN
- * bit is 1.
- * The mode of operation of the baudrate generator depends on the setting of bit
- * ASC_CTRL.BAUDMODE.
- * Mode 0
- * When bit ASC_CTRL.BAUDMODE is set to 0, the baudrate and the required reload
- * value for a given baudrate can be determined by the following formulae:
- * where: ASCBaudRate represents the content of the ASC_BaudRate register,
- * taken as an unsigned 16-bit integer.
- * fcomms is the frequency of the comms clock (clock channel CLK_IC_DIV2).
- * Mode 0 should be used for all baudrates below 19.2 Kbaud.
- * Table 39 lists commonly used baudrates with the required reload values and the
- * approximate deviation errors for an example baudrate with a comms clock of
- * 100 MHz.
- * Mode 1
- * When bit ASC_CTRL.BAUDMODE is set to 1, the baudrate is given by:
- * where: fcomms is the comms clock frequency and ASCBaudRate is the value written to
- * the ASC_BaudRate register. Mode 1 should be used for baudrates of 19.2 Kbytes
- * and above as it has a lower deviation error than mode 0 at higher frequencies. */
-
-#define ASC_BAUDRATE__RELOAD_VAL__SHIFT 0
-#define ASC_BAUDRATE__RELOAD_VAL__MASK  0x0000ffff
-
-
-
-/* ASC transmit buffer */
-
-#define ASC_TX_BUF 0x04 /* W, reset value: 0 */
-/* A transmission is started by writing to the transmit buffer register ASC_TX_BUF.
- * Serial data transmission is only possible when the baudrate generator bit
- * ASC_CTRL.RUN is set to 1.
- * Data transmission is double buffered or uses a FIFO, so a new character may be
- * written to the transmit buffer register before the transmission of the previous
- * character is complete. This allows characters to be sent back to back without gaps. */
-
-#define ASC_TX_BUF__TD__SHIFT 0
-#define ASC_TX_BUF__TD__MASK  0x000001ff
-/* TD[8]:
- * Transmit buffer data D8, or parity bit, or wake up bit or undefined depending on the operating
- * mode (the setting of field ASC_CTRL.MODE).
- * If the MODE field selects an 8-bit frame then this bit should be written as 0.
- * TD[7]:
- * Transmit buffer data D7, or parity bit depending on the operating mode (the setting of field
- * ASC_CTRL.MODE).
- * TD[6:0]: transmit buffer data D6 to D0 */
-
-
-
-/* ASC receive buffer */
-
-#define ASC_RX_BUF 0x08 /* R, reset value: 0 */
-/* Serial data reception is only possible when the baudrate generator bit
- * ASC_CTRL.RUN is set to 1. */
-
-#define ASC_RX_BUF__RD__SHIFT 0
-#define ASC_RX_BUF__RD__MASK  0x000001ff
-/* RD[8]:
- * Receive buffer data D8, or parity error bit, or wake up bit depending on the operating mode (the
- * setting of field ASC_CTRL.MODE)
- * If the MODE field selects an 8-bit frame then this bit is undefined. Software should ignore this
- * bit when reading 8-bit frames
- * RD[7]:
- * Receive buffer data D7, or parity error bit depending on the operating mode (the setting of field
- * ASC_CTRL.MODE)
- * RD[6:0]:
- * Receive buffer data D6 to D0 */
-
-
-
-/* ASC control */
-
-#define ASC_CTRL 0x0c /* RW, reset value: 0 */
-/* This register controls the operating mode of the ASC and contains control bits for
- * mode and error check selection, and status flags for error identification.
- * Programming the mode control field (MODE) to one of the reserved combinations
- * may result in unpredictable behavior. Serial data transmission or reception is only
- * possible when the baudrate generator run bit (RUN) is set to 1. When the RUN bit is
- * set to 0, TxD is 1. Setting the RUN bit to 0 immediately freezes the state of the
- * transmitter and receiver. This should only be done when the ASC is idle.
- * Serial data transmission or reception is only possible when the baudrate generator
- * RUN bit is set to 1. A transmission is started by writing to the transmit buffer register
- * ASC_Tx_Buf. */
-
-#define ASC_CTRL__MODE__SHIFT 0
-#define ASC_CTRL__MODE__MASK  0x00000007
-/* MODE: ASC mode control
- * 000: reserved	001: 8-bit data
- * 010: reserved	011: 7-bit data + parity
- * 100: 9-bit data	101: 8-bit data + wake up bit
- * 110: reserved	111: 8-bit data + parity */
-
-#define ASC_CTRL__STOPBITS__SHIFT 3
-#define ASC_CTRL__STOPBITS__MASK  0x00000003
-/* STOPBITS: number of stop bits selection
- * 00: 0.5 stop bits	01: 1 stop bits
- * 10: 1.5 stop bits	11: 2 stop bits */
-
-#define ASC_CTRL__PARITYODD__SHIFT 5
-#define ASC_CTRL__PARITYODD__MASK  0x00000001
-/* PARITYODD: parity selection
- * 0: even parity (parity bit set on odd number of 1's in data)
- * 1: odd parity (parity bit set on even number of 1's in data) */
-
-#define ASC_CTRL__LOOPBACK__SHIFT 6
-#define ASC_CTRL__LOOPBACK__MASK  0x00000001
-/* LOOPBACK: loopback mode enable bit
- * 0: standard transmit/receive mode	1: loopback mode enabled */
-
-#define ASC_CTRL__RUN__SHIFT 7
-#define ASC_CTRL__RUN__MASK  0x00000001
-/* RUN: baudrate generator run bit
- * 0: baudrate generator disabled (ASC inactive)	1: baudrate generator enabled */
-
-#define ASC_CTRL__RX_EN__SHIFT 8
-#define ASC_CTRL__RX_EN__MASK  0x00000001
-/* RX_EN: receiver enable bit
- * 0: receiver disabled	1: receiver enabled */
-
-#define ASC_CTRL__SC_EN__SHIFT 9
-#define ASC_CTRL__SC_EN__MASK  0x00000001
-/* SC_EN: smartcard enable
- * 0: smartcard mode disabled	1: smartcard mode enabled */
-
-#define ASC_CTRL__FIFO_EN__SHIFT 10
-#define ASC_CTRL__FIFO_EN__MASK  0x00000001
-/* FIFO_EN: FIFO enable:
- * 0: FIFO disabled	1: FIFO enabled */
-
-#define ASC_CTRL__CTS_EN__SHIFT 11
-#define ASC_CTRL__CTS_EN__MASK  0x00000001
-/* CTS_EN: CTS enable
- * 0: CTS ignored		1: CTS enabled */
-
-#define ASC_CTRL__BAUDMODE__SHIFT 12
-#define ASC_CTRL__BAUDMODE__MASK  0x00000001
-/* BAUDMODE: baudrate generation mode
- * 0: baud counter decrements, ticks when it reaches 1	1: baud counter added to itself, ticks when
- * there is a carry */
-
-#define ASC_CTRL__NACK_DISABLE__SHIFT 13
-#define ASC_CTRL__NACK_DISABLE__MASK  0x00000001
-/* NACK_DISABLE: NACKing behavior control
- * 0: NACKing behavior in smartcard mode	1: no NACKing behavior in smartcard mode */
-
-
-
-/* ASC interrupt enable */
-
-#define ASC_INT_EN 0x10 /* RW, reset value: 0 */
-
-#define ASC_INT_EN__RX_BUFFULL__SHIFT 0
-#define ASC_INT_EN__RX_BUFFULL__MASK  0x00000001
-/* RX_BUFFULL: receiver buffer full interrupt enable
- * 0: receiver buffer full interrupt disable	1: receiver buffer full interrupt enable */
-
-#define ASC_INT_EN__TX_EMPTY__SHIFT 1
-#define ASC_INT_EN__TX_EMPTY__MASK  0x00000001
-/* TX_EMPTY: transmitter empty interrupt enable
- * 0: transmitter empty interrupt disable	1: transmitter empty interrupt enable */
-
-#define ASC_INT_EN__TX_HALFEMPTY__SHIFT 2
-#define ASC_INT_EN__TX_HALFEMPTY__MASK  0x00000001
-/* TX_HALFEMPTY: transmitter buffer half empty interrupt enable
- * 0: transmitter buffer half empty interrupt disable	1: transmitter buffer half empty interrupt
- * enable */
-
-#define ASC_INT_EN__PARITY_ERR__SHIFT 3
-#define ASC_INT_EN__PARITY_ERR__MASK  0x00000001
-/* PARITY_ERR: parity error interrupt enable:
- * 0: parity error interrupt disable	1: parity error interrupt enable */
-
-#define ASC_INT_EN__FRAME_ERR__SHIFT 4
-#define ASC_INT_EN__FRAME_ERR__MASK  0x00000001
-/* FRAME_ERR: framing error interrupt enable
- * 0: framing error interrupt disable	1: framing error interrupt enable */
-
-#define ASC_INT_EN__OVERRUN_ERROR__SHIFT 5
-#define ASC_INT_EN__OVERRUN_ERROR__MASK  0x00000001
-/* OVERRUN_ERR: overrun error interrupt enable
- * 0: overrun error interrupt disable	1: overrun error interrupt enable */
-
-#define ASC_INT_EN__TIMEOUT_NOTEMPTY__SHIFT 6
-#define ASC_INT_EN__TIMEOUT_NOTEMPTY__MASK  0x00000001
-/* TIMEOUT_NOTEMPTY: time out when not empty interrupt enable
- * 0: time out when input FIFO or buffer not empty interrupt disable
- * 1: time out when input FIFO or buffer not empty interrupt enable */
-
-#define ASC_INT_EN__TIMEOUT_IDLE__SHIFT 7
-#define ASC_INT_EN__TIMEOUT_IDLE__MASK  0x00000001
-/* TIMEOUT_IDLE: time out when the receiver FIFO is empty interrupt enable
- * 0: time out when the input FIFO or buffer is empty interrupt disable
- * 1: time out when the input FIFO or buffer is empty interrupt enable */
-
-#define ASC_INT_EN__RX_HALFFULL__SHIFT 8
-#define ASC_INT_EN__RX_HALFFULL__MASK  0x00000001
-/* RX_HALFFULL: receiver FIFO is half full interrupt enable
- * 0: receiver FIFO is half full interrupt disable	1: receiver FIFO is half full interrupt enable */
-
-
-
-/* ASC interrupt status */
-
-#define ASC_STA 0x14 /* R, reset value: 3 (Rx buffer full and Tx buffer empty) */
-
-#define ASC_STA__RX_BUFFULL__SHIFT 0
-#define ASC_STA__RX_BUFFULL__MASK  0x00000001
-/* RX_BUFFULL: Receiver FIFO not empty (FIFO operation) or buffer full (double buffered
- * operation)
- * 0: receiver FIFO is empty or buffer is not full	1: receiver FIFO is not empty or buffer is full */
-
-#define ASC_STA__TX_EMPTY__SHIFT 1
-#define ASC_STA__TX_EMPTY__MASK  0x00000001
-/* TX_EMPTY: Transmitter empty flag
- * 0: transmitter is not empty	1: transmitter is empty */
-
-#define ASC_STA__TX_HALFEMPTY__SHIFT 2
-#define ASC_STA__TX_HALFEMPTY__MASK  0x00000001
-/* TX_HALFEMPTY: Transmitter FIFO at least half empty flag or buffer empty
- * 0: the FIFOs are enabled and the transmitter FIFO is more than half full (more than eight
- * characters) or the FIFOs are disabled and the transmit buffer is not empty.
- * 1: the FIFOs are enabled and the transmitter FIFO is at least half empty (eight or less
- * characters) or the FIFOs are disabled and the transmit buffer is empty */
-
-#define ASC_STA__PARITY_ERR__SHIFT 3
-#define ASC_STA__PARITY_ERR__MASK  0x00000001
-/* PARITY_ERR: Input parity error flag:
- * 0: no parity error	1: parity error */
-
-#define ASC_STA__FRAME_ERR__SHIFT 4
-#define ASC_STA__FRAME_ERR__MASK  0x00000001
-/* FRAME_ERR: Input frame error flag
- * 0: no framing error	1: framing error (stop bits not found) */
-
-#define ASC_STA__OVERRUN_ERR__SHIFT 5
-#define ASC_STA__OVERRUN_ERR__MASK  0x00000001
-/* OVERRUN_ERR: Overrun error flag
- * 0: no overrun error
- * 1: overrun error, that is, data received when the input buffer is full */
-
-#define ASC_STA__TONE__SHIFT 6
-#define ASC_STA__TONE__MASK  0x00000001
-/* TONE: Time out when the receiver FIFO or buffer is not empty
- * 0: no time out or the receiver FIFO or buffer is empty
- * 1: time out when the receiver FIFO or buffer is not empty */
-
-#define ASC_STA__TOE__SHIFT 7
-#define ASC_STA__TOE__MASK  0x00000001
-/* TOE: Time out when the receiver FIFO or buffer is empty
- * 0: no time out or the receiver FIFO or buffer is not empty
- * 1: time out when the receiver FIFO or buffer is empty */
-
-#define ASC_STA__RX_HALFFULL__SHIFT 8
-#define ASC_STA__RX_HALFFULL__MASK  0x00000001
-/* RX_HALFFULL: Receiver FIFO is half full
- * 0: the receiver FIFO contains eight characters or less
- * 1: the receiver FIFO contains more than eight characters */
-
-#define ASC_STA__TX_FULL__SHIFT 9
-#define ASC_STA__TX_FULL__MASK  0x00000001
-/* TX_FULL: Transmitter FIFO or buffer is full
- * 0: the FIFOs are enabled and the transmitter FIFO is empty or contains less than 16
- * characters or the FIFOs are disabled and the transmit buffer is empty
- * 1: the FIFOs are enabled and the transmitter FIFO contains 16 characters or the FIFOs are
- * disabled and the transmit buffer is full */
-
-#define ASC_STA__NKD__SHIFT 10
-#define ASC_STA__NKD__MASK  0x00000001
-/* NKD: Transmission failure acknowledgement by receiver in smartcard mode.
- * 0: data transmitted successfully
- * 1: data transmission unsuccessful (data NACKed by smartcard) */
-
-
-
-/* ASC guard time */
-
-#define ASC_GUARDTIME 0x18 /* RW, reset value: 0 */
-/* This register defines the number of stop bits and the delay of the assertion of the
- * interrupt TX_EMPTY by a programmable number of baud clock ticks. The value in the
- * register is the number of baud clock ticks to delay assertion of TX_EMPTY. This
- * value must be in the range 0 to 511. */
-
-#define ASC_GUARDTIME__GUARDTIME__SHIFT 0
-#define ASC_GUARDTIME__GUARDTIME__MASK  0x000001ff
-
-
-
-/* ASC time out */
-
-#define ASC_TIMEOUT 0x1c /* RW, reset value: 0 */
-/* The time out period in baudrate ticks. The ASC contains an 8-bit time out counter,
- * which reloads from ASC_TIMEOUT when one or more of the following is true:
- * If none of these conditions hold, the counter decrements to 0 at every baudrate tick.
- * The TONE (time out when not empty) bit of the ASC_STA register is 1 when the
- * input FIFO is not empty and the time out counter is zero. The TIMEOUT_IDLE bit of
- * the ASC_STA register is 1 when the input FIFO is empty and the time out counter is
- * zero.
- * When the software has emptied the input FIFO, the time out counter resets and starts
- * decrementing. If no more characters arrive, when the counter reaches zero the
- * TIMEOUT_IDLE bit of the ASC_STA register is set. */
-
-#define ASC_TIMEOUT__TIMEOUT__SHIFT 0
-#define ASC_TIMEOUT__TIMEOUT__MASK  0x000000ff
-
-
-
-/* ASC transmit FIFO reset */
-
-#define ASC_TX_RST 0x20 /* W */
-/* Reset the transmit FIFO. Registers ASC_TX_RST have no storage associated with
- * them. A write of any value to these registers resets the corresponding transmitter
- * FIFO. */
-
-
-
-/* ASC receive FIFO reset */
-
-#define ASC_RX_RST 0x24 /* W */
-/* Reset the receiver FIFO. The registers ASC_RX_RST have no actual storage
- * associated with them. A write of any value to one of these registers resets the
- * corresponding receiver FIFO. */
-
-
-
-/* ASC number of retries on transmission */
-
-#define ASC_RETRIES 0x28 /* RW, reset value: 1 */
-/* Defines the number of transmissions attempted on a piece of data before the UART
- * discards the data. If a transmission still fails after NUM_RETRIES, the NKD bit is set
- * in the ASC_STA register where it can be read and acted on by software. This
- * register does not have to be reinitialized after a NACK error. */
-
-#define ASC_RETRIES__NUM_RETRIES__SHIFT 0
-#define ASC_RETRIES__NUM_RETRIES__MASK  0x000000ff
-
-
-
-#endif
diff --git a/include/linux/stm/registers/aud_pcmin.h b/include/linux/stm/registers/aud_pcmin.h
deleted file mode 100644
index d38016f..0000000
--- a/include/linux/stm/registers/aud_pcmin.h
+++ /dev/null
@@ -1,172 +0,0 @@
-#ifndef __STM_REGISTERS_AUD_PCMIN_H
-#define __STM_REGISTERS_AUD_PCMIN_H
-
-
-
-#define AUD_PCMIN_RST 0x00
-
-#define AUD_PCMIN_RST__RSTP__SHIFT          0
-#define AUD_PCMIN_RST__RSTP__MASK           0x1
-#define AUD_PCMIN_RST__RSTP__VALUE__RUNNING 0x0
-#define AUD_PCMIN_RST__RSTP__VALUE__RESET   0x1
-
-
-
-#define AUD_PCMIN_DATA 0x04
-
-#define AUD_PCMIN_DATA__DATA__SHIFT 0
-#define AUD_PCMIN_DATA__DATA__MASK  0xffffffff
-
-
-
-#define AUD_PCMIN_ITS 0x08
-
-#define AUD_PCMIN_ITS__OVF__SHIFT          0
-#define AUD_PCMIN_ITS__OVF__MASK           0x1
-#define AUD_PCMIN_ITS__OVF__VALUE__PENDING 0x1
-
-#define AUD_PCMIN_ITS__VSYNC__SHIFT          1
-#define AUD_PCMIN_ITS__VSYNC__MASK           0x1
-#define AUD_PCMIN_ITS__VSYNC__VALUE__PENDING 0x1
-
-
-
-#define AUD_PCMIN_ITS_CLR 0x0c
-
-#define AUD_PCMIN_ITS_CLR__OVF__SHIFT        0
-#define AUD_PCMIN_ITS_CLR__OVF__MASK         0x1
-#define AUD_PCMIN_ITS_CLR__OVF__VALUE__CLEAR 0x1
-
-#define AUD_PCMIN_ITS_CLR__VSYNC__SHIFT       1
-#define AUD_PCMIN_ITS_CLR__VSYNC__MASK        0x1
-#define AUD_PCMIN_ITS_CLR__VSYNC__VALUE_CLEAR 0x1
-
-
-
-#define AUD_PCMIN_IT_EN 0x10
-
-#define AUD_PCMIN_IT_EN__OVF__SHIFT           0
-#define AUD_PCMIN_IT_EN__OVF__MASK            0x1
-#define AUD_PCMIN_IT_EN__OVF__VALUE__DISABLED 0x0
-#define AUD_PCMIN_IT_EN__OVF__VALUE__ENABLED  0x1
-
-#define AUD_PCMIN_IT_EN__VSYNC__SHIFT           1
-#define AUD_PCMIN_IT_EN__VSYNC__MASK            0x1
-#define AUD_PCMIN_IT_EN__VSYNC__VALUE__DISABLED 0x0
-#define AUD_PCMIN_IT_EN__VSYNC__VALUE__ENABLED  0x1
-
-
-
-#define AUD_PCMIN_IT_EN_SET 0x14
-
-#define AUD_PCMIN_IT_EN_SET__OVF__SHIFT      0
-#define AUD_PCMIN_IT_EN_SET__OVF__MASK       0x1
-#define AUD_PCMIN_IT_EN_SET__OVF__VALUE__SET 0x1
-
-#define AUD_PCMIN_IT_EN_SET__VSYNC__SHIFT      1
-#define AUD_PCMIN_IT_EN_SET__VSYNC__MASK       0x1
-#define AUD_PCMIN_IT_EN_SET__VSYNC__VALUE__SET 0x1
-
-
-
-#define AUD_PCMIN_IT_EN_CLR 0x18
-
-#define AUD_PCMIN_IT_EN_CLR__OVF__SHIFT        0
-#define AUD_PCMIN_IT_EN_CLR__OVF__MASK         0x1
-#define AUD_PCMIN_IT_EN_CLR__OVF__VALUE__CLEAR 0x1
-
-#define AUD_PCMIN_IT_EN_CLR__VSYNC__SHIFT        1
-#define AUD_PCMIN_IT_EN_CLR__VSYNC__MASK         0x1
-#define AUD_PCMIN_IT_EN_CLR__VSYNC__VALUE__CLEAR 0x1
-
-
-
-#define AUD_PCMIN_CTRL 0x1c
-
-#define AUD_PCMIN_CTRL__MODE__SHIFT       0
-#define AUD_PCMIN_CTRL__MODE__MASK        0x3
-#define AUD_PCMIN_CTRL__MODE__VALUE__OFF  0x0
-#define AUD_PCMIN_CTRL__MODE__VALUE__PCM  0x2
-#define AUD_PCMIN_CTRL__MODE__VALUE__CD   0x3
-
-#define AUD_PCMIN_CTRL__MEM_FMT__SHIFT                  2
-#define AUD_PCMIN_CTRL__MEM_FMT__MASK                   0x1
-#define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
-#define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
-
-#define AUD_PCMIN_CTRL__RND__SHIFT                   3
-#define AUD_PCMIN_CTRL__RND__MASK                    0x1
-#define AUD_PCMIN_CTRL__RND__VALUE__NO_ROUNDING      0x0
-#define AUD_PCMIN_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
-
-#define AUD_PCMIN_CTRL__NUM_FRAMES__SHIFT 4
-#define AUD_PCMIN_CTRL__NUM_FRAMES__MASK  0xfffffff
-
-
-
-
-#define AUD_PCMIN_STA 0x20
-
-#define AUD_PCMIN_STA__RUN_STOP__SHIFT          0
-#define AUD_PCMIN_STA__RUN_STOP__MASK           0x1
-#define AUD_PCMIN_STA__RUN_STOP__VALUE__STOPPED 0x0
-#define AUD_PCMIN_STA__RUN_STOP__VALUE__RUNNING 0x1
-
-#define AUD_PCMIN_STA__OVF__SHIFT                    1
-#define AUD_PCMIN_STA__OVF__MASK                     0x1
-#define AUD_PCMIN_STA__OVF__VALUE__OVERFLOW_DETECTED 0x1
-
-#define AUD_PCMIN_STA__SAMPL_CNT__SHIFT 2
-#define AUD_PCMIN_STA__SAMPL_CNT__MASK  0xffff
-
-#define AUD_PCMIN_STA__VSYNC__SHIFT 18
-#define AUD_PCMIN_STA__VSYNC__MASK  0x1
-
-#define AUD_PCMIN_STA__NFRAMES__SHIFT       19
-#define AUD_PCMIN_STA__NFRAMES__MASK        0x1
-#define AUD_PCMIN_STA__NFRAMES__VALUE__DONE 0x1
-
-
-
-#define AUD_PCMIN_FMT 0x24
-
-#define AUD_PCMIN_FMT__NBIT__SHIFT          0
-#define AUD_PCMIN_FMT__NBIT__MASK           0x1
-#define AUD_PCMIN_FMT__NBIT__VALUE__32_BITS 0x0
-#define AUD_PCMIN_FMT__NBIT__VALUE__16_BITS 0x1
-
-#define AUD_PCMIN_FMT__DATA_SIZE__SHIFT          1
-#define AUD_PCMIN_FMT__DATA_SIZE__MASK           0x3
-#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__24_BITS 0x0
-#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__20_BITS 0x1
-#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__18_BITS 0x2
-#define AUD_PCMIN_FMT__DATA_SIZE__VALUE__16_BITS 0x3
-
-#define AUD_PCMIN_FMT__LR_POL__SHIFT            3
-#define AUD_PCMIN_FMT__LR_POL__MASK             0x1
-#define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_LOW  0x0
-#define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
-
-#define AUD_PCMIN_FMT__SCLK_EDGE__SHIFT          4
-#define AUD_PCMIN_FMT__SCLK_EDGE__MASK           0x1
-#define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__RISING  0x0
-#define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__FALLING 0x1
-
-#define AUD_PCMIN_FMT__PADDING__SHIFT                5
-#define AUD_PCMIN_FMT__PADDING__MASK                 0x1
-#define AUD_PCMIN_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
-#define AUD_PCMIN_FMT__PADDING__VALUE__NO_DELAY      0x1
-
-#define AUD_PCMIN_FMT__ALIGN__SHIFT        6
-#define AUD_PCMIN_FMT__ALIGN__MASK         0x1
-#define AUD_PCMIN_FMT__ALIGN__VALUE__RIGHT 0x0
-#define AUD_PCMIN_FMT__ALIGN__VALUE__LEFT  0x1
-
-#define AUD_PCMIN_FMT__ORDER__SHIFT            7
-#define AUD_PCMIN_FMT__ORDER__MASK             0x1
-#define AUD_PCMIN_FMT__ORDER__VALUE__LSB_FIRST 0x0
-#define AUD_PCMIN_FMT__ORDER__VALUE__MSB_FIRST 0x1
-
-
-
-#endif
diff --git a/include/linux/stm/registers/aud_pcmout.h b/include/linux/stm/registers/aud_pcmout.h
deleted file mode 100644
index f2d5008..0000000
--- a/include/linux/stm/registers/aud_pcmout.h
+++ /dev/null
@@ -1,251 +0,0 @@
-#ifndef __STM_REGISTERS_AUD_PCMOUT_H
-#define __STM_REGISTERS_AUD_PCMOUT_H
-
-
-
-#define AUD_PCMOUT_RST 0x00
-
-#define AUD_PCMOUT_RST__SRSTP__SHIFT          0
-#define AUD_PCMOUT_RST__SRSTP__MASK           0x1
-#define AUD_PCMOUT_RST__SRSTP__VALUE__RUNNING 0x0
-#define AUD_PCMOUT_RST__SRSTP__VALUE__RESET   0x1
-
-
-
-#define AUD_PCMOUT_DATA 0x04
-
-#define AUD_PCMOUT_DATA__DATA__SHIFT 0
-#define AUD_PCMOUT_DATA__DATA__MASK  0xffffffff
-
-
-
-#define AUD_PCMOUT_ITS 0x08
-
-#define AUD_PCMOUT_ITS__UNF__SHIFT          0
-#define AUD_PCMOUT_ITS__UNF__MASK           0x1
-#define AUD_PCMOUT_ITS__UNF__VALUE__PENDING 0x1
-
-#define AUD_PCMOUT_ITS__NSAMPLE__SHIFT          1
-#define AUD_PCMOUT_ITS__NSAMPLE__MASK           0x1
-#define AUD_PCMOUT_ITS__NSAMPLE__VALUE__PENDING 0x1
-
-
-
-#define AUD_PCMOUT_ITS_CLR 0x0c
-
-#define AUD_PCMOUT_ITS_CLR__UNF__SHIFT        0
-#define AUD_PCMOUT_ITS_CLR__UNF__MASK         0x1
-#define AUD_PCMOUT_ITS_CLR__UNF__VALUE__CLEAR 0x1
-
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__SHIFT        1
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__MASK         0x1
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
-
-
-
-#define AUD_PCMOUT_IT_EN 0x10
-
-#define AUD_PCMOUT_IT_EN__UNF__SHIFT           0
-#define AUD_PCMOUT_IT_EN__UNF__MASK            0x1
-#define AUD_PCMOUT_IT_EN__UNF__VALUE__DISABLED 0x0
-#define AUD_PCMOUT_IT_EN__UNF__VALUE__ENABLED  0x1
-
-#define AUD_PCMOUT_IT_EN__NSAMPLE__SHIFT           1
-#define AUD_PCMOUT_IT_EN__NSAMPLE__MASK            0x1
-#define AUD_PCMOUT_IT_EN__NSAMPLE__VALUE__DISABLED 0x0
-#define AUD_PCMOUT_IT_EN__NSAMPLE__VALUE__ENABLED  0x1
-
-
-
-#define AUD_PCMOUT_IT_EN_SET 0x14
-
-#define AUD_PCMOUT_IT_EN_SET__UNF__SHIFT      0
-#define AUD_PCMOUT_IT_EN_SET__UNF__MASK       0x1
-#define AUD_PCMOUT_IT_EN_SET__UNF__VALUE__SET 0x1
-
-#define AUD_PCMOUT_IT_EN_SET__NSAMPLE__SHIFT      1
-#define AUD_PCMOUT_IT_EN_SET__NSAMPLE__MASK       0x1
-#define AUD_PCMOUT_IT_EN_SET__NSAMPLE__VALUE__SET 0x1
-
-
-
-#define AUD_PCMOUT_IT_EN_CLR 0x18
-
-#define AUD_PCMOUT_IT_EN_CLR__UNF__SHIFT        0
-#define AUD_PCMOUT_IT_EN_CLR__UNF__MASK         0x1
-#define AUD_PCMOUT_IT_EN_CLR__UNF__VALUE__CLEAR 0x1
-
-#define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__SHIFT        1
-#define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__MASK         0x1
-#define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__VALUE__CLEAR 0x1
-
-
-
-#define AUD_PCMOUT_CTRL 0x1c
-
-#define AUD_PCMOUT_CTRL__MODE__SHIFT       0
-#define AUD_PCMOUT_CTRL__MODE__MASK        0x3
-#define AUD_PCMOUT_CTRL__MODE__VALUE__OFF  0x0
-#define AUD_PCMOUT_CTRL__MODE__VALUE__MUTE 0x1
-#define AUD_PCMOUT_CTRL__MODE__VALUE__PCM  0x2
-#define AUD_PCMOUT_CTRL__MODE__VALUE__CD   0x3
-
-#define AUD_PCMOUT_CTRL__MEM_FMT__SHIFT                  2
-#define AUD_PCMOUT_CTRL__MEM_FMT__MASK                   0x1
-#define AUD_PCMOUT_CTRL__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
-#define AUD_PCMOUT_CTRL__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
-
-#define AUD_PCMOUT_CTRL__RND__SHIFT                   3
-#define AUD_PCMOUT_CTRL__RND__MASK                    0x1
-#define AUD_PCMOUT_CTRL__RND__VALUE__NO_ROUNDING      0x0
-#define AUD_PCMOUT_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
-
-#define AUD_PCMOUT_CTRL__CLK_DIV__SHIFT 4
-#define AUD_PCMOUT_CTRL__CLK_DIV__MASK  0xff
-
-#define AUD_PCMOUT_CTRL__SPDIF_LAT__SHIFT                 12
-#define AUD_PCMOUT_CTRL__SPDIF_LAT__MASK                  0x1
-#define AUD_PCMOUT_CTRL__SPDIF_LAT__VALUE__IGNORE_SPDIF   0x0
-#define AUD_PCMOUT_CTRL__SPDIF_LAT__VALUE__WAIT_FOR_SPDIF 0x1
-
-#define AUD_PCMOUT_CTRL__NSAMPLE__SHIFT 13
-#define AUD_PCMOUT_CTRL__NSAMPLE__MASK  0x7ffff
-
-
-
-#define AUD_PCMOUT_STA 0x20
-
-#define AUD_PCMOUT_STA__RUN_STOP__SHIFT          0
-#define AUD_PCMOUT_STA__RUN_STOP__MASK           0x1
-#define AUD_PCMOUT_STA__RUN_STOP__VALUE__STOPPED 0x0
-#define AUD_PCMOUT_STA__RUN_STOP__VALUE__RUNNING 0x1
-
-#define AUD_PCMOUT_STA__UNF__SHIFT           1
-#define AUD_PCMOUT_STA__UNF__MASK            0x1
-#define AUD_PCMOUT_STA__UNF__VALUE__DETECTED 0x1
-
-#define AUD_PCMOUT_STA__NSAMPLE__SHIFT       2
-#define AUD_PCMOUT_STA__NSAMPLE__MASK        0x1
-#define AUD_PCMOUT_STA__NSAMPLE__VALUE__DONE 0x1
-
-
-
-#define AUD_PCMOUT_FMT 0x24
-
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-
-#define AUD_PCMOUT_FMT__NBIT__SHIFT          0
-#define AUD_PCMOUT_FMT__NBIT__MASK           0x1
-#define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
-#define AUD_PCMOUT_FMT__NBIT__VALUE__16_BITS 0x1
-
-#define AUD_PCMOUT_FMT__DATA_SIZE__SHIFT          1
-#define AUD_PCMOUT_FMT__DATA_SIZE__MASK           0x7
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__16_BITS 0x0
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__18_BITS 0x1
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__20_BITS 0x2
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__24_BITS 0x3
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__28_BITS 0x4
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__32_BITS 0x5
-
-#define AUD_PCMOUT_FMT__LR_POL__SHIFT            4
-#define AUD_PCMOUT_FMT__LR_POL__MASK             0x1
-#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW  0x0
-#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
-
-#define AUD_PCMOUT_FMT__SCLK_EDGE__SHIFT          5
-#define AUD_PCMOUT_FMT__SCLK_EDGE__MASK           0x1
-#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__RISING  0x0
-#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING 0x1
-
-#define AUD_PCMOUT_FMT__PADDING__SHIFT                6
-#define AUD_PCMOUT_FMT__PADDING__MASK                 0x1
-#define AUD_PCMOUT_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
-#define AUD_PCMOUT_FMT__PADDING__VALUE__NO_DELAY      0x1
-
-#define AUD_PCMOUT_FMT__ALIGN__SHIFT        7
-#define AUD_PCMOUT_FMT__ALIGN__MASK         0x1
-#define AUD_PCMOUT_FMT__ALIGN__VALUE__LEFT  0x0
-#define AUD_PCMOUT_FMT__ALIGN__VALUE__RIGHT 0x1
-
-#define AUD_PCMOUT_FMT__ORDER__SHIFT            8
-#define AUD_PCMOUT_FMT__ORDER__MASK             0x1
-#define AUD_PCMOUT_FMT__ORDER__VALUE__LSB_FIRST 0x0
-#define AUD_PCMOUT_FMT__ORDER__VALUE__MSB_FIRST 0x1
-
-#define AUD_PCMOUT_FMT__NUM_CH__SHIFT             9
-#define AUD_PCMOUT_FMT__NUM_CH__MASK              0x7
-/* "1 channel" means 1 PCM player channel so
- * 2 audio channels (stereo) */
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__1_CHANNEL  0x1
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__2_CHANNELS 0x2
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__3_CHANNELS 0x3
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
-
-#define AUD_PCMOUT_FMT__BACK_STALLING__SHIFT            12
-#define AUD_PCMOUT_FMT__BACK_STALLING__MASK             0x1
-#define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__DISABLED  0x0
-#define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__ENABLED   0x1
-
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 13
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x3f
-
-#else /* STx710x, STx7200 cut 1.0 */
-
-#define AUD_PCMOUT_FMT__NBIT__SHIFT          0
-#define AUD_PCMOUT_FMT__NBIT__MASK           0x1
-#define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
-#define AUD_PCMOUT_FMT__NBIT__VALUE__16_BITS 0x1
-
-#define AUD_PCMOUT_FMT__DATA_SIZE__SHIFT          1
-#define AUD_PCMOUT_FMT__DATA_SIZE__MASK           0x3
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__24_BITS 0x0
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__20_BITS 0x1
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__18_BITS 0x2
-#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__16_BITS 0x3
-
-#define AUD_PCMOUT_FMT__LR_POL__SHIFT            3
-#define AUD_PCMOUT_FMT__LR_POL__MASK             0x1
-#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW  0x0
-#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
-
-#define AUD_PCMOUT_FMT__SCLK_EDGE__SHIFT          4
-#define AUD_PCMOUT_FMT__SCLK_EDGE__MASK           0x1
-/* Beware that in 7100 and some cuts of 7109 there is
- * a HW bug and these values are inverted; such
- * situation must be detected in runtime! */
-#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__RISING  0x0
-#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING 0x1
-
-#define AUD_PCMOUT_FMT__PADDING__SHIFT                5
-#define AUD_PCMOUT_FMT__PADDING__MASK                 0x1
-#define AUD_PCMOUT_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
-#define AUD_PCMOUT_FMT__PADDING__VALUE__NO_DELAY      0x1
-
-#define AUD_PCMOUT_FMT__ALIGN__SHIFT        6
-#define AUD_PCMOUT_FMT__ALIGN__MASK         0x1
-#define AUD_PCMOUT_FMT__ALIGN__VALUE__LEFT  0x0
-#define AUD_PCMOUT_FMT__ALIGN__VALUE__RIGHT 0x1
-
-#define AUD_PCMOUT_FMT__ORDER__SHIFT            7
-#define AUD_PCMOUT_FMT__ORDER__MASK             0x1
-#define AUD_PCMOUT_FMT__ORDER__VALUE__LSB_FIRST 0x0
-#define AUD_PCMOUT_FMT__ORDER__VALUE__MSB_FIRST 0x1
-
-#define AUD_PCMOUT_FMT__NUM_CH__SHIFT             8
-#define AUD_PCMOUT_FMT__NUM_CH__MASK              0x7
-/* "1 channel" means 1 PCM player channel so
- * 2 audio channels (stereo) */
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__1_CHANNEL  0x1
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__2_CHANNELS 0x2
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__3_CHANNELS 0x3
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
-#define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
-
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 11
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x1f
-
-#endif
-
-#endif
diff --git a/include/linux/stm/registers/aud_spdif.h b/include/linux/stm/registers/aud_spdif.h
deleted file mode 100644
index 82725f0..0000000
--- a/include/linux/stm/registers/aud_spdif.h
+++ /dev/null
@@ -1,371 +0,0 @@
-#ifndef __STM_REGISTERS_AUD_SPDIF_H
-#define __STM_REGISTERS_AUD_SPDIF_H
-
-
-
-#define AUD_SPDIF_RST 0x00
-
-#define AUD_SPDIF_RST__SRSTP__SHIFT          0
-#define AUD_SPDIF_RST__SRSTP__MASK           0x1
-#define AUD_SPDIF_RST__SRSTP__VALUE__RUNNING 0x0
-#define AUD_SPDIF_RST__SRSTP__VALUE__RESET   0x1
-
-
-
-#define AUD_SPDIF_DATA 0x04
-
-#define AUD_SPDIF_DATA__DATA__SHIFT 0
-#define AUD_SPDIF_DATA__DATA__MASK  0xffffffff
-
-
-
-#define AUD_SPDIF_ITS 0x08
-
-#define AUD_SPDIF_ITS__UNF__SHIFT          0
-#define AUD_SPDIF_ITS__UNF__MASK           0x1
-#define AUD_SPDIF_ITS__UNF__VALUE__PENDING 0x1
-
-#define AUD_SPDIF_ITS__EOBURST__SHIFT          1
-#define AUD_SPDIF_ITS__EOBURST__MASK           0x1
-#define AUD_SPDIF_ITS__EOBURST__VALUE__PENDING 0x1
-
-#define AUD_SPDIF_ITS__EOBLOCK__SHIFT          2
-#define AUD_SPDIF_ITS__EOBLOCK__MASK           0x1
-#define AUD_SPDIF_ITS__EOBLOCK__VALUE__PENDING 0x1
-
-#define AUD_SPDIF_ITS__EOLATENCY__SHIFT          3
-#define AUD_SPDIF_ITS__EOLATENCY__MASK           0x1
-#define AUD_SPDIF_ITS__EOLATENCY__VALUE__PENDING 0x1
-
-#define AUD_SPDIF_ITS__EOPD__SHIFT          4
-#define AUD_SPDIF_ITS__EOPD__MASK           0x1
-#define AUD_SPDIF_ITS__EOPD__VALUE__PENDING 0x1
-
-#define AUD_SPDIF_ITS__NSAMPLE__SHIFT          5
-#define AUD_SPDIF_ITS__NSAMPLE__MASK           0x1
-#define AUD_SPDIF_ITS__NSAMPLE__VALUE__PENDING 0x1
-
-
-
-#define AUD_SPDIF_ITS_CLR 0x0c
-
-#define AUD_SPDIF_ITS_CLR__UNF__SHIFT        0
-#define AUD_SPDIF_ITS_CLR__UNF__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__UNF__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_ITS_CLR__EOBURST__SHIFT        1
-#define AUD_SPDIF_ITS_CLR__EOBURST__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__EOBURST__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_ITS_CLR__EOBLOCK__SHIFT        2
-#define AUD_SPDIF_ITS_CLR__EOBLOCK__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__EOBLOCK__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_ITS_CLR__EOLATENCY__SHIFT        3
-#define AUD_SPDIF_ITS_CLR__EOLATENCY__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__EOLATENCY__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_ITS_CLR__EOPD__SHIFT        4
-#define AUD_SPDIF_ITS_CLR__EOPD__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__EOPD__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_ITS_CLR__NSAMPLE__SHIFT        5
-#define AUD_SPDIF_ITS_CLR__NSAMPLE__MASK         0x1
-#define AUD_SPDIF_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
-
-
-
-#define AUD_SPDIF_IT_EN 0x10
-
-#define AUD_SPDIF_IT_EN__UNF__SHIFT           0
-#define AUD_SPDIF_IT_EN__UNF__MASK            0x1
-#define AUD_SPDIF_IT_EN__UNF__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__UNF__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_IT_EN__EOBURST__SHIFT           1
-#define AUD_SPDIF_IT_EN__EOBURST__MASK            0x1
-#define AUD_SPDIF_IT_EN__EOBURST__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__EOBURST__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_IT_EN__EOBLOCK__SHIFT           2
-#define AUD_SPDIF_IT_EN__EOBLOCK__MASK            0x1
-#define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_IT_EN__EOLATENCY__SHIFT           3
-#define AUD_SPDIF_IT_EN__EOLATENCY__MASK            0x1
-#define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__ENABLED 0x1
-
-#define AUD_SPDIF_IT_EN__EOPD__SHIFT           4
-#define AUD_SPDIF_IT_EN__EOPD__MASK            0x1
-#define AUD_SPDIF_IT_EN__EOPD__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__EOPD__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_IT_EN__NSAMPLE__SHIFT           5
-#define AUD_SPDIF_IT_EN__NSAMPLE__MASK            0x1
-#define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__DISABLED 0x0
-#define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__ENABLED  0x1
-
-
-
-#define AUD_SPDIF_IT_EN_SET 0x14
-
-#define AUD_SPDIF_IT_EN_SET__UNF__SHIFT      0
-#define AUD_SPDIF_IT_EN_SET__UNF__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__UNF__VALUE__SET 0x1
-
-#define AUD_SPDIF_IT_EN_SET__EOBURST__SHIFT      1
-#define AUD_SPDIF_IT_EN_SET__EOBURST__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__EOBURST__VALUE__SET 0x1
-
-#define AUD_SPDIF_IT_EN_SET__EOBLOCK__SHIFT      2
-#define AUD_SPDIF_IT_EN_SET__EOBLOCK__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__EOBLOCK__VALUE__SET 0x1
-
-#define AUD_SPDIF_IT_EN_SET__EOLATENCY__SHIFT      3
-#define AUD_SPDIF_IT_EN_SET__EOLATENCY__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__EOLATENCY__VALUE__SET 0x1
-
-#define AUD_SPDIF_IT_EN_SET__EOPD__SHIFT      4
-#define AUD_SPDIF_IT_EN_SET__EOPD__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__EOPD__VALUE__SET 0x1
-
-#define AUD_SPDIF_IT_EN_SET__NSAMPLE__SHIFT      5
-#define AUD_SPDIF_IT_EN_SET__NSAMPLE__MASK       0x1
-#define AUD_SPDIF_IT_EN_SET__NSAMPLE__VALUE__SET 0x1
-
-
-
-#define AUD_SPDIF_IT_EN_CLR 0x18
-
-#define AUD_SPDIF_IT_EN_CLR__UNF__SHIFT        0
-#define AUD_SPDIF_IT_EN_CLR__UNF__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__UNF__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_IT_EN_CLR__EOBURST__SHIFT        1
-#define AUD_SPDIF_IT_EN_CLR__EOBURST__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__EOBURST__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__SHIFT        2
-#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__EOBLOCK__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__SHIFT        3
-#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__EOLATENCY__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_IT_EN_CLR__EOPD__SHIFT        4
-#define AUD_SPDIF_IT_EN_CLR__EOPD__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__EOPD__VALUE__CLEAR 0x1
-
-#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__SHIFT        5
-#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__MASK         0x1
-#define AUD_SPDIF_IT_EN_CLR__NSAMPLE__VALUE__CLEAR 0x1
-
-
-
-#define AUD_SPDIF_CTRL 0x1c
-
-#define AUD_SPDIF_CTRL__MODE__SHIFT                    0
-#define AUD_SPDIF_CTRL__MODE__MASK                     0x7
-#define AUD_SPDIF_CTRL__MODE__VALUE__OFF               0x0
-#define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PCM_NULL     0x1
-#define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PAUSE_BURSTS 0x2
-#define AUD_SPDIF_CTRL__MODE__VALUE__PCM               0x3
-#define AUD_SPDIF_CTRL__MODE__VALUE__ENCODED           0x4
-
-#define AUD_SPDIF_CTRL__IDLE__SHIFT         3
-#define AUD_SPDIF_CTRL__IDLE__MASK          0x1
-#define AUD_SPDIF_CTRL__IDLE__VALUE__NORMAL 0x0
-#define AUD_SPDIF_CTRL__IDLE__VALUE__IDLE   0x1
-
-#define AUD_SPDIF_CTRL__RND__SHIFT                   4
-#define AUD_SPDIF_CTRL__RND__MASK                    0x1
-#define AUD_SPDIF_CTRL__RND__VALUE__NO_ROUNDING      0x0
-#define AUD_SPDIF_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
-
-#define AUD_SPDIF_CTRL__CLK_DIV__SHIFT 5
-#define AUD_SPDIF_CTRL__CLK_DIV__MASK  0xff
-
-#define AUD_SPDIF_CTRL__STUFFING__SHIFT           14
-#define AUD_SPDIF_CTRL__STUFFING__MASK            0x1
-#define AUD_SPDIF_CTRL__STUFFING__VALUE__SOFTWARE 0x0
-#define AUD_SPDIF_CTRL__STUFFING__VALUE__HARDWARE 0x1
-
-#define AUD_SPDIF_CTRL__MEMREAD__SHIFT 15
-#define AUD_SPDIF_CTRL__MEMREAD__MASK  0x1ffff
-
-
-
-#define AUD_SPDIF_STA 0x20
-
-#define AUD_SPDIF_STA__RUN_STOP__SHIFT          0
-#define AUD_SPDIF_STA__RUN_STOP__MASK           0x1
-#define AUD_SPDIF_STA__RUN_STOP__VALUE__STOPPED 0x0
-#define AUD_SPDIF_STA__RUN_STOP__VALUE__RUNNING 0x1
-
-#define AUD_SPDIF_STA__UNF__SHIFT           1
-#define AUD_SPDIF_STA__UNF__MASK            0x1
-#define AUD_SPDIF_STA__UNF__VALUE__DETECTED 0x1
-
-#define AUD_SPDIF_STA__EOBURST__SHIFT      2
-#define AUD_SPDIF_STA__EOBURST__MASK       0x1
-#define AUD_SPDIF_STA__EOBURST__VALUE__END 0x1
-
-#define AUD_SPDIF_STA__EOBLOCK__SHIFT      3
-#define AUD_SPDIF_STA__EOBLOCK__MASK       0x1
-#define AUD_SPDIF_STA__EOBLOCK__VALUE__END 0x1
-
-#define AUD_SPDIF_STA__EOLATENCY__SHIFT                         4
-#define AUD_SPDIF_STA__EOLATENCY__MASK                          0x1
-#define AUD_SPDIF_STA__EOLATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
-
-#define AUD_SPDIF_STA__PDDATA__SHIFT       5
-#define AUD_SPDIF_STA__PDDATA__MASK        0x1
-#define AUD_SPDIF_STA__PDDATA__VALUE__SENT 0x1
-
-#define AUD_SPDIF_STA__NSAMPLE__SHIFT       6
-#define AUD_SPDIF_STA__NSAMPLE__MASK        0x1
-#define AUD_SPDIF_STA__NSAMPLE__VALUE__DONE 0x1
-
-#define AUD_SPDIF_STA__PABIT__SHIFT       7
-#define AUD_SPDIF_STA__PABIT__MASK        0xff
-
-#define AUD_SPDIF_STA__PDPAUSE__SHIFT       15
-#define AUD_SPDIF_STA__PDPAUSE__MASK        0x1
-#define AUD_SPDIF_STA__PDPAUSE__VALUE__SENT 0x1
-
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-#define AUD_SPDIF_STA__SAMPLES_IN_FIFO__SHIFT 16
-#define AUD_SPDIF_STA__SAMPLES_IN_FIFO__MASK  0x1f
-#endif
-
-
-
-#define AUD_SPDIF_PA_PB 0x24
-
-#define AUD_SPDIF_PA_PB__PB__SHIFT 0
-#define AUD_SPDIF_PA_PB__PB__MASK  0xffff
-
-#define AUD_SPDIF_PA_PB__PA__SHIFT 16
-#define AUD_SPDIF_PA_PB__PA__MASK  0xffff
-
-
-
-#define AUD_SPDIF_PC_PD 0x28
-
-#define AUD_SPDIF_PC_PD__PD__SHIFT 0
-#define AUD_SPDIF_PC_PD__PD__MASK  0xffff
-
-#define AUD_SPDIF_PC_PD__PC__SHIFT 16
-#define AUD_SPDIF_PC_PD__PC__MASK  0xffff
-
-
-
-
-#define AUD_SPDIF_CL1 0x2c
-
-#define AUD_SPDIF_CL1__CL1__SHIFT 0
-#define AUD_SPDIF_CL1__CL1__MASK  0xffffffff
-
-
-
-#define AUD_SPDIF_CR1 0x30
-
-#define AUD_SPDIF_CR1__CR1__SHIFT 0
-#define AUD_SPDIF_CR1__CR1__MASK  0xffffffff
-
-
-/* LU, RU, LV & RV bits are described wrong in datasheet... */
-#define AUD_SPDIF_CL2_CR2_UV 0x34
-
-#define AUD_SPDIF_CL2_CR2_UV__CL2__SHIFT 0
-#define AUD_SPDIF_CL2_CR2_UV__CL2__MASK  0xf
-
-#define AUD_SPDIF_CL2_CR2_UV__CR2__SHIFT 8
-#define AUD_SPDIF_CL2_CR2_UV__CR2__MASK  0xf
-
-#define AUD_SPDIF_CL2_CR2_UV__LU__SHIFT  16
-#define AUD_SPDIF_CL2_CR2_UV__LU__MASK   0x1
-
-#define AUD_SPDIF_CL2_CR2_UV__RU__SHIFT  17
-#define AUD_SPDIF_CL2_CR2_UV__RU__MASK   0x1
-
-#define AUD_SPDIF_CL2_CR2_UV__LV__SHIFT  18
-#define AUD_SPDIF_CL2_CR2_UV__LV__MASK   0x1
-
-#define AUD_SPDIF_CL2_CR2_UV__RV__SHIFT  19
-#define AUD_SPDIF_CL2_CR2_UV__RV__MASK   0x1
-
-
-
-#define AUD_SPDIF_PAU_LAT 0x38
-
-#define AUD_SPDIF_PAU_LAT__LAT__SHIFT 0
-#define AUD_SPDIF_PAU_LAT__LAT__MASK  0xffff
-
-#define AUD_SPDIF_PAU_LAT__NPD_BURST__SHIFT 16
-#define AUD_SPDIF_PAU_LAT__NPD_BURST__MASK  0xffff
-
-
-
-#define AUD_SPDIF_BST_FL 0x3c
-
-#define AUD_SPDIF_BST_FL__PDBURST__SHIFT 0
-#define AUD_SPDIF_BST_FL__PDBURST__MASK  0xffff
-
-#define AUD_SPDIF_BST_FL__DBURST__SHIFT 16
-#define AUD_SPDIF_BST_FL__DBURST__MASK  0xffff
-
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-
-#define AUD_SPDIF_CONFIG 0x40
-
-#define AUD_SPDIF_CONFIG__P_BIT__SHIFT       0
-#define AUD_SPDIF_CONFIG__P_BIT__SHIFT__MASK 0x1
-#define AUD_SPDIF_CONFIG__P_BIT__VALUE__HW   0x0
-#define AUD_SPDIF_CONFIG__P_BIT__VALUE__FDMA 0x1
-
-#define AUD_SPDIF_CONFIG__C_BIT__SHIFT       1
-#define AUD_SPDIF_CONFIG__C_BIT__SHIFT__MASK 0x1
-#define AUD_SPDIF_CONFIG__C_BIT__VALUE__FDMA 0x0
-#define AUD_SPDIF_CONFIG__C_BIT__VALUE__HW   0x1
-
-#define AUD_SPDIF_CONFIG__U_BIT__SHIFT       2
-#define AUD_SPDIF_CONFIG__U_BIT__SHIFT__MASK 0x1
-#define AUD_SPDIF_CONFIG__U_BIT__VALUE__FDMA 0x0
-#define AUD_SPDIF_CONFIG__U_BIT__VALUE__HW   0x1
-
-#define AUD_SPDIF_CONFIG__V_BIT__SHIFT       2
-#define AUD_SPDIF_CONFIG__V_BIT__SHIFT__MASK 0x1
-#define AUD_SPDIF_CONFIG__V_BIT__VALUE__FDMA 0x0
-#define AUD_SPDIF_CONFIG__V_BIT__VALUE__HW   0x1
-
-#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__SHIFT           4
-#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__MASK            0x1
-#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__DISABLED 0x0
-#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_CONFIG__MEM_FMT__SHIFT                  5
-#define AUD_SPDIF_CONFIG__MEM_FMT__MASK                   0x1
-#define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
-#define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
-
-#define AUD_SPDIF_CONFIG__DTS_HD__SHIFT           6
-#define AUD_SPDIF_CONFIG__DTS_HD__MASK            0x1
-#define AUD_SPDIF_CONFIG__DTS_HD__VALUE__DISABLED 0x0
-#define AUD_SPDIF_CONFIG__DTS_HD__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_CONFIG__BACK_STALLING__SHIFT           7
-#define AUD_SPDIF_CONFIG__BACK_STALLING__MASK            0x1
-#define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__DISABLED 0x0
-#define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__ENABLED  0x1
-
-#define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__SHIFT 8
-#define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK  0x1f
-
-
-#endif
-
-#endif
diff --git a/include/linux/stm/registers/aud_spdifpc.h b/include/linux/stm/registers/aud_spdifpc.h
deleted file mode 100644
index 2d4aacb..0000000
--- a/include/linux/stm/registers/aud_spdifpc.h
+++ /dev/null
@@ -1,483 +0,0 @@
-#ifndef __STM_REGISTERS_AUD_SPDIFPC_H
-#define __STM_REGISTERS_AUD_SPDIFPC_H
-
-
-
-#define AUD_SPDIFPC_CFG 0x000
-
-#define AUD_SPDIFPC_CFG__DEVICE_EN__SHIFT           0
-#define AUD_SPDIFPC_CFG__DEVICE_EN__MASK            0x1
-#define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_CFG__SW_RESET__SHIFT          1
-#define AUD_SPDIFPC_CFG__SW_RESET__MASK           0x1
-#define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RUNNING 0x0
-#define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RESET   0x1
-
-#define AUD_SPDIFPC_CFG__FIFO_EN__SHIFT           2
-#define AUD_SPDIFPC_CFG__FIFO_EN__MASK            0x1
-#define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__SHIFT          3
-#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__MASK           0x3
-#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__16_BITS 0x0
-#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__20_BITS 0x1
-#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__24_BITS 0x2
-
-#define AUD_SPDIFPC_CFG__REQ_ACK_EN__SHIFT           5
-#define AUD_SPDIFPC_CFG__REQ_ACK_EN__MASK            0x1
-#define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__ENABLED  0x1
-
-/* Undocumented configuration bit, which exists in some hardware... */
-#define AUD_SPDIFPC_CFG__CHA_STA_BITS__SHIFT           6
-#define AUD_SPDIFPC_CFG__CHA_STA_BITS__MASK            0x1
-#define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__SUBFRAME 0x0
-#define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__FRAME    0x1
-
-
-
-#define AUD_SPDIFPC_STA 0x004
-
-#define AUD_SPDIFPC_STA__SOFT_RESET__SHIFT         1
-#define AUD_SPDIFPC_STA__SOFT_RESET__MASK          0x1
-#define AUD_SPDIFPC_STA__SOFT_RESET__VALUE__ACTIVE 0x1
-
-#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__SHIFT        2
-#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__MASK         0x1
-#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__VALUE__EMPTY 0x1
-
-#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__SHIFT           3
-#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__MASK            0x1
-#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__VALUE__DETECTED 0x1
-
-#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__SHIFT        4
-#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__MASK         0x1
-#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__VALUE__EMPTY 0x1
-
-#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__SHIFT           5
-#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__MASK            0x1
-#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__VALUE__DETECTED 0x1
-
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__SHIFT        6
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__MASK         0x1
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__VALUE__EMPTY 0x1
-
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__SHIFT           7
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__MASK            0x1
-#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__VALUE__DETECTED 0x1
-
-#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__SHIFT           8
-#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__MASK            0x1
-#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__VALUE__DETECTED 0x1
-
-#define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT       16
-#define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT__MASK 0x7
-
-
-
-#define AUD_SPDIFPC_IT_EN 0x008
-
-#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__SHIFT           0
-#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__SHIFT           1
-#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__SHIFT           2
-#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__SHIFT           3
-#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__SHIFT           4
-#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__SHIFT           5
-#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__SHIFT           6
-#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__SHIFT           7
-#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__SHIFT           8
-#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__SHIFT           16
-#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__SHIFT           17
-#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__SHIFT           18
-#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__SHIFT           19
-#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__SHIFT           20
-#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__SHIFT           21
-#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__SHIFT           22
-#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__ENABLED  0x1
-
-#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__SHIFT           31
-#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__MASK            0x1
-#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__DISABLED 0x0
-#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__ENABLED  0x1
-
-
-
-#define AUD_SPDIFPC_ITS 0x00c
-
-#define AUD_SPDIFPC_ITS__INTERRUPT__SHIFT          0
-#define AUD_SPDIFPC_ITS__INTERRUPT__MASK           0x1
-#define AUD_SPDIFPC_ITS__INTERRUPT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__SHIFT          1
-#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__SHIFT          2
-#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__SHIFT          3
-#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__SHIFT          4
-#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__SHIFT          5
-#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__SHIFT          6
-#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__SHIFT          7
-#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__SHIFT          8
-#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__RUN_STOP_INT__SHIFT          16
-#define AUD_SPDIFPC_ITS__RUN_STOP_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__RUN_STOP_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__SHIFT          17
-#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__EODATABURST_INT__SHIFT          18
-#define AUD_SPDIFPC_ITS__EODATABURST_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__EODATABURST_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__EOBLOCK_INT__SHIFT          19
-#define AUD_SPDIFPC_ITS__EOBLOCK_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__EOBLOCK_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__LATENCY_INT__SHIFT          20
-#define AUD_SPDIFPC_ITS__LATENCY_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__LATENCY_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__PD_DATA_BURST__SHIFT          21
-#define AUD_SPDIFPC_ITS__PD_DATA_BURST__MASK           0x1
-#define AUD_SPDIFPC_ITS__PD_DATA_BURST__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__SHIFT          22
-#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__VALUE__PENDING 0x1
-
-#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__SHIFT          31
-#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__MASK           0x1
-#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__VALUE__PENDING 0x1
-
-
-
-#define AUD_SPDIFPC_IT_CLR 0x010
-
-#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__SHIFT        0
-#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__SHIFT        1
-#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__SHIFT        2
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__SHIFT        3
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__SHIFT        4
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__SHIFT        5
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__SHIFT        6
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__SHIFT        7
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__SHIFT        8
-#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__SHIFT        16
-#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__SHIFT        17
-#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__SHIFT        18
-#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__SHIFT        19
-#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__SHIFT        20
-#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__SHIFT        21
-#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__SHIFT        22
-#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__VALUE__CLEAR 0x1
-
-#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__SHIFT        31
-#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__MASK         0x1
-#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__VALUE__CLEAR 0x1
-
-
-
-#define AUD_SPDIFPC_VAL 0x100
-
-#define AUD_SPDIFPC_VAL__VALIDITY_BITS__SHIFT 0
-#define AUD_SPDIFPC_VAL__VALIDITY_BITS__MASK  0xffffffff
-
-
-
-#define AUD_SPDIFPC_DATA 0x104
-
-#define AUD_SPDIFPC_DATA__USER_DATA_BITS__SHIFT 0
-#define AUD_SPDIFPC_DATA__USER_DATA_BITS__MASK  0xffffffff
-
-
-
-#define AUD_SPDIFPC_CHA_STA(n) (0x108 + (n) * 4)
-
-#define AUD_SPDIFPC_CHA_STA__CHA_STA__SHIFT 0
-#define AUD_SPDIFPC_CHA_STA__CHA_STA__MASK  0xffffffff
-
-
-
-#define AUD_SPDIFPC_CTRL 0x200
-
-#define AUD_SPDIFPC_CTRL__OPERATION__SHIFT                    0
-#define AUD_SPDIFPC_CTRL__OPERATION__MASK                     0x7
-#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__OFF               0x0
-#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PCM_NULL     0x1
-#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PAUSE_BURSTS 0x2
-#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__PCM               0x3
-#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__ENCODED           0x4
-
-#define AUD_SPDIFPC_CTRL__IDLE_STATE__SHIFT         3
-#define AUD_SPDIFPC_CTRL__IDLE_STATE__MASK          0x1
-#define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__NORMAL 0x0
-#define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__IDLE   0x1
-
-#define AUD_SPDIFPC_CTRL__ROUNDING__SHIFT                   4
-#define AUD_SPDIFPC_CTRL__ROUNDING__MASK                    0x1
-#define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__NO_ROUNDING      0x0
-#define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__16_BITS_ROUNDING 0x1
-
-#define AUD_SPDIFPC_CTRL__DIVIDER__SHIFT 5
-#define AUD_SPDIFPC_CTRL__DIVIDER__MASK  0xff
-
-#define AUD_SPDIFPC_CTRL__STUFFING__SHIFT           14
-#define AUD_SPDIFPC_CTRL__STUFFING__MASK            0x1
-#define AUD_SPDIFPC_CTRL__STUFFING__VALUE__SOFTWARE 0x0
-#define AUD_SPDIFPC_CTRL__STUFFING__VALUE__HARDWARE 0x1
-
-#define AUD_SPDIFPC_CTRL__NO_SAMPLES__SHIFT 15
-#define AUD_SPDIFPC_CTRL__NO_SAMPLES__MASK  0x1ffff
-
-
-
-#define AUD_SPDIFPC_SPDIFSTA 0x204
-
-#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__SHIFT          0
-#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__MASK           0x1
-#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__STOPPED 0x0
-#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__RUNNING 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__SHIFT           1
-#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__MASK            0x1
-#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__VALUE__DETECTED 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__SHIFT      2
-#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__MASK       0x1
-#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__VALUE__END 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__SHIFT      3
-#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__MASK       0x1
-#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__VALUE__END 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__LATENCY__SHIFT                         4
-#define AUD_SPDIFPC_SPDIFSTA__LATENCY__MASK                          0x1
-#define AUD_SPDIFPC_SPDIFSTA__LATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SHIFT       5
-#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__MASK        0x1
-#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__VALUE__SENT 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__SHIFT       6
-#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__MASK        0x1
-#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__VALUE__DONE 0x1
-
-#define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__SHIFT       7
-#define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__MASK        0xff
-
-#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SHIFT       5
-#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__MASK        0x1
-#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__VALUE__SENT 0x1
-
-
-
-#define AUD_SPDIFPC_PAUSE 0x208
-
-#define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__SHIFT 0
-#define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__MASK  0xffff
-
-#define AUD_SPDIFPC_PAUSE__PAUSE_LAT__SHIFT 16
-#define AUD_SPDIFPC_PAUSE__PAUSE_LAT__MASK  0xffff
-
-
-
-#define AUD_SPDIFPC_DATA_BURST 0x20c
-
-#define AUD_SPDIFPC_DATA_BURST__DATA_BURST__SHIFT 0
-#define AUD_SPDIFPC_DATA_BURST__DATA_BURST__MASK  0xffff
-
-#define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__SHIFT 16
-#define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__MASK  0xffff
-
-
-
-#define AUD_SPDIFPC_PA_PB 0x210
-
-#define AUD_SPDIFPC_PA_PB__PB__SHIFT 0
-#define AUD_SPDIFPC_PA_PB__PB__MASK  0xffff
-
-#define AUD_SPDIFPC_PA_PB__PA__SHIFT 16
-#define AUD_SPDIFPC_PA_PB__PA__MASK  0xffff
-
-
-
-#define AUD_SPDIFPC_PC_PD 0x214
-
-#define AUD_SPDIFPC_PC_PD__PD__SHIFT 0
-#define AUD_SPDIFPC_PC_PD__PD__MASK  0xffff
-
-#define AUD_SPDIFPC_PC_PD__PC__SHIFT 16
-#define AUD_SPDIFPC_PC_PD__PC__MASK  0xffff
-
-
-
-
-#define AUD_SPDIFPC_CL1 0x218
-
-#define AUD_SPDIFPC_CL1__CHANNEL_STATUS__SHIFT 0
-#define AUD_SPDIFPC_CL1__CHANNEL_STATUS__MASK  0xffffffff
-
-
-
-#define AUD_SPDIFPC_CR1 0x21c
-
-#define AUD_SPDIFPC_CR1__CH_STA__SHIFT 0
-#define AUD_SPDIFPC_CR1__CH_STA__MASK  0xffffffff
-
-
-
-#define AUD_SPDIFPC_SUV 0x220
-
-#define AUD_SPDIFPC_SUV__CH_STA_LEFT__SHIFT 0
-#define AUD_SPDIFPC_SUV__CH_STA_LEFT__MASK  0xf
-
-#define AUD_SPDIFPC_SUV__CH_STA_RIGHT__SHIFT 8
-#define AUD_SPDIFPC_SUV__CH_STA_RIGHT__MASK  0xf
-
-#define AUD_SPDIFPC_SUV__DATA_LEFT__SHIFT  16
-#define AUD_SPDIFPC_SUV__DATA_LEFT__MASK   0x1
-
-#define AUD_SPDIFPC_SUV__DATA_RIGHT__SHIFT  17
-#define AUD_SPDIFPC_SUV__DATA_RIGHT__MASK   0x1
-
-#define AUD_SPDIFPC_SUV__VAL_LEFT__SHIFT  18
-#define AUD_SPDIFPC_SUV__VAL_LEFT__MASK   0x1
-
-#define AUD_SPDIFPC_SUV__VAL_RIGHT__SHIFT  19
-#define AUD_SPDIFPC_SUV__VAL_RIGHT__MASK   0x1
-
-#endif
diff --git a/include/linux/stm/registers/audcfg.h b/include/linux/stm/registers/audcfg.h
deleted file mode 100644
index ccd5df2..0000000
--- a/include/linux/stm/registers/audcfg.h
+++ /dev/null
@@ -1,20 +0,0 @@
-#ifndef __STM_REGISTERS_AUDCFG_H
-#define __STM_REGISTERS_AUDCFG_H
-
-
-
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
-#include <linux/stm/registers/stx710x/audcfg.h>
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_STX7111
-#include <linux/stm/registers/stx7111/audcfg.h>
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
-#include <linux/stm/registers/stx7200/audcfg.h>
-#endif
-
-
-
-#endif
diff --git a/include/linux/stm/registers/audcfg_adac.h b/include/linux/stm/registers/audcfg_adac.h
deleted file mode 100644
index ec324ac..0000000
--- a/include/linux/stm/registers/audcfg_adac.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#ifndef __STM_REGISTERS_AUDCFG_ADAC_H
-#define __STM_REGISTERS_AUDCFG_ADAC_H
-
-
-
-#define AUDCFG_ADAC_CTRL 0x00
-
-#define AUDCFG_ADAC_CTRL__NRST__SHIFT         0
-#define AUDCFG_ADAC_CTRL__NRST__MASK          0x1
-#define AUDCFG_ADAC_CTRL__NRST__VALUE__RESET  0x0
-#define AUDCFG_ADAC_CTRL__NRST__VALUE__NORMAL 0x1
-
-#define AUDCFG_ADAC_CTRL__MODE__SHIFT          1
-#define AUDCFG_ADAC_CTRL__MODE__MASK           0x3
-#define AUDCFG_ADAC_CTRL__MODE__VALUE__DEFAULT 0x0
-
-#define AUDCFG_ADAC_CTRL__NSB__SHIFT             3
-#define AUDCFG_ADAC_CTRL__NSB__MASK              0x1
-#define AUDCFG_ADAC_CTRL__NSB__VALUE__POWER_DOWN 0x0
-#define AUDCFG_ADAC_CTRL__NSB__VALUE__NORMAL     0x1
-
-#define AUDCFG_ADAC_CTRL__SOFTMUTE__SHIFT         4
-#define AUDCFG_ADAC_CTRL__SOFTMUTE__MASK          0x1
-#define AUDCFG_ADAC_CTRL__SOFTMUTE__VALUE__NORMAL 0x0
-#define AUDCFG_ADAC_CTRL__SOFTMUTE__VALUE__MUTE   0x1
-
-#define AUDCFG_ADAC_CTRL__PDNANA__SHIFT             5
-#define AUDCFG_ADAC_CTRL__PDNANA__MASK              0x1
-#define AUDCFG_ADAC_CTRL__PDNANA__VALUE__POWER_DOWN 0x0
-#define AUDCFG_ADAC_CTRL__PDNANA__VALUE__NORMAL     0x1
-
-#define AUDCFG_ADAC_CTRL__PDNBG__SHIFT             6
-#define AUDCFG_ADAC_CTRL__PDNBG__MASK              0x1
-#define AUDCFG_ADAC_CTRL__PDNBG__VALUE__POWER_DOWN 0x0
-#define AUDCFG_ADAC_CTRL__PDNBG__VALUE__NORMAL     0x1
-
-
-
-#endif
diff --git a/include/linux/stm/registers/audcfg_fsyn.h b/include/linux/stm/registers/audcfg_fsyn.h
deleted file mode 100644
index 1934159..0000000
--- a/include/linux/stm/registers/audcfg_fsyn.h
+++ /dev/null
@@ -1,113 +0,0 @@
-#ifndef __STM_REGISTERS_AUDCFG_FSYN_H
-#define __STM_REGISTERS_AUDCFG_FSYN_H
-
-
-
-#define AUDCFG_FSYN_CFG 0x00
-
-#define AUDCFG_FSYN_CFG__RSTP__SHIFT          0
-#define AUDCFG_FSYN_CFG__RSTP__MASK           0x1
-#define AUDCFG_FSYN_CFG__RSTP__VALUE__RUNNING 0x0
-#define AUDCFG_FSYN_CFG__RSTP__VALUE__RESET   0x1
-
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__SHIFT 2
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__MASK  0xf
-#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (0 << n)
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (1 << n)
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (0 << n)
-#define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (1 << n)
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-#define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
-#define AUDCFG_FSYN_CFG__FS_EN__MASK               0x7
-#define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
-#define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-#define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
-#define AUDCFG_FSYN_CFG__FS_EN__MASK               0xf
-#define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
-#define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
-#endif
-/* Doesn't exist in 7200 - again, veeery strange... */
-
-#define AUDCFG_FSYN_CFG__NSB__SHIFT             10
-#define AUDCFG_FSYN_CFG__NSB__MASK              0xf
-#define AUDCFG_FSYN_CFG__NSB__VALUE__STANDBY(n) (0 << n)
-#define AUDCFG_FSYN_CFG__NSB__VALUE__ACTIVE(n)  (1 << n)
-
-#define AUDCFG_FSYN_CFG__NPDA__SHIFT             14
-#define AUDCFG_FSYN_CFG__NPDA__MASK              0x1
-#define AUDCFG_FSYN_CFG__NPDA__VALUE__POWER_DOWN 0x0
-#define AUDCFG_FSYN_CFG__NPDA__VALUE__NORMAL     0x1
-
-#define AUDCFG_FSYN_CFG__NDIV__SHIFT            15
-#define AUDCFG_FSYN_CFG__NDIV__MASK             0x1
-#define AUDCFG_FSYN_CFG__NDIV__VALUE__27_30_MHZ 0x0
-#define AUDCFG_FSYN_CFG__NDIV__VALUE__54_60_MHZ 0x1
-
-#define AUDCFG_FSYN_CFG__BW_SEL__SHIFT                      16
-#define AUDCFG_FSYN_CFG__BW_SEL__MASK                       0x3
-#define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_GOOD_REFERENCE 0x0
-#define AUDCFG_FSYN_CFG__BW_SEL__VALUE__GOOD_REFERENCE      0x1
-#define AUDCFG_FSYN_CFG__BW_SEL__VALUE__BAD_REFERENCE       0x2
-#define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_BAD_REFERENCE  0x3
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               24
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x3
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__FE900_CLOCK  0x0
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x1
-#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSCLKINALT  0x2
-#endif
-
-
-
-#define AUDCFG_FSYN_MD(n) ((n + 1) * 0x10 + 0x00)
-
-#define AUDCFG_FSYN_MD__MD__SHIFT 0
-#define AUDCFG_FSYN_MD__MD__MASK  0x1f
-
-
-
-#define AUDCFG_FSYN_PE(n) ((n + 1) * 0x10 + 0x04)
-
-#define AUDCFG_FSYN_PE__PE__SHIFT 0
-#define AUDCFG_FSYN_PE__PE__MASK  0xffff
-
-
-
-#define AUDCFG_FSYN_SDIV(n) ((n + 1) * 0x10 + 0x08)
-
-#define AUDCFG_FSYN_SDIV__SDIV__SHIFT 0
-#define AUDCFG_FSYN_SDIV__SDIV__MASK  0x7
-
-
-
-#define AUDCFG_FSYN_PROGEN(n) ((n + 1) * 0x10 + 0x0c)
-
-#define AUDCFG_FSYN_PROGEN__PROG_EN__SHIFT                  0
-#define AUDCFG_FSYN_PROGEN__PROG_EN__MASK                   0x1
-#define AUDCFG_FSYN_PROGEN__PROG_EN__VALUE__PE0_MD0_IGNORED 0x0
-#define AUDCFG_FSYN_PROGEN__PROG_EN__VALUE__PE0_MD0_USED    0x1
-
-
-
-
-#endif
diff --git a/include/linux/stm/registers/pwm.h b/include/linux/stm/registers/pwm.h
deleted file mode 100644
index a0f08e2..0000000
--- a/include/linux/stm/registers/pwm.h
+++ /dev/null
@@ -1,131 +0,0 @@
-#ifndef __STM_REGISTERS_PWM_H
-#define __STM_REGISTERS_PWM_H
-
-
-
-#define PWM_VAL(n) (0x00 + n * 0x04) /* R/W */
-
-#define PWM_VAL__PWM_VAL__SHIFT 0
-#define PWM_VAL__PWM_VAL__MASK  0xff
-
-
-
-#define PWM_CPT_VAL(n) (0x10 + (n * 0x04)) /* RO */
-
-#define PWM_CPT_VAL__CPT_VAL__SHIFT 0
-#define PWM_CPT_VAL__CPT_VAL__MASK  0xffffffff
-
-
-
-#define PWM_CMP_VAL(n) (0x20 + (n * 0x04)) /* R/W */
-
-#define PWM_CMP_VAL__CMP_VAL__SHIFT 0
-#define PWM_CMP_VAL__CMP_VAL__MASK  0xffffffff
-
-
-
-#define PWM_CPT_EDGE(n) (0x30 + (n * 0x04)) /* R/W */
-
-#define PWM_CPT_EDGE__CE__SHIFT 0
-#define PWM_CPT_EDGE__CE__MASK  0x3
-
-
-
-#define PWM_CMP_OUT_VAL(n) (0x40 + (n * 0x04)) /* R/W */
-
-#define PWM_CMP_OUT_VAL__CO__SHIFT 0
-#define PWM_CMP_OUT_VAL__CO__MASK  0x1
-
-
-
-#define PWM_CTRL 0x50 /* R/W */
-
-#define PWM_CTRL__PWM_CLK_VAL_3_0__SHIFT 0
-#define PWM_CTRL__PWM_CLK_VAL_3_0__MASK  0xf
-
-#define PWM_CTRL__CPT_CLK_VAL_4_0__SHIFT 4
-#define PWM_CTRL__CPT_CLK_VAL_4_0__MASK  0x1f
-
-#define PWM_CTRL__PWM_EN__SHIFT 9
-#define PWM_CTRL__PWM_EN__MASK  0x1
-
-#define PWM_CTRL__CPT_EN__SHIFT 10
-#define PWM_CTRL__CPT_EN__MASK  0x1
-
-#define PWM_CTRL__PWM_CLK_VAL_7_4__SHIFT 11
-#define PWM_CTRL__PWM_CLK_VAL_7_4__MASK	 0xf
-
-
-
-#define PWM_INT_EN 0x54 /* R/W */
-
-#define PWM_INT_EN__EN__SHIFT 0
-#define PWM_INT_EN__EN__MASK  0x1
-
-#define PWM_INT_EN__CPT0_INT_EN__SHIFT 1
-#define PWM_INT_EN__CPT0_INT_EN__MASK  0x1
-
-#define PWM_INT_EN__CPT1_INT_EN__SHIFT 2
-#define PWM_INT_EN__CPT1_INT_EN__MASK  0x1
-
-#define PWM_INT_EN__CMP0_INT_EN__SHIFT 5
-#define PWM_INT_EN__CMP0_INT_EN__MASK  0x1
-
-#define PWM_INT_EN__CMP1_INT_EN__SHIFT 6
-#define PWM_INT_EN__CMP1_INT_EN__MASK  0x1
-
-
-
-#define PWM_INT_STA 0x58 /* RO */
-
-#define PWM_INT_STA__PWM_INT__SHIFT  0
-#define PWM_INT_STA__PWM_INT__MASK   0x1
-
-#define PWM_INT_STA__CPT0_INT__SHIFT 1
-#define PWM_INT_STA__CPT0_INT__MASK  0x1
-
-#define PWM_INT_STA__CPT1_INT__SHIFT 2
-#define PWM_INT_STA__CPT1_INT__MASK  0x1
-
-#define PWM_INT_STA__CMP0_INT__SHIFT 5
-#define PWM_INT_STA__CMP0_INT__MASK  0x1
-
-#define PWM_INT_STA__CMP1_INT__SHIFT 6
-#define PWM_INT_STA__CMP1_INT__MASK  0x1
-
-
-
-#define PWM_INT_ACK 0x5c /* WO */
-
-#define PWM_INT_ACK__PWM_INT__SHIFT 0
-#define PWM_INT_ACK__PWM_INT__MASK  0x1
-
-#define PWM_INT_ACK__CPT0_INT__SHIFT 1
-#define PWM_INT_ACK__CPT0_INT__MASK  0x1
-
-#define PWM_INT_ACK__CPT1_INT__SHIFT 2
-#define PWM_INT_ACK__CPT1_INT__MASK  0x1
-
-#define PWM_INT_ACK__CMP0_INT__SHIFT 5
-#define PWM_INT_ACK__CMP0_INT__MASK  0x1
-
-#define PWM_INT_ACK__CMP1_INT__SHIFT 6
-#define PWM_INT_ACK__CMP1_INT__MASK  0x1
-
-
-
-#define PWM_CNT 0x60 /* R, W only when PWM timer is disabled */
-
-#define PWM_CNT__PWM_CNT__SHIFT 0
-#define PWM_CNT__PWM_CNT__MASK  0xff
-
-
-
-#define PWM_CPT_CMP_CNT 0x64 /* R/W */
-
-#define PWM_CPT_CMP_CNT__CPT_CMP_CNT__SHIFT 0
-#define PWM_CPT_CMP_CNT__CPT_CMP_CNT__MASK  0xffffffff
-
-
-
-#endif
diff --git a/include/linux/stm/registers/stx710x/audcfg.h b/include/linux/stm/registers/stx710x/audcfg.h
deleted file mode 100644
index 4e33612..0000000
--- a/include/linux/stm/registers/stx710x/audcfg.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef __STM_REGISTERS_STX710x_AUDCFG_H
-#define __STM_REGISTERS_STX710x_AUDCFG_H
-
-
-
-#define AUDCFG_IO_CTRL 0x00
-
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__DATA0_EN__SHIFT         1
-#define AUDCFG_IO_CTRL__DATA0_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__DATA0_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__DATA0_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__DATA1_EN__SHIFT         2
-#define AUDCFG_IO_CTRL__DATA1_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__DATA1_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__DATA1_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__SPDIF_EN__SHIFT          3
-#define AUDCFG_IO_CTRL__SPDIF_EN__MASK           0x1
-#define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__DISABLE 0x0
-#define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__ENABLE  0x1
-
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__SHIFT               4
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__MASK                0x1
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__PCM_PLAYER   0x0
-#define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__SPDIF_PLAYER 0x1
-/* Actually, in 7109 it seems to be a separate register (offset 0x04...) */
-
-
-
-#endif
diff --git a/include/linux/stm/registers/stx7111/audcfg.h b/include/linux/stm/registers/stx7111/audcfg.h
deleted file mode 100644
index 929ec9b..0000000
--- a/include/linux/stm/registers/stx7111/audcfg.h
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifndef __STM_REGISTERS_STX7111_AUDCFG_H
-#define __STM_REGISTERS_STX7111_AUDCFG_H
-
-
-
-#define AUDCFG_IO_CTRL 0x00
-
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__SHIFT         3
-#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__SHIFT         5
-#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__MASK          0x1
-#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__INPUT  0x0
-#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IO_CTRL__CLKREC_SEL__SHIFT            9
-#define AUDCFG_IO_CTRL__CLKREC_SEL__MASK             0x3
-#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPLHDMI 0x0
-#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__SPDIFHDMI 0x1
-#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPL1    0x2
-
-#endif
diff --git a/include/linux/stm/registers/stx7200/audcfg.h b/include/linux/stm/registers/stx7200/audcfg.h
deleted file mode 100644
index 8fcb725..0000000
--- a/include/linux/stm/registers/stx7200/audcfg.h
+++ /dev/null
@@ -1,79 +0,0 @@
-#ifndef __STM_REGISTERS_STX7200_AUDCFG_H
-#define __STM_REGISTERS_STX7200_AUDCFG_H
-
-
-
-#define AUDCFG_IOMUX_CTRL 0x00
-
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__SHIFT         0
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__MASK          0x1
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
-#define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IOMUX_CTRL__DATA0_EN__SHIFT         1
-#define AUDCFG_IOMUX_CTRL__DATA0_EN__MASK          0x1
-#define AUDCFG_IOMUX_CTRL__DATA0_EN__VALUE__INPUT  0x0
-#define AUDCFG_IOMUX_CTRL__DATA0_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IOMUX_CTRL__DATA1_EN__SHIFT         2
-#define AUDCFG_IOMUX_CTRL__DATA1_EN__MASK          0x1
-#define AUDCFG_IOMUX_CTRL__DATA1_EN__VALUE__INPUT  0x0
-#define AUDCFG_IOMUX_CTRL__DATA1_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IOMUX_CTRL__DATA2_EN__SHIFT         3
-#define AUDCFG_IOMUX_CTRL__DATA2_EN__MASK          0x1
-#define AUDCFG_IOMUX_CTRL__DATA2_EN__VALUE__INPUT  0x0
-#define AUDCFG_IOMUX_CTRL__DATA2_EN__VALUE__OUTPUT 0x1
-
-#define AUDCFG_IOMUX_CTRL__SPDIF_EN__SHIFT          4
-#define AUDCFG_IOMUX_CTRL__SPDIF_EN__MASK           0x1
-#define AUDCFG_IOMUX_CTRL__SPDIF_EN__VALUE__DISABLE 0x0
-#define AUDCFG_IOMUX_CTRL__SPDIF_EN__VALUE__ENABLE  0x1
-
-
-
-#define AUDCFG_HDMI_CTRL 0x04
-
-#define AUDCFG_HDMI_CTRL__HDMI_DEBUG__SHIFT              0
-#define AUDCFG_HDMI_CTRL__HDMI_DEBUG__MASK               0x1
-#define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__PCM_PLAYERS 0x0
-#define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__HDMI        0x1
-
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__SHIFT              1
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__MASK               0x1
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_PCM_PLAYER   0x0
-#define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_SPDIF_PLAYER 0x1
-
-
-
-#define AUDCFG_RECOVERY_CTRL 0x08
-
-#define AUDCFG_RECOVERY_CTRL__RECO_EN0__SHIFT 0
-#define AUDCFG_RECOVERY_CTRL__RECO_EN0__MASK  0x1
-
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__SHIFT       1
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__MASK        0x3
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK0 0x0
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK1 0x1
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK2 0x2
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK3 0x3
-
-#define AUDCFG_RECOVERY_CTRL__RECO_EXT0__SHIFT 3
-#define AUDCFG_RECOVERY_CTRL__RECO_EXT0__MASK  0x1
-
-#define AUDCFG_RECOVERY_CTRL__RECO_EN1__SHIFT 4
-#define AUDCFG_RECOVERY_CTRL__RECO_EN1__MASK  0x1
-
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__SHIFT       5
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__MASK        0x3
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK0 0x0
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK1 0x1
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK2 0x2
-#define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK3 0x3
-
-#define AUDCFG_RECOVERY_CTRL__RECO_EXT1__SHIFT 7
-#define AUDCFG_RECOVERY_CTRL__RECO_EXT1__MASK  0x1
-
-
-
-#endif
diff --git a/include/sound/stm.h b/include/sound/stm.h
index c6ae539..3c68076 100644
--- a/include/sound/stm.h
+++ b/include/sound/stm.h
@@ -36,19 +36,19 @@
 /* Link type (format) description
  * Please note, that 0 value means I2S with 32 bits per
  * subframe (channel) and is a default setting. */
-#define SND_STM_FORMAT__I2S              0x00000000
-#define SND_STM_FORMAT__LEFT_JUSTIFIED   0x00000001
-#define SND_STM_FORMAT__RIGHT_JUSTIFIED  0x00000002
-#define SND_STM_FORMAT__SPDIF            0x00000003
+#define SND_STM_FORMAT__I2S              0x00000001
+#define SND_STM_FORMAT__LEFT_JUSTIFIED   0x00000002
+#define SND_STM_FORMAT__RIGHT_JUSTIFIED  0x00000003
+#define SND_STM_FORMAT__SPDIF            0x00000004
 #define SND_STM_FORMAT__MASK             0x0000000f
 
 /* Following values are valid only for I2S, Left Justified and
  * Right justified formats and can be bit-added to format;
  * they define size of one subframe (channel) transmitted.
  * For SPDIF the frame size is fixed and defined by standard. */
-#define SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS 0x00000000
-#define SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS 0x00000010
-#define SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK    0x000000f0
+#define SND_STM_FORMAT__SUBFRAME_32_BITS 0x00000010
+#define SND_STM_FORMAT__SUBFRAME_16_BITS 0x00000020
+#define SND_STM_FORMAT__SUBFRAME_MASK    0x000000f0
 
 /* Converter handle */
 struct snd_stm_conv {
@@ -68,7 +68,9 @@ struct snd_stm_conv {
 	struct snd_stm_conv *master;
 };
 
-int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source);
+/* Returns negative value on error or unique converter index number (>=0) */
+int snd_stm_conv_attach(struct snd_stm_conv *conv, struct bus_type *source_bus,
+		const char *source_bus_id);
 
 
 
@@ -82,50 +84,66 @@ int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source);
  * as a platform data:
  *
  * static struct i2c_board_info external_dac __initdata = {
- * 	.driver_name = "snd_conv_i2c",
+ * 	I2C_BOARD_INFO("snd_conv_i2c", <I2C address>),
  * 	.type = "<i.e. chip model>",
- * 	.addr = <I2C address>
  * 	.platform_data = &(struct snd_stm_conv_i2c_info) {
  * 		<see below>
  * 	},
  * };
  *
- * and add it using:
+ * and add it:
  *
- * i2c_new_device(i2c_get_adapter(<i2c adapter (bus) id>), &external_dac);
+ * i2c_register_board_info(<I2C bus number>, &external_dac, 1);
  */
-
 struct snd_stm_conv_i2c_info {
 	const char *name;
-	const char *card_id;
+
+	int card_device;
+	const char *source_bus_id;
+	unsigned int format;
+	int oversampling;
 
 	const char *enable_cmd;
 	int enable_cmd_len;
 	const char *disable_cmd;
 	int disable_cmd_len;
+
+	int mute_supported;
 	const char *mute_cmd;
 	int mute_cmd_len;
 	const char *unmute_cmd;
 	int unmute_cmd_len;
 };
 
-/* GPIO-controlled (STPIO interface) DAC/ADC generic implementation
+/* GPIO-controlled DAC/ADC generic implementation
  *
- * Define platform device named "snd_conv_stpio", pass
+ * Define platform device named "snd_conv_gpio", pass
  * following structure as platform_data and add it in normal way :-) */
+struct snd_stm_conv_gpio_info {
+	const char *name;
+
+	int card_device;
+	const char *source_bus_id;
+	unsigned int format;
+	int oversampling;
 
-struct snd_stm_conv_stpio_info {
+	unsigned enable_gpio;
+	int enable_value;
+
+	int mute_supported;
+	unsigned mute_gpio;
+	int mute_value;
+};
+
+/* Dummy converter - use it (as a platform device) to define format or
+ * oversampling only */
+struct snd_stm_conv_dummy_info {
 	const char *name;
-	const char *card_id;
-
-	struct stpio_pin *enable_pin;
-	unsigned int enable_value;
-	struct stpio_pin *disable_pin;
-	unsigned int disable_value;
-	struct stpio_pin *mute_pin;
-	unsigned int mute_value;
-	struct stpio_pin *unmute_pin;
-	unsigned int unmute_value;
+
+	int card_device;
+	const char *source_bus_id;
+	unsigned int format;
+	int oversampling;
 };
 
 #endif
diff --git a/sound/Kconfig b/sound/Kconfig
index e48b9b3..34df9c2 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -81,6 +81,9 @@ source "sound/parisc/Kconfig"
 
 source "sound/soc/Kconfig"
 
+# STMicroelectronics' SoCs support
+source "sound/stm/Kconfig"
+
 endmenu
 
 menu "Open Sound System"
diff --git a/sound/Makefile b/sound/Makefile
index 3ead922..4b43af5 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -5,7 +5,7 @@ obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/ stm/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index aa59da0..97b2552 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -32,7 +32,4 @@ source "sound/soc/sh/Kconfig"
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
-# STMicroelectronics' SoCs support
-source "sound/soc/stm/Kconfig"
-
 endmenu
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 3cb891b..3041403 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -2,5 +2,3 @@ snd-soc-core-objs := soc-core.o soc-dapm.o
 
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/ at91/ pxa/ s3c24xx/ sh/
-
-obj-$(CONFIG_SND_STM)   += stm/
\ No newline at end of file
diff --git a/sound/soc/stm/Kconfig b/sound/soc/stm/Kconfig
deleted file mode 100644
index 3c5bdfb..0000000
--- a/sound/soc/stm/Kconfig
+++ /dev/null
@@ -1,12 +0,0 @@
-config SND_STM
-	tristate "STMicroelectronics SoCs support"
-	depends on SND
-	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200
-	select SND_PCM
-	select STM_DMA
-	select BPA2
-	help
-	  Say Y here for ALSA support on the STx710x, STx7111 & STx7200 families.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called snd-stm.o
\ No newline at end of file
diff --git a/sound/soc/stm/Makefile b/sound/soc/stm/Makefile
deleted file mode 100644
index 3bf2230..0000000
--- a/sound/soc/stm/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-obj-$(CONFIG_SND_STM) += snd-stm.o
-snd-stm-y := init.o common.o synchro.o
-snd-stm-$(CONFIG_CPU_SUBTYPE_STB7100) += stx710x.o
-snd-stm-$(CONFIG_CPU_SUBTYPE_STX7111) += stx7111.o
-snd-stm-$(CONFIG_CPU_SUBTYPE_STX7200) += stx7200.o
-snd-stm-y += audio_outputs.o conv.o conv_dummy.o conv_i2s-spdif.o conv_internal_dac.o
-snd-stm-y += fsynth.o pcm_player.o pcm_reader.o spdif_player.o
diff --git a/sound/soc/stm/audio_outputs.c b/sound/soc/stm/audio_outputs.c
deleted file mode 100644
index 30d9722..0000000
--- a/sound/soc/stm/audio_outputs.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- *   STx7200 System-on-Chip audio outputs control driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/info.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 1 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Audio control instance structure
- */
-
-struct snd_stm_audio_outputs {
-	struct resource *mem_region;
-
-	void *base;
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-static void snd_stm_audio_outputs_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_audio_outputs *audio_outputs = entry->private_data;
-
-	snd_assert(audio_outputs, return);
-	snd_stm_magic_assert(audio_outputs, return);
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
-	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
-			REGISTER_PEEK(audio_outputs->base, AUDCFG_IO_CTRL));
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-	snd_iprintf(buffer, "AUDCFG_IOMUX_CTRL (offset 0x00) = 0x%08x\n",
-			REGISTER_PEEK(audio_outputs->base, AUDCFG_IOMUX_CTRL));
-	snd_iprintf(buffer, "AUDCFG_HDMI_CTRL (offset 0x04) = 0x%08x\n",
-			REGISTER_PEEK(audio_outputs->base, AUDCFG_HDMI_CTRL));
-	snd_iprintf(buffer, "AUDCFG_RECOVERY_CTRL (offset 0x08) = 0x%08x\n",
-			REGISTER_PEEK(audio_outputs->base,
-			AUDCFG_RECOVERY_CTRL));
-#endif
-}
-
-static int snd_stm_audio_outputs_register(struct snd_device *snd_device)
-{
-	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
-
-	snd_assert(audio_outputs, return -EINVAL);
-	snd_stm_magic_assert(audio_outputs, return -EINVAL);
-
-	/* Enable audio outputs */
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, ENABLE) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, ENABLE) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, OUTPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, OUTPUT));
-#endif
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&audio_outputs->proc_entry, "audio_outputs",
-			snd_stm_audio_outputs_dump_registers, audio_outputs);
-
-	return 0;
-}
-
-static int snd_stm_audio_outputs_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
-
-	snd_assert(audio_outputs, return -EINVAL);
-	snd_stm_magic_assert(audio_outputs, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(audio_outputs->proc_entry);
-
-	/* Disable audio outputs */
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, DISABLE) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, DISABLE) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, INPUT) |
-			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, INPUT));
-#endif
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_audio_outputs_snd_device_ops = {
-	.dev_register = snd_stm_audio_outputs_register,
-	.dev_disconnect = snd_stm_audio_outputs_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_audio_outputs *audio_outputs;
-	struct snd_card *card;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	audio_outputs = kzalloc(sizeof(*audio_outputs), GFP_KERNEL);
-	if (!audio_outputs) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(audio_outputs);
-
-	result = snd_stm_memory_request(pdev, &audio_outputs->mem_region,
-			&audio_outputs->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	card = snd_stm_cards_default();
-	snd_assert(card, return -EINVAL);
-	snd_printd("Audio output controls will be a member of a card '%s'\n",
-		card->id);
-
-	/* Register HDMI route control */
-
-	/* TODO */
-
-
-	/* ALSA component */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, audio_outputs,
-			&snd_stm_audio_outputs_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, audio_outputs);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return result;
-
-error_device:
-	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
-error_memory_request:
-	snd_stm_magic_clear(audio_outputs);
-	kfree(audio_outputs);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_audio_outputs_remove(struct platform_device *pdev)
-{
-	struct snd_stm_audio_outputs *audio_outputs =
-			platform_get_drvdata(pdev);
-
-	snd_assert(audio_outputs, return -EINVAL);
-	snd_stm_magic_assert(audio_outputs, return -EINVAL);
-
-	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
-
-	snd_stm_magic_clear(audio_outputs);
-	kfree(audio_outputs);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_audio_outputs_driver = {
-	.driver = {
-		.name = "audio_outputs",
-	},
-	.probe = snd_stm_audio_outputs_probe,
-	.remove = snd_stm_audio_outputs_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_audio_outputs_init(void)
-{
-	return platform_driver_register(&snd_stm_audio_outputs_driver);
-}
-
-void snd_stm_audio_outputs_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_audio_outputs_driver);
-}
diff --git a/sound/soc/stm/common.c b/sound/soc/stm/common.c
deleted file mode 100644
index 96d9bee..0000000
--- a/sound/soc/stm/common.c
+++ /dev/null
@@ -1,641 +0,0 @@
-/*
- *   Helpful ;-) routines for STMicroelectronics' SoCs audio drivers
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/platform_device.h>
-#include <linux/stm/soc.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/info.h>
-#include <sound/pcm_params.h>
-#include <sound/asoundef.h>
-
-#undef TRACE
-#include "common.h"
-
-
-
-/*
- * Cards management
- */
-
-static struct snd_card *snd_stm_cards[SNDRV_CARDS];
-static struct snd_card *snd_stm_default;
-
-/* Card list initialization/cleanup */
-
-int __init snd_stm_cards_init(const char *driver, struct snd_stm_card *cards,
-		int num_cards)
-{
-	int result = 0;
-	int i;
-
-	for (i = 0; i < num_cards; i++) {
-		int card = cards[i].index;
-
-		snd_stm_cards[card] = snd_card_new(card, cards[i].id,
-				THIS_MODULE, 0);
-		if (snd_stm_cards[card] == NULL) {
-			snd_stm_cards_free();
-			result = -ENOMEM;
-			break;
-		}
-
-		if (snd_stm_default == NULL)
-			snd_stm_default = snd_stm_cards[i];
-
-		strcpy(snd_stm_cards[card]->driver, driver);
-		strcpy(snd_stm_cards[card]->shortname, cards[i].short_name);
-		strcpy(snd_stm_cards[card]->longname, cards[i].long_name);
-
-		snd_printd("Card %d ('%s') created:\n", card, cards[i].id);
-		snd_printd("- driver: %s,\n", snd_stm_cards[card]->driver);
-		snd_printd("- short name: %s,\n",
-				snd_stm_cards[card]->shortname);
-		snd_printd("- long name: %s.\n", snd_stm_cards[card]->longname);
-	}
-
-	return result;
-}
-
-int __init snd_stm_cards_register(void)
-{
-	int result = -ENODEV;
-	int i;
-
-	for (i = 0; i < SNDRV_CARDS; i++) {
-		if (snd_stm_cards[i]) {
-			result = snd_card_register(snd_stm_cards[i]);
-			if (result < 0) {
-				snd_stm_cards_free();
-				break;
-			}
-		}
-	}
-
-	return result;
-}
-
-void snd_stm_cards_free(void)
-{
-	int i;
-
-	for (i = 0; i < SNDRV_CARDS; i++) {
-		if (snd_stm_cards[i]) {
-			snd_card_free(snd_stm_cards[i]);
-			snd_stm_cards[i] = NULL;
-		}
-	}
-}
-
-/* Card list access */
-
-struct snd_card __init *snd_stm_cards_get(const char *id)
-{
-	int i;
-
-	for (i = 0; i < SNDRV_CARDS; i++)
-		if (snd_stm_cards[i] &&
-				strcmp(snd_stm_cards[i]->id, id) == 0)
-			return snd_stm_cards[i];
-
-	snd_stm_printe("Unknown card %s requested!\n", id);
-	return NULL;
-}
-
-struct snd_card __init *snd_stm_cards_default(void)
-{
-	return snd_stm_default;
-}
-
-
-
-/*
- * Device management
- */
-
-static void dummy_release(struct device *dev)
-{
-}
-
-int __init snd_stm_add_plaform_devices(struct platform_device **devices,
-		int cnt)
-{
-	int result = 0;
-	int i;
-
-	for (i = 0; i < cnt; i++) {
-		devices[i]->dev.release = dummy_release;
-		result = platform_device_register(devices[i]);
-		if (result != 0) {
-			while (--i >= 0)
-				platform_device_unregister(devices[i]);
-			break;
-		}
-	}
-
-	return result;
-}
-
-void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
-		int cnt)
-{
-	int i;
-
-	for (i = 0; i < cnt; i++)
-		platform_device_unregister(devices[i]);
-}
-
-static int snd_stm_bus_id_match(struct device *device, void *bus_id)
-{
-	return strcmp(device->bus_id, bus_id) == 0;
-}
-
-struct device *snd_stm_find_device(struct bus_type *bus,
-		const char *bus_id)
-{
-	if (bus == NULL)
-		bus = &platform_bus_type;
-	return bus_find_device(bus, NULL, (void *)bus_id, snd_stm_bus_id_match);
-}
-
-
-
-
-/*
- * Resources management
- */
-
-int __init snd_stm_memory_request(struct platform_device *pdev,
-		struct resource **mem_region, void **base_address)
-{
-	struct resource *resource;
-
-	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!resource) {
-		snd_stm_printe("Failed to"
-				" platform_get_resource(IORESOURCE_MEM)!\n");
-		return -ENODEV;
-	}
-
-	*mem_region = request_mem_region(resource->start,
-			resource->end - resource->start + 1, pdev->name);
-	if (!*mem_region) {
-		snd_stm_printe("Failed request_mem_region(0x%08x,"
-				" 0x%08x, '%s')!\n", resource->start,
-				resource->end - resource->start + 1,
-				pdev->name);
-		return -EBUSY;
-	}
-	snd_printd("Memory region: 0x%08x-0x%08x\n",
-			(*mem_region)->start, (*mem_region)->end);
-
-	*base_address = ioremap(resource->start,
-			resource->end - resource->start + 1);
-	if (!*base_address) {
-		release_resource(*mem_region);
-		snd_stm_printe("Failed ioremap!\n");
-		return -EINVAL;
-	}
-
-	snd_stm_printt("Base address is 0x%p.\n", base_address);
-
-	return 0;
-}
-
-void snd_stm_memory_release(struct resource *mem_region,
-		void *base_address)
-{
-	iounmap(base_address);
-	release_resource(mem_region);
-}
-
-int  __init snd_stm_irq_request(struct platform_device *pdev,
-		unsigned int *irq, irq_handler_t handler, void *dev_id)
-{
-	struct resource *resource;
-	int result;
-
-	resource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!resource) {
-		snd_stm_printe("Failed to "
-				"platform_get_resource(IORESOURCE_IRQ)!\n");
-		return -ENODEV;
-	}
-	snd_printd("IRQ: %u\n", resource->start);
-
-	*irq = resource->start;
-
-	result = request_irq(*irq, handler, IRQF_DISABLED, pdev->name, dev_id);
-	if (result != 0) {
-		snd_stm_printe("Failed request_irq!\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int __init snd_stm_fdma_request(struct platform_device *pdev,
-		unsigned int *channel)
-{
-	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
-	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
-	static const char *fdma_cap_hb[] = { STM_DMA_CAP_HIGH_BW, NULL };
-
-	*channel = request_dma_bycap(fdmac_id, fdma_cap_lb, pdev->name);
-	if (*channel < 0) {
-		*channel = request_dma_bycap(fdmac_id, fdma_cap_hb, pdev->name);
-		if (*channel < 0) {
-			snd_stm_printe("Failed to request_dma_bycap()==%d!\n",
-					*channel);
-			return -ENODEV;
-		}
-	}
-	snd_printd("FDMA channel: %d\n", *channel);
-
-	return 0;
-}
-
-
-
-/*
- * ALSA procfs additional entries
- */
-
-static struct snd_info_entry *snd_stm_info_root;
-
-int __init snd_stm_info_init(void)
-{
-	int result = 0;
-
-	snd_stm_info_root = snd_info_create_module_entry(THIS_MODULE,
-			"stm", NULL);
-	if (snd_stm_info_root) {
-		snd_stm_info_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
-		if (snd_info_register(snd_stm_info_root) < 0) {
-			result = -EINVAL;
-			snd_info_free_entry(snd_stm_info_root);
-		}
-	} else {
-		result = -ENOMEM;
-	}
-
-	return result;
-}
-
-void snd_stm_info_cleanup(void)
-{
-	if (snd_stm_info_root)
-		snd_info_free_entry(snd_stm_info_root);
-}
-
-int snd_stm_info_register(struct snd_info_entry **entry,
-		const char *name,
-		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
-		void *private_data)
-{
-	int result = 0;
-
-	*entry = snd_info_create_module_entry(THIS_MODULE, name,
-			snd_stm_info_root);
-	if (*entry) {
-		(*entry)->c.text.read = read;
-		(*entry)->private_data = private_data;
-		if (snd_info_register(*entry) < 0) {
-			result = -EINVAL;
-			snd_info_free_entry(*entry);
-		}
-	} else {
-		result = -EINVAL;
-	}
-	return result;
-}
-
-void snd_stm_info_unregister(struct snd_info_entry *entry)
-{
-	if (entry)
-		snd_info_free_entry(entry);
-}
-
-
-
-/*
- * ALSA PCM buffer memory mapping
- */
-
-static struct page *snd_stm_mmap_nopage(struct vm_area_struct *area,
-		unsigned long address, int *type)
-{
-	/* No VMA expanding here! */
-	return NOPAGE_SIGBUS;
-}
-
-static struct vm_operations_struct snd_stm_mmap_vm_ops = {
-	.open =   snd_pcm_mmap_data_open,
-	.close =  snd_pcm_mmap_data_close,
-	.nopage = snd_stm_mmap_nopage,
-};
-
-int snd_stm_mmap(struct snd_pcm_substream *substream,
-		struct vm_area_struct *area)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long map_offset = area->vm_pgoff << PAGE_SHIFT;
-	unsigned long phys_addr = runtime->dma_addr + map_offset;
-	unsigned long map_size = area->vm_end - area->vm_start;
-	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
-			runtime->dma_bytes % PAGE_SIZE;
-
-	snd_stm_printt("snd_stm_pcm_mmap(substream=0x%p)\n",
-			substream);
-
-	snd_stm_printt("Mmaping %lu bytes starting from 0x%08lx "
-			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
-			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
-			phys_addr, runtime->dma_addr, runtime->dma_bytes,
-			area->vm_pgoff, area->vm_start, area->vm_end);
-
-	if (map_size > phys_size) {
-		snd_stm_printe("Trying to perform mmap larger than buffer!\n");
-		return -EINVAL;
-	}
-
-	area->vm_ops = &snd_stm_mmap_vm_ops;
-	area->vm_private_data = substream;
-	area->vm_flags |= VM_RESERVED;
-	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
-
-	if (remap_pfn_range(area, area->vm_start, phys_addr >> PAGE_SHIFT,
-			map_size, area->vm_page_prot) != 0) {
-		snd_stm_printe("Can't remap buffer!\n");
-		return -EAGAIN;
-	}
-
-	/* Must be called implicitly here... */
-	snd_pcm_mmap_data_open(area);
-
-	return 0;
-}
-
-
-
-/*
- * Common ALSA parameters constraints
- */
-
-/*
-#define FIXED_TRANSFER_BYTES max_transfer_bytes > 16 ? 16 : max_transfer_bytes
-#define FIXED_TRANSFER_BYTES max_transfer_bytes
-*/
-
-#ifdef FIXED_TRANSFER_BYTES
-
-int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
-		unsigned int max_transfer_bytes)
-{
-	int transfer_bytes = FIXED_TRANSFER_BYTES;
-
-	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
-			"max_transfer_bytes=%u) = %u (FIXED)\n",
-			bytes_per_frame, max_transfer_bytes, transfer_bytes);
-
-	return transfer_bytes;
-}
-
-int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
-		unsigned int max_transfer_bytes)
-{
-	return snd_pcm_hw_constraint_step(runtime, 0,
-			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-			snd_stm_pcm_transfer_bytes(0, max_transfer_bytes));
-}
-
-#else
-
-int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
-		unsigned int max_transfer_bytes)
-{
-	unsigned int transfer_bytes;
-
-	for (transfer_bytes = bytes_per_frame;
-			transfer_bytes * 2 < max_transfer_bytes;
-			transfer_bytes *= 2)
-		;
-
-	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
-			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
-			max_transfer_bytes, transfer_bytes);
-
-	return transfer_bytes;
-}
-
-static int snd_stm_pcm_hw_rule_transfer_bytes(struct snd_pcm_hw_params *params,
-		struct snd_pcm_hw_rule *rule)
-{
-	int changed = 0;
-	unsigned int max_transfer_bytes = (unsigned int)rule->private;
-	struct snd_interval *period_bytes = hw_param_interval(params,
-			SNDRV_PCM_HW_PARAM_PERIOD_BYTES);
-	struct snd_interval *frame_bits = hw_param_interval(params,
-			SNDRV_PCM_HW_PARAM_FRAME_BITS);
-	unsigned int transfer_bytes, n;
-
-	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->min / 8,
-			max_transfer_bytes);
-	n = period_bytes->min % transfer_bytes;
-	if (n != 0 || period_bytes->openmin) {
-		period_bytes->min += transfer_bytes - n;
-		changed = 1;
-	}
-
-	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->max / 8,
-			max_transfer_bytes);
-	n = period_bytes->max % transfer_bytes;
-	if (n != 0 || period_bytes->openmax) {
-		period_bytes->max -= n;
-		changed = 1;
-	}
-
-	if (snd_interval_checkempty(period_bytes)) {
-		period_bytes->empty = 1;
-		return -EINVAL;
-	}
-
-	return changed;
-}
-
-int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
-		unsigned int max_transfer_bytes)
-{
-	return snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-			snd_stm_pcm_hw_rule_transfer_bytes,
-			(void *)max_transfer_bytes,
-			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-			SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);
-}
-
-#endif
-
-
-
-/*
- * Common ALSA controls routines
- */
-
-int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-
-	return 0;
-}
-
-int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
-	uinfo->count = 1;
-
-	return 0;
-}
-
-
-int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
-			IEC958_AES0_NONAUDIO |
-			IEC958_AES0_CON_NOT_COPYRIGHT |
-			IEC958_AES0_CON_EMPHASIS |
-			IEC958_AES0_CON_MODE;
-	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |
-			IEC958_AES1_CON_ORIGINAL;
-	ucontrol->value.iec958.status[2] = IEC958_AES2_CON_SOURCE |
-			IEC958_AES2_CON_CHANNEL;
-	ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS |
-			IEC958_AES3_CON_CLOCK;
-	ucontrol->value.iec958.status[4] = IEC958_AES4_CON_MAX_WORDLEN_24 |
-			IEC958_AES4_CON_WORDLEN;
-
-	return 0;
-}
-
-int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
-			IEC958_AES0_NONAUDIO |
-			IEC958_AES0_PRO_EMPHASIS |
-			IEC958_AES0_PRO_FREQ_UNLOCKED |
-			IEC958_AES0_PRO_FS;
-	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
-			IEC958_AES1_PRO_USERBITS;
-	ucontrol->value.iec958.status[2] = IEC958_AES2_PRO_SBITS |
-			IEC958_AES2_PRO_WORDLEN;
-
-	return 0;
-}
-
-int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
-		const struct snd_aes_iec958 *b)
-{
-	int result;
-
-	snd_assert(a != NULL, return -EINVAL);
-	snd_assert(b != NULL, return -EINVAL);
-
-	result = memcmp(a->status, b->status, sizeof(a->status));
-	if (result == 0)
-		result = memcmp(a->subcode, b->subcode, sizeof(a->subcode));
-	if (result == 0)
-		result = memcmp(a->dig_subframe, b->dig_subframe,
-				sizeof(a->dig_subframe));
-
-	return result;
-}
-
-
-/*
- * Debug features
- */
-
-/* Memory dump function */
-
-void snd_stm_hex_dump(void *data, int size)
-{
-	unsigned char *buffer = data;
-	char line[57];
-	int i;
-
-	for (i = 0; i < size; i++) {
-		if (i % 16 == 0)
-			sprintf(line, "%p", data + i);
-		sprintf(line + 8 + ((i % 16) * 3), " %02x", *buffer++);
-		if (i % 16 == 15 || i == size - 1)
-			printk(KERN_DEBUG "%s\n", line);
-	}
-}
-
-/* IEC958 structure dump */
-void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc)
-{
-	int i;
-	char line[54];
-	const unsigned char *data;
-
-	printk(KERN_DEBUG "                        "
-			"0  1  2  3  4  5  6  7  8  9\n");
-	data = vuc->status;
-	for (i = 0; i < 24; i++) {
-		if (i % 10 == 0)
-			sprintf(line, "%p status    %02d:",
-					(unsigned char *)vuc + i, i);
-		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
-		if (i % 10 == 9 || i == 23)
-			printk(KERN_DEBUG "%s\n", line);
-	}
-
-	data = vuc->subcode;
-	for (i = 0; i < 147; i++) {
-		if (i % 10 == 0)
-			sprintf(line, "%p subcode  %03d:",
-					(unsigned char *)vuc +
-					offsetof(struct snd_aes_iec958,
-					dig_subframe) + i, i);
-		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
-		if (i % 10 == 9 || i == 146)
-			printk(KERN_DEBUG "%s\n", line);
-	}
-
-	printk(KERN_DEBUG "%p dig_subframe: %02x %02x %02x %02x\n",
-			(unsigned char *)vuc +
-			offsetof(struct snd_aes_iec958, dig_subframe),
-			vuc->dig_subframe[0], vuc->dig_subframe[1],
-			vuc->dig_subframe[2], vuc->dig_subframe[3]);
-}
diff --git a/sound/soc/stm/common.h b/sound/soc/stm/common.h
deleted file mode 100644
index 71dba20..0000000
--- a/sound/soc/stm/common.h
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- * STMicroelectronics' System-on-Chips audio subsystem commons
- */
-
-#ifndef __SOUND_STM_COMMON_H
-#define __SOUND_STM_COMMON_H
-
-#include <linux/interrupt.h>
-#include <linux/mm.h>
-#include <linux/platform_device.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/stm-dma.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/info.h>
-#include <sound/control.h>
-#include <sound/stm.h>
-
-
-
-/*
- * Audio frequency synthesizer description (platform data)
- */
-
-struct snd_stm_fsynth_info {
-	const char *card_id;
-
-	int channels_from, channels_to;
-};
-
-int snd_stm_fsynth_set_frequency(struct device *device, int channel,
-		int frequency);
-
-int snd_stm_fsynth_add_adjustement_ctl(struct device *device, int channel,
-		struct snd_card *card, int card_device);
-
-
-
-/*
- * Converters (DAC, ADC, I2S-SPDIF etc.) control interface
- */
-
-struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source);
-int snd_stm_conv_add_route_ctl(struct device *source,
-		struct snd_card *card, int card_device);
-
-unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv);
-int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv);
-
-int snd_stm_conv_enable(struct snd_stm_conv *conv);
-int snd_stm_conv_disable(struct snd_stm_conv *conv);
-int snd_stm_conv_mute(struct snd_stm_conv *conv);
-int snd_stm_conv_unmute(struct snd_stm_conv *conv);
-
-
-
-/*
- * Internal audio DAC description (platform data)
- */
-
-struct snd_stm_conv_internal_dac_info {
-	const char *name;
-
-	const char *card_id;
-	int card_device;
-
-	const char *source_bus_id;
-};
-
-
-/*
- * I2S to SPDIF converter description (platform data)
- */
-
-struct snd_stm_conv_i2s_spdif_info {
-	const char *name;
-
-	const char *card_id;
-	int card_device;
-
-	const char *source_bus_id;
-
-	int full_channel_status;
-};
-
-
-
-/*
- * PCM Player description (platform data)
- */
-
-struct snd_stm_pcm_player_info {
-	const char *name;
-
-	const char *card_id;
-	int card_device;
-
-	const char *fsynth_bus_id;
-	int fsynth_output;
-
-	unsigned int channels_num;
-	unsigned int *channels;
-
-	unsigned char fdma_initiator;
-	unsigned int fdma_request_line;
-	int fdma_max_transfer_size;
-
-	int invert_sclk_edge_falling;
-};
-
-
-
-/*
- * PCM Reader description (platform data)
- */
-
-struct snd_stm_pcm_reader_info {
-	const char *name;
-
-	const char *card_id;
-	int card_device;
-
-	int channels_num;
-	int *channels;
-
-	unsigned char fdma_initiator;
-	unsigned int fdma_request_line;
-	int fdma_max_transfer_size;
-};
-
-
-
-/*
- * SPDIF Player description (platform data)
- */
-
-struct snd_stm_spdif_player_info {
-	const char *name;
-
-	const char *card_id;
-	int card_device;
-
-	const char *fsynth_bus_id;
-	int fsynth_output;
-
-	unsigned char fdma_initiator;
-	unsigned int fdma_request_line;
-	int fdma_max_transfer_size;
-};
-
-
-
-/*
- * Buffer memory mapping operation
- */
-
-int snd_stm_mmap(struct snd_pcm_substream *substream,
-		struct vm_area_struct *area);
-
-
-
-/*
- * Common ALSA controls routines
- */
-
-int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo);
-
-int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo);
-
-int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol);
-
-int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol);
-
-int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
-		const struct snd_aes_iec958 *b);
-
-
-
-/*
- * Common ALSA parameters constraints
- */
-
-int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
-		unsigned int max_transfer_bytes);
-int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
-		unsigned int max_transfer_bytes);
-
-
-
-/*
- * Device management
- */
-
-/* Add/remove a list of platform devices */
-int __init snd_stm_add_plaform_devices(struct platform_device **devices,
-		int cnt);
-void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
-		int cnt);
-
-/* Leave bus NULL to use default (platform) bus */
-struct device *snd_stm_find_device(struct bus_type *bus,
-		const char *bus_id);
-
-
-
-/*
- * Components management
- */
-
-/* Card description */
-
-struct snd_stm_card {
-	int index;              /* card number */
-	const char *id;         /* unique, 15 chars max (plus '\0' as 16th) */
-	const char *short_name; /* 31 chars max (plus '\0' as 32nd) */
-	const char *long_name;  /* 79 chars max (plus '\0' as 80th) */
-};
-
-/* Card list initialization/cleanup */
-
-int __init snd_stm_cards_init(const char *device, struct snd_stm_card *cards,
-		int num_cards);
-int __init snd_stm_cards_register(void);
-void snd_stm_cards_free(void);
-
-/* Card list access */
-
-struct snd_card __init *snd_stm_cards_get(const char *id);
-struct snd_card __init *snd_stm_cards_default(void);
-
-
-
-/*
- * ALSA procfs additional entries
- */
-
-int __init snd_stm_info_init(void);
-void snd_stm_info_cleanup(void);
-
-int snd_stm_info_register(struct snd_info_entry **entry,
-		const char *name,
-		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
-		void *private_data);
-void snd_stm_info_unregister(struct snd_info_entry *entry);
-
-
-
-/*
- * Resources management
- */
-
-int __init snd_stm_memory_request(struct platform_device *pdev,
-		struct resource **mem_region, void **base_address);
-void snd_stm_memory_release(struct resource *mem_region,
-		void *base_address);
-
-int __init snd_stm_irq_request(struct platform_device *pdev,
-		unsigned int *irq, irq_handler_t handler, void *dev_id);
-#define snd_stm_irq_release(irq, dev_id) free_irq(irq, dev_id)
-
-int __init snd_stm_fdma_request(struct platform_device *pdev,
-		unsigned int *channel);
-#define snd_stm_fdma_release(channel) free_dma(channel)
-
-
-
-/*
- * Drivers initialization/cleanup
- */
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-int __init snd_stm_stx710x_init(void);
-void __exit snd_stm_stx710x_cleanup(void);
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-int __init snd_stm_stx7111_init(void);
-void __exit snd_stm_stx7111_cleanup(void);
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-int __init snd_stm_stx7200_init(void);
-void __exit snd_stm_stx7200_cleanup(void);
-#endif
-
-int __init snd_stm_audio_outputs_init(void);
-void snd_stm_audio_outputs_cleanup(void);
-
-int __init snd_stm_fsynth_init(void);
-void snd_stm_fsynth_cleanup(void);
-
-int __init snd_stm_conv_init(void);
-void snd_stm_conv_cleanup(void);
-
-int __init snd_stm_conv_dummy_init(void);
-void snd_stm_conv_dummy_cleanup(void);
-
-int __init snd_stm_conv_internal_dac_init(void);
-void snd_stm_conv_internal_dac_cleanup(void);
-
-int __init snd_stm_conv_i2s_spdif_init(void);
-void snd_stm_conv_i2s_spdif_cleanup(void);
-
-int __init snd_stm_pcm_player_init(void);
-void snd_stm_pcm_player_cleanup(void);
-
-int __init snd_stm_pcm_reader_init(void);
-void snd_stm_pcm_reader_cleanup(void);
-
-int __init snd_stm_spdif_player_init(void);
-void snd_stm_spdif_player_cleanup(void);
-
-int __init snd_stm_synchro_init(void);
-void snd_stm_synchro_cleanup(void);
-
-
-
-/*
- * Debug features
- */
-
-/* Data dump functions */
-
-void snd_stm_hex_dump(void *data, int size);
-void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc);
-
-
-
-/* Trace debug messages
- * - even more debugs than with CONFIG_SND_DEBUG ;-)
- * - enables snd_printd when CONFIG_SND_DEBUG is not defined :-)
- * - define TRACE _before_ including common.h to enable in selected
- *   submodule; alternatively you can change following "#ifdef TRACE"
- *   to "#if 1" to force verbose output in all STM submodules. */
-
-#ifdef TRACE
-
-#	ifndef CONFIG_SND_DEBUG
-#		undef snd_printd
-#		define snd_printd(format, args...) \
-				snd_printk(KERN_INFO format, ## args)
-#	endif
-
-#	define snd_stm_printt(format, args...) \
-			snd_printd(format, ## args)
-
-#else
-
-#	define snd_stm_printt(...)
-
-#endif
-
-/* Error debug messages */
-
-#define snd_stm_printe(format, args...) \
-		snd_printk(KERN_ERR format, ## args)
-
-/* Magic value checking in device structures
- * - define MAGIC as a unique value _before_ including
- *   common.h to enable in selected submodule; alternatively you can
- *   change following "#ifdef MAGIC" to "#if 1" to force magic
- *   checking in all STM submodules. */
-
-#ifdef MAGIC
-
-	enum snd_stm_magic {
-		snd_stm_magic_good = 0x600da15a + MAGIC,
-		snd_stm_magic_bad  = 0xbaada15a + MAGIC
-	};
-
-#	define snd_stm_magic_field \
-			enum snd_stm_magic __magic
-#	define snd_stm_magic_set(object) \
-			(object)->__magic = snd_stm_magic_good
-#	define snd_stm_magic_clear(object) \
-			(object)->__magic = snd_stm_magic_bad
-#	define snd_stm_magic_assert(object, args...) \
-			snd_assert((object)->__magic == snd_stm_magic_good, \
-					## args)
-
-#else
-
-#	define snd_stm_magic_field
-#	define snd_stm_magic_set(object)
-#	define snd_stm_magic_clear(object)
-#	define snd_stm_magic_assert(object, args...)
-
-#endif
-
-
-
-#endif
diff --git a/sound/soc/stm/conv.c b/sound/soc/stm/conv.c
deleted file mode 100644
index 2ef0ba8..0000000
--- a/sound/soc/stm/conv.c
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' generic converters infrastructure
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/list.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 2 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Converters infrastructure interface implementation
- */
-
-#define CONVS_MAX 5 /* TODO: dynamic structure (really necessary???) */
-
-struct snd_stm_conv_links_list {
-	struct list_head list;
-
-	struct device *device;
-
-	int convs_num;
-	struct snd_stm_conv *convs[CONVS_MAX];
-
-	int conv_attached;
-
-	snd_stm_magic_field;
-};
-
-LIST_HEAD(snd_stm_conv_links); /* "Device->Converter" links list */
-DEFINE_SPINLOCK(snd_stm_conv_links_lock); /* Synchronises the links list */
-
-static inline struct snd_stm_conv_links_list *snd_stm_conv_find_link(
-		struct device *source) {
-	struct snd_stm_conv_links_list *entry;
-
-	list_for_each_entry(entry, &snd_stm_conv_links, list)
-		if (source == entry->device)
-			return entry;
-
-	return NULL;
-}
-
-int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source)
-{
-	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
-
-	snd_stm_printt("snd_stm_conv_attach(conv=%p, source=%p)\n",
-			conv, source);
-
-	/* Not synchronised intentionally (doesn't have to be...) */
-
-	if (link) { /* Known device */
-		snd_stm_magic_assert(link, return -EINVAL);
-		snd_assert(link->convs_num < CONVS_MAX,
-				return -ENOMEM);
-		link->convs[link->convs_num++] = conv;
-	} else { /* New device */
-		link = kzalloc(sizeof(*link), GFP_KERNEL);
-		if (link == NULL)
-			return -ENOMEM;
-		snd_stm_magic_set(link);
-
-		link->device = source;
-		link->convs_num = 1;
-		link->convs[0] = conv;
-
-		list_add_tail(&link->list, &snd_stm_conv_links);
-	}
-
-	return 0;
-}
-
-struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source)
-{
-	struct snd_stm_conv_links_list *link;
-	struct snd_stm_conv *conv = NULL;
-
-	snd_stm_printt("snd_stm_conv_attach(source=%p)\n", source);
-
-	spin_lock(&snd_stm_conv_links_lock);
-
-	link = snd_stm_conv_find_link(source);
-	conv = link ? link->convs[link->conv_attached] : NULL;
-
-	spin_unlock(&snd_stm_conv_links_lock);
-
-	return conv;
-}
-
-static int snd_stm_conv_route_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo)
-{
-	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
-	struct snd_stm_conv *conv;
-
-	snd_stm_magic_assert(link, return -EINVAL);
-
-	/* Not synchronised intentionally (doesn't have to be...) */
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = link->convs_num;
-
-	if (uinfo->value.enumerated.item >= link->convs_num)
-		uinfo->value.enumerated.item = link->convs_num - 1;
-
-	conv = link->convs[uinfo->value.enumerated.item];
-	snprintf(uinfo->value.enumerated.name, 64, "%s", conv->name);
-
-	return 0;
-}
-
-static int snd_stm_conv_route_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_conv_route_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_stm_magic_assert(link, return -EINVAL);
-
-	spin_lock(&snd_stm_conv_links_lock);
-
-	ucontrol->value.enumerated.item[0] = link->conv_attached;
-
-	spin_unlock(&snd_stm_conv_links_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_route_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	int changed;
-	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_conv_route_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_stm_magic_assert(link, return -EINVAL);
-
-	spin_lock(&snd_stm_conv_links_lock);
-
-	changed = (ucontrol->value.enumerated.item[0] != link->conv_attached);
-	link->conv_attached = ucontrol->value.enumerated.item[0];
-
-	spin_unlock(&snd_stm_conv_links_lock);
-
-	return changed;
-}
-
-static struct snd_kcontrol_new snd_stm_conv_route_ctl = {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	.name = "PCM Playback Route",
-	.info = snd_stm_conv_route_info,
-	.get = snd_stm_conv_route_get,
-	.put = snd_stm_conv_route_put,
-};
-
-int snd_stm_conv_add_route_ctl(struct device *source,
-		struct snd_card *card, int card_device)
-{
-	int result = 0;
-	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
-
-	snd_stm_printt("snd_stm_conv_add_route_ctl(source=%p, card=%p, "
-			"cards_device=%d)\n", source, card, card_device);
-
-	/* Not synchronised intentionally (doesn't have to be...) */
-
-	if (link != NULL) {
-		snd_stm_magic_assert(link, return -EINVAL);
-
-		if (link->convs_num > 1) {
-			snd_stm_conv_route_ctl.device = card_device;
-			result = snd_ctl_add(card,
-					snd_ctl_new1(&snd_stm_conv_route_ctl,
-					link));
-
-			/* TODO: index per card */
-			snd_stm_conv_route_ctl.index++;
-		}
-	} else {
-		snd_stm_printt("Source device '%s' not found...\n",
-				source->bus_id);
-	}
-
-	return result;
-}
-
-
-
-/*
- * Converter control interface implementation
- */
-
-unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv)
-{
-	snd_stm_printt("snd_stm_conv_get_format(conv=%p)\n", conv);
-
-	snd_assert(conv->get_format != NULL, return -EINVAL);
-
-	return conv->get_format(conv);
-}
-
-int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv)
-{
-	snd_stm_printt("snd_stm_conv_get_oversampling(conv=%p)\n", conv);
-
-	snd_assert(conv->get_oversampling != NULL, return -EINVAL);
-
-	return conv->get_oversampling(conv);
-}
-
-int snd_stm_conv_enable(struct snd_stm_conv *conv)
-{
-	int result = 0;
-
-	snd_stm_printt("snd_stm_conv_enable(conv=%p)\n", conv);
-
-	snd_assert(conv->enable != NULL, return -EINVAL);
-
-	if (conv->master)
-		result = snd_stm_conv_enable(conv->master);
-
-	return result ? result : conv->enable(conv);
-}
-
-int snd_stm_conv_disable(struct snd_stm_conv *conv)
-{
-	int result = 0;
-
-	snd_stm_printt("snd_stm_conv_disable(conv=%p)\n", conv);
-
-	snd_assert(conv->disable != NULL, return -EINVAL);
-
-	if (conv->master)
-		result = snd_stm_conv_disable(conv->master);
-
-	return result ? result : conv->disable(conv);
-}
-
-int snd_stm_conv_mute(struct snd_stm_conv *conv)
-{
-	snd_stm_printt("snd_stm_conv_mute(conv=%p)\n", conv);
-
-	snd_assert(conv->mute != NULL, return -EINVAL);
-
-	return conv->mute(conv);
-}
-
-int snd_stm_conv_unmute(struct snd_stm_conv *conv)
-{
-	snd_stm_printt("snd_stm_conv_unmute(conv=%p)\n", conv);
-
-	snd_assert(conv->unmute != NULL, return -EINVAL);
-
-	return conv->unmute(conv);
-}
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_conv_init(void)
-{
-	return 0;
-}
-
-void snd_stm_conv_cleanup(void)
-{
-	struct snd_stm_conv_links_list *entry, *next;
-
-	list_for_each_entry_safe(entry, next, &snd_stm_conv_links, list) {
-		snd_stm_magic_clear(entry);
-		list_del(&entry->list);
-		kfree(entry);
-	};
-}
diff --git a/sound/soc/stm/conv_dummy.c b/sound/soc/stm/conv_dummy.c
deleted file mode 100644
index 0773e51..0000000
--- a/sound/soc/stm/conv_dummy.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' internal audio DAC driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <sound/stm.h>
-
-#include "common.h"
-
-
-
-/*
- * Converter interface implementation
- */
-
-static unsigned int snd_stm_conv_dummy_get_format(struct snd_stm_conv
-		*conv)
-{
-	return (SND_STM_FORMAT__RIGHT_JUSTIFIED |
-			SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS);
-}
-
-static int snd_stm_conv_dummy_get_oversampling(struct snd_stm_conv *conv)
-{
-	return 64;
-}
-
-static int snd_stm_conv_dummy_enable(struct snd_stm_conv *conv)
-{
-	snd_printk("Waking up dummy DAC '%s'.\n", conv->name);
-
-	return 0;
-}
-
-static int snd_stm_conv_dummy_disable(struct snd_stm_conv *conv)
-{
-	snd_printk("Setting dummy DAC '%s' into reset mode.\n", conv->name);
-
-	return 0;
-}
-
-static int snd_stm_conv_dummy_mute(struct snd_stm_conv *conv)
-{
-	snd_printk("Muting dummy DAC '%s'.\n", conv->name);
-
-	return 0;
-}
-
-static int snd_stm_conv_dummy_unmute(struct snd_stm_conv *conv)
-{
-	snd_printk("Unmuting dummy DAC '%s'.\n", conv->name);
-
-	return 0;
-}
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_conv_dummy_probe(struct platform_device *pdev)
-{
-	int result;
-	struct snd_stm_conv *conv;
-	const char *source_bus_id = pdev->dev.platform_data;
-	struct device *player_device;
-	static int index;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	conv = kzalloc(sizeof(*conv) + 25, GFP_KERNEL);
-	if (!conv) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		return -ENOMEM;
-	}
-
-	conv->name = (char *)conv + sizeof(*conv);
-	sprintf((char *)conv->name, "Dummy converter %x", index++);
-
-	conv->get_format =
-		snd_stm_conv_dummy_get_format;
-	conv->get_oversampling =
-		snd_stm_conv_dummy_get_oversampling;
-	conv->enable = snd_stm_conv_dummy_enable;
-	conv->disable = snd_stm_conv_dummy_disable;
-	conv->mute = snd_stm_conv_dummy_mute;
-	conv->unmute = snd_stm_conv_dummy_unmute;
-
-	snd_printd("This dummy DAC is attached to PCM player '%s'.\n",
-			source_bus_id);
-	player_device = snd_stm_find_device(NULL, source_bus_id);
-	snd_assert(player_device != NULL, return -EINVAL);
-	result = snd_stm_conv_attach(conv, player_device);
-	if (result < 0) {
-		snd_stm_printe("Can't attach to PCM player!\n");
-		return -EINVAL;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, conv);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return 0;
-}
-
-static int snd_stm_conv_dummy_remove(struct platform_device *pdev)
-{
-	kfree(platform_get_drvdata(pdev));
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_conv_dummy_driver = {
-	.driver = {
-		.name = "conv_dummy",
-	},
-	.probe = snd_stm_conv_dummy_probe,
-	.remove = snd_stm_conv_dummy_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_conv_dummy_init(void)
-{
-	return platform_driver_register(&snd_stm_conv_dummy_driver);
-}
-
-void snd_stm_conv_dummy_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_conv_dummy_driver);
-}
diff --git a/sound/soc/stm/conv_i2s-spdif.c b/sound/soc/stm/conv_i2s-spdif.c
deleted file mode 100644
index 98cc071..0000000
--- a/sound/soc/stm/conv_i2s-spdif.c
+++ /dev/null
@@ -1,749 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/info.h>
-#include <sound/stm.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 3 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Hardware-related definitions
- */
-
-#define DEFAULT_OVERSAMPLING 128
-
-
-
-/*
- * Converter instance structure
- */
-
-struct snd_stm_conv_i2s_spdif {
-	/* Generic converter interface */
-	struct snd_stm_conv conv;
-
-	/* System informations */
-	struct snd_stm_conv_i2s_spdif_info *info;
-	struct device *device;
-
-	/* Resources */
-	struct resource *mem_region;
-	void *base;
-
-	/* Default configuration */
-	struct snd_aes_iec958 iec958_default;
-	spinlock_t iec958_default_lock; /* Protects iec958_default */
-
-	/* Runtime data */
-	int enabled;
-	struct snd_stm_conv *attached_conv;
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Internal routines
- */
-
-/* Such a empty (zeroed) structure is pretty useful later... ;-) */
-static struct snd_aes_iec958 snd_stm_conv_i2s_spdif_iec958_zeroed;
-
-
-
-#define CHA_STA_TRIES 50000
-
-static int snd_stm_conv_i2s_spdif_iec958_set(struct snd_stm_conv_i2s_spdif
-		*conv_i2s_spdif, struct snd_aes_iec958 *iec958)
-{
-	int i, j, ok;
-	unsigned long status[6];
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif=%p, "
-			"iec958=%p)\n", conv_i2s_spdif, iec958);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-
-	/* I2S to SPDIF converter should be used only for playing
-	 * PCM (non compressed) data, so validity bit should be always
-	 * zero... (it means "valid linear PCM data") */
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_VAL, VALIDITY_BITS, 0);
-
-	/* Well... User data bit... Frankly speaking there is no way
-	 * of correctly setting them with a mechanism provided by
-	 * converter hardware, so it is better not to do this at all... */
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_DATA,
-			USER_DATA_BITS, 0);
-	snd_assert(memcmp(snd_stm_conv_i2s_spdif_iec958_zeroed.subcode,
-			iec958->subcode, sizeof(iec958->subcode)) == 0);
-
-	if (conv_i2s_spdif->info->full_channel_status == 0) {
-		/* Converter hardware by default puts every single bit of
-		 * status to separate SPDIF subframe (instead of putting
-		 * the same bit to both left and right subframes).
-		 * So we have to prepare a "duplicated" version of
-		 * status bits... Note that in such way status will be
-		 * transmitted twice in every block! This is definitely
-		 * out of spec, but fortunately most of receivers pay
-		 * attention only to first 36 bits... */
-
-		for (i = 0; i < 6; i++) {
-			unsigned long word = 0;
-
-			for (j = 1; j >= 0; j--) {
-				unsigned char byte = iec958->status[i * 2 + j];
-				int k;
-
-				for (k = 0; k < 8; k++) {
-					word |= ((byte & 0x80) != 0);
-					if (!(j == 0 && k == 7)) {
-						word <<= 2;
-						byte <<= 1;
-					}
-				}
-			}
-
-			status[i] = word | (word << 1);
-		}
-	} else {
-		/* Fortunately in some hardware there is a "sane" mode
-		 * of channel status registers operation... :-) */
-
-		for (i = 0; i < 6; i++)
-			status[i] = iec958->status[i * 4] |
-					iec958->status[i * 4 + 1] << 8 |
-					iec958->status[i * 4 + 2] << 16 |
-					iec958->status[i * 4 + 3] << 24;
-	}
-
-	/* Set converter's channel status registers - they are realised
-	 * in such a ridiculous way that write to them is enabled only
-	 * in (about) 300us time window after CHL_STS_BUFF_EMPTY bit
-	 * is asserted... And this happens once every 2ms (only when
-	 * converter is enabled and gets data...) */
-
-	ok = 0;
-	for (i = 0; i < CHA_STA_TRIES; i++) {
-		if (REGFIELD_PEEK(conv_i2s_spdif->base,
-				AUD_SPDIFPC_STA, CHL_STS_BUFF_EMPTY)) {
-			for (j = 0; j < 6; j++)
-				REGISTER_POKE_N(conv_i2s_spdif->base,
-						AUD_SPDIFPC_CHA_STA,
-						j, status[j]);
-			ok = 1;
-			for (j = 0; j < 6; j++)
-				if (REGISTER_PEEK_N(conv_i2s_spdif->base,
-						AUD_SPDIFPC_CHA_STA,
-						j) != status[j]) {
-					ok = 0;
-					break;
-				}
-			if (ok)
-				break;
-		}
-	}
-	if (!ok) {
-		snd_stm_printe("WARNING! Failed to set channel status registers"
-				" for converter %s! (tried %d times)\n",
-				conv_i2s_spdif->device->bus_id, i);
-		return -EINVAL;
-	}
-
-	snd_stm_printt("Channel status registers set successfully "
-			"in %i tries.", i);
-
-	/* Set SPDIF player's VUC registers (these are used only
-	 * for mute data formatting, and it should never happen ;-) */
-
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			VAL_LEFT, 0);
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			VAL_RIGHT, 0);
-
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			DATA_LEFT, 0);
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			DATA_RIGHT, 0);
-
-	/* And this time the problem is that SPDIF player lets
-	 * to set only first 36 bits of channel status bits...
-	 * Hopefully no one needs more ever ;-) And well - at least
-	 * it puts channel status bits to both subframes :-) */
-	status[0] = iec958->status[0] | iec958->status[1] << 8 |
-		iec958->status[2] << 16 | iec958->status[3] << 24;
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CL1,
-			CHANNEL_STATUS, status[0]);
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			CH_STA_LEFT, iec958->status[4] & 0xf);
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CR1,
-			CH_STA, status[0]);
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
-			CH_STA_RIGHT, iec958->status[4] & 0xf);
-
-	return 0;
-}
-
-
-
-
-/*
- * Converter interface implementation
- */
-
-static unsigned int snd_stm_conv_i2s_spdif_get_format(struct snd_stm_conv
-		*conv)
-{
-	snd_stm_printt("snd_stm_conv_i2s_spdif_get_format(conv=%p)\n", conv);
-
-	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS);
-}
-
-static int snd_stm_conv_i2s_spdif_get_oversampling(struct snd_stm_conv *conv)
-{
-	int oversampling = 0;
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
-			struct snd_stm_conv_i2s_spdif, conv);
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_get_oversampling(conv=%p)\n",
-			conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-
-	if (conv_i2s_spdif->attached_conv)
-		oversampling = snd_stm_conv_get_oversampling(
-				conv_i2s_spdif->attached_conv);
-
-	if (oversampling == 0)
-		oversampling = DEFAULT_OVERSAMPLING;
-
-	return oversampling;
-}
-
-static int snd_stm_conv_i2s_spdif_enable(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
-			struct snd_stm_conv_i2s_spdif, conv);
-	int oversampling;
-	struct snd_aes_iec958 iec958;
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_enable(conv=%p)\n", conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
-
-	snd_stm_printt("Enabling I2S to SPDIF converter '%s'.\n",
-			conv_i2s_spdif->device->bus_id);
-
-	conv_i2s_spdif->attached_conv =
-			snd_stm_conv_get_attached(conv_i2s_spdif->device);
-	if (conv_i2s_spdif->attached_conv) {
-		int result = snd_stm_conv_enable(conv_i2s_spdif->attached_conv);
-		if (result != 0) {
-			snd_stm_printe("Can't enable attached converter!\n");
-			return result;
-		}
-	}
-
-	oversampling = snd_stm_conv_i2s_spdif_get_oversampling(conv);
-	snd_assert(oversampling > 0, return -EINVAL);
-	snd_assert((oversampling % 128) == 0, return -EINVAL);
-
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, ENABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RUNNING) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, ENABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, AUDIO_WORD_SIZE,
-					24_BITS) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, ENABLED));
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
-			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, PCM) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, ROUNDING,
-					NO_ROUNDING));
-	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL, DIVIDER,
-			oversampling / 128);
-
-	/* Full channel status processing - an undocumented feature that
-	 * exists in some hardware... Normally channel status registers
-	 * provides bits for each subframe, so only for 96 frames (a half
-	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
-	 * enables a mode in which channel status bits in L/R subframes
-	 * are identical, and whole block is served... */
-	if (conv_i2s_spdif->info->full_channel_status)
-		REGFIELD_SET(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
-				CHA_STA_BITS, FRAME);
-
-	spin_lock(&conv_i2s_spdif->iec958_default_lock);
-	iec958 = conv_i2s_spdif->iec958_default;
-	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
-	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif, &iec958) != 0)
-		snd_stm_printe("WARNING! Can't set channel status "
-				"registers!\n");
-
-	conv_i2s_spdif->enabled = 1;
-
-	return 0;
-}
-
-static int snd_stm_conv_i2s_spdif_disable(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
-			struct snd_stm_conv_i2s_spdif, conv);
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_disable(conv=%p)\n", conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
-
-	snd_stm_printt("Disabling I2S to SPDIF converter '%s'\n",
-			conv_i2s_spdif->device->bus_id);
-
-	if (conv_i2s_spdif->attached_conv) {
-		int result = snd_stm_conv_disable(
-				conv_i2s_spdif->attached_conv);
-
-		if (result != 0) {
-			snd_stm_printe("Can't disable attached converter!\n");
-			return result;
-		}
-	}
-
-	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif,
-			&snd_stm_conv_i2s_spdif_iec958_zeroed) != 0)
-		snd_stm_printe("WARNING! Failed to clear channel status "
-				"registers!\n");
-
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
-			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
-
-	conv_i2s_spdif->enabled = 0;
-
-	return 0;
-}
-
-static int snd_stm_conv_i2s_spdif_mute(struct snd_stm_conv *conv)
-{
-	int result = 0;
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
-			struct snd_stm_conv_i2s_spdif, conv);
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_mute(conv=%p)\n", conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
-
-	if (conv_i2s_spdif->attached_conv)
-		result = snd_stm_conv_mute(conv_i2s_spdif->attached_conv);
-
-	return result;
-}
-
-static int snd_stm_conv_i2s_spdif_unmute(struct snd_stm_conv *conv)
-{
-	int result = 0;
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
-			struct snd_stm_conv_i2s_spdif, conv);
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_unmute(conv=%p)\n", conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
-
-	if (conv_i2s_spdif->attached_conv)
-		result = snd_stm_conv_unmute(conv_i2s_spdif->attached_conv);
-
-	return result;
-}
-
-
-
-/*
- * ALSA controls
- */
-
-static int snd_stm_conv_i2s_spdif_ctl_default_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
-			snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_get("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-
-	spin_lock(&conv_i2s_spdif->iec958_default_lock);
-	ucontrol->value.iec958 = conv_i2s_spdif->iec958_default;
-	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_i2s_spdif_ctl_default_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
-			snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_put("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-
-	spin_lock(&conv_i2s_spdif->iec958_default_lock);
-	if (snd_stm_iec958_cmp(&conv_i2s_spdif->iec958_default,
-				&ucontrol->value.iec958) != 0) {
-		conv_i2s_spdif->iec958_default = ucontrol->value.iec958;
-		changed = 1;
-	}
-	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
-
-	return changed;
-}
-
-static struct snd_kcontrol_new __initdata snd_stm_conv_i2s_spdif_ctls[] = {
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
-		.info = snd_stm_ctl_iec958_info,
-		.get = snd_stm_conv_i2s_spdif_ctl_default_get,
-		.put = snd_stm_conv_i2s_spdif_ctl_default_put,
-	}, {
-		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
-		.info =	snd_stm_ctl_iec958_info,
-		.get = snd_stm_ctl_iec958_mask_get_con,
-	}, {
-		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
-		.info =	snd_stm_ctl_iec958_info,
-		.get = snd_stm_ctl_iec958_mask_get_pro,
-	},
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-#define DUMP_REGISTER(r) \
-		snd_iprintf(buffer, "AUD_SPDIFPC_%s (offset 0x%03x) =" \
-				" 0x%08x\n", __stringify(r), \
-				AUD_SPDIFPC_##r, \
-				REGISTER_PEEK(conv_i2s_spdif->base, \
-				AUD_SPDIFPC_##r))
-
-static void snd_stm_conv_i2s_spdif_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
-		entry->private_data;
-	int i;
-
-	snd_assert(conv_i2s_spdif, return);
-	snd_stm_magic_assert(conv_i2s_spdif, return);
-
-	DUMP_REGISTER(CFG);
-	DUMP_REGISTER(STA);
-	DUMP_REGISTER(IT_EN);
-	DUMP_REGISTER(ITS);
-	DUMP_REGISTER(IT_CLR);
-	DUMP_REGISTER(VAL);
-	DUMP_REGISTER(DATA);
-	for (i = 0; i <= 5; i++)
-		snd_iprintf(buffer, "AUD_SPDIFPC_CHA_STA%d_CHANNEL_STATUS_BITS"
-				" (offset 0x%03x) = 0x%08x\n",
-				i, AUD_SPDIFPC_CHA_STA(i),
-				REGISTER_PEEK_N(conv_i2s_spdif->base,
-				AUD_SPDIFPC_CHA_STA, i));
-	DUMP_REGISTER(CTRL);
-	DUMP_REGISTER(SPDIFSTA);
-	DUMP_REGISTER(PAUSE);
-	DUMP_REGISTER(DATA_BURST);
-	DUMP_REGISTER(PA_PB);
-	DUMP_REGISTER(PC_PD);
-	DUMP_REGISTER(CL1);
-	DUMP_REGISTER(CR1);
-	DUMP_REGISTER(SUV);
-}
-
-static int snd_stm_conv_i2s_spdif_register(struct snd_device *snd_device)
-{
-	int result;
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
-
-	/* Initialize converter's input & SPDIF player as disabled */
-
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
-			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&conv_i2s_spdif->proc_entry,
-			conv_i2s_spdif->device->bus_id,
-			snd_stm_conv_i2s_spdif_dump_registers,
-			conv_i2s_spdif);
-
-	/* Create ALSA controls */
-
-	result = snd_stm_conv_add_route_ctl(conv_i2s_spdif->device,
-			snd_device->card, conv_i2s_spdif->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add converter route control!\n");
-		return result;
-	}
-
-	return 0;
-}
-
-static int snd_stm_conv_i2s_spdif_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(conv_i2s_spdif->proc_entry);
-
-	/* Power done mode, just to be sure :-) */
-
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
-			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
-	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
-			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_conv_i2s_spdif_snd_device_ops = {
-	.dev_register = snd_stm_conv_i2s_spdif_register,
-	.dev_disconnect = snd_stm_conv_i2s_spdif_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_conv_i2s_spdif_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_conv_i2s_spdif_info *conv_i2s_spdif_info =
-			pdev->dev.platform_data;
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif;
-	struct snd_card *card;
-	struct device *player_device;
-	int i;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	snd_assert(conv_i2s_spdif_info != NULL, return -EINVAL);
-
-	conv_i2s_spdif = kzalloc(sizeof(*conv_i2s_spdif), GFP_KERNEL);
-	if (!conv_i2s_spdif) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(conv_i2s_spdif);
-	conv_i2s_spdif->info = conv_i2s_spdif_info;
-	conv_i2s_spdif->device = &pdev->dev;
-	spin_lock_init(&conv_i2s_spdif->iec958_default_lock);
-
-	/* Converter interface initialization */
-
-	conv_i2s_spdif->conv.name = conv_i2s_spdif_info->name;
-	conv_i2s_spdif->conv.get_format = snd_stm_conv_i2s_spdif_get_format;
-	conv_i2s_spdif->conv.get_oversampling =
-			snd_stm_conv_i2s_spdif_get_oversampling;
-	conv_i2s_spdif->conv.enable = snd_stm_conv_i2s_spdif_enable;
-	conv_i2s_spdif->conv.disable = snd_stm_conv_i2s_spdif_disable;
-	conv_i2s_spdif->conv.mute = snd_stm_conv_i2s_spdif_mute;
-	conv_i2s_spdif->conv.unmute = snd_stm_conv_i2s_spdif_unmute;
-
-	/* Get resources */
-
-	result = snd_stm_memory_request(pdev, &conv_i2s_spdif->mem_region,
-			&conv_i2s_spdif->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	/* Get connections */
-
-	snd_assert(conv_i2s_spdif_info->card_id, return -EINVAL);
-	card = snd_stm_cards_get(conv_i2s_spdif_info->card_id);
-	snd_assert(card, return -EINVAL);
-	snd_printd("This I2S-SPDIF converter will be a member of a card "
-			"'%s'.\n", card->id);
-
-	snd_assert(conv_i2s_spdif_info->source_bus_id != NULL,
-			return -EINVAL);
-	snd_printd("This I2S-SPDIF converter is attached to PCM player '%s'.\n",
-			conv_i2s_spdif_info->source_bus_id);
-	player_device = snd_stm_find_device(NULL,
-			conv_i2s_spdif_info->source_bus_id);
-	snd_assert(player_device != NULL, return -EINVAL);
-	result = snd_stm_conv_attach(&conv_i2s_spdif->conv, player_device);
-	if (result < 0) {
-		snd_stm_printe("Can't attach to PCM player!\n");
-		goto error_attach;
-	}
-
-	/* Create ALSA lowlevel device*/
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_i2s_spdif,
-			&snd_stm_conv_i2s_spdif_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Create ALSA controls */
-
-	result = 0;
-	for (i = 0; i < ARRAY_SIZE(snd_stm_conv_i2s_spdif_ctls); i++) {
-		snd_stm_conv_i2s_spdif_ctls[i].device =
-				conv_i2s_spdif->info->card_device;
-		result |= snd_ctl_add(card,
-				snd_ctl_new1(&snd_stm_conv_i2s_spdif_ctls[i],
-				conv_i2s_spdif));
-		/* TODO: index per card */
-		snd_stm_conv_i2s_spdif_ctls[i].index++;
-	}
-	if (result < 0) {
-		snd_stm_printe("Failed to add all ALSA controls!\n");
-		goto error_controls;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, &conv_i2s_spdif->conv);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return result;
-
-error_controls:
-error_device:
-error_attach:
-	snd_stm_memory_release(conv_i2s_spdif->mem_region,
-			conv_i2s_spdif->base);
-error_memory_request:
-	snd_stm_magic_clear(conv_i2s_spdif);
-	kfree(conv_i2s_spdif);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_conv_i2s_spdif_remove(struct platform_device *pdev)
-{
-	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
-			container_of(platform_get_drvdata(pdev),
-			struct snd_stm_conv_i2s_spdif, conv);
-
-	snd_assert(conv_i2s_spdif, return -EINVAL);
-	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
-
-	snd_stm_memory_release(conv_i2s_spdif->mem_region,
-			conv_i2s_spdif->base);
-
-	snd_stm_magic_clear(conv_i2s_spdif);
-	kfree(conv_i2s_spdif);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_conv_i2s_spdif_driver = {
-	.driver = {
-		.name = "conv_i2s-spdif",
-	},
-	.probe = snd_stm_conv_i2s_spdif_probe,
-	.remove = snd_stm_conv_i2s_spdif_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_conv_i2s_spdif_init(void)
-{
-	return platform_driver_register(&snd_stm_conv_i2s_spdif_driver);
-}
-
-void snd_stm_conv_i2s_spdif_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_conv_i2s_spdif_driver);
-}
diff --git a/sound/soc/stm/conv_internal_dac.c b/sound/soc/stm/conv_internal_dac.c
deleted file mode 100644
index 42dad93..0000000
--- a/sound/soc/stm/conv_internal_dac.c
+++ /dev/null
@@ -1,509 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' internal audio DAC driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/info.h>
-#include <sound/stm.h>
-
-#undef TRACE   /* See common.h debug features */
-#define MAGIC 3 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Hardware-related definitions
- */
-
-#define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
-#define OVERSAMPLING 256
-
-
-
-/*
- * Internal DAC instance structure
- */
-
-struct snd_stm_conv_internal_dac {
-	/* Generic converter interface */
-	struct snd_stm_conv conv;
-
-	/* System informations */
-	const char *bus_id;
-
-	/* Resources */
-	struct resource *mem_region;
-	void *base;
-
-	/* Runtime data */
-	int enabled;
-	int muted_by_source;
-	int muted_by_user;
-	spinlock_t status_lock; /* Protects enabled & muted_by_* */
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Converter interface implementation
- */
-
-static unsigned int snd_stm_conv_internal_dac_get_format(struct snd_stm_conv
-		*conv)
-{
-	snd_stm_printt("snd_stm_conv_internal_dac_get_format(conv=%p)\n", conv);
-
-	return FORMAT;
-}
-
-static int snd_stm_conv_internal_dac_get_oversampling(struct snd_stm_conv *conv)
-{
-	snd_stm_printt("snd_stm_conv_internal_dac_get_oversampling(conv=%p)\n",
-			conv);
-
-	return OVERSAMPLING;
-}
-
-static int snd_stm_conv_internal_dac_enable(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
-			struct snd_stm_conv_internal_dac, conv);
-
-	snd_stm_printt("snd_stm_conv_internal_dac_enable(conv=%p)\n", conv);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
-
-	snd_stm_printt("Enabling DAC %s's digital part. (still muted)\n",
-			conv_internal_dac->bus_id);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NSB, NORMAL);
-	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, NORMAL);
-
-	conv_internal_dac->enabled = 1;
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_internal_dac_disable(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
-			struct snd_stm_conv_internal_dac, conv);
-
-	snd_stm_printt("snd_stm_conv_internal_dac_disable(conv=%p)\n", conv);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(conv_internal_dac->enabled, return -EINVAL);
-
-	snd_stm_printt("Disabling DAC %s's digital part.\n",
-			conv_internal_dac->bus_id);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, RESET);
-	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-			NSB, POWER_DOWN);
-
-	conv_internal_dac->enabled = 0;
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_internal_dac_mute(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
-			struct snd_stm_conv_internal_dac, conv);
-
-	snd_stm_printt("snd_stm_conv_internal_dac_mute(conv=%p)\n", conv);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(conv_internal_dac->enabled, return -EINVAL);
-
-	snd_stm_printt("Muting DAC %s.\n", conv_internal_dac->bus_id);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	conv_internal_dac->muted_by_source = 1;
-	if (!conv_internal_dac->muted_by_user)
-		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-				SOFTMUTE, MUTE);
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_internal_dac_unmute(struct snd_stm_conv *conv)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
-			struct snd_stm_conv_internal_dac, conv);
-
-	snd_stm_printt("snd_stm_conv_internal_dac_unmute(conv=%p)\n", conv);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(conv_internal_dac->enabled, return -EINVAL);
-
-	snd_stm_printt("Unmuting DAC %s.\n", conv_internal_dac->bus_id);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	conv_internal_dac->muted_by_source = 0;
-	if (!conv_internal_dac->muted_by_user)
-		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-				SOFTMUTE, NORMAL);
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return 0;
-}
-
-
-
-/*
- * ALSA controls
- */
-
-static int snd_stm_conv_internal_dac_ctl_mute_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-			snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_get(kcontrol=0x%p,"
-			" ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	ucontrol->value.integer.value[0] = !conv_internal_dac->muted_by_user;
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return 0;
-}
-
-static int snd_stm_conv_internal_dac_ctl_mute_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-			snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_put(kcontrol=0x%p,"
-			" ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-
-	spin_lock(&conv_internal_dac->status_lock);
-
-	if (ucontrol->value.integer.value[0] !=
-			!conv_internal_dac->muted_by_user) {
-		changed = 1;
-
-		conv_internal_dac->muted_by_user =
-				!ucontrol->value.integer.value[0];
-
-		if (conv_internal_dac->enabled &&
-				conv_internal_dac->muted_by_user &&
-				!conv_internal_dac->muted_by_source)
-			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-					SOFTMUTE, MUTE);
-		else if (conv_internal_dac->enabled &&
-				!conv_internal_dac->muted_by_user &&
-				!conv_internal_dac->muted_by_source)
-			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-					SOFTMUTE, NORMAL);
-	}
-
-	spin_unlock(&conv_internal_dac->status_lock);
-
-	return changed;
-}
-
-static struct snd_kcontrol_new __initdata snd_stm_conv_dac_internal_ctl_mute = {
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "Master Playback Switch",
-	.info = snd_stm_ctl_boolean_info,
-	.get = snd_stm_conv_internal_dac_ctl_mute_get,
-	.put = snd_stm_conv_internal_dac_ctl_mute_put,
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-static void snd_stm_conv_internal_dac_dump_registers(
-		struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-		entry->private_data;
-
-	snd_assert(conv_internal_dac, return);
-	snd_stm_magic_assert(conv_internal_dac, return);
-
-	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
-			REGISTER_PEEK(conv_internal_dac->base,
-			AUDCFG_ADAC_CTRL));
-}
-
-static int snd_stm_conv_internal_dac_register(struct snd_device *snd_device)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-			snd_device->device_data;
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
-
-	/* Initialize DAC with digital part down, analog up and muted */
-
-	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, NORMAL) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, NORMAL));
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&conv_internal_dac->proc_entry,
-			conv_internal_dac->bus_id,
-			snd_stm_conv_internal_dac_dump_registers,
-			conv_internal_dac);
-
-	return 0;
-}
-
-static int snd_stm_conv_internal_dac_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-			snd_device->device_data;
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(conv_internal_dac->proc_entry);
-
-	/* Global power done & mute mode */
-
-	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_conv_internal_dac_snd_device_ops = {
-	.dev_register = snd_stm_conv_internal_dac_register,
-	.dev_disconnect = snd_stm_conv_internal_dac_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_conv_internal_dac_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_conv_internal_dac_info *conv_internal_dac_info =
-			pdev->dev.platform_data;
-	struct snd_stm_conv_internal_dac *conv_internal_dac;
-	struct snd_card *card;
-	struct device *player_device;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	snd_assert(conv_internal_dac_info != NULL, return -EINVAL);
-
-	conv_internal_dac = kzalloc(sizeof(*conv_internal_dac), GFP_KERNEL);
-	if (!conv_internal_dac) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(conv_internal_dac);
-	conv_internal_dac->bus_id = pdev->dev.bus_id;
-	spin_lock_init(&conv_internal_dac->status_lock);
-
-	/* Converter interface initialization */
-
-	conv_internal_dac->conv.name = conv_internal_dac_info->name;
-	conv_internal_dac->conv.get_format =
-			snd_stm_conv_internal_dac_get_format;
-	conv_internal_dac->conv.get_oversampling =
-			snd_stm_conv_internal_dac_get_oversampling;
-	conv_internal_dac->conv.enable = snd_stm_conv_internal_dac_enable;
-	conv_internal_dac->conv.disable = snd_stm_conv_internal_dac_disable;
-	conv_internal_dac->conv.mute = snd_stm_conv_internal_dac_mute;
-	conv_internal_dac->conv.unmute = snd_stm_conv_internal_dac_unmute;
-
-	/* Get resources */
-
-	result = snd_stm_memory_request(pdev, &conv_internal_dac->mem_region,
-			&conv_internal_dac->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	/* Get connections */
-
-	snd_assert(conv_internal_dac_info->card_id, return -EINVAL);
-	card = snd_stm_cards_get(conv_internal_dac_info->card_id);
-	snd_assert(card, return -EINVAL);
-	snd_printd("This DAC will be a member of a card '%s'.\n", card->id);
-
-	snd_assert(conv_internal_dac_info->source_bus_id != NULL,
-			return -EINVAL);
-	snd_printd("This DAC is attached to PCM player '%s'.\n",
-			conv_internal_dac_info->source_bus_id);
-	player_device = snd_stm_find_device(NULL,
-			conv_internal_dac_info->source_bus_id);
-	snd_assert(player_device != NULL, return -EINVAL);
-	result = snd_stm_conv_attach(&conv_internal_dac->conv, player_device);
-	if (result < 0) {
-		snd_stm_printe("Can't attach to PCM player!\n");
-		goto error_attach;
-	}
-
-	/* Create ALSA lowlevel device*/
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_internal_dac,
-			&snd_stm_conv_internal_dac_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Create ALSA control */
-
-	snd_stm_conv_dac_internal_ctl_mute.device =
-			conv_internal_dac_info->card_device;
-	result = snd_ctl_add(card,
-			snd_ctl_new1(&snd_stm_conv_dac_internal_ctl_mute,
-			conv_internal_dac));
-	if (result < 0) {
-		snd_stm_printe("Failed to add all ALSA control!\n");
-		goto error_control;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, &conv_internal_dac->conv);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return 0;
-
-error_control:
-error_device:
-error_attach:
-	snd_stm_memory_release(conv_internal_dac->mem_region,
-			conv_internal_dac->base);
-error_memory_request:
-	snd_stm_magic_clear(conv_internal_dac);
-	kfree(conv_internal_dac);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_conv_internal_dac_remove(struct platform_device *pdev)
-{
-	struct snd_stm_conv_internal_dac *conv_internal_dac =
-			container_of(platform_get_drvdata(pdev),
-			struct snd_stm_conv_internal_dac, conv);
-
-	snd_assert(conv_internal_dac, return -EINVAL);
-	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
-
-	snd_stm_memory_release(conv_internal_dac->mem_region,
-			conv_internal_dac->base);
-
-	snd_stm_magic_clear(conv_internal_dac);
-	kfree(conv_internal_dac);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_conv_internal_dac_driver = {
-	.driver = {
-		.name = "conv_internal_dac",
-	},
-	.probe = snd_stm_conv_internal_dac_probe,
-	.remove = snd_stm_conv_internal_dac_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_conv_internal_dac_init(void)
-{
-	return platform_driver_register(&snd_stm_conv_internal_dac_driver);
-}
-
-void snd_stm_conv_internal_dac_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_conv_internal_dac_driver);
-}
diff --git a/sound/soc/stm/fsynth.c b/sound/soc/stm/fsynth.c
deleted file mode 100644
index 7a1abb5..0000000
--- a/sound/soc/stm/fsynth.c
+++ /dev/null
@@ -1,749 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' audio oversampling frequency
- *   synthesizers driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Authors: Pawel MOLL <pawel.moll@st.com>
- *            Daniel THOMPSON <daniel.thompson@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <asm/div64.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/info.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 5 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Hardware constants
- */
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-#	define CHANNELS 3
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200) || defined(CONFIG_CPU_SUBTYPE_STX7111)
-#	define CHANNELS 4
-#endif
-
-/* PLL inside the synthesizer multiplies input frequency
- * (which is 30MHz in our case) by 8... */
-#define PLL_FREQ 8 * 30 * 1000 * 1000
-
-
-
-/*
- * Audio frequency synthesizer structures
- */
-
-struct snd_stm_fsynth_channel {
-	struct snd_stm_fsynth *fsynth;
-
-	int frequency;  /* Nominal */
-	int adjustment; /* Actual (achieved) */
-};
-
-struct snd_stm_fsynth {
-	const char *bus_id;
-
-	struct resource *mem_region;
-
-	void *base;
-
-	int channels_from, channels_to;
-	struct snd_stm_fsynth_channel channels[CHANNELS];
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Toolbox
- */
-
-/* Return the number of set bits in x. */
-static unsigned int population(unsigned int x)
-{
-	/* This is the traditional branch-less algorithm for population count */
-	x = x - ((x >> 1) & 0x55555555);
-	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
-	x = (x + (x >> 4)) & 0x0f0f0f0f;
-	x = x + (x << 8);
-	x = x + (x << 16);
-
-	return x >> 24;
-}
-
-/* Return the index of the most significant set in x.
- * The results are 'undefined' is x is 0 (0xffffffff as it happens
- * but this is a mere side effect of the algorithm. */
-static unsigned int most_significant_set_bit(unsigned int x)
-{
-	/* propagate the MSSB right until all bits smaller than MSSB are set */
-	x = x | (x >> 1);
-	x = x | (x >> 2);
-	x = x | (x >> 4);
-	x = x | (x >> 8);
-	x = x | (x >> 16);
-
-	/* now count the number of set bits [clz is population(~x)] */
-	return population(x) - 1;
-}
-
-/* Solve the frequency synthesiser equations to provide a specified output
- * frequency.
- *
- * The approach taken to solve the equation is to solve for sdiv assuming
- * maximal values for md and one greater than maximal pe (-16 and 32768
- * respectively) before rounding down. Once sdiv is selected we can
- * solve for md by assuming maximal pe and rounding down. With these
- * values pe can trivially be calculated.
- *
- * The function is implemented entirely with integer calculations making
- * it suitable for use within the Linux kernel.
- *
- * The magic numbers within the function are derived from the Fsynth equation
- * which is as follows:
- *
- * <pre>
- *                                  32768*Fpll
- * #1: Fout = ------------------------------------------------------
- *                            md                        (md + 1)
- *            (sdiv*((pe*(1 + --)) - ((pe - 32768)*(1 + --------))))
- *                            32                           32
- * </pre>
- *
- * Where:
- *
- *  - Fpll and Fout are frequencies in Hz
- *  - sdiv is power of 2 between 1 and 8
- *  - md is an integer between -1 and -16
- *  - pe is an integer between 0 and 32767
- *
- * This simplifies to:
- *
- * <pre>
- *                       1048576*Fpll
- * #2: Fout = ----------------------------------
- *            (sdiv*(1081344 - pe + (32768*md)))
- * </pre>
- *
- * Rearranging:
- *
- * <pre>
- *                 1048576*Fpll
- * #3: predivide = ------------ = (sdiv*(1081344 - pe + (32768*md)))
- *                     Fout
- * </pre>
- *
- * If solve for sdiv and let pe = 32768 and md = -16 we get:
- *
- * <pre>
- *                     predivide            predivide
- * #4: sdiv = --------------------------- = ---------
- *            (1081344 - pe + (32768*md))     524288
- * </pre>
- *
- * Returning to eqn. #3, solving for md and let pe = 32768 we get:
- *
- * <pre>
- *           predivide                    predivide
- *          (--------- - 1081344 + pe)   (--------- - 1048576)
- *             sdiv                         sdiv
- * #5: md = -------------------------- = ---------------------
- *                    32768                      32768
-
- * </pre>
- *
- * Finally we return to #3 and rearrange for pe:
- *
- * <pre>
- *              predivide
- * #6: pe = -1*(--------- - 1081344 - (32768*md))
- *                sdiv
- * </pre>
- *
- */
-static int solve_fsynth_eqn(unsigned int Fpll, unsigned int Fout,
-		unsigned int *sdivp, int *mdp, unsigned int *pep)
-{
-	unsigned long long p, q;
-	unsigned int predivide;
-	int preshift; /* always +ve but used in subtraction */
-	unsigned int sdiv;
-	int md;
-	unsigned int pe = 1 << 14;
-
-	/* pre-divide the frequencies */
-	p = 1048576ull * Fpll;		/* <<20? */
-	q = Fout;
-
-	predivide = (unsigned int)div64_64(p, q);
-
-	/* determine an appropriate value for the output divider using eqn. #4
-	 * with md = -16 and pe = 32768 (and round down) */
-	sdiv = predivide / 524288;
-	if (sdiv > 1) {
-		/* sdiv = fls(sdiv) - 1; // this doesn't work
-		 * for some unknown reason */
-		sdiv = most_significant_set_bit(sdiv);
-	} else
-		sdiv = 1;
-
-	/* pre-shift a common sub-expression of later calculations */
-	preshift = predivide >> sdiv;
-
-	/* determine an appropriate value for the coarse selection using eqn. #5
-	 * with pe = 32768 (and round down which for signed values means away
-	 * from zero) */
-	md = ((preshift - 1048576) / 32768) - 1;	/* >>15? */
-
-	/* calculate a value for pe that meets the output target */
-	pe = -1 * (preshift - 1081344 - (32768 * md));	/* <<15? */
-
-	/* finally give sdiv its true hardware form */
-	sdiv--;
-
-	/* special case for 58593.75Hz and harmonics...
-	 * can't quite seem to get the rounding right */
-	if (md == -17 && pe == 0) {
-		md = -16;
-		pe = 32767;
-	}
-
-	/* update the outgoing arguments */
-	*sdivp = sdiv;
-	*mdp = md;
-	*pep = pe;
-
-	snd_stm_printt("SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
-
-	/* return 0 if all variables meet their contraints */
-	return (sdiv <= 7 && -16 <= md && md <= -1 && pe <= 32767) ? 0 : -1;
-}
-
-/*
- *                   1048576*Fpll
- * Fout = ----------------------------------
- *        (sdiv*(1081344 - pe + (32768*md)))
- *
- * Fpll is premultiplied by 8
- * Fout needs dividing by 256 to get real frequency
- *
- * small error compared to double based original
- * i.e. for 44100 (11289600) it reports 11289610 instead of 11289610.36
- */
-static int get_fsynth_output(unsigned int Fpll,
-		unsigned int sdiv, int md, unsigned int pe)
-{
-	long long p, q, r, s, t, u;
-
-	p = 1048576ll * Fpll;
-	q = 32768 * md;
-	r = 1081344 - pe;
-	s = r + q;
-	t = (1 << (sdiv + 1)) * s;
-	u = div64_64(p, t);
-
-	return (int)u;
-}
-
-static int snd_stm_fsynth_channel_configure(struct snd_stm_fsynth *fsynth,
-		int channel, int frequency, int adjustment)
-{
-	int result;
-	unsigned int sdiv;
-	int md;
-	unsigned int pe;
-	int frequency_adjusted, frequency_achieved, adjustment_achieved;
-	int delta;
-
-	snd_stm_printt("snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
-			"frequency=%d, adjustment=%d)\n", fsynth, channel,
-			frequency, adjustment);
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
-	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
-
-	/* All specs say, that maximum frequency generated by the fsynth
-	 * is 12.288MHz... */
-	if (frequency > 12288000)
-		snd_stm_printe("WARNING! %s should not generate frequency %d!"
-				" (12.288MHz is maximum)\n",
-				fsynth->bus_id, frequency);
-
-	/*             a
-	 * F = f + --------- * f = f + d
-	 *          1000000
-	 *
-	 *         a
-	 * d = --------- * f
-	 *      1000000
-	 *
-	 * where:
-	 *   f - nominal frequency
-	 *   a - adjustment in ppm (parts per milion)
-	 *   F - frequency to be set in synthesizer
-	 *   d - delta (difference) between f and F
-	 */
-	if (adjustment < 0) {
-		/* div64_64 operates on unsigned values... */
-		delta = -1;
-		adjustment = -adjustment;
-	} else {
-		delta = 1;
-	}
-	/* 500000 ppm is 0.5, which is used to round up values */
-	delta *= (int)div64_64((uint64_t)frequency * (uint64_t)adjustment +
-			500000, 1000000);
-	frequency_adjusted = frequency + delta;
-
-	snd_stm_printt("Setting %s channel %d to frequency %d.\n",
-			fsynth->bus_id, channel,
-			frequency_adjusted);
-
-	result = solve_fsynth_eqn(PLL_FREQ, frequency_adjusted,
-			&sdiv, &md, &pe);
-	if (result < 0) {
-		snd_stm_printe("Frequency %d can't be generated!\n",
-				frequency_adjusted);
-		return -EINVAL;
-	}
-
-	snd_stm_printt("SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
-			(unsigned int)md & AUDCFG_FSYN_MD__MD__MASK, pe);
-	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
-			PROG_EN, PE0_MD0_IGNORED);
-	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_SDIV, channel,
-			SDIV, sdiv);
-	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_MD, channel,
-			MD, (unsigned int)md & AUDCFG_FSYN_MD__MD__MASK);
-	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_PE, channel,
-			PE, pe);
-	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
-			PROG_EN, PE0_MD0_USED);
-	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
-			PROG_EN, PE0_MD0_IGNORED);
-
-	/*             a                    a
-	 * F = f + --------- * f   =>   --------- * f = F - f   ==>
-	 *          1000000              1000000
-	 *
-	 *           a        F - f               F - f
-	 * ==>   --------- = -------   ==>   a = ------- * 1000000
-	 *        1000000       f                   f
-	 *
-	 * F = f + d   ==>   d = F - f
-	 *
-	 *      f + d - f               d
-	 * a = ----------- * 1000000 = --- * 1000000
-	 *          f                   f
-	 * where:
-	 *   f - nominal frequency
-	 *   a - adjustment in ppm (parts per milion)
-	 *   F - frequency actually being generated by fsynch
-	 *   d - delta between F and f
-	 */
-	frequency_achieved = get_fsynth_output(PLL_FREQ, sdiv, md, pe);
-	delta = frequency_achieved - frequency;
-	if (delta < 0) {
-		/* div64_64 operates on unsigned values... */
-		delta = -delta;
-		adjustment_achieved = -1;
-	} else {
-		adjustment_achieved = 1;
-	}
-	/* frequency/2 is added to round up result */
-	adjustment_achieved *= (int)div64_64((uint64_t)delta * 1000000 +
-			frequency / 2, frequency);
-
-	snd_stm_printt("Nominal frequency is %d, actual frequency is %d, "
-			"(%d ppm difference).\n", frequency,
-			frequency_achieved, adjustment_achieved);
-
-	/* Save this informations for future generations ;-) */
-	fsynth->channels[channel].frequency = frequency;
-	fsynth->channels[channel].adjustment = adjustment_achieved;
-
-	return 0;
-}
-
-
-
-/*
- * ALSA controls
- */
-
-static int snd_stm_fsynth_adjustment_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = -1000000;
-	uinfo->value.integer.max = 1000000;
-
-	return 0;
-}
-
-static int snd_stm_fsynth_adjustment_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_fsynth_channel *fsynth_channel =
-		snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(fsynth_channel, return -EINVAL);
-	snd_assert(fsynth_channel->fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
-
-	ucontrol->value.integer.value[0] = fsynth_channel->adjustment;
-
-	return 0;
-}
-
-static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	int result;
-	struct snd_stm_fsynth_channel *fsynth_channel =
-		snd_kcontrol_chip(kcontrol);
-	struct snd_stm_fsynth *fsynth;
-	int channel;
-	int old_adjustement;
-
-	snd_stm_printt("snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(fsynth_channel, return -EINVAL);
-
-	fsynth = fsynth_channel->fsynth;
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-
-	channel = fsynth_channel - fsynth_channel->fsynth->channels;
-	old_adjustement = fsynth_channel->adjustment;
-
-	result = snd_stm_fsynth_channel_configure(fsynth, channel,
-			fsynth_channel->frequency,
-			ucontrol->value.integer.value[0]);
-
-	if (result < 0)
-		return -EINVAL;
-
-	return old_adjustement != fsynth_channel->adjustment;
-}
-
-static struct snd_kcontrol_new snd_stm_fsynth_adjustment_ctl = {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	.name = "PCM Playback Oversampling Freq. Adjustment",
-	.info = snd_stm_fsynth_adjustment_info,
-	.get = snd_stm_fsynth_adjustment_get,
-	.put = snd_stm_fsynth_adjustment_put,
-};
-
-
-
-/*
- * Audio frequency synthesizer public interface implementation
- */
-
-int snd_stm_fsynth_set_frequency(struct device *device, int channel,
-		int frequency)
-{
-	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
-
-	snd_stm_printt("snd_stm_fsynth_set_frequency(device=%p, channel=%d, "
-			"frequency=%d)\n", device, channel, frequency);
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
-	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
-
-	return snd_stm_fsynth_channel_configure(fsynth, channel, frequency, 0);
-}
-
-int snd_stm_fsynth_add_adjustement_ctl(struct device *device,
-		int channel, struct snd_card *card, int card_device)
-{
-	int result;
-	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
-
-	snd_stm_printt("snd_stm_fsynth_add_control(device=%p, channel=%d, "
-			"card=%p, card_device=%d)\n", device, channel,
-			card, card_device);
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
-	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
-
-	snd_stm_fsynth_adjustment_ctl.device = card_device;
-	result = snd_ctl_add(card, snd_ctl_new1(&snd_stm_fsynth_adjustment_ctl,
-			&fsynth->channels[channel]));
-	/* TODO: index per card */
-	snd_stm_fsynth_adjustment_ctl.index++;
-
-	return result;
-}
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-#define DUMP_REGISTER(r, n) \
-		snd_iprintf(buffer, "AUDCFG_FSYN%d_%s (offset 0x%02x) " \
-				"= 0x%08x\n", n, __stringify(r), \
-				AUDCFG_FSYN_##r(n), \
-				REGISTER_PEEK_N(fsynth->base, \
-				AUDCFG_FSYN_##r, n))
-
-static void snd_stm_fsynth_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_fsynth *fsynth = entry->private_data;
-	int i;
-
-	snd_assert(fsynth, return);
-	snd_stm_magic_assert(fsynth, return);
-
-	snd_iprintf(buffer, "AUDCFG_FSYN_CFG (offset 0x00) = 0x%08x\n",
-			REGISTER_PEEK(fsynth->base, AUDCFG_FSYN_CFG));
-
-	for (i = 0; i < CHANNELS; i++) {
-		DUMP_REGISTER(MD, i);
-		DUMP_REGISTER(PE, i);
-		DUMP_REGISTER(SDIV, i);
-		DUMP_REGISTER(PROGEN, i);
-	}
-}
-
-static int snd_stm_fsynth_register(struct snd_device *snd_device)
-{
-	struct snd_stm_fsynth *fsynth = snd_device->device_data;
-	unsigned long value = 0;
-	int i;
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-
-	/* Initialize & reset synthesizer */
-
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RESET);
-	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
-		snd_printd("Enabling synthesizer '%s' channel %d\n",
-				fsynth->bus_id, i);
-		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, PCM_CLK_SEL,
-				FSYNTH(i));
-#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
-		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, ENABLED(i));
-#endif
-		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, ACTIVE(i));
-	}
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, NORMAL);
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NDIV, 27_30_MHZ);
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, BW_SEL, GOOD_REFERENCE);
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, REF_CLK_IN, 30_MHZ_CLOCK);
-
-	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
-	barrier();
-
-	/* Unreset ;-) it now */
-
-	REGFIELD_SET(fsynth->base, AUDCFG_FSYN_CFG, RSTP, RUNNING);
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&fsynth->proc_entry, fsynth->bus_id,
-			snd_stm_fsynth_dump_registers, fsynth);
-
-	return 0;
-}
-
-static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_fsynth *fsynth = snd_device->device_data;
-	unsigned long value = 0;
-	int i;
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(fsynth->proc_entry);
-
-	/* Disable synthesizer */
-
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RUNNING);
-	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
-#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
-		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, DISABLED(i));
-#endif
-		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, STANDBY(i));
-	}
-	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, POWER_DOWN);
-
-	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_fsynth_snd_device_ops = {
-	.dev_register = snd_stm_fsynth_register,
-	.dev_disconnect = snd_stm_fsynth_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_fsynth_info *fsynth_info = pdev->dev.platform_data;
-	struct snd_stm_fsynth *fsynth;
-	struct snd_card *card;
-	int i;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	snd_assert(fsynth_info != NULL, return -EINVAL);
-
-	fsynth = kzalloc(sizeof(*fsynth), GFP_KERNEL);
-	if (!fsynth) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(fsynth);
-	fsynth->bus_id = pdev->dev.bus_id;
-	for (i = 0; i < CHANNELS; i++)
-		fsynth->channels[i].fsynth = fsynth;
-
-	result = snd_stm_memory_request(pdev, &fsynth->mem_region,
-			&fsynth->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	if (fsynth_info->card_id)
-		card = snd_stm_cards_get(fsynth_info->card_id);
-	else
-		card = snd_stm_cards_default();
-	snd_assert(card, return -EINVAL);
-	snd_printd("This frequency synthesizer will be a member "
-			"of a card '%s'\n", card->id);
-
-	fsynth->channels_from = fsynth_info->channels_from;
-	fsynth->channels_to = fsynth_info->channels_to;
-	snd_assert(fsynth->channels_from < fsynth->channels_to,
-			return -EINVAL);
-	snd_assert(fsynth->channels_from >= 0, return -EINVAL);
-	snd_assert(fsynth->channels_to < CHANNELS, return -EINVAL);
-
-	snd_printd("Used synthesizer channels: %d to %d\n",
-			fsynth->channels_from, fsynth->channels_to);
-
-	/* ALSA component */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, fsynth,
-			&snd_stm_fsynth_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, fsynth);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return result;
-
-error_device:
-	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
-error_memory_request:
-	snd_stm_magic_clear(fsynth);
-	kfree(fsynth);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_fsynth_remove(struct platform_device *pdev)
-{
-	struct snd_stm_fsynth *fsynth = platform_get_drvdata(pdev);
-
-	snd_assert(fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth, return -EINVAL);
-
-	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
-
-	snd_stm_magic_clear(fsynth);
-	kfree(fsynth);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_fsynth_driver = {
-	.driver = {
-		.name = "fsynth",
-	},
-	.probe = snd_stm_fsynth_probe,
-	.remove = snd_stm_fsynth_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_fsynth_init(void)
-{
-	return platform_driver_register(&snd_stm_fsynth_driver);
-}
-
-void snd_stm_fsynth_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_fsynth_driver);
-}
diff --git a/sound/soc/stm/init.c b/sound/soc/stm/init.c
deleted file mode 100644
index ddb4e7d..0000000
--- a/sound/soc/stm/init.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- *   STMicrolectronics System-on-Chips' audio subsystem driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-
-#undef TRACE
-#include "common.h"
-
-MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio subsystem");
-MODULE_LICENSE("GPL");
-
-static int __init alsa_card_stm_init(void)
-{
-	int result;
-
-	snd_printd("=== STM ALSA driver is initializing...\n");
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-	result = snd_stm_stx710x_init();
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	result = snd_stm_stx7111_init();
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-	result = snd_stm_stx7200_init();
-#endif
-	if (result != 0) {
-		snd_stm_printe("Can't initialize SOC platform!\n");
-		goto error_soc;
-	}
-
-	result = snd_stm_info_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize procfs info entries!\n");
-		goto error_info;
-	}
-	result = snd_stm_audio_outputs_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize audio outputs!\n");
-		goto error_audio_outputs;
-	}
-	result = snd_stm_fsynth_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize frequency synthesizer!\n");
-		goto error_fsynth;
-	}
-	result = snd_stm_conv_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize converters infrastructure!\n");
-		goto error_conv;
-	}
-	result = snd_stm_conv_dummy_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize dummy converter!\n");
-		goto error_conv_dummy;
-	}
-	result = snd_stm_conv_internal_dac_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize internal DACs!\n");
-		goto error_conv_internal_dac;
-	}
-	result = snd_stm_conv_i2s_spdif_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize I2S to SPDIF converter!\n");
-		goto error_conv_i2s_spdif;
-	}
-	result = snd_stm_synchro_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize synchronisation routines!\n");
-		goto error_synchro;
-	}
-	result = snd_stm_pcm_player_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize PCM player!\n");
-		goto error_pcm_player;
-	}
-	result = snd_stm_pcm_reader_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize PCM reader!\n");
-		goto error_pcm_reader;
-	}
-	result = snd_stm_spdif_player_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize SPDIF player!\n");
-		goto error_spdif_player;
-	}
-
-	/* Cards should be created by SoC-specific initialization
-	 * function (snd_stm_stxXXXX_init) */
-	result = snd_stm_cards_register();
-	if (result != 0) {
-		snd_stm_printe("Can't register ALSA cards!\n");
-		goto error_cards;
-	}
-
-	snd_printd("=== Success!\n");
-
-	return result;
-
-error_cards:
-	snd_stm_spdif_player_cleanup();
-error_spdif_player:
-	snd_stm_pcm_reader_cleanup();
-error_pcm_reader:
-	snd_stm_pcm_player_cleanup();
-error_pcm_player:
-	snd_stm_synchro_cleanup();
-error_synchro:
-	snd_stm_conv_i2s_spdif_cleanup();
-error_conv_i2s_spdif:
-	snd_stm_conv_internal_dac_cleanup();
-error_conv_internal_dac:
-	snd_stm_conv_dummy_cleanup();
-error_conv_dummy:
-	snd_stm_conv_cleanup();
-error_conv:
-	snd_stm_fsynth_cleanup();
-error_fsynth:
-	snd_stm_audio_outputs_cleanup();
-error_audio_outputs:
-	snd_stm_info_cleanup();
-error_info:
-	snd_stm_cards_free();
-error_soc:
-	return result;
-}
-
-static void __exit alsa_card_stm_exit(void)
-{
-	snd_printd("=== STM ALSA driver cleanup.\n");
-
-	snd_stm_cards_free();
-
-	snd_stm_spdif_player_cleanup();
-	snd_stm_pcm_reader_cleanup();
-	snd_stm_pcm_player_cleanup();
-	snd_stm_synchro_cleanup();
-	snd_stm_conv_i2s_spdif_cleanup();
-	snd_stm_conv_internal_dac_cleanup();
-	snd_stm_conv_dummy_cleanup();
-	snd_stm_conv_cleanup();
-	snd_stm_fsynth_cleanup();
-	snd_stm_audio_outputs_cleanup();
-	snd_stm_info_cleanup();
-
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-	snd_stm_stx710x_cleanup();
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	snd_stm_stx7111_cleanup();
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_STX7200)
-	snd_stm_stx7200_cleanup();
-#endif
-}
-
-module_init(alsa_card_stm_init)
-module_exit(alsa_card_stm_exit)
diff --git a/sound/soc/stm/pcm_player.c b/sound/soc/stm/pcm_player.c
deleted file mode 100644
index 3981f7d..0000000
--- a/sound/soc/stm/pcm_player.c
+++ /dev/null
@@ -1,1090 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' PCM player driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *           Mark Glaisher
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/bpa2.h>
-#include <asm/cacheflush.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/stm-dma.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/control.h>
-#include <sound/info.h>
-#include <sound/pcm_params.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 6 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Some hardware-related definitions
- */
-
-#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
-		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
-#define DEFAULT_OVERSAMPLING 256
-
-/* The sample count field (NSAMPLES in CTRL register) is 19 bits wide */
-#define MAX_SAMPLES_PER_PERIOD ((1 << 19) - 1)
-
-#define MAX_CHANNELS 10
-
-
-
-/*
- * PCM player instance definition
- */
-
-struct snd_stm_pcm_player {
-	/* System informations */
-	struct snd_stm_pcm_player_info *info;
-	struct device *device;
-	struct snd_pcm *pcm;
-
-	/* Resources */
-	struct resource *mem_region;
-	void *base;
-	unsigned long fifo_phys_address;
-	unsigned int irq;
-	unsigned int fdma_channel;
-
-	/* Environment settings */
-	struct device *fsynth_device;
-	int fsynth_channel;
-	struct snd_stm_conv *conv;
-	struct snd_pcm_hw_constraint_list channels_constraint;
-
-	/* Runtime data */
-	void *buffer;
-	struct snd_info_entry *proc_entry;
-	struct snd_pcm_substream *substream;
-	struct stm_dma_params fdma_params;
-	struct stm_dma_req *fdma_request;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Playing engine implementation
- */
-
-static irqreturn_t snd_stm_pcm_player_irq_handler(int irq, void *dev_id)
-{
-	irqreturn_t result = IRQ_NONE;
-	struct snd_stm_pcm_player *pcm_player = dev_id;
-	unsigned int status;
-
-	snd_stm_printt("snd_stm_pcm_player_irq_handler(irq=%d, dev_id=0x%p)\n",
-			irq, dev_id);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* Get interrupt status & clear them immediately */
-	preempt_disable();
-	status = REGISTER_PEEK(pcm_player->base, AUD_PCMOUT_ITS);
-	REGISTER_POKE(pcm_player->base, AUD_PCMOUT_ITS_CLR, status);
-	preempt_enable();
-
-	/* Underflow? */
-	if (unlikely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, UNF, PENDING))) {
-		snd_stm_printe("Underflow detected in PCM player '%s'!\n",
-				pcm_player->device->bus_id);
-		result = IRQ_HANDLED;
-	}
-
-	/* Period successfully played */
-	if (likely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, NSAMPLE, PENDING)))
-		do {
-			snd_assert(pcm_player->substream, break);
-
-			snd_stm_printt("Period elapsed ('%s')\n",
-					pcm_player->device->bus_id);
-			snd_pcm_period_elapsed(pcm_player->substream);
-
-			result = IRQ_HANDLED;
-		} while (0);
-
-	/* Some alien interrupt??? */
-	snd_assert(result == IRQ_HANDLED);
-
-	return result;
-}
-
-static struct snd_pcm_hardware snd_stm_pcm_player_hw = {
-	.info		= (SNDRV_PCM_INFO_MMAP |
-				SNDRV_PCM_INFO_MMAP_VALID |
-				SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				SNDRV_PCM_INFO_PAUSE),
-	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
-				SNDRV_PCM_FMTBIT_S16_LE),
-
-	.rates		= (SNDRV_PCM_RATE_32000 |
-				SNDRV_PCM_RATE_44100 |
-				SNDRV_PCM_RATE_48000 |
-				SNDRV_PCM_RATE_64000 |
-				SNDRV_PCM_RATE_88200 |
-				SNDRV_PCM_RATE_96000 |
-				SNDRV_PCM_RATE_176400 |
-				SNDRV_PCM_RATE_192000),
-	.rate_min	= 32000,
-	.rate_max	= 192000,
-
-	.channels_min	= 2,
-	.channels_max	= 10,
-
-	.periods_min	= 2,
-	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
-
-	/* Values below were worked out mostly basing on ST media player
-	 * requirements. They should, however, fit most "normal" cases...
-	 * Note 1: that these value must be also calculated not to exceed
-	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
-	 * Note 2: for 16/16-bits data this counter is a "frames counter",
-	 * not "samples counter" (two channels are read as one word).
-	 * Note 3: period_bytes_min defines minimum time between period
-	 * (NSAMPLE) interrupts... Keep it large enough not to kill
-	 * the system... */
-	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
-	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
-	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
-};
-
-static int snd_stm_pcm_player_open(struct snd_pcm_substream *substream)
-{
-	int result;
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_pcm_player_open(substream=0x%p)\n", substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	snd_pcm_set_sync(substream);  /* TODO: ??? */
-
-	/* Get attached converter handle */
-
-	pcm_player->conv = snd_stm_conv_get_attached(pcm_player->device);
-	if (pcm_player->conv)
-		snd_stm_printt("Converter '%s' attached to '%s'...\n",
-				pcm_player->conv->name,
-				pcm_player->device->bus_id);
-	else
-		snd_stm_printt("Warning! No converter attached to '%s'!\n",
-				pcm_player->device->bus_id);
-
-	/* Set up constraints & pass hardware capabilities info to ALSA */
-
-	result = snd_pcm_hw_constraint_list(runtime, 0,
-			SNDRV_PCM_HW_PARAM_CHANNELS,
-			&pcm_player->channels_constraint);
-	if (result < 0) {
-		snd_stm_printe("Can't set channels constraint!\n");
-		return result;
-	}
-
-	/* It is better when buffer size is an integer multiple of period
-	 * size... Such thing will ensure this :-O */
-	result = snd_pcm_hw_constraint_integer(runtime,
-			SNDRV_PCM_HW_PARAM_PERIODS);
-	if (result < 0) {
-		snd_stm_printe("Can't set periods constraint!\n");
-		return result;
-	}
-
-	/* Make the period (so buffer as well) length (in bytes) a multiply
-	 * of a FDMA transfer bytes (which varies depending on channels
-	 * number and sample bytes) */
-	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			pcm_player->info->fdma_max_transfer_size * 4);
-	if (result < 0) {
-		snd_stm_printe("Can't set buffer bytes constraint!\n");
-		return result;
-	}
-
-	runtime->hw = snd_stm_pcm_player_hw;
-
-	return 0;
-}
-
-static int snd_stm_pcm_player_close(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_player_close(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	return 0;
-}
-
-static int snd_stm_pcm_player_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_pcm_player_hw_free(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This callback may be called more than once... */
-
-	if (pcm_player->buffer) {
-		/* Dispose buffer */
-
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", pcm_player->device->bus_id,
-				pcm_player->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
-
-		iounmap(runtime->dma_area);
-
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
-
-		pcm_player->buffer = NULL;
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
-
-		/* Dispose FDMA parameters & configuration */
-
-		dma_params_free(&pcm_player->fdma_params);
-		dma_req_free(pcm_player->fdma_channel,
-				pcm_player->fdma_request);
-	}
-
-	return 0;
-}
-
-static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *hw_params)
-{
-	int result;
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes, frame_bytes, transfer_bytes;
-	unsigned int transfer_size;
-	struct stm_dma_req_config fdma_req_config = {
-		.rw        = REQ_CONFIG_WRITE,
-		.opcode    = REQ_CONFIG_OPCODE_4,
-		.increment = 0,
-		.hold_off  = 0,
-		.initiator = pcm_player->info->fdma_initiator,
-	};
-
-	snd_stm_printt("snd_stm_pcm_player_hw_params(substream=0x%p,"
-			" hw_params=0x%p)\n", substream, hw_params);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This function may be called many times, so let's be prepared... */
-	if (pcm_player->buffer)
-		snd_stm_pcm_player_hw_free(substream);
-
-	/* Allocate buffer */
-
-	buffer_bytes = params_buffer_bytes(hw_params);
-	pcm_player->buffer = bigphysarea_alloc(buffer_bytes);
-	/* TODO: move to BPA2, use pcm lib as fallback... */
-	if (!pcm_player->buffer) {
-		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, pcm_player->device->bus_id);
-		result = -ENOMEM;
-		goto error_buf_alloc;
-	}
-
-	runtime->dma_addr = virt_to_phys(pcm_player->buffer);
-	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
-	runtime->dma_bytes = buffer_bytes;
-
-	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
-			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", pcm_player->device->bus_id,
-			pcm_player->buffer, runtime->dma_addr,
-			runtime->dma_area, runtime->dma_bytes);
-
-	/* Set FDMA transfer size (number of opcodes generated
-	 * after request line assertion) */
-
-	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
-			params_channels(hw_params) / 8;
-	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			pcm_player->info->fdma_max_transfer_size * 4);
-	transfer_size = transfer_bytes / 4;
-	snd_stm_printt("FDMA request trigger limit and transfer size set to "
-			"%d.\n", transfer_size);
-
-	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_assert(transfer_size <= pcm_player->info->fdma_max_transfer_size,
-			return -EINVAL);
-	fdma_req_config.count = transfer_size;
-
-	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
-			return -EINVAL);
-	snd_assert(transfer_size <= AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK,
-			return -EINVAL);
-	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
-			DMA_REQ_TRIG_LMT, transfer_size);
-
-	/* Configure FDMA transfer */
-
-	pcm_player->fdma_request = dma_req_config(pcm_player->fdma_channel,
-			pcm_player->info->fdma_request_line, &fdma_req_config);
-	if (!pcm_player->fdma_request) {
-		snd_stm_printe("Can't configure FDMA pacing channel for player"
-				" '%s'!\n", pcm_player->device->bus_id);
-		result = -EINVAL;
-		goto error_req_config;
-	}
-
-	dma_params_init(&pcm_player->fdma_params, MODE_PACED,
-			STM_DMA_LIST_CIRC);
-
-	dma_params_DIM_1_x_0(&pcm_player->fdma_params);
-
-	dma_params_req(&pcm_player->fdma_params, pcm_player->fdma_request);
-
-	dma_params_addrs(&pcm_player->fdma_params, runtime->dma_addr,
-			pcm_player->fifo_phys_address, buffer_bytes);
-
-	result = dma_compile_list(pcm_player->fdma_channel,
-				&pcm_player->fdma_params, GFP_KERNEL);
-	if (result < 0) {
-		snd_stm_printe("Can't compile FDMA parameters for player"
-				" '%s'!\n", pcm_player->device->bus_id);
-		goto error_compile_list;
-	}
-
-	return 0;
-
-error_compile_list:
-	dma_req_free(pcm_player->fdma_channel,
-			pcm_player->fdma_request);
-error_req_config:
-	iounmap(runtime->dma_area);
-	/* TODO: symmetrical to the above (BPA2 etc.) */
-	bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
-	pcm_player->buffer = NULL;
-	runtime->dma_area = NULL;
-	runtime->dma_addr = 0;
-	runtime->dma_bytes = 0;
-error_buf_alloc:
-	return result;
-}
-
-static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned int format, lr_pol;
-	int oversampling, bits_in_output_frame;
-
-	snd_stm_printt("snd_stm_pcm_player_prepare(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(runtime->period_size * runtime->channels <
-			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
-
-	/* Configure SPDIF synchronisation */
-
-	/* TODO */
-
-	/* Get format & oversampling value from connected converter */
-
-	if (pcm_player->conv) {
-		format = snd_stm_conv_get_format(pcm_player->conv);
-		oversampling = snd_stm_conv_get_oversampling(pcm_player->conv);
-		if (oversampling == 0)
-			oversampling = DEFAULT_OVERSAMPLING;
-	} else {
-		format = DEFAULT_FORMAT;
-		oversampling = DEFAULT_OVERSAMPLING;
-	}
-
-	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
-			pcm_player->device->bus_id, runtime->rate,
-			oversampling);
-
-	snd_assert(oversampling > 0, return -EINVAL);
-
-	/* For 32 bits subframe oversampling must be a multiple of 128,
-	 * for 16 bits - of 64 */
-	snd_assert(((format & SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS) &&
-				(oversampling % 128 == 0)) ||
-				(oversampling % 64 == 0), return -EINVAL);
-
-	/* Set up frequency synthesizer */
-
-	snd_stm_fsynth_set_frequency(pcm_player->fsynth_device,
-			pcm_player->fsynth_channel,
-			runtime->rate * oversampling);
-
-	/* Set up player hardware */
-
-	snd_stm_printt("Player %s format configuration:\n",
-			pcm_player->device->bus_id);
-
-	/* Number of bits per subframe (which is one channel sample)
-	 * on output - it determines serial clock frequency, which is
-	 * 64 times sampling rate for 32 bits subframe (2 channels 32
-	 * bits each means 64 bits per frame) and 32 times sampling
-	 * rate for 16 bits subframe
-	 * (you know why, don't you? :-) */
-
-	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
-	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
-		snd_stm_printt("- 32 bits per subframe\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 32_BITS);
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				DATA_SIZE, 32_BITS);
-#else
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				DATA_SIZE, 24_BITS);
-#endif
-		bits_in_output_frame = 64; /* frame = 2 * subframe */
-		break;
-	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
-		snd_stm_printt("- 16 bits per subframe\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 16_BITS);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					DATA_SIZE, 16_BITS);
-			bits_in_output_frame = 32; /* frame = 2 * subframe */
-			break;
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Serial audio interface format - for detailed explanation
-	 * see ie.:
-	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-			ORDER, MSB_FIRST);
-
-	/* Value of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
-	 * actually means "data clocking on the falling edge" -
-	 * STx7100 and _some_ cuts of STx7109 have this value
-	 * inverted than datasheets claim... (specs say 1) */
-
-	if (pcm_player->info->invert_sclk_edge_falling) {
-		snd_stm_printt("Inverted SCLK_EDGE!\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				SCLK_EDGE, RISING);
-	} else {
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				SCLK_EDGE, FALLING);
-	}
-
-	switch (format & SND_STM_FORMAT__MASK) {
-	case SND_STM_FORMAT__I2S:
-		snd_stm_printt("- I2S\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				PADDING, 1_CYCLE_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
-		break;
-	case SND_STM_FORMAT__LEFT_JUSTIFIED:
-		snd_stm_printt("- left justified\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				PADDING, NO_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
-		break;
-	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
-		snd_stm_printt("- right justified\n");
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, RIGHT);
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				PADDING, NO_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
-		break;
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Configure PCM player frequency divider
-	 *
-	 *             Fdacclk             Fs * oversampling
-	 * divider = ----------- = ------------------------------- =
-	 *            2 * Fsclk     2 * Fs * bits_in_output_frame
-	 *
-	 *                  oversampling
-	 *         = --------------------------
-	 *            2 * bits_in_output_frame
-	 * where:
-	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
-	 *               MCLK (master clock), "system clock" etc.
-	 *   - Fsclk - frequency of SCLK (serial clock) aka BICK (bit clock)
-	 *   - Fs - sampling rate (frequency)
-	 *   - bits_in_output_frame - number of bits in output signal _frame_
-	 *                (32 or 64, depending on NBIT field of FMT register)
-	 */
-
-	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, CLK_DIV,
-			oversampling / (2 * bits_in_output_frame));
-
-	/* Configure data memory format & NSAMPLE interrupt */
-
-	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-		/* One data word contains two samples */
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
-				MEM_FMT, 16_BITS_16_BITS);
-
-		/* Workaround for a problem with L/R channels swap in case of
-		 * 16/16 memory model: PCM player expects left channel data in
-		 * word's upper two bytes, but due to little endianess
-		 * character of our memory there is right channel data there;
-		 * the workaround is to invert L/R signal, however it is
-		 * cheating, because in such case channel phases are shifted
-		 * by one sample...
-		 * (ask me for more details if above is not clear ;-)
-		 * TODO this somehow better... */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
-				LR_POL, !lr_pol);
-
-		/* One word of data is two samples (two channels...) */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
-				runtime->period_size * runtime->channels / 2);
-		break;
-
-	case SNDRV_PCM_FORMAT_S32_LE:
-		/* Actually "16 bits/0 bits" means "32/28/24/20/18/16 bits
-		 * on the left than zeros (if less than 32 bites)"... ;-) */
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
-				MEM_FMT, 16_BITS_0_BITS);
-
-		/* In x/0 bits memory mode there is no problem with
-		 * L/R polarity */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
-				lr_pol);
-
-		/* One word of data is one sample, so period size
-		 * times channels */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
-				runtime->period_size * runtime->channels);
-		break;
-
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Number of channels... */
-
-	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
-	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
-			return -EINVAL);
-
-	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, NUM_CH,
-			runtime->channels / 2);
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_player_start(struct snd_pcm_substream *substream)
-{
-	int result;
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_player_start(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* Un-reset PCM player */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RUNNING);
-
-	/* Launch FDMA transfer */
-
-	result = dma_xfer_list(pcm_player->fdma_channel,
-			&pcm_player->fdma_params);
-	if (result != 0) {
-		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
-				pcm_player->device->bus_id);
-		return -EINVAL;
-	}
-
-	/* Launch PCM player */
-
-	pcm_player->substream = substream;
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
-
-	/* Enable player interrupts */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, NSAMPLE, SET);
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, UNF, SET);
-
-	/* Wake up & unmute DAC */
-
-	if (pcm_player->conv) {
-		snd_stm_conv_enable(pcm_player->conv);
-		snd_stm_conv_unmute(pcm_player->conv);
-	}
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_player_stop(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_player_stop(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* Mute & shutdown DAC */
-
-	if (pcm_player->conv) {
-		snd_stm_conv_mute(pcm_player->conv);
-		snd_stm_conv_disable(pcm_player->conv);
-	}
-
-	/* Disable interrupts */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, NSAMPLE, CLEAR);
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, UNF, CLEAR);
-
-	/* Stop PCM player */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, OFF);
-	pcm_player->substream = NULL;
-
-	/* Stop FDMA transfer */
-
-	dma_stop_channel(pcm_player->fdma_channel);
-
-	/* Reset PCM player */
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_player_pause(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_player_pause(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* "Mute" player
-	 * Documentation describes this mode in a wrong way - data is _not_
-	 * consumed in the "mute" mode, so it is actually a "pause" mode */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, MUTE);
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_player_release(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-		snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_player_release(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* "Unmute" player */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
-
-	return 0;
-}
-
-static int snd_stm_pcm_player_trigger(struct snd_pcm_substream *substream,
-		int command)
-{
-	snd_stm_printt("snd_stm_pcm_player_trigger(substream=0x%p,"
-			" command=%d)\n", substream, command);
-
-	switch (command) {
-	case SNDRV_PCM_TRIGGER_START:
-		return snd_stm_pcm_player_start(substream);
-	case SNDRV_PCM_TRIGGER_STOP:
-		return snd_stm_pcm_player_stop(substream);
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		return snd_stm_pcm_player_pause(substream);
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		return snd_stm_pcm_player_release(substream);
-	default:
-		return -EINVAL;
-	}
-}
-
-static snd_pcm_uframes_t snd_stm_pcm_player_pointer(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-		snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int residue;
-	snd_pcm_uframes_t pointer;
-
-	snd_stm_printt("snd_stm_pcm_player_pointer(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	residue = get_dma_residue(pcm_player->fdma_channel);
-	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
-
-	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
-			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
-			pointer, pointer);
-
-	return pointer;
-}
-
-static struct snd_pcm_ops snd_stm_pcm_player_pcm_ops = {
-	.open =      snd_stm_pcm_player_open,
-	.close =     snd_stm_pcm_player_close,
-	.mmap =      snd_stm_mmap,
-	.ioctl =     snd_pcm_lib_ioctl,
-	.hw_params = snd_stm_pcm_player_hw_params,
-	.hw_free =   snd_stm_pcm_player_hw_free,
-	.prepare =   snd_stm_pcm_player_prepare,
-	.trigger =   snd_stm_pcm_player_trigger,
-	.pointer =   snd_stm_pcm_player_pointer,
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-#define DUMP_REGISTER(r) \
-		snd_iprintf(buffer, "AUD_PCMOUT_%s (offset 0x%02x) =" \
-				" 0x%08x\n", __stringify(r), \
-				AUD_PCMOUT_##r, \
-				REGISTER_PEEK(pcm_player->base, \
-				AUD_PCMOUT_##r))
-
-static void snd_stm_pcm_player_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_pcm_player *pcm_player = entry->private_data;
-
-	snd_assert(pcm_player, return);
-	snd_stm_magic_assert(pcm_player, return);
-
-	DUMP_REGISTER(RST);
-	DUMP_REGISTER(DATA);
-	DUMP_REGISTER(ITS);
-	DUMP_REGISTER(ITS_CLR);
-	DUMP_REGISTER(IT_EN);
-	DUMP_REGISTER(IT_EN_SET);
-	DUMP_REGISTER(IT_EN_CLR);
-	DUMP_REGISTER(CTRL);
-	DUMP_REGISTER(STA);
-	DUMP_REGISTER(FMT);
-}
-
-static int snd_stm_pcm_player_register(struct snd_device *snd_device)
-{
-	int result;
-	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_pcm_player_register(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	/* Set reset mode */
-
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
-
-	/* TODO: well, hardcoded - shall anyone use it?
-	 * And what it actually means? */
-
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, BACK_STALLING, DISABLED);
-#endif
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, RND, NO_ROUNDING);
-
-	/* Registers view in ALSA's procfs */
-
-	snd_stm_info_register(&pcm_player->proc_entry,
-			pcm_player->device->bus_id,
-			snd_stm_pcm_player_dump_registers, pcm_player);
-
-	/* Create ALSA controls */
-
-	result = snd_stm_conv_add_route_ctl(pcm_player->device,
-			snd_device->card, pcm_player->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add converter route control!\n");
-		return result;
-	}
-
-	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_device,
-			pcm_player->fsynth_channel,
-			snd_device->card, pcm_player->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add fsynth adjustment control!\n");
-		return result;
-	}
-
-	return 0;
-}
-
-static int snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_pcm_player_unregister(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_stm_info_unregister(pcm_player->proc_entry);
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_pcm_player_snd_device_ops = {
-	.dev_register = snd_stm_pcm_player_register,
-	.dev_disconnect = snd_stm_pcm_player_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_pcm_player *pcm_player;
-	struct snd_card *card;
-	int i;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
-	if (!pcm_player) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(pcm_player);
-	pcm_player->info = pdev->dev.platform_data;
-	snd_assert(pcm_player->info != NULL, return -EINVAL);
-	pcm_player->device = &pdev->dev;
-
-	/* Get resources */
-
-	result = snd_stm_memory_request(pdev, &pcm_player->mem_region,
-			&pcm_player->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-	pcm_player->fifo_phys_address = pcm_player->mem_region->start +
-		AUD_PCMOUT_DATA;
-	snd_printd("FIFO physical address: 0x%lx.\n",
-			pcm_player->fifo_phys_address);
-
-	result = snd_stm_irq_request(pdev, &pcm_player->irq,
-			snd_stm_pcm_player_irq_handler, pcm_player);
-	if (result < 0) {
-		snd_stm_printe("IRQ request failed!\n");
-		goto error_irq_request;
-	}
-
-	result = snd_stm_fdma_request(pdev, &pcm_player->fdma_channel);
-	if (result < 0) {
-		snd_stm_printe("FDMA request failed!\n");
-		goto error_fdma_request;
-	}
-
-	/* Get player capabilities */
-
-	snd_printd("Player's name is '%s'\n", pcm_player->info->name);
-
-	card = snd_stm_cards_get(pcm_player->info->card_id);
-	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Player will be a member of a card '%s' as a PCM device "
-			"no. %d.\n", card->id, pcm_player->info->card_device);
-
-	snd_assert(pcm_player->info->channels != NULL, return -EINVAL);
-	snd_assert(pcm_player->info->channels_num > 0, return -EINVAL);
-	pcm_player->channels_constraint.list = pcm_player->info->channels;
-	pcm_player->channels_constraint.count = pcm_player->info->channels_num;
-	pcm_player->channels_constraint.mask = 0;
-	for (i = 0; i < pcm_player->info->channels_num; i++)
-		snd_printd("Player capable of playing %u-channels PCM.\n",
-				pcm_player->info->channels[i]);
-
-	/* Get fsynth device */
-
-	snd_assert(pcm_player->info->fsynth_bus_id != NULL, return -EINVAL);
-	snd_printd("Player connected to %s's output %d.\n",
-			pcm_player->info->fsynth_bus_id,
-			pcm_player->info->fsynth_output);
-	pcm_player->fsynth_device = snd_stm_find_device(NULL,
-			pcm_player->info->fsynth_bus_id);
-	snd_assert(pcm_player->fsynth_device != NULL, return -EINVAL);
-	pcm_player->fsynth_channel = pcm_player->info->fsynth_output;
-
-	/* Preallocate buffer */
-
-	/* TODO */
-
-	/* Create ALSA lowlevel device */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_player,
-			&snd_stm_pcm_player_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Create ALSA PCM device */
-
-	result = snd_pcm_new(card, NULL, pcm_player->info->card_device, 1, 0,
-			&pcm_player->pcm);
-	if (result < 0) {
-		snd_stm_printe("ALSA PCM instance creation failed!\n");
-		goto error_pcm;
-	}
-	pcm_player->pcm->private_data = pcm_player;
-	strcpy(pcm_player->pcm->name, pcm_player->info->name);
-
-	snd_pcm_set_ops(pcm_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
-			&snd_stm_pcm_player_pcm_ops);
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, pcm_player);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return 0;
-
-error_pcm:
-	snd_device_free(card, pcm_player);
-error_device:
-	snd_stm_fdma_release(pcm_player->fdma_channel);
-error_fdma_request:
-	snd_stm_irq_release(pcm_player->irq, pcm_player);
-error_irq_request:
-	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
-error_memory_request:
-	snd_stm_magic_clear(pcm_player);
-	kfree(pcm_player);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_pcm_player_remove(struct platform_device *pdev)
-{
-	struct snd_stm_pcm_player *pcm_player = platform_get_drvdata(pdev);
-
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
-	snd_stm_fdma_release(pcm_player->fdma_channel);
-	snd_stm_irq_release(pcm_player->irq, pcm_player);
-	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
-
-	snd_stm_magic_clear(pcm_player);
-	kfree(pcm_player);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_pcm_player_driver = {
-	.driver = {
-		.name = "pcm_player",
-	},
-	.probe = snd_stm_pcm_player_probe,
-	.remove = snd_stm_pcm_player_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_pcm_player_init(void)
-{
-	return platform_driver_register(&snd_stm_pcm_player_driver);
-}
-
-void snd_stm_pcm_player_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_pcm_player_driver);
-}
diff --git a/sound/soc/stm/pcm_reader.c b/sound/soc/stm/pcm_reader.c
deleted file mode 100644
index 9562158..0000000
--- a/sound/soc/stm/pcm_reader.c
+++ /dev/null
@@ -1,993 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' PCM reader driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/bpa2.h>
-#include <asm/cacheflush.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/stm-dma.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/control.h>
-#include <sound/info.h>
-#include <sound/pcm_params.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 7 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Some hardware-related definitions
- */
-
-#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
-		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
-
-#define MAX_CHANNELS 10
-
-
-
-/*
- * PCM reader instance definition
- */
-
-struct snd_stm_pcm_reader {
-	/* System informations */
-	struct snd_stm_pcm_reader_info *info;
-	struct device *device;
-	struct snd_pcm *pcm;
-
-	/* Resources */
-	struct resource *mem_region;
-	void *base;
-	unsigned long fifo_phys_address;
-	unsigned int irq;
-	int fdma_channel;
-	struct stm_dma_req *fdma_request;
-
-	/* Environment settings */
-	struct snd_stm_conv *conv;
-	struct snd_pcm_hw_constraint_list channels_constraint;
-
-	/* Runtime data */
-	void *buffer;
-	struct snd_info_entry *proc_entry;
-	struct snd_pcm_substream *substream;
-	struct stm_dma_params *fdma_params_list;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Capturing engine implementation
- */
-
-static irqreturn_t snd_stm_pcm_reader_irq_handler(int irq, void *dev_id)
-{
-	irqreturn_t result = IRQ_NONE;
-	struct snd_stm_pcm_reader *pcm_reader = dev_id;
-	unsigned int status;
-
-	snd_stm_printt("snd_stm_pcm_reader_irq_handler(irq=%d, dev_id=0x%p)\n",
-			irq, dev_id);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	/* Get interrupt status & clear them immediately */
-	preempt_disable();
-	status = REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_ITS);
-	REGISTER_POKE(pcm_reader->base, AUD_PCMIN_ITS_CLR, status);
-	preempt_enable();
-
-	/* Overflow? */
-	if (unlikely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, OVF, PENDING))) {
-		snd_stm_printe("Overflow detected in PCM reader '%s'!\n",
-				pcm_reader->device->bus_id);
-		result = IRQ_HANDLED;
-		snd_pcm_stop(pcm_reader->substream, SNDRV_PCM_STATE_XRUN);
-	}
-
-	/* Period successfully played */
-	if (likely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, VSYNC, PENDING))) {
-		snd_stm_printt("Vsync interrupt detected by '%s'!\n",
-				pcm_reader->device->bus_id);
-		/* TODO: Calculate sampling frequency */
-		result = IRQ_HANDLED;
-	}
-
-	/* Some alien interrupt??? */
-	snd_assert(result == IRQ_HANDLED);
-
-	return result;
-}
-
-static void snd_stm_pcm_reader_callback_node_done(unsigned long param)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			(struct snd_stm_pcm_reader *)param;
-
-	snd_stm_printt("snd_stm_pcm_reader_callback_node_done(param=0x%lx)\n",
-			param);
-
-	snd_assert(pcm_reader, return);
-	snd_stm_magic_assert(pcm_reader, return);
-
-	/* This function will be called after stopping FDMA as well
-	 * and in this moment ALSA is already shut down... */
-	if (pcm_reader->substream) {
-		snd_stm_printt("Period elapsed ('%s')\n",
-				pcm_reader->device->bus_id);
-		snd_pcm_period_elapsed(pcm_reader->substream);
-	}
-}
-
-static void snd_stm_pcm_reader_callback_node_error(unsigned long param)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			(struct snd_stm_pcm_reader *)param;
-
-	snd_stm_printt("snd_stm_pcm_reader_callback_node_error(param=0x%lx)\n",
-			param);
-
-	snd_assert(pcm_reader, return);
-	snd_stm_magic_assert(pcm_reader, return);
-
-	snd_stm_printe("Error during FDMA transfer in reader '%s'!\n",
-			pcm_reader->device->bus_id);
-}
-
-static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
-	.info		= (SNDRV_PCM_INFO_MMAP |
-				SNDRV_PCM_INFO_MMAP_VALID |
-				SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER),
-#if 0
-	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
-				SNDRV_PCM_FMTBIT_S16_LE),
-#else
-	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
-#endif
-
-	/* Keep in mind that we are working in slave mode, so sampling
-	 * rate is determined by external components... */
-	.rates		= (SNDRV_PCM_RATE_CONTINUOUS),
-	.rate_min	= 32000,
-	.rate_max	= 192000,
-
-	.channels_min	= 2,
-	.channels_max	= 10,
-
-	.periods_min	= 2,
-	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
-
-	/* Values below were worked out mostly basing on ST media player
-	 * requirements. They should, however, fit most "normal" cases...
-	 * Note: period_bytes_min defines minimum time between FDMA transfer
-	 * interrupts... Keep it large enough not to kill the system... */
-
-	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
-	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
-	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
-};
-
-static int snd_stm_pcm_reader_open(struct snd_pcm_substream *substream)
-{
-	int result;
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_pcm_reader_open(substream=0x%p)\n", substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	snd_pcm_set_sync(substream);  /* TODO: ??? */
-
-	/* Get attached converter handle */
-
-	pcm_reader->conv = snd_stm_conv_get_attached(pcm_reader->device);
-	if (pcm_reader->conv)
-		snd_printd("Converter '%s' attached to '%s'...\n",
-				pcm_reader->conv->name,
-				pcm_reader->device->bus_id);
-	else
-		snd_printd("Warning! No converter attached to '%s'!\n",
-				pcm_reader->device->bus_id);
-
-	/* Set up constraints & pass hardware capabilities info to ALSA */
-
-	result = snd_pcm_hw_constraint_list(runtime, 0,
-			SNDRV_PCM_HW_PARAM_CHANNELS,
-			&pcm_reader->channels_constraint);
-	if (result < 0) {
-		snd_stm_printe("Can't set channels constraint!\n");
-		return result;
-	}
-
-	/* Buffer size must be an integer multiple of a period size to use
-	 * FDMA nodes as periods... Such thing will ensure this :-O */
-	result = snd_pcm_hw_constraint_integer(runtime,
-			SNDRV_PCM_HW_PARAM_PERIODS);
-	if (result < 0) {
-		snd_stm_printe("Can't set periods constraint!\n");
-		return result;
-	}
-
-	/* Make the period (so buffer as well) length (in bytes) a multiply
-	 * of a FDMA transfer bytes (which varies depending on channels
-	 * number and sample bytes) */
-	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			pcm_reader->info->fdma_max_transfer_size * 4);
-	if (result < 0) {
-		snd_stm_printe("Can't set buffer bytes constraint!\n");
-		return result;
-	}
-
-	runtime->hw = snd_stm_pcm_reader_hw;
-
-	return 0;
-}
-
-static int snd_stm_pcm_reader_close(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_reader_close(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	return 0;
-}
-
-static int snd_stm_pcm_reader_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This callback may be called more than once... */
-
-	if (pcm_reader->buffer) {
-		/* Dispose buffer */
-
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", pcm_reader->device->bus_id,
-				pcm_reader->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
-
-		iounmap(runtime->dma_area);
-
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
-
-		pcm_reader->buffer = NULL;
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
-
-		/* Dispose FDMA parameters (whole list) */
-		dma_params_free(pcm_reader->fdma_params_list);
-		dma_req_free(pcm_reader->fdma_channel,
-				pcm_reader->fdma_request);
-		kfree(pcm_reader->fdma_params_list);
-	}
-
-	return 0;
-}
-
-static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *hw_params)
-{
-	int result;
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes, period_bytes, periods, frame_bytes, transfer_bytes;
-	unsigned int transfer_size;
-	struct stm_dma_req_config fdma_req_config = {
-		.rw        = REQ_CONFIG_READ,
-		.opcode    = REQ_CONFIG_OPCODE_4,
-		.increment = 0,
-		.hold_off  = 0,
-		.initiator = pcm_reader->info->fdma_initiator,
-	};
-	int i;
-
-	snd_stm_printt("snd_stm_pcm_reader_hw_params(substream=0x%p,"
-			" hw_params=0x%p)\n", substream, hw_params);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This function may be called many times, so let's be prepared... */
-	if (pcm_reader->buffer)
-		snd_stm_pcm_reader_hw_free(substream);
-
-	/* Get the numbers... */
-
-	buffer_bytes = params_buffer_bytes(hw_params);
-	periods = params_periods(hw_params);
-	period_bytes = buffer_bytes / periods;
-	snd_assert(periods * period_bytes == buffer_bytes, return -EINVAL);
-
-	/* Allocate buffer */
-
-	pcm_reader->buffer = bigphysarea_alloc(buffer_bytes);
-	/* TODO: move to BPA2, use pcm lib as fallback... */
-	if (!pcm_reader->buffer) {
-		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, pcm_reader->device->bus_id);
-		result = -ENOMEM;
-		goto error_buf_alloc;
-	}
-
-	runtime->dma_addr = virt_to_phys(pcm_reader->buffer);
-	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
-	runtime->dma_bytes = buffer_bytes;
-
-	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
-			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", pcm_reader->device->bus_id,
-			pcm_reader->buffer, runtime->dma_addr,
-			runtime->dma_area, runtime->dma_bytes);
-
-	/* Set FDMA transfer size (number of opcodes generated
-	 * after request line assertion) */
-
-	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
-			params_channels(hw_params) / 8;
-	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			pcm_reader->info->fdma_max_transfer_size * 4);
-	transfer_size = transfer_bytes / 4;
-
-	snd_stm_printt("FDMA request trigger limit set to %d.\n",
-			transfer_size);
-	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_assert(transfer_size <= pcm_reader->info->fdma_max_transfer_size,
-			return -EINVAL);
-	fdma_req_config.count = transfer_size;
-
-	/* Configure FDMA transfer */
-
-	pcm_reader->fdma_request = dma_req_config(pcm_reader->fdma_channel,
-			pcm_reader->info->fdma_request_line, &fdma_req_config);
-	if (!pcm_reader->fdma_request) {
-		snd_stm_printe("Can't configure FDMA pacing channel for player"
-				" '%s'!\n", pcm_reader->device->bus_id);
-		result = -EINVAL;
-		goto error_req_config;
-	}
-
-	pcm_reader->fdma_params_list =
-			kmalloc(sizeof(*pcm_reader->fdma_params_list) *
-			periods, GFP_KERNEL);
-	if (!pcm_reader->fdma_params_list) {
-		/* TODO: move to BPA2 (see above) */
-		snd_stm_printe("Can't allocate %d bytes for FDMA parameters "
-				"list!\n", sizeof(*pcm_reader->fdma_params_list)
-				* periods);
-		result = -ENOMEM;
-		goto error_params_alloc;
-	}
-
-	snd_stm_printt("Configuring FDMA transfer nodes:\n");
-
-	for (i = 0; i < periods; i++) {
-		dma_params_init(&pcm_reader->fdma_params_list[i], MODE_PACED,
-				STM_DMA_LIST_CIRC);
-
-		if (i > 0)
-			dma_params_link(&pcm_reader->fdma_params_list[i - 1],
-					(&pcm_reader->fdma_params_list[i]));
-
-		dma_params_comp_cb(&pcm_reader->fdma_params_list[i],
-				snd_stm_pcm_reader_callback_node_done,
-				(unsigned long)pcm_reader,
-				STM_DMA_CB_CONTEXT_ISR);
-
-		dma_params_err_cb(&pcm_reader->fdma_params_list[i],
-				snd_stm_pcm_reader_callback_node_error,
-				(unsigned long)pcm_reader,
-				STM_DMA_CB_CONTEXT_ISR);
-
-		/* Get callback every time a node is completed */
-		dma_params_interrupts(&pcm_reader->fdma_params_list[i],
-				STM_DMA_NODE_COMP_INT);
-
-		dma_params_DIM_0_x_1(&pcm_reader->fdma_params_list[i]);
-
-		dma_params_req(&pcm_reader->fdma_params_list[i],
-				pcm_reader->fdma_request);
-
-		snd_stm_printt("- %d: %d bytes from 0x%08x\n", i, period_bytes,
-				runtime->dma_addr + i * period_bytes);
-
-		dma_params_addrs(&pcm_reader->fdma_params_list[i],
-				pcm_reader->fifo_phys_address,
-				runtime->dma_addr + i * period_bytes,
-				period_bytes);
-	}
-
-	result = dma_compile_list(pcm_reader->fdma_channel,
-				pcm_reader->fdma_params_list, GFP_KERNEL);
-	if (result < 0) {
-		snd_stm_printe("Can't compile FDMA parameters for"
-				" reader '%s'!\n", pcm_reader->device->bus_id);
-		goto error_compile_list;
-	}
-
-	return 0;
-
-error_compile_list:
-	dma_req_free(pcm_reader->fdma_channel,
-			pcm_reader->fdma_request);
-error_req_config:
-	iounmap(runtime->dma_area);
-	/* TODO: symmetrical to the above (BPA2 etc.) */
-	bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
-	pcm_reader->buffer = NULL;
-	runtime->dma_area = NULL;
-	runtime->dma_addr = 0;
-	runtime->dma_bytes = 0;
-error_params_alloc:
-	kfree(pcm_reader->fdma_params_list);
-error_buf_alloc:
-	return result;
-}
-
-static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned int format, lr_pol;
-
-	snd_stm_printt("snd_stm_pcm_reader_prepare(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* Get format value from connected converter */
-
-	if (pcm_reader->conv)
-		format = snd_stm_conv_get_format(pcm_reader->conv);
-	else
-		format = DEFAULT_FORMAT;
-
-	/* Number of bits per subframe (which is one channel sample)
-	 * on input. */
-
-	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
-	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
-		snd_stm_printt("- 32 bits per subframe\n");
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 32_BITS);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				DATA_SIZE, 24_BITS);
-		break;
-	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
-		snd_stm_printt("- 16 bits per subframe\n");
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 16_BITS);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				DATA_SIZE, 16_BITS);
-		break;
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Serial audio interface format -
-	 * for detailed explanation see ie.
-	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-			ORDER, MSB_FIRST);
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-			SCLK_EDGE, RISING);
-	switch (format & SND_STM_FORMAT__MASK) {
-	case SND_STM_FORMAT__I2S:
-		snd_stm_printt("- I2S\n");
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				PADDING, 1_CYCLE_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
-		break;
-	case SND_STM_FORMAT__LEFT_JUSTIFIED:
-		snd_stm_printt("- left justified\n");
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				PADDING, NO_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
-		break;
-	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
-		snd_stm_printt("- right justified\n");
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				ALIGN, RIGHT);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				PADDING, NO_DELAY);
-		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
-		break;
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Configure data memory format */
-
-	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
-				MEM_FMT, 16_BITS_16_BITS);
-
-		/* Workaround for a problem with L/R channels swap in case of
-		 * 16/16 memory model: PCM puts left channel data in
-		 * word's upper two bytes, but due to little endianess
-		 * character of our memory it will be interpreted as right
-		 * channel data...  The workaround is to invert L/R signal,
-		 * however it is cheating, because in such case channel
-		 * phases are shifted by one sample...
-		 * (ask me for more details if above is not clear ;-)
-		 * TODO this somehow better... */
-		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, !lr_pol);
-		break;
-
-	case SNDRV_PCM_FORMAT_S32_LE:
-		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
-		 * left than zeros"... ;-) */
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
-				MEM_FMT, 16_BITS_0_BITS);
-
-		/* In x/0 bits memory mode there is no problem with
-		 * L/R polarity */
-		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, lr_pol);
-		break;
-
-	default:
-		snd_BUG();
-		return -EINVAL;
-	}
-
-	/* Number of channels... */
-
-	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
-	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
-			return -EINVAL);
-
-	/* Will be here in 7200 cut 2.0... */
-#if 0
-	REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, NUM_CH,
-			runtime->channels / 2);
-#endif
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_reader_start(struct snd_pcm_substream *substream)
-{
-	int result;
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_reader_start(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	/* Un-reset PCM reader */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RUNNING);
-
-	/* Launch FDMA transfer */
-
-	result = dma_xfer_list(pcm_reader->fdma_channel,
-			pcm_reader->fdma_params_list);
-	if (result != 0) {
-		snd_stm_printe("Can't launch FDMA transfer for reader '%s'!\n",
-				pcm_reader->device->bus_id);
-		return -EINVAL;
-	}
-
-	/* Launch PCM reader */
-
-	pcm_reader->substream = substream;
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, PCM);
-
-	/* Enable reader interrupts */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, VSYNC, SET);
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, OVF, SET);
-
-	/* Wake up & unmute ADC */
-
-	if (pcm_reader->conv) {
-		snd_stm_conv_enable(pcm_reader->conv);
-		snd_stm_conv_unmute(pcm_reader->conv);
-	}
-
-	return 0;
-}
-
-static inline int snd_stm_pcm_reader_stop(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_pcm_reader_stop(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	/* Mute & shutdown DAC */
-
-	if (pcm_reader->conv) {
-		snd_stm_conv_mute(pcm_reader->conv);
-		snd_stm_conv_disable(pcm_reader->conv);
-	}
-
-	/* Disable interrupts */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, VSYNC, CLEAR);
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, OVF, CLEAR);
-
-	/* Stop PCM reader */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, OFF);
-	pcm_reader->substream = NULL;
-
-	/* Stop FDMA transfer */
-
-	dma_stop_channel(pcm_reader->fdma_channel);
-
-	/* Reset PCM reader */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
-
-	return 0;
-}
-
-static int snd_stm_pcm_reader_trigger(struct snd_pcm_substream *substream,
-		int command)
-{
-	snd_stm_printt("snd_stm_pcm_reader_trigger(substream=0x%p,"
-		       "command=%d)\n", substream, command);
-
-	switch (command) {
-	case SNDRV_PCM_TRIGGER_START:
-		return snd_stm_pcm_reader_start(substream);
-	case SNDRV_PCM_TRIGGER_STOP:
-		return snd_stm_pcm_reader_stop(substream);
-	default:
-		return -EINVAL;
-	}
-}
-
-static snd_pcm_uframes_t snd_stm_pcm_reader_pointer(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int residue;
-	snd_pcm_uframes_t pointer;
-
-	snd_stm_printt("snd_stm_pcm_reader_pointer(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	residue = get_dma_residue(pcm_reader->fdma_channel);
-	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
-
-	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
-			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
-			pointer, pointer);
-
-	return pointer;
-}
-
-static struct snd_pcm_ops snd_stm_pcm_reader_pcm_ops = {
-	.open =      snd_stm_pcm_reader_open,
-	.close =     snd_stm_pcm_reader_close,
-	.mmap =      snd_stm_mmap,
-	.ioctl =     snd_pcm_lib_ioctl,
-	.hw_params = snd_stm_pcm_reader_hw_params,
-	.hw_free =   snd_stm_pcm_reader_hw_free,
-	.prepare =   snd_stm_pcm_reader_prepare,
-	.trigger =   snd_stm_pcm_reader_trigger,
-	.pointer =   snd_stm_pcm_reader_pointer,
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-#define DUMP_REGISTER(r) \
-		snd_iprintf(buffer, "AUD_PCMIN_%s (offset 0x%02x) = 0x%08x\n", \
-				__stringify(r), AUD_PCMIN_##r, \
-				REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_##r))
-
-static void snd_stm_pcm_reader_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_pcm_reader *pcm_reader = entry->private_data;
-
-	snd_assert(pcm_reader, return);
-	snd_stm_magic_assert(pcm_reader, return);
-
-	DUMP_REGISTER(RST);
-	DUMP_REGISTER(DATA);
-	DUMP_REGISTER(ITS);
-	DUMP_REGISTER(ITS_CLR);
-	DUMP_REGISTER(IT_EN);
-	DUMP_REGISTER(IT_EN_SET);
-	DUMP_REGISTER(IT_EN_CLR);
-	DUMP_REGISTER(CTRL);
-	DUMP_REGISTER(STA);
-	DUMP_REGISTER(FMT);
-}
-
-static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
-{
-	int result;
-	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_pcm_reader_register(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	/* Set reset mode */
-
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
-
-	/* TODO: well, hardcoded - shall anyone use it?
-	 * And what it actually means? */
-	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, RND, NO_ROUNDING);
-
-	/* Registers view in ALSA's procfs */
-
-	snd_stm_info_register(&pcm_reader->proc_entry,
-			pcm_reader->device->bus_id,
-			snd_stm_pcm_reader_dump_registers, pcm_reader);
-
-	/* Create ALSA controls */
-
-	result = snd_stm_conv_add_route_ctl(pcm_reader->device,
-			snd_device->card, pcm_reader->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add converter route control!\n");
-		return result;
-	}
-
-	return 0;
-}
-
-static int snd_stm_pcm_reader_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_pcm_reader_unregister(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_stm_info_unregister(pcm_reader->proc_entry);
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_pcm_reader_snd_device_ops = {
-	.dev_register = snd_stm_pcm_reader_register,
-	.dev_disconnect = snd_stm_pcm_reader_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_pcm_reader *pcm_reader;
-	struct snd_card *card;
-	int i;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
-	if (!pcm_reader) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(pcm_reader);
-	pcm_reader->info = pdev->dev.platform_data;
-	snd_assert(pcm_reader->info != NULL, return -EINVAL);
-	pcm_reader->device = &pdev->dev;
-
-	/* Get resources */
-
-	result = snd_stm_memory_request(pdev, &pcm_reader->mem_region,
-			&pcm_reader->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-	pcm_reader->fifo_phys_address = pcm_reader->mem_region->start +
-		AUD_PCMIN_DATA;
-	snd_printd("FIFO physical address: 0x%lx.\n",
-			pcm_reader->fifo_phys_address);
-
-	result = snd_stm_irq_request(pdev, &pcm_reader->irq,
-			snd_stm_pcm_reader_irq_handler, pcm_reader);
-	if (result < 0) {
-		snd_stm_printe("IRQ request failed!\n");
-		goto error_irq_request;
-	}
-
-	result = snd_stm_fdma_request(pdev, &pcm_reader->fdma_channel);
-	if (result < 0) {
-		snd_stm_printe("FDMA request failed!\n");
-		goto error_fdma_request;
-	}
-
-	/* Get component capabilities */
-
-	snd_printd("Reader's name is '%s'\n", pcm_reader->info->name);
-
-	card = snd_stm_cards_get(pcm_reader->info->card_id);
-	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Reader will be a member of a card '%s' as a PCM device "
-			"no. %d.\n", card->id, pcm_reader->info->card_device);
-
-	snd_assert(pcm_reader->info->channels != NULL, return -EINVAL);
-	snd_assert(pcm_reader->info->channels_num > 0, return -EINVAL);
-	pcm_reader->channels_constraint.list = pcm_reader->info->channels;
-	pcm_reader->channels_constraint.count = pcm_reader->info->channels_num;
-	pcm_reader->channels_constraint.mask = 0;
-	for (i = 0; i < pcm_reader->info->channels_num; i++)
-		snd_printd("Player capable of playing %u-channels PCM.\n",
-				pcm_reader->info->channels[i]);
-
-	/* Preallocate buffer */
-
-	/* TODO */
-
-	/* Create ALSA lowlevel device */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_reader,
-			&snd_stm_pcm_reader_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Create ALSA PCM device */
-
-	result = snd_pcm_new(card, NULL, pcm_reader->info->card_device, 0, 1,
-		       &pcm_reader->pcm);
-	if (result < 0) {
-		snd_stm_printe("ALSA PCM instance creation failed!\n");
-		goto error_pcm;
-	}
-	pcm_reader->pcm->private_data = pcm_reader;
-	strcpy(pcm_reader->pcm->name, pcm_reader->info->name);
-
-	snd_pcm_set_ops(pcm_reader->pcm, SNDRV_PCM_STREAM_CAPTURE,
-			&snd_stm_pcm_reader_pcm_ops);
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, pcm_reader);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return 0;
-
-error_pcm:
-	snd_device_free(card, pcm_reader);
-error_device:
-	snd_stm_fdma_release(pcm_reader->fdma_channel);
-error_fdma_request:
-	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
-error_irq_request:
-	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
-error_memory_request:
-	snd_stm_magic_clear(pcm_reader);
-	kfree(pcm_reader);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_pcm_reader_remove(struct platform_device *pdev)
-{
-	struct snd_stm_pcm_reader *pcm_reader = platform_get_drvdata(pdev);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
-	snd_stm_fdma_release(pcm_reader->fdma_channel);
-	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
-	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
-
-	snd_stm_magic_clear(pcm_reader);
-	kfree(pcm_reader);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_pcm_reader_driver = {
-	.driver = {
-		.name = "pcm_reader",
-	},
-	.probe = snd_stm_pcm_reader_probe,
-	.remove = snd_stm_pcm_reader_remove,
-};
-
-/*
- * Initialization
- */
-
-int __init snd_stm_pcm_reader_init(void)
-{
-	return platform_driver_register(&snd_stm_pcm_reader_driver);
-}
-
-void snd_stm_pcm_reader_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_pcm_reader_driver);
-}
diff --git a/sound/soc/stm/spdif_player.c b/sound/soc/stm/spdif_player.c
deleted file mode 100644
index 0dcee51..0000000
--- a/sound/soc/stm/spdif_player.c
+++ /dev/null
@@ -1,1678 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' SPDIF player driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/bpa2.h>
-#include <asm/cacheflush.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/stm-dma.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/control.h>
-#include <sound/info.h>
-#include <sound/asoundef.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 8 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Some hardware-related definitions
- */
-
-#define DEFAULT_OVERSAMPLING 128
-
-/* The sample count field (MEMREAD in CTRL register) is 17 bits wide */
-#define MAX_SAMPLES_PER_PERIOD ((1 << 17) - 1)
-
-#define PREAMBLE_BYTES 8
-
-
-/*
- * SPDIF player instance definition
- */
-
-enum snd_stm_spdif_player_input_mode {
-	SNDRV_STM_SPDIF_INPUT_MODE_NORMAL,
-	SNDRV_STM_SPDIF_INPUT_MODE_RAW
-};
-
-enum snd_stm_spdif_player_encoding_mode {
-	SNDRV_STM_SPDIF_ENCODING_MODE_PCM,
-	SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED
-};
-
-struct snd_stm_spdif_player_settings {
-	enum snd_stm_spdif_player_input_mode input_mode;
-	enum snd_stm_spdif_player_encoding_mode encoding_mode;
-	struct snd_aes_iec958 iec958;
-	unsigned char iec61937_preamble[PREAMBLE_BYTES]; /* Used in */
-	unsigned int iec61937_audio_repetition;          /* encoded */
-	unsigned int iec61937_pause_repetition;          /* mode */
-};
-
-struct snd_stm_spdif_player {
-	/* System informations */
-	struct snd_stm_spdif_player_info *info;
-	struct device *device;
-	struct snd_pcm *pcm;
-
-	/* Resources */
-	struct resource *mem_region;
-	void *base;
-	unsigned long fifo_phys_address;
-	unsigned int irq;
-	unsigned int fdma_channel;
-
-	/* Environment settings */
-	struct device *fsynth_device;
-	int fsynth_channel;
-	struct snd_stm_conv *conv;
-
-	/* Default settings (controlled by controls ;-) */
-	struct snd_stm_spdif_player_settings default_settings;
-	spinlock_t default_settings_lock; /* Protects default_settings */
-
-	/* Runtime data */
-	void *buffer;
-	struct snd_info_entry *proc_entry;
-	struct snd_pcm_substream *substream;
-	struct stm_dma_params fdma_params;
-	struct stm_dma_req *fdma_request;
-	struct snd_stm_spdif_player_settings stream_settings;
-	int stream_iec958_status_cnt;
-	int stream_iec958_subcode_cnt;
-
-	snd_stm_magic_field;
-};
-
-
-
-/*
- * Playing engine implementation
- */
-
-static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
-{
-	irqreturn_t result = IRQ_NONE;
-	struct snd_stm_spdif_player *spdif_player = dev_id;
-	unsigned int status;
-
-	snd_stm_printt("snd_stm_spdif_player_irq_handler(irq=%d, "
-			"dev_id=0x%p)\n", irq, dev_id);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* Get interrupt status & clear them immediately */
-	preempt_disable();
-	status = REGISTER_PEEK(spdif_player->base, AUD_SPDIF_ITS);
-	REGISTER_POKE(spdif_player->base, AUD_SPDIF_ITS_CLR, status);
-	preempt_enable();
-
-	/* Underflow? */
-	if (unlikely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, UNF, PENDING))) {
-		snd_stm_printe("Underflow detected in SPDIF player '%s'!\n",
-				spdif_player->device->bus_id);
-		result = IRQ_HANDLED;
-	}
-
-	/* Period successfully played */
-	if (likely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, NSAMPLE, PENDING)))
-		do {
-			snd_assert(spdif_player->substream, break);
-
-			snd_stm_printt("Period elapsed ('%s')\n",
-					spdif_player->device->bus_id);
-			snd_pcm_period_elapsed(spdif_player->substream);
-
-			result = IRQ_HANDLED;
-		} while (0);
-
-	/* Some alien interrupt??? */
-	snd_assert(result == IRQ_HANDLED);
-
-	return result;
-}
-
-/* In normal mode we are preparing SPDIF formating "manually".
- * It means:
- * 1. A lot of parsing...
- * 2. MMAPing is impossible...
- * 3. We can handle some other formats! */
-static struct snd_pcm_hardware snd_stm_spdif_player_hw_normal = {
-	.info		= (SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				SNDRV_PCM_INFO_PAUSE),
-	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
-				SNDRV_PCM_FMTBIT_S24_LE),
-
-	.rates		= (SNDRV_PCM_RATE_32000 |
-				SNDRV_PCM_RATE_44100 |
-				SNDRV_PCM_RATE_48000 |
-				SNDRV_PCM_RATE_64000 |
-				SNDRV_PCM_RATE_88200 |
-				SNDRV_PCM_RATE_96000 |
-				SNDRV_PCM_RATE_176400 |
-				SNDRV_PCM_RATE_192000),
-	.rate_min	= 32000,
-	.rate_max	= 192000,
-
-	.channels_min	= 2,
-	.channels_max	= 2,
-
-	.periods_min	= 2,
-	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
-
-	/* Values below were worked out mostly basing on ST media player
-	 * requirements. They should, however, fit most "normal" cases...
-	 * Note 1: that these value must be also calculated not to exceed
-	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
-	 * Note 2: period_bytes_min defines minimum time between period
-	 * (NSAMPLE) interrupts... Keep it large enough not to kill
-	 * the system... */
-	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
-	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
-	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
-};
-
-/* In raw mode SPDIF formatting must be prepared by user. Every sample
- * (one channel) is a 32 bits word containing up to 24 bits of data
- * and 4 SPDIF control bits: V(alidty flag), U(ser data), C(hannel status),
- * P(arity bit):
- *
- *      +---------------+---------------+---------------+---------------+
- *      |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
- * bit: |1|0|9|8|6|7|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
- *      +---------------+---------------+---------------+-------+-------+
- *      |M                                             L|       |       |
- *      |S          sample data (up to 24 bits)        S|0|0|0|0|V|U|C|0|
- *      |B                                             B|       |       |
- *      +-----------------------------------------------+-------+-------+
- *
- * SPDIF player sends subframe's sync preamble first (thanks at least
- * for this ;-)), than data starting from LSB (so samples smaller than
- * 24 bits should be aligned to MSB and have zeros as LSBs), than VUC bits
- * and finally adds a parity bit (thanks again ;-).
- */
-static struct snd_pcm_hardware snd_stm_spdif_player_hw_raw = {
-	.info		= (SNDRV_PCM_INFO_MMAP |
-				SNDRV_PCM_INFO_MMAP_VALID |
-				SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				SNDRV_PCM_INFO_PAUSE),
-	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
-
-	.rates		= (SNDRV_PCM_RATE_32000 |
-				SNDRV_PCM_RATE_44100 |
-				SNDRV_PCM_RATE_48000 |
-				SNDRV_PCM_RATE_64000 |
-				SNDRV_PCM_RATE_88200 |
-				SNDRV_PCM_RATE_96000 |
-				SNDRV_PCM_RATE_176400 |
-				SNDRV_PCM_RATE_192000),
-	.rate_min	= 32000,
-	.rate_max	= 192000,
-
-	.channels_min	= 2,
-	.channels_max	= 2,
-
-	.periods_min	= 2,
-	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
-
-	/* See above... */
-	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
-	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
-	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
-};
-
-static int snd_stm_spdif_player_open(struct snd_pcm_substream *substream)
-{
-	int result;
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_spdif_player_open(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	snd_pcm_set_sync(substream);  /* TODO: ??? */
-
-	/* Get attached converter handle */
-
-	spdif_player->conv = snd_stm_conv_get_attached(spdif_player->device);
-	if (spdif_player->conv)
-		snd_printd("Converter '%s' attached to '%s'...\n",
-				spdif_player->conv->name,
-				spdif_player->device->bus_id);
-	else
-		snd_printd("Warning! No converter attached to '%s'!\n",
-				spdif_player->device->bus_id);
-
-	/* Get default data */
-
-	spin_lock(&spdif_player->default_settings_lock);
-	spdif_player->stream_settings = spdif_player->default_settings;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	/* Set up constraints & pass hardware capabilities info to ALSA */
-
-	/* It is better when buffer size is an integer multiple of period
-	 * size... Such thing will ensure this :-O */
-	result = snd_pcm_hw_constraint_integer(runtime,
-			SNDRV_PCM_HW_PARAM_PERIODS);
-	if (result < 0) {
-		snd_stm_printe("Can't set periods constraint!\n");
-		return result;
-	}
-
-	/* Make the period (so buffer as well) length (in bytes) a multiply
-	 * of a FDMA transfer bytes (which varies depending on channels
-	 * number and sample bytes) */
-	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			spdif_player->info->fdma_max_transfer_size * 4);
-	if (result < 0) {
-		snd_stm_printe("Can't set buffer bytes constraint!\n");
-		return result;
-	}
-
-	if (spdif_player->stream_settings.input_mode ==
-			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL)
-		runtime->hw = snd_stm_spdif_player_hw_normal;
-	else
-		runtime->hw = snd_stm_spdif_player_hw_raw;
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_close(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_spdif_player_close(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_spdif_player_hw_free(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This callback may be called more than once... */
-
-	if (spdif_player->buffer) {
-		/* Dispose buffer */
-
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", spdif_player->device->bus_id,
-				spdif_player->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
-
-		iounmap(runtime->dma_area);
-
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
-
-		spdif_player->buffer = NULL;
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
-
-		/* Dispose FDMA parameters */
-
-		dma_params_free(&spdif_player->fdma_params);
-		dma_req_free(spdif_player->fdma_channel,
-				spdif_player->fdma_request);
-	}
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *hw_params)
-{
-	int result;
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes, frame_bytes, transfer_bytes;
-	unsigned int transfer_size;
-	struct stm_dma_req_config fdma_req_config = {
-		.rw        = REQ_CONFIG_WRITE,
-		.opcode    = REQ_CONFIG_OPCODE_4,
-		.increment = 0,
-		.hold_off  = 0,
-		.initiator = spdif_player->info->fdma_initiator,
-	};
-
-	snd_stm_printt("snd_stm_spdif_player_hw_params(substream=0x%p,"
-			" hw_params=0x%p)\n", substream, hw_params);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	/* This function may be called many times, so let's be prepared... */
-	if (spdif_player->buffer)
-		snd_stm_spdif_player_hw_free(substream);
-
-	/* Allocate buffer */
-
-	buffer_bytes = params_buffer_bytes(hw_params);
-	spdif_player->buffer = bigphysarea_alloc(buffer_bytes);
-	/* TODO: move to BPA2, use pcm lib as fallback... */
-	if (!spdif_player->buffer) {
-		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, spdif_player->device->bus_id);
-		result = -ENOMEM;
-		goto error_buf_alloc;
-	}
-
-	runtime->dma_addr = virt_to_phys(spdif_player->buffer);
-	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
-	runtime->dma_bytes = buffer_bytes;
-
-	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
-			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", spdif_player->device->bus_id,
-			spdif_player->buffer, runtime->dma_addr,
-			runtime->dma_area, runtime->dma_bytes);
-
-	/* Set FDMA transfer size (number of opcodes generated
-	 * after request line assertion) */
-
-	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
-			params_channels(hw_params) / 8;
-	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			spdif_player->info->fdma_max_transfer_size * 4);
-	transfer_size = transfer_bytes / 4;
-	snd_stm_printt("FDMA request trigger limit and transfer size set to "
-			"%d.\n", transfer_size);
-
-	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_assert(transfer_size <= spdif_player->info->fdma_max_transfer_size,
-			return -EINVAL);
-	fdma_req_config.count = transfer_size;
-
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
-			return -EINVAL);
-	snd_assert(transfer_size <= AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK,
-			return -EINVAL);
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CONFIG,
-			DMA_REQ_TRIG_LMT, transfer_size);
-#endif
-
-	/* Configure FDMA transfer */
-
-	/* TODO: try to use SPDIF FMDA channel */
-
-	spdif_player->fdma_request = dma_req_config(spdif_player->fdma_channel,
-			spdif_player->info->fdma_request_line,
-			&fdma_req_config);
-	if (!spdif_player->fdma_request) {
-		snd_stm_printe("Can't configure FDMA pacing channel for player"
-				" '%s'!\n", spdif_player->device->bus_id);
-		result = -EINVAL;
-		goto error_req_config;
-	}
-
-	dma_params_init(&spdif_player->fdma_params, MODE_PACED,
-			STM_DMA_LIST_CIRC);
-
-	dma_params_DIM_1_x_0(&spdif_player->fdma_params);
-
-	dma_params_req(&spdif_player->fdma_params, spdif_player->fdma_request);
-
-	dma_params_addrs(&spdif_player->fdma_params, runtime->dma_addr,
-			spdif_player->fifo_phys_address, buffer_bytes);
-
-	result = dma_compile_list(spdif_player->fdma_channel,
-				&spdif_player->fdma_params, GFP_KERNEL);
-	if (result < 0) {
-		snd_stm_printe("Can't compile FDMA parameters for player"
-				" '%s'!\n", spdif_player->device->bus_id);
-		goto error_compile_list;
-	}
-
-	return 0;
-
-error_compile_list:
-	dma_req_free(spdif_player->fdma_channel,
-			spdif_player->fdma_request);
-error_req_config:
-	iounmap(runtime->dma_area);
-	/* TODO: symmetrical to the above (BPA2 etc.) */
-	bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
-	spdif_player->buffer = NULL;
-	runtime->dma_area = NULL;
-	runtime->dma_addr = 0;
-	runtime->dma_bytes = 0;
-error_buf_alloc:
-	return result;
-}
-
-static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int oversampling;
-	unsigned long status;
-	struct snd_aes_iec958 *iec958;
-
-	snd_stm_printt("snd_stm_spdif_player_prepare(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(runtime->period_size * runtime->channels <
-			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
-
-	/* Configure SPDIF-PCM synchronisation */
-
-	/* TODO */
-
-	/* Get oversampling value from connected converter */
-
-	if (spdif_player->conv) {
-		unsigned int format =
-				snd_stm_conv_get_format(spdif_player->conv);
-
-		snd_assert((format & SND_STM_FORMAT__MASK) ==
-				SND_STM_FORMAT__SPDIF, return -EINVAL);
-
-		oversampling = snd_stm_conv_get_oversampling(
-				spdif_player->conv);
-		if (oversampling == 0)
-			oversampling = DEFAULT_OVERSAMPLING;
-	} else {
-		oversampling = DEFAULT_OVERSAMPLING;
-	}
-
-	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
-			spdif_player->device->bus_id, runtime->rate,
-			oversampling);
-
-	snd_assert(oversampling > 0, return -EINVAL);
-
-	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
-	 * so oversampling must be multiple of 128... */
-	snd_assert(oversampling % 128 == 0, return -EINVAL);
-
-	/* Set up frequency synthesizer */
-
-	snd_stm_fsynth_set_frequency(spdif_player->fsynth_device,
-			spdif_player->fsynth_channel,
-			runtime->rate * oversampling);
-
-	/* Configure SPDIF player frequency divider
-	 *
-	 *                        Fdacclk
-	 * divider = ------------------------------- =
-	 *            2 * Fs * bits_in_output_frame
-	 *
-	 *            Fs * oversampling     oversampling
-	 *         = ------------------- = --------------
-	 *            2 * Fs * (32 * 2)         128
-	 * where:
-	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
-	 *               MCLK (master clock), "system clock" etc.
-	 *   - Fs - sampling rate (frequency)
-	 */
-
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, CLK_DIV,
-			oversampling / 128);
-
-	/* Configure NSAMPLE interrupt (in samples,
-	 * so period size times channels) */
-
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, MEMREAD,
-			runtime->period_size * 2);
-
-	/* Reset IEC958 software formatting counters */
-
-	spdif_player->stream_iec958_status_cnt = 0;
-	spdif_player->stream_iec958_subcode_cnt = 0;
-
-	/* Set VUC register settings */
-
-	/* Channel status */
-	iec958 = &spdif_player->stream_settings.iec958;
-	status = iec958->status[0] | iec958->status[1] << 8 |
-		iec958->status[2] << 16 | iec958->status[3] << 24;
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL1,
-			CL1, status);
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
-			CL2, iec958->status[4] & 0xf);
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CR1,
-			CR1, status);
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
-			CR2, iec958->status[4] & 0xf);
-
-	/* User data - well, can't do too much here... */
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LU, 0);
-	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RU, 0);
-
-	if (spdif_player->stream_settings.encoding_mode ==
-			SNDRV_STM_SPDIF_ENCODING_MODE_PCM) {
-		/* Linear PCM: validity bit are zeroed */
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 0);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 0);
-	} else {
-		struct snd_stm_spdif_player_settings *settings =
-				&spdif_player->stream_settings;
-
-		/* Encoded mode: validity bits are one */
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 1);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 1);
-
-		/* Number of frames is data/pause bursts */
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, DBURST,
-				settings->iec61937_audio_repetition);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, PDBURST,
-				settings->iec61937_pause_repetition);
-
-		/* IEC61937 Preamble */
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PA,
-				settings->iec61937_preamble[0] |
-				settings->iec61937_preamble[1] << 8);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PB,
-				settings->iec61937_preamble[2] |
-				settings->iec61937_preamble[3] << 8);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PC,
-				settings->iec61937_preamble[4] |
-				settings->iec61937_preamble[5] << 8);
-		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PD,
-				settings->iec61937_preamble[6] |
-				settings->iec61937_preamble[7] << 8);
-
-		/* TODO: set AUD_SPDIF_PAU_LAT NPD_BURST somehow... */
-	}
-
-	return 0;
-}
-
-static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
-		*substream)
-{
-	int result;
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_spdif_player_start(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* Un-reset SPDIF player */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RUNNING);
-
-	/* Launch FDMA transfer */
-
-	result = dma_xfer_list(spdif_player->fdma_channel,
-			&spdif_player->fdma_params);
-	if (result != 0) {
-		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
-				spdif_player->device->bus_id);
-		return -EINVAL;
-	}
-
-	/* Launch SPDIF player */
-
-	spdif_player->substream = substream;
-
-	if (spdif_player->stream_settings.encoding_mode ==
-			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
-	else
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
-
-	/* Enable player interrupts */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, NSAMPLE, SET);
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, UNF, SET);
-
-	/* Wake up & unmute converter */
-
-	if (spdif_player->conv) {
-		snd_stm_conv_enable(spdif_player->conv);
-		snd_stm_conv_unmute(spdif_player->conv);
-	}
-
-	return 0;
-}
-
-static inline int snd_stm_spdif_player_stop(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_spdif_player_stop(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* Mute & shutdown converter */
-
-	if (spdif_player->conv) {
-		snd_stm_conv_mute(spdif_player->conv);
-		snd_stm_conv_disable(spdif_player->conv);
-	}
-
-	/* Disable interrupts */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, NSAMPLE, CLEAR);
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, UNF, CLEAR);
-
-	/* Stop SPDIF player */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, OFF);
-	spdif_player->substream = NULL;
-
-	/* Stop FDMA transfer */
-
-	dma_stop_channel(spdif_player->fdma_channel);
-
-	/* Reset SPDIF player */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
-
-	return 0;
-}
-
-static inline int snd_stm_spdif_player_pause(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_spdif_player_pause(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* "Mute" player
-	 * Documentation describes this mode in a wrong way - data is _not_
-	 * consumed in the "mute" mode, so it is actually a "pause" mode */
-
-	if (spdif_player->stream_settings.encoding_mode ==
-			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
-				MUTE_PCM_NULL);
-	else
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
-				MUTE_PAUSE_BURSTS);
-
-	return 0;
-}
-
-static inline int snd_stm_spdif_player_release(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-		snd_pcm_substream_chip(substream);
-
-	snd_stm_printt("snd_stm_spdif_player_release(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* "Unmute" player */
-
-	if (spdif_player->stream_settings.encoding_mode ==
-			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
-	else
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_trigger(struct snd_pcm_substream *substream,
-		int command)
-{
-	snd_stm_printt("snd_stm_spdif_player_trigger(substream=0x%p,"
-			" command=%d)\n", substream, command);
-
-	switch (command) {
-	case SNDRV_PCM_TRIGGER_START:
-		return snd_stm_spdif_player_start(substream);
-	case SNDRV_PCM_TRIGGER_STOP:
-		return snd_stm_spdif_player_stop(substream);
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		return snd_stm_spdif_player_pause(substream);
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		return snd_stm_spdif_player_release(substream);
-	default:
-		return -EINVAL;
-	}
-}
-
-static snd_pcm_uframes_t snd_stm_spdif_player_pointer(struct snd_pcm_substream
-		*substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-		snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int residue;
-	snd_pcm_uframes_t pointer;
-
-	snd_stm_printt("snd_stm_spdif_player_pointer(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-
-	residue = get_dma_residue(spdif_player->fdma_channel);
-	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
-
-	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
-			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
-			pointer, pointer);
-
-	return pointer;
-}
-
-#define VUC_MASK 0xf
-#define V_BIT (1 << 3)
-#define U_BIT (1 << 2)
-#define C_BIT (1 << 1)
-
-#define GET_SAMPLE(kernel_var, user_ptr, memory_format) \
-	do { \
-		__get_user(kernel_var, (memory_format __user *)user_ptr); \
-		(*((memory_format __user **)&user_ptr))++; \
-	} while (0);
-
-static void snd_stm_spdif_player_format_frame(struct snd_stm_spdif_player
-		*spdif_player, unsigned long *left_subframe,
-		unsigned long *right_subframe)
-{
-	unsigned char data;
-
-	snd_assert(spdif_player, return);
-	snd_stm_magic_assert(spdif_player, return);
-
-	/* Clean VUC bits */
-	*left_subframe &= ~VUC_MASK;
-	*right_subframe &= ~VUC_MASK;
-
-	/* Validity bit should be set to one when non-PCM data are
-	 * transmitted... */
-	if (spdif_player->stream_settings.encoding_mode) {
-		*left_subframe |= V_BIT;
-		*right_subframe |= V_BIT;
-	}
-
-	/* User data consists of both subframe U-bits */
-	data = spdif_player->stream_settings.iec958.subcode[
-			spdif_player->stream_iec958_subcode_cnt / 8];
-	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
-		*left_subframe |= U_BIT;
-	spdif_player->stream_iec958_subcode_cnt++;
-	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
-		*right_subframe |= U_BIT;
-	spdif_player->stream_iec958_subcode_cnt =
-			(spdif_player->stream_iec958_subcode_cnt + 1) % 1176;
-
-	/* Channel status bit shall be the same for both subframes
-	 * (except channel number field, which we ignore.) */
-	data = spdif_player->stream_settings.iec958.status[
-			spdif_player->stream_iec958_status_cnt / 8];
-	if (data & (1 << (spdif_player->stream_iec958_status_cnt % 8))) {
-		*left_subframe |= C_BIT;
-		*right_subframe |= C_BIT;
-	}
-	spdif_player->stream_iec958_status_cnt =
-			(spdif_player->stream_iec958_status_cnt + 1) % 192;
-}
-
-static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
-		int channel, snd_pcm_uframes_t pos,
-		void __user *src, snd_pcm_uframes_t count)
-{
-	struct snd_stm_spdif_player *spdif_player =
-		snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_spdif_player_copy(substream=0x%p, channel=%d,"
-			" pos=%lu, buf=0x%p, count=%lu)\n", substream,
-			channel, pos, src, count);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
-
-	if (spdif_player->stream_settings.input_mode ==
-			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
-		unsigned long *dest = (unsigned long *)(runtime->dma_area +
-				frames_to_bytes(runtime, pos));
-		int i;
-
-		if (!access_ok(VERIFY_READ, src, frames_to_bytes(runtime,
-						count)))
-			return -EFAULT;
-
-		snd_stm_printt("Formatting SPDIF frame (format=%d)\n",
-				runtime->format);
-
-#if 0
-		{
-			unsigned char data[64];
-
-			copy_from_user(data, src, 64);
-
-			snd_stm_printt("Input:\n");
-			snd_stm_hex_dump(data, 64);
-		}
-#endif
-
-		for (i = 0; i < count; i++) {
-			unsigned long left_subframe, right_subframe;
-
-			switch (runtime->format) {
-			case SNDRV_PCM_FORMAT_S32_LE:
-				GET_SAMPLE(left_subframe, src, u32);
-				GET_SAMPLE(right_subframe, src, u32);
-				break;
-			case SNDRV_PCM_FORMAT_S24_LE:
-				/* 24-bits sample are in lower 3 bytes,
-				 * while we want them in upper 3... ;-) */
-				GET_SAMPLE(left_subframe, src, u32);
-				left_subframe <<= 8;
-				GET_SAMPLE(right_subframe, src, u32);
-				right_subframe <<= 8;
-				break;
-			default:
-				snd_BUG();
-				return -EINVAL;
-			}
-
-			snd_stm_spdif_player_format_frame(spdif_player,
-					&left_subframe, &right_subframe);
-
-			*(dest++) = left_subframe;
-			*(dest++) = right_subframe;
-		}
-
-#if 0
-		snd_stm_printt("Output:\n");
-		snd_stm_hex_dump(runtime->dma_area +
-				frames_to_bytes(runtime, pos), 64);
-#endif
-	} else {
-		/* RAW mode */
-		if (copy_from_user(runtime->dma_area +
-				frames_to_bytes(runtime, pos), src,
-				frames_to_bytes(runtime, count)) != 0)
-			return -EFAULT;
-	}
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_silence(struct snd_pcm_substream *substream,
-		int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
-{
-	int result = 0;
-	struct snd_stm_spdif_player *spdif_player =
-		snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_spdif_player_silence(substream=0x%p, "
-			"channel=%d, pos=%lu, count=%lu)\n",
-			substream, channel, pos, count);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
-
-	if (spdif_player->stream_settings.input_mode ==
-			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
-		unsigned long *buffer = (unsigned long *)(runtime->dma_area +
-				frames_to_bytes(runtime, pos));
-		unsigned long left_subframe = 0;
-		unsigned long right_subframe = 0;
-		int i;
-
-		for (i = 0; i < count; i++) {
-			snd_stm_spdif_player_format_frame(spdif_player,
-					&left_subframe, &right_subframe);
-			*(buffer++) = left_subframe;
-			*(buffer++) = right_subframe;
-		}
-	} else {
-		/* RAW mode */
-		result = snd_pcm_format_set_silence(runtime->format,
-				runtime->dma_area +
-				frames_to_bytes(runtime, pos),
-				runtime->channels * count);
-	}
-
-	return result;
-}
-
-static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
-	.open =      snd_stm_spdif_player_open,
-	.close =     snd_stm_spdif_player_close,
-	.mmap =      snd_stm_mmap,
-	.ioctl =     snd_pcm_lib_ioctl,
-	.hw_params = snd_stm_spdif_player_hw_params,
-	.hw_free =   snd_stm_spdif_player_hw_free,
-	.prepare =   snd_stm_spdif_player_prepare,
-	.trigger =   snd_stm_spdif_player_trigger,
-	.pointer =   snd_stm_spdif_player_pointer,
-	.copy =      snd_stm_spdif_player_copy,
-	.silence =   snd_stm_spdif_player_silence,
-};
-
-
-
-/*
- * ALSA controls
- */
-
-static int snd_stm_spdif_player_ctl_default_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_default_get("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	ucontrol->value.iec958 = spdif_player->default_settings.iec958;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_default_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_default_put("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	if (snd_stm_iec958_cmp(&spdif_player->default_settings.iec958,
-				&ucontrol->value.iec958) != 0) {
-		spdif_player->default_settings.iec958 = ucontrol->value.iec958;
-		changed = 1;
-	}
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-/* "Raw Data" switch controls data input mode - "RAW" means that played
- * data are already properly formated (VUC bits); in "normal" mode
- * this data will be added by driver according to setting passed in\
- * following controls */
-
-static int snd_stm_spdif_player_ctl_raw_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	ucontrol->value.integer.value[0] =
-			(spdif_player->default_settings.input_mode ==
-			SNDRV_STM_SPDIF_INPUT_MODE_RAW);
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_raw_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-	enum snd_stm_spdif_player_input_mode input_mode;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	if (ucontrol->value.integer.value[0])
-		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_RAW;
-	else
-		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_NORMAL;
-
-	spin_lock(&spdif_player->default_settings_lock);
-	changed = (input_mode != spdif_player->default_settings.input_mode);
-	spdif_player->default_settings.input_mode = input_mode;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-/* "Encoded Data" switch selects linear PCM or encoded operation of
- * SPDIF player - the difference is in generating mute data; PCM mode
- * will generate NULL data, encoded - pause bursts */
-
-static int snd_stm_spdif_player_ctl_encoded_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	ucontrol->value.integer.value[0] =
-			(spdif_player->default_settings.encoding_mode ==
-			SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED);
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_encoded_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-	enum snd_stm_spdif_player_encoding_mode encoding_mode;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	if (ucontrol->value.integer.value[0])
-		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED;
-	else
-		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_PCM;
-
-	spin_lock(&spdif_player->default_settings_lock);
-	changed = (encoding_mode !=
-			spdif_player->default_settings.encoding_mode);
-	spdif_player->default_settings.encoding_mode = encoding_mode;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-/* Three following controls are valid for encoded mode only - they
- * control IEC 61937 preamble and data burst periods (see mentioned
- * standard for more informations) */
-
-static int snd_stm_spdif_player_ctl_preamble_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = PREAMBLE_BYTES;
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_preamble_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	memcpy(ucontrol->value.bytes.data,
-			spdif_player->default_settings.iec61937_preamble,
-			PREAMBLE_BYTES);
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_preamble_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	if (memcmp(spdif_player->default_settings.iec61937_preamble,
-			ucontrol->value.bytes.data, PREAMBLE_BYTES) != 0) {
-		changed = 1;
-		memcpy(spdif_player->default_settings.iec61937_preamble,
-				ucontrol->value.bytes.data, PREAMBLE_BYTES);
-	}
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-static int snd_stm_spdif_player_ctl_repetition_info(struct snd_kcontrol
-		*kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 0xffff;
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_audio_repetition_get(struct snd_kcontrol
-		*kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_get("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	ucontrol->value.integer.value[0] =
-		spdif_player->default_settings.iec61937_audio_repetition;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_audio_repetition_put(struct snd_kcontrol
-		*kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_put("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	if (spdif_player->default_settings.iec61937_audio_repetition !=
-			ucontrol->value.integer.value[0]) {
-		changed = 1;
-		spdif_player->default_settings.iec61937_audio_repetition =
-				ucontrol->value.integer.value[0];
-	}
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-static int snd_stm_spdif_player_ctl_pause_repetition_get(struct snd_kcontrol
-		*kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_get("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	ucontrol->value.integer.value[0] =
-		spdif_player->default_settings.iec61937_pause_repetition;
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_ctl_pause_repetition_put(struct snd_kcontrol
-		*kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
-	int changed = 0;
-
-	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_put("
-			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	spin_lock(&spdif_player->default_settings_lock);
-	if (spdif_player->default_settings.iec61937_pause_repetition !=
-			ucontrol->value.integer.value[0]) {
-		changed = 1;
-		spdif_player->default_settings.iec61937_pause_repetition =
-				ucontrol->value.integer.value[0];
-	}
-	spin_unlock(&spdif_player->default_settings_lock);
-
-	return changed;
-}
-
-static struct snd_kcontrol_new __initdata snd_stm_spdif_player_ctls[] = {
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
-		.info = snd_stm_ctl_iec958_info,
-		.get = snd_stm_spdif_player_ctl_default_get,
-		.put = snd_stm_spdif_player_ctl_default_put,
-	}, {
-		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
-		.info =	snd_stm_ctl_iec958_info,
-		.get = snd_stm_ctl_iec958_mask_get_con,
-	}, {
-		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
-		.info =	snd_stm_ctl_iec958_info,
-		.get = snd_stm_ctl_iec958_mask_get_pro,
-	}, {
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("Raw Data ", PLAYBACK, DEFAULT),
-		.info = snd_stm_ctl_boolean_info,
-		.get = snd_stm_spdif_player_ctl_raw_get,
-		.put = snd_stm_spdif_player_ctl_raw_put,
-	}, {
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("Encoded Data ",
-				PLAYBACK, DEFAULT),
-		.info = snd_stm_ctl_boolean_info,
-		.get = snd_stm_spdif_player_ctl_encoded_get,
-		.put = snd_stm_spdif_player_ctl_encoded_put,
-	}, {
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("Preamble ", PLAYBACK, DEFAULT),
-		.info = snd_stm_spdif_player_ctl_preamble_info,
-		.get = snd_stm_spdif_player_ctl_preamble_get,
-		.put = snd_stm_spdif_player_ctl_preamble_put,
-	}, {
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("Audio Burst Period ",
-				PLAYBACK, DEFAULT),
-		.info = snd_stm_spdif_player_ctl_repetition_info,
-		.get = snd_stm_spdif_player_ctl_audio_repetition_get,
-		.put = snd_stm_spdif_player_ctl_audio_repetition_put,
-	}, {
-		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-		.name = SNDRV_CTL_NAME_IEC958("Pause Burst Period ",
-				PLAYBACK, DEFAULT),
-		.info = snd_stm_spdif_player_ctl_repetition_info,
-		.get = snd_stm_spdif_player_ctl_pause_repetition_get,
-		.put = snd_stm_spdif_player_ctl_pause_repetition_put,
-	}
-};
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-#define DUMP_REGISTER(r) \
-		snd_iprintf(buffer, "AUD_SPDIF_%s (offset 0x%02x) =" \
-				" 0x%08x\n", __stringify(r), \
-				AUD_SPDIF_##r, \
-				REGISTER_PEEK(spdif_player->base, \
-				AUD_SPDIF_##r))
-
-static void snd_stm_spdif_player_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_spdif_player *spdif_player = entry->private_data;
-
-	snd_assert(spdif_player, return);
-	snd_stm_magic_assert(spdif_player, return);
-
-	DUMP_REGISTER(RST);
-	DUMP_REGISTER(DATA);
-	DUMP_REGISTER(ITS);
-	DUMP_REGISTER(ITS_CLR);
-	DUMP_REGISTER(IT_EN);
-	DUMP_REGISTER(IT_EN_SET);
-	DUMP_REGISTER(IT_EN_CLR);
-	DUMP_REGISTER(CTRL);
-	DUMP_REGISTER(STA);
-	DUMP_REGISTER(PA_PB);
-	DUMP_REGISTER(PC_PD);
-	DUMP_REGISTER(CL1);
-	DUMP_REGISTER(CR1);
-	DUMP_REGISTER(CL2_CR2_UV);
-	DUMP_REGISTER(PAU_LAT);
-	DUMP_REGISTER(BST_FL);
-#if defined(CONFIG_CPU_SUBTYPE_STX7111)
-	DUMP_REGISTER(CONFIG);
-#endif
-}
-
-static int snd_stm_spdif_player_register(struct snd_device *snd_device)
-{
-	int result;
-	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_spdif_player_register(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	/* Initialize hardware (format etc.) */
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
-
-	/* TODO: well, hardcoded - shall anyone use it?
-	 * And what it actually means? */
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, RND, NO_ROUNDING);
-
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
-
-	/* Hardware stuffing is not implemented yet... */
-	/* TODO: oh, is that so? */
-	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, STUFFING, SOFTWARE);
-
-	/* Registers view in ALSA's procfs */
-
-	snd_stm_info_register(&spdif_player->proc_entry,
-			spdif_player->device->bus_id,
-			snd_stm_spdif_player_dump_registers, spdif_player);
-
-	/* Create ALSA controls */
-
-	result = snd_stm_conv_add_route_ctl(spdif_player->device,
-			snd_device->card, spdif_player->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add converter route control!\n");
-		return result;
-	}
-
-	result = snd_stm_fsynth_add_adjustement_ctl(spdif_player->fsynth_device,
-			spdif_player->fsynth_channel,
-			snd_device->card, spdif_player->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add fsynth adjustment control!\n");
-		return result;
-	}
-
-	return 0;
-}
-
-static int snd_stm_spdif_player_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
-
-	snd_stm_printt("snd_stm_spdif_player_unregister(snd_device=0x%p)\n",
-			snd_device);
-
-	snd_stm_info_unregister(spdif_player->proc_entry);
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_spdif_player_snd_device_ops = {
-	.dev_register = snd_stm_spdif_player_register,
-	.dev_disconnect = snd_stm_spdif_player_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_spdif_player *spdif_player;
-	struct snd_card *card;
-	int i;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
-	if (!spdif_player) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(spdif_player);
-	spdif_player->info = pdev->dev.platform_data;
-	snd_assert(spdif_player->info != NULL, return -EINVAL);
-	spdif_player->device = &pdev->dev;
-
-	spin_lock_init(&spdif_player->default_settings_lock);
-
-	/* Get resources */
-
-	result = snd_stm_memory_request(pdev, &spdif_player->mem_region,
-			&spdif_player->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-	spdif_player->fifo_phys_address = spdif_player->mem_region->start +
-		AUD_SPDIF_DATA;
-	snd_printd("FIFO physical address: 0x%lx.\n",
-			spdif_player->fifo_phys_address);
-
-	result = snd_stm_irq_request(pdev, &spdif_player->irq,
-			snd_stm_spdif_player_irq_handler, spdif_player);
-	if (result < 0) {
-		snd_stm_printe("IRQ request failed!\n");
-		goto error_irq_request;
-	}
-
-	result = snd_stm_fdma_request(pdev, &spdif_player->fdma_channel);
-	if (result < 0) {
-		snd_stm_printe("FDMA request failed!\n");
-		goto error_fdma_request;
-	}
-
-	/* Get component caps */
-
-	snd_printd("Player's name is '%s'\n", spdif_player->info->name);
-
-	card = snd_stm_cards_get(spdif_player->info->card_id);
-	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Player will be a member of a card '%s' as a PCM device "
-			"no. %d.\n", card->id, spdif_player->info->card_device);
-
-	/* Get fsynth device */
-
-	snd_printd("Player connected to %s's output %d.\n",
-			spdif_player->info->fsynth_bus_id,
-			spdif_player->info->fsynth_output);
-	spdif_player->fsynth_device = snd_stm_find_device(NULL,
-			spdif_player->info->fsynth_bus_id);
-	snd_assert(spdif_player->fsynth_device != NULL, return -EINVAL);
-	spdif_player->fsynth_channel = spdif_player->info->fsynth_output;
-
-	/* Preallocate buffer */
-
-	/* TODO */
-
-	/* Create ALSA lowlevel device */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, spdif_player,
-			&snd_stm_spdif_player_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Create ALSA PCM device */
-
-	result = snd_pcm_new(card, NULL, spdif_player->info->card_device, 1, 0,
-			&spdif_player->pcm);
-	if (result < 0) {
-		snd_stm_printe("ALSA PCM instance creation failed!\n");
-		goto error_pcm;
-	}
-	spdif_player->pcm->private_data = spdif_player;
-	strcpy(spdif_player->pcm->name, spdif_player->info->name);
-
-	snd_pcm_set_ops(spdif_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
-			&snd_stm_spdif_player_spdif_ops);
-
-	/* Create ALSA controls */
-
-	result = 0;
-	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
-		snd_stm_spdif_player_ctls[i].device =
-				spdif_player->info->card_device;
-		result |= snd_ctl_add(card,
-				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
-				spdif_player));
-		/* TODO: index per card */
-		snd_stm_spdif_player_ctls[i].index++;
-	}
-	result |= snd_stm_fsynth_add_adjustement_ctl(
-			spdif_player->fsynth_device,
-			spdif_player->fsynth_channel, card,
-			spdif_player->info->card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add all ALSA controls!\n");
-		goto error_controls;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, spdif_player);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return 0;
-
-error_controls:
-error_pcm:
-	snd_device_free(card, spdif_player);
-error_device:
-	snd_stm_fdma_release(spdif_player->fdma_channel);
-error_fdma_request:
-	snd_stm_irq_release(spdif_player->irq, spdif_player);
-error_irq_request:
-	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
-error_memory_request:
-	snd_stm_magic_clear(spdif_player);
-	kfree(spdif_player);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_spdif_player_remove(struct platform_device *pdev)
-{
-	struct snd_stm_spdif_player *spdif_player = platform_get_drvdata(pdev);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
-	snd_stm_fdma_release(spdif_player->fdma_channel);
-	snd_stm_irq_release(spdif_player->irq, spdif_player);
-	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
-
-	snd_stm_magic_clear(spdif_player);
-	kfree(spdif_player);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_spdif_player_driver = {
-	.driver = {
-		.name = "spdif_player",
-	},
-	.probe = snd_stm_spdif_player_probe,
-	.remove = snd_stm_spdif_player_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_spdif_player_init(void)
-{
-	return platform_driver_register(&snd_stm_spdif_player_driver);
-}
-
-void snd_stm_spdif_player_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_spdif_player_driver);
-}
diff --git a/sound/soc/stm/stx710x.c b/sound/soc/stm/stx710x.c
deleted file mode 100644
index d574cad..0000000
--- a/sound/soc/stm/stx710x.c
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- *   STMicrolectronics STx7100 SoC description
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/stm/fdma-reqs.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-
-#undef TRACE
-#include "common.h"
-
-
-
-/*
- * ALSA cards list and descriptions
- */
-
-static struct snd_stm_card __initdata snd_stm_stx710x_cards[] = {
-	{
-		.index = 0,
-		.id = "PCM",
-		.short_name = "PCM output",
-		.long_name = "Digital audio output (PCM player 0)",
-	},
-	{
-		.index = 1,
-		.id = "ANALOG",
-		.short_name = "Analog output",
-		.long_name = "Analog audio output (PCM player 1)",
-	},
-	{
-		.index = 2,
-		.id = "SPDIF",
-		.short_name = "SPDIF output",
-		.long_name = "SPDIF audio output",
-	},
-	{
-		.index = 4,
-		.id = "INPUT",
-		.short_name = "PCM input",
-		.long_name = "Digital audio input (PCM reader)",
-	}
-};
-
-
-
-/*
- * Audio subsystem components & platform devices
- */
-
-/* Audio IO controls */
-
-static struct platform_device audio_outputs = {
-	.name          = "audio_outputs",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210200,
-			.end   = 0x19210203,
-		},
-	},
-};
-
-/* Frequency synthesizer */
-
-static struct platform_device fsynth = {
-	.name          = "fsynth",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210000,
-			.end   = 0x1921003f,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_fsynth_info) {
-		.channels_from = 0,
-		.channels_to = 2,
-	},
-};
-
-/* Internal DAC */
-
-static struct platform_device conv_internal_dac = {
-	.name          = "conv_internal_dac",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210100,
-			.end   = 0x19210103,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
-		.name = "Internal audio DAC",
-		.card_id = "ANALOG",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.1",
-	},
-};
-
-/* PCM reader */
-
-struct snd_stm_pcm_reader_info pcm_reader_info = {
-	.name = "PCM reader",
-	.card_id = "INPUT",
-	.card_device = 0,
-	.channels_num = 1,
-	.channels = (int []) { 2 },
-	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx710x_init() */
-	.fdma_max_transfer_size = 2,
-};
-
-static struct platform_device pcm_reader = {
-	.name          = "pcm_reader",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18102000,
-			.end   = 0x18102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 146,
-			.end   = 146,
-		},
-	},
-	.dev.platform_data = &pcm_reader_info,
-};
-
-/* PCM players */
-
-struct snd_stm_pcm_player_info pcm_player_0_info = {
-	.name = "PCM player #0",
-	.card_id = "PCM",
-	.card_device = 0,
-	.fsynth_bus_id = "fsynth",
-	.fsynth_output = 0,
-	/* .channels_num = see snd_stm_stx710x_init() */
-	/* .channels = see snd_stm_stx710x_init() */
-	/* .invert_sclk_edge_falling = see snd_stm_stx710x_init() */
-	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx710x_init() */
-	.fdma_max_transfer_size = 2,
-};
-
-static struct platform_device pcm_player_0 = {
-	.name          = "pcm_player",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18101000,
-			.end   = 0x18101027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 144,
-			.end   = 144,
-		},
-	},
-	.dev.platform_data = &pcm_player_0_info,
-};
-
-struct snd_stm_pcm_player_info pcm_player_1_info = {
-	.name = "PCM player #1",
-	.card_id = "ANALOG",
-	.card_device = 0,
-	.fsynth_bus_id = "fsynth",
-	.fsynth_output = 1,
-	/* .channels_num = see snd_stm_stx710x_init() */
-	/* .channels = see snd_stm_stx710x_init() */
-	/* .invert_sclk_edge_falling = see snd_stm_stx710x_init() */
-	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx710x_init() */
-	.fdma_max_transfer_size = 2,
-};
-
-static struct platform_device pcm_player_1 = {
-	.name          = "pcm_player",
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18101800,
-			.end   = 0x18101827,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 145,
-			.end   = 145,
-		},
-	},
-	.dev.platform_data = &pcm_player_1_info,
-};
-
-/* SPDIF player */
-
-struct snd_stm_spdif_player_info spdif_player_info = {
-	.name = "SPDIF player",
-	.card_id = "SPDIF",
-	.card_device = 0,
-	.fsynth_bus_id = "fsynth",
-	.fsynth_output = 2,
-	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx710x_init() */
-	.fdma_max_transfer_size = 2,
-};
-
-static struct platform_device spdif_player = {
-	.name          = "spdif_player",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18103000,
-			.end   = 0x1810303f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 147,
-			.end   = 147,
-		},
-	},
-	.dev.platform_data = &spdif_player_info,
-};
-
-/* HDMI-connected I2S to SPDIF converter */
-
-static struct platform_device conv_i2s_spdif = {
-	.name          = "conv_i2s-spdif",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18103800,
-			.end   = 0x18103a23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 142,
-			.end   = 142,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
-		.name = "I2S to SPDIF converter",
-		.card_id = "PCM",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-	},
-};
-
-
-
-/*
- * Initialization and runtime configuration
- */
-
-static struct platform_device *snd_stm_stx710x_devices[] = {
-	&audio_outputs,
-	&fsynth,
-	&pcm_reader,
-	&pcm_player_0,
-	&pcm_player_1,
-	&conv_internal_dac,
-	&spdif_player,
-	&conv_i2s_spdif,
-};
-
-static int channels_2[] = { 2 };
-static int channels_10[] = { 10 };
-static int channels_2_10[] = { 2, 4, 6, 8, 10 };
-
-int __init snd_stm_stx710x_init(void)
-{
-	int result = 0;
-	const char *soc_type;
-
-	switch (cpu_data->type) {
-	case CPU_STB7100:
-		soc_type = "STx7100";
-
-		/* FDMA request line configuration */
-		pcm_player_0_info.fdma_request_line = STB7100_FDMA_REQ_PCM_0;
-		pcm_player_1_info.fdma_request_line = STB7100_FDMA_REQ_PCM_1;
-		spdif_player_info.fdma_request_line = STB7100_FDMA_REQ_SPDIF;
-		pcm_reader_info.fdma_request_line = STB7100_FDMA_REQ_PCM_READ;
-
-		/* STx7100 PCM players have small hardware bug - bit SCLK_EDGE
-		 * in AUD_PCMOUT_FMT register has opposite meaning than stated
-		 * in datasheet - 0 means that PCM serial output is clocked
-		 * (changed) during falling SCLK edge (which is usually what
-		 * we want ;-) */
-		pcm_player_0_info.invert_sclk_edge_falling = 1;
-		pcm_player_1_info.invert_sclk_edge_falling = 1;
-
-		if (cpu_data->cut_major < 3) {
-			/* STx7100 cut < 3.0 */
-			/* Hardware bug again - in early 7100s player ignored
-			 * NUM_CH setting in AUD_PCMOUT_FMT register */
-			pcm_player_0_info.channels_num =
-				ARRAY_SIZE(channels_10);
-			pcm_player_0_info.channels = channels_10;
-			pcm_player_1_info.channels_num =
-				ARRAY_SIZE(channels_10);
-			pcm_player_1_info.channels = channels_10;
-		} else {
-			/* STx7100 cut >= 3.0 */
-			pcm_player_0_info.channels_num =
-				ARRAY_SIZE(channels_2_10);
-			pcm_player_0_info.channels = channels_2_10;
-			pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
-			pcm_player_1_info.channels = channels_2;
-		}
-		break;
-
-	case CPU_STB7109:
-		soc_type = "STx7109";
-
-		/* FDMA request line configuration */
-		pcm_player_0_info.fdma_request_line = STB7109_FDMA_REQ_PCM_0;
-		pcm_player_1_info.fdma_request_line = STB7109_FDMA_REQ_PCM_1;
-		spdif_player_info.fdma_request_line = STB7109_FDMA_REQ_SPDIF;
-		pcm_reader_info.fdma_request_line = STB7109_FDMA_REQ_PCM_READ;
-
-		pcm_player_0_info.channels_num = ARRAY_SIZE(channels_2_10);
-		pcm_player_0_info.channels = channels_2_10;
-		pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
-		pcm_player_1_info.channels = channels_2;
-
-		if (cpu_data->cut_major < 3) {
-			/* STx7109 cut < 3.0 */
-			/* PCM players of early 7109s have small hardware
-			 * bug - bit SCLK_EDGE in AUD_PCMOUT_FMT register has
-			 * opposite meaning than stated in datasheet - 0 means
-			 * that PCM serial output is clocked (changed) during
-			 * falling SCLK edge (which is usually what we
-			 * want ;-) */
-			pcm_player_0_info.invert_sclk_edge_falling = 1;
-			pcm_player_1_info.invert_sclk_edge_falling = 1;
-		}
-		break;
-
-	default:
-		/* Unknown CPU! */
-		snd_stm_printe("Not supported CPU detected!\n");
-		result = -EINVAL;
-		break;
-	}
-
-	if (result == 0)
-		result = snd_stm_cards_init(soc_type,
-				snd_stm_stx710x_cards,
-				ARRAY_SIZE(snd_stm_stx710x_cards));
-
-	if (result == 0) {
-		result = snd_stm_add_plaform_devices(snd_stm_stx710x_devices,
-				ARRAY_SIZE(snd_stm_stx710x_devices));
-
-		if (result != 0)
-			snd_stm_cards_free();
-	}
-
-	return result;
-}
-
-void __exit snd_stm_stx710x_cleanup(void)
-{
-	snd_stm_remove_plaform_devices(snd_stm_stx710x_devices,
-			ARRAY_SIZE(snd_stm_stx710x_devices));
-}
diff --git a/sound/soc/stm/stx7111.c b/sound/soc/stm/stx7111.c
deleted file mode 100644
index cacffaa..0000000
--- a/sound/soc/stm/stx7111.c
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- *   STMicrolectronics STx7111 SoC description
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-
-#undef TRACE
-#include "common.h"
-
-
-
-/*
- * ALSA cards list and descriptions
- */
-
-struct snd_stm_card __initdata snd_stm_stx7111_cards[] = {
-	{
-		.index = 0,
-		.id = "PCM",
-		.short_name = "PCM outputs",
-		.long_name = "Digital audio outputs (PCM player 0)",
-	},
-	{
-		.index = 1,
-		.id = "ANALOG",
-		.short_name = "Analog outputs",
-		.long_name = "Analog audio outputs (PCM player 1)",
-	},
-	{
-		.index = 2,
-		.id = "SPDIF",
-		.short_name = "SPDIF output",
-		.long_name = "SPDIF audio output",
-	},
-	{
-		.index = 3,
-		.id = "INPUT",
-		.short_name = "PCM input",
-		.long_name = "Digital audio input (PCM reader)",
-	}
-};
-
-
-
-/*
- * Audio subsystem components & platform devices
- */
-
-/* Audio outputs control */
-
-static struct platform_device audio_outputs = {
-	.name          = "audio_outputs",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfe210200,
-			.end   = 0xfe21020b,
-		},
-	}
-};
-
-/* Frequency synthesizers */
-
-static struct platform_device fsynth = {
-	.name          = "fsynth",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfe210000,
-			.end   = 0xfe21004f,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_fsynth_info) {
-		.channels_from = 0,
-		.channels_to = 2,
-	},
-};
-
-/* PCM reader */
-
-#if 0 /* MB618 has no audio input, so there is no way to test it... */
-static struct platform_device pcm_reader = {
-	.name          = "pcm_reader",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd102000,
-			.end   = 0xfd102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x1440),
-			.end   = evt2irq(0x1440),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
-		.name = "PCM reader",
-		.card_id = "INPUT",
-		.card_device = 0,
-		.channels_num = 5,
-		.channels = (int []) { 2, 4, 6, 8, 10 },
-		.fdma_initiator = 0,
-		.fdma_request_line = 29,
-		.fdma_max_transfer_size = 30,
-	},
-};
-#endif
-
-/* Internal DACs */
-
-static struct platform_device conv_internal_dac = {
-	.name          = "conv_internal_dac",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfe210100,
-			.end   = 0xfe210103,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
-		.name = "Internal audio DAC",
-		.card_id = "ANALOG",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.1",
-	},
-};
-
-/* PCM players  */
-
-static struct platform_device pcm_player_0 = {
-	.name          = "pcm_player",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd104d00,
-			.end   = 0xfd104d27,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x1400),
-			.end   = evt2irq(0x1400),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #0",
-		.card_id = "PCM",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth",
-		.fsynth_output = 0,
-		.channels_num = 4,
-		.channels = (int []) { 2, 4, 6, 8 },
-		.fdma_initiator = 0,
-		.fdma_request_line = 27,
-		.fdma_max_transfer_size = 30,
-	},
-};
-
-static struct platform_device pcm_player_1 = {
-	.name          = "pcm_player",
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd101800,
-			.end   = 0xfd101827,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x1420),
-			.end   = evt2irq(0x1420),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #1",
-		.card_id = "ANALOG",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth",
-		.fsynth_output = 1,
-		.channels_num = 1,
-		.channels = (int []) { 2 },
-		.fdma_initiator = 0,
-		.fdma_request_line = 28,
-		.fdma_max_transfer_size = 30,
-	},
-};
-
-/*
- * SPDIF player
- */
-
-static struct platform_device spdif_player = {
-	.name          = "spdif_player",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd104c00,
-			.end   = 0xfd104c43,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x1460),
-			.end   = evt2irq(0x1460),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
-		.name = "SPDIF player",
-		.card_id = "SPDIF",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth",
-		.fsynth_output = 2,
-		.fdma_initiator = 0,
-		.fdma_request_line = 30,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-/* I2S to SPDIF converters */
-
-static struct platform_device conv_i2s_spdif_0 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105000,
-			.end   = 0xfd105223,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x13c0),
-			.end   = evt2irq(0x13c0),
-		}
-	},
-	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
-		.name = "I2S to SPDIF converter #0",
-		.card_id = "PCM",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-		.full_channel_status = 1,
-	},
-};
-
-static struct platform_device conv_i2s_spdif_1 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105400,
-			.end   = 0xfd105623,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x0a80),
-			.end   = evt2irq(0x0a80),
-		}
-	},
-	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
-		.name = "I2S to SPDIF converter #1",
-		.card_id = "PCM",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-		.full_channel_status = 1,
-	},
-};
-
-static struct platform_device conv_i2s_spdif_2 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 2,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105800,
-			.end   = 0xfd105a23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x0b00),
-			.end   = evt2irq(0x0b00),
-		}
-	},
-	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
-		.name = "I2S to SPDIF converter #2",
-		.card_id = "PCM",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-		.full_channel_status = 1,
-	},
-};
-
-static struct platform_device conv_i2s_spdif_3 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 3,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105c00,
-			.end   = 0xfd105e23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = evt2irq(0x0b20),
-			.end   = evt2irq(0x0b20),
-		}
-	},
-	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
-		.name = "I2S to SPDIF converter #3",
-		.card_id = "PCM",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-		.full_channel_status = 1,
-	},
-};
-
-
-
-/*
- * Initialization and runtime configuration
- */
-
-static struct platform_device *snd_stm_stx7111_devices[] = {
-	&audio_outputs,
-	&fsynth,
-#if 0 /* MB618 has no audio input, so there is no way to test it... */
-	&pcm_reader,
-#endif
-	&conv_internal_dac,
-	&pcm_player_0,
-	&pcm_player_1,
-	&spdif_player,
-	&conv_i2s_spdif_0,
-	&conv_i2s_spdif_1,
-	&conv_i2s_spdif_2,
-	&conv_i2s_spdif_3,
-};
-
-int __init snd_stm_stx7111_init(void)
-{
-	int result = 0;
-
-	/* TODO: 7111 is identified now as ST40-300... */
-	if (cpu_data->type != CPU_ST40_300) {
-		/* Unknown CPU! */
-		snd_stm_printe("Not supported CPU detected!\n");
-		result = -EINVAL;
-	}
-
-	/* Ugly but quick hack to have SPDIF player & I2S to SPDIF
-	 * converters enabled without loading STMFB...
-	 * TODO: do this in some sane way! */
-	{
-		void *hdmi_gpout = ioremap(0xfd104020, 4);
-		writel(readl(hdmi_gpout) | 0x3, hdmi_gpout);
-		iounmap(hdmi_gpout);
-	}
-
-	if (result == 0) {
-		/* Cut 2.0 presumably will bring something new into the
-		 * matter, so above configuration must be checked!
-		 * - transfer_sizes (FIFO sizes has changed) */
-		WARN_ON(cpu_data->cut_major > 1);
-
-		result = snd_stm_cards_init("STx7111",
-				snd_stm_stx7111_cards,
-				ARRAY_SIZE(snd_stm_stx7111_cards));
-	}
-
-	if (result == 0) {
-		result = snd_stm_add_plaform_devices(snd_stm_stx7111_devices,
-				ARRAY_SIZE(snd_stm_stx7111_devices));
-
-		if (result != 0)
-			snd_stm_cards_free();
-	}
-
-	return result;
-}
-
-void __exit snd_stm_stx7111_cleanup(void)
-{
-	snd_stm_remove_plaform_devices(snd_stm_stx7111_devices,
-			ARRAY_SIZE(snd_stm_stx7111_devices));
-}
diff --git a/sound/soc/stm/stx7200.c b/sound/soc/stm/stx7200.c
deleted file mode 100644
index cd2e37f..0000000
--- a/sound/soc/stm/stx7200.c
+++ /dev/null
@@ -1,559 +0,0 @@
-/*
- *   STMicrolectronics STx7200 SoC description
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/stm/fdma-reqs.h>
-#include <asm/irq-ilc.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-
-#undef TRACE
-#include "common.h"
-
-
-
-/*
- * ALSA cards list and descriptions
- */
-
-struct snd_stm_card __initdata snd_stm_stx7200_cards[] = {
-	{
-		.index = 0,
-		.id = "PCM",
-		.short_name = "PCM outputs",
-		.long_name = "Digital audio outputs (PCM players 2 and 3)",
-	},
-	{
-		.index = 1,
-		.id = "ANALOG",
-		.short_name = "Analog outputs",
-		.long_name = "Analog audio outputs (PCM players 0 and 1)",
-	},
-	{
-		.index = 2,
-		.id = "SPDIF",
-		.short_name = "SPDIF output",
-		.long_name = "SPDIF audio output",
-	},
-	{
-		.index = 3,
-		.id = "HDMI",
-		.short_name = "HDMI output",
-		.long_name = "HDMI audio output (dedicated PCM "
-				"and SPDIF players)",
-	},
-	{
-		.index = 4,
-		.id = "INPUT",
-		.short_name = "PCM input",
-		.long_name = "Digital audio input (PCM reader)",
-	}
-};
-
-
-
-/*
- * Audio subsystem components & platform devices
- */
-
-/* Audio outputs control */
-
-static struct platform_device audio_outputs = {
-	.name          = "audio_outputs",
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601200,
-			.end   = 0xfd60120b,
-		},
-	}
-};
-
-/* Frequency synthesizers */
-
-static struct platform_device fsynth_0 = {
-	.name          = "fsynth",
-	.id            = 0,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601000,
-			.end   = 0xfd60104f,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_fsynth_info) {
-		.channels_from = 0,
-		.channels_to = 3,
-	},
-};
-
-static struct platform_device fsynth_1 = {
-	.name          = "fsynth",
-	.id            = 1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601100,
-			.end   = 0xfd60114f,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_fsynth_info) {
-		.channels_from = 2,
-		.channels_to = 3,
-	},
-};
-
-/* PCM reader */
-
-static struct platform_device pcm_reader = {
-	.name          = "pcm_reader",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd100000,
-			.end   = 0xfd100027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(38),
-			.end   = ILC_IRQ(38),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
-		.name = "PCM reader",
-		.card_id = "INPUT",
-		.card_device = 0,
-		.channels_num = 1,
-		.channels = (int []) { 2 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_PCMIN,
-		.fdma_max_transfer_size = 2,
-	},
-};
-
-/* Internal DACs */
-
-static struct platform_device conv_internal_dac_0 = {
-	.name          = "conv_internal_dac",
-	.id            = 0,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601400,
-			.end   = 0xfd601403,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
-		.name = "Internal audio DAC #0",
-		.card_id = "ANALOG",
-		.card_device = 0,
-		.source_bus_id = "pcm_player.0",
-	},
-};
-
-static struct platform_device conv_internal_dac_1 = {
-	.name          = "conv_internal_dac",
-	.id            = 1,
-	.num_resources = 1,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601500,
-			.end   = 0xfd601503,
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
-		.name = "Internal audio DAC #1 (slave)",
-		.card_id = "ANALOG",
-		.card_device = 1,
-		.source_bus_id = "pcm_player.1",
-	},
-};
-
-/* PCM players connected to internal DACs */
-
-static struct platform_device pcm_player_0 = {
-	.name          = "pcm_player",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd101000,
-			.end   = 0xfd101027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(39),
-			.end   = ILC_IRQ(39),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #0",
-		.card_id = "ANALOG",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth.0",
-		.fsynth_output = 0,
-		.channels_num = 1,
-		.channels = (int []) { 2 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_PCM0,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-static struct platform_device pcm_player_1 = {
-	.name          = "pcm_player",
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd102000,
-			.end   = 0xfd102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(40),
-			.end   = ILC_IRQ(40),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #1",
-		.card_id = "ANALOG",
-		.card_device = 1,
-		.fsynth_bus_id = "fsynth.0",
-		.fsynth_output = 1,
-		.channels_num = 3,
-		.channels = (int []) { 2, 4, 6 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_PCM1,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-/* PCM players with digital outputs */
-
-static struct platform_device pcm_player_2 = {
-	.name          = "pcm_player",
-	.id            = 2,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd103000,
-			.end   = 0xfd103027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(41),
-			.end   = ILC_IRQ(41),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #2",
-		.card_id = "PCM",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth.0",
-		.fsynth_output = 2,
-		.channels_num = 4,
-		.channels = (int []) { 2, 4, 6, 8 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_PCM2,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-static struct platform_device pcm_player_3 = {
-	.name          = "pcm_player",
-	.id            = 3,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd104000,
-			.end   = 0xfd104027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(42),
-			.end   = ILC_IRQ(42),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player #3",
-		.card_id = "PCM",
-		.card_device = 1,
-		.fsynth_bus_id = "fsynth.0",
-		.fsynth_output = 3,
-		.channels_num = 5,
-		.channels = (int []) { 2, 4, 6, 8, 10 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_PCM3,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-/* SPDIF player */
-
-static struct platform_device spdif_player = {
-	.name          = "spdif_player",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105000,
-			.end   = 0xfd10503f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(37),
-			.end   = ILC_IRQ(37),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
-		.name = "SPDIF player",
-		.card_id = "SPDIF",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth.1",
-		.fsynth_output = 3,
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_SPDIF,
-		.fdma_max_transfer_size = 4,
-	},
-};
-
-/* HDMI output devices
- * Please note that "HDTVOutBaseAddress" (0xFD10C000) from page 54 of
- * "7200 Programming Manual, Volume 2" is wrong. The correct HDMI players
- * subsystem base address is "HDMIPlayerBaseAddress" (0xFD106000) from
- * page 488 of the manual. */
-
-static struct platform_device hdmi_pcm_player = {
-	.name          = "pcm_player",
-	.id            = 4, /* HDMI PCM player is no. 4 */
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd106d00,
-			.end   = 0xfd106d27,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(62),
-			.end   = ILC_IRQ(62),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
-		.name = "PCM player HDMI",
-		.card_id = "HDMI",
-		.card_device = 0,
-		.fsynth_bus_id = "fsynth.1",
-		.fsynth_output = 2,
-		.channels_num = 4,
-		.channels = (int []) { 2, 4, 6, 8 },
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_HDMI_PCM,
-		.fdma_max_transfer_size = 20,
-	},
-};
-
-static struct platform_device hdmi_spdif_player = {
-	.name          = "spdif_player",
-	.id            = 1, /* HDMI SPDIF player is no. 1 */
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd106c00,
-			.end   = 0xfd106c3f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(63),
-			.end   = ILC_IRQ(63),
-		},
-	},
-	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
-		.name = "SPDIF player HDMI",
-		.card_id = "HDMI",
-		.card_device = 1,
-		.fsynth_bus_id = "fsynth.1",
-		.fsynth_output = 2,
-		.fdma_initiator = 0,
-		.fdma_request_line = STB7200_FDMA_REQ_HDMI_SPDIF,
-		.fdma_max_transfer_size = 4,
-	},
-};
-
-#if 0 /* Disabled till cut 2.0 */
-static struct platform_device hdmi_conv_i2s_spdif_0 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107000,
-			.end   = 0xfd107223,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(64),
-			.end   = ILC_IRQ(64),
-		}
-	},
-};
-
-static struct platform_device hdmi_conv_i2s_spdif_1 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107400,
-			.end   = 0xfd107623,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(65),
-			.end   = ILC_IRQ(65),
-		}
-	},
-};
-
-static struct platform_device hdmi_conv_i2s_spdif_2 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 2,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107800,
-			.end   = 0xfd107a23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(66),
-			.end   = ILC_IRQ(66),
-		}
-	},
-};
-
-static struct platform_device hdmi_conv_i2s_spdif_3 = {
-	.name          = "conv_i2s-spdif",
-	.id            = 3,
-	.num_resources = 2,
-	.resource      = (struct resource []) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107c00,
-			.end   = 0xfd107e23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(67),
-			.end   = ILC_IRQ(67),
-		}
-	},
-};
-#endif
-
-
-
-/*
- * Initialization and runtime configuration
- */
-
-static struct platform_device *snd_stm_stx7200_devices[] = {
-	&audio_outputs,
-	&fsynth_0,
-	&fsynth_1,
-	&pcm_reader,
-	&conv_internal_dac_0,
-	&conv_internal_dac_1,
-	&pcm_player_0,
-	&pcm_player_1,
-	&pcm_player_2,
-	&pcm_player_3,
-	&spdif_player,
-	&hdmi_pcm_player,
-	&hdmi_spdif_player,
-#if 0 /* Disabled till cut 2.0 */
-	&hdmi_conv_i2s_spdif_0,
-	&hdmi_conv_i2s_spdif_1,
-	&hdmi_conv_i2s_spdif_2,
-	&hdmi_conv_i2s_spdif_3,
-#endif
-};
-
-int __init snd_stm_stx7200_init(void)
-{
-	int result = 0;
-
-	if (cpu_data->type != CPU_STX7200) {
-		/* Unknown CPU! */
-		snd_stm_printe("Not supported CPU detected!\n");
-		result = -EINVAL;
-	}
-
-	if (result == 0) {
-		/* Cut 2.0 presumably will bring something new into the
-		 * matter, so above configuration must be checked!
-		 * - transfer_sizes (FIFO sizes has changed) */
-		WARN_ON(cpu_data->cut_major > 1);
-
-		result = snd_stm_cards_init("STx7200",
-				snd_stm_stx7200_cards,
-				ARRAY_SIZE(snd_stm_stx7200_cards));
-	}
-
-	if (result == 0) {
-		result = snd_stm_add_plaform_devices(snd_stm_stx7200_devices,
-				ARRAY_SIZE(snd_stm_stx7200_devices));
-
-		if (result != 0)
-			snd_stm_cards_free();
-	}
-
-
-	return result;
-}
-
-void __exit snd_stm_stx7200_cleanup(void)
-{
-	snd_stm_remove_plaform_devices(snd_stm_stx7200_devices,
-			ARRAY_SIZE(snd_stm_stx7200_devices));
-}
diff --git a/sound/soc/stm/synchro.c b/sound/soc/stm/synchro.c
deleted file mode 100644
index 04ebad9..0000000
--- a/sound/soc/stm/synchro.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *   Audio playback synchronization routines for STMicroelectronics' SoCs
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 9 /* See common.h debug features */
-#include "common.h"
-
-/*
- * Initialization
- */
-
-int __init snd_stm_synchro_init(void)
-{
-	return 0;
-}
-
-void snd_stm_synchro_cleanup(void)
-{
-}
diff --git a/sound/stm/Kconfig b/sound/stm/Kconfig
new file mode 100644
index 0000000..1d7cb16
--- /dev/null
+++ b/sound/stm/Kconfig
@@ -0,0 +1,121 @@
+menuconfig SND_STM
+	tristate "STMicroelectronics SoCs support"
+	depends on SND
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200
+	select STM_DMA
+	select SND_PCM
+	select SND_DYNAMIC_MINORS
+	help
+		Say Y here for ALSA support on the STMicroelectronics SoCs.
+
+		This driver provides core functionality - you have to build
+		(at least one) SoC-specific driver as well. Additionally, it is
+		using dynamic device minor number allocation, so udev-like
+		utility is required.
+
+		It is recommended to have BPA2 enabled with dedicated
+		partition defined, however it is not absolutely necessary.
+
+		To compile this driver as a module, choose M here: the module
+	 	will be called snd-stm.ko
+
+config SND_STM_BPA2_PARTITION_NAME
+	string "Name of BPA2 partition to allocate buffers from"
+	depends on SND_STM
+	depends on BPA2
+	default "audio"
+	help
+		Define a name of BPA2 partition the driver should try to
+		allocate from.
+
+		If name is not given or given partition does not exist, driver
+		will try to use "bigphysmem" partition or eventually
+		preallocate some system memory using
+		ALSA snd_pcm_lib_preallocate_pages_for_all() method.
+
+		This value can be overridden by module parameter
+		"bpa2_part=<name>" (or kernel command line parameter
+		"snd-stm.bpa2_part=<name>", if driver is compiled into
+		kernel).
+
+config SND_STM_DEBUG_LEVEL
+	int "Default debug verbosity level"
+	depends on SND_STM
+	depends on SND_DEBUG
+	default 0
+	help
+		Defines debug verbosity level (bigger number equals more
+		messages). This can be overridden using "debug=<n>" module
+		parameter or "snd-stm.debug=<n>" kernel command line
+		parameter. You can also change this value in runtime,
+		using /sys/module/snd_stm/parameters/debug.
+
+		There is also fine-grained debug verbosity control available -
+		just put "#define DEBUG <n>" in debugged component _before_
+		#including "common.h", or alter the value using sysfs file
+		/sys/module/snd_stm/parameter/debug_component_name (or
+		use module/kernel command line parameter ;-)...
+
+config SND_STM_STX710X
+	tristate "STx7100 and STx7109 support"
+	depends on SND_STM
+	default y if CPU_SUBTYPE_STB7100
+	help
+		Select this to get ALSA driver for STx7100 and STx7109 chips.
+
+		If you compile this driver as a module, it will be
+		called snd-stm-stx710x.ko
+
+config SND_STM_STX7111
+	tristate "STx7111 support"
+	depends on SND_STM
+	default y if CPU_SUBTYPE_STX7111
+	help
+		Select this to get ALSA driver for STx7111 chip.
+
+		If you compile this driver as a module, it will be
+		called snd-stm-stx7111.ko
+
+config SND_STM_STX7200
+	tristate "STx7200 support"
+	depends on SND_STM
+	default y if CPU_SUBTYPE_STX7200
+	help
+		Select this to get ALSA driver for STx7200 chip.
+
+		If you compile this driver as a module, it will be
+		called snd-stm-stx7111.ko
+
+config SND_STM_CONV_DUMMY
+	tristate "Dummy converter driver"
+	depends on SND_STM
+	help
+		This provides dummy converter driver to configure
+		digital audio interface format (I2S, Left-Justified,
+		Right-Justified). See include/sound/stm.h for
+		more information.
+
+		If compiled as module, it will be called
+		snd-stm-conv-dummy.ko.
+
+config SND_STM_CONV_GPIO
+	tristate "Generic GPIO-controlled converter driver"
+	depends on SND_STM
+	help
+		This provides generic driver for GPIO-controlled
+		converters. See include/sound/stm.h for informations
+		how to define GPIO line numbers.
+
+		If compiled as module, it will be called
+		snd-stm-conv-gpio.ko.
+
+config SND_STM_CONV_I2C
+	tristate "Generic I2C-controlled converter driver"
+	depends on SND_STM
+	help
+		This provides generic driver for I2C-controlled
+		converters. See include/sound/stm.h for informations
+		how to define required I2C addresses & commands.
+
+		If compiled as module, it will be called
+		snd-stm-conv-gpio.ko.
diff --git a/sound/stm/Makefile b/sound/stm/Makefile
new file mode 100644
index 0000000..32e82e5
--- /dev/null
+++ b/sound/stm/Makefile
@@ -0,0 +1,22 @@
+obj-$(CONFIG_SND_STM) += snd-stm.o
+snd-stm-y := init.o common.o synchro.o fsynth.o
+snd-stm-y += conv.o conv_i2sspdif.o conv_int_dac.o
+snd-stm-y += pcm_player.o pcm_reader.o spdif_player.o
+
+obj-$(CONFIG_SND_STM_STX710X) += snd-stm-stx710x.o
+snd-stm-stx710x-y := stx710x.o
+
+obj-$(CONFIG_SND_STM_STX7111) += snd-stm-stx7111.o
+snd-stm-stx7111-y := stx7111.o
+
+obj-$(CONFIG_SND_STM_STX7200) += snd-stm-stx7200.o
+snd-stm-stx7200-y := stx7200.o
+
+obj-$(CONFIG_SND_STM_CONV_DUMMY) += snd-stm-conv-dummy.o
+snd-stm-conv-dummy-y := conv_dummy.o
+
+obj-$(CONFIG_SND_STM_CONV_GPIO) += snd-stm-conv-gpio.o
+snd-stm-conv-gpio-y := conv_gpio.o
+
+obj-$(CONFIG_SND_STM_CONV_I2C) += snd-stm-conv-i2c.o
+snd-stm-conv-i2c-y := conv_i2c.o
diff --git a/sound/stm/common.c b/sound/stm/common.c
new file mode 100644
index 0000000..426da53
--- /dev/null
+++ b/sound/stm/common.c
@@ -0,0 +1,761 @@
+/*
+ *   Helpful ;-) routines for STMicroelectronics' SoCs audio drivers
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/bpa2.h>
+#include <linux/stm/soc.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/pcm_params.h>
+#include <sound/asoundef.h>
+
+#define COMPONENT common
+#include "common.h"
+
+
+
+/*
+ * Cards management
+ */
+
+static struct snd_card *snd_stm_card;
+
+struct snd_card *snd_stm_card_new(int index, const char *id,
+		struct module *module)
+{
+	snd_assert(snd_stm_card == NULL, return NULL);
+
+	snd_stm_card = snd_card_new(index, id, module, 0);
+
+	return snd_stm_card;
+}
+EXPORT_SYMBOL(snd_stm_card_new);
+
+int snd_stm_card_register(void)
+{
+	snd_assert(snd_stm_card != NULL, return -EINVAL);
+
+	return snd_card_register(snd_stm_card);
+}
+EXPORT_SYMBOL(snd_stm_card_register);
+
+void snd_stm_card_free(void)
+{
+	snd_assert(snd_stm_card != NULL, return);
+
+	snd_card_free(snd_stm_card);
+
+	snd_stm_card = NULL;
+}
+EXPORT_SYMBOL(snd_stm_card_free);
+
+struct snd_card *snd_stm_card_get(void)
+{
+	snd_assert(snd_stm_card != NULL, return NULL);
+
+	return snd_stm_card;
+}
+EXPORT_SYMBOL(snd_stm_card_get);
+
+
+
+/*
+ * Device management
+ */
+
+static void dummy_release(struct device *dev)
+{
+}
+
+int snd_stm_add_plaform_devices(struct platform_device **devices,
+		int cnt)
+{
+	int result = 0;
+	int i;
+
+	for (i = 0; i < cnt; i++) {
+		devices[i]->dev.release = dummy_release;
+		result = platform_device_register(devices[i]);
+		if (result != 0) {
+			while (--i >= 0)
+				platform_device_unregister(devices[i]);
+			break;
+		}
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(snd_stm_add_plaform_devices);
+
+void snd_stm_remove_plaform_devices(struct platform_device **devices,
+		int cnt)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++)
+		platform_device_unregister(devices[i]);
+}
+EXPORT_SYMBOL(snd_stm_remove_plaform_devices);
+
+
+
+/*
+ * Resources management
+ */
+
+int snd_stm_memory_request(struct platform_device *pdev,
+		struct resource **mem_region, void **base_address)
+{
+	struct resource *resource;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to"
+				" platform_get_resource(IORESOURCE_MEM)!\n");
+		return -ENODEV;
+	}
+
+	*mem_region = request_mem_region(resource->start,
+			resource->end - resource->start + 1, pdev->name);
+	if (!*mem_region) {
+		snd_stm_printe("Failed request_mem_region(0x%08x,"
+				" 0x%08x, '%s')!\n", resource->start,
+				resource->end - resource->start + 1,
+				pdev->name);
+		return -EBUSY;
+	}
+	snd_stm_printd(0, "Memory region: 0x%08x-0x%08x\n",
+			(*mem_region)->start, (*mem_region)->end);
+
+	*base_address = ioremap(resource->start,
+			resource->end - resource->start + 1);
+	if (!*base_address) {
+		release_resource(*mem_region);
+		snd_stm_printe("Failed ioremap!\n");
+		return -EINVAL;
+	}
+
+	snd_stm_printd(0, "Base address is 0x%p.\n", base_address);
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_stm_memory_request);
+
+void snd_stm_memory_release(struct resource *mem_region,
+		void *base_address)
+{
+	iounmap(base_address);
+	release_resource(mem_region);
+}
+EXPORT_SYMBOL(snd_stm_memory_release);
+
+int snd_stm_irq_request(struct platform_device *pdev,
+		unsigned int *irq, irq_handler_t handler, void *dev_id)
+{
+	struct resource *resource;
+	int result;
+
+	resource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to "
+				"platform_get_resource(IORESOURCE_IRQ)!\n");
+		return -ENODEV;
+	}
+	snd_stm_printd(0, "IRQ: %u\n", resource->start);
+
+	*irq = resource->start;
+
+	result = request_irq(*irq, handler, IRQF_DISABLED, pdev->name, dev_id);
+	if (result != 0) {
+		snd_stm_printe("Failed request_irq!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int snd_stm_fdma_request(struct platform_device *pdev,
+		unsigned int *channel)
+{
+	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
+	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
+	static const char *fdma_cap_hb[] = { STM_DMA_CAP_HIGH_BW, NULL };
+
+	*channel = request_dma_bycap(fdmac_id, fdma_cap_lb, pdev->name);
+	if (*channel < 0) {
+		*channel = request_dma_bycap(fdmac_id, fdma_cap_hb, pdev->name);
+		if (*channel < 0) {
+			snd_stm_printe("Failed to request_dma_bycap()==%d!\n",
+					*channel);
+			return -ENODEV;
+		}
+	}
+	snd_stm_printd(0, "FDMA channel: %d\n", *channel);
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA procfs additional entries
+ */
+
+static struct snd_info_entry *snd_stm_info_root;
+
+int snd_stm_info_create(void)
+{
+	int result = 0;
+
+	snd_stm_info_root = snd_info_create_module_entry(THIS_MODULE,
+			"stm", NULL);
+	if (snd_stm_info_root) {
+		snd_stm_info_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		if (snd_info_register(snd_stm_info_root) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(snd_stm_info_root);
+		}
+	} else {
+		result = -ENOMEM;
+	}
+
+	return result;
+}
+
+void snd_stm_info_dispose(void)
+{
+	if (snd_stm_info_root)
+		snd_info_free_entry(snd_stm_info_root);
+}
+
+int snd_stm_info_register(struct snd_info_entry **entry,
+		const char *name,
+		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
+		void *private_data)
+{
+	int result = 0;
+
+	*entry = snd_info_create_module_entry(THIS_MODULE, name,
+			snd_stm_info_root);
+	if (*entry) {
+		(*entry)->c.text.read = read;
+		(*entry)->private_data = private_data;
+		if (snd_info_register(*entry) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(*entry);
+		}
+	} else {
+		result = -EINVAL;
+	}
+	return result;
+}
+EXPORT_SYMBOL(snd_stm_info_register);
+
+void snd_stm_info_unregister(struct snd_info_entry *entry)
+{
+	if (entry)
+		snd_info_free_entry(entry);
+}
+EXPORT_SYMBOL(snd_stm_info_unregister);
+
+
+
+/*
+ * PCM buffer memory management
+ */
+
+struct snd_stm_buffer {
+	struct snd_pcm *pcm;
+
+	struct bpa2_part *bpa2_part;
+
+	int allocated;
+	struct snd_pcm_substream *substream;
+
+	snd_stm_magic_field;
+};
+
+#if defined(CONFIG_BPA2)
+static char *bpa2_part = CONFIG_SND_STM_BPA2_PARTITION_NAME;
+#else
+static char *bpa2_part = "";
+#endif
+module_param(bpa2_part, charp, S_IRUGO);
+
+struct snd_stm_buffer *snd_stm_buffer_create(struct snd_pcm *pcm,
+		struct device *device, int prealloc_size)
+{
+	struct snd_stm_buffer *buffer;
+
+	snd_stm_printd(1, "snd_stm_buffer_init(pcm=%p, prealloc_size=%d)\n",
+			pcm, prealloc_size);
+
+	snd_assert(pcm, return NULL);
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer) {
+		snd_stm_printe("Can't allocate memory for a buffer "
+				"description!\n");
+		return NULL;
+	}
+	snd_stm_magic_set(buffer);
+	buffer->pcm = pcm;
+
+#if defined(CONFIG_BPA2)
+	buffer->bpa2_part = bpa2_find_part(bpa2_part);
+	if (buffer->bpa2_part) {
+		snd_stm_printd(0, "Using BPA2 partition '%s'...\n", bpa2_part);
+		return buffer;
+	}
+
+	buffer->bpa2_part = bpa2_find_part("bigphysarea");
+	if (buffer->bpa2_part) {
+		snd_stm_printd(0, "Using legacy 'bigphysarea' BPA2 "
+				"partition...\n");
+		return buffer;
+	}
+#endif
+
+	if (snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_DEV, device,
+			prealloc_size, prealloc_size) == 0) {
+		snd_stm_printd(0, "Using pcm_lib's preallocated buffer "
+				"(%d bytes)...\n", prealloc_size);
+		return buffer;
+	}
+
+	snd_stm_printe("Can't provide any memory for buffers!\n");
+	kfree(buffer);
+	return NULL;
+}
+
+void snd_stm_buffer_dispose(struct snd_stm_buffer *buffer)
+{
+	snd_stm_printd(1, "snd_stm_buffer_dispose(buffer=%p)\n", buffer);
+
+	snd_assert(buffer, return);
+	snd_stm_magic_assert(buffer, return);
+	snd_assert(!buffer->allocated, return);
+
+	if (!buffer->bpa2_part)
+		snd_pcm_lib_preallocate_free_for_all(buffer->pcm);
+
+	snd_stm_magic_clear(buffer);
+	kfree(buffer);
+}
+
+inline int snd_stm_buffer_is_allocated(struct snd_stm_buffer *buffer)
+{
+	snd_stm_printd(1, "snd_stm_buffer_is_allocated(buffer=%p)\n",
+			buffer);
+
+	snd_assert(buffer, return -EINVAL);
+	snd_stm_magic_assert(buffer, return -EINVAL);
+
+	return buffer->allocated;
+}
+
+int snd_stm_buffer_alloc(struct snd_stm_buffer *buffer,
+		struct snd_pcm_substream *substream, int size)
+{
+	snd_stm_printd(1, "snd_stm_buffer_alloc(buffer=%p, substream=%p, "
+			"size=%d)\n", buffer, substream, size);
+
+	snd_assert(buffer, return -EINVAL);
+	snd_stm_magic_assert(buffer, return -EINVAL);
+	snd_assert(!buffer->allocated, return -EINVAL);
+	snd_assert(size > 0, return -EINVAL);
+
+	if (buffer->bpa2_part) {
+#if defined(CONFIG_BPA2)
+		struct snd_pcm_runtime *runtime = substream->runtime;
+		int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+		runtime->dma_addr = bpa2_alloc_pages(buffer->bpa2_part, pages,
+				0, GFP_KERNEL);
+		if (runtime->dma_addr == 0) {
+			snd_stm_printe("Can't get %d pages from BPA2!\n",
+					pages);
+			return -ENOMEM;
+		}
+		runtime->dma_bytes = size;
+		runtime->dma_area = ioremap_nocache(runtime->dma_addr, size);
+#else
+		snd_BUG();
+#endif
+	} else {
+		if (snd_pcm_lib_malloc_pages(substream, size) < 0) {
+			snd_stm_printe("Can't allocate pages using pcm_lib!\n");
+			return -ENOMEM;
+		}
+		/* runtime->dma_* are set by snd_pcm_lib_malloc_pages()
+		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
+	}
+
+	snd_stm_printd(1, "Allocated memory: dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", substream->runtime->dma_addr,
+			substream->runtime->dma_area,
+			substream->runtime->dma_bytes);
+
+	buffer->substream = substream;
+	buffer->allocated = 1;
+
+	return 0;
+}
+
+void snd_stm_buffer_free(struct snd_stm_buffer *buffer)
+{
+	struct snd_pcm_runtime *runtime;
+
+	snd_stm_printd(1, "snd_stm_buffer_free(buffer=%p)\n", buffer);
+
+	snd_assert(buffer, return);
+	snd_stm_magic_assert(buffer, return);
+	snd_assert(buffer->allocated, return);
+
+	runtime = buffer->substream->runtime;
+
+	snd_stm_printd(1, "Freeing dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
+	iounmap(runtime->dma_area);
+
+	if (buffer->bpa2_part) {
+#if defined(CONFIG_BPA2)
+		bpa2_free_pages(buffer->bpa2_part, runtime->dma_addr);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+#else
+		snd_BUG();
+#endif
+	} else {
+		snd_pcm_lib_free_pages(buffer->substream);
+		/* runtime->dma_* are cleared by snd_pcm_lib_free_pages()
+		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
+	}
+
+	buffer->allocated = 0;
+	buffer->substream = NULL;
+}
+
+static struct page *snd_stm_buffer_mmap_nopage(struct vm_area_struct *area,
+		unsigned long address, int *type)
+{
+	/* No VMA expanding here! */
+	return NOPAGE_SIGBUS;
+}
+
+static struct vm_operations_struct snd_stm_buffer_mmap_vm_ops = {
+	.open =   snd_pcm_mmap_data_open,
+	.close =  snd_pcm_mmap_data_close,
+	.nopage = snd_stm_buffer_mmap_nopage,
+};
+
+int snd_stm_buffer_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long map_offset = area->vm_pgoff << PAGE_SHIFT;
+	unsigned long phys_addr = runtime->dma_addr + map_offset;
+	unsigned long map_size = area->vm_end - area->vm_start;
+	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
+			runtime->dma_bytes % PAGE_SIZE;
+
+	snd_stm_printd(1, "snd_stm_buffer_mmap(substream=%p, area=%p)\n",
+			substream, area);
+
+	snd_stm_printd(1, "Mmaping %lu bytes starting from 0x%08lx "
+			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
+			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
+			phys_addr, runtime->dma_addr, runtime->dma_bytes,
+			area->vm_pgoff, area->vm_start, area->vm_end);
+
+	if (map_size > phys_size) {
+		snd_stm_printe("Trying to perform mmap larger than buffer!\n");
+		return -EINVAL;
+	}
+
+	area->vm_ops = &snd_stm_buffer_mmap_vm_ops;
+	area->vm_private_data = substream;
+	area->vm_flags |= VM_RESERVED;
+	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+
+	if (remap_pfn_range(area, area->vm_start, phys_addr >> PAGE_SHIFT,
+			map_size, area->vm_page_prot) != 0) {
+		snd_stm_printe("Can't remap buffer!\n");
+		return -EAGAIN;
+	}
+
+	/* Must be called implicitly here... */
+	snd_pcm_mmap_data_open(area);
+
+	return 0;
+}
+
+
+
+/*
+ * Common ALSA parameters constraints
+ */
+
+/*
+#define FIXED_TRANSFER_BYTES max_transfer_bytes > 16 ? 16 : max_transfer_bytes
+#define FIXED_TRANSFER_BYTES max_transfer_bytes
+*/
+
+#if defined(FIXED_TRANSFER_BYTES)
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	int transfer_bytes = FIXED_TRANSFER_BYTES;
+
+	snd_stm_printd(1, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u (FIXED)\n",
+			bytes_per_frame, max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_constraint_step(runtime, 0,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_transfer_bytes(0, max_transfer_bytes));
+}
+
+#else
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	unsigned int transfer_bytes;
+
+	for (transfer_bytes = bytes_per_frame;
+			transfer_bytes * 2 < max_transfer_bytes;
+			transfer_bytes *= 2)
+		;
+
+	snd_stm_printd(2, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
+			max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+static int snd_stm_pcm_hw_rule_transfer_bytes(struct snd_pcm_hw_params *params,
+		struct snd_pcm_hw_rule *rule)
+{
+	int changed = 0;
+	unsigned int max_transfer_bytes = (unsigned int)rule->private;
+	struct snd_interval *period_bytes = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES);
+	struct snd_interval *frame_bits = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS);
+	unsigned int transfer_bytes, n;
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->min / 8,
+			max_transfer_bytes);
+	n = period_bytes->min % transfer_bytes;
+	if (n != 0 || period_bytes->openmin) {
+		period_bytes->min += transfer_bytes - n;
+		changed = 1;
+	}
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->max / 8,
+			max_transfer_bytes);
+	n = period_bytes->max % transfer_bytes;
+	if (n != 0 || period_bytes->openmax) {
+		period_bytes->max -= n;
+		changed = 1;
+	}
+
+	if (snd_interval_checkempty(period_bytes)) {
+		period_bytes->empty = 1;
+		return -EINVAL;
+	}
+
+	return changed;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_hw_rule_transfer_bytes,
+			(void *)max_transfer_bytes,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);
+}
+
+#endif
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_stm_ctl_boolean_info);
+
+int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+
+int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_CON_NOT_COPYRIGHT |
+			IEC958_AES0_CON_EMPHASIS |
+			IEC958_AES0_CON_MODE;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |
+			IEC958_AES1_CON_ORIGINAL;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_CON_SOURCE |
+			IEC958_AES2_CON_CHANNEL;
+	ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS |
+			IEC958_AES3_CON_CLOCK;
+	ucontrol->value.iec958.status[4] = IEC958_AES4_CON_MAX_WORDLEN_24 |
+			IEC958_AES4_CON_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PRO_EMPHASIS |
+			IEC958_AES0_PRO_FREQ_UNLOCKED |
+			IEC958_AES0_PRO_FS;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
+			IEC958_AES1_PRO_USERBITS;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_PRO_SBITS |
+			IEC958_AES2_PRO_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
+		const struct snd_aes_iec958 *b)
+{
+	int result;
+
+	snd_assert(a != NULL, return -EINVAL);
+	snd_assert(b != NULL, return -EINVAL);
+
+	result = memcmp(a->status, b->status, sizeof(a->status));
+	if (result == 0)
+		result = memcmp(a->subcode, b->subcode, sizeof(a->subcode));
+	if (result == 0)
+		result = memcmp(a->dig_subframe, b->dig_subframe,
+				sizeof(a->dig_subframe));
+
+	return result;
+}
+
+
+/*
+ * Debug features
+ */
+
+/* Memory dump function */
+
+void snd_stm_hex_dump(void *data, int size)
+{
+	unsigned char *buffer = data;
+	char line[57];
+	int i;
+
+	for (i = 0; i < size; i++) {
+		if (i % 16 == 0)
+			sprintf(line, "%p", data + i);
+		sprintf(line + 8 + ((i % 16) * 3), " %02x", *buffer++);
+		if (i % 16 == 15 || i == size - 1)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+}
+
+/* IEC958 structure dump */
+void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc)
+{
+	int i;
+	char line[54];
+	const unsigned char *data;
+
+	printk(KERN_DEBUG "                        "
+			"0  1  2  3  4  5  6  7  8  9\n");
+	data = vuc->status;
+	for (i = 0; i < 24; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p status    %02d:",
+					(unsigned char *)vuc + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 23)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	data = vuc->subcode;
+	for (i = 0; i < 147; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p subcode  %03d:",
+					(unsigned char *)vuc +
+					offsetof(struct snd_aes_iec958,
+					dig_subframe) + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 146)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	printk(KERN_DEBUG "%p dig_subframe: %02x %02x %02x %02x\n",
+			(unsigned char *)vuc +
+			offsetof(struct snd_aes_iec958, dig_subframe),
+			vuc->dig_subframe[0], vuc->dig_subframe[1],
+			vuc->dig_subframe[2], vuc->dig_subframe[3]);
+}
diff --git a/sound/stm/common.h b/sound/stm/common.h
new file mode 100644
index 0000000..8687701
--- /dev/null
+++ b/sound/stm/common.h
@@ -0,0 +1,395 @@
+/*
+ * STMicroelectronics' System-on-Chips audio subsystem commons
+ */
+
+#ifndef __SOUND_STM_COMMON_H
+#define __SOUND_STM_COMMON_H
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/stringify.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/stm.h>
+
+
+
+/*
+ * Frequency synthesizers control interface
+ */
+
+struct snd_stm_fsynth_channel;
+
+struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
+		int output);
+
+int snd_stm_fsynth_add_adjustement_ctl(
+		struct snd_stm_fsynth_channel *fsynth_channel,
+		struct snd_card *card, int card_device);
+
+int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+		int frequency);
+
+
+
+/*
+ * Converters (DAC, ADC, I2S-SPDIF etc.) control interface
+ */
+
+struct snd_stm_conv *snd_stm_conv_get_attached(struct bus_type *source_bus,
+		const char *source_bus_id);
+int snd_stm_conv_add_route_ctl(struct bus_type *source_bus,
+		const char *source_bus_id, struct snd_card *card,
+		int card_device);
+
+unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv);
+int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv);
+
+int snd_stm_conv_enable(struct snd_stm_conv *conv);
+int snd_stm_conv_disable(struct snd_stm_conv *conv);
+int snd_stm_conv_mute(struct snd_stm_conv *conv);
+int snd_stm_conv_unmute(struct snd_stm_conv *conv);
+
+
+
+/*
+ * Audio frequency synthesizer description (platform data)
+ */
+
+struct snd_stm_fsynth_info {
+	int ver;
+
+	int channels_from, channels_to;
+};
+
+
+
+/*
+ * Internal audio DAC description (platform data)
+ */
+
+struct snd_stm_conv_int_dac_info {
+	const char *name;
+	int ver;
+
+	int card_device;
+	const char *source_bus_id;
+};
+
+
+/*
+ * I2S to SPDIF converter description (platform data)
+ */
+
+struct snd_stm_conv_i2sspdif_info {
+	const char *name;
+	int ver;
+
+	int card_device;
+	const char *source_bus_id;
+};
+
+
+
+/*
+ * PCM Player description (platform data)
+ */
+
+struct snd_stm_pcm_player_info {
+	const char *name;
+	int ver;
+
+	int card_device;
+	const char *fsynth_bus_id;
+	int fsynth_output;
+
+	unsigned int channels;
+
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+};
+
+
+
+/*
+ * PCM Reader description (platform data)
+ */
+
+struct snd_stm_pcm_reader_info {
+	const char *name;
+	int ver;
+
+	int card_device;
+
+	int channels;
+
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+};
+
+
+
+/*
+ * SPDIF Player description (platform data)
+ */
+
+struct snd_stm_spdif_player_info {
+	const char *name;
+	int ver;
+
+	int card_device;
+	const char *fsynth_bus_id;
+	int fsynth_output;
+
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+};
+
+
+
+/*
+ * PCM buffer memory management
+ */
+
+struct snd_stm_buffer;
+
+struct snd_stm_buffer *snd_stm_buffer_create(struct snd_pcm *pcm,
+		struct device *device, int prealloc_size);
+void snd_stm_buffer_dispose(struct snd_stm_buffer *buffer);
+
+int snd_stm_buffer_is_allocated(struct snd_stm_buffer *buffer);
+
+int snd_stm_buffer_alloc(struct snd_stm_buffer *buffer,
+		struct snd_pcm_substream *substream, int size);
+void snd_stm_buffer_free(struct snd_stm_buffer *buffer);
+
+int snd_stm_buffer_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area);
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+
+int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+
+int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol);
+
+int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol);
+
+int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
+		const struct snd_aes_iec958 *b);
+
+
+
+/*
+ * Common ALSA parameters constraints
+ */
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes);
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes);
+
+
+
+/*
+ * Device management
+ */
+
+/* Add/remove a list of platform devices */
+int snd_stm_add_plaform_devices(struct platform_device **devices,
+		int cnt);
+void snd_stm_remove_plaform_devices(struct platform_device **devices,
+		int cnt);
+
+
+
+/*
+ * ALSA card management
+ */
+
+struct snd_card *snd_stm_card_new(int index, const char *id,
+		struct module *module);
+int snd_stm_card_register(void);
+void snd_stm_card_free(void);
+
+struct snd_card *snd_stm_card_get(void);
+
+
+
+/*
+ * ALSA procfs additional entries
+ */
+
+int snd_stm_info_create(void);
+void snd_stm_info_dispose(void);
+
+int snd_stm_info_register(struct snd_info_entry **entry,
+		const char *name,
+		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
+		void *private_data);
+void snd_stm_info_unregister(struct snd_info_entry *entry);
+
+
+
+/*
+ * Resources management
+ */
+
+int snd_stm_memory_request(struct platform_device *pdev,
+		struct resource **mem_region, void **base_address);
+void snd_stm_memory_release(struct resource *mem_region,
+		void *base_address);
+
+int snd_stm_irq_request(struct platform_device *pdev,
+		unsigned int *irq, irq_handler_t handler, void *dev_id);
+#define snd_stm_irq_release(irq, dev_id) free_irq(irq, dev_id)
+
+int snd_stm_fdma_request(struct platform_device *pdev,
+		unsigned int *channel);
+#define snd_stm_fdma_release(channel) free_dma(channel)
+
+
+
+/*
+ * Core drivers initialization/exit
+ */
+
+int snd_stm_fsynth_init(void);
+void snd_stm_fsynth_exit(void);
+
+int snd_stm_conv_init(void);
+void snd_stm_conv_exit(void);
+
+int snd_stm_conv_int_dac_init(void);
+void snd_stm_conv_int_dac_exit(void);
+
+int snd_stm_conv_i2sspdif_init(void);
+void snd_stm_conv_i2sspdif_exit(void);
+
+int snd_stm_pcm_player_init(void);
+void snd_stm_pcm_player_exit(void);
+
+int snd_stm_pcm_reader_init(void);
+void snd_stm_pcm_reader_exit(void);
+
+int snd_stm_spdif_player_init(void);
+void snd_stm_spdif_player_exit(void);
+
+int snd_stm_synchro_init(void);
+void snd_stm_synchro_exit(void);
+
+
+
+/*
+ * Debug features
+ */
+
+/* Data dump functions */
+
+void snd_stm_hex_dump(void *data, int size);
+void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc);
+
+/* Component name */
+
+#if !defined(COMPONENT)
+#error Please define COMPONENT name before including "common.h" !
+#endif
+static const char __maybe_unused *__snd_stm_component = __stringify(COMPONENT);
+
+/* Debug messages */
+
+#if defined(CONFIG_SND_DEBUG) || defined(DEBUG)
+
+#define ___concat(a, b) a##b
+#define __concat(a, b) ___concat(a, b)
+
+#if defined(DEBUG)
+static int __concat(debug_, COMPONENT) = DEBUG;
+#else
+static int __concat(debug_, COMPONENT) = -1;
+#endif
+module_param(__concat(debug_, COMPONENT), int, S_IRUGO | S_IWUSR);
+
+#if defined(CONFIG_SND_STM_DEBUG_LEVEL)
+extern int *snd_stm_debug_level;
+#define verbosity max(*snd_stm_debug_level, __concat(debug_, COMPONENT))
+#else
+#define verbosity __concat(debug_, COMPONENT)
+#endif
+
+#if defined(CONFIG_SND_VERBOSE_PRINTK)
+#define snd_stm_printd(level, format, args...) \
+		do { \
+			if (level <= verbosity) \
+				snd_printk(KERN_INFO format, ## args); \
+		} while (0)
+#else
+#define snd_stm_printd(level, format, args...) \
+		do { \
+			if (level <= verbosity) \
+				printk(KERN_INFO "snd-stm:%s:%d: " format, \
+						__snd_stm_component, \
+						__LINE__, ## args); \
+		} while (0)
+#endif
+
+#else
+
+#define snd_stm_printd(...) /* nothing */
+
+#endif
+
+/* Error messages */
+
+#if defined(CONFIG_SND_VERBOSE_PRINTK)
+#define snd_stm_printe(format, args...) \
+		snd_printk(KERN_ERR format, ## args)
+#else
+#define snd_stm_printe(format, args...) \
+		printk(KERN_ERR "snd-stm:%s:%d: " format, \
+				__snd_stm_component, __LINE__, ## args)
+#endif
+
+/* Magic value checking in device structures */
+
+#if defined(SND_DEBUG) || defined(DEBUG)
+
+#define snd_stm_magic ((&__snd_stm_component & 0xffff0000) >> 16 ^ \
+		(&__snd_stm_component & 0xffff))
+#define snd_stm_magic_good (0x600d0000 | snd_stm_magic)
+#define snd_stm_magic_bad (0xbaad0000 | snd_stm_magic)
+#define snd_stm_magic_field unsigned __snd_stm_magic
+#define snd_stm_magic_set(object) (object)->__magic = snd_stm_magic_good
+#define snd_stm_magic_clear(object) (object)->__magic = snd_stm_magic_bad
+#define snd_stm_magic_assert(object, args...) \
+		snd_assert((object)->__snd_stm_magic == \
+				snd_stm_magic_good, ## args)
+
+#else
+
+#	define snd_stm_magic_field /* nothing */
+#	define snd_stm_magic_set(object) /* nothing */
+#	define snd_stm_magic_clear(object) /* nothing */
+#	define snd_stm_magic_assert(object, args...) /* nothing */
+
+#endif
+
+
+
+#endif
diff --git a/sound/stm/conv.c b/sound/stm/conv.c
new file mode 100644
index 0000000..92b5c1e
--- /dev/null
+++ b/sound/stm/conv.c
@@ -0,0 +1,318 @@
+/*
+ *   STMicroelectronics System-on-Chips' generic converters infrastructure
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+
+#define COMPONENT conv
+#include "common.h"
+
+
+
+/*
+ * Converters infrastructure interface implementation
+ */
+
+#define CONVS_MAX 5 /* TODO: dynamic structure (really necessary???) */
+
+struct snd_stm_conv_links_list {
+	struct list_head list;
+
+	struct bus_type *bus;
+	char bus_id[BUS_ID_SIZE];
+
+	int convs_num;
+	struct snd_stm_conv *convs[CONVS_MAX];
+
+	int conv_attached;
+
+	snd_stm_magic_field;
+};
+
+LIST_HEAD(snd_stm_conv_links); /* "Device->Converter" links list */
+DEFINE_SPINLOCK(snd_stm_conv_links_lock); /* Synchronises the links list */
+
+static inline struct snd_stm_conv_links_list *snd_stm_conv_find_link(
+		struct bus_type *source_bus, const char *source_bus_id)
+{
+	struct snd_stm_conv_links_list *entry;
+
+	list_for_each_entry(entry, &snd_stm_conv_links, list)
+		if (source_bus == entry->bus &&
+				strcmp(source_bus_id, entry->bus_id) == 0)
+			return entry;
+
+	return NULL;
+}
+
+int snd_stm_conv_attach(struct snd_stm_conv *conv, struct bus_type *source_bus,
+		const char *source_bus_id)
+{
+	static int index;
+	struct snd_stm_conv_links_list *link =
+			snd_stm_conv_find_link(source_bus, source_bus_id);
+
+	snd_stm_printd(1, "snd_stm_conv_attach(conv=%p, source_bus=%p, "
+			"source_bus_id='%s')\n", conv, source_bus,
+			source_bus_id);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	if (link) { /* Known device */
+		snd_stm_magic_assert(link, return -EINVAL);
+		if (link->convs_num == CONVS_MAX)
+			return -ENOMEM;
+		link->convs[link->convs_num++] = conv;
+	} else { /* New device */
+		link = kzalloc(sizeof(*link), GFP_KERNEL);
+		if (link == NULL)
+			return -ENOMEM;
+		snd_stm_magic_set(link);
+
+		link->bus = source_bus;
+		strlcpy(link->bus_id, source_bus_id, BUS_ID_SIZE);
+		link->convs_num = 1;
+		link->convs[0] = conv;
+
+		list_add_tail(&link->list, &snd_stm_conv_links);
+	}
+
+	return index++;
+}
+EXPORT_SYMBOL(snd_stm_conv_attach);
+
+struct snd_stm_conv *snd_stm_conv_get_attached(struct bus_type *source_bus,
+		const char *source_bus_id)
+{
+	struct snd_stm_conv_links_list *link;
+	struct snd_stm_conv *conv = NULL;
+
+	snd_stm_printd(1, "snd_stm_conv_attach(source_bus=%p, source_bus_id=%s"
+			")\n", source_bus, source_bus_id);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	link = snd_stm_conv_find_link(source_bus, source_bus_id);
+	conv = link ? link->convs[link->conv_attached] : NULL;
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return conv;
+}
+
+static int snd_stm_conv_route_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+	struct snd_stm_conv *conv;
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = link->convs_num;
+
+	if (uinfo->value.enumerated.item >= link->convs_num)
+		uinfo->value.enumerated.item = link->convs_num - 1;
+
+	conv = link->convs[uinfo->value.enumerated.item];
+	snprintf(uinfo->value.enumerated.name, 64, "%s", conv->name);
+
+	return 0;
+}
+
+static int snd_stm_conv_route_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_conv_route_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	ucontrol->value.enumerated.item[0] = link->conv_attached;
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_route_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	int changed;
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_conv_route_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	changed = (ucontrol->value.enumerated.item[0] != link->conv_attached);
+	link->conv_attached = ucontrol->value.enumerated.item[0];
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_conv_route_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Playback Route",
+	.info = snd_stm_conv_route_info,
+	.get = snd_stm_conv_route_get,
+	.put = snd_stm_conv_route_put,
+};
+
+int snd_stm_conv_add_route_ctl(struct bus_type *source_bus,
+		const char *source_bus_id, struct snd_card *card,
+		int card_device)
+{
+	int result = 0;
+	struct snd_stm_conv_links_list *link =
+			snd_stm_conv_find_link(source_bus, source_bus_id);
+
+	snd_stm_printd(1, "snd_stm_conv_add_route_ctl(source_bus=%p, "
+			"source_bus_id='%s', card=%p, cards_device=%d)\n",
+			source_bus, source_bus_id, card, card_device);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	if (link != NULL) {
+		snd_stm_magic_assert(link, return -EINVAL);
+
+		if (link->convs_num > 1) {
+			snd_stm_conv_route_ctl.device = card_device;
+			result = snd_ctl_add(card,
+					snd_ctl_new1(&snd_stm_conv_route_ctl,
+					link));
+
+			snd_stm_conv_route_ctl.index++;
+		}
+	} else {
+		snd_stm_printd(0, "No converter is attached to '%s' (bus %p)"
+				"...\n", source_bus_id, source_bus);
+	}
+
+	return result;
+}
+
+
+
+/*
+ * Converter control interface implementation
+ */
+
+unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_get_format(conv=%p)\n", conv);
+
+	snd_assert(conv->get_format != NULL, return -EINVAL);
+
+	return conv->get_format(conv);
+}
+
+int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_get_oversampling(conv=%p)\n", conv);
+
+	snd_assert(conv->get_oversampling != NULL, return -EINVAL);
+
+	return conv->get_oversampling(conv);
+}
+
+int snd_stm_conv_enable(struct snd_stm_conv *conv)
+{
+	int result = 0;
+
+	snd_stm_printd(1, "snd_stm_conv_enable(conv=%p)\n", conv);
+
+	snd_assert(conv->enable != NULL, return -EINVAL);
+
+	if (conv->master)
+		result = snd_stm_conv_enable(conv->master);
+
+	return result ? result : conv->enable(conv);
+}
+
+int snd_stm_conv_disable(struct snd_stm_conv *conv)
+{
+	int result = 0;
+
+	snd_stm_printd(1, "snd_stm_conv_disable(conv=%p)\n", conv);
+
+	snd_assert(conv->disable != NULL, return -EINVAL);
+
+	if (conv->master)
+		result = snd_stm_conv_disable(conv->master);
+
+	return result ? result : conv->disable(conv);
+}
+
+int snd_stm_conv_mute(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_mute(conv=%p)\n", conv);
+
+	snd_assert(conv->mute != NULL, return -EINVAL);
+
+	return conv->mute(conv);
+}
+
+int snd_stm_conv_unmute(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv->unmute != NULL, return -EINVAL);
+
+	return conv->unmute(conv);
+}
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_init(void)
+{
+	return 0;
+}
+
+void snd_stm_conv_exit(void)
+{
+	struct snd_stm_conv_links_list *entry, *next;
+
+	list_for_each_entry_safe(entry, next, &snd_stm_conv_links, list) {
+		snd_stm_magic_clear(entry);
+		list_del(&entry->list);
+		kfree(entry);
+	};
+}
diff --git a/sound/stm/conv_dummy.c b/sound/stm/conv_dummy.c
new file mode 100644
index 0000000..c03eb09
--- /dev/null
+++ b/sound/stm/conv_dummy.c
@@ -0,0 +1,195 @@
+/*
+ *   STMicroelectronics System-on-Chips' dummy DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_dummy
+#include "common.h"
+
+
+
+/*
+ * Dummy converter instance structure
+ */
+
+struct snd_stm_conv_dummy {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	struct snd_stm_conv_dummy_info *info;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_dummy_get_format(struct snd_stm_conv
+		*conv)
+{
+	struct snd_stm_conv_dummy *conv_dummy = container_of(conv,
+			struct snd_stm_conv_dummy, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_dummy_get_format(conv=%p)\n", conv);
+
+	snd_assert(conv_dummy, return -EINVAL);
+	snd_stm_magic_assert(conv_dummy, return -EINVAL);
+
+	return conv_dummy->info->format;
+}
+
+static int snd_stm_conv_dummy_get_oversampling(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_dummy *conv_dummy = container_of(conv,
+			struct snd_stm_conv_dummy, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_dummy_get_oversampling(conv=%p)\n",
+			conv);
+
+	snd_assert(conv_dummy, return -EINVAL);
+	snd_stm_magic_assert(conv_dummy, return -EINVAL);
+
+	return conv_dummy->info->oversampling;
+}
+
+static int snd_stm_conv_dummy_enable(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_dummy_enable(conv=%p)\n", conv);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_disable(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_dummy_disable(conv=%p)\n", conv);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_mute(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_dummy_mute(conv=%p)\n", conv);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_unmute(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_dummy_unmute(conv=%p)\n", conv);
+
+	return 0;
+}
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_conv_dummy_probe(struct platform_device *pdev)
+{
+	int result;
+	struct snd_stm_conv_dummy *conv_dummy;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(pdev->dev.platform_data != NULL, return -EINVAL);
+
+	conv_dummy = kzalloc(sizeof(*conv_dummy), GFP_KERNEL);
+	if (!conv_dummy) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		return -ENOMEM;
+	}
+	snd_stm_magic_set(conv_dummy);
+	conv_dummy->info = pdev->dev.platform_data;
+
+	conv_dummy->conv.name = conv_dummy->info->name;
+	conv_dummy->conv.get_format = snd_stm_conv_dummy_get_format;
+	conv_dummy->conv.get_oversampling = snd_stm_conv_dummy_get_oversampling;
+	conv_dummy->conv.enable = snd_stm_conv_dummy_enable;
+	conv_dummy->conv.disable = snd_stm_conv_dummy_disable;
+	conv_dummy->conv.mute = snd_stm_conv_dummy_mute;
+	conv_dummy->conv.unmute = snd_stm_conv_dummy_unmute;
+
+	snd_stm_printd(0, "This dummy DAC is attached to PCM player '%s'.\n",
+			conv_dummy->info->source_bus_id);
+	result = snd_stm_conv_attach(&conv_dummy->conv, &platform_bus_type,
+			conv_dummy->info->source_bus_id);
+	if (result < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		return -EINVAL;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, conv_dummy);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_remove(struct platform_device *pdev)
+{
+	kfree(platform_get_drvdata(pdev));
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_dummy_driver = {
+	.driver = {
+		.name = "snd_conv_dummy",
+	},
+	.probe = snd_stm_conv_dummy_probe,
+	.remove = snd_stm_conv_dummy_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+static int __init snd_stm_conv_dummy_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_dummy_driver);
+}
+
+static void __exit snd_stm_conv_dummy_exit(void)
+{
+	platform_driver_unregister(&snd_stm_conv_dummy_driver);
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics dummy audio converter driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_conv_dummy_init);
+module_exit(snd_stm_conv_dummy_exit);
diff --git a/sound/stm/conv_gpio.c b/sound/stm/conv_gpio.c
new file mode 100644
index 0000000..d265778
--- /dev/null
+++ b/sound/stm/conv_gpio.c
@@ -0,0 +1,602 @@
+/*
+ *   STMicroelectronics System-on-Chips' GPIO-controlled ADC/DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_gpio
+#include "common.h"
+
+
+
+/*
+ * Internal DAC instance structure
+ */
+
+struct snd_stm_conv_gpio {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	/* System informations */
+	const char *bus_id;
+	struct snd_stm_conv_gpio_info *info;
+
+	/* Runtime data */
+	int enabled;
+	int muted_by_source;
+	int muted_by_user;
+	spinlock_t status_lock; /* Protects enabled & muted_by_* */
+	int may_sleep;
+	struct work_struct work; /* Used if may_sleep */
+	int work_enable_value;
+	int work_mute_value;
+	spinlock_t work_lock; /* Protects work_*_value */
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Sleeping-safe GPIO access implementation
+ */
+
+static void snd_stm_conv_gpio_work(struct work_struct *work)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(work,
+			struct snd_stm_conv_gpio, work);
+	int enable_value, mute_value;
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_work(work=%p)\n", work);
+
+	snd_assert(conv_gpio, return);
+	snd_stm_magic_assert(conv_gpio, return);
+
+	spin_lock(&conv_gpio->work_lock);
+
+	enable_value = conv_gpio->work_enable_value;
+	conv_gpio->work_enable_value = -1;
+
+	mute_value = conv_gpio->work_mute_value;
+	conv_gpio->work_mute_value = -1;
+
+	spin_unlock(&conv_gpio->work_lock);
+
+	if (enable_value != -1)
+		gpio_set_value(conv_gpio->info->enable_gpio, enable_value);
+
+	if (mute_value != -1)
+		gpio_set_value(conv_gpio->info->mute_gpio, mute_value);
+}
+
+static void snd_stm_conv_gpio_set_value(struct snd_stm_conv_gpio *conv_gpio,
+		int enable_not_mute, int value)
+{
+	snd_stm_printd(1, "snd_stm_conv_gpio_set_value(conv_gpio=%p, "
+			"enable_not_mute=%d, value=%d)\n",
+			conv_gpio, enable_not_mute, value);
+
+	snd_assert(conv_gpio, return);
+	snd_stm_magic_assert(conv_gpio, return);
+
+	if (conv_gpio->may_sleep) {
+		spin_lock(&conv_gpio->work_lock);
+		if (enable_not_mute)
+			conv_gpio->work_enable_value = value;
+		else
+			conv_gpio->work_mute_value = value;
+		schedule_work(&conv_gpio->work);
+		spin_unlock(&conv_gpio->work_lock);
+	} else {
+		gpio_set_value(enable_not_mute ? conv_gpio->info->enable_gpio :
+				conv_gpio->info->mute_gpio, value);
+	}
+}
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_gpio_get_format(struct snd_stm_conv
+		*conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_get_format(conv=%p)\n", conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+
+	return conv_gpio->info->format;
+}
+
+static int snd_stm_conv_gpio_get_oversampling(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_get_oversampling(conv=%p)\n",
+			conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+
+	return conv_gpio->info->oversampling;
+}
+
+static int snd_stm_conv_gpio_enable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_enable(conv=%p)\n", conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(!conv_gpio->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Enabling DAC %s's digital part. (still muted)\n",
+			conv_gpio->bus_id);
+
+	spin_lock(&conv_gpio->status_lock);
+
+	snd_stm_conv_gpio_set_value(conv_gpio, 1,
+			conv_gpio->info->enable_value);
+	conv_gpio->enabled = 1;
+
+	spin_unlock(&conv_gpio->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_gpio_disable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_disable(conv=%p)\n", conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(conv_gpio->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Disabling DAC %s's digital part.\n",
+			conv_gpio->bus_id);
+
+	spin_lock(&conv_gpio->status_lock);
+
+	snd_stm_conv_gpio_set_value(conv_gpio, 1,
+			!conv_gpio->info->enable_value);
+	conv_gpio->enabled = 0;
+
+	spin_unlock(&conv_gpio->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_gpio_mute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_mute(conv=%p)\n", conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(conv_gpio->enabled, return -EINVAL);
+
+	if (conv_gpio->info->mute_supported) {
+		snd_stm_printd(1, "Muting DAC %s.\n", conv_gpio->bus_id);
+
+		spin_lock(&conv_gpio->status_lock);
+
+		conv_gpio->muted_by_source = 1;
+		if (!conv_gpio->muted_by_user)
+			snd_stm_conv_gpio_set_value(conv_gpio, 0,
+					conv_gpio->info->mute_value);
+
+		spin_unlock(&conv_gpio->status_lock);
+	}
+
+	return 0;
+}
+
+static int snd_stm_conv_gpio_unmute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_gpio *conv_gpio = container_of(conv,
+			struct snd_stm_conv_gpio, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(conv_gpio->enabled, return -EINVAL);
+
+	if (conv_gpio->info->mute_supported) {
+		snd_stm_printd(1, "Unmuting DAC %s.\n", conv_gpio->bus_id);
+
+		spin_lock(&conv_gpio->status_lock);
+
+		conv_gpio->muted_by_source = 0;
+		if (!conv_gpio->muted_by_user)
+			snd_stm_conv_gpio_set_value(conv_gpio, 0,
+					!conv_gpio->info->mute_value);
+
+		spin_unlock(&conv_gpio->status_lock);
+	}
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_conv_gpio_ctl_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+			snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_ctl_mute_get(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+
+	spin_lock(&conv_gpio->status_lock);
+
+	ucontrol->value.integer.value[0] = !conv_gpio->muted_by_user;
+
+	spin_unlock(&conv_gpio->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_gpio_ctl_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+			snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_conv_gpio_ctl_mute_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+
+	spin_lock(&conv_gpio->status_lock);
+
+	if (ucontrol->value.integer.value[0] !=
+			!conv_gpio->muted_by_user) {
+		changed = 1;
+
+		conv_gpio->muted_by_user =
+				!ucontrol->value.integer.value[0];
+
+		if (conv_gpio->enabled &&
+				conv_gpio->muted_by_user &&
+				!conv_gpio->muted_by_source)
+			snd_stm_conv_gpio_set_value(conv_gpio, 0,
+					conv_gpio->info->mute_value);
+		else if (conv_gpio->enabled &&
+				!conv_gpio->muted_by_user &&
+				!conv_gpio->muted_by_source)
+			snd_stm_conv_gpio_set_value(conv_gpio, 0,
+					!conv_gpio->info->mute_value);
+	}
+
+	spin_unlock(&conv_gpio->status_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_conv_gpio_ctl_mute = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master Playback Switch",
+	.info = snd_stm_ctl_boolean_info,
+	.get = snd_stm_conv_gpio_ctl_mute_get,
+	.put = snd_stm_conv_gpio_ctl_mute_put,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_conv_gpio_read_info(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+		entry->private_data;
+
+	snd_assert(conv_gpio, return);
+	snd_stm_magic_assert(conv_gpio, return);
+
+	snd_iprintf(buffer, "enable_gpio(%d) = %d\n",
+			conv_gpio->info->enable_gpio,
+			gpio_get_value(conv_gpio->info->enable_gpio));
+	if (conv_gpio->info->mute_supported)
+		snd_iprintf(buffer, "mute_gpio(%d) = %d\n",
+				conv_gpio->info->mute_gpio,
+				gpio_get_value(conv_gpio->info->mute_gpio));
+
+	snd_iprintf(buffer, "enabled = %d\n", conv_gpio->enabled);
+	snd_iprintf(buffer, "muted_by_source = %d\n",
+			conv_gpio->muted_by_source);
+	snd_iprintf(buffer, "muted_by_user = %d\n", conv_gpio->muted_by_user);
+}
+
+static int snd_stm_conv_gpio_register(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+			snd_device->device_data;
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(!conv_gpio->enabled, return -EINVAL);
+
+	/* Initialize DAC disabled and mute */
+
+	conv_gpio->enabled = 0;
+	conv_gpio->muted_by_source = 1;
+	gpio_set_value(conv_gpio->info->enable_gpio,
+			!conv_gpio->info->enable_value);
+	if (conv_gpio->info->mute_supported)
+		gpio_set_value(conv_gpio->info->mute_gpio,
+				conv_gpio->info->mute_value);
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_gpio->proc_entry,
+			conv_gpio->bus_id,
+			snd_stm_conv_gpio_read_info,
+			conv_gpio);
+
+	return 0;
+}
+
+static int snd_stm_conv_gpio_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+			snd_device->device_data;
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+	snd_assert(!conv_gpio->enabled, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_gpio->proc_entry);
+
+	/* Muting and disabling - just to be sure ;-) */
+
+	if (conv_gpio->info->mute_supported)
+		gpio_set_value(conv_gpio->info->mute_gpio,
+				conv_gpio->info->mute_value);
+	gpio_set_value(conv_gpio->info->enable_gpio,
+			!conv_gpio->info->enable_value);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_gpio_snd_device_ops = {
+	.dev_register = snd_stm_conv_gpio_register,
+	.dev_disconnect = snd_stm_conv_gpio_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_conv_gpio_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_gpio *conv_gpio;
+	struct snd_card *card = snd_stm_card_get();
+	int index;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card, return -EINVAL);
+	snd_assert(pdev->dev.platform_data != NULL, return -EINVAL);
+
+	conv_gpio = kzalloc(sizeof(*conv_gpio), GFP_KERNEL);
+	if (!conv_gpio) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_gpio);
+	conv_gpio->bus_id = pdev->dev.bus_id;
+	conv_gpio->info = pdev->dev.platform_data;
+	spin_lock_init(&conv_gpio->status_lock);
+
+	/* Converter interface initialization */
+
+	conv_gpio->conv.name = conv_gpio->info->name;
+	conv_gpio->conv.get_format =
+			snd_stm_conv_gpio_get_format;
+	conv_gpio->conv.get_oversampling =
+			snd_stm_conv_gpio_get_oversampling;
+	conv_gpio->conv.enable = snd_stm_conv_gpio_enable;
+	conv_gpio->conv.disable = snd_stm_conv_gpio_disable;
+	conv_gpio->conv.mute = snd_stm_conv_gpio_mute;
+	conv_gpio->conv.unmute = snd_stm_conv_gpio_unmute;
+
+	/* Get connections */
+
+	snd_assert(conv_gpio->info->source_bus_id != NULL,
+			return -EINVAL);
+	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
+			conv_gpio->info->source_bus_id);
+	index = snd_stm_conv_attach(&conv_gpio->conv, &platform_bus_type,
+			conv_gpio->info->source_bus_id);
+	if (index < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		result = index;
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_gpio,
+			&snd_stm_conv_gpio_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Reserve GPIO lines */
+
+	result = gpio_request(conv_gpio->info->enable_gpio, conv_gpio->bus_id);
+	if (result != 0) {
+		snd_stm_printe("Can't reserve 'enable' GPIO line!\n");
+		goto error_gpio_request_enable;
+	}
+
+	if (conv_gpio->info->mute_supported) {
+		result = gpio_request(conv_gpio->info->mute_gpio,
+				conv_gpio->bus_id);
+		if (result != 0) {
+			snd_stm_printe("Can't reserve 'mute' GPIO line!\n");
+			goto error_gpio_request_mute;
+		}
+	}
+	if (gpio_cansleep(conv_gpio->info->enable_gpio) ||
+			(conv_gpio->info->mute_supported &&
+			gpio_cansleep(conv_gpio->info->mute_gpio))) {
+		conv_gpio->may_sleep = 1;
+		INIT_WORK(&conv_gpio->work, snd_stm_conv_gpio_work);
+		spin_lock_init(&conv_gpio->work_lock);
+		conv_gpio->work_enable_value = -1;
+		conv_gpio->work_mute_value = -1;
+	}
+
+	/* Create ALSA control */
+
+	if (conv_gpio->info->mute_supported) {
+		snd_stm_conv_gpio_ctl_mute.device =
+			conv_gpio->info->card_device;
+		snd_stm_conv_gpio_ctl_mute.index = index;
+		result = snd_ctl_add(card,
+				snd_ctl_new1(&snd_stm_conv_gpio_ctl_mute,
+				conv_gpio));
+		if (result < 0) {
+			snd_stm_printe("Failed to add all ALSA control!\n");
+			goto error_control;
+		}
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, &conv_gpio->conv);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_control:
+	if (conv_gpio->info->mute_supported)
+		gpio_free(conv_gpio->info->mute_gpio);
+error_gpio_request_mute:
+	gpio_free(conv_gpio->info->enable_gpio);
+error_gpio_request_enable:
+error_device:
+error_attach:
+	snd_stm_magic_clear(conv_gpio);
+	kfree(conv_gpio);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_gpio_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_gpio *conv_gpio =
+			container_of(platform_get_drvdata(pdev),
+			struct snd_stm_conv_gpio, conv);
+
+	snd_assert(conv_gpio, return -EINVAL);
+	snd_stm_magic_assert(conv_gpio, return -EINVAL);
+
+	if (conv_gpio->info->mute_supported)
+		gpio_free(conv_gpio->info->mute_gpio);
+	gpio_free(conv_gpio->info->enable_gpio);
+
+	snd_stm_magic_clear(conv_gpio);
+	kfree(conv_gpio);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_gpio_driver = {
+	.driver = {
+		.name = "snd_conv_gpio",
+	},
+	.probe = snd_stm_conv_gpio_probe,
+	.remove = snd_stm_conv_gpio_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+static int __init snd_stm_conv_gpio_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_gpio_driver);
+}
+
+static void __exit snd_stm_conv_gpio_exit(void)
+{
+	platform_driver_unregister(&snd_stm_conv_gpio_driver);
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics GPIO-controlled audio converter driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_conv_gpio_init);
+module_exit(snd_stm_conv_gpio_exit);
diff --git a/sound/stm/conv_i2c.c b/sound/stm/conv_i2c.c
new file mode 100644
index 0000000..bc718f5
--- /dev/null
+++ b/sound/stm/conv_i2c.c
@@ -0,0 +1,65 @@
+/*
+ *   STMicroelectronics System-on-Chips' I2C-controlled ADC/DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_i2c
+#include "common.h"
+
+
+
+/*
+ * Implementation
+ */
+
+/* TODO */
+
+
+
+/*
+ * Initialization
+ */
+
+static int __init snd_stm_conv_i2c_init(void)
+{
+	return 0;
+}
+
+static void __exit snd_stm_conv_i2c_exit(void)
+{
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics I2C-controlled audio converter driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_conv_i2c_init);
+module_exit(snd_stm_conv_i2c_exit);
diff --git a/sound/stm/conv_i2sspdif.c b/sound/stm/conv_i2sspdif.c
new file mode 100644
index 0000000..10b89fa
--- /dev/null
+++ b/sound/stm/conv_i2sspdif.c
@@ -0,0 +1,746 @@
+/*
+ *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_i2sspdif
+#include "common.h"
+#include "reg_aud_spdifpc.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define DEFAULT_OVERSAMPLING 128
+
+
+
+/*
+ * Converter instance structure
+ */
+
+struct snd_stm_conv_i2sspdif {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	/* System informations */
+	struct snd_stm_conv_i2sspdif_info *info;
+	struct device *device;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Default configuration */
+	struct snd_aes_iec958 iec958_default;
+	spinlock_t iec958_default_lock; /* Protects iec958_default */
+
+	/* Runtime data */
+	int enabled;
+	struct snd_stm_conv *attached_conv;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Internal routines
+ */
+
+/* Such a empty (zeroed) structure is pretty useful later... ;-) */
+static struct snd_aes_iec958 snd_stm_conv_i2sspdif_iec958_zeroed;
+
+
+
+#define CHA_STA_TRIES 50000
+
+static int snd_stm_conv_i2sspdif_iec958_set(struct snd_stm_conv_i2sspdif
+		*conv_i2sspdif, struct snd_aes_iec958 *iec958)
+{
+	int i, j, ok;
+	unsigned long status[6];
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif=%p"
+			", iec958=%p)\n", conv_i2sspdif, iec958);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+
+	/* I2S to SPDIF converter should be used only for playing
+	 * PCM (non compressed) data, so validity bit should be always
+	 * zero... (it means "valid linear PCM data") */
+	set__AUD_SPDIFPC_VAL__VALIDITY_BITS(conv_i2sspdif, 0);
+
+	/* Well... User data bit... Frankly speaking there is no way
+	 * of correctly setting them with a mechanism provided by
+	 * converter hardware, so it is better not to do this at all... */
+	set__AUD_SPDIFPC_DATA__USER_DATA_BITS(conv_i2sspdif, 0);
+
+	snd_assert(memcmp(snd_stm_conv_i2sspdif_iec958_zeroed.subcode,
+			iec958->subcode, sizeof(iec958->subcode)) == 0);
+
+	if (conv_i2sspdif->ver < ver__AUD_SPDIFPC__65_3_0) {
+		/* Converter hardware by default puts every single bit of
+		 * status to separate SPDIF subframe (instead of putting
+		 * the same bit to both left and right subframes).
+		 * So we have to prepare a "duplicated" version of
+		 * status bits... Note that in such way status will be
+		 * transmitted twice in every block! This is definitely
+		 * out of spec, but fortunately most of receivers pay
+		 * attention only to first 36 bits... */
+
+		for (i = 0; i < 6; i++) {
+			unsigned long word = 0;
+
+			for (j = 1; j >= 0; j--) {
+				unsigned char byte = iec958->status[i * 2 + j];
+				int k;
+
+				for (k = 0; k < 8; k++) {
+					word |= ((byte & 0x80) != 0);
+					if (!(j == 0 && k == 7)) {
+						word <<= 2;
+						byte <<= 1;
+					}
+				}
+			}
+
+			status[i] = word | (word << 1);
+		}
+	} else {
+		/* Fortunately in some hardware there is a "sane" mode
+		 * of channel status registers operation... :-) */
+
+		for (i = 0; i < 6; i++)
+			status[i] = iec958->status[i * 4] |
+					iec958->status[i * 4 + 1] << 8 |
+					iec958->status[i * 4 + 2] << 16 |
+					iec958->status[i * 4 + 3] << 24;
+	}
+
+	/* Set converter's channel status registers - they are realised
+	 * in such a ridiculous way that write to them is enabled only
+	 * in (about) 300us time window after CHL_STS_BUFF_EMPTY bit
+	 * is asserted... And this happens once every 2ms (only when
+	 * converter is enabled and gets data...) */
+
+	ok = 0;
+	for (i = 0; i < CHA_STA_TRIES; i++) {
+		if (get__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(conv_i2sspdif)) {
+			for (j = 0; j < 6; j++)
+				set__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, j,
+						status[j]);
+			ok = 1;
+			for (j = 0; j < 6; j++)
+				if (get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif,
+						j) != status[j]) {
+					ok = 0;
+					break;
+				}
+			if (ok)
+				break;
+		}
+	}
+	if (!ok) {
+		snd_stm_printe("WARNING! Failed to set channel status registers"
+				" for converter %s! (tried %d times)\n",
+				conv_i2sspdif->device->bus_id, i);
+		return -EINVAL;
+	}
+
+	snd_stm_printd(1, "Channel status registers set successfully "
+			"in %i tries.", i);
+
+	/* Set SPDIF player's VUC registers (these are used only
+	 * for mute data formatting, and it should never happen ;-) */
+
+	set__AUD_SPDIFPC_SUV__VAL_LEFT(conv_i2sspdif, 0);
+	set__AUD_SPDIFPC_SUV__VAL_RIGHT(conv_i2sspdif, 0);
+
+	set__AUD_SPDIFPC_SUV__DATA_LEFT(conv_i2sspdif, 0);
+	set__AUD_SPDIFPC_SUV__DATA_RIGHT(conv_i2sspdif, 0);
+
+	/* And this time the problem is that SPDIF player lets
+	 * to set only first 36 bits of channel status bits...
+	 * Hopefully no one needs more ever ;-) And well - at least
+	 * it puts channel status bits to both subframes :-) */
+	status[0] = iec958->status[0] | iec958->status[1] << 8 |
+		iec958->status[2] << 16 | iec958->status[3] << 24;
+	set__AUD_SPDIFPC_CL1__CHANNEL_STATUS(conv_i2sspdif, status[0]);
+	set__AUD_SPDIFPC_SUV__CH_STA_LEFT(conv_i2sspdif,
+			iec958->status[4] & 0xf);
+	set__AUD_SPDIFPC_CR1__CH_STA(conv_i2sspdif, status[0]);
+	set__AUD_SPDIFPC_SUV__CH_STA_RIGHT(conv_i2sspdif,
+			iec958->status[4] & 0xf);
+
+	return 0;
+}
+
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_i2sspdif_get_format(struct snd_stm_conv
+		*conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_format(conv=%p)\n", conv);
+
+	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS);
+}
+
+static int snd_stm_conv_i2sspdif_get_oversampling(struct snd_stm_conv *conv)
+{
+	int oversampling = 0;
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = container_of(conv,
+			struct snd_stm_conv_i2sspdif, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_oversampling(conv=%p)\n",
+			conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+
+	if (conv_i2sspdif->attached_conv)
+		oversampling = snd_stm_conv_get_oversampling(
+				conv_i2sspdif->attached_conv);
+
+	if (oversampling == 0)
+		oversampling = DEFAULT_OVERSAMPLING;
+
+	return oversampling;
+}
+
+static int snd_stm_conv_i2sspdif_enable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = container_of(conv,
+			struct snd_stm_conv_i2sspdif, conv);
+	int oversampling;
+	struct snd_aes_iec958 iec958;
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_enable(conv=%p)\n", conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(!conv_i2sspdif->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Enabling I2S to SPDIF converter '%s'.\n",
+			conv_i2sspdif->device->bus_id);
+
+	conv_i2sspdif->attached_conv =
+			snd_stm_conv_get_attached(&platform_bus_type,
+			conv_i2sspdif->device->bus_id);
+	if (conv_i2sspdif->attached_conv) {
+		int result = snd_stm_conv_enable(conv_i2sspdif->attached_conv);
+		if (result != 0) {
+			snd_stm_printe("Can't enable attached converter!\n");
+			return result;
+		}
+	}
+
+	oversampling = snd_stm_conv_i2sspdif_get_oversampling(conv);
+	snd_assert(oversampling > 0, return -EINVAL);
+	snd_assert((oversampling % 128) == 0, return -EINVAL);
+
+	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(conv_i2sspdif)
+		| mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(conv_i2sspdif));
+	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CTRL__OPERATION__PCM(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(conv_i2sspdif));
+	set__AUD_SPDIFPC_CTRL__DIVIDER(conv_i2sspdif, oversampling / 128);
+
+	/* Full channel status processing - an undocumented feature that
+	 * exists in some hardware... Normally channel status registers
+	 * provides bits for each subframe, so only for 96 frames (a half
+	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
+	 * enables a mode in which channel status bits in L/R subframes
+	 * are identical, and whole block is served... */
+	if (conv_i2sspdif->ver >= ver__AUD_SPDIFPC__65_3_0)
+		set__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(conv_i2sspdif);
+
+	spin_lock(&conv_i2sspdif->iec958_default_lock);
+	iec958 = conv_i2sspdif->iec958_default;
+	spin_unlock(&conv_i2sspdif->iec958_default_lock);
+	if (snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif, &iec958) != 0)
+		snd_stm_printe("WARNING! Can't set channel status "
+				"registers!\n");
+
+	conv_i2sspdif->enabled = 1;
+
+	return 0;
+}
+
+static int snd_stm_conv_i2sspdif_disable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = container_of(conv,
+			struct snd_stm_conv_i2sspdif, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disable(conv=%p)\n", conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(conv_i2sspdif->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Disabling I2S to SPDIF converter '%s'\n",
+			conv_i2sspdif->device->bus_id);
+
+	if (conv_i2sspdif->attached_conv) {
+		int result = snd_stm_conv_disable(
+				conv_i2sspdif->attached_conv);
+
+		if (result != 0) {
+			snd_stm_printe("Can't disable attached converter!\n");
+			return result;
+		}
+	}
+
+	if (snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif,
+			&snd_stm_conv_i2sspdif_iec958_zeroed) != 0)
+		snd_stm_printe("WARNING! Failed to clear channel status "
+				"registers!\n");
+
+	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
+	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
+
+	conv_i2sspdif->enabled = 0;
+
+	return 0;
+}
+
+static int snd_stm_conv_i2sspdif_mute(struct snd_stm_conv *conv)
+{
+	int result = 0;
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = container_of(conv,
+			struct snd_stm_conv_i2sspdif, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_mute(conv=%p)\n", conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(conv_i2sspdif->enabled, return -EINVAL);
+
+	if (conv_i2sspdif->attached_conv)
+		result = snd_stm_conv_mute(conv_i2sspdif->attached_conv);
+
+	return result;
+}
+
+static int snd_stm_conv_i2sspdif_unmute(struct snd_stm_conv *conv)
+{
+	int result = 0;
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = container_of(conv,
+			struct snd_stm_conv_i2sspdif, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(conv_i2sspdif->enabled, return -EINVAL);
+
+	if (conv_i2sspdif->attached_conv)
+		result = snd_stm_conv_unmute(conv_i2sspdif->attached_conv);
+
+	return result;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_conv_i2sspdif_ctl_default_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
+			snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+
+	spin_lock(&conv_i2sspdif->iec958_default_lock);
+	ucontrol->value.iec958 = conv_i2sspdif->iec958_default;
+	spin_unlock(&conv_i2sspdif->iec958_default_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_i2sspdif_ctl_default_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
+			snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+
+	spin_lock(&conv_i2sspdif->iec958_default_lock);
+	if (snd_stm_iec958_cmp(&conv_i2sspdif->iec958_default,
+				&ucontrol->value.iec958) != 0) {
+		conv_i2sspdif->iec958_default = ucontrol->value.iec958;
+		changed = 1;
+	}
+	spin_unlock(&conv_i2sspdif->iec958_default_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_conv_i2sspdif_ctls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_iec958_info,
+		.get = snd_stm_conv_i2sspdif_ctl_default_get,
+		.put = snd_stm_conv_i2sspdif_ctl_default_put,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_con,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_pro,
+	},
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_SPDIFPC_%s (offset 0x%03x) =" \
+				" 0x%08x\n", __stringify(r), \
+				offset__AUD_SPDIFPC_##r(conv_i2sspdif), \
+				get__AUD_SPDIFPC_##r(conv_i2sspdif))
+
+static void snd_stm_conv_i2sspdif_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
+		entry->private_data;
+	int i;
+
+	snd_assert(conv_i2sspdif, return);
+	snd_stm_magic_assert(conv_i2sspdif, return);
+
+	DUMP_REGISTER(CFG);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(IT_CLR);
+	DUMP_REGISTER(VAL);
+	DUMP_REGISTER(DATA);
+	for (i = 0; i <= 5; i++)
+		snd_iprintf(buffer, "AUD_SPDIFPC_CHA_STA%d_CHANNEL_STATUS_BITS"
+				" (offset 0x%03x) = 0x%08x\n", i,
+				offset__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, i),
+				get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, i));
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(SPDIFSTA);
+	DUMP_REGISTER(PAUSE);
+	DUMP_REGISTER(DATA_BURST);
+	DUMP_REGISTER(PA_PB);
+	DUMP_REGISTER(PC_PD);
+	DUMP_REGISTER(CL1);
+	DUMP_REGISTER(CR1);
+	DUMP_REGISTER(SUV);
+}
+
+static int snd_stm_conv_i2sspdif_register(
+		struct snd_device *snd_device)
+{
+	int result;
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(!conv_i2sspdif->enabled, return -EINVAL);
+
+	snd_stm_printd(0, "--- Registering I2S to SPDIF converter '%s'...\n",
+			conv_i2sspdif->device->bus_id);
+
+	/* Initialize converter's input & SPDIF player as disabled */
+
+	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
+
+	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_i2sspdif->proc_entry,
+			conv_i2sspdif->device->bus_id,
+			snd_stm_conv_i2sspdif_dump_registers,
+			conv_i2sspdif);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(&platform_bus_type,
+			conv_i2sspdif->device->bus_id, snd_device->card,
+			conv_i2sspdif->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_conv_i2sspdif_disconnect(
+		struct snd_device *snd_device)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disconnect(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+	snd_assert(!conv_i2sspdif->enabled, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_i2sspdif->proc_entry);
+
+	/* Power done mode, just to be sure :-) */
+
+	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
+		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
+
+	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
+		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_i2sspdif_snd_device_ops = {
+	.dev_register = snd_stm_conv_i2sspdif_register,
+	.dev_disconnect = snd_stm_conv_i2sspdif_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_conv_i2sspdif_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_i2sspdif_info *conv_i2sspdif_info =
+			pdev->dev.platform_data;
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif;
+	struct snd_card *card = snd_stm_card_get();
+	int index;
+	int i;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card, return -EINVAL);
+	snd_assert(conv_i2sspdif_info != NULL, return -EINVAL);
+
+	conv_i2sspdif = kzalloc(sizeof(*conv_i2sspdif), GFP_KERNEL);
+	if (!conv_i2sspdif) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_i2sspdif);
+	conv_i2sspdif->ver = conv_i2sspdif_info->ver;
+	snd_assert(conv_i2sspdif->ver > 0, return -EINVAL);
+	conv_i2sspdif->info = conv_i2sspdif_info;
+	conv_i2sspdif->device = &pdev->dev;
+	spin_lock_init(&conv_i2sspdif->iec958_default_lock);
+
+	/* Converter interface initialization */
+
+	conv_i2sspdif->conv.name = conv_i2sspdif_info->name;
+	conv_i2sspdif->conv.get_format = snd_stm_conv_i2sspdif_get_format;
+	conv_i2sspdif->conv.get_oversampling =
+			snd_stm_conv_i2sspdif_get_oversampling;
+	conv_i2sspdif->conv.enable = snd_stm_conv_i2sspdif_enable;
+	conv_i2sspdif->conv.disable = snd_stm_conv_i2sspdif_disable;
+	conv_i2sspdif->conv.mute = snd_stm_conv_i2sspdif_mute;
+	conv_i2sspdif->conv.unmute = snd_stm_conv_i2sspdif_unmute;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &conv_i2sspdif->mem_region,
+			&conv_i2sspdif->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* Get connections */
+
+	snd_assert(conv_i2sspdif_info->source_bus_id != NULL,
+			return -EINVAL);
+	snd_stm_printd(0, "This I2S-SPDIF converter is attached to PCM player"
+			" '%s'.\n",
+			conv_i2sspdif_info->source_bus_id);
+	index = snd_stm_conv_attach(&conv_i2sspdif->conv, &platform_bus_type,
+			conv_i2sspdif_info->source_bus_id);
+	if (index < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		result = index;
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_i2sspdif,
+			&snd_stm_conv_i2sspdif_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA controls */
+
+	result = 0;
+	for (i = 0; i < ARRAY_SIZE(snd_stm_conv_i2sspdif_ctls); i++) {
+		snd_stm_conv_i2sspdif_ctls[i].device =
+				conv_i2sspdif->info->card_device;
+		snd_stm_conv_i2sspdif_ctls[i].index = index;
+		result |= snd_ctl_add(card,
+				snd_ctl_new1(&snd_stm_conv_i2sspdif_ctls[i],
+				conv_i2sspdif));
+	}
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA controls!\n");
+		goto error_controls;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, &conv_i2sspdif->conv);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_controls:
+error_device:
+error_attach:
+	snd_stm_memory_release(conv_i2sspdif->mem_region,
+			conv_i2sspdif->base);
+error_memory_request:
+	snd_stm_magic_clear(conv_i2sspdif);
+	kfree(conv_i2sspdif);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_i2sspdif_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
+			container_of(platform_get_drvdata(pdev),
+			struct snd_stm_conv_i2sspdif, conv);
+
+	snd_assert(conv_i2sspdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
+
+	snd_stm_memory_release(conv_i2sspdif->mem_region,
+			conv_i2sspdif->base);
+
+	snd_stm_magic_clear(conv_i2sspdif);
+	kfree(conv_i2sspdif);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_i2sspdif_driver = {
+	.driver = {
+		.name = "snd_conv_i2sspdif",
+	},
+	.probe = snd_stm_conv_i2sspdif_probe,
+	.remove = snd_stm_conv_i2sspdif_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_i2sspdif_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_i2sspdif_driver);
+}
+
+void snd_stm_conv_i2sspdif_exit(void)
+{
+	platform_driver_unregister(&snd_stm_conv_i2sspdif_driver);
+}
diff --git a/sound/stm/conv_int_dac.c b/sound/stm/conv_int_dac.c
new file mode 100644
index 0000000..9ec10b3
--- /dev/null
+++ b/sound/stm/conv_int_dac.c
@@ -0,0 +1,507 @@
+/*
+ *   STMicroelectronics System-on-Chips' internal audio DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_int_dac
+#include "common.h"
+#include "reg_audcfg_adac.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS)
+#define OVERSAMPLING 256
+
+
+
+/*
+ * Internal DAC instance structure
+ */
+
+struct snd_stm_conv_int_dac {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	/* System informations */
+	const char *bus_id;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Runtime data */
+	int enabled;
+	int muted_by_source;
+	int muted_by_user;
+	spinlock_t status_lock; /* Protects enabled & muted_by_* */
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_int_dac_get_format(struct snd_stm_conv
+		*conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_int_dac_get_format(conv=%p)\n", conv);
+
+	return FORMAT;
+}
+
+static int snd_stm_conv_int_dac_get_oversampling(struct snd_stm_conv *conv)
+{
+	snd_stm_printd(1, "snd_stm_conv_int_dac_get_oversampling(conv=%p)\n",
+			conv);
+
+	return OVERSAMPLING;
+}
+
+static int snd_stm_conv_int_dac_enable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = container_of(conv,
+			struct snd_stm_conv_int_dac, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_enable(conv=%p)\n", conv);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(!conv_int_dac->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Enabling DAC %s's digital part. (still muted)\n",
+			conv_int_dac->bus_id);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	set__AUDCFG_ADAC_CTRL__NSB__NORMAL(conv_int_dac);
+	set__AUDCFG_ADAC_CTRL__NRST__NORMAL(conv_int_dac);
+
+	conv_int_dac->enabled = 1;
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_int_dac_disable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = container_of(conv,
+			struct snd_stm_conv_int_dac, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_disable(conv=%p)\n", conv);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(conv_int_dac->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Disabling DAC %s's digital part.\n",
+			conv_int_dac->bus_id);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	set__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac);
+	set__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac);
+
+	conv_int_dac->enabled = 0;
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_int_dac_mute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = container_of(conv,
+			struct snd_stm_conv_int_dac, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_mute(conv=%p)\n", conv);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(conv_int_dac->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Muting DAC %s.\n", conv_int_dac->bus_id);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	conv_int_dac->muted_by_source = 1;
+	if (!conv_int_dac->muted_by_user)
+		set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac);
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_int_dac_unmute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = container_of(conv,
+			struct snd_stm_conv_int_dac, conv);
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(conv_int_dac->enabled, return -EINVAL);
+
+	snd_stm_printd(1, "Unmuting DAC %s.\n", conv_int_dac->bus_id);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	conv_int_dac->muted_by_source = 0;
+	if (!conv_int_dac->muted_by_user)
+		set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(conv_int_dac);
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_conv_int_dac_ctl_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_ctl_mute_get(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	ucontrol->value.integer.value[0] = !conv_int_dac->muted_by_user;
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_int_dac_ctl_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_ctl_mute_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+
+	spin_lock(&conv_int_dac->status_lock);
+
+	if (ucontrol->value.integer.value[0] !=
+			!conv_int_dac->muted_by_user) {
+		changed = 1;
+
+		conv_int_dac->muted_by_user =
+				!ucontrol->value.integer.value[0];
+
+		if (conv_int_dac->enabled &&
+				conv_int_dac->muted_by_user &&
+				!conv_int_dac->muted_by_source)
+			set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac);
+		else if (conv_int_dac->enabled &&
+				!conv_int_dac->muted_by_user &&
+				!conv_int_dac->muted_by_source)
+			set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(conv_int_dac);
+	}
+
+	spin_unlock(&conv_int_dac->status_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_conv_int_dac_ctl_mute = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master Playback Switch",
+	.info = snd_stm_ctl_boolean_info,
+	.get = snd_stm_conv_int_dac_ctl_mute_get,
+	.put = snd_stm_conv_int_dac_ctl_mute_put,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_conv_int_dac_read_info(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+		entry->private_data;
+
+	snd_assert(conv_int_dac, return);
+	snd_stm_magic_assert(conv_int_dac, return);
+
+	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
+			get__AUDCFG_ADAC_CTRL(conv_int_dac));
+
+	snd_iprintf(buffer, "enabled = %d\n", conv_int_dac->enabled);
+	snd_iprintf(buffer, "muted_by_source = %d\n",
+			conv_int_dac->muted_by_source);
+	snd_iprintf(buffer, "muted_by_user = %d\n",
+			conv_int_dac->muted_by_user);
+}
+
+static int snd_stm_conv_int_dac_register(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_device->device_data;
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(!conv_int_dac->enabled, return -EINVAL);
+
+	/* Initialize DAC with digital part down, analog up and muted */
+
+	conv_int_dac->enabled = 0;
+	conv_int_dac->muted_by_source = 1;
+	set__AUDCFG_ADAC_CTRL(conv_int_dac,
+			mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(conv_int_dac));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_int_dac->proc_entry,
+			conv_int_dac->bus_id,
+			snd_stm_conv_int_dac_read_info,
+			conv_int_dac);
+
+	return 0;
+}
+
+static int __exit snd_stm_conv_int_dac_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_device->device_data;
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+	snd_assert(!conv_int_dac->enabled, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_int_dac->proc_entry);
+
+	/* Global power done & mute mode */
+
+	set__AUDCFG_ADAC_CTRL(conv_int_dac,
+		mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(conv_int_dac));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_int_dac_snd_device_ops = {
+	.dev_register = snd_stm_conv_int_dac_register,
+	.dev_disconnect = snd_stm_conv_int_dac_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_conv_int_dac_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_int_dac_info *conv_int_dac_info =
+			pdev->dev.platform_data;
+	struct snd_stm_conv_int_dac *conv_int_dac;
+	struct snd_card *card = snd_stm_card_get();
+	int index;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card != NULL, return -EINVAL);
+	snd_assert(conv_int_dac_info != NULL, return -EINVAL);
+
+	conv_int_dac = kzalloc(sizeof(*conv_int_dac), GFP_KERNEL);
+	if (!conv_int_dac) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_int_dac);
+	conv_int_dac->ver = conv_int_dac_info->ver;
+	snd_assert(conv_int_dac->ver > 0, return -EINVAL);
+	conv_int_dac->bus_id = pdev->dev.bus_id;
+	spin_lock_init(&conv_int_dac->status_lock);
+
+	/* Converter interface initialization */
+
+	conv_int_dac->conv.name = conv_int_dac_info->name;
+	conv_int_dac->conv.get_format =
+			snd_stm_conv_int_dac_get_format;
+	conv_int_dac->conv.get_oversampling =
+			snd_stm_conv_int_dac_get_oversampling;
+	conv_int_dac->conv.enable = snd_stm_conv_int_dac_enable;
+	conv_int_dac->conv.disable = snd_stm_conv_int_dac_disable;
+	conv_int_dac->conv.mute = snd_stm_conv_int_dac_mute;
+	conv_int_dac->conv.unmute = snd_stm_conv_int_dac_unmute;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &conv_int_dac->mem_region,
+			&conv_int_dac->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* Get connections */
+
+	snd_assert(conv_int_dac_info->source_bus_id != NULL,
+			return -EINVAL);
+	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
+			conv_int_dac_info->source_bus_id);
+	index = snd_stm_conv_attach(&conv_int_dac->conv, &platform_bus_type,
+			conv_int_dac_info->source_bus_id);
+	if (index < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		result = index;
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_int_dac,
+			&snd_stm_conv_int_dac_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA control */
+
+	snd_stm_conv_int_dac_ctl_mute.device =
+			conv_int_dac_info->card_device;
+	snd_stm_conv_int_dac_ctl_mute.index = index;
+	result = snd_ctl_add(card,
+			snd_ctl_new1(&snd_stm_conv_int_dac_ctl_mute,
+			conv_int_dac));
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA control!\n");
+		goto error_control;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, &conv_int_dac->conv);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_control:
+error_device:
+error_attach:
+	snd_stm_memory_release(conv_int_dac->mem_region,
+			conv_int_dac->base);
+error_memory_request:
+	snd_stm_magic_clear(conv_int_dac);
+	kfree(conv_int_dac);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_int_dac_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			container_of(platform_get_drvdata(pdev),
+			struct snd_stm_conv_int_dac, conv);
+
+	snd_assert(conv_int_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
+
+	snd_stm_memory_release(conv_int_dac->mem_region,
+			conv_int_dac->base);
+
+	snd_stm_magic_clear(conv_int_dac);
+	kfree(conv_int_dac);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_int_dac_driver = {
+	.driver = {
+		.name = "snd_conv_int_dac",
+	},
+	.probe = snd_stm_conv_int_dac_probe,
+	.remove = snd_stm_conv_int_dac_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_int_dac_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_int_dac_driver);
+}
+
+void snd_stm_conv_int_dac_exit(void)
+{
+	platform_driver_unregister(&snd_stm_conv_int_dac_driver);
+}
diff --git a/sound/stm/fsynth.c b/sound/stm/fsynth.c
new file mode 100644
index 0000000..4ed4aad
--- /dev/null
+++ b/sound/stm/fsynth.c
@@ -0,0 +1,788 @@
+/*
+ *   STMicroelectronics System-on-Chips' audio oversampling frequency
+ *   synthesizers driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Authors: Pawel MOLL <pawel.moll@st.com>
+ *            Daniel THOMPSON <daniel.thompson@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <asm/div64.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+
+#define COMPONENT fsynth
+#include "common.h"
+#include "reg_audcfg_fsyn.h"
+
+
+
+/*
+ * Hardware constants
+ */
+
+/* PLL inside the synthesizer multiplies input frequency
+ * (which is 30MHz in our case) by 8... */
+#define PLL_FREQ 8 * 30 * 1000 * 1000
+
+
+
+/*
+ * Audio frequency synthesizer structures
+ */
+
+struct snd_stm_fsynth_channel {
+	struct snd_stm_fsynth *fsynth;
+
+	int frequency;  /* Nominal */
+	int adjustment; /* Actual (achieved) */
+
+	snd_stm_magic_field;
+};
+
+struct snd_stm_fsynth {
+	/* System informations */
+	const char *bus_id;
+	int ver; /* IP version, used by register access macros */
+	int channels_max;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Environment settings */
+	int channels_from, channels_to;
+
+	/* Runtime data */
+	struct snd_stm_fsynth_channel *channels;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Toolbox
+ */
+
+/* Return the number of set bits in x. */
+static unsigned int population(unsigned int x)
+{
+	/* This is the traditional branch-less algorithm for population count */
+	x = x - ((x >> 1) & 0x55555555);
+	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
+	x = (x + (x >> 4)) & 0x0f0f0f0f;
+	x = x + (x << 8);
+	x = x + (x << 16);
+
+	return x >> 24;
+}
+
+/* Return the index of the most significant set in x.
+ * The results are 'undefined' is x is 0 (0xffffffff as it happens
+ * but this is a mere side effect of the algorithm. */
+static unsigned int most_significant_set_bit(unsigned int x)
+{
+	/* propagate the MSSB right until all bits smaller than MSSB are set */
+	x = x | (x >> 1);
+	x = x | (x >> 2);
+	x = x | (x >> 4);
+	x = x | (x >> 8);
+	x = x | (x >> 16);
+
+	/* now count the number of set bits [clz is population(~x)] */
+	return population(x) - 1;
+}
+
+/* Solve the frequency synthesiser equations to provide a specified output
+ * frequency.
+ *
+ * The approach taken to solve the equation is to solve for sdiv assuming
+ * maximal values for md and one greater than maximal pe (-16 and 32768
+ * respectively) before rounding down. Once sdiv is selected we can
+ * solve for md by assuming maximal pe and rounding down. With these
+ * values pe can trivially be calculated.
+ *
+ * The function is implemented entirely with integer calculations making
+ * it suitable for use within the Linux kernel.
+ *
+ * The magic numbers within the function are derived from the Fsynth equation
+ * which is as follows:
+ *
+ * <pre>
+ *                                  32768*Fpll
+ * #1: Fout = ------------------------------------------------------
+ *                            md                        (md + 1)
+ *            (sdiv*((pe*(1 + --)) - ((pe - 32768)*(1 + --------))))
+ *                            32                           32
+ * </pre>
+ *
+ * Where:
+ *
+ *  - Fpll and Fout are frequencies in Hz
+ *  - sdiv is power of 2 between 1 and 8
+ *  - md is an integer between -1 and -16
+ *  - pe is an integer between 0 and 32767
+ *
+ * This simplifies to:
+ *
+ * <pre>
+ *                       1048576*Fpll
+ * #2: Fout = ----------------------------------
+ *            (sdiv*(1081344 - pe + (32768*md)))
+ * </pre>
+ *
+ * Rearranging:
+ *
+ * <pre>
+ *                 1048576*Fpll
+ * #3: predivide = ------------ = (sdiv*(1081344 - pe + (32768*md)))
+ *                     Fout
+ * </pre>
+ *
+ * If solve for sdiv and let pe = 32768 and md = -16 we get:
+ *
+ * <pre>
+ *                     predivide            predivide
+ * #4: sdiv = --------------------------- = ---------
+ *            (1081344 - pe + (32768*md))     524288
+ * </pre>
+ *
+ * Returning to eqn. #3, solving for md and let pe = 32768 we get:
+ *
+ * <pre>
+ *           predivide                    predivide
+ *          (--------- - 1081344 + pe)   (--------- - 1048576)
+ *             sdiv                         sdiv
+ * #5: md = -------------------------- = ---------------------
+ *                    32768                      32768
+
+ * </pre>
+ *
+ * Finally we return to #3 and rearrange for pe:
+ *
+ * <pre>
+ *              predivide
+ * #6: pe = -1*(--------- - 1081344 - (32768*md))
+ *                sdiv
+ * </pre>
+ *
+ */
+static int solve_fsynth_eqn(unsigned int Fpll, unsigned int Fout,
+		unsigned int *sdivp, int *mdp, unsigned int *pep)
+{
+	unsigned long long p, q;
+	unsigned int predivide;
+	int preshift; /* always +ve but used in subtraction */
+	unsigned int sdiv;
+	int md;
+	unsigned int pe = 1 << 14;
+
+	/* pre-divide the frequencies */
+	p = 1048576ull * Fpll;		/* <<20? */
+	q = Fout;
+
+	predivide = (unsigned int)div64_64(p, q);
+
+	/* determine an appropriate value for the output divider using eqn. #4
+	 * with md = -16 and pe = 32768 (and round down) */
+	sdiv = predivide / 524288;
+	if (sdiv > 1) {
+		/* sdiv = fls(sdiv) - 1; // this doesn't work
+		 * for some unknown reason */
+		sdiv = most_significant_set_bit(sdiv);
+	} else
+		sdiv = 1;
+
+	/* pre-shift a common sub-expression of later calculations */
+	preshift = predivide >> sdiv;
+
+	/* determine an appropriate value for the coarse selection using eqn. #5
+	 * with pe = 32768 (and round down which for signed values means away
+	 * from zero) */
+	md = ((preshift - 1048576) / 32768) - 1;	/* >>15? */
+
+	/* calculate a value for pe that meets the output target */
+	pe = -1 * (preshift - 1081344 - (32768 * md));	/* <<15? */
+
+	/* finally give sdiv its true hardware form */
+	sdiv--;
+
+	/* special case for 58593.75Hz and harmonics...
+	 * can't quite seem to get the rounding right */
+	if (md == -17 && pe == 0) {
+		md = -16;
+		pe = 32767;
+	}
+
+	/* update the outgoing arguments */
+	*sdivp = sdiv;
+	*mdp = md;
+	*pep = pe;
+
+	snd_stm_printd(1, "SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
+
+	/* return 0 if all variables meet their contraints */
+	return (sdiv <= 7 && -16 <= md && md <= -1 && pe <= 32767) ? 0 : -1;
+}
+
+/*
+ *                   1048576*Fpll
+ * Fout = ----------------------------------
+ *        (sdiv*(1081344 - pe + (32768*md)))
+ *
+ * Fpll is premultiplied by 8
+ * Fout needs dividing by 256 to get real frequency
+ *
+ * small error compared to double based original
+ * i.e. for 44100 (11289600) it reports 11289610 instead of 11289610.36
+ */
+static int get_fsynth_output(unsigned int Fpll,
+		unsigned int sdiv, int md, unsigned int pe)
+{
+	long long p, q, r, s, t, u;
+
+	p = 1048576ll * Fpll;
+	q = 32768 * md;
+	r = 1081344 - pe;
+	s = r + q;
+	t = (1 << (sdiv + 1)) * s;
+	u = div64_64(p, t);
+
+	return (int)u;
+}
+
+static int snd_stm_fsynth_channel_configure(struct snd_stm_fsynth *fsynth,
+		int channel, int frequency, int adjustment)
+{
+	int result;
+	unsigned int sdiv;
+	int md;
+	unsigned int pe;
+	int frequency_adjusted, frequency_achieved, adjustment_achieved;
+	int delta;
+
+	snd_stm_printd(1, "snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
+			"frequency=%d, adjustment=%d)\n", fsynth, channel,
+			frequency, adjustment);
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	/* All specs say, that maximum frequency generated by the fsynth
+	 * is 12.288MHz... */
+	if (frequency > 12288000)
+		snd_stm_printe("WARNING! %s should not generate frequency %d!"
+				" (12.288MHz is maximum)\n",
+				fsynth->bus_id, frequency);
+
+	/*             a
+	 * F = f + --------- * f = f + d
+	 *          1000000
+	 *
+	 *         a
+	 * d = --------- * f
+	 *      1000000
+	 *
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency to be set in synthesizer
+	 *   d - delta (difference) between f and F
+	 */
+	if (adjustment < 0) {
+		/* div64_64 operates on unsigned values... */
+		delta = -1;
+		adjustment = -adjustment;
+	} else {
+		delta = 1;
+	}
+	/* 500000 ppm is 0.5, which is used to round up values */
+	delta *= (int)div64_64((uint64_t)frequency * (uint64_t)adjustment +
+			500000, 1000000);
+	frequency_adjusted = frequency + delta;
+
+	snd_stm_printd(1, "Setting %s channel %d to frequency %d.\n",
+			fsynth->bus_id, channel,
+			frequency_adjusted);
+
+	result = solve_fsynth_eqn(PLL_FREQ, frequency_adjusted,
+			&sdiv, &md, &pe);
+	if (result < 0) {
+		snd_stm_printe("Frequency %d can't be generated!\n",
+				frequency_adjusted);
+		return -EINVAL;
+	}
+
+	snd_stm_printd(1, "SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
+			(unsigned int)md & mask__AUDCFG_FSYN_MD__MD(fsynth,
+			channel), pe);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
+	set__AUDCFG_FSYN_SDIV__SDIV(fsynth, channel, sdiv);
+	set__AUDCFG_FSYN_MD__MD(fsynth, channel, (unsigned int)md &
+			mask__AUDCFG_FSYN_MD__MD(fsynth, channel));
+	set__AUDCFG_FSYN_PE__PE(fsynth, channel, pe);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(fsynth, channel);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
+
+	/*             a                    a
+	 * F = f + --------- * f   =>   --------- * f = F - f   ==>
+	 *          1000000              1000000
+	 *
+	 *           a        F - f               F - f
+	 * ==>   --------- = -------   ==>   a = ------- * 1000000
+	 *        1000000       f                   f
+	 *
+	 * F = f + d   ==>   d = F - f
+	 *
+	 *      f + d - f               d
+	 * a = ----------- * 1000000 = --- * 1000000
+	 *          f                   f
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency actually being generated by fsynch
+	 *   d - delta between F and f
+	 */
+	frequency_achieved = get_fsynth_output(PLL_FREQ, sdiv, md, pe);
+	delta = frequency_achieved - frequency;
+	if (delta < 0) {
+		/* div64_64 operates on unsigned values... */
+		delta = -delta;
+		adjustment_achieved = -1;
+	} else {
+		adjustment_achieved = 1;
+	}
+	/* frequency/2 is added to round up result */
+	adjustment_achieved *= (int)div64_64((uint64_t)delta * 1000000 +
+			frequency / 2, frequency);
+
+	snd_stm_printd(1, "Nominal frequency is %d, actual frequency is %d, "
+			"(%d ppm difference).\n", frequency,
+			frequency_achieved, adjustment_achieved);
+
+	/* Save this informations for future generations ;-) */
+	fsynth->channels[channel].frequency = frequency;
+	fsynth->channels[channel].adjustment = adjustment_achieved;
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_fsynth_adjustment_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = -1000000;
+	uinfo->value.integer.max = 1000000;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth_channel->fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
+
+	ucontrol->value.integer.value[0] = fsynth_channel->adjustment;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	int result;
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+	struct snd_stm_fsynth *fsynth;
+	int channel;
+	int old_adjustement;
+
+	snd_stm_printd(1, "snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+
+	fsynth = fsynth_channel->fsynth;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	channel = fsynth_channel - fsynth_channel->fsynth->channels;
+	old_adjustement = fsynth_channel->adjustment;
+
+	result = snd_stm_fsynth_channel_configure(fsynth, channel,
+			fsynth_channel->frequency,
+			ucontrol->value.integer.value[0]);
+
+	if (result < 0)
+		return -EINVAL;
+
+	return old_adjustement != fsynth_channel->adjustment;
+}
+
+static struct snd_kcontrol_new snd_stm_fsynth_adjustment_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Playback Oversampling Freq. Adjustment",
+	.info = snd_stm_fsynth_adjustment_info,
+	.get = snd_stm_fsynth_adjustment_get,
+	.put = snd_stm_fsynth_adjustment_put,
+};
+
+
+
+/*
+ * Audio frequency synthesizer public interface implementation
+ */
+static int snd_stm_fsynth_bus_id_match(struct device *device, void *bus_id)
+{
+	return strcmp(device->bus_id, bus_id) == 0;
+}
+
+struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
+		int output)
+{
+	struct device *device;
+
+	snd_stm_printd(1, "snd_stm_fsynth_get_channel(bus_id='%s', output=%d)"
+			"\n", bus_id, output);
+
+	device = bus_find_device(&platform_bus_type, NULL, (void *)bus_id,
+			snd_stm_fsynth_bus_id_match);
+	if (device) {
+		struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
+
+		snd_stm_magic_assert(fsynth, return NULL);
+		snd_assert(output >= fsynth->channels_from, return NULL);
+		snd_assert(output <= fsynth->channels_to, return NULL);
+
+		return &fsynth->channels[output];
+	}
+
+	snd_stm_printe("Can't find '%s' frequency synthesizer "
+			"device!\n", bus_id);
+
+	return NULL;
+}
+
+int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+		int frequency)
+{
+	snd_stm_printd(1, "snd_stm_fsynth_set_frequency(fsynth_channel=%p, "
+			"frequency=%d)\n", fsynth_channel, frequency);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth_channel->fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
+
+	return snd_stm_fsynth_channel_configure(fsynth_channel->fsynth,
+			fsynth_channel - fsynth_channel->fsynth->channels,
+			frequency, 0);
+}
+
+int snd_stm_fsynth_add_adjustement_ctl(
+		struct snd_stm_fsynth_channel *fsynth_channel,
+		struct snd_card *card, int card_device)
+{
+	int result;
+
+	snd_stm_printd(1, "snd_stm_fsynth_add_control(fsynth_channel=%p, "
+			"card=%p, card_device=%d)\n", fsynth_channel,
+			card, card_device);
+
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+
+	snd_stm_fsynth_adjustment_ctl.device = card_device;
+	result = snd_ctl_add(card, snd_ctl_new1(&snd_stm_fsynth_adjustment_ctl,
+			fsynth_channel));
+	snd_stm_fsynth_adjustment_ctl.index++;
+
+	return result;
+}
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r, n) \
+		snd_iprintf(buffer, "AUDCFG_FSYN%d_%s (offset 0x%02x) " \
+				"= 0x%08x\n", n, __stringify(r), \
+				offset__AUDCFG_FSYN_##r(fsynth, n), \
+				get__AUDCFG_FSYN_##r(fsynth, n))
+
+static void snd_stm_fsynth_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_fsynth *fsynth = entry->private_data;
+	int i;
+
+	snd_assert(fsynth, return);
+	snd_stm_magic_assert(fsynth, return);
+
+	snd_iprintf(buffer, "AUDCFG_FSYN_CFG (offset 0x00) = 0x%08x\n",
+			get__AUDCFG_FSYN_CFG(fsynth));
+
+	for (i = 0; i < fsynth->channels_max; i++) {
+		DUMP_REGISTER(MD, i);
+		DUMP_REGISTER(PE, i);
+		DUMP_REGISTER(SDIV, i);
+		DUMP_REGISTER(PROGEN, i);
+	}
+}
+
+static int snd_stm_fsynth_register(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	snd_stm_printd(0, "--- Registering frequency synthesizer '%s'...\n",
+			fsynth->bus_id);
+
+	/* Initialize & reset synthesizer */
+
+	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		snd_stm_printd(0, "Enabling synthesizer '%s' channel %d\n",
+				fsynth->bus_id, i);
+		value |= mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(fsynth, i);
+		if (fsynth->ver != ver__AUDCFG_FSYN__65_2_1_2 &&
+				fsynth->ver != ver__AUDCFG_FSYN__65_3_3)
+			value |= mask__AUDCFG_FSYN_CFG__FS_EN__ENABLED(fsynth,
+					i);
+		value |= mask__AUDCFG_FSYN_CFG__NSB__ACTIVE(fsynth, i);
+	}
+	value |= mask__AUDCFG_FSYN_CFG__NPDA__NORMAL(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(fsynth);
+
+	set__AUDCFG_FSYN_CFG(fsynth, value);
+	barrier();
+
+	/* Unreset ;-) it now */
+
+	set__AUDCFG_FSYN_CFG__RSTP__RUNNING(fsynth);
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&fsynth->proc_entry, fsynth->bus_id,
+			snd_stm_fsynth_dump_registers, fsynth);
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(fsynth->proc_entry);
+
+	/* Disable synthesizer */
+
+	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		if (fsynth->ver != ver__AUDCFG_FSYN__65_2_1_2 &&
+				fsynth->ver != ver__AUDCFG_FSYN__65_3_3)
+			value |= mask__AUDCFG_FSYN_CFG__FS_EN__DISABLED(fsynth,
+					i);
+		value |= mask__AUDCFG_FSYN_CFG__NSB__STANDBY(fsynth, i);
+	}
+	value |= mask__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(fsynth);
+
+	set__AUDCFG_FSYN_CFG(fsynth, value);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_fsynth_snd_device_ops = {
+	.dev_register = snd_stm_fsynth_register,
+	.dev_disconnect = snd_stm_fsynth_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_fsynth_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_fsynth_info *fsynth_info = pdev->dev.platform_data;
+	struct snd_stm_fsynth *fsynth;
+	int channels_max;
+	int i;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(fsynth_info != NULL, return -EINVAL);
+
+	if (fsynth_info->ver < ver__AUDCFG_FSYN__65_2_1_2)
+		channels_max = 3;
+	else
+		channels_max = 4;
+
+	fsynth = kzalloc(sizeof(*fsynth) + (channels_max *
+			sizeof(*fsynth->channels)), GFP_KERNEL);
+	if (!fsynth) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(fsynth);
+	fsynth->ver = fsynth_info->ver;
+	snd_assert(fsynth->ver > 0, return -EINVAL);
+	fsynth->bus_id = pdev->dev.bus_id;
+	fsynth->channels_max = channels_max;
+	fsynth->channels = (void *)fsynth + (channels_max *
+			sizeof(*fsynth->channels));
+	for (i = 0; i < channels_max; i++) {
+		fsynth->channels[i].fsynth = fsynth;
+		snd_stm_magic_set(&fsynth->channels[i]);
+	}
+
+	result = snd_stm_memory_request(pdev, &fsynth->mem_region,
+			&fsynth->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	fsynth->channels_from = fsynth_info->channels_from;
+	fsynth->channels_to = fsynth_info->channels_to;
+	snd_assert(fsynth->channels_from < fsynth->channels_to,
+			return -EINVAL);
+	snd_assert(fsynth->channels_from >= 0, return -EINVAL);
+	snd_assert(fsynth->channels_to < channels_max, return -EINVAL);
+
+	snd_stm_printd(0, "Used synthesizer channels: %d to %d\n",
+			fsynth->channels_from, fsynth->channels_to);
+
+	/* ALSA component */
+
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL, fsynth,
+			&snd_stm_fsynth_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, fsynth);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+error_memory_request:
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_fsynth_remove(struct platform_device *pdev)
+{
+	struct snd_stm_fsynth *fsynth = platform_get_drvdata(pdev);
+	int i;
+
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+
+	for (i = 0; i < fsynth->channels_max; i++) {
+		fsynth->channels[i].fsynth = fsynth;
+		snd_stm_magic_clear(&fsynth->channels[i]);
+	}
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_fsynth_driver = {
+	.driver = {
+		.name = "snd_fsynth",
+	},
+	.probe = snd_stm_fsynth_probe,
+	.remove = snd_stm_fsynth_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_fsynth_init(void)
+{
+	return platform_driver_register(&snd_stm_fsynth_driver);
+}
+
+void snd_stm_fsynth_exit(void)
+{
+	platform_driver_unregister(&snd_stm_fsynth_driver);
+}
diff --git a/sound/stm/init.c b/sound/stm/init.c
new file mode 100644
index 0000000..5ac673a
--- /dev/null
+++ b/sound/stm/init.c
@@ -0,0 +1,138 @@
+/*
+ *   STMicrolectronics System-on-Chips' audio subsystem core driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#define COMPONENT init
+#include "common.h"
+
+/* General debug level */
+#if defined(CONFIG_SND_STM_DEBUG_LEVEL)
+static int debug = CONFIG_SND_STM_DEBUG_LEVEL;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+int *snd_stm_debug_level = &debug;
+EXPORT_SYMBOL(snd_stm_debug_level);
+#endif
+
+static int __init snd_stm_init(void)
+{
+	int result;
+
+	snd_stm_printd(0, "snd_stm_init()\n");
+
+	result = snd_stm_info_create();
+	if (result != 0) {
+		snd_stm_printe("Procfs info creation failed!\n");
+		goto error_info;
+	}
+	result = snd_stm_fsynth_init();
+	if (result != 0) {
+		snd_stm_printe("Frequency synthesizer driver initialization"
+				" failed!\n");
+		goto error_fsynth;
+	}
+	result = snd_stm_conv_init();
+	if (result != 0) {
+		snd_stm_printe("Converters infrastructure initialization"
+				" failed!\n");
+		goto error_conv;
+	}
+	result = snd_stm_conv_int_dac_init();
+	if (result != 0) {
+		snd_stm_printe("Internal DACs driver initialization failed!\n");
+		goto error_conv_int_dac;
+	}
+	result = snd_stm_conv_i2sspdif_init();
+	if (result != 0) {
+		snd_stm_printe("I2S to SPDIF converter driver initialization"
+				" failed!\n");
+		goto error_conv_i2sspdif;
+	}
+	result = snd_stm_synchro_init();
+	if (result != 0) {
+		snd_stm_printe("Synchronisation routines initialization"
+				" failed!\n");
+		goto error_synchro;
+	}
+	result = snd_stm_pcm_player_init();
+	if (result != 0) {
+		snd_stm_printe("PCM player driver initialization failed!\n");
+		goto error_pcm_player;
+	}
+	result = snd_stm_pcm_reader_init();
+	if (result != 0) {
+		snd_stm_printe("PCM reader driver initialization failed!\n");
+		goto error_pcm_reader;
+	}
+	result = snd_stm_spdif_player_init();
+	if (result != 0) {
+		snd_stm_printe("SPDIF player driver initialization failed!\n");
+		goto error_spdif_player;
+	}
+
+	return result;
+
+error_spdif_player:
+	snd_stm_pcm_reader_exit();
+error_pcm_reader:
+	snd_stm_pcm_player_exit();
+error_pcm_player:
+	snd_stm_synchro_exit();
+error_synchro:
+	snd_stm_conv_i2sspdif_exit();
+error_conv_i2sspdif:
+	snd_stm_conv_int_dac_exit();
+error_conv_int_dac:
+	snd_stm_conv_exit();
+error_conv:
+	snd_stm_fsynth_exit();
+error_fsynth:
+	snd_stm_info_dispose();
+error_info:
+	return result;
+}
+
+static void __exit snd_stm_exit(void)
+{
+	snd_stm_printd(0, "snd_stm_exit()\n");
+
+	snd_stm_spdif_player_exit();
+	snd_stm_pcm_reader_exit();
+	snd_stm_pcm_player_exit();
+	snd_stm_synchro_exit();
+	snd_stm_conv_i2sspdif_exit();
+	snd_stm_conv_int_dac_exit();
+	snd_stm_conv_exit();
+	snd_stm_fsynth_exit();
+	snd_stm_info_dispose();
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio core driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_init)
+module_exit(snd_stm_exit)
diff --git a/sound/stm/pcm_player.c b/sound/stm/pcm_player.c
new file mode 100644
index 0000000..115d70a
--- /dev/null
+++ b/sound/stm/pcm_player.c
@@ -0,0 +1,1079 @@
+/*
+ *   STMicroelectronics System-on-Chips' PCM player driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *           Mark Glaisher
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/pcm_params.h>
+
+#define COMPONENT pcm_player
+#include "common.h"
+#include "reg_aud_pcmout.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
+		SND_STM_FORMAT__SUBFRAME_32_BITS)
+#define DEFAULT_OVERSAMPLING 256
+
+/* The sample count field (NSAMPLES in CTRL register) is 19 bits wide */
+#define MAX_SAMPLES_PER_PERIOD ((1 << 19) - 1)
+
+
+
+/*
+ * PCM player instance definition
+ */
+
+struct snd_stm_pcm_player {
+	/* System informations */
+	struct snd_stm_pcm_player_info *info;
+	struct device *device;
+	struct snd_pcm *pcm;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	unsigned int fdma_channel;
+
+	/* Environment settings */
+	struct snd_stm_fsynth_channel *fsynth_channel;
+	struct snd_stm_conv *conv;
+	struct snd_pcm_hw_constraint_list channels_constraint;
+
+	/* Runtime data */
+	struct snd_stm_buffer *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	int fdma_max_transfer_size;
+	struct stm_dma_params fdma_params;
+	struct stm_dma_req *fdma_request;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Playing engine implementation
+ */
+
+static irqreturn_t snd_stm_pcm_player_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_pcm_player *pcm_player = dev_id;
+	unsigned int status;
+
+	snd_stm_printd(2, "snd_stm_pcm_player_irq_handler(irq=%d, "
+			"dev_id=0x%p)\n", irq, dev_id);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = get__AUD_PCMOUT_ITS(pcm_player);
+	set__AUD_PCMOUT_ITS_CLR(pcm_player, status);
+	preempt_enable();
+
+	/* Underflow? */
+	if (unlikely(status & mask__AUD_PCMOUT_ITS__UNF__PENDING(pcm_player))) {
+		snd_stm_printe("Underflow detected in PCM player '%s'!\n",
+				pcm_player->device->bus_id);
+		result = IRQ_HANDLED;
+	}
+
+	/* Period successfully played */
+	if (likely(status & mask__AUD_PCMOUT_ITS__NSAMPLE__PENDING(pcm_player)))
+		do {
+			snd_assert(pcm_player->substream, break);
+
+			snd_stm_printd(2, "Period elapsed ('%s')\n",
+					pcm_player->device->bus_id);
+			snd_pcm_period_elapsed(pcm_player->substream);
+
+			result = IRQ_HANDLED;
+		} while (0);
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+static struct snd_pcm_hardware snd_stm_pcm_player_hw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S16_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 10,
+
+	.periods_min	= 2,
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note 1: that these value must be also calculated not to exceed
+	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
+	 * Note 2: for 16/16-bits data this counter is a "frames counter",
+	 * not "samples counter" (two channels are read as one word).
+	 * Note 3: period_bytes_min defines minimum time between period
+	 * (NSAMPLE) interrupts... Keep it large enough not to kill
+	 * the system... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_pcm_player_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_pcm_player_open(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Get attached converter handle */
+
+	pcm_player->conv = snd_stm_conv_get_attached(&platform_bus_type,
+			pcm_player->device->bus_id);
+	if (pcm_player->conv)
+		snd_stm_printd(1, "Converter '%s' attached to '%s'...\n",
+				pcm_player->conv->name,
+				pcm_player->device->bus_id);
+	else
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+				pcm_player->device->bus_id);
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	result = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_CHANNELS,
+			&pcm_player->channels_constraint);
+	if (result < 0) {
+		snd_stm_printe("Can't set channels constraint!\n");
+		return result;
+	}
+
+	/* It is better when buffer size is an integer multiple of period
+	 * size... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			pcm_player->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
+	runtime->hw = snd_stm_pcm_player_hw;
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_player_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_pcm_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (snd_stm_buffer_is_allocated(pcm_player->buffer)) {
+		/* Free buffer */
+		snd_stm_buffer_free(pcm_player->buffer);
+
+		/* Free FDMA parameters & configuration */
+		dma_params_free(&pcm_player->fdma_params);
+		dma_req_free(pcm_player->fdma_channel,
+				pcm_player->fdma_request);
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_WRITE,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = pcm_player->info->fdma_initiator,
+	};
+
+	snd_stm_printd(1, "snd_stm_pcm_player_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This function may be called many times, so let's be prepared... */
+	if (snd_stm_buffer_is_allocated(pcm_player->buffer))
+		snd_stm_pcm_player_hw_free(substream);
+
+	/* Allocate buffer */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	result = snd_stm_buffer_alloc(pcm_player->buffer, substream,
+			buffer_bytes);
+	if (result != 0) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, pcm_player->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
+	}
+
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			pcm_player->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
+			"to %d.\n", transfer_size);
+
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_player->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+			return -EINVAL);
+	snd_assert(transfer_size <=
+			mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player),
+			return -EINVAL);
+	set__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player, transfer_size);
+
+	/* Configure FDMA transfer */
+
+	pcm_player->fdma_request = dma_req_config(pcm_player->fdma_channel,
+			pcm_player->info->fdma_request_line, &fdma_req_config);
+	if (!pcm_player->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", pcm_player->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
+
+	dma_params_init(&pcm_player->fdma_params, MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	dma_params_DIM_1_x_0(&pcm_player->fdma_params);
+
+	dma_params_req(&pcm_player->fdma_params, pcm_player->fdma_request);
+
+	dma_params_addrs(&pcm_player->fdma_params, runtime->dma_addr,
+			pcm_player->fifo_phys_address, buffer_bytes);
+
+	result = dma_compile_list(pcm_player->fdma_channel,
+				&pcm_player->fdma_params, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for player"
+				" '%s'!\n", pcm_player->device->bus_id);
+		goto error_compile_list;
+	}
+
+	return 0;
+
+error_compile_list:
+	dma_req_free(pcm_player->fdma_channel,
+			pcm_player->fdma_request);
+error_req_config:
+	snd_stm_buffer_free(pcm_player->buffer);
+error_buf_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int format, lr_pol;
+	int oversampling, bits_in_output_frame;
+
+	snd_stm_printd(1, "snd_stm_pcm_player_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+
+	/* Configure SPDIF synchronisation */
+
+	/* TODO */
+
+	/* Get format & oversampling value from connected converter */
+
+	if (pcm_player->conv) {
+		format = snd_stm_conv_get_format(pcm_player->conv);
+		oversampling = snd_stm_conv_get_oversampling(pcm_player->conv);
+		if (oversampling == 0)
+			oversampling = DEFAULT_OVERSAMPLING;
+	} else {
+		format = DEFAULT_FORMAT;
+		oversampling = DEFAULT_OVERSAMPLING;
+	}
+
+	snd_stm_printd(1, "Player %s: sampling frequency %d, oversampling %d\n",
+			pcm_player->device->bus_id, runtime->rate,
+			oversampling);
+
+	snd_assert(oversampling > 0, return -EINVAL);
+
+	/* For 32 bits subframe oversampling must be a multiple of 128,
+	 * for 16 bits - of 64 */
+	snd_assert(((format & SND_STM_FORMAT__SUBFRAME_32_BITS) &&
+				(oversampling % 128 == 0)) ||
+				(oversampling % 64 == 0), return -EINVAL);
+
+	/* Set up frequency synthesizer */
+
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth_channel,
+			runtime->rate * oversampling);
+
+	/* Set up player hardware */
+
+	snd_stm_printd(1, "Player %s format configuration:\n",
+			pcm_player->device->bus_id);
+
+	/* Number of bits per subframe (which is one channel sample)
+	 * on output - it determines serial clock frequency, which is
+	 * 64 times sampling rate for 32 bits subframe (2 channels 32
+	 * bits each means 64 bits per frame) and 32 times sampling
+	 * rate for 16 bits subframe
+	 * (you know why, don't you? :-) */
+
+	switch (format & SND_STM_FORMAT__SUBFRAME_MASK) {
+	case SND_STM_FORMAT__SUBFRAME_32_BITS:
+		snd_stm_printd(1, "- 32 bits per subframe\n");
+		set__AUD_PCMOUT_FMT__NBIT__32_BITS(pcm_player);
+		if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
+			set__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(pcm_player);
+		else
+			set__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(pcm_player);
+		bits_in_output_frame = 64; /* frame = 2 * subframe */
+		break;
+	case SND_STM_FORMAT__SUBFRAME_16_BITS:
+		snd_stm_printd(1, "- 16 bits per subframe\n");
+		set__AUD_PCMOUT_FMT__NBIT__16_BITS(pcm_player);
+		set__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(pcm_player);
+		bits_in_output_frame = 32; /* frame = 2 * subframe */
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Serial audio interface format - for detailed explanation
+	 * see ie.:
+	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+
+	set__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(pcm_player);
+
+	/* Value FALLING of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
+	 * actually means "data clocking (changing) on the falling edge"
+	 * (and we usually want this...) - STx7100 and cuts < 3.0 of
+	 * STx7109 have this bit inverted comparing to what their
+	 * datasheets claim... (specs say 1) */
+
+	set__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(pcm_player);
+
+	switch (format & SND_STM_FORMAT__MASK) {
+	case SND_STM_FORMAT__I2S:
+		snd_stm_printd(1, "- I2S\n");
+		set__AUD_PCMOUT_FMT__ALIGN__LEFT(pcm_player);
+		set__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(pcm_player);
+		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(pcm_player);
+		break;
+	case SND_STM_FORMAT__LEFT_JUSTIFIED:
+		snd_stm_printd(1, "- left justified\n");
+		set__AUD_PCMOUT_FMT__ALIGN__LEFT(pcm_player);
+		set__AUD_PCMOUT_FMT__PADDING__NO_DELAY(pcm_player);
+		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(pcm_player);
+		break;
+	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
+		snd_stm_printd(1, "- right justified\n");
+		set__AUD_PCMOUT_FMT__ALIGN__RIGHT(pcm_player);
+		set__AUD_PCMOUT_FMT__PADDING__NO_DELAY(pcm_player);
+		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(pcm_player);
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Configure PCM player frequency divider
+	 *
+	 *             Fdacclk             Fs * oversampling
+	 * divider = ----------- = ------------------------------- =
+	 *            2 * Fsclk     2 * Fs * bits_in_output_frame
+	 *
+	 *                  oversampling
+	 *         = --------------------------
+	 *            2 * bits_in_output_frame
+	 * where:
+	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
+	 *               MCLK (master clock), "system clock" etc.
+	 *   - Fsclk - frequency of SCLK (serial clock) aka BICK (bit clock)
+	 *   - Fs - sampling rate (frequency)
+	 *   - bits_in_output_frame - number of bits in output signal _frame_
+	 *                (32 or 64, depending on NBIT field of FMT register)
+	 */
+
+	set__AUD_PCMOUT_CTRL__CLK_DIV(pcm_player,
+			oversampling / (2 * bits_in_output_frame));
+
+	/* Configure data memory format & NSAMPLE interrupt */
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* One data word contains two samples */
+		set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(pcm_player);
+
+		/* Workaround for a problem with L/R channels swap in case of
+		 * 16/16 memory model: PCM player expects left channel data in
+		 * word's upper two bytes, but due to little endianess
+		 * character of our memory there is right channel data there;
+		 * the workaround is to invert L/R signal, however it is
+		 * cheating, because in such case channel phases are shifted
+		 * by one sample...
+		 * (ask me for more details if above is not clear ;-)
+		 * TODO this somehow better... */
+		set__AUD_PCMOUT_FMT__LR_POL(pcm_player, !lr_pol);
+
+		/* One word of data is two samples (two channels...) */
+		set__AUD_PCMOUT_CTRL__NSAMPLE(pcm_player,
+				runtime->period_size * runtime->channels / 2);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		/* Actually "16 bits/0 bits" means "32/28/24/20/18/16 bits
+		 * on the left than zeros (if less than 32 bites)"... ;-) */
+		set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(pcm_player);
+
+		/* In x/0 bits memory mode there is no problem with
+		 * L/R polarity */
+		set__AUD_PCMOUT_FMT__LR_POL(pcm_player, lr_pol);
+
+		/* One word of data is one sample, so period size
+		 * times channels */
+		set__AUD_PCMOUT_CTRL__NSAMPLE(pcm_player,
+				runtime->period_size * runtime->channels);
+		break;
+
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Number of channels... */
+
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= 10,
+			return -EINVAL);
+
+	set__AUD_PCMOUT_FMT__NUM_CH(pcm_player, runtime->channels / 2);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_start(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_player_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Un-reset PCM player */
+
+	set__AUD_PCMOUT_RST__SRSTP__RUNNING(pcm_player);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(pcm_player->fdma_channel,
+			&pcm_player->fdma_params);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
+				pcm_player->device->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch PCM player */
+
+	pcm_player->substream = substream;
+	set__AUD_PCMOUT_CTRL__MODE__PCM(pcm_player);
+
+	/* Enable player interrupts */
+
+	set__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(pcm_player);
+	set__AUD_PCMOUT_IT_EN_SET__UNF__SET(pcm_player);
+
+	/* Wake up & unmute DAC */
+
+	if (pcm_player->conv) {
+		snd_stm_conv_enable(pcm_player->conv);
+		snd_stm_conv_unmute(pcm_player->conv);
+	}
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_player_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* Mute & shutdown DAC */
+
+	if (pcm_player->conv) {
+		snd_stm_conv_mute(pcm_player->conv);
+		snd_stm_conv_disable(pcm_player->conv);
+	}
+
+	/* Disable interrupts */
+
+	set__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(pcm_player);
+	set__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(pcm_player);
+
+	/* Stop PCM player */
+
+	set__AUD_PCMOUT_CTRL__MODE__OFF(pcm_player);
+	pcm_player->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(pcm_player->fdma_channel);
+
+	/* Reset PCM player */
+	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_pause(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_player_pause(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* "Mute" player
+	 * Documentation describes this mode in a wrong way - data is _not_
+	 * consumed in the "mute" mode, so it is actually a "pause" mode */
+
+	set__AUD_PCMOUT_CTRL__MODE__MUTE(pcm_player);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_player_release(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+		snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_player_release(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	/* "Unmute" player */
+
+	set__AUD_PCMOUT_CTRL__MODE__PCM(pcm_player);
+
+	return 0;
+}
+
+static int snd_stm_pcm_player_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printd(1, "snd_stm_pcm_player_trigger(substream=0x%p,"
+			" command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_pcm_player_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_pcm_player_stop(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return snd_stm_pcm_player_pause(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return snd_stm_pcm_player_release(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_pcm_player_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printd(2, "snd_stm_pcm_player_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(pcm_player->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+static struct snd_pcm_ops snd_stm_pcm_player_pcm_ops = {
+	.open =      snd_stm_pcm_player_open,
+	.close =     snd_stm_pcm_player_close,
+	.mmap =      snd_stm_buffer_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_pcm_player_hw_params,
+	.hw_free =   snd_stm_pcm_player_hw_free,
+	.prepare =   snd_stm_pcm_player_prepare,
+	.trigger =   snd_stm_pcm_player_trigger,
+	.pointer =   snd_stm_pcm_player_pointer,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_PCMOUT_%s (offset 0x%02x) =" \
+				" 0x%08x\n", __stringify(r), \
+				offset__AUD_PCMOUT_##r(pcm_player), \
+				get__AUD_PCMOUT_##r(pcm_player))
+
+static void snd_stm_pcm_player_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_pcm_player *pcm_player = entry->private_data;
+
+	snd_assert(pcm_player, return);
+	snd_stm_magic_assert(pcm_player, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(FMT);
+}
+
+static int snd_stm_pcm_player_register(struct snd_device *snd_device)
+{
+	int result;
+	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_pcm_player_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	snd_stm_printd(0, "--- Registering player '%s'...\n",
+			pcm_player->device->bus_id);
+
+	/* Set reset mode */
+
+	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+
+	if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
+		set__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(pcm_player);
+	set__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(pcm_player);
+
+	/* Get frequency synthesizer channel */
+
+	snd_assert(pcm_player->info->fsynth_bus_id != NULL, return -EINVAL);
+	snd_stm_printd(0, "Player connected to %s's output %d.\n",
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+
+	pcm_player->fsynth_channel = snd_stm_fsynth_get_channel(
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+	snd_assert(pcm_player->fsynth_channel != NULL, return -EINVAL);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&pcm_player->proc_entry,
+			pcm_player->device->bus_id,
+			snd_stm_pcm_player_dump_registers, pcm_player);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(&platform_bus_type,
+			pcm_player->device->bus_id, snd_device->card,
+			pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_channel,
+			snd_device->card, pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int __exit snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_pcm_player_disconnect(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	snd_stm_info_unregister(pcm_player->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_pcm_player_snd_device_ops = {
+	.dev_register = snd_stm_pcm_player_register,
+	.dev_disconnect = snd_stm_pcm_player_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_pcm_player_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_pcm_player *pcm_player;
+	struct snd_card *card = snd_stm_card_get();
+	int i;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
+	if (!pcm_player) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(pcm_player);
+	pcm_player->info = pdev->dev.platform_data;
+	snd_assert(pcm_player->info != NULL, return -EINVAL);
+	pcm_player->ver = pcm_player->info->ver;
+	snd_assert(pcm_player->ver > 0, return -EINVAL);
+	pcm_player->device = &pdev->dev;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &pcm_player->mem_region,
+			&pcm_player->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	pcm_player->fifo_phys_address = pcm_player->mem_region->start +
+		offset__AUD_PCMOUT_DATA(pcm_player);
+	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+			pcm_player->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &pcm_player->irq,
+			snd_stm_pcm_player_irq_handler, pcm_player);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &pcm_player->fdma_channel);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* FDMA transfer size depends (among others ;-) on FIFO length,
+	 * which is:
+	 * - 30 cells (120 bytes) in STx710x and STx7200 cut 1.0
+	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
+
+	if (pcm_player->ver < ver__AUD_PCMOUT__65_1_3)
+		pcm_player->fdma_max_transfer_size = 2;
+	else if (pcm_player->ver == ver__AUD_PCMOUT__65_1_3)
+		pcm_player->fdma_max_transfer_size = 20;
+	else
+		pcm_player->fdma_max_transfer_size = 30;
+
+	/* Get player capabilities */
+
+	snd_stm_printd(0, "Player's name is '%s'\n", pcm_player->info->name);
+
+	snd_assert(pcm_player->info->channels > 0, return -EINVAL);
+	snd_assert(pcm_player->info->channels <= 10, return -EINVAL);
+	snd_assert(pcm_player->info->channels % 2 == 0, return -EINVAL);
+	if (pcm_player->ver > ver__AUD_PCMOUT__90_1_1) {
+		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
+
+		pcm_player->channels_constraint.list = channels_2_10;
+		pcm_player->channels_constraint.count =
+			pcm_player->info->channels / 2;
+	} else {
+		/* In STx7100 cut < 3.0 PCM player ignored NUM_CH setting in
+		 * AUD_PCMOUT_FMT register (and it was always in 10 channels
+		 * mode...) */
+		static unsigned int channels_10[] = { 10 };
+
+		pcm_player->channels_constraint.list = channels_10;
+		pcm_player->channels_constraint.count = 1;
+	}
+	pcm_player->channels_constraint.mask = 0;
+	for (i = 0; i < pcm_player->channels_constraint.count; i++)
+		snd_stm_printd(0, "Player capable of playing %u-channels PCM."
+				"\n", pcm_player->channels_constraint.list[i]);
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_player,
+			&snd_stm_pcm_player_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, pcm_player->info->card_device, 1, 0,
+			&pcm_player->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	pcm_player->pcm->private_data = pcm_player;
+	strcpy(pcm_player->pcm->name, pcm_player->info->name);
+
+	snd_pcm_set_ops(pcm_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_stm_pcm_player_pcm_ops);
+
+	/* Initialize buffer */
+
+	pcm_player->buffer = snd_stm_buffer_create(pcm_player->pcm,
+			pcm_player->device,
+			snd_stm_pcm_player_hw.buffer_bytes_max);
+	if (!pcm_player->buffer) {
+		snd_stm_printe("Cannot initialize buffer!\n");
+		result = -ENOMEM;
+		goto error_buffer_init;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, pcm_player);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_buffer_init:
+	/* snd_pcm_free() is not available - PCM device will be released
+	 * during card release */
+error_pcm:
+	snd_device_free(card, pcm_player);
+error_device:
+	snd_stm_fdma_release(pcm_player->fdma_channel);
+error_fdma_request:
+	snd_stm_irq_release(pcm_player->irq, pcm_player);
+error_irq_request:
+	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
+error_memory_request:
+	snd_stm_magic_clear(pcm_player);
+	kfree(pcm_player);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_player_remove(struct platform_device *pdev)
+{
+	struct snd_stm_pcm_player *pcm_player = platform_get_drvdata(pdev);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+
+	snd_stm_buffer_dispose(pcm_player->buffer);
+	snd_stm_fdma_release(pcm_player->fdma_channel);
+	snd_stm_irq_release(pcm_player->irq, pcm_player);
+	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
+
+	snd_stm_magic_clear(pcm_player);
+	kfree(pcm_player);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_pcm_player_driver = {
+	.driver = {
+		.name = "snd_pcm_player",
+	},
+	.probe = snd_stm_pcm_player_probe,
+	.remove = snd_stm_pcm_player_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_pcm_player_init(void)
+{
+	return platform_driver_register(&snd_stm_pcm_player_driver);
+}
+
+void snd_stm_pcm_player_exit(void)
+{
+	platform_driver_unregister(&snd_stm_pcm_player_driver);
+}
diff --git a/sound/stm/pcm_reader.c b/sound/stm/pcm_reader.c
new file mode 100644
index 0000000..9207240
--- /dev/null
+++ b/sound/stm/pcm_reader.c
@@ -0,0 +1,1004 @@
+/*
+ *   STMicroelectronics System-on-Chips' PCM reader driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/pcm_params.h>
+
+#define COMPONENT pcm_reader
+#include "common.h"
+#include "reg_aud_pcmin.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
+		SND_STM_FORMAT__SUBFRAME_32_BITS)
+
+
+
+/*
+ * PCM reader instance definition
+ */
+
+struct snd_stm_pcm_reader {
+	/* System informations */
+	struct snd_stm_pcm_reader_info *info;
+	struct device *device;
+	struct snd_pcm *pcm;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	int fdma_channel;
+
+	/* Environment settings */
+	struct snd_stm_conv *conv;
+	struct snd_pcm_hw_constraint_list channels_constraint;
+
+	/* Runtime data */
+	struct snd_stm_buffer *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	int fdma_max_transfer_size;
+	struct stm_dma_params *fdma_params_list;
+	struct stm_dma_req *fdma_request;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Capturing engine implementation
+ */
+
+static irqreturn_t snd_stm_pcm_reader_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_pcm_reader *pcm_reader = dev_id;
+	unsigned int status;
+
+	snd_stm_printd(2, "snd_stm_pcm_reader_irq_handler(irq=%d, "
+			"dev_id=0x%p)\n", irq, dev_id);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = get__AUD_PCMIN_ITS(pcm_reader);
+	set__AUD_PCMIN_ITS_CLR(pcm_reader, status);
+	preempt_enable();
+
+	/* Overflow? */
+	if (unlikely(status & mask__AUD_PCMIN_ITS__OVF__PENDING(pcm_reader))) {
+		snd_stm_printe("Overflow detected in PCM reader '%s'!\n",
+				pcm_reader->device->bus_id);
+		result = IRQ_HANDLED;
+		snd_pcm_stop(pcm_reader->substream, SNDRV_PCM_STATE_XRUN);
+	}
+
+	/* Period successfully played */
+	if (likely(status & mask__AUD_PCMIN_ITS__VSYNC__PENDING(pcm_reader))) {
+		snd_stm_printd(2, "Vsync interrupt detected by '%s'!\n",
+				pcm_reader->device->bus_id);
+		/* TODO: Calculate sampling frequency */
+		result = IRQ_HANDLED;
+	}
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+static void snd_stm_pcm_reader_callback_node_done(unsigned long param)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			(struct snd_stm_pcm_reader *)param;
+
+	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_done(param=0x%lx"
+			")\n", param);
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	/* This function will be called after stopping FDMA as well
+	 * and in this moment ALSA is already shut down... */
+	if (pcm_reader->substream) {
+		snd_stm_printd(2, "Period elapsed ('%s')\n",
+				pcm_reader->device->bus_id);
+		snd_pcm_period_elapsed(pcm_reader->substream);
+	}
+}
+
+static void snd_stm_pcm_reader_callback_node_error(unsigned long param)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			(struct snd_stm_pcm_reader *)param;
+
+	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_error(param=0x%lx"
+			")\n", param);
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	snd_stm_printe("Error during FDMA transfer in reader '%s'!\n",
+			pcm_reader->device->bus_id);
+}
+
+static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER),
+#if 0
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S16_LE),
+#else
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
+#endif
+
+	/* Keep in mind that we are working in slave mode, so sampling
+	 * rate is determined by external components... */
+	.rates		= (SNDRV_PCM_RATE_CONTINUOUS),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 10,
+
+	.periods_min	= 2,
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note: period_bytes_min defines minimum time between FDMA transfer
+	 * interrupts... Keep it large enough not to kill the system... */
+
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_pcm_reader_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_open(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Get attached converter handle */
+
+	pcm_reader->conv = snd_stm_conv_get_attached(&platform_bus_type,
+			pcm_reader->device->bus_id);
+	if (pcm_reader->conv)
+		snd_stm_printd(1, "Converter '%s' attached to '%s'...\n",
+				pcm_reader->conv->name,
+				pcm_reader->device->bus_id);
+	else
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+				pcm_reader->device->bus_id);
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	result = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_CHANNELS,
+			&pcm_reader->channels_constraint);
+	if (result < 0) {
+		snd_stm_printe("Can't set channels constraint!\n");
+		return result;
+	}
+
+	/* Buffer size must be an integer multiple of a period size to use
+	 * FDMA nodes as periods... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			pcm_reader->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
+	runtime->hw = snd_stm_pcm_reader_hw;
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (snd_stm_buffer_is_allocated(pcm_reader->buffer)) {
+		/* Free buffer */
+		snd_stm_buffer_free(pcm_reader->buffer);
+
+		/* Free FDMA parameters (whole list) */
+		dma_params_free(pcm_reader->fdma_params_list);
+		dma_req_free(pcm_reader->fdma_channel,
+				pcm_reader->fdma_request);
+		kfree(pcm_reader->fdma_params_list);
+	}
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes, period_bytes, periods, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_READ,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = pcm_reader->info->fdma_initiator,
+	};
+	int i;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This function may be called many times, so let's be prepared... */
+	if (snd_stm_buffer_is_allocated(pcm_reader->buffer))
+		snd_stm_pcm_reader_hw_free(substream);
+
+	/* Get the numbers... */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	periods = params_periods(hw_params);
+	period_bytes = buffer_bytes / periods;
+	snd_assert(periods * period_bytes == buffer_bytes, return -EINVAL);
+
+	/* Allocate buffer */
+
+	result = snd_stm_buffer_alloc(pcm_reader->buffer, substream,
+			buffer_bytes);
+	if (result != 0) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, pcm_reader->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
+	}
+
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			pcm_reader->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+
+	snd_stm_printd(1, "FDMA request trigger limit set to %d.\n",
+			transfer_size);
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_reader->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0) {
+		snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+				return -EINVAL);
+		snd_assert(transfer_size <=
+				mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(
+				pcm_reader), return -EINVAL);
+		set__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(pcm_reader, transfer_size);
+	}
+
+	/* Configure FDMA transfer */
+
+	pcm_reader->fdma_request = dma_req_config(pcm_reader->fdma_channel,
+			pcm_reader->info->fdma_request_line, &fdma_req_config);
+	if (!pcm_reader->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", pcm_reader->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
+
+	pcm_reader->fdma_params_list =
+			kmalloc(sizeof(*pcm_reader->fdma_params_list) *
+			periods, GFP_KERNEL);
+	if (!pcm_reader->fdma_params_list) {
+		snd_stm_printe("Can't allocate %d bytes for FDMA parameters "
+				"list!\n", sizeof(*pcm_reader->fdma_params_list)
+				* periods);
+		result = -ENOMEM;
+		goto error_params_alloc;
+	}
+
+	snd_stm_printd(1, "Configuring FDMA transfer nodes:\n");
+
+	for (i = 0; i < periods; i++) {
+		dma_params_init(&pcm_reader->fdma_params_list[i], MODE_PACED,
+				STM_DMA_LIST_CIRC);
+
+		if (i > 0)
+			dma_params_link(&pcm_reader->fdma_params_list[i - 1],
+					(&pcm_reader->fdma_params_list[i]));
+
+		dma_params_comp_cb(&pcm_reader->fdma_params_list[i],
+				snd_stm_pcm_reader_callback_node_done,
+				(unsigned long)pcm_reader,
+				STM_DMA_CB_CONTEXT_ISR);
+
+		dma_params_err_cb(&pcm_reader->fdma_params_list[i],
+				snd_stm_pcm_reader_callback_node_error,
+				(unsigned long)pcm_reader,
+				STM_DMA_CB_CONTEXT_ISR);
+
+		/* Get callback every time a node is completed */
+		dma_params_interrupts(&pcm_reader->fdma_params_list[i],
+				STM_DMA_NODE_COMP_INT);
+
+		dma_params_DIM_0_x_1(&pcm_reader->fdma_params_list[i]);
+
+		dma_params_req(&pcm_reader->fdma_params_list[i],
+				pcm_reader->fdma_request);
+
+		snd_stm_printd(1, "- %d: %d bytes from 0x%08x\n", i,
+				period_bytes,
+				runtime->dma_addr + i * period_bytes);
+
+		dma_params_addrs(&pcm_reader->fdma_params_list[i],
+				pcm_reader->fifo_phys_address,
+				runtime->dma_addr + i * period_bytes,
+				period_bytes);
+	}
+
+	result = dma_compile_list(pcm_reader->fdma_channel,
+				pcm_reader->fdma_params_list, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for"
+				" reader '%s'!\n", pcm_reader->device->bus_id);
+		goto error_compile_list;
+	}
+
+	return 0;
+
+error_compile_list:
+	kfree(pcm_reader->fdma_params_list);
+error_params_alloc:
+	dma_req_free(pcm_reader->fdma_channel,
+			pcm_reader->fdma_request);
+error_req_config:
+	snd_stm_buffer_free(pcm_reader->buffer);
+error_buf_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int format, lr_pol;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* Get format value from connected converter */
+
+	if (pcm_reader->conv)
+		format = snd_stm_conv_get_format(pcm_reader->conv);
+	else
+		format = DEFAULT_FORMAT;
+
+	/* Number of bits per subframe (which is one channel sample)
+	 * on input. */
+
+	switch (format & SND_STM_FORMAT__SUBFRAME_MASK) {
+	case SND_STM_FORMAT__SUBFRAME_32_BITS:
+		snd_stm_printd(1, "- 32 bits per subframe\n");
+		set__AUD_PCMIN_FMT__NBIT__32_BITS(pcm_reader);
+		set__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(pcm_reader);
+		break;
+	case SND_STM_FORMAT__SUBFRAME_16_BITS:
+		snd_stm_printd(1, "- 16 bits per subframe\n");
+		set__AUD_PCMIN_FMT__NBIT__16_BITS(pcm_reader);
+		set__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(pcm_reader);
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Serial audio interface format -
+	 * for detailed explanation see ie.
+	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+
+	set__AUD_PCMIN_FMT__ORDER__MSB_FIRST(pcm_reader);
+	set__AUD_PCMIN_FMT__SCLK_EDGE__RISING(pcm_reader);
+	switch (format & SND_STM_FORMAT__MASK) {
+	case SND_STM_FORMAT__I2S:
+		snd_stm_printd(1, "- I2S\n");
+		set__AUD_PCMIN_FMT__ALIGN__LEFT(pcm_reader);
+		set__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(pcm_reader);
+		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(pcm_reader);
+		break;
+	case SND_STM_FORMAT__LEFT_JUSTIFIED:
+		snd_stm_printd(1, "- left justified\n");
+		set__AUD_PCMIN_FMT__ALIGN__LEFT(pcm_reader);
+		set__AUD_PCMIN_FMT__PADDING__NO_DELAY(pcm_reader);
+		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(pcm_reader);
+		break;
+	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
+		snd_stm_printd(1, "- right justified\n");
+		set__AUD_PCMIN_FMT__ALIGN__RIGHT(pcm_reader);
+		set__AUD_PCMIN_FMT__PADDING__NO_DELAY(pcm_reader);
+		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(pcm_reader);
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Configure data memory format */
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		set__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(pcm_reader);
+
+		/* Workaround for a problem with L/R channels swap in case of
+		 * 16/16 memory model: PCM puts left channel data in
+		 * word's upper two bytes, but due to little endianess
+		 * character of our memory it will be interpreted as right
+		 * channel data...  The workaround is to invert L/R signal,
+		 * however it is cheating, because in such case channel
+		 * phases are shifted by one sample...
+		 * (ask me for more details if above is not clear ;-)
+		 * TODO this somehow better... */
+		set__AUD_PCMIN_FMT__LR_POL(pcm_reader, !lr_pol);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
+		 * left than zeros"... ;-) */
+		set__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(pcm_reader);
+
+		/* In x/0 bits memory mode there is no problem with
+		 * L/R polarity */
+		set__AUD_PCMIN_FMT__LR_POL(pcm_reader, lr_pol);
+		break;
+
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+
+	/* Number of channels... */
+
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= 10,
+			return -EINVAL);
+
+	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0)
+		set__AUD_PCMIN_FMT__NUM_CH(pcm_reader, runtime->channels / 2);
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_reader_start(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Un-reset PCM reader */
+
+	set__AUD_PCMIN_RST__RSTP__RUNNING(pcm_reader);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(pcm_reader->fdma_channel,
+			pcm_reader->fdma_params_list);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for reader '%s'!\n",
+				pcm_reader->device->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch PCM reader */
+
+	pcm_reader->substream = substream;
+	set__AUD_PCMIN_CTRL__MODE__PCM(pcm_reader);
+
+	/* Enable reader interrupts */
+
+	set__AUD_PCMIN_IT_EN_SET__VSYNC__SET(pcm_reader);
+	set__AUD_PCMIN_IT_EN_SET__OVF__SET(pcm_reader);
+
+	/* Wake up & unmute ADC */
+
+	if (pcm_reader->conv) {
+		snd_stm_conv_enable(pcm_reader->conv);
+		snd_stm_conv_unmute(pcm_reader->conv);
+	}
+
+	return 0;
+}
+
+static inline int snd_stm_pcm_reader_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	/* Mute & shutdown DAC */
+
+	if (pcm_reader->conv) {
+		snd_stm_conv_mute(pcm_reader->conv);
+		snd_stm_conv_disable(pcm_reader->conv);
+	}
+
+	/* Disable interrupts */
+
+	set__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(pcm_reader);
+	set__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(pcm_reader);
+
+	/* Stop PCM reader */
+
+	set__AUD_PCMIN_CTRL__MODE__OFF(pcm_reader);
+	pcm_reader->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(pcm_reader->fdma_channel);
+
+	/* Reset PCM reader */
+
+	set__AUD_PCMIN_RST__RSTP__RESET(pcm_reader);
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printd(1, "snd_stm_pcm_reader_trigger(substream=0x%p,"
+		       "command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_pcm_reader_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_pcm_reader_stop(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_pcm_reader_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printd(2, "snd_stm_pcm_reader_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(pcm_reader->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+static struct snd_pcm_ops snd_stm_pcm_reader_pcm_ops = {
+	.open =      snd_stm_pcm_reader_open,
+	.close =     snd_stm_pcm_reader_close,
+	.mmap =      snd_stm_buffer_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_pcm_reader_hw_params,
+	.hw_free =   snd_stm_pcm_reader_hw_free,
+	.prepare =   snd_stm_pcm_reader_prepare,
+	.trigger =   snd_stm_pcm_reader_trigger,
+	.pointer =   snd_stm_pcm_reader_pointer,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_PCMIN_%s (offset 0x%02x) = 0x%08x\n", \
+				__stringify(r), \
+				offset__AUD_PCMIN_##r(pcm_reader), \
+				get__AUD_PCMIN_##r(pcm_reader))
+
+static void snd_stm_pcm_reader_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_pcm_reader *pcm_reader = entry->private_data;
+
+	snd_assert(pcm_reader, return);
+	snd_stm_magic_assert(pcm_reader, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(FMT);
+}
+
+static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
+{
+	int result;
+	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	snd_stm_printd(0, "--- Registering reader '%s'...\n",
+			pcm_reader->device->bus_id);
+
+	/* Set reset mode */
+
+	set__AUD_PCMIN_RST__RSTP__RESET(pcm_reader);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+
+	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0)
+		set__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(pcm_reader);
+	set__AUD_PCMIN_CTRL__RND__NO_ROUNDING(pcm_reader);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&pcm_reader->proc_entry,
+			pcm_reader->device->bus_id,
+			snd_stm_pcm_reader_dump_registers, pcm_reader);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(&platform_bus_type,
+			pcm_reader->device->bus_id, snd_device->card,
+			pcm_reader->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_pcm_reader_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_pcm_reader_disconnect(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	snd_stm_info_unregister(pcm_reader->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_pcm_reader_snd_device_ops = {
+	.dev_register = snd_stm_pcm_reader_register,
+	.dev_disconnect = snd_stm_pcm_reader_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_pcm_reader_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_pcm_reader *pcm_reader;
+	struct snd_card *card = snd_stm_card_get();
+	int i;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
+	if (!pcm_reader) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(pcm_reader);
+	pcm_reader->info = pdev->dev.platform_data;
+	snd_assert(pcm_reader->info != NULL, return -EINVAL);
+	pcm_reader->ver = pcm_reader->info->ver;
+	snd_assert(pcm_reader->ver > 0, return -EINVAL);
+	pcm_reader->device = &pdev->dev;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &pcm_reader->mem_region,
+			&pcm_reader->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	pcm_reader->fifo_phys_address = pcm_reader->mem_region->start +
+			offset__AUD_PCMIN_DATA(pcm_reader);
+	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+			pcm_reader->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &pcm_reader->irq,
+			snd_stm_pcm_reader_irq_handler, pcm_reader);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &pcm_reader->fdma_channel);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* FDMA transfer size depends (among others ;-) on FIFO length,
+	 * which is:
+	 * - 2 cells (8 bytes) in STx710x and STx7200 cut 1.0
+	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
+
+	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_1)
+		pcm_reader->fdma_max_transfer_size = 2;
+	else
+		pcm_reader->fdma_max_transfer_size = 30;
+
+	/* Get component capabilities */
+
+	snd_stm_printd(0, "Reader's name is '%s'\n", pcm_reader->info->name);
+
+	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_3) {
+		/* STx7111 has a hardware bug in PCM reader in multichannels
+		 * mode, so we will just not be using it ;-) */
+		static unsigned int channels_2[] = { 2 };
+
+		snd_assert(pcm_reader->info->channels == 2, return -EINVAL);
+		pcm_reader->channels_constraint.list = channels_2;
+		pcm_reader->channels_constraint.count = 1;
+	} else {
+		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
+
+		snd_assert(pcm_reader->info->channels > 0, return -EINVAL);
+		snd_assert(pcm_reader->info->channels <= 10, return -EINVAL);
+		snd_assert(pcm_reader->info->channels % 2 == 0, return -EINVAL);
+		pcm_reader->channels_constraint.list = channels_2_10;
+		pcm_reader->channels_constraint.count =
+			pcm_reader->info->channels / 2;
+	}
+	pcm_reader->channels_constraint.mask = 0;
+	for (i = 0; i < pcm_reader->channels_constraint.count; i++)
+		snd_stm_printd(0, "Reader capable of capturing %u-channels PCM."
+				"\n", pcm_reader->channels_constraint.list[i]);
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_reader,
+			&snd_stm_pcm_reader_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, pcm_reader->info->card_device, 0, 1,
+		       &pcm_reader->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	pcm_reader->pcm->private_data = pcm_reader;
+	strcpy(pcm_reader->pcm->name, pcm_reader->info->name);
+
+	snd_pcm_set_ops(pcm_reader->pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_stm_pcm_reader_pcm_ops);
+
+	/* Initialize buffer */
+
+	pcm_reader->buffer = snd_stm_buffer_create(pcm_reader->pcm,
+			pcm_reader->device,
+			snd_stm_pcm_reader_hw.buffer_bytes_max);
+	if (!pcm_reader->buffer) {
+		snd_stm_printe("Cannot initialize buffer!\n");
+		result = -ENOMEM;
+		goto error_buffer_create;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, pcm_reader);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_buffer_create:
+	/* snd_pcm_free() is not available - PCM device will be released
+	 * during card release */
+error_pcm:
+	snd_device_free(card, pcm_reader);
+error_device:
+	snd_stm_fdma_release(pcm_reader->fdma_channel);
+error_fdma_request:
+	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
+error_irq_request:
+	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
+error_memory_request:
+	snd_stm_magic_clear(pcm_reader);
+	kfree(pcm_reader);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_pcm_reader_remove(struct platform_device *pdev)
+{
+	struct snd_stm_pcm_reader *pcm_reader = platform_get_drvdata(pdev);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+
+	snd_stm_buffer_dispose(pcm_reader->buffer);
+	snd_stm_fdma_release(pcm_reader->fdma_channel);
+	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
+	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
+
+	snd_stm_magic_clear(pcm_reader);
+	kfree(pcm_reader);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_pcm_reader_driver = {
+	.driver = {
+		.name = "snd_pcm_reader",
+	},
+	.probe = snd_stm_pcm_reader_probe,
+	.remove = snd_stm_pcm_reader_remove,
+};
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_pcm_reader_init(void)
+{
+	return platform_driver_register(&snd_stm_pcm_reader_driver);
+}
+
+void snd_stm_pcm_reader_exit(void)
+{
+	platform_driver_unregister(&snd_stm_pcm_reader_driver);
+}
diff --git a/sound/stm/reg_710x_audcfg.h b/sound/stm/reg_710x_audcfg.h
new file mode 100644
index 0000000..e5447ed
--- /dev/null
+++ b/sound/stm/reg_710x_audcfg.h
@@ -0,0 +1,176 @@
+#ifndef __SND_STM_710X_AUDCFG_H
+#define __SND_STM_710X_AUDCFG_H
+
+
+
+/*
+ * 710X_AUDCFG_IO_CTRL
+ */
+
+#define offset__710X_AUDCFG_IO_CTRL(ip) 0x00
+#define get__710X_AUDCFG_IO_CTRL(ip) readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+#define set__710X_AUDCFG_IO_CTRL(ip, value) writel((value), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+/* PCM_CLK_EN */
+
+#define shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0
+#define mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0x1
+#define get__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) ((readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip)) >> \
+	shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) & \
+	mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, value) \
+	writel((readl(ip->base + offset__710X_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))) | (((value) & \
+	mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) << \
+	shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) 0x0
+#define mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) 0x1
+#define mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip))
+
+/* DATA0_EN */
+
+#define shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip) 1
+#define mask__710X_AUDCFG_IO_CTRL__DATA0_EN(ip) 0x1
+#define get__710X_AUDCFG_IO_CTRL__DATA0_EN(ip) ((readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip)) >> \
+	shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip)) & \
+	mask__710X_AUDCFG_IO_CTRL__DATA0_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA0_EN(ip, value) \
+	writel((readl(ip->base + offset__710X_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__710X_AUDCFG_IO_CTRL__DATA0_EN(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip))) | (((value) & \
+	mask__710X_AUDCFG_IO_CTRL__DATA0_EN(ip)) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip)), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(ip) 0x0
+#define mask__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__DATA0_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(ip) 0x1
+#define mask__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA0_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__DATA0_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(ip))
+
+/* DATA1_EN */
+
+#define shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip) 2
+#define mask__710X_AUDCFG_IO_CTRL__DATA1_EN(ip) 0x1
+#define get__710X_AUDCFG_IO_CTRL__DATA1_EN(ip) ((readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip)) >> \
+	shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip)) & \
+	mask__710X_AUDCFG_IO_CTRL__DATA1_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA1_EN(ip, value) \
+	writel((readl(ip->base + offset__710X_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__710X_AUDCFG_IO_CTRL__DATA1_EN(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip))) | (((value) & \
+	mask__710X_AUDCFG_IO_CTRL__DATA1_EN(ip)) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip)), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(ip) 0x0
+#define mask__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__DATA1_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(ip) 0x1
+#define mask__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(ip) \
+	(value__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__DATA1_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(ip) \
+	set__710X_AUDCFG_IO_CTRL__DATA1_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(ip))
+
+/* SPDIF_EN */
+
+#define shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip) 3
+#define mask__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip) 0x1
+#define get__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip) ((readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip)) >> \
+	shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip)) & \
+	mask__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip, value) \
+	writel((readl(ip->base + offset__710X_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip))) | (((value) & \
+	mask__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip)) << \
+	shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip)), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(ip) 0x0
+#define mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(ip) \
+	(value__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(ip) \
+	set__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(ip) 0x1
+#define mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(ip) \
+	(value__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip))
+#define set__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(ip) \
+	set__710X_AUDCFG_IO_CTRL__SPDIF_EN(ip, \
+	value__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(ip))
+
+/* HDMI_AUD_SRC */
+
+#define shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip) 4
+#define mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip) 0x1
+#define get__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip) ((readl(ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip)) >> \
+	shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip)) & \
+	mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip))
+#define set__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip, value) \
+	writel((readl(ip->base + offset__710X_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip))) | (((value) & \
+	mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip)) << \
+	shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip)), ip->base + \
+	offset__710X_AUDCFG_IO_CTRL(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__PCM_PLAYER(ip) 0x0
+#define mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__PCM_PLAYER(ip) \
+	(value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__PCM_PLAYER(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip))
+#define set__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__PCM_PLAYER(ip) \
+	set__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip, \
+	value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__PCM_PLAYER(ip))
+
+#define value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__SPDIF_PLAYER(ip) 0x1
+#define mask__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__SPDIF_PLAYER(ip) \
+	(value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__SPDIF_PLAYER(ip) << \
+	shift__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip))
+#define set__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__SPDIF_PLAYER(ip) \
+	set__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC(ip, \
+	value__710X_AUDCFG_IO_CTRL__HDMI_AUD_SRC__SPDIF_PLAYER(ip))
+
+#endif
diff --git a/sound/stm/reg_7111_audcfg.h b/sound/stm/reg_7111_audcfg.h
new file mode 100644
index 0000000..9faad5d
--- /dev/null
+++ b/sound/stm/reg_7111_audcfg.h
@@ -0,0 +1,152 @@
+#ifndef __SND_STM_7111_AUDCFG_H
+#define __SND_STM_7111_AUDCFG_H
+
+
+
+/*
+ * 7111_AUDCFG_IO_CTRL
+ */
+
+#define offset__7111_AUDCFG_IO_CTRL(ip) 0x00
+#define get__7111_AUDCFG_IO_CTRL(ip) readl(ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+#define set__7111_AUDCFG_IO_CTRL(ip, value) writel((value), ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+
+/* PCM_CLK_EN */
+
+#define shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0
+#define mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0x1
+#define get__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) ((readl(ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) & \
+	mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, value) \
+	writel((readl(ip->base + offset__7111_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))) | (((value) & \
+	mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) << \
+	shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)), ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) 0x0
+#define mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) 0x1
+#define mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip))
+
+/* SPDIFHDMI_EN */
+
+#define shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) 3
+#define mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) 0x1
+#define get__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) ((readl(ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)) & \
+	mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, value) \
+	writel((readl(ip->base + offset__7111_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))) | (((value) & \
+	mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)) << \
+	shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)), ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) 0x0
+#define mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) 0x1
+#define mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip))
+
+/* PCMPLHDMI_EN */
+
+#define shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) 5
+#define mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) 0x1
+#define get__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) ((readl(ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)) & \
+	mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, value) \
+	writel((readl(ip->base + offset__7111_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))) | (((value) & \
+	mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)) << \
+	shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)), ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) 0x0
+#define mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) 0x1
+#define mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) \
+	(value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) \
+	set__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, \
+	value__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip))
+
+/* CLKREC_SEL */
+
+#define shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip) 9
+#define mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip) 0x3
+#define get__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip) ((readl(ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip)) & \
+	mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip, value) \
+	writel((readl(ip->base + offset__7111_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip))) | (((value) & \
+	mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip)) << \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip)), ip->base + \
+	offset__7111_AUDCFG_IO_CTRL(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) 0x0
+#define mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) \
+	(value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) \
+	set__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) 0x1
+#define mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) \
+	(value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7111_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) \
+	set__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip))
+
+#define value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) 0x2
+#define mask__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) \
+	(value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) << \
+	shift__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) \
+	set__7111_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7111_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip))
+
+#endif
diff --git a/sound/stm/reg_7200_audcfg.h b/sound/stm/reg_7200_audcfg.h
new file mode 100644
index 0000000..25d765e
--- /dev/null
+++ b/sound/stm/reg_7200_audcfg.h
@@ -0,0 +1,408 @@
+#ifndef __SND_STM_7200_AUDCFG_H
+#define __SND_STM_7200_AUDCFG_H
+
+
+
+/*
+ * 7200_AUDCFG_IOMUX_CTRL
+ */
+
+#define offset__7200_AUDCFG_IOMUX_CTRL(ip) 0x00
+#define get__7200_AUDCFG_IOMUX_CTRL(ip) readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL(ip, value) writel((value), \
+	ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+/* PCM_CLK_EN */
+
+#define shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip) 0
+#define mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip) 0x1
+#define get__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip)) >> \
+	shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip)) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip))) | (((value) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip)) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip)), ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(ip) 0x0
+#define mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(ip) 0x1
+#define mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(ip))
+
+/* DATA0_EN */
+
+#define shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip) 1
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip) 0x1
+#define get__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip)) >> \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip)) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip))) | (((value) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip)) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip)), ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(ip) 0x0
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(ip) 0x1
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA0_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(ip))
+
+/* DATA1_EN */
+
+#define shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip) 2
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip) 0x1
+#define get__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip)) >> \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip)) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip))) | (((value) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip)) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip)), ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(ip) 0x0
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(ip) 0x1
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA1_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(ip))
+
+/* DATA2_EN */
+
+#define shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip) 3
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip) 0x1
+#define get__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip)) >> \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip)) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip))) | (((value) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip)) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip)), ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(ip) 0x0
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(ip) 0x1
+#define mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__DATA2_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(ip))
+
+/* SPDIF_EN */
+
+#define shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip) 4
+#define mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip) 0x1
+#define get__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip)) >> \
+	shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip)) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_IOMUX_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip))) | (((value) & \
+	mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip)) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip)), ip->base + \
+	offset__7200_AUDCFG_IOMUX_CTRL(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(ip) 0x0
+#define mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(ip))
+
+#define value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(ip) 0x1
+#define mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(ip) \
+	(value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(ip) << \
+	shift__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip))
+#define set__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(ip) \
+	set__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN(ip, \
+	value__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(ip))
+
+
+
+/*
+ * 7200_AUDCFG_HDMI_CTRL
+ */
+
+#define offset__7200_AUDCFG_HDMI_CTRL(ip) 0x04
+#define get__7200_AUDCFG_HDMI_CTRL(ip) readl(ip->base + \
+	offset__7200_AUDCFG_HDMI_CTRL(ip))
+#define set__7200_AUDCFG_HDMI_CTRL(ip, value) writel((value), ip->base \
+	+ offset__7200_AUDCFG_HDMI_CTRL(ip))
+
+/* HDMI_DEBUG */
+
+#define shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip) 0
+#define mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip) 0x1
+#define get__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_HDMI_CTRL(ip)) >> \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip)) & \
+	mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip))
+#define set__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_HDMI_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip))) | (((value) & \
+	mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip)) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip)), ip->base + \
+	offset__7200_AUDCFG_HDMI_CTRL(ip))
+
+#define value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__PCM_PLAYERS(ip) 0x0
+#define mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__PCM_PLAYERS(ip) \
+	(value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__PCM_PLAYERS(ip) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip))
+#define set__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__PCM_PLAYERS(ip) \
+	set__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip, \
+	value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__PCM_PLAYERS(ip))
+
+#define value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__HDMI(ip) 0x1
+#define mask__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__HDMI(ip) \
+	(value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__HDMI(ip) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip))
+#define set__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__HDMI(ip) \
+	set__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG(ip, \
+	value__7200_AUDCFG_HDMI_CTRL__HDMI_DEBUG__HDMI(ip))
+
+/* HDMI_SPDIF */
+
+#define shift__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip) 1
+#define mask__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip) 0x1
+#define get__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip) ((readl(ip->base + \
+	offset__7200_AUDCFG_HDMI_CTRL(ip)) >> \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip)) & \
+	mask__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip))
+#define set__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_HDMI_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip))) | (((value) & \
+	mask__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip)) << \
+	shift__7200_AUDCFG_HDMI_CTRL__HDMI_SPDIF(ip)), ip->base + \
+	offset__7200_AUDCFG_HDMI_CTRL(ip))
+
+
+
+/*
+ * 7200_AUDCFG_RECOVERY_CTRL
+ */
+
+#define offset__7200_AUDCFG_RECOVERY_CTRL(ip) 0x08
+#define get__7200_AUDCFG_RECOVERY_CTRL(ip) readl(ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL(ip, value) writel((value), \
+	ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+/* RECO_EN0 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip) 0
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip) 0x1
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN0(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+/* RECO_SEL0 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip) 1
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip) 0x3
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK0(ip) 0x0
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK0(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK0(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK0(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK0(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK1(ip) 0x1
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK1(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK1(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK1(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK1(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK2(ip) 0x2
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK2(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK2(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK2(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK2(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK3(ip) 0x3
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK3(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK3(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK3(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL0__CLK3(ip))
+
+/* RECO_EXT0 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip) 3
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip) 0x1
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT0(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+/* RECO_EN1 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip) 4
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip) 0x1
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EN1(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+/* RECO_SEL1 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip) 5
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip) 0x3
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK0(ip) 0x0
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK0(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK0(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK0(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK0(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK1(ip) 0x1
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK1(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK1(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK1(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK1(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK2(ip) 0x2
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK2(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK2(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK2(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK2(ip))
+
+#define value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK3(ip) 0x3
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK3(ip) \
+	(value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK3(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK3(ip) \
+	set__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1(ip, \
+	value__7200_AUDCFG_RECOVERY_CTRL__RECO_SEL1__CLK3(ip))
+
+/* RECO_EXT1 */
+
+#define shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip) 7
+#define mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip) 0x1
+#define get__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip) ((readl(ip->base \
+	+ offset__7200_AUDCFG_RECOVERY_CTRL(ip)) >> \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip)) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip))
+#define set__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip, value) \
+	writel((readl(ip->base + offset__7200_AUDCFG_RECOVERY_CTRL(ip)) & \
+	~(mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip))) | (((value) & \
+	mask__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip)) << \
+	shift__7200_AUDCFG_RECOVERY_CTRL__RECO_EXT1(ip)), ip->base + \
+	offset__7200_AUDCFG_RECOVERY_CTRL(ip))
+
+#endif
diff --git a/sound/stm/reg_aud_pcmin.h b/sound/stm/reg_aud_pcmin.h
new file mode 100644
index 0000000..cb4c113
--- /dev/null
+++ b/sound/stm/reg_aud_pcmin.h
@@ -0,0 +1,1015 @@
+#ifndef __SND_STM_AUD_PCMIN_H
+#define __SND_STM_AUD_PCMIN_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_PCMIN__90_1_1 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_PCMIN__90_2_0 2
+
+/* 7200 1.0 */
+#define ver__AUD_PCMIN__65_2_0 3
+
+/* 7111 */
+#define ver__AUD_PCMIN__65_3_1 4
+
+/* 7200 2.0 */
+#define ver__AUD_PCMIN__65_3_3 5
+
+
+
+/*
+ * AUD_PCMIN_RST
+ */
+
+#define offset__AUD_PCMIN_RST(ip) 0x00
+#define get__AUD_PCMIN_RST(ip) readl(ip->base + \
+	offset__AUD_PCMIN_RST(ip))
+#define set__AUD_PCMIN_RST(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_RST(ip))
+
+/* RSTP */
+
+#define shift__AUD_PCMIN_RST__RSTP(ip) 0
+#define mask__AUD_PCMIN_RST__RSTP(ip) 0x1
+#define get__AUD_PCMIN_RST__RSTP(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_RST(ip)) >> shift__AUD_PCMIN_RST__RSTP(ip)) & \
+	mask__AUD_PCMIN_RST__RSTP(ip))
+#define set__AUD_PCMIN_RST__RSTP(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_RST(ip)) & ~(mask__AUD_PCMIN_RST__RSTP(ip) << \
+	shift__AUD_PCMIN_RST__RSTP(ip))) | (((value) & \
+	mask__AUD_PCMIN_RST__RSTP(ip)) << shift__AUD_PCMIN_RST__RSTP(ip)), \
+	ip->base + offset__AUD_PCMIN_RST(ip))
+
+#define value__AUD_PCMIN_RST__RSTP__RUNNING(ip) 0x0
+#define mask__AUD_PCMIN_RST__RSTP__RUNNING(ip) \
+	(value__AUD_PCMIN_RST__RSTP__RUNNING(ip) << \
+	shift__AUD_PCMIN_RST__RSTP(ip))
+#define set__AUD_PCMIN_RST__RSTP__RUNNING(ip) \
+	set__AUD_PCMIN_RST__RSTP(ip, value__AUD_PCMIN_RST__RSTP__RUNNING(ip))
+
+#define value__AUD_PCMIN_RST__RSTP__RESET(ip) 0x1
+#define mask__AUD_PCMIN_RST__RSTP__RESET(ip) \
+	(value__AUD_PCMIN_RST__RSTP__RESET(ip) << \
+	shift__AUD_PCMIN_RST__RSTP(ip))
+#define set__AUD_PCMIN_RST__RSTP__RESET(ip) \
+	set__AUD_PCMIN_RST__RSTP(ip, value__AUD_PCMIN_RST__RSTP__RESET(ip))
+
+
+
+/*
+ * AUD_PCMIN_DATA
+ */
+
+#define offset__AUD_PCMIN_DATA(ip) 0x04
+#define get__AUD_PCMIN_DATA(ip) readl(ip->base + \
+	offset__AUD_PCMIN_DATA(ip))
+#define set__AUD_PCMIN_DATA(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_DATA(ip))
+
+/* DATA */
+
+#define shift__AUD_PCMIN_DATA__DATA(ip) 0
+#define mask__AUD_PCMIN_DATA__DATA(ip) 0xffffffff
+#define get__AUD_PCMIN_DATA__DATA(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_DATA(ip)) >> shift__AUD_PCMIN_DATA__DATA(ip)) & \
+	mask__AUD_PCMIN_DATA__DATA(ip))
+#define set__AUD_PCMIN_DATA__DATA(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_DATA(ip)) & ~(mask__AUD_PCMIN_DATA__DATA(ip) << \
+	shift__AUD_PCMIN_DATA__DATA(ip))) | (((value) & \
+	mask__AUD_PCMIN_DATA__DATA(ip)) << shift__AUD_PCMIN_DATA__DATA(ip)), \
+	ip->base + offset__AUD_PCMIN_DATA(ip))
+
+
+
+/*
+ * AUD_PCMIN_ITS
+ */
+
+#define offset__AUD_PCMIN_ITS(ip) 0x08
+#define get__AUD_PCMIN_ITS(ip) readl(ip->base + \
+	offset__AUD_PCMIN_ITS(ip))
+#define set__AUD_PCMIN_ITS(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_ITS(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_ITS__OVF(ip) 0
+#define mask__AUD_PCMIN_ITS__OVF(ip) 0x1
+#define get__AUD_PCMIN_ITS__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_ITS(ip)) >> shift__AUD_PCMIN_ITS__OVF(ip)) & \
+	mask__AUD_PCMIN_ITS__OVF(ip))
+#define set__AUD_PCMIN_ITS__OVF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_ITS(ip)) & ~(mask__AUD_PCMIN_ITS__OVF(ip) << \
+	shift__AUD_PCMIN_ITS__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_ITS__OVF(ip)) << shift__AUD_PCMIN_ITS__OVF(ip)), \
+	ip->base + offset__AUD_PCMIN_ITS(ip))
+
+#define value__AUD_PCMIN_ITS__OVF__PENDING(ip) 0x1
+#define mask__AUD_PCMIN_ITS__OVF__PENDING(ip) \
+	(value__AUD_PCMIN_ITS__OVF__PENDING(ip) << \
+	shift__AUD_PCMIN_ITS__OVF(ip))
+#define set__AUD_PCMIN_ITS__OVF__PENDING(ip) \
+	set__AUD_PCMIN_ITS__OVF(ip, value__AUD_PCMIN_ITS__OVF__PENDING(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_ITS__VSYNC(ip) 1
+#define mask__AUD_PCMIN_ITS__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_ITS__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_ITS(ip)) >> shift__AUD_PCMIN_ITS__VSYNC(ip)) & \
+	mask__AUD_PCMIN_ITS__VSYNC(ip))
+#define set__AUD_PCMIN_ITS__VSYNC(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_ITS(ip)) & ~(mask__AUD_PCMIN_ITS__VSYNC(ip) << \
+	shift__AUD_PCMIN_ITS__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_ITS__VSYNC(ip)) << shift__AUD_PCMIN_ITS__VSYNC(ip)), \
+	ip->base + offset__AUD_PCMIN_ITS(ip))
+
+#define value__AUD_PCMIN_ITS__VSYNC__PENDING(ip) 0x1
+#define mask__AUD_PCMIN_ITS__VSYNC__PENDING(ip) \
+	(value__AUD_PCMIN_ITS__VSYNC__PENDING(ip) << \
+	shift__AUD_PCMIN_ITS__VSYNC(ip))
+#define set__AUD_PCMIN_ITS__VSYNC__PENDING(ip) \
+	set__AUD_PCMIN_ITS__VSYNC(ip, \
+	value__AUD_PCMIN_ITS__VSYNC__PENDING(ip))
+
+
+
+/*
+ * AUD_PCMIN_ITS_CLR
+ */
+
+#define offset__AUD_PCMIN_ITS_CLR(ip) 0x0c
+#define get__AUD_PCMIN_ITS_CLR(ip) readl(ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip))
+#define set__AUD_PCMIN_ITS_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_ITS_CLR__OVF(ip) 0
+#define mask__AUD_PCMIN_ITS_CLR__OVF(ip) 0x1
+#define get__AUD_PCMIN_ITS_CLR__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip)) >> shift__AUD_PCMIN_ITS_CLR__OVF(ip)) & \
+	mask__AUD_PCMIN_ITS_CLR__OVF(ip))
+#define set__AUD_PCMIN_ITS_CLR__OVF(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_ITS_CLR(ip)) & ~(mask__AUD_PCMIN_ITS_CLR__OVF(ip) \
+	<< shift__AUD_PCMIN_ITS_CLR__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_ITS_CLR__OVF(ip)) << \
+	shift__AUD_PCMIN_ITS_CLR__OVF(ip)), ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip))
+
+#define value__AUD_PCMIN_ITS_CLR__OVF__CLEAR(ip) 0x1
+#define mask__AUD_PCMIN_ITS_CLR__OVF__CLEAR(ip) \
+	(value__AUD_PCMIN_ITS_CLR__OVF__CLEAR(ip) << \
+	shift__AUD_PCMIN_ITS_CLR__OVF(ip))
+#define set__AUD_PCMIN_ITS_CLR__OVF__CLEAR(ip) \
+	set__AUD_PCMIN_ITS_CLR__OVF(ip, \
+	value__AUD_PCMIN_ITS_CLR__OVF__CLEAR(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_ITS_CLR__VSYNC(ip) 1
+#define mask__AUD_PCMIN_ITS_CLR__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_ITS_CLR__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip)) >> shift__AUD_PCMIN_ITS_CLR__VSYNC(ip)) \
+	& mask__AUD_PCMIN_ITS_CLR__VSYNC(ip))
+#define set__AUD_PCMIN_ITS_CLR__VSYNC(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_ITS_CLR(ip)) & \
+	~(mask__AUD_PCMIN_ITS_CLR__VSYNC(ip) << \
+	shift__AUD_PCMIN_ITS_CLR__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_ITS_CLR__VSYNC(ip)) << \
+	shift__AUD_PCMIN_ITS_CLR__VSYNC(ip)), ip->base + \
+	offset__AUD_PCMIN_ITS_CLR(ip))
+
+
+
+/*
+ * AUD_PCMIN_IT_EN
+ */
+
+#define offset__AUD_PCMIN_IT_EN(ip) 0x10
+#define get__AUD_PCMIN_IT_EN(ip) readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip))
+#define set__AUD_PCMIN_IT_EN(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_IT_EN__OVF(ip) 0
+#define mask__AUD_PCMIN_IT_EN__OVF(ip) 0x1
+#define get__AUD_PCMIN_IT_EN__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip)) >> shift__AUD_PCMIN_IT_EN__OVF(ip)) & \
+	mask__AUD_PCMIN_IT_EN__OVF(ip))
+#define set__AUD_PCMIN_IT_EN__OVF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip)) & ~(mask__AUD_PCMIN_IT_EN__OVF(ip) << \
+	shift__AUD_PCMIN_IT_EN__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN__OVF(ip)) << shift__AUD_PCMIN_IT_EN__OVF(ip)), \
+	ip->base + offset__AUD_PCMIN_IT_EN(ip))
+
+#define value__AUD_PCMIN_IT_EN__OVF__DISABLED(ip) 0x0
+#define mask__AUD_PCMIN_IT_EN__OVF__DISABLED(ip) \
+	(value__AUD_PCMIN_IT_EN__OVF__DISABLED(ip) << \
+	shift__AUD_PCMIN_IT_EN__OVF(ip))
+#define set__AUD_PCMIN_IT_EN__OVF__DISABLED(ip) \
+	set__AUD_PCMIN_IT_EN__OVF(ip, \
+	value__AUD_PCMIN_IT_EN__OVF__DISABLED(ip))
+
+#define value__AUD_PCMIN_IT_EN__OVF__ENABLED(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN__OVF__ENABLED(ip) \
+	(value__AUD_PCMIN_IT_EN__OVF__ENABLED(ip) << \
+	shift__AUD_PCMIN_IT_EN__OVF(ip))
+#define set__AUD_PCMIN_IT_EN__OVF__ENABLED(ip) \
+	set__AUD_PCMIN_IT_EN__OVF(ip, \
+	value__AUD_PCMIN_IT_EN__OVF__ENABLED(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_IT_EN__VSYNC(ip) 1
+#define mask__AUD_PCMIN_IT_EN__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_IT_EN__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip)) >> shift__AUD_PCMIN_IT_EN__VSYNC(ip)) & \
+	mask__AUD_PCMIN_IT_EN__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN__VSYNC(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_IT_EN(ip)) & ~(mask__AUD_PCMIN_IT_EN__VSYNC(ip) << \
+	shift__AUD_PCMIN_IT_EN__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN__VSYNC(ip)) << \
+	shift__AUD_PCMIN_IT_EN__VSYNC(ip)), ip->base + \
+	offset__AUD_PCMIN_IT_EN(ip))
+
+#define value__AUD_PCMIN_IT_EN__VSYNC__DISABLED(ip) 0x0
+#define mask__AUD_PCMIN_IT_EN__VSYNC__DISABLED(ip) \
+	(value__AUD_PCMIN_IT_EN__VSYNC__DISABLED(ip) << \
+	shift__AUD_PCMIN_IT_EN__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN__VSYNC__DISABLED(ip) \
+	set__AUD_PCMIN_IT_EN__VSYNC(ip, \
+	value__AUD_PCMIN_IT_EN__VSYNC__DISABLED(ip))
+
+#define value__AUD_PCMIN_IT_EN__VSYNC__ENABLED(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN__VSYNC__ENABLED(ip) \
+	(value__AUD_PCMIN_IT_EN__VSYNC__ENABLED(ip) << \
+	shift__AUD_PCMIN_IT_EN__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN__VSYNC__ENABLED(ip) \
+	set__AUD_PCMIN_IT_EN__VSYNC(ip, \
+	value__AUD_PCMIN_IT_EN__VSYNC__ENABLED(ip))
+
+
+
+/*
+ * AUD_PCMIN_IT_EN_SET
+ */
+
+#define offset__AUD_PCMIN_IT_EN_SET(ip) 0x14
+#define get__AUD_PCMIN_IT_EN_SET(ip) readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip))
+#define set__AUD_PCMIN_IT_EN_SET(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_IT_EN_SET__OVF(ip) 0
+#define mask__AUD_PCMIN_IT_EN_SET__OVF(ip) 0x1
+#define get__AUD_PCMIN_IT_EN_SET__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip)) >> \
+	shift__AUD_PCMIN_IT_EN_SET__OVF(ip)) & \
+	mask__AUD_PCMIN_IT_EN_SET__OVF(ip))
+#define set__AUD_PCMIN_IT_EN_SET__OVF(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_IT_EN_SET(ip)) & \
+	~(mask__AUD_PCMIN_IT_EN_SET__OVF(ip) << \
+	shift__AUD_PCMIN_IT_EN_SET__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN_SET__OVF(ip)) << \
+	shift__AUD_PCMIN_IT_EN_SET__OVF(ip)), ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip))
+
+#define value__AUD_PCMIN_IT_EN_SET__OVF__SET(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN_SET__OVF__SET(ip) \
+	(value__AUD_PCMIN_IT_EN_SET__OVF__SET(ip) << \
+	shift__AUD_PCMIN_IT_EN_SET__OVF(ip))
+#define set__AUD_PCMIN_IT_EN_SET__OVF__SET(ip) \
+	set__AUD_PCMIN_IT_EN_SET__OVF(ip, \
+	value__AUD_PCMIN_IT_EN_SET__OVF__SET(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_IT_EN_SET__VSYNC(ip) 1
+#define mask__AUD_PCMIN_IT_EN_SET__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_IT_EN_SET__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip)) >> \
+	shift__AUD_PCMIN_IT_EN_SET__VSYNC(ip)) & \
+	mask__AUD_PCMIN_IT_EN_SET__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN_SET__VSYNC(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_IT_EN_SET(ip)) & \
+	~(mask__AUD_PCMIN_IT_EN_SET__VSYNC(ip) << \
+	shift__AUD_PCMIN_IT_EN_SET__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN_SET__VSYNC(ip)) << \
+	shift__AUD_PCMIN_IT_EN_SET__VSYNC(ip)), ip->base + \
+	offset__AUD_PCMIN_IT_EN_SET(ip))
+
+#define value__AUD_PCMIN_IT_EN_SET__VSYNC__SET(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN_SET__VSYNC__SET(ip) \
+	(value__AUD_PCMIN_IT_EN_SET__VSYNC__SET(ip) << \
+	shift__AUD_PCMIN_IT_EN_SET__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN_SET__VSYNC__SET(ip) \
+	set__AUD_PCMIN_IT_EN_SET__VSYNC(ip, \
+	value__AUD_PCMIN_IT_EN_SET__VSYNC__SET(ip))
+
+
+
+/*
+ * AUD_PCMIN_IT_EN_CLR
+ */
+
+#define offset__AUD_PCMIN_IT_EN_CLR(ip) 0x18
+#define get__AUD_PCMIN_IT_EN_CLR(ip) readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip))
+#define set__AUD_PCMIN_IT_EN_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_IT_EN_CLR__OVF(ip) 0
+#define mask__AUD_PCMIN_IT_EN_CLR__OVF(ip) 0x1
+#define get__AUD_PCMIN_IT_EN_CLR__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip)) >> \
+	shift__AUD_PCMIN_IT_EN_CLR__OVF(ip)) & \
+	mask__AUD_PCMIN_IT_EN_CLR__OVF(ip))
+#define set__AUD_PCMIN_IT_EN_CLR__OVF(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_IT_EN_CLR(ip)) & \
+	~(mask__AUD_PCMIN_IT_EN_CLR__OVF(ip) << \
+	shift__AUD_PCMIN_IT_EN_CLR__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN_CLR__OVF(ip)) << \
+	shift__AUD_PCMIN_IT_EN_CLR__OVF(ip)), ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip))
+
+#define value__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(ip) \
+	(value__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(ip) << \
+	shift__AUD_PCMIN_IT_EN_CLR__OVF(ip))
+#define set__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(ip) \
+	set__AUD_PCMIN_IT_EN_CLR__OVF(ip, \
+	value__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_IT_EN_CLR__VSYNC(ip) 1
+#define mask__AUD_PCMIN_IT_EN_CLR__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_IT_EN_CLR__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip)) >> \
+	shift__AUD_PCMIN_IT_EN_CLR__VSYNC(ip)) & \
+	mask__AUD_PCMIN_IT_EN_CLR__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN_CLR__VSYNC(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_IT_EN_CLR(ip)) & \
+	~(mask__AUD_PCMIN_IT_EN_CLR__VSYNC(ip) << \
+	shift__AUD_PCMIN_IT_EN_CLR__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_IT_EN_CLR__VSYNC(ip)) << \
+	shift__AUD_PCMIN_IT_EN_CLR__VSYNC(ip)), ip->base + \
+	offset__AUD_PCMIN_IT_EN_CLR(ip))
+
+#define value__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(ip) 0x1
+#define mask__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(ip) \
+	(value__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(ip) << \
+	shift__AUD_PCMIN_IT_EN_CLR__VSYNC(ip))
+#define set__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(ip) \
+	set__AUD_PCMIN_IT_EN_CLR__VSYNC(ip, \
+	value__AUD_PCMIN_IT_EN_CLR__VSYNC__CLEAR(ip))
+
+
+
+/*
+ * AUD_PCMIN_CTRL
+ */
+
+#define offset__AUD_PCMIN_CTRL(ip) 0x1c
+#define get__AUD_PCMIN_CTRL(ip) readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip))
+#define set__AUD_PCMIN_CTRL(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_CTRL(ip))
+
+/* MODE */
+
+#define shift__AUD_PCMIN_CTRL__MODE(ip) 0
+#define mask__AUD_PCMIN_CTRL__MODE(ip) 0x3
+#define get__AUD_PCMIN_CTRL__MODE(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) >> shift__AUD_PCMIN_CTRL__MODE(ip)) & \
+	mask__AUD_PCMIN_CTRL__MODE(ip))
+#define set__AUD_PCMIN_CTRL__MODE(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) & ~(mask__AUD_PCMIN_CTRL__MODE(ip) << \
+	shift__AUD_PCMIN_CTRL__MODE(ip))) | (((value) & \
+	mask__AUD_PCMIN_CTRL__MODE(ip)) << shift__AUD_PCMIN_CTRL__MODE(ip)), \
+	ip->base + offset__AUD_PCMIN_CTRL(ip))
+
+#define value__AUD_PCMIN_CTRL__MODE__OFF(ip) 0x0
+#define mask__AUD_PCMIN_CTRL__MODE__OFF(ip) \
+	(value__AUD_PCMIN_CTRL__MODE__OFF(ip) << \
+	shift__AUD_PCMIN_CTRL__MODE(ip))
+#define set__AUD_PCMIN_CTRL__MODE__OFF(ip) \
+	set__AUD_PCMIN_CTRL__MODE(ip, value__AUD_PCMIN_CTRL__MODE__OFF(ip))
+
+#define value__AUD_PCMIN_CTRL__MODE__PCM(ip) 0x2
+#define mask__AUD_PCMIN_CTRL__MODE__PCM(ip) \
+	(value__AUD_PCMIN_CTRL__MODE__PCM(ip) << \
+	shift__AUD_PCMIN_CTRL__MODE(ip))
+#define set__AUD_PCMIN_CTRL__MODE__PCM(ip) \
+	set__AUD_PCMIN_CTRL__MODE(ip, value__AUD_PCMIN_CTRL__MODE__PCM(ip))
+
+#define value__AUD_PCMIN_CTRL__MODE__CD(ip) 0x3
+#define mask__AUD_PCMIN_CTRL__MODE__CD(ip) \
+	(value__AUD_PCMIN_CTRL__MODE__CD(ip) << \
+	shift__AUD_PCMIN_CTRL__MODE(ip))
+#define set__AUD_PCMIN_CTRL__MODE__CD(ip) \
+	set__AUD_PCMIN_CTRL__MODE(ip, value__AUD_PCMIN_CTRL__MODE__CD(ip))
+
+/* MEM_FMT */
+
+#define shift__AUD_PCMIN_CTRL__MEM_FMT(ip) 2
+#define mask__AUD_PCMIN_CTRL__MEM_FMT(ip) 0x1
+#define get__AUD_PCMIN_CTRL__MEM_FMT(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) >> shift__AUD_PCMIN_CTRL__MEM_FMT(ip)) & \
+	mask__AUD_PCMIN_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMIN_CTRL__MEM_FMT(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_CTRL(ip)) & ~(mask__AUD_PCMIN_CTRL__MEM_FMT(ip) << \
+	shift__AUD_PCMIN_CTRL__MEM_FMT(ip))) | (((value) & \
+	mask__AUD_PCMIN_CTRL__MEM_FMT(ip)) << \
+	shift__AUD_PCMIN_CTRL__MEM_FMT(ip)), ip->base + \
+	offset__AUD_PCMIN_CTRL(ip))
+
+#define value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(ip) 0x0
+#define mask__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(ip) \
+	(value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(ip) << \
+	shift__AUD_PCMIN_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(ip) \
+	set__AUD_PCMIN_CTRL__MEM_FMT(ip, \
+	value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(ip))
+
+#define value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(ip) 0x1
+#define mask__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(ip) \
+	(value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(ip) << \
+	shift__AUD_PCMIN_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(ip) \
+	set__AUD_PCMIN_CTRL__MEM_FMT(ip, \
+	value__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_16_BITS(ip))
+
+/* RND */
+
+#define shift__AUD_PCMIN_CTRL__RND(ip) 3
+#define mask__AUD_PCMIN_CTRL__RND(ip) 0x1
+#define get__AUD_PCMIN_CTRL__RND(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) >> shift__AUD_PCMIN_CTRL__RND(ip)) & \
+	mask__AUD_PCMIN_CTRL__RND(ip))
+#define set__AUD_PCMIN_CTRL__RND(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) & ~(mask__AUD_PCMIN_CTRL__RND(ip) << \
+	shift__AUD_PCMIN_CTRL__RND(ip))) | (((value) & \
+	mask__AUD_PCMIN_CTRL__RND(ip)) << shift__AUD_PCMIN_CTRL__RND(ip)), \
+	ip->base + offset__AUD_PCMIN_CTRL(ip))
+
+#define value__AUD_PCMIN_CTRL__RND__NO_ROUNDING(ip) 0x0
+#define mask__AUD_PCMIN_CTRL__RND__NO_ROUNDING(ip) \
+	(value__AUD_PCMIN_CTRL__RND__NO_ROUNDING(ip) << \
+	shift__AUD_PCMIN_CTRL__RND(ip))
+#define set__AUD_PCMIN_CTRL__RND__NO_ROUNDING(ip) \
+	set__AUD_PCMIN_CTRL__RND(ip, \
+	value__AUD_PCMIN_CTRL__RND__NO_ROUNDING(ip))
+
+#define value__AUD_PCMIN_CTRL__RND__16_BITS_ROUNDING(ip) 0x1
+#define mask__AUD_PCMIN_CTRL__RND__16_BITS_ROUNDING(ip) \
+	(value__AUD_PCMIN_CTRL__RND__16_BITS_ROUNDING(ip) << \
+	shift__AUD_PCMIN_CTRL__RND(ip))
+#define set__AUD_PCMIN_CTRL__RND__16_BITS_ROUNDING(ip) \
+	set__AUD_PCMIN_CTRL__RND(ip, \
+	value__AUD_PCMIN_CTRL__RND__16_BITS_ROUNDING(ip))
+
+/* NUM_FRAMES */
+
+#define shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip) 4
+#define mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip) 0xfffffff
+#define get__AUD_PCMIN_CTRL__NUM_FRAMES(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_CTRL(ip)) >> shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip)) \
+	& mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip))
+#define set__AUD_PCMIN_CTRL__NUM_FRAMES(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_CTRL(ip)) & \
+	~(mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip) << \
+	shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip))) | (((value) & \
+	mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip)) << \
+	shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip)), ip->base + \
+	offset__AUD_PCMIN_CTRL(ip))
+
+
+
+/*
+ * AUD_PCMIN_STA
+ */
+
+#define offset__AUD_PCMIN_STA(ip) 0x20
+#define get__AUD_PCMIN_STA(ip) readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+#define set__AUD_PCMIN_STA(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+
+/* RUN_STOP */
+
+#define shift__AUD_PCMIN_STA__RUN_STOP(ip) 0
+#define mask__AUD_PCMIN_STA__RUN_STOP(ip) 0x1
+#define get__AUD_PCMIN_STA__RUN_STOP(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__RUN_STOP(ip)) & \
+	mask__AUD_PCMIN_STA__RUN_STOP(ip))
+#define set__AUD_PCMIN_STA__RUN_STOP(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_STA(ip)) & ~(mask__AUD_PCMIN_STA__RUN_STOP(ip) << \
+	shift__AUD_PCMIN_STA__RUN_STOP(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__RUN_STOP(ip)) << \
+	shift__AUD_PCMIN_STA__RUN_STOP(ip)), ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+
+#define value__AUD_PCMIN_STA__RUN_STOP__STOPPED(ip) 0x0
+#define mask__AUD_PCMIN_STA__RUN_STOP__STOPPED(ip) \
+	(value__AUD_PCMIN_STA__RUN_STOP__STOPPED(ip) << \
+	shift__AUD_PCMIN_STA__RUN_STOP(ip))
+#define set__AUD_PCMIN_STA__RUN_STOP__STOPPED(ip) \
+	set__AUD_PCMIN_STA__RUN_STOP(ip, \
+	value__AUD_PCMIN_STA__RUN_STOP__STOPPED(ip))
+
+#define value__AUD_PCMIN_STA__RUN_STOP__RUNNING(ip) 0x1
+#define mask__AUD_PCMIN_STA__RUN_STOP__RUNNING(ip) \
+	(value__AUD_PCMIN_STA__RUN_STOP__RUNNING(ip) << \
+	shift__AUD_PCMIN_STA__RUN_STOP(ip))
+#define set__AUD_PCMIN_STA__RUN_STOP__RUNNING(ip) \
+	set__AUD_PCMIN_STA__RUN_STOP(ip, \
+	value__AUD_PCMIN_STA__RUN_STOP__RUNNING(ip))
+
+/* OVF */
+
+#define shift__AUD_PCMIN_STA__OVF(ip) 1
+#define mask__AUD_PCMIN_STA__OVF(ip) 0x1
+#define get__AUD_PCMIN_STA__OVF(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__OVF(ip)) & \
+	mask__AUD_PCMIN_STA__OVF(ip))
+#define set__AUD_PCMIN_STA__OVF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) & ~(mask__AUD_PCMIN_STA__OVF(ip) << \
+	shift__AUD_PCMIN_STA__OVF(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__OVF(ip)) << shift__AUD_PCMIN_STA__OVF(ip)), \
+	ip->base + offset__AUD_PCMIN_STA(ip))
+
+#define value__AUD_PCMIN_STA__OVF__OVERFLOW_DETECTED(ip) 0x1
+#define mask__AUD_PCMIN_STA__OVF__OVERFLOW_DETECTED(ip) \
+	(value__AUD_PCMIN_STA__OVF__OVERFLOW_DETECTED(ip) << \
+	shift__AUD_PCMIN_STA__OVF(ip))
+#define set__AUD_PCMIN_STA__OVF__OVERFLOW_DETECTED(ip) \
+	set__AUD_PCMIN_STA__OVF(ip, \
+	value__AUD_PCMIN_STA__OVF__OVERFLOW_DETECTED(ip))
+
+/* SAMPL_CNT */
+
+#define shift__AUD_PCMIN_STA__SAMPL_CNT(ip) 2
+#define mask__AUD_PCMIN_STA__SAMPL_CNT(ip) 0xffff
+#define get__AUD_PCMIN_STA__SAMPL_CNT(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__SAMPL_CNT(ip)) & \
+	mask__AUD_PCMIN_STA__SAMPL_CNT(ip))
+#define set__AUD_PCMIN_STA__SAMPL_CNT(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_STA(ip)) & \
+	~(mask__AUD_PCMIN_STA__SAMPL_CNT(ip) << \
+	shift__AUD_PCMIN_STA__SAMPL_CNT(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__SAMPL_CNT(ip)) << \
+	shift__AUD_PCMIN_STA__SAMPL_CNT(ip)), ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+
+/* VSYNC */
+
+#define shift__AUD_PCMIN_STA__VSYNC(ip) 18
+#define mask__AUD_PCMIN_STA__VSYNC(ip) 0x1
+#define get__AUD_PCMIN_STA__VSYNC(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__VSYNC(ip)) & \
+	mask__AUD_PCMIN_STA__VSYNC(ip))
+#define set__AUD_PCMIN_STA__VSYNC(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) & ~(mask__AUD_PCMIN_STA__VSYNC(ip) << \
+	shift__AUD_PCMIN_STA__VSYNC(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__VSYNC(ip)) << shift__AUD_PCMIN_STA__VSYNC(ip)), \
+	ip->base + offset__AUD_PCMIN_STA(ip))
+
+/* NFRAMES */
+
+#define shift__AUD_PCMIN_STA__NFRAMES(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? 19 : -1)
+#define mask__AUD_PCMIN_STA__NFRAMES(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? 0x1 : -1)
+#define get__AUD_PCMIN_STA__NFRAMES(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__NFRAMES(ip)) & \
+	mask__AUD_PCMIN_STA__NFRAMES(ip))
+#define set__AUD_PCMIN_STA__NFRAMES(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_STA(ip)) & ~(mask__AUD_PCMIN_STA__NFRAMES(ip) << \
+	shift__AUD_PCMIN_STA__NFRAMES(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__NFRAMES(ip)) << \
+	shift__AUD_PCMIN_STA__NFRAMES(ip)), ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+
+#define value__AUD_PCMIN_STA__NFRAMES__DONE(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? 0x1 : -1)
+#define mask__AUD_PCMIN_STA__NFRAMES__DONE(ip) \
+	(value__AUD_PCMIN_STA__NFRAMES__DONE(ip) << \
+	shift__AUD_PCMIN_STA__NFRAMES(ip))
+#define set__AUD_PCMIN_STA__NFRAMES__DONE(ip) \
+	set__AUD_PCMIN_STA__NFRAMES(ip, \
+	value__AUD_PCMIN_STA__NFRAMES__DONE(ip))
+
+/* SAMPLES_IN_FIFO */
+
+#define shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 19)
+#define mask__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7f)
+#define get__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_STA(ip)) >> \
+	shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip)) & \
+	mask__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip))
+#define set__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_STA(ip)) & \
+	~(mask__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) << \
+	shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip))) | (((value) & \
+	mask__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip)) << \
+	shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip)), ip->base + \
+	offset__AUD_PCMIN_STA(ip))
+
+
+
+/*
+ * AUD_PCMIN_FMT
+ */
+
+#define offset__AUD_PCMIN_FMT(ip) 0x24
+#define get__AUD_PCMIN_FMT(ip) readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+#define set__AUD_PCMIN_FMT(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+/* NBIT */
+
+#define shift__AUD_PCMIN_FMT__NBIT(ip) 0
+#define mask__AUD_PCMIN_FMT__NBIT(ip) 0x1
+#define get__AUD_PCMIN_FMT__NBIT(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__NBIT(ip)) & \
+	mask__AUD_PCMIN_FMT__NBIT(ip))
+#define set__AUD_PCMIN_FMT__NBIT(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__NBIT(ip) << \
+	shift__AUD_PCMIN_FMT__NBIT(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__NBIT(ip)) << shift__AUD_PCMIN_FMT__NBIT(ip)), \
+	ip->base + offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__NBIT__32_BITS(ip) 0x0
+#define mask__AUD_PCMIN_FMT__NBIT__32_BITS(ip) \
+	(value__AUD_PCMIN_FMT__NBIT__32_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__NBIT(ip))
+#define set__AUD_PCMIN_FMT__NBIT__32_BITS(ip) \
+	set__AUD_PCMIN_FMT__NBIT(ip, value__AUD_PCMIN_FMT__NBIT__32_BITS(ip))
+
+#define value__AUD_PCMIN_FMT__NBIT__16_BITS(ip) 0x1
+#define mask__AUD_PCMIN_FMT__NBIT__16_BITS(ip) \
+	(value__AUD_PCMIN_FMT__NBIT__16_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__NBIT(ip))
+#define set__AUD_PCMIN_FMT__NBIT__16_BITS(ip) \
+	set__AUD_PCMIN_FMT__NBIT(ip, value__AUD_PCMIN_FMT__NBIT__16_BITS(ip))
+
+/* DATA_SIZE */
+
+#define shift__AUD_PCMIN_FMT__DATA_SIZE(ip) 1
+#define mask__AUD_PCMIN_FMT__DATA_SIZE(ip) 0x3
+#define get__AUD_PCMIN_FMT__DATA_SIZE(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__DATA_SIZE(ip)) & \
+	mask__AUD_PCMIN_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMIN_FMT__DATA_SIZE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_FMT(ip)) & \
+	~(mask__AUD_PCMIN_FMT__DATA_SIZE(ip) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__DATA_SIZE(ip)) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(ip) 0x0
+#define mask__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(ip) \
+	(value__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(ip) \
+	set__AUD_PCMIN_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(ip))
+
+#define value__AUD_PCMIN_FMT__DATA_SIZE__20_BITS(ip) 0x1
+#define mask__AUD_PCMIN_FMT__DATA_SIZE__20_BITS(ip) \
+	(value__AUD_PCMIN_FMT__DATA_SIZE__20_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMIN_FMT__DATA_SIZE__20_BITS(ip) \
+	set__AUD_PCMIN_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMIN_FMT__DATA_SIZE__20_BITS(ip))
+
+#define value__AUD_PCMIN_FMT__DATA_SIZE__18_BITS(ip) 0x2
+#define mask__AUD_PCMIN_FMT__DATA_SIZE__18_BITS(ip) \
+	(value__AUD_PCMIN_FMT__DATA_SIZE__18_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMIN_FMT__DATA_SIZE__18_BITS(ip) \
+	set__AUD_PCMIN_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMIN_FMT__DATA_SIZE__18_BITS(ip))
+
+#define value__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(ip) 0x3
+#define mask__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(ip) \
+	(value__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(ip) << \
+	shift__AUD_PCMIN_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(ip) \
+	set__AUD_PCMIN_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(ip))
+
+/* LR_POL */
+
+#define shift__AUD_PCMIN_FMT__LR_POL(ip) 3
+#define mask__AUD_PCMIN_FMT__LR_POL(ip) 0x1
+#define get__AUD_PCMIN_FMT__LR_POL(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__LR_POL(ip)) & \
+	mask__AUD_PCMIN_FMT__LR_POL(ip))
+#define set__AUD_PCMIN_FMT__LR_POL(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__LR_POL(ip) << \
+	shift__AUD_PCMIN_FMT__LR_POL(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__LR_POL(ip)) << shift__AUD_PCMIN_FMT__LR_POL(ip)), \
+	ip->base + offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(ip) 0x0
+#define mask__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(ip) \
+	(value__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(ip) << \
+	shift__AUD_PCMIN_FMT__LR_POL(ip))
+#define set__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(ip) \
+	set__AUD_PCMIN_FMT__LR_POL(ip, \
+	value__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(ip))
+
+#define value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(ip) 0x1
+#define mask__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(ip) \
+	(value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(ip) << \
+	shift__AUD_PCMIN_FMT__LR_POL(ip))
+#define set__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(ip) \
+	set__AUD_PCMIN_FMT__LR_POL(ip, \
+	value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(ip))
+
+/* SCLK_EDGE */
+
+#define shift__AUD_PCMIN_FMT__SCLK_EDGE(ip) 4
+#define mask__AUD_PCMIN_FMT__SCLK_EDGE(ip) 0x1
+#define get__AUD_PCMIN_FMT__SCLK_EDGE(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__SCLK_EDGE(ip)) & \
+	mask__AUD_PCMIN_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMIN_FMT__SCLK_EDGE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_FMT(ip)) & \
+	~(mask__AUD_PCMIN_FMT__SCLK_EDGE(ip) << \
+	shift__AUD_PCMIN_FMT__SCLK_EDGE(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__SCLK_EDGE(ip)) << \
+	shift__AUD_PCMIN_FMT__SCLK_EDGE(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__SCLK_EDGE__RISING(ip) 0x0
+#define mask__AUD_PCMIN_FMT__SCLK_EDGE__RISING(ip) \
+	(value__AUD_PCMIN_FMT__SCLK_EDGE__RISING(ip) << \
+	shift__AUD_PCMIN_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMIN_FMT__SCLK_EDGE__RISING(ip) \
+	set__AUD_PCMIN_FMT__SCLK_EDGE(ip, \
+	value__AUD_PCMIN_FMT__SCLK_EDGE__RISING(ip))
+
+#define value__AUD_PCMIN_FMT__SCLK_EDGE__FALLING(ip) 0x1
+#define mask__AUD_PCMIN_FMT__SCLK_EDGE__FALLING(ip) \
+	(value__AUD_PCMIN_FMT__SCLK_EDGE__FALLING(ip) << \
+	shift__AUD_PCMIN_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMIN_FMT__SCLK_EDGE__FALLING(ip) \
+	set__AUD_PCMIN_FMT__SCLK_EDGE(ip, \
+	value__AUD_PCMIN_FMT__SCLK_EDGE__FALLING(ip))
+
+/* PADDING */
+
+#define shift__AUD_PCMIN_FMT__PADDING(ip) 5
+#define mask__AUD_PCMIN_FMT__PADDING(ip) 0x1
+#define get__AUD_PCMIN_FMT__PADDING(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__PADDING(ip)) & \
+	mask__AUD_PCMIN_FMT__PADDING(ip))
+#define set__AUD_PCMIN_FMT__PADDING(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__PADDING(ip) << \
+	shift__AUD_PCMIN_FMT__PADDING(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__PADDING(ip)) << \
+	shift__AUD_PCMIN_FMT__PADDING(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(ip) 0x0
+#define mask__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(ip) \
+	(value__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(ip) << \
+	shift__AUD_PCMIN_FMT__PADDING(ip))
+#define set__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(ip) \
+	set__AUD_PCMIN_FMT__PADDING(ip, \
+	value__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(ip))
+
+#define value__AUD_PCMIN_FMT__PADDING__NO_DELAY(ip) 0x1
+#define mask__AUD_PCMIN_FMT__PADDING__NO_DELAY(ip) \
+	(value__AUD_PCMIN_FMT__PADDING__NO_DELAY(ip) << \
+	shift__AUD_PCMIN_FMT__PADDING(ip))
+#define set__AUD_PCMIN_FMT__PADDING__NO_DELAY(ip) \
+	set__AUD_PCMIN_FMT__PADDING(ip, \
+	value__AUD_PCMIN_FMT__PADDING__NO_DELAY(ip))
+
+/* ALIGN */
+
+#define shift__AUD_PCMIN_FMT__ALIGN(ip) 6
+#define mask__AUD_PCMIN_FMT__ALIGN(ip) 0x1
+#define get__AUD_PCMIN_FMT__ALIGN(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__ALIGN(ip)) & \
+	mask__AUD_PCMIN_FMT__ALIGN(ip))
+#define set__AUD_PCMIN_FMT__ALIGN(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__ALIGN(ip) << \
+	shift__AUD_PCMIN_FMT__ALIGN(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__ALIGN(ip)) << shift__AUD_PCMIN_FMT__ALIGN(ip)), \
+	ip->base + offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__ALIGN__RIGHT(ip) 0x0
+#define mask__AUD_PCMIN_FMT__ALIGN__RIGHT(ip) \
+	(value__AUD_PCMIN_FMT__ALIGN__RIGHT(ip) << \
+	shift__AUD_PCMIN_FMT__ALIGN(ip))
+#define set__AUD_PCMIN_FMT__ALIGN__RIGHT(ip) \
+	set__AUD_PCMIN_FMT__ALIGN(ip, value__AUD_PCMIN_FMT__ALIGN__RIGHT(ip))
+
+#define value__AUD_PCMIN_FMT__ALIGN__LEFT(ip) 0x1
+#define mask__AUD_PCMIN_FMT__ALIGN__LEFT(ip) \
+	(value__AUD_PCMIN_FMT__ALIGN__LEFT(ip) << \
+	shift__AUD_PCMIN_FMT__ALIGN(ip))
+#define set__AUD_PCMIN_FMT__ALIGN__LEFT(ip) \
+	set__AUD_PCMIN_FMT__ALIGN(ip, value__AUD_PCMIN_FMT__ALIGN__LEFT(ip))
+
+/* ORDER */
+
+#define shift__AUD_PCMIN_FMT__ORDER(ip) 7
+#define mask__AUD_PCMIN_FMT__ORDER(ip) 0x1
+#define get__AUD_PCMIN_FMT__ORDER(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__ORDER(ip)) & \
+	mask__AUD_PCMIN_FMT__ORDER(ip))
+#define set__AUD_PCMIN_FMT__ORDER(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__ORDER(ip) << \
+	shift__AUD_PCMIN_FMT__ORDER(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__ORDER(ip)) << shift__AUD_PCMIN_FMT__ORDER(ip)), \
+	ip->base + offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__ORDER__LSB_FIRST(ip) 0x0
+#define mask__AUD_PCMIN_FMT__ORDER__LSB_FIRST(ip) \
+	(value__AUD_PCMIN_FMT__ORDER__LSB_FIRST(ip) << \
+	shift__AUD_PCMIN_FMT__ORDER(ip))
+#define set__AUD_PCMIN_FMT__ORDER__LSB_FIRST(ip) \
+	set__AUD_PCMIN_FMT__ORDER(ip, \
+	value__AUD_PCMIN_FMT__ORDER__LSB_FIRST(ip))
+
+#define value__AUD_PCMIN_FMT__ORDER__MSB_FIRST(ip) 0x1
+#define mask__AUD_PCMIN_FMT__ORDER__MSB_FIRST(ip) \
+	(value__AUD_PCMIN_FMT__ORDER__MSB_FIRST(ip) << \
+	shift__AUD_PCMIN_FMT__ORDER(ip))
+#define set__AUD_PCMIN_FMT__ORDER__MSB_FIRST(ip) \
+	set__AUD_PCMIN_FMT__ORDER(ip, \
+	value__AUD_PCMIN_FMT__ORDER__MSB_FIRST(ip))
+
+/* NUM_CH */
+
+#define shift__AUD_PCMIN_FMT__NUM_CH(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 8)
+#define mask__AUD_PCMIN_FMT__NUM_CH(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7)
+#define get__AUD_PCMIN_FMT__NUM_CH(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__NUM_CH(ip)) & \
+	mask__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) & ~(mask__AUD_PCMIN_FMT__NUM_CH(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__NUM_CH(ip)) << shift__AUD_PCMIN_FMT__NUM_CH(ip)), \
+	ip->base + offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
+#define mask__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) \
+	(value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) \
+	set__AUD_PCMIN_FMT__NUM_CH(ip, \
+	value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip))
+
+#define value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x2)
+#define mask__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) \
+	(value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) \
+	set__AUD_PCMIN_FMT__NUM_CH(ip, \
+	value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip))
+
+#define value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x3)
+#define mask__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) \
+	(value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) \
+	set__AUD_PCMIN_FMT__NUM_CH(ip, \
+	value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip))
+
+#define value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x4)
+#define mask__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) \
+	(value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) \
+	set__AUD_PCMIN_FMT__NUM_CH(ip, \
+	value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip))
+
+#define value__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x5)
+#define mask__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) \
+	(value__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) << \
+	shift__AUD_PCMIN_FMT__NUM_CH(ip))
+#define set__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) \
+	set__AUD_PCMIN_FMT__NUM_CH(ip, \
+	value__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip))
+
+/* BACK_STALLING */
+
+#define shift__AUD_PCMIN_FMT__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 11)
+#define mask__AUD_PCMIN_FMT__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
+#define get__AUD_PCMIN_FMT__BACK_STALLING(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__BACK_STALLING(ip)) \
+	& mask__AUD_PCMIN_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMIN_FMT__BACK_STALLING(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_FMT(ip)) & \
+	~(mask__AUD_PCMIN_FMT__BACK_STALLING(ip) << \
+	shift__AUD_PCMIN_FMT__BACK_STALLING(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__BACK_STALLING(ip)) << \
+	shift__AUD_PCMIN_FMT__BACK_STALLING(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x0)
+#define mask__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) \
+	(value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) << \
+	shift__AUD_PCMIN_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) \
+	set__AUD_PCMIN_FMT__BACK_STALLING(ip, \
+	value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip))
+
+#define value__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
+#define mask__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) \
+	(value__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) << \
+	shift__AUD_PCMIN_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) \
+	set__AUD_PCMIN_FMT__BACK_STALLING(ip, \
+	value__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip))
+
+/* MASTER_CLKEDGE */
+
+#define shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 12)
+#define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
+#define get__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> \
+	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip)) & \
+	mask__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))
+#define set__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_FMT(ip)) & \
+	~(mask__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) << \
+	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip)) << \
+	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#define value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x0)
+#define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) \
+	(value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) << \
+	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))
+#define set__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) \
+	set__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip, \
+	value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip))
+
+#define value__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
+#define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) \
+	(value__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) << \
+	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))
+#define set__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) \
+	set__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip, \
+	value__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip))
+
+/* DMA_REQ_TRIG_LMT */
+
+#define shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 13)
+#define mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7f)
+#define get__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
+	offset__AUD_PCMIN_FMT(ip)) >> \
+	shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip)) & \
+	mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip))
+#define set__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMIN_FMT(ip)) & \
+	~(mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) << \
+	shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip))) | (((value) & \
+	mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip)) << \
+	shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip)), ip->base + \
+	offset__AUD_PCMIN_FMT(ip))
+
+#endif
diff --git a/sound/stm/reg_aud_pcmout.h b/sound/stm/reg_aud_pcmout.h
new file mode 100644
index 0000000..c3d8672
--- /dev/null
+++ b/sound/stm/reg_aud_pcmout.h
@@ -0,0 +1,1036 @@
+#ifndef __SND_STM_AUD_PCMOUT_H
+#define __SND_STM_AUD_PCMOUT_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0 */
+#define ver__AUD_PCMOUT__90_1_1 1
+
+/* 7100 3.0 */
+#define ver__AUD_PCMOUT__90_1_3 2
+
+/* 7109 2.0 */
+#define ver__AUD_PCMOUT__90_2_0 3
+
+/* 7109 3.0 */
+#define ver__AUD_PCMOUT__90_2_1 4
+
+/* 7200 1.0 */
+#define ver__AUD_PCMOUT__65_1_3 5
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_PCMOUT__65_2_2 6
+
+
+
+/*
+ * AUD_PCMOUT_RST
+ */
+
+#define offset__AUD_PCMOUT_RST(ip) 0x00
+#define get__AUD_PCMOUT_RST(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_RST(ip))
+#define set__AUD_PCMOUT_RST(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_RST(ip))
+
+/* SRSTP */
+
+#define shift__AUD_PCMOUT_RST__SRSTP(ip) 0
+#define mask__AUD_PCMOUT_RST__SRSTP(ip) 0x1
+#define get__AUD_PCMOUT_RST__SRSTP(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_RST(ip)) >> shift__AUD_PCMOUT_RST__SRSTP(ip)) & \
+	mask__AUD_PCMOUT_RST__SRSTP(ip))
+#define set__AUD_PCMOUT_RST__SRSTP(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_RST(ip)) & ~(mask__AUD_PCMOUT_RST__SRSTP(ip) << \
+	shift__AUD_PCMOUT_RST__SRSTP(ip))) | (((value) & \
+	mask__AUD_PCMOUT_RST__SRSTP(ip)) << shift__AUD_PCMOUT_RST__SRSTP(ip)), \
+	ip->base + offset__AUD_PCMOUT_RST(ip))
+
+#define value__AUD_PCMOUT_RST__SRSTP__RUNNING(ip) 0x0
+#define mask__AUD_PCMOUT_RST__SRSTP__RUNNING(ip) \
+	(value__AUD_PCMOUT_RST__SRSTP__RUNNING(ip) << \
+	shift__AUD_PCMOUT_RST__SRSTP(ip))
+#define set__AUD_PCMOUT_RST__SRSTP__RUNNING(ip) \
+	set__AUD_PCMOUT_RST__SRSTP(ip, \
+	value__AUD_PCMOUT_RST__SRSTP__RUNNING(ip))
+
+#define value__AUD_PCMOUT_RST__SRSTP__RESET(ip) 0x1
+#define mask__AUD_PCMOUT_RST__SRSTP__RESET(ip) \
+	(value__AUD_PCMOUT_RST__SRSTP__RESET(ip) << \
+	shift__AUD_PCMOUT_RST__SRSTP(ip))
+#define set__AUD_PCMOUT_RST__SRSTP__RESET(ip) \
+	set__AUD_PCMOUT_RST__SRSTP(ip, \
+	value__AUD_PCMOUT_RST__SRSTP__RESET(ip))
+
+
+
+/*
+ * AUD_PCMOUT_DATA
+ */
+
+#define offset__AUD_PCMOUT_DATA(ip) 0x04
+#define get__AUD_PCMOUT_DATA(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_DATA(ip))
+#define set__AUD_PCMOUT_DATA(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_DATA(ip))
+
+/* DATA */
+
+#define shift__AUD_PCMOUT_DATA__DATA(ip) 0
+#define mask__AUD_PCMOUT_DATA__DATA(ip) 0xffffffff
+#define get__AUD_PCMOUT_DATA__DATA(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_DATA(ip)) >> shift__AUD_PCMOUT_DATA__DATA(ip)) & \
+	mask__AUD_PCMOUT_DATA__DATA(ip))
+#define set__AUD_PCMOUT_DATA__DATA(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_DATA(ip)) & ~(mask__AUD_PCMOUT_DATA__DATA(ip) << \
+	shift__AUD_PCMOUT_DATA__DATA(ip))) | (((value) & \
+	mask__AUD_PCMOUT_DATA__DATA(ip)) << shift__AUD_PCMOUT_DATA__DATA(ip)), \
+	ip->base + offset__AUD_PCMOUT_DATA(ip))
+
+
+
+/*
+ * AUD_PCMOUT_ITS
+ */
+
+#define offset__AUD_PCMOUT_ITS(ip) 0x08
+#define get__AUD_PCMOUT_ITS(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_ITS(ip))
+#define set__AUD_PCMOUT_ITS(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_ITS(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_ITS__UNF(ip) 0
+#define mask__AUD_PCMOUT_ITS__UNF(ip) 0x1
+#define get__AUD_PCMOUT_ITS__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_ITS(ip)) >> shift__AUD_PCMOUT_ITS__UNF(ip)) & \
+	mask__AUD_PCMOUT_ITS__UNF(ip))
+#define set__AUD_PCMOUT_ITS__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_ITS(ip)) & ~(mask__AUD_PCMOUT_ITS__UNF(ip) << \
+	shift__AUD_PCMOUT_ITS__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_ITS__UNF(ip)) << shift__AUD_PCMOUT_ITS__UNF(ip)), \
+	ip->base + offset__AUD_PCMOUT_ITS(ip))
+
+#define value__AUD_PCMOUT_ITS__UNF__PENDING(ip) 0x1
+#define mask__AUD_PCMOUT_ITS__UNF__PENDING(ip) \
+	(value__AUD_PCMOUT_ITS__UNF__PENDING(ip) << \
+	shift__AUD_PCMOUT_ITS__UNF(ip))
+#define set__AUD_PCMOUT_ITS__UNF__PENDING(ip) \
+	set__AUD_PCMOUT_ITS__UNF(ip, value__AUD_PCMOUT_ITS__UNF__PENDING(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_ITS__NSAMPLE(ip) 1
+#define mask__AUD_PCMOUT_ITS__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_ITS__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_ITS(ip)) >> shift__AUD_PCMOUT_ITS__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_ITS__NSAMPLE(ip))
+#define set__AUD_PCMOUT_ITS__NSAMPLE(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_ITS(ip)) & ~(mask__AUD_PCMOUT_ITS__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_ITS__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_ITS__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_ITS__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_ITS(ip))
+
+#define value__AUD_PCMOUT_ITS__NSAMPLE__PENDING(ip) 0x1
+#define mask__AUD_PCMOUT_ITS__NSAMPLE__PENDING(ip) \
+	(value__AUD_PCMOUT_ITS__NSAMPLE__PENDING(ip) << \
+	shift__AUD_PCMOUT_ITS__NSAMPLE(ip))
+#define set__AUD_PCMOUT_ITS__NSAMPLE__PENDING(ip) \
+	set__AUD_PCMOUT_ITS__NSAMPLE(ip, \
+	value__AUD_PCMOUT_ITS__NSAMPLE__PENDING(ip))
+
+
+
+/*
+ * AUD_PCMOUT_ITS_CLR
+ */
+
+#define offset__AUD_PCMOUT_ITS_CLR(ip) 0x0c
+#define get__AUD_PCMOUT_ITS_CLR(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip))
+#define set__AUD_PCMOUT_ITS_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_ITS_CLR__UNF(ip) 0
+#define mask__AUD_PCMOUT_ITS_CLR__UNF(ip) 0x1
+#define get__AUD_PCMOUT_ITS_CLR__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip)) >> shift__AUD_PCMOUT_ITS_CLR__UNF(ip)) \
+	& mask__AUD_PCMOUT_ITS_CLR__UNF(ip))
+#define set__AUD_PCMOUT_ITS_CLR__UNF(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_ITS_CLR(ip)) & \
+	~(mask__AUD_PCMOUT_ITS_CLR__UNF(ip) << \
+	shift__AUD_PCMOUT_ITS_CLR__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_ITS_CLR__UNF(ip)) << \
+	shift__AUD_PCMOUT_ITS_CLR__UNF(ip)), ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip))
+
+#define value__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(ip) 0x1
+#define mask__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(ip) \
+	(value__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(ip) << \
+	shift__AUD_PCMOUT_ITS_CLR__UNF(ip))
+#define set__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(ip) \
+	set__AUD_PCMOUT_ITS_CLR__UNF(ip, \
+	value__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip) 1
+#define mask__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip)) >> \
+	shift__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip))
+#define set__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_ITS_CLR(ip)) & \
+	~(mask__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_ITS_CLR(ip))
+
+#define value__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(ip) 0x1
+#define mask__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(ip) \
+	(value__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(ip) << \
+	shift__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip))
+#define set__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(ip) \
+	set__AUD_PCMOUT_ITS_CLR__NSAMPLE(ip, \
+	value__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(ip))
+
+
+
+/*
+ * AUD_PCMOUT_IT_EN
+ */
+
+#define offset__AUD_PCMOUT_IT_EN(ip) 0x10
+#define get__AUD_PCMOUT_IT_EN(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip))
+#define set__AUD_PCMOUT_IT_EN(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_IT_EN__UNF(ip) 0
+#define mask__AUD_PCMOUT_IT_EN__UNF(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip)) >> shift__AUD_PCMOUT_IT_EN__UNF(ip)) & \
+	mask__AUD_PCMOUT_IT_EN__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip)) & ~(mask__AUD_PCMOUT_IT_EN__UNF(ip) << \
+	shift__AUD_PCMOUT_IT_EN__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN__UNF(ip)) << shift__AUD_PCMOUT_IT_EN__UNF(ip)), \
+	ip->base + offset__AUD_PCMOUT_IT_EN(ip))
+
+#define value__AUD_PCMOUT_IT_EN__UNF__DISABLED(ip) 0x0
+#define mask__AUD_PCMOUT_IT_EN__UNF__DISABLED(ip) \
+	(value__AUD_PCMOUT_IT_EN__UNF__DISABLED(ip) << \
+	shift__AUD_PCMOUT_IT_EN__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN__UNF__DISABLED(ip) \
+	set__AUD_PCMOUT_IT_EN__UNF(ip, \
+	value__AUD_PCMOUT_IT_EN__UNF__DISABLED(ip))
+
+#define value__AUD_PCMOUT_IT_EN__UNF__ENABLED(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN__UNF__ENABLED(ip) \
+	(value__AUD_PCMOUT_IT_EN__UNF__ENABLED(ip) << \
+	shift__AUD_PCMOUT_IT_EN__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN__UNF__ENABLED(ip) \
+	set__AUD_PCMOUT_IT_EN__UNF(ip, \
+	value__AUD_PCMOUT_IT_EN__UNF__ENABLED(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip) 1
+#define mask__AUD_PCMOUT_IT_EN__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip)) >> shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip)) \
+	& mask__AUD_PCMOUT_IT_EN__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_IT_EN(ip)) & \
+	~(mask__AUD_PCMOUT_IT_EN__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_IT_EN(ip))
+
+#define value__AUD_PCMOUT_IT_EN__NSAMPLE__DISABLED(ip) 0x0
+#define mask__AUD_PCMOUT_IT_EN__NSAMPLE__DISABLED(ip) \
+	(value__AUD_PCMOUT_IT_EN__NSAMPLE__DISABLED(ip) << \
+	shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN__NSAMPLE__DISABLED(ip) \
+	set__AUD_PCMOUT_IT_EN__NSAMPLE(ip, \
+	value__AUD_PCMOUT_IT_EN__NSAMPLE__DISABLED(ip))
+
+#define value__AUD_PCMOUT_IT_EN__NSAMPLE__ENABLED(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN__NSAMPLE__ENABLED(ip) \
+	(value__AUD_PCMOUT_IT_EN__NSAMPLE__ENABLED(ip) << \
+	shift__AUD_PCMOUT_IT_EN__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN__NSAMPLE__ENABLED(ip) \
+	set__AUD_PCMOUT_IT_EN__NSAMPLE(ip, \
+	value__AUD_PCMOUT_IT_EN__NSAMPLE__ENABLED(ip))
+
+
+
+/*
+ * AUD_PCMOUT_IT_EN_SET
+ */
+
+#define offset__AUD_PCMOUT_IT_EN_SET(ip) 0x14
+#define get__AUD_PCMOUT_IT_EN_SET(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_SET(ip))
+#define set__AUD_PCMOUT_IT_EN_SET(ip, value) writel((value), ip->base \
+	+ offset__AUD_PCMOUT_IT_EN_SET(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_IT_EN_SET__UNF(ip) 0
+#define mask__AUD_PCMOUT_IT_EN_SET__UNF(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN_SET__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_SET(ip)) >> \
+	shift__AUD_PCMOUT_IT_EN_SET__UNF(ip)) & \
+	mask__AUD_PCMOUT_IT_EN_SET__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN_SET__UNF(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_IT_EN_SET(ip)) & \
+	~(mask__AUD_PCMOUT_IT_EN_SET__UNF(ip) << \
+	shift__AUD_PCMOUT_IT_EN_SET__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN_SET__UNF(ip)) << \
+	shift__AUD_PCMOUT_IT_EN_SET__UNF(ip)), ip->base + \
+	offset__AUD_PCMOUT_IT_EN_SET(ip))
+
+#define value__AUD_PCMOUT_IT_EN_SET__UNF__SET(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN_SET__UNF__SET(ip) \
+	(value__AUD_PCMOUT_IT_EN_SET__UNF__SET(ip) << \
+	shift__AUD_PCMOUT_IT_EN_SET__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN_SET__UNF__SET(ip) \
+	set__AUD_PCMOUT_IT_EN_SET__UNF(ip, \
+	value__AUD_PCMOUT_IT_EN_SET__UNF__SET(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip) 1
+#define mask__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_SET(ip)) >> \
+	shift__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_IT_EN_SET(ip)) & \
+	~(mask__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_IT_EN_SET(ip))
+
+#define value__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(ip) \
+	(value__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(ip) << \
+	shift__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(ip) \
+	set__AUD_PCMOUT_IT_EN_SET__NSAMPLE(ip, \
+	value__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(ip))
+
+
+
+/*
+ * AUD_PCMOUT_IT_EN_CLR
+ */
+
+#define offset__AUD_PCMOUT_IT_EN_CLR(ip) 0x18
+#define get__AUD_PCMOUT_IT_EN_CLR(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_CLR(ip))
+#define set__AUD_PCMOUT_IT_EN_CLR(ip, value) writel((value), ip->base \
+	+ offset__AUD_PCMOUT_IT_EN_CLR(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_IT_EN_CLR__UNF(ip) 0
+#define mask__AUD_PCMOUT_IT_EN_CLR__UNF(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN_CLR__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_CLR(ip)) >> \
+	shift__AUD_PCMOUT_IT_EN_CLR__UNF(ip)) & \
+	mask__AUD_PCMOUT_IT_EN_CLR__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN_CLR__UNF(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_IT_EN_CLR(ip)) & \
+	~(mask__AUD_PCMOUT_IT_EN_CLR__UNF(ip) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN_CLR__UNF(ip)) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__UNF(ip)), ip->base + \
+	offset__AUD_PCMOUT_IT_EN_CLR(ip))
+
+#define value__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(ip) \
+	(value__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(ip) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__UNF(ip))
+#define set__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(ip) \
+	set__AUD_PCMOUT_IT_EN_CLR__UNF(ip, \
+	value__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip) 1
+#define mask__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_IT_EN_CLR(ip)) >> \
+	shift__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_IT_EN_CLR(ip)) & \
+	~(mask__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_IT_EN_CLR(ip))
+
+#define value__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(ip) 0x1
+#define mask__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(ip) \
+	(value__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(ip) << \
+	shift__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip))
+#define set__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(ip) \
+	set__AUD_PCMOUT_IT_EN_CLR__NSAMPLE(ip, \
+	value__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(ip))
+
+
+
+/*
+ * AUD_PCMOUT_CTRL
+ */
+
+#define offset__AUD_PCMOUT_CTRL(ip) 0x1c
+#define get__AUD_PCMOUT_CTRL(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+#define set__AUD_PCMOUT_CTRL(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+
+/* MODE */
+
+#define shift__AUD_PCMOUT_CTRL__MODE(ip) 0
+#define mask__AUD_PCMOUT_CTRL__MODE(ip) 0x3
+#define get__AUD_PCMOUT_CTRL__MODE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__MODE(ip)) & \
+	mask__AUD_PCMOUT_CTRL__MODE(ip))
+#define set__AUD_PCMOUT_CTRL__MODE(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) & ~(mask__AUD_PCMOUT_CTRL__MODE(ip) << \
+	shift__AUD_PCMOUT_CTRL__MODE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__MODE(ip)) << shift__AUD_PCMOUT_CTRL__MODE(ip)), \
+	ip->base + offset__AUD_PCMOUT_CTRL(ip))
+
+#define value__AUD_PCMOUT_CTRL__MODE__OFF(ip) 0x0
+#define mask__AUD_PCMOUT_CTRL__MODE__OFF(ip) \
+	(value__AUD_PCMOUT_CTRL__MODE__OFF(ip) << \
+	shift__AUD_PCMOUT_CTRL__MODE(ip))
+#define set__AUD_PCMOUT_CTRL__MODE__OFF(ip) \
+	set__AUD_PCMOUT_CTRL__MODE(ip, value__AUD_PCMOUT_CTRL__MODE__OFF(ip))
+
+#define value__AUD_PCMOUT_CTRL__MODE__MUTE(ip) 0x1
+#define mask__AUD_PCMOUT_CTRL__MODE__MUTE(ip) \
+	(value__AUD_PCMOUT_CTRL__MODE__MUTE(ip) << \
+	shift__AUD_PCMOUT_CTRL__MODE(ip))
+#define set__AUD_PCMOUT_CTRL__MODE__MUTE(ip) \
+	set__AUD_PCMOUT_CTRL__MODE(ip, value__AUD_PCMOUT_CTRL__MODE__MUTE(ip))
+
+#define value__AUD_PCMOUT_CTRL__MODE__PCM(ip) 0x2
+#define mask__AUD_PCMOUT_CTRL__MODE__PCM(ip) \
+	(value__AUD_PCMOUT_CTRL__MODE__PCM(ip) << \
+	shift__AUD_PCMOUT_CTRL__MODE(ip))
+#define set__AUD_PCMOUT_CTRL__MODE__PCM(ip) \
+	set__AUD_PCMOUT_CTRL__MODE(ip, value__AUD_PCMOUT_CTRL__MODE__PCM(ip))
+
+#define value__AUD_PCMOUT_CTRL__MODE__CD(ip) 0x3
+#define mask__AUD_PCMOUT_CTRL__MODE__CD(ip) \
+	(value__AUD_PCMOUT_CTRL__MODE__CD(ip) << \
+	shift__AUD_PCMOUT_CTRL__MODE(ip))
+#define set__AUD_PCMOUT_CTRL__MODE__CD(ip) \
+	set__AUD_PCMOUT_CTRL__MODE(ip, value__AUD_PCMOUT_CTRL__MODE__CD(ip))
+
+/* MEM_FMT */
+
+#define shift__AUD_PCMOUT_CTRL__MEM_FMT(ip) 2
+#define mask__AUD_PCMOUT_CTRL__MEM_FMT(ip) 0x1
+#define get__AUD_PCMOUT_CTRL__MEM_FMT(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__MEM_FMT(ip)) & \
+	mask__AUD_PCMOUT_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMOUT_CTRL__MEM_FMT(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_CTRL(ip)) & \
+	~(mask__AUD_PCMOUT_CTRL__MEM_FMT(ip) << \
+	shift__AUD_PCMOUT_CTRL__MEM_FMT(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__MEM_FMT(ip)) << \
+	shift__AUD_PCMOUT_CTRL__MEM_FMT(ip)), ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+
+#define value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(ip) 0x0
+#define mask__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(ip) \
+	(value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(ip) << \
+	shift__AUD_PCMOUT_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(ip) \
+	set__AUD_PCMOUT_CTRL__MEM_FMT(ip, \
+	value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(ip))
+
+#define value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(ip) 0x1
+#define mask__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(ip) \
+	(value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(ip) << \
+	shift__AUD_PCMOUT_CTRL__MEM_FMT(ip))
+#define set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(ip) \
+	set__AUD_PCMOUT_CTRL__MEM_FMT(ip, \
+	value__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(ip))
+
+/* RND */
+
+#define shift__AUD_PCMOUT_CTRL__RND(ip) 3
+#define mask__AUD_PCMOUT_CTRL__RND(ip) 0x1
+#define get__AUD_PCMOUT_CTRL__RND(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__RND(ip)) & \
+	mask__AUD_PCMOUT_CTRL__RND(ip))
+#define set__AUD_PCMOUT_CTRL__RND(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) & ~(mask__AUD_PCMOUT_CTRL__RND(ip) << \
+	shift__AUD_PCMOUT_CTRL__RND(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__RND(ip)) << shift__AUD_PCMOUT_CTRL__RND(ip)), \
+	ip->base + offset__AUD_PCMOUT_CTRL(ip))
+
+#define value__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(ip) 0x0
+#define mask__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(ip) \
+	(value__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(ip) << \
+	shift__AUD_PCMOUT_CTRL__RND(ip))
+#define set__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(ip) \
+	set__AUD_PCMOUT_CTRL__RND(ip, \
+	value__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(ip))
+
+#define value__AUD_PCMOUT_CTRL__RND__16_BITS_ROUNDING(ip) 0x1
+#define mask__AUD_PCMOUT_CTRL__RND__16_BITS_ROUNDING(ip) \
+	(value__AUD_PCMOUT_CTRL__RND__16_BITS_ROUNDING(ip) << \
+	shift__AUD_PCMOUT_CTRL__RND(ip))
+#define set__AUD_PCMOUT_CTRL__RND__16_BITS_ROUNDING(ip) \
+	set__AUD_PCMOUT_CTRL__RND(ip, \
+	value__AUD_PCMOUT_CTRL__RND__16_BITS_ROUNDING(ip))
+
+/* CLK_DIV */
+
+#define shift__AUD_PCMOUT_CTRL__CLK_DIV(ip) 4
+#define mask__AUD_PCMOUT_CTRL__CLK_DIV(ip) 0xff
+#define get__AUD_PCMOUT_CTRL__CLK_DIV(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__CLK_DIV(ip)) & \
+	mask__AUD_PCMOUT_CTRL__CLK_DIV(ip))
+#define set__AUD_PCMOUT_CTRL__CLK_DIV(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_CTRL(ip)) & \
+	~(mask__AUD_PCMOUT_CTRL__CLK_DIV(ip) << \
+	shift__AUD_PCMOUT_CTRL__CLK_DIV(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__CLK_DIV(ip)) << \
+	shift__AUD_PCMOUT_CTRL__CLK_DIV(ip)), ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+
+/* SPDIF_LAT */
+
+#define shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip) 12
+#define mask__AUD_PCMOUT_CTRL__SPDIF_LAT(ip) 0x1
+#define get__AUD_PCMOUT_CTRL__SPDIF_LAT(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip)) \
+	& mask__AUD_PCMOUT_CTRL__SPDIF_LAT(ip))
+#define set__AUD_PCMOUT_CTRL__SPDIF_LAT(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_CTRL(ip)) & \
+	~(mask__AUD_PCMOUT_CTRL__SPDIF_LAT(ip) << \
+	shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__SPDIF_LAT(ip)) << \
+	shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip)), ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+
+#define value__AUD_PCMOUT_CTRL__SPDIF_LAT__IGNORE_SPDIF(ip) 0x0
+#define mask__AUD_PCMOUT_CTRL__SPDIF_LAT__IGNORE_SPDIF(ip) \
+	(value__AUD_PCMOUT_CTRL__SPDIF_LAT__IGNORE_SPDIF(ip) << \
+	shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip))
+#define set__AUD_PCMOUT_CTRL__SPDIF_LAT__IGNORE_SPDIF(ip) \
+	set__AUD_PCMOUT_CTRL__SPDIF_LAT(ip, \
+	value__AUD_PCMOUT_CTRL__SPDIF_LAT__IGNORE_SPDIF(ip))
+
+#define value__AUD_PCMOUT_CTRL__SPDIF_LAT__WAIT_FOR_SPDIF(ip) 0x1
+#define mask__AUD_PCMOUT_CTRL__SPDIF_LAT__WAIT_FOR_SPDIF(ip) \
+	(value__AUD_PCMOUT_CTRL__SPDIF_LAT__WAIT_FOR_SPDIF(ip) << \
+	shift__AUD_PCMOUT_CTRL__SPDIF_LAT(ip))
+#define set__AUD_PCMOUT_CTRL__SPDIF_LAT__WAIT_FOR_SPDIF(ip) \
+	set__AUD_PCMOUT_CTRL__SPDIF_LAT(ip, \
+	value__AUD_PCMOUT_CTRL__SPDIF_LAT__WAIT_FOR_SPDIF(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_CTRL__NSAMPLE(ip) 13
+#define mask__AUD_PCMOUT_CTRL__NSAMPLE(ip) 0x7ffff
+#define get__AUD_PCMOUT_CTRL__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip)) >> shift__AUD_PCMOUT_CTRL__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_CTRL__NSAMPLE(ip))
+#define set__AUD_PCMOUT_CTRL__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_CTRL(ip)) & \
+	~(mask__AUD_PCMOUT_CTRL__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_CTRL__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_CTRL__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_CTRL__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_CTRL(ip))
+
+
+
+/*
+ * AUD_PCMOUT_STA
+ */
+
+#define offset__AUD_PCMOUT_STA(ip) 0x20
+#define get__AUD_PCMOUT_STA(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_STA(ip))
+#define set__AUD_PCMOUT_STA(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_STA(ip))
+
+/* RUN_STOP */
+
+#define shift__AUD_PCMOUT_STA__RUN_STOP(ip) 0
+#define mask__AUD_PCMOUT_STA__RUN_STOP(ip) 0x1
+#define get__AUD_PCMOUT_STA__RUN_STOP(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_STA(ip)) >> shift__AUD_PCMOUT_STA__RUN_STOP(ip)) & \
+	mask__AUD_PCMOUT_STA__RUN_STOP(ip))
+#define set__AUD_PCMOUT_STA__RUN_STOP(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_STA(ip)) & \
+	~(mask__AUD_PCMOUT_STA__RUN_STOP(ip) << \
+	shift__AUD_PCMOUT_STA__RUN_STOP(ip))) | (((value) & \
+	mask__AUD_PCMOUT_STA__RUN_STOP(ip)) << \
+	shift__AUD_PCMOUT_STA__RUN_STOP(ip)), ip->base + \
+	offset__AUD_PCMOUT_STA(ip))
+
+#define value__AUD_PCMOUT_STA__RUN_STOP__STOPPED(ip) 0x0
+#define mask__AUD_PCMOUT_STA__RUN_STOP__STOPPED(ip) \
+	(value__AUD_PCMOUT_STA__RUN_STOP__STOPPED(ip) << \
+	shift__AUD_PCMOUT_STA__RUN_STOP(ip))
+#define set__AUD_PCMOUT_STA__RUN_STOP__STOPPED(ip) \
+	set__AUD_PCMOUT_STA__RUN_STOP(ip, \
+	value__AUD_PCMOUT_STA__RUN_STOP__STOPPED(ip))
+
+#define value__AUD_PCMOUT_STA__RUN_STOP__RUNNING(ip) 0x1
+#define mask__AUD_PCMOUT_STA__RUN_STOP__RUNNING(ip) \
+	(value__AUD_PCMOUT_STA__RUN_STOP__RUNNING(ip) << \
+	shift__AUD_PCMOUT_STA__RUN_STOP(ip))
+#define set__AUD_PCMOUT_STA__RUN_STOP__RUNNING(ip) \
+	set__AUD_PCMOUT_STA__RUN_STOP(ip, \
+	value__AUD_PCMOUT_STA__RUN_STOP__RUNNING(ip))
+
+/* UNF */
+
+#define shift__AUD_PCMOUT_STA__UNF(ip) 1
+#define mask__AUD_PCMOUT_STA__UNF(ip) 0x1
+#define get__AUD_PCMOUT_STA__UNF(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_STA(ip)) >> shift__AUD_PCMOUT_STA__UNF(ip)) & \
+	mask__AUD_PCMOUT_STA__UNF(ip))
+#define set__AUD_PCMOUT_STA__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_STA(ip)) & ~(mask__AUD_PCMOUT_STA__UNF(ip) << \
+	shift__AUD_PCMOUT_STA__UNF(ip))) | (((value) & \
+	mask__AUD_PCMOUT_STA__UNF(ip)) << shift__AUD_PCMOUT_STA__UNF(ip)), \
+	ip->base + offset__AUD_PCMOUT_STA(ip))
+
+#define value__AUD_PCMOUT_STA__UNF__DETECTED(ip) 0x1
+#define mask__AUD_PCMOUT_STA__UNF__DETECTED(ip) \
+	(value__AUD_PCMOUT_STA__UNF__DETECTED(ip) << \
+	shift__AUD_PCMOUT_STA__UNF(ip))
+#define set__AUD_PCMOUT_STA__UNF__DETECTED(ip) \
+	set__AUD_PCMOUT_STA__UNF(ip, value__AUD_PCMOUT_STA__UNF__DETECTED(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_PCMOUT_STA__NSAMPLE(ip) 2
+#define mask__AUD_PCMOUT_STA__NSAMPLE(ip) 0x1
+#define get__AUD_PCMOUT_STA__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_STA(ip)) >> shift__AUD_PCMOUT_STA__NSAMPLE(ip)) & \
+	mask__AUD_PCMOUT_STA__NSAMPLE(ip))
+#define set__AUD_PCMOUT_STA__NSAMPLE(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_STA(ip)) & ~(mask__AUD_PCMOUT_STA__NSAMPLE(ip) << \
+	shift__AUD_PCMOUT_STA__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_STA__NSAMPLE(ip)) << \
+	shift__AUD_PCMOUT_STA__NSAMPLE(ip)), ip->base + \
+	offset__AUD_PCMOUT_STA(ip))
+
+#define value__AUD_PCMOUT_STA__NSAMPLE__DONE(ip) 0x1
+#define mask__AUD_PCMOUT_STA__NSAMPLE__DONE(ip) \
+	(value__AUD_PCMOUT_STA__NSAMPLE__DONE(ip) << \
+	shift__AUD_PCMOUT_STA__NSAMPLE(ip))
+#define set__AUD_PCMOUT_STA__NSAMPLE__DONE(ip) \
+	set__AUD_PCMOUT_STA__NSAMPLE(ip, \
+	value__AUD_PCMOUT_STA__NSAMPLE__DONE(ip))
+
+
+
+/*
+ * AUD_PCMOUT_FMT
+ */
+
+#define offset__AUD_PCMOUT_FMT(ip) 0x24
+#define get__AUD_PCMOUT_FMT(ip) readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+#define set__AUD_PCMOUT_FMT(ip, value) writel((value), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+/* NBIT */
+
+#define shift__AUD_PCMOUT_FMT__NBIT(ip) 0
+#define mask__AUD_PCMOUT_FMT__NBIT(ip) 0x1
+#define get__AUD_PCMOUT_FMT__NBIT(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__NBIT(ip)) & \
+	mask__AUD_PCMOUT_FMT__NBIT(ip))
+#define set__AUD_PCMOUT_FMT__NBIT(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__NBIT(ip) << \
+	shift__AUD_PCMOUT_FMT__NBIT(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__NBIT(ip)) << shift__AUD_PCMOUT_FMT__NBIT(ip)), \
+	ip->base + offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__NBIT__32_BITS(ip) 0x0
+#define mask__AUD_PCMOUT_FMT__NBIT__32_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__NBIT__32_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__NBIT(ip))
+#define set__AUD_PCMOUT_FMT__NBIT__32_BITS(ip) \
+	set__AUD_PCMOUT_FMT__NBIT(ip, \
+	value__AUD_PCMOUT_FMT__NBIT__32_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__NBIT__16_BITS(ip) 0x1
+#define mask__AUD_PCMOUT_FMT__NBIT__16_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__NBIT__16_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__NBIT(ip))
+#define set__AUD_PCMOUT_FMT__NBIT__16_BITS(ip) \
+	set__AUD_PCMOUT_FMT__NBIT(ip, \
+	value__AUD_PCMOUT_FMT__NBIT__16_BITS(ip))
+
+/* DATA_SIZE */
+
+#define shift__AUD_PCMOUT_FMT__DATA_SIZE(ip) 1
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x3 : 0x7)
+#define get__AUD_PCMOUT_FMT__DATA_SIZE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__DATA_SIZE(ip)) & \
+	mask__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_FMT(ip)) & \
+	~(mask__AUD_PCMOUT_FMT__DATA_SIZE(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__DATA_SIZE(ip)) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x3 : 0x0)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x2 : 0x1)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x1 : 0x2)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x0 : 0x3)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x4)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip))
+
+#define value__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x5)
+#define mask__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) \
+	(value__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) << \
+	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
+#define set__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) \
+	set__AUD_PCMOUT_FMT__DATA_SIZE(ip, \
+	value__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip))
+
+/* LR_POL */
+
+#define shift__AUD_PCMOUT_FMT__LR_POL(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 3 : 4)
+#define mask__AUD_PCMOUT_FMT__LR_POL(ip) 0x1
+#define get__AUD_PCMOUT_FMT__LR_POL(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__LR_POL(ip)) & \
+	mask__AUD_PCMOUT_FMT__LR_POL(ip))
+#define set__AUD_PCMOUT_FMT__LR_POL(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__LR_POL(ip) << \
+	shift__AUD_PCMOUT_FMT__LR_POL(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__LR_POL(ip)) << \
+	shift__AUD_PCMOUT_FMT__LR_POL(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(ip) 0x0
+#define mask__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(ip) \
+	(value__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(ip) << \
+	shift__AUD_PCMOUT_FMT__LR_POL(ip))
+#define set__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(ip) \
+	set__AUD_PCMOUT_FMT__LR_POL(ip, \
+	value__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(ip))
+
+#define value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(ip) 0x1
+#define mask__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(ip) \
+	(value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(ip) << \
+	shift__AUD_PCMOUT_FMT__LR_POL(ip))
+#define set__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(ip) \
+	set__AUD_PCMOUT_FMT__LR_POL(ip, \
+	value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(ip))
+
+/* SCLK_EDGE */
+
+#define shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 4 : 5)
+#define mask__AUD_PCMOUT_FMT__SCLK_EDGE(ip) 0x1
+#define get__AUD_PCMOUT_FMT__SCLK_EDGE(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip)) & \
+	mask__AUD_PCMOUT_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMOUT_FMT__SCLK_EDGE(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_FMT(ip)) & \
+	~(mask__AUD_PCMOUT_FMT__SCLK_EDGE(ip) << \
+	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__SCLK_EDGE(ip)) << \
+	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_2_1 ? 0x1 : 0x0)
+#define mask__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) \
+	(value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) << \
+	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) \
+	set__AUD_PCMOUT_FMT__SCLK_EDGE(ip, \
+	value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip))
+
+#define value__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_2_1 ? 0x0 : 0x1)
+#define mask__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) \
+	(value__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) << \
+	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip))
+#define set__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) \
+	set__AUD_PCMOUT_FMT__SCLK_EDGE(ip, \
+	value__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip))
+
+/* PADDING */
+
+#define shift__AUD_PCMOUT_FMT__PADDING(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 5 : 6)
+#define mask__AUD_PCMOUT_FMT__PADDING(ip) 0x1
+#define get__AUD_PCMOUT_FMT__PADDING(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__PADDING(ip)) & \
+	mask__AUD_PCMOUT_FMT__PADDING(ip))
+#define set__AUD_PCMOUT_FMT__PADDING(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__PADDING(ip) << \
+	shift__AUD_PCMOUT_FMT__PADDING(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__PADDING(ip)) << \
+	shift__AUD_PCMOUT_FMT__PADDING(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(ip) 0x0
+#define mask__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(ip) \
+	(value__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(ip) << \
+	shift__AUD_PCMOUT_FMT__PADDING(ip))
+#define set__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(ip) \
+	set__AUD_PCMOUT_FMT__PADDING(ip, \
+	value__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(ip))
+
+#define value__AUD_PCMOUT_FMT__PADDING__NO_DELAY(ip) 0x1
+#define mask__AUD_PCMOUT_FMT__PADDING__NO_DELAY(ip) \
+	(value__AUD_PCMOUT_FMT__PADDING__NO_DELAY(ip) << \
+	shift__AUD_PCMOUT_FMT__PADDING(ip))
+#define set__AUD_PCMOUT_FMT__PADDING__NO_DELAY(ip) \
+	set__AUD_PCMOUT_FMT__PADDING(ip, \
+	value__AUD_PCMOUT_FMT__PADDING__NO_DELAY(ip))
+
+/* ALIGN */
+
+#define shift__AUD_PCMOUT_FMT__ALIGN(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 6 : 7)
+#define mask__AUD_PCMOUT_FMT__ALIGN(ip) 0x1
+#define get__AUD_PCMOUT_FMT__ALIGN(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__ALIGN(ip)) & \
+	mask__AUD_PCMOUT_FMT__ALIGN(ip))
+#define set__AUD_PCMOUT_FMT__ALIGN(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__ALIGN(ip) << \
+	shift__AUD_PCMOUT_FMT__ALIGN(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__ALIGN(ip)) << shift__AUD_PCMOUT_FMT__ALIGN(ip)), \
+	ip->base + offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__ALIGN__LEFT(ip) 0x0
+#define mask__AUD_PCMOUT_FMT__ALIGN__LEFT(ip) \
+	(value__AUD_PCMOUT_FMT__ALIGN__LEFT(ip) << \
+	shift__AUD_PCMOUT_FMT__ALIGN(ip))
+#define set__AUD_PCMOUT_FMT__ALIGN__LEFT(ip) \
+	set__AUD_PCMOUT_FMT__ALIGN(ip, value__AUD_PCMOUT_FMT__ALIGN__LEFT(ip))
+
+#define value__AUD_PCMOUT_FMT__ALIGN__RIGHT(ip) 0x1
+#define mask__AUD_PCMOUT_FMT__ALIGN__RIGHT(ip) \
+	(value__AUD_PCMOUT_FMT__ALIGN__RIGHT(ip) << \
+	shift__AUD_PCMOUT_FMT__ALIGN(ip))
+#define set__AUD_PCMOUT_FMT__ALIGN__RIGHT(ip) \
+	set__AUD_PCMOUT_FMT__ALIGN(ip, \
+	value__AUD_PCMOUT_FMT__ALIGN__RIGHT(ip))
+
+/* ORDER */
+
+#define shift__AUD_PCMOUT_FMT__ORDER(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 7 : 8)
+#define mask__AUD_PCMOUT_FMT__ORDER(ip) 0x1
+#define get__AUD_PCMOUT_FMT__ORDER(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__ORDER(ip)) & \
+	mask__AUD_PCMOUT_FMT__ORDER(ip))
+#define set__AUD_PCMOUT_FMT__ORDER(ip, value) writel((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__ORDER(ip) << \
+	shift__AUD_PCMOUT_FMT__ORDER(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__ORDER(ip)) << shift__AUD_PCMOUT_FMT__ORDER(ip)), \
+	ip->base + offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__ORDER__LSB_FIRST(ip) 0x0
+#define mask__AUD_PCMOUT_FMT__ORDER__LSB_FIRST(ip) \
+	(value__AUD_PCMOUT_FMT__ORDER__LSB_FIRST(ip) << \
+	shift__AUD_PCMOUT_FMT__ORDER(ip))
+#define set__AUD_PCMOUT_FMT__ORDER__LSB_FIRST(ip) \
+	set__AUD_PCMOUT_FMT__ORDER(ip, \
+	value__AUD_PCMOUT_FMT__ORDER__LSB_FIRST(ip))
+
+#define value__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(ip) 0x1
+#define mask__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(ip) \
+	(value__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(ip) << \
+	shift__AUD_PCMOUT_FMT__ORDER(ip))
+#define set__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(ip) \
+	set__AUD_PCMOUT_FMT__ORDER(ip, \
+	value__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(ip))
+
+/* NUM_CH */
+
+#define shift__AUD_PCMOUT_FMT__NUM_CH(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 8 : 9)
+#define mask__AUD_PCMOUT_FMT__NUM_CH(ip) 0x7
+#define get__AUD_PCMOUT_FMT__NUM_CH(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__NUM_CH(ip)) & \
+	mask__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH(ip, value) writel((readl(ip->base \
+	+ offset__AUD_PCMOUT_FMT(ip)) & ~(mask__AUD_PCMOUT_FMT__NUM_CH(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__NUM_CH(ip)) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x1)
+#define mask__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) \
+	(value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) \
+	set__AUD_PCMOUT_FMT__NUM_CH(ip, \
+	value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip))
+
+#define value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x2)
+#define mask__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) \
+	(value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) \
+	set__AUD_PCMOUT_FMT__NUM_CH(ip, \
+	value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip))
+
+#define value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x3)
+#define mask__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) \
+	(value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) \
+	set__AUD_PCMOUT_FMT__NUM_CH(ip, \
+	value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip))
+
+#define value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x4)
+#define mask__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) \
+	(value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) \
+	set__AUD_PCMOUT_FMT__NUM_CH(ip, \
+	value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip))
+
+#define value__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) (ip->ver < \
+	ver__AUD_PCMOUT__90_1_3 ? 0x5 : 0x5)
+#define mask__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) \
+	(value__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) << \
+	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
+#define set__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) \
+	set__AUD_PCMOUT_FMT__NUM_CH(ip, \
+	value__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip))
+
+/* BACK_STALLING */
+
+#define shift__AUD_PCMOUT_FMT__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 12)
+#define mask__AUD_PCMOUT_FMT__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x1)
+#define get__AUD_PCMOUT_FMT__BACK_STALLING(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> \
+	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip)) & \
+	mask__AUD_PCMOUT_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMOUT_FMT__BACK_STALLING(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_FMT(ip)) & \
+	~(mask__AUD_PCMOUT_FMT__BACK_STALLING(ip) << \
+	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__BACK_STALLING(ip)) << \
+	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#define value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x0)
+#define mask__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) \
+	(value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) << \
+	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) \
+	set__AUD_PCMOUT_FMT__BACK_STALLING(ip, \
+	value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip))
+
+#define value__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x1)
+#define mask__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) \
+	(value__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) << \
+	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip))
+#define set__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) \
+	set__AUD_PCMOUT_FMT__BACK_STALLING(ip, \
+	value__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip))
+
+/* DMA_REQ_TRIG_LMT */
+
+#define shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 11 : 13)
+#define mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_PCMOUT__65_2_2 ? 0x1f : 0x7f)
+#define get__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
+	offset__AUD_PCMOUT_FMT(ip)) >> \
+	shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip)) & \
+	mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip))
+#define set__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip, value) \
+	writel((readl(ip->base + offset__AUD_PCMOUT_FMT(ip)) & \
+	~(mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) << \
+	shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip))) | (((value) & \
+	mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip)) << \
+	shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip)), ip->base + \
+	offset__AUD_PCMOUT_FMT(ip))
+
+#endif
diff --git a/sound/stm/reg_aud_spdif.h b/sound/stm/reg_aud_spdif.h
new file mode 100644
index 0000000..5a83701
--- /dev/null
+++ b/sound/stm/reg_aud_spdif.h
@@ -0,0 +1,1906 @@
+#ifndef __SND_STM_AUD_SPDIF_H
+#define __SND_STM_AUD_SPDIF_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_SPDIF__90_1_1 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_SPDIF__90_2_2 2
+
+/* 7200 1.0 */
+#define ver__AUD_SPDIF__65_2_0 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_SPDIF__65_3_1 4
+
+
+
+/*
+ * AUD_SPDIF_RST
+ */
+
+#define offset__AUD_SPDIF_RST(ip) 0x00
+#define get__AUD_SPDIF_RST(ip) readl(ip->base + \
+	offset__AUD_SPDIF_RST(ip))
+#define set__AUD_SPDIF_RST(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_RST(ip))
+
+/* SRSTP */
+
+#define shift__AUD_SPDIF_RST__SRSTP(ip) 0
+#define mask__AUD_SPDIF_RST__SRSTP(ip) 0x1
+#define get__AUD_SPDIF_RST__SRSTP(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_RST(ip)) >> shift__AUD_SPDIF_RST__SRSTP(ip)) & \
+	mask__AUD_SPDIF_RST__SRSTP(ip))
+#define set__AUD_SPDIF_RST__SRSTP(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_RST(ip)) & ~(mask__AUD_SPDIF_RST__SRSTP(ip) << \
+	shift__AUD_SPDIF_RST__SRSTP(ip))) | (((value) & \
+	mask__AUD_SPDIF_RST__SRSTP(ip)) << shift__AUD_SPDIF_RST__SRSTP(ip)), \
+	ip->base + offset__AUD_SPDIF_RST(ip))
+
+#define value__AUD_SPDIF_RST__SRSTP__RUNNING(ip) 0x0
+#define mask__AUD_SPDIF_RST__SRSTP__RUNNING(ip) \
+	(value__AUD_SPDIF_RST__SRSTP__RUNNING(ip) << \
+	shift__AUD_SPDIF_RST__SRSTP(ip))
+#define set__AUD_SPDIF_RST__SRSTP__RUNNING(ip) \
+	set__AUD_SPDIF_RST__SRSTP(ip, \
+	value__AUD_SPDIF_RST__SRSTP__RUNNING(ip))
+
+#define value__AUD_SPDIF_RST__SRSTP__RESET(ip) 0x1
+#define mask__AUD_SPDIF_RST__SRSTP__RESET(ip) \
+	(value__AUD_SPDIF_RST__SRSTP__RESET(ip) << \
+	shift__AUD_SPDIF_RST__SRSTP(ip))
+#define set__AUD_SPDIF_RST__SRSTP__RESET(ip) \
+	set__AUD_SPDIF_RST__SRSTP(ip, value__AUD_SPDIF_RST__SRSTP__RESET(ip))
+
+
+
+/*
+ * AUD_SPDIF_DATA
+ */
+
+#define offset__AUD_SPDIF_DATA(ip) 0x04
+#define get__AUD_SPDIF_DATA(ip) readl(ip->base + \
+	offset__AUD_SPDIF_DATA(ip))
+#define set__AUD_SPDIF_DATA(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_DATA(ip))
+
+/* DATA */
+
+#define shift__AUD_SPDIF_DATA__DATA(ip) 0
+#define mask__AUD_SPDIF_DATA__DATA(ip) 0xffffffff
+#define get__AUD_SPDIF_DATA__DATA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_DATA(ip)) >> shift__AUD_SPDIF_DATA__DATA(ip)) & \
+	mask__AUD_SPDIF_DATA__DATA(ip))
+#define set__AUD_SPDIF_DATA__DATA(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_DATA(ip)) & ~(mask__AUD_SPDIF_DATA__DATA(ip) << \
+	shift__AUD_SPDIF_DATA__DATA(ip))) | (((value) & \
+	mask__AUD_SPDIF_DATA__DATA(ip)) << shift__AUD_SPDIF_DATA__DATA(ip)), \
+	ip->base + offset__AUD_SPDIF_DATA(ip))
+
+
+
+/*
+ * AUD_SPDIF_ITS
+ */
+
+#define offset__AUD_SPDIF_ITS(ip) 0x08
+#define get__AUD_SPDIF_ITS(ip) readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+#define set__AUD_SPDIF_ITS(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_ITS__UNF(ip) 0
+#define mask__AUD_SPDIF_ITS__UNF(ip) 0x1
+#define get__AUD_SPDIF_ITS__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__UNF(ip)) & \
+	mask__AUD_SPDIF_ITS__UNF(ip))
+#define set__AUD_SPDIF_ITS__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) & ~(mask__AUD_SPDIF_ITS__UNF(ip) << \
+	shift__AUD_SPDIF_ITS__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__UNF(ip)) << shift__AUD_SPDIF_ITS__UNF(ip)), \
+	ip->base + offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__UNF__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__UNF__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__UNF__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__UNF(ip))
+#define set__AUD_SPDIF_ITS__UNF__PENDING(ip) \
+	set__AUD_SPDIF_ITS__UNF(ip, value__AUD_SPDIF_ITS__UNF__PENDING(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_ITS__EOBURST(ip) 1
+#define mask__AUD_SPDIF_ITS__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_ITS__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__EOBURST(ip)) & \
+	mask__AUD_SPDIF_ITS__EOBURST(ip))
+#define set__AUD_SPDIF_ITS__EOBURST(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_ITS(ip)) & ~(mask__AUD_SPDIF_ITS__EOBURST(ip) << \
+	shift__AUD_SPDIF_ITS__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__EOBURST(ip)) << \
+	shift__AUD_SPDIF_ITS__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__EOBURST__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__EOBURST__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__EOBURST__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__EOBURST(ip))
+#define set__AUD_SPDIF_ITS__EOBURST__PENDING(ip) \
+	set__AUD_SPDIF_ITS__EOBURST(ip, \
+	value__AUD_SPDIF_ITS__EOBURST__PENDING(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_ITS__EOBLOCK(ip) 2
+#define mask__AUD_SPDIF_ITS__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_ITS__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_ITS__EOBLOCK(ip))
+#define set__AUD_SPDIF_ITS__EOBLOCK(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_ITS(ip)) & ~(mask__AUD_SPDIF_ITS__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_ITS__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_ITS__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__EOBLOCK__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__EOBLOCK__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__EOBLOCK__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__EOBLOCK(ip))
+#define set__AUD_SPDIF_ITS__EOBLOCK__PENDING(ip) \
+	set__AUD_SPDIF_ITS__EOBLOCK(ip, \
+	value__AUD_SPDIF_ITS__EOBLOCK__PENDING(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_ITS__EOLATENCY(ip) 3
+#define mask__AUD_SPDIF_ITS__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_ITS__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__EOLATENCY(ip)) & \
+	mask__AUD_SPDIF_ITS__EOLATENCY(ip))
+#define set__AUD_SPDIF_ITS__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_ITS(ip)) & \
+	~(mask__AUD_SPDIF_ITS__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_ITS__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_ITS__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__EOLATENCY__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__EOLATENCY__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__EOLATENCY__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__EOLATENCY(ip))
+#define set__AUD_SPDIF_ITS__EOLATENCY__PENDING(ip) \
+	set__AUD_SPDIF_ITS__EOLATENCY(ip, \
+	value__AUD_SPDIF_ITS__EOLATENCY__PENDING(ip))
+
+/* EOPD */
+
+#define shift__AUD_SPDIF_ITS__EOPD(ip) 4
+#define mask__AUD_SPDIF_ITS__EOPD(ip) 0x1
+#define get__AUD_SPDIF_ITS__EOPD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__EOPD(ip)) & \
+	mask__AUD_SPDIF_ITS__EOPD(ip))
+#define set__AUD_SPDIF_ITS__EOPD(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) & ~(mask__AUD_SPDIF_ITS__EOPD(ip) << \
+	shift__AUD_SPDIF_ITS__EOPD(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__EOPD(ip)) << shift__AUD_SPDIF_ITS__EOPD(ip)), \
+	ip->base + offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__EOPD__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__EOPD__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__EOPD__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__EOPD(ip))
+#define set__AUD_SPDIF_ITS__EOPD__PENDING(ip) \
+	set__AUD_SPDIF_ITS__EOPD(ip, value__AUD_SPDIF_ITS__EOPD__PENDING(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_ITS__NSAMPLE(ip) 5
+#define mask__AUD_SPDIF_ITS__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_ITS__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS(ip)) >> shift__AUD_SPDIF_ITS__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_ITS__NSAMPLE(ip))
+#define set__AUD_SPDIF_ITS__NSAMPLE(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_ITS(ip)) & ~(mask__AUD_SPDIF_ITS__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_ITS__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_ITS__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS(ip))
+
+#define value__AUD_SPDIF_ITS__NSAMPLE__PENDING(ip) 0x1
+#define mask__AUD_SPDIF_ITS__NSAMPLE__PENDING(ip) \
+	(value__AUD_SPDIF_ITS__NSAMPLE__PENDING(ip) << \
+	shift__AUD_SPDIF_ITS__NSAMPLE(ip))
+#define set__AUD_SPDIF_ITS__NSAMPLE__PENDING(ip) \
+	set__AUD_SPDIF_ITS__NSAMPLE(ip, \
+	value__AUD_SPDIF_ITS__NSAMPLE__PENDING(ip))
+
+
+
+/*
+ * AUD_SPDIF_ITS_CLR
+ */
+
+#define offset__AUD_SPDIF_ITS_CLR(ip) 0x0c
+#define get__AUD_SPDIF_ITS_CLR(ip) readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+#define set__AUD_SPDIF_ITS_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_ITS_CLR__UNF(ip) 0
+#define mask__AUD_SPDIF_ITS_CLR__UNF(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> shift__AUD_SPDIF_ITS_CLR__UNF(ip)) & \
+	mask__AUD_SPDIF_ITS_CLR__UNF(ip))
+#define set__AUD_SPDIF_ITS_CLR__UNF(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_ITS_CLR(ip)) & ~(mask__AUD_SPDIF_ITS_CLR__UNF(ip) \
+	<< shift__AUD_SPDIF_ITS_CLR__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__UNF(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__UNF(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__UNF__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__UNF__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__UNF__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__UNF(ip))
+#define set__AUD_SPDIF_ITS_CLR__UNF__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__UNF(ip, \
+	value__AUD_SPDIF_ITS_CLR__UNF__CLEAR(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_ITS_CLR__EOBURST(ip) 1
+#define mask__AUD_SPDIF_ITS_CLR__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> \
+	shift__AUD_SPDIF_ITS_CLR__EOBURST(ip)) & \
+	mask__AUD_SPDIF_ITS_CLR__EOBURST(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_ITS_CLR(ip)) & \
+	~(mask__AUD_SPDIF_ITS_CLR__EOBURST(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__EOBURST(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__EOBURST__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__EOBURST__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__EOBURST__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBURST(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOBURST__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__EOBURST(ip, \
+	value__AUD_SPDIF_ITS_CLR__EOBURST__CLEAR(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_ITS_CLR__EOBLOCK(ip) 2
+#define mask__AUD_SPDIF_ITS_CLR__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> \
+	shift__AUD_SPDIF_ITS_CLR__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_ITS_CLR__EOBLOCK(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOBLOCK(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_ITS_CLR(ip)) & \
+	~(mask__AUD_SPDIF_ITS_CLR__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__EOBLOCK__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__EOBLOCK__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__EOBLOCK__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOBLOCK(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOBLOCK__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__EOBLOCK(ip, \
+	value__AUD_SPDIF_ITS_CLR__EOBLOCK__CLEAR(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_ITS_CLR__EOLATENCY(ip) 3
+#define mask__AUD_SPDIF_ITS_CLR__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> \
+	shift__AUD_SPDIF_ITS_CLR__EOLATENCY(ip)) & \
+	mask__AUD_SPDIF_ITS_CLR__EOLATENCY(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_ITS_CLR(ip)) & \
+	~(mask__AUD_SPDIF_ITS_CLR__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__EOLATENCY__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__EOLATENCY__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__EOLATENCY__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOLATENCY(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOLATENCY__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__EOLATENCY(ip, \
+	value__AUD_SPDIF_ITS_CLR__EOLATENCY__CLEAR(ip))
+
+/* EOPD */
+
+#define shift__AUD_SPDIF_ITS_CLR__EOPD(ip) 4
+#define mask__AUD_SPDIF_ITS_CLR__EOPD(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__EOPD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> shift__AUD_SPDIF_ITS_CLR__EOPD(ip)) \
+	& mask__AUD_SPDIF_ITS_CLR__EOPD(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOPD(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_ITS_CLR(ip)) & ~(mask__AUD_SPDIF_ITS_CLR__EOPD(ip) \
+	<< shift__AUD_SPDIF_ITS_CLR__EOPD(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__EOPD(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__EOPD(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__EOPD__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__EOPD__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__EOPD__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__EOPD(ip))
+#define set__AUD_SPDIF_ITS_CLR__EOPD__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__EOPD(ip, \
+	value__AUD_SPDIF_ITS_CLR__EOPD__CLEAR(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_ITS_CLR__NSAMPLE(ip) 5
+#define mask__AUD_SPDIF_ITS_CLR__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_ITS_CLR__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip)) >> \
+	shift__AUD_SPDIF_ITS_CLR__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_ITS_CLR__NSAMPLE(ip))
+#define set__AUD_SPDIF_ITS_CLR__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_ITS_CLR(ip)) & \
+	~(mask__AUD_SPDIF_ITS_CLR__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_ITS_CLR__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_ITS_CLR__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_ITS_CLR(ip))
+
+#define value__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(ip) \
+	(value__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(ip) << \
+	shift__AUD_SPDIF_ITS_CLR__NSAMPLE(ip))
+#define set__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(ip) \
+	set__AUD_SPDIF_ITS_CLR__NSAMPLE(ip, \
+	value__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(ip))
+
+
+
+/*
+ * AUD_SPDIF_IT_EN
+ */
+
+#define offset__AUD_SPDIF_IT_EN(ip) 0x10
+#define get__AUD_SPDIF_IT_EN(ip) readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+#define set__AUD_SPDIF_IT_EN(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_IT_EN__UNF(ip) 0
+#define mask__AUD_SPDIF_IT_EN__UNF(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__UNF(ip)) & \
+	mask__AUD_SPDIF_IT_EN__UNF(ip))
+#define set__AUD_SPDIF_IT_EN__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) & ~(mask__AUD_SPDIF_IT_EN__UNF(ip) << \
+	shift__AUD_SPDIF_IT_EN__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__UNF(ip)) << shift__AUD_SPDIF_IT_EN__UNF(ip)), \
+	ip->base + offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__UNF__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__UNF__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__UNF__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__UNF(ip))
+#define set__AUD_SPDIF_IT_EN__UNF__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__UNF(ip, \
+	value__AUD_SPDIF_IT_EN__UNF__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__UNF__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__UNF__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__UNF__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__UNF(ip))
+#define set__AUD_SPDIF_IT_EN__UNF__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__UNF(ip, \
+	value__AUD_SPDIF_IT_EN__UNF__ENABLED(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_IT_EN__EOBURST(ip) 1
+#define mask__AUD_SPDIF_IT_EN__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__EOBURST(ip)) & \
+	mask__AUD_SPDIF_IT_EN__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN__EOBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN__EOBURST(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__EOBURST(ip)) << \
+	shift__AUD_SPDIF_IT_EN__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOBURST__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__EOBURST__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOBURST__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN__EOBURST__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOBURST(ip, \
+	value__AUD_SPDIF_IT_EN__EOBURST__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOBURST__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__EOBURST__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOBURST__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN__EOBURST__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOBURST(ip, \
+	value__AUD_SPDIF_IT_EN__EOBURST__ENABLED(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_IT_EN__EOBLOCK(ip) 2
+#define mask__AUD_SPDIF_IT_EN__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_IT_EN__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN__EOBLOCK(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_IT_EN__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOBLOCK__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__EOBLOCK__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOBLOCK__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN__EOBLOCK__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOBLOCK(ip, \
+	value__AUD_SPDIF_IT_EN__EOBLOCK__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOBLOCK__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__EOBLOCK__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOBLOCK__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN__EOBLOCK__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOBLOCK(ip, \
+	value__AUD_SPDIF_IT_EN__EOBLOCK__ENABLED(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_IT_EN__EOLATENCY(ip) 3
+#define mask__AUD_SPDIF_IT_EN__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__EOLATENCY(ip)) \
+	& mask__AUD_SPDIF_IT_EN__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_IT_EN__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOLATENCY__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__EOLATENCY__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOLATENCY__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN__EOLATENCY__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOLATENCY(ip, \
+	value__AUD_SPDIF_IT_EN__EOLATENCY__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOLATENCY__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__EOLATENCY__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOLATENCY__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN__EOLATENCY__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOLATENCY(ip, \
+	value__AUD_SPDIF_IT_EN__EOLATENCY__ENABLED(ip))
+
+/* EOPD */
+
+#define shift__AUD_SPDIF_IT_EN__EOPD(ip) 4
+#define mask__AUD_SPDIF_IT_EN__EOPD(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__EOPD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__EOPD(ip)) & \
+	mask__AUD_SPDIF_IT_EN__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN__EOPD(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) & ~(mask__AUD_SPDIF_IT_EN__EOPD(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOPD(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__EOPD(ip)) << shift__AUD_SPDIF_IT_EN__EOPD(ip)), \
+	ip->base + offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOPD__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__EOPD__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOPD__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN__EOPD__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOPD(ip, \
+	value__AUD_SPDIF_IT_EN__EOPD__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__EOPD__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__EOPD__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__EOPD__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN__EOPD__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__EOPD(ip, \
+	value__AUD_SPDIF_IT_EN__EOPD__ENABLED(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_IT_EN__NSAMPLE(ip) 5
+#define mask__AUD_SPDIF_IT_EN__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_IT_EN__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip)) >> shift__AUD_SPDIF_IT_EN__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_IT_EN__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_IT_EN__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_IT_EN__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN(ip))
+
+#define value__AUD_SPDIF_IT_EN__NSAMPLE__DISABLED(ip) 0x0
+#define mask__AUD_SPDIF_IT_EN__NSAMPLE__DISABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__NSAMPLE__DISABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN__NSAMPLE__DISABLED(ip) \
+	set__AUD_SPDIF_IT_EN__NSAMPLE(ip, \
+	value__AUD_SPDIF_IT_EN__NSAMPLE__DISABLED(ip))
+
+#define value__AUD_SPDIF_IT_EN__NSAMPLE__ENABLED(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN__NSAMPLE__ENABLED(ip) \
+	(value__AUD_SPDIF_IT_EN__NSAMPLE__ENABLED(ip) << \
+	shift__AUD_SPDIF_IT_EN__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN__NSAMPLE__ENABLED(ip) \
+	set__AUD_SPDIF_IT_EN__NSAMPLE(ip, \
+	value__AUD_SPDIF_IT_EN__NSAMPLE__ENABLED(ip))
+
+
+
+/*
+ * AUD_SPDIF_IT_EN_SET
+ */
+
+#define offset__AUD_SPDIF_IT_EN_SET(ip) 0x14
+#define get__AUD_SPDIF_IT_EN_SET(ip) readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+#define set__AUD_SPDIF_IT_EN_SET(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_IT_EN_SET__UNF(ip) 0
+#define mask__AUD_SPDIF_IT_EN_SET__UNF(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__UNF(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__UNF(ip))
+#define set__AUD_SPDIF_IT_EN_SET__UNF(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__UNF(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__UNF(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__UNF(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__UNF__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__UNF__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__UNF__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__UNF(ip))
+#define set__AUD_SPDIF_IT_EN_SET__UNF__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__UNF(ip, \
+	value__AUD_SPDIF_IT_EN_SET__UNF__SET(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_IT_EN_SET__EOBURST(ip) 1
+#define mask__AUD_SPDIF_IT_EN_SET__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__EOBURST(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__EOBURST(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOBURST(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__EOBURST__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__EOBURST__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__EOBURST__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOBURST__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__EOBURST(ip, \
+	value__AUD_SPDIF_IT_EN_SET__EOBURST__SET(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip) 2
+#define mask__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__EOBLOCK__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__EOBLOCK__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__EOBLOCK__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOBLOCK__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__EOBLOCK(ip, \
+	value__AUD_SPDIF_IT_EN_SET__EOBLOCK__SET(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip) 3
+#define mask__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__EOLATENCY__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__EOLATENCY__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__EOLATENCY__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOLATENCY__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__EOLATENCY(ip, \
+	value__AUD_SPDIF_IT_EN_SET__EOLATENCY__SET(ip))
+
+/* EOPD */
+
+#define shift__AUD_SPDIF_IT_EN_SET__EOPD(ip) 4
+#define mask__AUD_SPDIF_IT_EN_SET__EOPD(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__EOPD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__EOPD(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOPD(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__EOPD(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOPD(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__EOPD(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOPD(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__EOPD__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__EOPD__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__EOPD__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN_SET__EOPD__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__EOPD(ip, \
+	value__AUD_SPDIF_IT_EN_SET__EOPD__SET(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip) 5
+#define mask__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_SET(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_SET(ip))
+
+#define value__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(ip) \
+	(value__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(ip) << \
+	shift__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(ip) \
+	set__AUD_SPDIF_IT_EN_SET__NSAMPLE(ip, \
+	value__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(ip))
+
+
+
+/*
+ * AUD_SPDIF_IT_EN_CLR
+ */
+
+#define offset__AUD_SPDIF_IT_EN_CLR(ip) 0x18
+#define get__AUD_SPDIF_IT_EN_CLR(ip) readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+#define set__AUD_SPDIF_IT_EN_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__UNF(ip) 0
+#define mask__AUD_SPDIF_IT_EN_CLR__UNF(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__UNF(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__UNF(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__UNF(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__UNF(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__UNF(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__UNF(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__UNF(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__UNF(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__EOBURST(ip) 1
+#define mask__AUD_SPDIF_IT_EN_CLR__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBURST(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__EOBURST(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOBURST(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__EOBURST__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__EOBURST__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__EOBURST__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBURST(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOBURST__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__EOBURST(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__EOBURST__CLEAR(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip) 2
+#define mask__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__EOBLOCK__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__EOBLOCK__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__EOBLOCK__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOBLOCK__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__EOBLOCK(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__EOBLOCK__CLEAR(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip) 3
+#define mask__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__EOLATENCY__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__EOLATENCY__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__EOLATENCY__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOLATENCY__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__EOLATENCY(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__EOLATENCY__CLEAR(ip))
+
+/* EOPD */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__EOPD(ip) 4
+#define mask__AUD_SPDIF_IT_EN_CLR__EOPD(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__EOPD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__EOPD(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOPD(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__EOPD(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOPD(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__EOPD(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOPD(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__EOPD__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__EOPD__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__EOPD__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__EOPD(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__EOPD__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__EOPD(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__EOPD__CLEAR(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip) 5
+#define mask__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip)) >> \
+	shift__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_IT_EN_CLR(ip)) & \
+	~(mask__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_IT_EN_CLR(ip))
+
+#define value__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(ip) 0x1
+#define mask__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(ip) \
+	(value__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(ip) << \
+	shift__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip))
+#define set__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(ip) \
+	set__AUD_SPDIF_IT_EN_CLR__NSAMPLE(ip, \
+	value__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(ip))
+
+
+
+/*
+ * AUD_SPDIF_CTRL
+ */
+
+#define offset__AUD_SPDIF_CTRL(ip) 0x1c
+#define get__AUD_SPDIF_CTRL(ip) readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip))
+#define set__AUD_SPDIF_CTRL(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_CTRL(ip))
+
+/* MODE */
+
+#define shift__AUD_SPDIF_CTRL__MODE(ip) 0
+#define mask__AUD_SPDIF_CTRL__MODE(ip) 0x7
+#define get__AUD_SPDIF_CTRL__MODE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__MODE(ip)) & \
+	mask__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) & ~(mask__AUD_SPDIF_CTRL__MODE(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__MODE(ip)) << shift__AUD_SPDIF_CTRL__MODE(ip)), \
+	ip->base + offset__AUD_SPDIF_CTRL(ip))
+
+#define value__AUD_SPDIF_CTRL__MODE__OFF(ip) 0x0
+#define mask__AUD_SPDIF_CTRL__MODE__OFF(ip) \
+	(value__AUD_SPDIF_CTRL__MODE__OFF(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE__OFF(ip) \
+	set__AUD_SPDIF_CTRL__MODE(ip, value__AUD_SPDIF_CTRL__MODE__OFF(ip))
+
+#define value__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(ip) 0x1
+#define mask__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(ip) \
+	(value__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(ip) \
+	set__AUD_SPDIF_CTRL__MODE(ip, \
+	value__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(ip))
+
+#define value__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(ip) 0x2
+#define mask__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(ip) \
+	(value__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(ip) \
+	set__AUD_SPDIF_CTRL__MODE(ip, \
+	value__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(ip))
+
+#define value__AUD_SPDIF_CTRL__MODE__PCM(ip) 0x3
+#define mask__AUD_SPDIF_CTRL__MODE__PCM(ip) \
+	(value__AUD_SPDIF_CTRL__MODE__PCM(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE__PCM(ip) \
+	set__AUD_SPDIF_CTRL__MODE(ip, value__AUD_SPDIF_CTRL__MODE__PCM(ip))
+
+#define value__AUD_SPDIF_CTRL__MODE__ENCODED(ip) 0x4
+#define mask__AUD_SPDIF_CTRL__MODE__ENCODED(ip) \
+	(value__AUD_SPDIF_CTRL__MODE__ENCODED(ip) << \
+	shift__AUD_SPDIF_CTRL__MODE(ip))
+#define set__AUD_SPDIF_CTRL__MODE__ENCODED(ip) \
+	set__AUD_SPDIF_CTRL__MODE(ip, \
+	value__AUD_SPDIF_CTRL__MODE__ENCODED(ip))
+
+/* IDLE */
+
+#define shift__AUD_SPDIF_CTRL__IDLE(ip) 3
+#define mask__AUD_SPDIF_CTRL__IDLE(ip) 0x1
+#define get__AUD_SPDIF_CTRL__IDLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__IDLE(ip)) & \
+	mask__AUD_SPDIF_CTRL__IDLE(ip))
+#define set__AUD_SPDIF_CTRL__IDLE(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) & ~(mask__AUD_SPDIF_CTRL__IDLE(ip) << \
+	shift__AUD_SPDIF_CTRL__IDLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__IDLE(ip)) << shift__AUD_SPDIF_CTRL__IDLE(ip)), \
+	ip->base + offset__AUD_SPDIF_CTRL(ip))
+
+#define value__AUD_SPDIF_CTRL__IDLE__NORMAL(ip) 0x0
+#define mask__AUD_SPDIF_CTRL__IDLE__NORMAL(ip) \
+	(value__AUD_SPDIF_CTRL__IDLE__NORMAL(ip) << \
+	shift__AUD_SPDIF_CTRL__IDLE(ip))
+#define set__AUD_SPDIF_CTRL__IDLE__NORMAL(ip) \
+	set__AUD_SPDIF_CTRL__IDLE(ip, value__AUD_SPDIF_CTRL__IDLE__NORMAL(ip))
+
+#define value__AUD_SPDIF_CTRL__IDLE__IDLE(ip) 0x1
+#define mask__AUD_SPDIF_CTRL__IDLE__IDLE(ip) \
+	(value__AUD_SPDIF_CTRL__IDLE__IDLE(ip) << \
+	shift__AUD_SPDIF_CTRL__IDLE(ip))
+#define set__AUD_SPDIF_CTRL__IDLE__IDLE(ip) \
+	set__AUD_SPDIF_CTRL__IDLE(ip, value__AUD_SPDIF_CTRL__IDLE__IDLE(ip))
+
+/* RND */
+
+#define shift__AUD_SPDIF_CTRL__RND(ip) 4
+#define mask__AUD_SPDIF_CTRL__RND(ip) 0x1
+#define get__AUD_SPDIF_CTRL__RND(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__RND(ip)) & \
+	mask__AUD_SPDIF_CTRL__RND(ip))
+#define set__AUD_SPDIF_CTRL__RND(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) & ~(mask__AUD_SPDIF_CTRL__RND(ip) << \
+	shift__AUD_SPDIF_CTRL__RND(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__RND(ip)) << shift__AUD_SPDIF_CTRL__RND(ip)), \
+	ip->base + offset__AUD_SPDIF_CTRL(ip))
+
+#define value__AUD_SPDIF_CTRL__RND__NO_ROUNDING(ip) 0x0
+#define mask__AUD_SPDIF_CTRL__RND__NO_ROUNDING(ip) \
+	(value__AUD_SPDIF_CTRL__RND__NO_ROUNDING(ip) << \
+	shift__AUD_SPDIF_CTRL__RND(ip))
+#define set__AUD_SPDIF_CTRL__RND__NO_ROUNDING(ip) \
+	set__AUD_SPDIF_CTRL__RND(ip, \
+	value__AUD_SPDIF_CTRL__RND__NO_ROUNDING(ip))
+
+#define value__AUD_SPDIF_CTRL__RND__16_BITS_ROUNDING(ip) 0x1
+#define mask__AUD_SPDIF_CTRL__RND__16_BITS_ROUNDING(ip) \
+	(value__AUD_SPDIF_CTRL__RND__16_BITS_ROUNDING(ip) << \
+	shift__AUD_SPDIF_CTRL__RND(ip))
+#define set__AUD_SPDIF_CTRL__RND__16_BITS_ROUNDING(ip) \
+	set__AUD_SPDIF_CTRL__RND(ip, \
+	value__AUD_SPDIF_CTRL__RND__16_BITS_ROUNDING(ip))
+
+/* CLK_DIV */
+
+#define shift__AUD_SPDIF_CTRL__CLK_DIV(ip) 5
+#define mask__AUD_SPDIF_CTRL__CLK_DIV(ip) 0xff
+#define get__AUD_SPDIF_CTRL__CLK_DIV(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__CLK_DIV(ip)) & \
+	mask__AUD_SPDIF_CTRL__CLK_DIV(ip))
+#define set__AUD_SPDIF_CTRL__CLK_DIV(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_CTRL(ip)) & ~(mask__AUD_SPDIF_CTRL__CLK_DIV(ip) << \
+	shift__AUD_SPDIF_CTRL__CLK_DIV(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__CLK_DIV(ip)) << \
+	shift__AUD_SPDIF_CTRL__CLK_DIV(ip)), ip->base + \
+	offset__AUD_SPDIF_CTRL(ip))
+
+/* STUFFING */
+
+#define shift__AUD_SPDIF_CTRL__STUFFING(ip) 14
+#define mask__AUD_SPDIF_CTRL__STUFFING(ip) 0x1
+#define get__AUD_SPDIF_CTRL__STUFFING(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__STUFFING(ip)) & \
+	mask__AUD_SPDIF_CTRL__STUFFING(ip))
+#define set__AUD_SPDIF_CTRL__STUFFING(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CTRL(ip)) & \
+	~(mask__AUD_SPDIF_CTRL__STUFFING(ip) << \
+	shift__AUD_SPDIF_CTRL__STUFFING(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__STUFFING(ip)) << \
+	shift__AUD_SPDIF_CTRL__STUFFING(ip)), ip->base + \
+	offset__AUD_SPDIF_CTRL(ip))
+
+#define value__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(ip) 0x0
+#define mask__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(ip) \
+	(value__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(ip) << \
+	shift__AUD_SPDIF_CTRL__STUFFING(ip))
+#define set__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(ip) \
+	set__AUD_SPDIF_CTRL__STUFFING(ip, \
+	value__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(ip))
+
+#define value__AUD_SPDIF_CTRL__STUFFING__HARDWARE(ip) 0x1
+#define mask__AUD_SPDIF_CTRL__STUFFING__HARDWARE(ip) \
+	(value__AUD_SPDIF_CTRL__STUFFING__HARDWARE(ip) << \
+	shift__AUD_SPDIF_CTRL__STUFFING(ip))
+#define set__AUD_SPDIF_CTRL__STUFFING__HARDWARE(ip) \
+	set__AUD_SPDIF_CTRL__STUFFING(ip, \
+	value__AUD_SPDIF_CTRL__STUFFING__HARDWARE(ip))
+
+/* MEMREAD */
+
+#define shift__AUD_SPDIF_CTRL__MEMREAD(ip) 15
+#define mask__AUD_SPDIF_CTRL__MEMREAD(ip) 0x1ffff
+#define get__AUD_SPDIF_CTRL__MEMREAD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CTRL(ip)) >> shift__AUD_SPDIF_CTRL__MEMREAD(ip)) & \
+	mask__AUD_SPDIF_CTRL__MEMREAD(ip))
+#define set__AUD_SPDIF_CTRL__MEMREAD(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_CTRL(ip)) & ~(mask__AUD_SPDIF_CTRL__MEMREAD(ip) << \
+	shift__AUD_SPDIF_CTRL__MEMREAD(ip))) | (((value) & \
+	mask__AUD_SPDIF_CTRL__MEMREAD(ip)) << \
+	shift__AUD_SPDIF_CTRL__MEMREAD(ip)), ip->base + \
+	offset__AUD_SPDIF_CTRL(ip))
+
+
+
+/*
+ * AUD_SPDIF_STA
+ */
+
+#define offset__AUD_SPDIF_STA(ip) 0x20
+#define get__AUD_SPDIF_STA(ip) readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+#define set__AUD_SPDIF_STA(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+/* RUN_STOP */
+
+#define shift__AUD_SPDIF_STA__RUN_STOP(ip) 0
+#define mask__AUD_SPDIF_STA__RUN_STOP(ip) 0x1
+#define get__AUD_SPDIF_STA__RUN_STOP(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__RUN_STOP(ip)) & \
+	mask__AUD_SPDIF_STA__RUN_STOP(ip))
+#define set__AUD_SPDIF_STA__RUN_STOP(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__RUN_STOP(ip) << \
+	shift__AUD_SPDIF_STA__RUN_STOP(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__RUN_STOP(ip)) << \
+	shift__AUD_SPDIF_STA__RUN_STOP(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__RUN_STOP__STOPPED(ip) 0x0
+#define mask__AUD_SPDIF_STA__RUN_STOP__STOPPED(ip) \
+	(value__AUD_SPDIF_STA__RUN_STOP__STOPPED(ip) << \
+	shift__AUD_SPDIF_STA__RUN_STOP(ip))
+#define set__AUD_SPDIF_STA__RUN_STOP__STOPPED(ip) \
+	set__AUD_SPDIF_STA__RUN_STOP(ip, \
+	value__AUD_SPDIF_STA__RUN_STOP__STOPPED(ip))
+
+#define value__AUD_SPDIF_STA__RUN_STOP__RUNNING(ip) 0x1
+#define mask__AUD_SPDIF_STA__RUN_STOP__RUNNING(ip) \
+	(value__AUD_SPDIF_STA__RUN_STOP__RUNNING(ip) << \
+	shift__AUD_SPDIF_STA__RUN_STOP(ip))
+#define set__AUD_SPDIF_STA__RUN_STOP__RUNNING(ip) \
+	set__AUD_SPDIF_STA__RUN_STOP(ip, \
+	value__AUD_SPDIF_STA__RUN_STOP__RUNNING(ip))
+
+/* UNF */
+
+#define shift__AUD_SPDIF_STA__UNF(ip) 1
+#define mask__AUD_SPDIF_STA__UNF(ip) 0x1
+#define get__AUD_SPDIF_STA__UNF(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__UNF(ip)) & \
+	mask__AUD_SPDIF_STA__UNF(ip))
+#define set__AUD_SPDIF_STA__UNF(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__UNF(ip) << \
+	shift__AUD_SPDIF_STA__UNF(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__UNF(ip)) << shift__AUD_SPDIF_STA__UNF(ip)), \
+	ip->base + offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__UNF__DETECTED(ip) 0x1
+#define mask__AUD_SPDIF_STA__UNF__DETECTED(ip) \
+	(value__AUD_SPDIF_STA__UNF__DETECTED(ip) << \
+	shift__AUD_SPDIF_STA__UNF(ip))
+#define set__AUD_SPDIF_STA__UNF__DETECTED(ip) \
+	set__AUD_SPDIF_STA__UNF(ip, value__AUD_SPDIF_STA__UNF__DETECTED(ip))
+
+/* EOBURST */
+
+#define shift__AUD_SPDIF_STA__EOBURST(ip) 2
+#define mask__AUD_SPDIF_STA__EOBURST(ip) 0x1
+#define get__AUD_SPDIF_STA__EOBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__EOBURST(ip)) & \
+	mask__AUD_SPDIF_STA__EOBURST(ip))
+#define set__AUD_SPDIF_STA__EOBURST(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__EOBURST(ip) << \
+	shift__AUD_SPDIF_STA__EOBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__EOBURST(ip)) << \
+	shift__AUD_SPDIF_STA__EOBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__EOBURST__END(ip) 0x1
+#define mask__AUD_SPDIF_STA__EOBURST__END(ip) \
+	(value__AUD_SPDIF_STA__EOBURST__END(ip) << \
+	shift__AUD_SPDIF_STA__EOBURST(ip))
+#define set__AUD_SPDIF_STA__EOBURST__END(ip) \
+	set__AUD_SPDIF_STA__EOBURST(ip, \
+	value__AUD_SPDIF_STA__EOBURST__END(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIF_STA__EOBLOCK(ip) 3
+#define mask__AUD_SPDIF_STA__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIF_STA__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__EOBLOCK(ip)) & \
+	mask__AUD_SPDIF_STA__EOBLOCK(ip))
+#define set__AUD_SPDIF_STA__EOBLOCK(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__EOBLOCK(ip) << \
+	shift__AUD_SPDIF_STA__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__EOBLOCK(ip)) << \
+	shift__AUD_SPDIF_STA__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__EOBLOCK__END(ip) 0x1
+#define mask__AUD_SPDIF_STA__EOBLOCK__END(ip) \
+	(value__AUD_SPDIF_STA__EOBLOCK__END(ip) << \
+	shift__AUD_SPDIF_STA__EOBLOCK(ip))
+#define set__AUD_SPDIF_STA__EOBLOCK__END(ip) \
+	set__AUD_SPDIF_STA__EOBLOCK(ip, \
+	value__AUD_SPDIF_STA__EOBLOCK__END(ip))
+
+/* EOLATENCY */
+
+#define shift__AUD_SPDIF_STA__EOLATENCY(ip) 4
+#define mask__AUD_SPDIF_STA__EOLATENCY(ip) 0x1
+#define get__AUD_SPDIF_STA__EOLATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__EOLATENCY(ip)) & \
+	mask__AUD_SPDIF_STA__EOLATENCY(ip))
+#define set__AUD_SPDIF_STA__EOLATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_STA(ip)) & \
+	~(mask__AUD_SPDIF_STA__EOLATENCY(ip) << \
+	shift__AUD_SPDIF_STA__EOLATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__EOLATENCY(ip)) << \
+	shift__AUD_SPDIF_STA__EOLATENCY(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__EOLATENCY__END_OF_LATENCY_COUNTER(ip) \
+	0x1
+#define mask__AUD_SPDIF_STA__EOLATENCY__END_OF_LATENCY_COUNTER(ip) \
+	(value__AUD_SPDIF_STA__EOLATENCY__END_OF_LATENCY_COUNTER(ip) << \
+	shift__AUD_SPDIF_STA__EOLATENCY(ip))
+#define set__AUD_SPDIF_STA__EOLATENCY__END_OF_LATENCY_COUNTER(ip) \
+	set__AUD_SPDIF_STA__EOLATENCY(ip, \
+	value__AUD_SPDIF_STA__EOLATENCY__END_OF_LATENCY_COUNTER(ip))
+
+/* PDDATA */
+
+#define shift__AUD_SPDIF_STA__PDDATA(ip) 5
+#define mask__AUD_SPDIF_STA__PDDATA(ip) 0x1
+#define get__AUD_SPDIF_STA__PDDATA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__PDDATA(ip)) & \
+	mask__AUD_SPDIF_STA__PDDATA(ip))
+#define set__AUD_SPDIF_STA__PDDATA(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__PDDATA(ip) << \
+	shift__AUD_SPDIF_STA__PDDATA(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__PDDATA(ip)) << shift__AUD_SPDIF_STA__PDDATA(ip)), \
+	ip->base + offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__PDDATA__SENT(ip) 0x1
+#define mask__AUD_SPDIF_STA__PDDATA__SENT(ip) \
+	(value__AUD_SPDIF_STA__PDDATA__SENT(ip) << \
+	shift__AUD_SPDIF_STA__PDDATA(ip))
+#define set__AUD_SPDIF_STA__PDDATA__SENT(ip) \
+	set__AUD_SPDIF_STA__PDDATA(ip, value__AUD_SPDIF_STA__PDDATA__SENT(ip))
+
+/* NSAMPLE */
+
+#define shift__AUD_SPDIF_STA__NSAMPLE(ip) 6
+#define mask__AUD_SPDIF_STA__NSAMPLE(ip) 0x1
+#define get__AUD_SPDIF_STA__NSAMPLE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__NSAMPLE(ip)) & \
+	mask__AUD_SPDIF_STA__NSAMPLE(ip))
+#define set__AUD_SPDIF_STA__NSAMPLE(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__NSAMPLE(ip) << \
+	shift__AUD_SPDIF_STA__NSAMPLE(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__NSAMPLE(ip)) << \
+	shift__AUD_SPDIF_STA__NSAMPLE(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__NSAMPLE__DONE(ip) 0x1
+#define mask__AUD_SPDIF_STA__NSAMPLE__DONE(ip) \
+	(value__AUD_SPDIF_STA__NSAMPLE__DONE(ip) << \
+	shift__AUD_SPDIF_STA__NSAMPLE(ip))
+#define set__AUD_SPDIF_STA__NSAMPLE__DONE(ip) \
+	set__AUD_SPDIF_STA__NSAMPLE(ip, \
+	value__AUD_SPDIF_STA__NSAMPLE__DONE(ip))
+
+/* PABIT */
+
+#define shift__AUD_SPDIF_STA__PABIT(ip) 7
+#define mask__AUD_SPDIF_STA__PABIT(ip) 0xff
+#define get__AUD_SPDIF_STA__PABIT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__PABIT(ip)) & \
+	mask__AUD_SPDIF_STA__PABIT(ip))
+#define set__AUD_SPDIF_STA__PABIT(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__PABIT(ip) << \
+	shift__AUD_SPDIF_STA__PABIT(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__PABIT(ip)) << shift__AUD_SPDIF_STA__PABIT(ip)), \
+	ip->base + offset__AUD_SPDIF_STA(ip))
+
+/* PDPAUSE */
+
+#define shift__AUD_SPDIF_STA__PDPAUSE(ip) 15
+#define mask__AUD_SPDIF_STA__PDPAUSE(ip) 0x1
+#define get__AUD_SPDIF_STA__PDPAUSE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> shift__AUD_SPDIF_STA__PDPAUSE(ip)) & \
+	mask__AUD_SPDIF_STA__PDPAUSE(ip))
+#define set__AUD_SPDIF_STA__PDPAUSE(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_STA(ip)) & ~(mask__AUD_SPDIF_STA__PDPAUSE(ip) << \
+	shift__AUD_SPDIF_STA__PDPAUSE(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__PDPAUSE(ip)) << \
+	shift__AUD_SPDIF_STA__PDPAUSE(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+#define value__AUD_SPDIF_STA__PDPAUSE__SENT(ip) 0x1
+#define mask__AUD_SPDIF_STA__PDPAUSE__SENT(ip) \
+	(value__AUD_SPDIF_STA__PDPAUSE__SENT(ip) << \
+	shift__AUD_SPDIF_STA__PDPAUSE(ip))
+#define set__AUD_SPDIF_STA__PDPAUSE__SENT(ip) \
+	set__AUD_SPDIF_STA__PDPAUSE(ip, \
+	value__AUD_SPDIF_STA__PDPAUSE__SENT(ip))
+
+/* SAMPLES_IN_FIFO */
+
+#define shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 16)
+#define mask__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1f)
+#define get__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_STA(ip)) >> \
+	shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip)) & \
+	mask__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip))
+#define set__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_STA(ip)) & \
+	~(mask__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) << \
+	shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip))) | (((value) & \
+	mask__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip)) << \
+	shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip)), ip->base + \
+	offset__AUD_SPDIF_STA(ip))
+
+
+
+/*
+ * AUD_SPDIF_PA_PB
+ */
+
+#define offset__AUD_SPDIF_PA_PB(ip) 0x24
+#define get__AUD_SPDIF_PA_PB(ip) readl(ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip))
+#define set__AUD_SPDIF_PA_PB(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip))
+
+/* PB */
+
+#define shift__AUD_SPDIF_PA_PB__PB(ip) 0
+#define mask__AUD_SPDIF_PA_PB__PB(ip) 0xffff
+#define get__AUD_SPDIF_PA_PB__PB(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip)) >> shift__AUD_SPDIF_PA_PB__PB(ip)) & \
+	mask__AUD_SPDIF_PA_PB__PB(ip))
+#define set__AUD_SPDIF_PA_PB__PB(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip)) & ~(mask__AUD_SPDIF_PA_PB__PB(ip) << \
+	shift__AUD_SPDIF_PA_PB__PB(ip))) | (((value) & \
+	mask__AUD_SPDIF_PA_PB__PB(ip)) << shift__AUD_SPDIF_PA_PB__PB(ip)), \
+	ip->base + offset__AUD_SPDIF_PA_PB(ip))
+
+/* PA */
+
+#define shift__AUD_SPDIF_PA_PB__PA(ip) 16
+#define mask__AUD_SPDIF_PA_PB__PA(ip) 0xffff
+#define get__AUD_SPDIF_PA_PB__PA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip)) >> shift__AUD_SPDIF_PA_PB__PA(ip)) & \
+	mask__AUD_SPDIF_PA_PB__PA(ip))
+#define set__AUD_SPDIF_PA_PB__PA(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_PA_PB(ip)) & ~(mask__AUD_SPDIF_PA_PB__PA(ip) << \
+	shift__AUD_SPDIF_PA_PB__PA(ip))) | (((value) & \
+	mask__AUD_SPDIF_PA_PB__PA(ip)) << shift__AUD_SPDIF_PA_PB__PA(ip)), \
+	ip->base + offset__AUD_SPDIF_PA_PB(ip))
+
+
+
+/*
+ * AUD_SPDIF_PC_PD
+ */
+
+#define offset__AUD_SPDIF_PC_PD(ip) 0x28
+#define get__AUD_SPDIF_PC_PD(ip) readl(ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip))
+#define set__AUD_SPDIF_PC_PD(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip))
+
+/* PD */
+
+#define shift__AUD_SPDIF_PC_PD__PD(ip) 0
+#define mask__AUD_SPDIF_PC_PD__PD(ip) 0xffff
+#define get__AUD_SPDIF_PC_PD__PD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip)) >> shift__AUD_SPDIF_PC_PD__PD(ip)) & \
+	mask__AUD_SPDIF_PC_PD__PD(ip))
+#define set__AUD_SPDIF_PC_PD__PD(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip)) & ~(mask__AUD_SPDIF_PC_PD__PD(ip) << \
+	shift__AUD_SPDIF_PC_PD__PD(ip))) | (((value) & \
+	mask__AUD_SPDIF_PC_PD__PD(ip)) << shift__AUD_SPDIF_PC_PD__PD(ip)), \
+	ip->base + offset__AUD_SPDIF_PC_PD(ip))
+
+/* PC */
+
+#define shift__AUD_SPDIF_PC_PD__PC(ip) 16
+#define mask__AUD_SPDIF_PC_PD__PC(ip) 0xffff
+#define get__AUD_SPDIF_PC_PD__PC(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip)) >> shift__AUD_SPDIF_PC_PD__PC(ip)) & \
+	mask__AUD_SPDIF_PC_PD__PC(ip))
+#define set__AUD_SPDIF_PC_PD__PC(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_PC_PD(ip)) & ~(mask__AUD_SPDIF_PC_PD__PC(ip) << \
+	shift__AUD_SPDIF_PC_PD__PC(ip))) | (((value) & \
+	mask__AUD_SPDIF_PC_PD__PC(ip)) << shift__AUD_SPDIF_PC_PD__PC(ip)), \
+	ip->base + offset__AUD_SPDIF_PC_PD(ip))
+
+
+
+/*
+ * AUD_SPDIF_CL1
+ */
+
+#define offset__AUD_SPDIF_CL1(ip) 0x2c
+#define get__AUD_SPDIF_CL1(ip) readl(ip->base + \
+	offset__AUD_SPDIF_CL1(ip))
+#define set__AUD_SPDIF_CL1(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_CL1(ip))
+
+/* CL1 */
+
+#define shift__AUD_SPDIF_CL1__CL1(ip) 0
+#define mask__AUD_SPDIF_CL1__CL1(ip) 0xffffffff
+#define get__AUD_SPDIF_CL1__CL1(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL1(ip)) >> shift__AUD_SPDIF_CL1__CL1(ip)) & \
+	mask__AUD_SPDIF_CL1__CL1(ip))
+#define set__AUD_SPDIF_CL1__CL1(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_CL1(ip)) & ~(mask__AUD_SPDIF_CL1__CL1(ip) << \
+	shift__AUD_SPDIF_CL1__CL1(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL1__CL1(ip)) << shift__AUD_SPDIF_CL1__CL1(ip)), \
+	ip->base + offset__AUD_SPDIF_CL1(ip))
+
+
+
+/*
+ * AUD_SPDIF_CR1
+ */
+
+#define offset__AUD_SPDIF_CR1(ip) 0x30
+#define get__AUD_SPDIF_CR1(ip) readl(ip->base + \
+	offset__AUD_SPDIF_CR1(ip))
+#define set__AUD_SPDIF_CR1(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_CR1(ip))
+
+/* CR1 */
+
+#define shift__AUD_SPDIF_CR1__CR1(ip) 0
+#define mask__AUD_SPDIF_CR1__CR1(ip) 0xffffffff
+#define get__AUD_SPDIF_CR1__CR1(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CR1(ip)) >> shift__AUD_SPDIF_CR1__CR1(ip)) & \
+	mask__AUD_SPDIF_CR1__CR1(ip))
+#define set__AUD_SPDIF_CR1__CR1(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIF_CR1(ip)) & ~(mask__AUD_SPDIF_CR1__CR1(ip) << \
+	shift__AUD_SPDIF_CR1__CR1(ip))) | (((value) & \
+	mask__AUD_SPDIF_CR1__CR1(ip)) << shift__AUD_SPDIF_CR1__CR1(ip)), \
+	ip->base + offset__AUD_SPDIF_CR1(ip))
+
+
+
+/*
+ * AUD_SPDIF_CL2_CR2_UV
+ */
+
+#define offset__AUD_SPDIF_CL2_CR2_UV(ip) 0x34
+#define get__AUD_SPDIF_CL2_CR2_UV(ip) readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV(ip, value) writel((value), ip->base \
+	+ offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* CL2 */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__CL2(ip) 0
+#define mask__AUD_SPDIF_CL2_CR2_UV__CL2(ip) 0xf
+#define get__AUD_SPDIF_CL2_CR2_UV__CL2(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__CL2(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__CL2(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__CL2(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__CL2(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__CL2(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__CL2(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__CL2(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* CR2 */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__CR2(ip) 8
+#define mask__AUD_SPDIF_CL2_CR2_UV__CR2(ip) 0xf
+#define get__AUD_SPDIF_CL2_CR2_UV__CR2(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__CR2(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__CR2(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__CR2(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__CR2(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__CR2(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__CR2(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__CR2(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* LU */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__LU(ip) 16
+#define mask__AUD_SPDIF_CL2_CR2_UV__LU(ip) 0x1
+#define get__AUD_SPDIF_CL2_CR2_UV__LU(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__LU(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__LU(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__LU(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__LU(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__LU(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__LU(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__LU(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* RU */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__RU(ip) 17
+#define mask__AUD_SPDIF_CL2_CR2_UV__RU(ip) 0x1
+#define get__AUD_SPDIF_CL2_CR2_UV__RU(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__RU(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__RU(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__RU(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__RU(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__RU(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__RU(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__RU(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* LV */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__LV(ip) 18
+#define mask__AUD_SPDIF_CL2_CR2_UV__LV(ip) 0x1
+#define get__AUD_SPDIF_CL2_CR2_UV__LV(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__LV(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__LV(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__LV(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__LV(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__LV(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__LV(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__LV(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+/* RV */
+
+#define shift__AUD_SPDIF_CL2_CR2_UV__RV(ip) 19
+#define mask__AUD_SPDIF_CL2_CR2_UV__RV(ip) 0x1
+#define get__AUD_SPDIF_CL2_CR2_UV__RV(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip)) >> \
+	shift__AUD_SPDIF_CL2_CR2_UV__RV(ip)) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__RV(ip))
+#define set__AUD_SPDIF_CL2_CR2_UV__RV(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CL2_CR2_UV(ip)) & \
+	~(mask__AUD_SPDIF_CL2_CR2_UV__RV(ip) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__RV(ip))) | (((value) & \
+	mask__AUD_SPDIF_CL2_CR2_UV__RV(ip)) << \
+	shift__AUD_SPDIF_CL2_CR2_UV__RV(ip)), ip->base + \
+	offset__AUD_SPDIF_CL2_CR2_UV(ip))
+
+
+
+/*
+ * AUD_SPDIF_PAU_LAT
+ */
+
+#define offset__AUD_SPDIF_PAU_LAT(ip) 0x38
+#define get__AUD_SPDIF_PAU_LAT(ip) readl(ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip))
+#define set__AUD_SPDIF_PAU_LAT(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip))
+
+/* LAT */
+
+#define shift__AUD_SPDIF_PAU_LAT__LAT(ip) 0
+#define mask__AUD_SPDIF_PAU_LAT__LAT(ip) 0xffff
+#define get__AUD_SPDIF_PAU_LAT__LAT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip)) >> shift__AUD_SPDIF_PAU_LAT__LAT(ip)) & \
+	mask__AUD_SPDIF_PAU_LAT__LAT(ip))
+#define set__AUD_SPDIF_PAU_LAT__LAT(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIF_PAU_LAT(ip)) & ~(mask__AUD_SPDIF_PAU_LAT__LAT(ip) \
+	<< shift__AUD_SPDIF_PAU_LAT__LAT(ip))) | (((value) & \
+	mask__AUD_SPDIF_PAU_LAT__LAT(ip)) << \
+	shift__AUD_SPDIF_PAU_LAT__LAT(ip)), ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip))
+
+/* NPD_BURST */
+
+#define shift__AUD_SPDIF_PAU_LAT__NPD_BURST(ip) 16
+#define mask__AUD_SPDIF_PAU_LAT__NPD_BURST(ip) 0xffff
+#define get__AUD_SPDIF_PAU_LAT__NPD_BURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip)) >> \
+	shift__AUD_SPDIF_PAU_LAT__NPD_BURST(ip)) & \
+	mask__AUD_SPDIF_PAU_LAT__NPD_BURST(ip))
+#define set__AUD_SPDIF_PAU_LAT__NPD_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_PAU_LAT(ip)) & \
+	~(mask__AUD_SPDIF_PAU_LAT__NPD_BURST(ip) << \
+	shift__AUD_SPDIF_PAU_LAT__NPD_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_PAU_LAT__NPD_BURST(ip)) << \
+	shift__AUD_SPDIF_PAU_LAT__NPD_BURST(ip)), ip->base + \
+	offset__AUD_SPDIF_PAU_LAT(ip))
+
+
+
+/*
+ * AUD_SPDIF_BST_FL
+ */
+
+#define offset__AUD_SPDIF_BST_FL(ip) 0x3c
+#define get__AUD_SPDIF_BST_FL(ip) readl(ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip))
+#define set__AUD_SPDIF_BST_FL(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip))
+
+/* PDBURST */
+
+#define shift__AUD_SPDIF_BST_FL__PDBURST(ip) 0
+#define mask__AUD_SPDIF_BST_FL__PDBURST(ip) 0xffff
+#define get__AUD_SPDIF_BST_FL__PDBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip)) >> shift__AUD_SPDIF_BST_FL__PDBURST(ip)) \
+	& mask__AUD_SPDIF_BST_FL__PDBURST(ip))
+#define set__AUD_SPDIF_BST_FL__PDBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_BST_FL(ip)) & \
+	~(mask__AUD_SPDIF_BST_FL__PDBURST(ip) << \
+	shift__AUD_SPDIF_BST_FL__PDBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_BST_FL__PDBURST(ip)) << \
+	shift__AUD_SPDIF_BST_FL__PDBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip))
+
+/* DBURST */
+
+#define shift__AUD_SPDIF_BST_FL__DBURST(ip) 16
+#define mask__AUD_SPDIF_BST_FL__DBURST(ip) 0xffff
+#define get__AUD_SPDIF_BST_FL__DBURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip)) >> shift__AUD_SPDIF_BST_FL__DBURST(ip)) \
+	& mask__AUD_SPDIF_BST_FL__DBURST(ip))
+#define set__AUD_SPDIF_BST_FL__DBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_BST_FL(ip)) & \
+	~(mask__AUD_SPDIF_BST_FL__DBURST(ip) << \
+	shift__AUD_SPDIF_BST_FL__DBURST(ip))) | (((value) & \
+	mask__AUD_SPDIF_BST_FL__DBURST(ip)) << \
+	shift__AUD_SPDIF_BST_FL__DBURST(ip)), ip->base + \
+	offset__AUD_SPDIF_BST_FL(ip))
+
+
+
+/*
+ * AUD_SPDIF_CONFIG
+ */
+
+#define offset__AUD_SPDIF_CONFIG(ip) (ip->ver < ver__AUD_SPDIF__65_3_1 \
+	? -1 : 0x40)
+#define get__AUD_SPDIF_CONFIG(ip) readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+#define set__AUD_SPDIF_CONFIG(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+/* P_BIT */
+
+#define shift__AUD_SPDIF_CONFIG__P_BIT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0)
+
+#define value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) \
+	(value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) << \
+	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) \
+	set__AUD_SPDIF_CONFIG__P_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip))
+
+#define value__AUD_SPDIF_CONFIG__P_BIT__HW(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__P_BIT__HW(ip) \
+	(value__AUD_SPDIF_CONFIG__P_BIT__HW(ip) << \
+	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__P_BIT__HW(ip) \
+	set__AUD_SPDIF_CONFIG__P_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__P_BIT__HW(ip))
+
+#define value__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) \
+	(value__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) << \
+	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) \
+	set__AUD_SPDIF_CONFIG__P_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip))
+
+/* C_BIT */
+
+#define shift__AUD_SPDIF_CONFIG__C_BIT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 1)
+
+#define value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) \
+	(value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) << \
+	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) \
+	set__AUD_SPDIF_CONFIG__C_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip))
+
+#define value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) \
+	(value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) << \
+	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) \
+	set__AUD_SPDIF_CONFIG__C_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip))
+
+#define value__AUD_SPDIF_CONFIG__C_BIT__HW(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__C_BIT__HW(ip) \
+	(value__AUD_SPDIF_CONFIG__C_BIT__HW(ip) << \
+	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__C_BIT__HW(ip) \
+	set__AUD_SPDIF_CONFIG__C_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__C_BIT__HW(ip))
+
+/* U_BIT */
+
+#define shift__AUD_SPDIF_CONFIG__U_BIT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 2)
+
+#define value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) \
+	(value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) << \
+	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) \
+	set__AUD_SPDIF_CONFIG__U_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip))
+
+#define value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) \
+	(value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) << \
+	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) \
+	set__AUD_SPDIF_CONFIG__U_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip))
+
+#define value__AUD_SPDIF_CONFIG__U_BIT__HW(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__U_BIT__HW(ip) \
+	(value__AUD_SPDIF_CONFIG__U_BIT__HW(ip) << \
+	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__U_BIT__HW(ip) \
+	set__AUD_SPDIF_CONFIG__U_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__U_BIT__HW(ip))
+
+/* V_BIT */
+
+#define shift__AUD_SPDIF_CONFIG__V_BIT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 2)
+
+#define value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) \
+	(value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) << \
+	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) \
+	set__AUD_SPDIF_CONFIG__V_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip))
+
+#define value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) \
+	(value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) << \
+	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) \
+	set__AUD_SPDIF_CONFIG__V_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip))
+
+#define value__AUD_SPDIF_CONFIG__V_BIT__HW(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__V_BIT__HW(ip) \
+	(value__AUD_SPDIF_CONFIG__V_BIT__HW(ip) << \
+	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
+#define set__AUD_SPDIF_CONFIG__V_BIT__HW(ip) \
+	set__AUD_SPDIF_CONFIG__V_BIT(ip, \
+	value__AUD_SPDIF_CONFIG__V_BIT__HW(ip))
+
+/* ONE_BIT_AUDIO */
+
+#define shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 4)
+#define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define get__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip)) >> \
+	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip)) & \
+	mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))
+#define set__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CONFIG(ip)) & \
+	~(mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) << \
+	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))) | (((value) & \
+	mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip)) << \
+	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip)), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+#define value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) (ip->ver \
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))
+#define set__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) \
+	set__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip, \
+	value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip))
+
+#define value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))
+#define set__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) \
+	set__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip, \
+	value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip))
+
+/* MEM_FMT */
+
+#define shift__AUD_SPDIF_CONFIG__MEM_FMT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 5)
+#define mask__AUD_SPDIF_CONFIG__MEM_FMT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define get__AUD_SPDIF_CONFIG__MEM_FMT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip)) >> shift__AUD_SPDIF_CONFIG__MEM_FMT(ip)) \
+	& mask__AUD_SPDIF_CONFIG__MEM_FMT(ip))
+#define set__AUD_SPDIF_CONFIG__MEM_FMT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CONFIG(ip)) & \
+	~(mask__AUD_SPDIF_CONFIG__MEM_FMT(ip) << \
+	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip))) | (((value) & \
+	mask__AUD_SPDIF_CONFIG__MEM_FMT(ip)) << \
+	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip)), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+#define value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) (ip->ver \
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) \
+	(value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) << \
+	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip))
+#define set__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) \
+	set__AUD_SPDIF_CONFIG__MEM_FMT(ip, \
+	value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip))
+
+#define value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) (ip->ver \
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) \
+	(value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) << \
+	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip))
+#define set__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) \
+	set__AUD_SPDIF_CONFIG__MEM_FMT(ip, \
+	value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip))
+
+/* DTS_HD */
+
+#define shift__AUD_SPDIF_CONFIG__DTS_HD(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 6)
+#define mask__AUD_SPDIF_CONFIG__DTS_HD(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define get__AUD_SPDIF_CONFIG__DTS_HD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip)) >> shift__AUD_SPDIF_CONFIG__DTS_HD(ip)) \
+	& mask__AUD_SPDIF_CONFIG__DTS_HD(ip))
+#define set__AUD_SPDIF_CONFIG__DTS_HD(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CONFIG(ip)) & \
+	~(mask__AUD_SPDIF_CONFIG__DTS_HD(ip) << \
+	shift__AUD_SPDIF_CONFIG__DTS_HD(ip))) | (((value) & \
+	mask__AUD_SPDIF_CONFIG__DTS_HD(ip)) << \
+	shift__AUD_SPDIF_CONFIG__DTS_HD(ip)), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+#define value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__DTS_HD(ip))
+#define set__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) \
+	set__AUD_SPDIF_CONFIG__DTS_HD(ip, \
+	value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip))
+
+#define value__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__DTS_HD(ip))
+#define set__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) \
+	set__AUD_SPDIF_CONFIG__DTS_HD(ip, \
+	value__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip))
+
+/* BACK_STALLING */
+
+#define shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 7)
+#define mask__AUD_SPDIF_CONFIG__BACK_STALLING(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define get__AUD_SPDIF_CONFIG__BACK_STALLING(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip)) >> \
+	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip)) & \
+	mask__AUD_SPDIF_CONFIG__BACK_STALLING(ip))
+#define set__AUD_SPDIF_CONFIG__BACK_STALLING(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CONFIG(ip)) & \
+	~(mask__AUD_SPDIF_CONFIG__BACK_STALLING(ip) << \
+	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip))) | (((value) & \
+	mask__AUD_SPDIF_CONFIG__BACK_STALLING(ip)) << \
+	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip)), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+#define value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) (ip->ver \
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
+#define mask__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip))
+#define set__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) \
+	set__AUD_SPDIF_CONFIG__BACK_STALLING(ip, \
+	value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip))
+
+#define value__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
+#define mask__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) \
+	(value__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) << \
+	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip))
+#define set__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) \
+	set__AUD_SPDIF_CONFIG__BACK_STALLING(ip, \
+	value__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip))
+
+/* DMA_REQ_TRIG_LMT */
+
+#define shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 8)
+#define mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1f)
+#define get__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip)) >> \
+	shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip)) & \
+	mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip))
+#define set__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIF_CONFIG(ip)) & \
+	~(mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) << \
+	shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip))) | (((value) & \
+	mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip)) << \
+	shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip)), ip->base + \
+	offset__AUD_SPDIF_CONFIG(ip))
+
+#endif
diff --git a/sound/stm/reg_aud_spdifpc.h b/sound/stm/reg_aud_spdifpc.h
new file mode 100644
index 0000000..0c4dbc9
--- /dev/null
+++ b/sound/stm/reg_aud_spdifpc.h
@@ -0,0 +1,2708 @@
+#ifndef __SND_STM_AUD_SPDIFPC_H
+#define __SND_STM_AUD_SPDIFPC_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_SPDIFPC__90_1_0 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_SPDIFPC__90_1_1 2
+
+/* 7200 1.0 */
+#define ver__AUD_SPDIFPC__65_1_2 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_SPDIFPC__65_3_0 4
+
+
+
+/*
+ * AUD_SPDIFPC_CFG
+ */
+
+#define offset__AUD_SPDIFPC_CFG(ip) 0x000
+#define get__AUD_SPDIFPC_CFG(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+#define set__AUD_SPDIFPC_CFG(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+/* DEVICE_EN */
+
+#define shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip) 0
+#define mask__AUD_SPDIFPC_CFG__DEVICE_EN(ip) 0x1
+#define get__AUD_SPDIFPC_CFG__DEVICE_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip)) \
+	& mask__AUD_SPDIFPC_CFG__DEVICE_EN(ip))
+#define set__AUD_SPDIFPC_CFG__DEVICE_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__DEVICE_EN(ip) << \
+	shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__DEVICE_EN(ip)) << \
+	shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip))
+#define set__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_CFG__DEVICE_EN(ip, \
+	value__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__DEVICE_EN(ip))
+#define set__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_CFG__DEVICE_EN(ip, \
+	value__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(ip))
+
+/* SW_RESET */
+
+#define shift__AUD_SPDIFPC_CFG__SW_RESET(ip) 1
+#define mask__AUD_SPDIFPC_CFG__SW_RESET(ip) 0x1
+#define get__AUD_SPDIFPC_CFG__SW_RESET(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> shift__AUD_SPDIFPC_CFG__SW_RESET(ip)) \
+	& mask__AUD_SPDIFPC_CFG__SW_RESET(ip))
+#define set__AUD_SPDIFPC_CFG__SW_RESET(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__SW_RESET(ip) << \
+	shift__AUD_SPDIFPC_CFG__SW_RESET(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__SW_RESET(ip)) << \
+	shift__AUD_SPDIFPC_CFG__SW_RESET(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(ip) 0x0
+#define mask__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(ip) \
+	(value__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(ip) << \
+	shift__AUD_SPDIFPC_CFG__SW_RESET(ip))
+#define set__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(ip) \
+	set__AUD_SPDIFPC_CFG__SW_RESET(ip, \
+	value__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(ip))
+
+#define value__AUD_SPDIFPC_CFG__SW_RESET__RESET(ip) 0x1
+#define mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(ip) \
+	(value__AUD_SPDIFPC_CFG__SW_RESET__RESET(ip) << \
+	shift__AUD_SPDIFPC_CFG__SW_RESET(ip))
+#define set__AUD_SPDIFPC_CFG__SW_RESET__RESET(ip) \
+	set__AUD_SPDIFPC_CFG__SW_RESET(ip, \
+	value__AUD_SPDIFPC_CFG__SW_RESET__RESET(ip))
+
+/* FIFO_EN */
+
+#define shift__AUD_SPDIFPC_CFG__FIFO_EN(ip) 2
+#define mask__AUD_SPDIFPC_CFG__FIFO_EN(ip) 0x1
+#define get__AUD_SPDIFPC_CFG__FIFO_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> shift__AUD_SPDIFPC_CFG__FIFO_EN(ip)) & \
+	mask__AUD_SPDIFPC_CFG__FIFO_EN(ip))
+#define set__AUD_SPDIFPC_CFG__FIFO_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__FIFO_EN(ip) << \
+	shift__AUD_SPDIFPC_CFG__FIFO_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__FIFO_EN(ip)) << \
+	shift__AUD_SPDIFPC_CFG__FIFO_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__FIFO_EN(ip))
+#define set__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_CFG__FIFO_EN(ip, \
+	value__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__FIFO_EN(ip))
+#define set__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_CFG__FIFO_EN(ip, \
+	value__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(ip))
+
+/* AUDIO_WORD_SIZE */
+
+#define shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip) 3
+#define mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip) 0x3
+#define get__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip)) & \
+	mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip))
+#define set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip) << \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip)) << \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__16_BITS(ip) 0x0
+#define mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__16_BITS(ip) \
+	(value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__16_BITS(ip) << \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip))
+#define set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__16_BITS(ip) \
+	set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip, \
+	value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__16_BITS(ip))
+
+#define value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__20_BITS(ip) 0x1
+#define mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__20_BITS(ip) \
+	(value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__20_BITS(ip) << \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip))
+#define set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__20_BITS(ip) \
+	set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip, \
+	value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__20_BITS(ip))
+
+#define value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(ip) 0x2
+#define mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(ip) \
+	(value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(ip) << \
+	shift__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip))
+#define set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(ip) \
+	set__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE(ip, \
+	value__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(ip))
+
+/* REQ_ACK_EN */
+
+#define shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip) 5
+#define mask__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip) 0x1
+#define get__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> \
+	shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip)) & \
+	mask__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip))
+#define set__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip) << \
+	shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip)) << \
+	shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip))
+#define set__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip, \
+	value__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip))
+#define set__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_CFG__REQ_ACK_EN(ip, \
+	value__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip))
+
+/* CHA_STA_BITS */
+
+#define shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) (ip->ver < \
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 6)
+#define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) (ip->ver < \
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x1)
+#define get__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip)) >> \
+	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip)) & \
+	mask__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))
+#define set__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
+	~(mask__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) << \
+	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip)) << \
+	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CFG(ip))
+
+#define value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) (ip->ver < \
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x0)
+#define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) \
+	(value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) << \
+	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))
+#define set__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) \
+	set__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip, \
+	value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip))
+
+#define value__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) (ip->ver < \
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x1)
+#define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) \
+	(value__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) << \
+	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))
+#define set__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) \
+	set__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip, \
+	value__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_STA
+ */
+
+#define offset__AUD_SPDIFPC_STA(ip) 0x004
+#define get__AUD_SPDIFPC_STA(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+#define set__AUD_SPDIFPC_STA(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+/* SOFT_RESET */
+
+#define shift__AUD_SPDIFPC_STA__SOFT_RESET(ip) 1
+#define mask__AUD_SPDIFPC_STA__SOFT_RESET(ip) 0x1
+#define get__AUD_SPDIFPC_STA__SOFT_RESET(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__SOFT_RESET(ip)) & \
+	mask__AUD_SPDIFPC_STA__SOFT_RESET(ip))
+#define set__AUD_SPDIFPC_STA__SOFT_RESET(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__SOFT_RESET(ip) << \
+	shift__AUD_SPDIFPC_STA__SOFT_RESET(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__SOFT_RESET(ip)) << \
+	shift__AUD_SPDIFPC_STA__SOFT_RESET(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__SOFT_RESET__ACTIVE(ip) 0x1
+#define mask__AUD_SPDIFPC_STA__SOFT_RESET__ACTIVE(ip) \
+	(value__AUD_SPDIFPC_STA__SOFT_RESET__ACTIVE(ip) << \
+	shift__AUD_SPDIFPC_STA__SOFT_RESET(ip))
+#define set__AUD_SPDIFPC_STA__SOFT_RESET__ACTIVE(ip) \
+	set__AUD_SPDIFPC_STA__SOFT_RESET(ip, \
+	value__AUD_SPDIFPC_STA__SOFT_RESET__ACTIVE(ip))
+
+/* VALIDITY_REG_EMPTY */
+
+#define shift__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip) 2
+#define mask__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip) 0x1
+#define get__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip)) & \
+	mask__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip))
+#define set__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip)) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__EMPTY(ip) 0x1
+#define mask__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__EMPTY(ip) \
+	(value__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__EMPTY(ip) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip))
+#define set__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__EMPTY(ip) \
+	set__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY(ip, \
+	value__AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__EMPTY(ip))
+
+/* VALIDITY_REG_UNDERRUN */
+
+#define shift__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip) 3
+#define mask__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip) 0x1
+#define get__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip)) & \
+	mask__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip)) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__DETECTED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__DETECTED(ip) \
+	(value__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__DETECTED(ip) << \
+	shift__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__DETECTED(ip) \
+	set__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN(ip, \
+	value__AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__DETECTED(ip))
+
+/* USER_DATA_REG_STATUS */
+
+#define shift__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip) 4
+#define mask__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip) 0x1
+#define get__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip)) & \
+	mask__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip))
+#define set__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip)) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__EMPTY(ip) 0x1
+#define mask__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__EMPTY(ip) \
+	(value__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__EMPTY(ip) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip))
+#define set__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__EMPTY(ip) \
+	set__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS(ip, \
+	value__AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__EMPTY(ip))
+
+/* USER_DATA_REG_UNDERRUN */
+
+#define shift__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip) 5
+#define mask__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip) 0x1
+#define get__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip)) & \
+	mask__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip)) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__DETECTED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__DETECTED(ip) \
+	(value__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__DETECTED(ip) << \
+	shift__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__DETECTED(ip) \
+	set__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN(ip, \
+	value__AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__DETECTED(ip))
+
+/* CHL_STS_BUFF_EMPTY */
+
+#define shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip) 6
+#define mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip) 0x1
+#define get__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip)) & \
+	mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip))
+#define set__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip)) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__EMPTY(ip) 0x1
+#define mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__EMPTY(ip) \
+	(value__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__EMPTY(ip) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip))
+#define set__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__EMPTY(ip) \
+	set__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(ip, \
+	value__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__EMPTY(ip))
+
+/* CHL_STS_BUFF_UNDERRUN */
+
+#define shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip) 7
+#define mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip) 0x1
+#define get__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip)) & \
+	mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip)) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__DETECTED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__DETECTED(ip) \
+	(value__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__DETECTED(ip) << \
+	shift__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip))
+#define set__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__DETECTED(ip) \
+	set__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN(ip, \
+	value__AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__DETECTED(ip))
+
+/* I2S_FIFO_OVERRUN */
+
+#define shift__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip) 8
+#define mask__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip) 0x1
+#define get__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_STA(ip)) >> \
+	shift__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip)) & \
+	mask__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip))
+#define set__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip) << \
+	shift__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip)) << \
+	shift__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_STA(ip))
+
+#define value__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__DETECTED(ip) 0x1
+#define mask__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__DETECTED(ip) \
+	(value__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__DETECTED(ip) << \
+	shift__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip))
+#define set__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__DETECTED(ip) \
+	set__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN(ip, \
+	value__AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__DETECTED(ip))
+
+/* CURR_CHL_STS_BUFFER */
+
+#define shift__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER(ip) 16
+
+#define value__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__MASK(ip) 0x7
+#define mask__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__MASK(ip) \
+	(value__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__MASK(ip) << \
+	shift__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER(ip))
+#define set__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__MASK(ip) \
+	set__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER(ip, \
+	value__AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__MASK(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_IT_EN
+ */
+
+#define offset__AUD_SPDIFPC_IT_EN(ip) 0x008
+#define get__AUD_SPDIFPC_IT_EN(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+/* INTERRUPT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip) 0
+#define mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__INTERRUPT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__INTERRUPT_EN__ENABLED(ip))
+
+/* SOFT_RESET_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip) 1
+#define mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__ENABLED(ip))
+
+/* VALIDITY_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip) 2
+#define mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__DISABLED(ip) \
+	0x0
+#define mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__ENABLED(ip))
+
+/* VALIDITY_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip) 3
+#define mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__DISABLED(ip) 0x0
+#define \
+	mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__DISABLED(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__ENABLED(ip))
+
+/* USER_DATA_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip) 4
+#define mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__DISABLED(ip) \
+	0x0
+#define mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__ENABLED(ip))
+
+/* USER_DATA_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip) 5
+#define mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip))) | (((value) \
+	& mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__DISABLED(ip) 0x0
+#define \
+	mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip))
+#define \
+	set__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__DISABLED(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__ENABLED(ip) 0x1
+#define \
+	mask__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__ENABLED(ip))
+
+/* CHL_STS_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip) 6
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__DISABLED(ip) \
+	0x0
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__ENABLED(ip))
+
+/* CHL_STS_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip) 7
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__ENABLED(ip))
+
+/* I2S_FIFO_OVERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip) 8
+#define mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__ENABLED(ip))
+
+/* RUN_STOP_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip) 16
+#define mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__ENABLED(ip))
+
+/* UNDERFLOW_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip) 17
+#define mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__ENABLED(ip))
+
+/* EODATABURST_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip) 18
+#define mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__ENABLED(ip))
+
+/* EOBLOCK_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip) 19
+#define mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__ENABLED(ip))
+
+/* LATENCY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip) 20
+#define mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__ENABLED(ip))
+
+/* PD_DATA_BURST */
+
+#define shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip) 21
+#define mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__DISABLED(ip) 0x0
+#define mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip, \
+	value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__PD_DATA_BURST(ip, \
+	value__AUD_SPDIFPC_IT_EN__PD_DATA_BURST__ENABLED(ip))
+
+/* SAMPLES_READ_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip) 22
+#define mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__DISABLED(ip) \
+	0x0
+#define mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__ENABLED(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__ENABLED(ip))
+
+/* PD_PAUSE_BURST_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip) 31
+#define mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) >> \
+	shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_EN(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_EN(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__DISABLED(ip) \
+	0x0
+#define mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__DISABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__DISABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__DISABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__DISABLED(ip))
+
+#define value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__ENABLED(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__ENABLED(ip) \
+	(value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__ENABLED(ip) << \
+	shift__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__ENABLED(ip) \
+	set__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__ENABLED(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_ITS
+ */
+
+#define offset__AUD_SPDIFPC_ITS(ip) 0x00c
+#define get__AUD_SPDIFPC_ITS(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+#define set__AUD_SPDIFPC_ITS(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+/* INTERRUPT */
+
+#define shift__AUD_SPDIFPC_ITS__INTERRUPT(ip) 0
+#define mask__AUD_SPDIFPC_ITS__INTERRUPT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__INTERRUPT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> shift__AUD_SPDIFPC_ITS__INTERRUPT(ip)) \
+	& mask__AUD_SPDIFPC_ITS__INTERRUPT(ip))
+#define set__AUD_SPDIFPC_ITS__INTERRUPT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__INTERRUPT(ip) << \
+	shift__AUD_SPDIFPC_ITS__INTERRUPT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__INTERRUPT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__INTERRUPT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__INTERRUPT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__INTERRUPT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__INTERRUPT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__INTERRUPT(ip))
+#define set__AUD_SPDIFPC_ITS__INTERRUPT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__INTERRUPT(ip, \
+	value__AUD_SPDIFPC_ITS__INTERRUPT__PENDING(ip))
+
+/* SOFT_RESET_INT */
+
+#define shift__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip) 1
+#define mask__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip))
+#define set__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__SOFT_RESET_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__SOFT_RESET_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__SOFT_RESET_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip))
+#define set__AUD_SPDIFPC_ITS__SOFT_RESET_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__SOFT_RESET_INT(ip, \
+	value__AUD_SPDIFPC_ITS__SOFT_RESET_INT__PENDING(ip))
+
+/* VALIDITY_EMPTY_INT */
+
+#define shift__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip) 2
+#define mask__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT(ip, \
+	value__AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__PENDING(ip))
+
+/* VALIDITY_UNDERRUN_INT */
+
+#define shift__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip) 3
+#define mask__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT(ip, \
+	value__AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__PENDING(ip))
+
+/* USER_DATA_EMPTY_INT */
+
+#define shift__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip) 4
+#define mask__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT(ip, \
+	value__AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__PENDING(ip))
+
+/* USER_DATA_UNDERRUN_INT */
+
+#define shift__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip) 5
+#define mask__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__PENDING(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT(ip, \
+	value__AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__PENDING(ip))
+
+/* CHL_STS_EMPTY_INT */
+
+#define shift__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip) 6
+#define mask__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT(ip, \
+	value__AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__PENDING(ip))
+
+/* CHL_STS_UNDERRUN_INT */
+
+#define shift__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip) 7
+#define mask__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT(ip, \
+	value__AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__PENDING(ip))
+
+/* I2S_FIFO_OVERRUN_INT */
+
+#define shift__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip) 8
+#define mask__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip))
+#define set__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT(ip, \
+	value__AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__PENDING(ip))
+
+/* RUN_STOP_INT */
+
+#define shift__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip) 16
+#define mask__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip))
+#define set__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__RUN_STOP_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__RUN_STOP_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__RUN_STOP_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip))
+#define set__AUD_SPDIFPC_ITS__RUN_STOP_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__RUN_STOP_INT(ip, \
+	value__AUD_SPDIFPC_ITS__RUN_STOP_INT__PENDING(ip))
+
+/* UNDERFLOW_INT */
+
+#define shift__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip) 17
+#define mask__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip))
+#define set__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__UNDERFLOW_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__UNDERFLOW_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__UNDERFLOW_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip))
+#define set__AUD_SPDIFPC_ITS__UNDERFLOW_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__UNDERFLOW_INT(ip, \
+	value__AUD_SPDIFPC_ITS__UNDERFLOW_INT__PENDING(ip))
+
+/* EODATABURST_INT */
+
+#define shift__AUD_SPDIFPC_ITS__EODATABURST_INT(ip) 18
+#define mask__AUD_SPDIFPC_ITS__EODATABURST_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__EODATABURST_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__EODATABURST_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__EODATABURST_INT(ip))
+#define set__AUD_SPDIFPC_ITS__EODATABURST_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__EODATABURST_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__EODATABURST_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__EODATABURST_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__EODATABURST_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__EODATABURST_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__EODATABURST_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__EODATABURST_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__EODATABURST_INT(ip))
+#define set__AUD_SPDIFPC_ITS__EODATABURST_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__EODATABURST_INT(ip, \
+	value__AUD_SPDIFPC_ITS__EODATABURST_INT__PENDING(ip))
+
+/* EOBLOCK_INT */
+
+#define shift__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip) 19
+#define mask__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip))
+#define set__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__EOBLOCK_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__EOBLOCK_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__EOBLOCK_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip))
+#define set__AUD_SPDIFPC_ITS__EOBLOCK_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__EOBLOCK_INT(ip, \
+	value__AUD_SPDIFPC_ITS__EOBLOCK_INT__PENDING(ip))
+
+/* LATENCY_INT */
+
+#define shift__AUD_SPDIFPC_ITS__LATENCY_INT(ip) 20
+#define mask__AUD_SPDIFPC_ITS__LATENCY_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__LATENCY_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__LATENCY_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__LATENCY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__LATENCY_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__LATENCY_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__LATENCY_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__LATENCY_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__LATENCY_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__LATENCY_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__LATENCY_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__LATENCY_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__LATENCY_INT(ip))
+#define set__AUD_SPDIFPC_ITS__LATENCY_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__LATENCY_INT(ip, \
+	value__AUD_SPDIFPC_ITS__LATENCY_INT__PENDING(ip))
+
+/* PD_DATA_BURST */
+
+#define shift__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip) 21
+#define mask__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip)) & \
+	mask__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip) << \
+	shift__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip)) << \
+	shift__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__PD_DATA_BURST__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__PD_DATA_BURST__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__PD_DATA_BURST__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_ITS__PD_DATA_BURST__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__PD_DATA_BURST(ip, \
+	value__AUD_SPDIFPC_ITS__PD_DATA_BURST__PENDING(ip))
+
+/* SAMPLES_READ_INT */
+
+#define shift__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip) 22
+#define mask__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip))
+#define set__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__SAMPLES_READ_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__SAMPLES_READ_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__SAMPLES_READ_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip))
+#define set__AUD_SPDIFPC_ITS__SAMPLES_READ_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__SAMPLES_READ_INT(ip, \
+	value__AUD_SPDIFPC_ITS__SAMPLES_READ_INT__PENDING(ip))
+
+/* PD_PAUSE_BURST_INT */
+
+#define shift__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip) 31
+#define mask__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip) 0x1
+#define get__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_ITS(ip)) >> \
+	shift__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip)) & \
+	mask__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip))
+#define set__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_ITS(ip)) & \
+	~(mask__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip) << \
+	shift__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip)) << \
+	shift__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_ITS(ip))
+
+#define value__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__PENDING(ip) 0x1
+#define mask__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__PENDING(ip) \
+	(value__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__PENDING(ip) << \
+	shift__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip))
+#define set__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__PENDING(ip) \
+	set__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT(ip, \
+	value__AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__PENDING(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_IT_CLR
+ */
+
+#define offset__AUD_SPDIFPC_IT_CLR(ip) 0x010
+#define get__AUD_SPDIFPC_IT_CLR(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+#define set__AUD_SPDIFPC_IT_CLR(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+/* INTERRUPT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip) 0
+#define mask__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__CLEAR(ip))
+
+/* SOFT_RESET_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip) 1
+#define mask__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__CLEAR(ip))
+
+/* VALIDITY_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip) 2
+#define mask__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__CLEAR(ip))
+
+/* VALIDITY_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip) 3
+#define mask__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip))) | (((value) \
+	& mask__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__CLEAR(ip))
+
+/* USER_DATA_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip) 4
+#define mask__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__CLEAR(ip))
+
+/* USER_DATA_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip) 5
+#define mask__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip))) | (((value) \
+	& mask__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define \
+	value__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__CLEAR(ip))
+
+/* CHL_STS_EMPTY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip) 6
+#define mask__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__CLEAR(ip))
+
+/* CHL_STS_UNDERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip) 7
+#define mask__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__CLEAR(ip))
+
+/* I2S_FIFO_OVERRUN_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip) 8
+#define mask__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__CLEAR(ip))
+
+/* RUN_STOP_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip) 16
+#define mask__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__CLEAR(ip))
+
+/* UNDERFLOW_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip) 17
+#define mask__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__CLEAR(ip))
+
+/* EODATABURST_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip) 18
+#define mask__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__CLEAR(ip))
+
+/* EOBLOCK_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip) 19
+#define mask__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__CLEAR(ip))
+
+/* LATENCY_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip) 20
+#define mask__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__CLEAR(ip))
+
+/* PD_DATA_BURST */
+
+#define shift__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip) 21
+#define mask__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST(ip, \
+	value__AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__CLEAR(ip))
+
+/* SAMPLES_READ_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip) 22
+#define mask__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__CLEAR(ip) 0x1
+#define mask__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__CLEAR(ip))
+
+/* PD_PAUSE_BURST_INT_EN */
+
+#define shift__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip) 31
+#define mask__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip) 0x1
+#define get__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) >> \
+	shift__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip)) & \
+	mask__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_IT_CLR(ip)) & \
+	~(mask__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip)) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip)), ip->base + \
+	offset__AUD_SPDIFPC_IT_CLR(ip))
+
+#define value__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__CLEAR(ip) \
+	0x1
+#define mask__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__CLEAR(ip) \
+	(value__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__CLEAR(ip) << \
+	shift__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip))
+#define set__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__CLEAR(ip) \
+	set__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN(ip, \
+	value__AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__CLEAR(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_VAL
+ */
+
+#define offset__AUD_SPDIFPC_VAL(ip) 0x100
+#define get__AUD_SPDIFPC_VAL(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_VAL(ip))
+#define set__AUD_SPDIFPC_VAL(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_VAL(ip))
+
+/* VALIDITY_BITS */
+
+#define shift__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip) 0
+#define mask__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip) 0xffffffff
+#define get__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_VAL(ip)) >> \
+	shift__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip)) & \
+	mask__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip))
+#define set__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_VAL(ip)) & \
+	~(mask__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip) << \
+	shift__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip)) << \
+	shift__AUD_SPDIFPC_VAL__VALIDITY_BITS(ip)), ip->base + \
+	offset__AUD_SPDIFPC_VAL(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_DATA
+ */
+
+#define offset__AUD_SPDIFPC_DATA(ip) 0x104
+#define get__AUD_SPDIFPC_DATA(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_DATA(ip))
+#define set__AUD_SPDIFPC_DATA(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_DATA(ip))
+
+/* USER_DATA_BITS */
+
+#define shift__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip) 0
+#define mask__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip) 0xffffffff
+#define get__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_DATA(ip)) >> \
+	shift__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip)) & \
+	mask__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip))
+#define set__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_DATA(ip)) & \
+	~(mask__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip) << \
+	shift__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip)) << \
+	shift__AUD_SPDIFPC_DATA__USER_DATA_BITS(ip)), ip->base + \
+	offset__AUD_SPDIFPC_DATA(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_CHA_STA
+ */
+
+#define offset__AUD_SPDIFPC_CHA_STA(ip, n) (0x108 + (n) * 4)
+#define get__AUD_SPDIFPC_CHA_STA(ip, n) readl(ip->base + \
+	offset__AUD_SPDIFPC_CHA_STA(ip, n))
+#define set__AUD_SPDIFPC_CHA_STA(ip, n, value) writel((value), \
+	ip->base + offset__AUD_SPDIFPC_CHA_STA(ip, n))
+
+/* CHA_STA */
+
+#define shift__AUD_SPDIFPC_CHA_STA__CHA_STA(ip) 0
+#define mask__AUD_SPDIFPC_CHA_STA__CHA_STA(ip) 0xffffffff
+#define get__AUD_SPDIFPC_CHA_STA__CHA_STA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CHA_STA(ip)) >> \
+	shift__AUD_SPDIFPC_CHA_STA__CHA_STA(ip)) & \
+	mask__AUD_SPDIFPC_CHA_STA__CHA_STA(ip))
+#define set__AUD_SPDIFPC_CHA_STA__CHA_STA(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CHA_STA(ip)) & \
+	~(mask__AUD_SPDIFPC_CHA_STA__CHA_STA(ip) << \
+	shift__AUD_SPDIFPC_CHA_STA__CHA_STA(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CHA_STA__CHA_STA(ip)) << \
+	shift__AUD_SPDIFPC_CHA_STA__CHA_STA(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CHA_STA(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_CTRL
+ */
+
+#define offset__AUD_SPDIFPC_CTRL(ip) 0x200
+#define get__AUD_SPDIFPC_CTRL(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+#define set__AUD_SPDIFPC_CTRL(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+/* OPERATION */
+
+#define shift__AUD_SPDIFPC_CTRL__OPERATION(ip) 0
+#define mask__AUD_SPDIFPC_CTRL__OPERATION(ip) 0x7
+#define get__AUD_SPDIFPC_CTRL__OPERATION(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip)) & \
+	mask__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__OPERATION(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__OPERATION(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__OPERATION__OFF(ip) 0x0
+#define mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(ip) \
+	(value__AUD_SPDIFPC_CTRL__OPERATION__OFF(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION__OFF(ip) \
+	set__AUD_SPDIFPC_CTRL__OPERATION(ip, \
+	value__AUD_SPDIFPC_CTRL__OPERATION__OFF(ip))
+
+#define value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PCM_NULL(ip) 0x1
+#define mask__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PCM_NULL(ip) \
+	(value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PCM_NULL(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PCM_NULL(ip) \
+	set__AUD_SPDIFPC_CTRL__OPERATION(ip, \
+	value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PCM_NULL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PAUSE_BURSTS(ip) 0x2
+#define mask__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PAUSE_BURSTS(ip) \
+	(value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PAUSE_BURSTS(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PAUSE_BURSTS(ip) \
+	set__AUD_SPDIFPC_CTRL__OPERATION(ip, \
+	value__AUD_SPDIFPC_CTRL__OPERATION__MUTE_PAUSE_BURSTS(ip))
+
+#define value__AUD_SPDIFPC_CTRL__OPERATION__PCM(ip) 0x3
+#define mask__AUD_SPDIFPC_CTRL__OPERATION__PCM(ip) \
+	(value__AUD_SPDIFPC_CTRL__OPERATION__PCM(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION__PCM(ip) \
+	set__AUD_SPDIFPC_CTRL__OPERATION(ip, \
+	value__AUD_SPDIFPC_CTRL__OPERATION__PCM(ip))
+
+#define value__AUD_SPDIFPC_CTRL__OPERATION__ENCODED(ip) 0x4
+#define mask__AUD_SPDIFPC_CTRL__OPERATION__ENCODED(ip) \
+	(value__AUD_SPDIFPC_CTRL__OPERATION__ENCODED(ip) << \
+	shift__AUD_SPDIFPC_CTRL__OPERATION(ip))
+#define set__AUD_SPDIFPC_CTRL__OPERATION__ENCODED(ip) \
+	set__AUD_SPDIFPC_CTRL__OPERATION(ip, \
+	value__AUD_SPDIFPC_CTRL__OPERATION__ENCODED(ip))
+
+/* IDLE_STATE */
+
+#define shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip) 3
+#define mask__AUD_SPDIFPC_CTRL__IDLE_STATE(ip) 0x1
+#define get__AUD_SPDIFPC_CTRL__IDLE_STATE(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> \
+	shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip)) & \
+	mask__AUD_SPDIFPC_CTRL__IDLE_STATE(ip))
+#define set__AUD_SPDIFPC_CTRL__IDLE_STATE(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__IDLE_STATE(ip) << \
+	shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__IDLE_STATE(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__IDLE_STATE__NORMAL(ip) 0x0
+#define mask__AUD_SPDIFPC_CTRL__IDLE_STATE__NORMAL(ip) \
+	(value__AUD_SPDIFPC_CTRL__IDLE_STATE__NORMAL(ip) << \
+	shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip))
+#define set__AUD_SPDIFPC_CTRL__IDLE_STATE__NORMAL(ip) \
+	set__AUD_SPDIFPC_CTRL__IDLE_STATE(ip, \
+	value__AUD_SPDIFPC_CTRL__IDLE_STATE__NORMAL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__IDLE_STATE__IDLE(ip) 0x1
+#define mask__AUD_SPDIFPC_CTRL__IDLE_STATE__IDLE(ip) \
+	(value__AUD_SPDIFPC_CTRL__IDLE_STATE__IDLE(ip) << \
+	shift__AUD_SPDIFPC_CTRL__IDLE_STATE(ip))
+#define set__AUD_SPDIFPC_CTRL__IDLE_STATE__IDLE(ip) \
+	set__AUD_SPDIFPC_CTRL__IDLE_STATE(ip, \
+	value__AUD_SPDIFPC_CTRL__IDLE_STATE__IDLE(ip))
+
+/* ROUNDING */
+
+#define shift__AUD_SPDIFPC_CTRL__ROUNDING(ip) 4
+#define mask__AUD_SPDIFPC_CTRL__ROUNDING(ip) 0x1
+#define get__AUD_SPDIFPC_CTRL__ROUNDING(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> \
+	shift__AUD_SPDIFPC_CTRL__ROUNDING(ip)) & \
+	mask__AUD_SPDIFPC_CTRL__ROUNDING(ip))
+#define set__AUD_SPDIFPC_CTRL__ROUNDING(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__ROUNDING(ip) << \
+	shift__AUD_SPDIFPC_CTRL__ROUNDING(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__ROUNDING(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__ROUNDING(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(ip) 0x0
+#define mask__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(ip) \
+	(value__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(ip) << \
+	shift__AUD_SPDIFPC_CTRL__ROUNDING(ip))
+#define set__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(ip) \
+	set__AUD_SPDIFPC_CTRL__ROUNDING(ip, \
+	value__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(ip))
+
+#define value__AUD_SPDIFPC_CTRL__ROUNDING__16_BITS_ROUNDING(ip) 0x1
+#define mask__AUD_SPDIFPC_CTRL__ROUNDING__16_BITS_ROUNDING(ip) \
+	(value__AUD_SPDIFPC_CTRL__ROUNDING__16_BITS_ROUNDING(ip) << \
+	shift__AUD_SPDIFPC_CTRL__ROUNDING(ip))
+#define set__AUD_SPDIFPC_CTRL__ROUNDING__16_BITS_ROUNDING(ip) \
+	set__AUD_SPDIFPC_CTRL__ROUNDING(ip, \
+	value__AUD_SPDIFPC_CTRL__ROUNDING__16_BITS_ROUNDING(ip))
+
+/* DIVIDER */
+
+#define shift__AUD_SPDIFPC_CTRL__DIVIDER(ip) 5
+#define mask__AUD_SPDIFPC_CTRL__DIVIDER(ip) 0xff
+#define get__AUD_SPDIFPC_CTRL__DIVIDER(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> shift__AUD_SPDIFPC_CTRL__DIVIDER(ip)) \
+	& mask__AUD_SPDIFPC_CTRL__DIVIDER(ip))
+#define set__AUD_SPDIFPC_CTRL__DIVIDER(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__DIVIDER(ip) << \
+	shift__AUD_SPDIFPC_CTRL__DIVIDER(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__DIVIDER(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__DIVIDER(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+/* STUFFING */
+
+#define shift__AUD_SPDIFPC_CTRL__STUFFING(ip) 14
+#define mask__AUD_SPDIFPC_CTRL__STUFFING(ip) 0x1
+#define get__AUD_SPDIFPC_CTRL__STUFFING(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> \
+	shift__AUD_SPDIFPC_CTRL__STUFFING(ip)) & \
+	mask__AUD_SPDIFPC_CTRL__STUFFING(ip))
+#define set__AUD_SPDIFPC_CTRL__STUFFING(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__STUFFING(ip) << \
+	shift__AUD_SPDIFPC_CTRL__STUFFING(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__STUFFING(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__STUFFING(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+#define value__AUD_SPDIFPC_CTRL__STUFFING__SOFTWARE(ip) 0x0
+#define mask__AUD_SPDIFPC_CTRL__STUFFING__SOFTWARE(ip) \
+	(value__AUD_SPDIFPC_CTRL__STUFFING__SOFTWARE(ip) << \
+	shift__AUD_SPDIFPC_CTRL__STUFFING(ip))
+#define set__AUD_SPDIFPC_CTRL__STUFFING__SOFTWARE(ip) \
+	set__AUD_SPDIFPC_CTRL__STUFFING(ip, \
+	value__AUD_SPDIFPC_CTRL__STUFFING__SOFTWARE(ip))
+
+#define value__AUD_SPDIFPC_CTRL__STUFFING__HARDWARE(ip) 0x1
+#define mask__AUD_SPDIFPC_CTRL__STUFFING__HARDWARE(ip) \
+	(value__AUD_SPDIFPC_CTRL__STUFFING__HARDWARE(ip) << \
+	shift__AUD_SPDIFPC_CTRL__STUFFING(ip))
+#define set__AUD_SPDIFPC_CTRL__STUFFING__HARDWARE(ip) \
+	set__AUD_SPDIFPC_CTRL__STUFFING(ip, \
+	value__AUD_SPDIFPC_CTRL__STUFFING__HARDWARE(ip))
+
+/* NO_SAMPLES */
+
+#define shift__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip) 15
+#define mask__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip) 0x1ffff
+#define get__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip)) >> \
+	shift__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip)) & \
+	mask__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip))
+#define set__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CTRL(ip)) & \
+	~(mask__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip) << \
+	shift__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip)) << \
+	shift__AUD_SPDIFPC_CTRL__NO_SAMPLES(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CTRL(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_SPDIFSTA
+ */
+
+#define offset__AUD_SPDIFPC_SPDIFSTA(ip) 0x204
+#define get__AUD_SPDIFPC_SPDIFSTA(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA(ip, value) writel((value), ip->base \
+	+ offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+/* RUN_STOP */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip) 0
+#define mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__STOPPED(ip) 0x0
+#define mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__STOPPED(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__STOPPED(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__STOPPED(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__STOPPED(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__RUNNING(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__RUNNING(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__RUNNING(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__RUNNING(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__RUN_STOP(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__RUN_STOP__RUNNING(ip))
+
+/* UNDERFLOW */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip) 1
+#define mask__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__DETECTED(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__DETECTED(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__DETECTED(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__DETECTED(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__DETECTED(ip))
+
+/* EODATABURST */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip) 2
+#define mask__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__EODATABURST__END(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__EODATABURST__END(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__EODATABURST__END(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__EODATABURST__END(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__EODATABURST(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__EODATABURST__END(ip))
+
+/* EOBLOCK */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip) 3
+#define mask__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__EOBLOCK__END(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__EOBLOCK__END(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__EOBLOCK__END(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__EOBLOCK__END(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__EOBLOCK(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__EOBLOCK__END(ip))
+
+/* LATENCY */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip) 4
+#define mask__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define \
+	value__AUD_SPDIFPC_SPDIFSTA__LATENCY__END_OF_LATENCY_COUNTER(ip) 0x1
+#define \
+	mask__AUD_SPDIFPC_SPDIFSTA__LATENCY__END_OF_LATENCY_COUNTER(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__LATENCY__END_OF_LATENCY_COUNTER(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__LATENCY__END_OF_LATENCY_COUNTER(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__LATENCY(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__LATENCY__END_OF_LATENCY_COUNTER(ip))
+
+/* PD_DATABURST */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip) 5
+#define mask__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SENT(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SENT(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SENT(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SENT(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SENT(ip))
+
+/* AUDIO_READ */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip) 6
+#define mask__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__DONE(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__DONE(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__DONE(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__DONE(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__DONE(ip))
+
+/* PA_C_BIT_NUMBER */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip) 7
+#define mask__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip) 0xff
+#define get__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip) \
+	((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+/* PD_PAUSEBURST */
+
+#define shift__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip) 5
+#define mask__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip) 0x1
+#define get__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_SPDIFSTA(ip)) >> \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip)) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SPDIFSTA(ip)) & \
+	~(mask__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip)) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SPDIFSTA(ip))
+
+#define value__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SENT(ip) 0x1
+#define mask__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SENT(ip) \
+	(value__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SENT(ip) << \
+	shift__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip))
+#define set__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SENT(ip) \
+	set__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST(ip, \
+	value__AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SENT(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_PAUSE
+ */
+
+#define offset__AUD_SPDIFPC_PAUSE(ip) 0x208
+#define get__AUD_SPDIFPC_PAUSE(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip))
+#define set__AUD_SPDIFPC_PAUSE(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip))
+
+/* PAUSE_LENGTH */
+
+#define shift__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip) 0
+#define mask__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip) 0xffff
+#define get__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip)) >> \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip)) & \
+	mask__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip))
+#define set__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_PAUSE(ip)) & \
+	~(mask__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip) << \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip)) << \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LENGTH(ip)), ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip))
+
+/* PAUSE_LAT */
+
+#define shift__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip) 16
+#define mask__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip) 0xffff
+#define get__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip)) >> \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip)) & \
+	mask__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip))
+#define set__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_PAUSE(ip)) & \
+	~(mask__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip) << \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip)) << \
+	shift__AUD_SPDIFPC_PAUSE__PAUSE_LAT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_PAUSE(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_DATA_BURST
+ */
+
+#define offset__AUD_SPDIFPC_DATA_BURST(ip) 0x20c
+#define get__AUD_SPDIFPC_DATA_BURST(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_DATA_BURST(ip))
+#define set__AUD_SPDIFPC_DATA_BURST(ip, value) writel((value), \
+	ip->base + offset__AUD_SPDIFPC_DATA_BURST(ip))
+
+/* DATA_BURST */
+
+#define shift__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip) 0
+#define mask__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip) 0xffff
+#define get__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_DATA_BURST(ip)) >> \
+	shift__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip)) & \
+	mask__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip))
+#define set__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_DATA_BURST(ip)) & \
+	~(mask__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip) << \
+	shift__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip)) << \
+	shift__AUD_SPDIFPC_DATA_BURST__DATA_BURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_DATA_BURST(ip))
+
+/* PAUSE_BURST */
+
+#define shift__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip) 16
+#define mask__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip) 0xffff
+#define get__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip) ((readl(ip->base \
+	+ offset__AUD_SPDIFPC_DATA_BURST(ip)) >> \
+	shift__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip)) & \
+	mask__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip))
+#define set__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_DATA_BURST(ip)) & \
+	~(mask__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip) << \
+	shift__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip)) << \
+	shift__AUD_SPDIFPC_DATA_BURST__PAUSE_BURST(ip)), ip->base + \
+	offset__AUD_SPDIFPC_DATA_BURST(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_PA_PB
+ */
+
+#define offset__AUD_SPDIFPC_PA_PB(ip) 0x210
+#define get__AUD_SPDIFPC_PA_PB(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip))
+#define set__AUD_SPDIFPC_PA_PB(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip))
+
+/* PB */
+
+#define shift__AUD_SPDIFPC_PA_PB__PB(ip) 0
+#define mask__AUD_SPDIFPC_PA_PB__PB(ip) 0xffff
+#define get__AUD_SPDIFPC_PA_PB__PB(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip)) >> shift__AUD_SPDIFPC_PA_PB__PB(ip)) & \
+	mask__AUD_SPDIFPC_PA_PB__PB(ip))
+#define set__AUD_SPDIFPC_PA_PB__PB(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip)) & ~(mask__AUD_SPDIFPC_PA_PB__PB(ip) << \
+	shift__AUD_SPDIFPC_PA_PB__PB(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PA_PB__PB(ip)) << shift__AUD_SPDIFPC_PA_PB__PB(ip)), \
+	ip->base + offset__AUD_SPDIFPC_PA_PB(ip))
+
+/* PA */
+
+#define shift__AUD_SPDIFPC_PA_PB__PA(ip) 16
+#define mask__AUD_SPDIFPC_PA_PB__PA(ip) 0xffff
+#define get__AUD_SPDIFPC_PA_PB__PA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip)) >> shift__AUD_SPDIFPC_PA_PB__PA(ip)) & \
+	mask__AUD_SPDIFPC_PA_PB__PA(ip))
+#define set__AUD_SPDIFPC_PA_PB__PA(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIFPC_PA_PB(ip)) & ~(mask__AUD_SPDIFPC_PA_PB__PA(ip) << \
+	shift__AUD_SPDIFPC_PA_PB__PA(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PA_PB__PA(ip)) << shift__AUD_SPDIFPC_PA_PB__PA(ip)), \
+	ip->base + offset__AUD_SPDIFPC_PA_PB(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_PC_PD
+ */
+
+#define offset__AUD_SPDIFPC_PC_PD(ip) 0x214
+#define get__AUD_SPDIFPC_PC_PD(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip))
+#define set__AUD_SPDIFPC_PC_PD(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip))
+
+/* PD */
+
+#define shift__AUD_SPDIFPC_PC_PD__PD(ip) 0
+#define mask__AUD_SPDIFPC_PC_PD__PD(ip) 0xffff
+#define get__AUD_SPDIFPC_PC_PD__PD(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip)) >> shift__AUD_SPDIFPC_PC_PD__PD(ip)) & \
+	mask__AUD_SPDIFPC_PC_PD__PD(ip))
+#define set__AUD_SPDIFPC_PC_PD__PD(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip)) & ~(mask__AUD_SPDIFPC_PC_PD__PD(ip) << \
+	shift__AUD_SPDIFPC_PC_PD__PD(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PC_PD__PD(ip)) << shift__AUD_SPDIFPC_PC_PD__PD(ip)), \
+	ip->base + offset__AUD_SPDIFPC_PC_PD(ip))
+
+/* PC */
+
+#define shift__AUD_SPDIFPC_PC_PD__PC(ip) 16
+#define mask__AUD_SPDIFPC_PC_PD__PC(ip) 0xffff
+#define get__AUD_SPDIFPC_PC_PD__PC(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip)) >> shift__AUD_SPDIFPC_PC_PD__PC(ip)) & \
+	mask__AUD_SPDIFPC_PC_PD__PC(ip))
+#define set__AUD_SPDIFPC_PC_PD__PC(ip, value) writel((readl(ip->base + \
+	offset__AUD_SPDIFPC_PC_PD(ip)) & ~(mask__AUD_SPDIFPC_PC_PD__PC(ip) << \
+	shift__AUD_SPDIFPC_PC_PD__PC(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_PC_PD__PC(ip)) << shift__AUD_SPDIFPC_PC_PD__PC(ip)), \
+	ip->base + offset__AUD_SPDIFPC_PC_PD(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_CL1
+ */
+
+#define offset__AUD_SPDIFPC_CL1(ip) 0x218
+#define get__AUD_SPDIFPC_CL1(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_CL1(ip))
+#define set__AUD_SPDIFPC_CL1(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_CL1(ip))
+
+/* CHANNEL_STATUS */
+
+#define shift__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip) 0
+#define mask__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip) 0xffffffff
+#define get__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CL1(ip)) >> \
+	shift__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip)) & \
+	mask__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip))
+#define set__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_CL1(ip)) & \
+	~(mask__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip) << \
+	shift__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip)) << \
+	shift__AUD_SPDIFPC_CL1__CHANNEL_STATUS(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CL1(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_CR1
+ */
+
+#define offset__AUD_SPDIFPC_CR1(ip) 0x21c
+#define get__AUD_SPDIFPC_CR1(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_CR1(ip))
+#define set__AUD_SPDIFPC_CR1(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_CR1(ip))
+
+/* CH_STA */
+
+#define shift__AUD_SPDIFPC_CR1__CH_STA(ip) 0
+#define mask__AUD_SPDIFPC_CR1__CH_STA(ip) 0xffffffff
+#define get__AUD_SPDIFPC_CR1__CH_STA(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_CR1(ip)) >> shift__AUD_SPDIFPC_CR1__CH_STA(ip)) & \
+	mask__AUD_SPDIFPC_CR1__CH_STA(ip))
+#define set__AUD_SPDIFPC_CR1__CH_STA(ip, value) writel((readl(ip->base \
+	+ offset__AUD_SPDIFPC_CR1(ip)) & ~(mask__AUD_SPDIFPC_CR1__CH_STA(ip) \
+	<< shift__AUD_SPDIFPC_CR1__CH_STA(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_CR1__CH_STA(ip)) << \
+	shift__AUD_SPDIFPC_CR1__CH_STA(ip)), ip->base + \
+	offset__AUD_SPDIFPC_CR1(ip))
+
+
+
+/*
+ * AUD_SPDIFPC_SUV
+ */
+
+#define offset__AUD_SPDIFPC_SUV(ip) 0x220
+#define get__AUD_SPDIFPC_SUV(ip) readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+#define set__AUD_SPDIFPC_SUV(ip, value) writel((value), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* CH_STA_LEFT */
+
+#define shift__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip) 0
+#define mask__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip) 0xf
+#define get__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> \
+	shift__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip)) & \
+	mask__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip))
+#define set__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip) << \
+	shift__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__CH_STA_LEFT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* CH_STA_RIGHT */
+
+#define shift__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip) 8
+#define mask__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip) 0xf
+#define get__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> \
+	shift__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip)) & \
+	mask__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip))
+#define set__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip) << \
+	shift__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__CH_STA_RIGHT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* DATA_LEFT */
+
+#define shift__AUD_SPDIFPC_SUV__DATA_LEFT(ip) 16
+#define mask__AUD_SPDIFPC_SUV__DATA_LEFT(ip) 0x1
+#define get__AUD_SPDIFPC_SUV__DATA_LEFT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> shift__AUD_SPDIFPC_SUV__DATA_LEFT(ip)) \
+	& mask__AUD_SPDIFPC_SUV__DATA_LEFT(ip))
+#define set__AUD_SPDIFPC_SUV__DATA_LEFT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__DATA_LEFT(ip) << \
+	shift__AUD_SPDIFPC_SUV__DATA_LEFT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__DATA_LEFT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__DATA_LEFT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* DATA_RIGHT */
+
+#define shift__AUD_SPDIFPC_SUV__DATA_RIGHT(ip) 17
+#define mask__AUD_SPDIFPC_SUV__DATA_RIGHT(ip) 0x1
+#define get__AUD_SPDIFPC_SUV__DATA_RIGHT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> \
+	shift__AUD_SPDIFPC_SUV__DATA_RIGHT(ip)) & \
+	mask__AUD_SPDIFPC_SUV__DATA_RIGHT(ip))
+#define set__AUD_SPDIFPC_SUV__DATA_RIGHT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__DATA_RIGHT(ip) << \
+	shift__AUD_SPDIFPC_SUV__DATA_RIGHT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__DATA_RIGHT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__DATA_RIGHT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* VAL_LEFT */
+
+#define shift__AUD_SPDIFPC_SUV__VAL_LEFT(ip) 18
+#define mask__AUD_SPDIFPC_SUV__VAL_LEFT(ip) 0x1
+#define get__AUD_SPDIFPC_SUV__VAL_LEFT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> shift__AUD_SPDIFPC_SUV__VAL_LEFT(ip)) \
+	& mask__AUD_SPDIFPC_SUV__VAL_LEFT(ip))
+#define set__AUD_SPDIFPC_SUV__VAL_LEFT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__VAL_LEFT(ip) << \
+	shift__AUD_SPDIFPC_SUV__VAL_LEFT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__VAL_LEFT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__VAL_LEFT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+/* VAL_RIGHT */
+
+#define shift__AUD_SPDIFPC_SUV__VAL_RIGHT(ip) 19
+#define mask__AUD_SPDIFPC_SUV__VAL_RIGHT(ip) 0x1
+#define get__AUD_SPDIFPC_SUV__VAL_RIGHT(ip) ((readl(ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip)) >> shift__AUD_SPDIFPC_SUV__VAL_RIGHT(ip)) \
+	& mask__AUD_SPDIFPC_SUV__VAL_RIGHT(ip))
+#define set__AUD_SPDIFPC_SUV__VAL_RIGHT(ip, value) \
+	writel((readl(ip->base + offset__AUD_SPDIFPC_SUV(ip)) & \
+	~(mask__AUD_SPDIFPC_SUV__VAL_RIGHT(ip) << \
+	shift__AUD_SPDIFPC_SUV__VAL_RIGHT(ip))) | (((value) & \
+	mask__AUD_SPDIFPC_SUV__VAL_RIGHT(ip)) << \
+	shift__AUD_SPDIFPC_SUV__VAL_RIGHT(ip)), ip->base + \
+	offset__AUD_SPDIFPC_SUV(ip))
+
+#endif
diff --git a/sound/stm/reg_audcfg_adac.h b/sound/stm/reg_audcfg_adac.h
new file mode 100644
index 0000000..0be4ba9
--- /dev/null
+++ b/sound/stm/reg_audcfg_adac.h
@@ -0,0 +1,206 @@
+#ifndef __SND_STM_AUDCFG_ADAC_H
+#define __SND_STM_AUDCFG_ADAC_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUDCFG_ADAC__90_1_0 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUDCFG_ADAC__90_1_5_0 2
+
+/* 7200 1.0 */
+#define ver__AUDCFG_ADAC__65_3_0_0 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUDCFG_ADAC__65_3_2_a 4
+
+
+
+/*
+ * AUDCFG_ADAC_CTRL
+ */
+
+#define offset__AUDCFG_ADAC_CTRL(ip) 0x00
+#define get__AUDCFG_ADAC_CTRL(ip) readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+#define set__AUDCFG_ADAC_CTRL(ip, value) writel((value), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+/* NRST */
+
+#define shift__AUDCFG_ADAC_CTRL__NRST(ip) 0
+#define mask__AUDCFG_ADAC_CTRL__NRST(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__NRST(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__NRST(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__NRST(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__NRST(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__NRST(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NRST__RESET(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__NRST__RESET(ip) \
+	(value__AUDCFG_ADAC_CTRL__NRST__RESET(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST__RESET(ip) \
+	set__AUDCFG_ADAC_CTRL__NRST(ip, \
+	value__AUDCFG_ADAC_CTRL__NRST__RESET(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__NRST(ip, \
+	value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip))
+
+/* MODE */
+
+#define shift__AUDCFG_ADAC_CTRL__MODE(ip) 1
+#define mask__AUDCFG_ADAC_CTRL__MODE(ip) 0x3
+#define get__AUDCFG_ADAC_CTRL__MODE(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__MODE(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__MODE(ip))
+#define set__AUDCFG_ADAC_CTRL__MODE(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__MODE(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__MODE(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__MODE(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__MODE(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) \
+	(value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) << \
+	shift__AUDCFG_ADAC_CTRL__MODE(ip))
+#define set__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) \
+	set__AUDCFG_ADAC_CTRL__MODE(ip, \
+	value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip))
+
+/* NSB */
+
+#define shift__AUDCFG_ADAC_CTRL__NSB(ip) 3
+#define mask__AUDCFG_ADAC_CTRL__NSB(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__NSB(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__NSB(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__NSB(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__NSB(ip)) << shift__AUDCFG_ADAC_CTRL__NSB(ip)), \
+	ip->base + offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__NSB(ip, \
+	value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__NSB(ip, \
+	value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip))
+
+/* SOFTMUTE */
+
+#define shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) 4
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_ADAC_CTRL(ip)) & \
+	~(mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, \
+	value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) \
+	(value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) \
+	set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, \
+	value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip))
+
+/* PDNANA */
+
+#define shift__AUDCFG_ADAC_CTRL__PDNANA(ip) 5
+#define mask__AUDCFG_ADAC_CTRL__PDNANA(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__PDNANA(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__PDNANA(ip)) \
+	& mask__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_ADAC_CTRL(ip)) & \
+	~(mask__AUDCFG_ADAC_CTRL__PDNANA(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__PDNANA(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNANA(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNANA(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip))
+
+/* PDNBG */
+
+#define shift__AUDCFG_ADAC_CTRL__PDNBG(ip) 6
+#define mask__AUDCFG_ADAC_CTRL__PDNBG(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__PDNBG(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__PDNBG(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__PDNBG(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__PDNBG(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__PDNBG(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNBG(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNBG(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip))
+
+#endif
diff --git a/sound/stm/reg_audcfg_fsyn.h b/sound/stm/reg_audcfg_fsyn.h
new file mode 100644
index 0000000..dc08200
--- /dev/null
+++ b/sound/stm/reg_audcfg_fsyn.h
@@ -0,0 +1,446 @@
+#ifndef __SND_STM_AUDCFG_FSYN_H
+#define __SND_STM_AUDCFG_FSYN_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUDCFG_FSYN__90_1_0_3 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUDCFG_FSYN__90_2_3 2
+
+/* 7200 1.0 */
+#define ver__AUDCFG_FSYN__65_2_1_2 3
+
+/* 7111 */
+#define ver__AUDCFG_FSYN__65_3_1 4
+
+/* 7200 2.0 */
+#define ver__AUDCFG_FSYN__65_3_3 5
+
+
+
+/*
+ * AUDCFG_FSYN_CFG
+ */
+
+#define offset__AUDCFG_FSYN_CFG(ip) 0x00
+#define get__AUDCFG_FSYN_CFG(ip) readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+#define set__AUDCFG_FSYN_CFG(ip, value) writel((value), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+/* RSTP */
+
+#define shift__AUDCFG_FSYN_CFG__RSTP(ip) 0
+#define mask__AUDCFG_FSYN_CFG__RSTP(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__RSTP(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__RSTP(ip)) & \
+	mask__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__RSTP(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__RSTP(ip)) << shift__AUDCFG_FSYN_CFG__RSTP(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) \
+	(value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) \
+	set__AUDCFG_FSYN_CFG__RSTP(ip, \
+	value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip))
+
+#define value__AUDCFG_FSYN_CFG__RSTP__RESET(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__RSTP__RESET(ip) \
+	(value__AUDCFG_FSYN_CFG__RSTP__RESET(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP__RESET(ip) \
+	set__AUDCFG_FSYN_CFG__RSTP(ip, \
+	value__AUDCFG_FSYN_CFG__RSTP__RESET(ip))
+
+/* PCM_CLK_SEL */
+
+#define shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) 2
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) 0xf
+#define get__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)) & \
+	mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_CFG(ip)) & \
+	~(mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_3 ? (0 << n) : (1 << n))))
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) \
+	(value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) \
+	set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n))
+
+#define value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_3 ? (1 << n) : (0 << n))))
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) \
+	(value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) \
+	set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n))
+
+/* FS_EN */
+
+#define shift__AUDCFG_FSYN_CFG__FS_EN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 6 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 ? \
+	-1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 6 : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 0x7 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 0xf : -1)))
+#define get__AUDCFG_FSYN_CFG__FS_EN(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__FS_EN(ip)) & \
+	mask__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__FS_EN(ip) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__FS_EN(ip)) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	(0 << n) : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) \
+	(value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) \
+	set__AUDCFG_FSYN_CFG__FS_EN(ip, \
+	value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n))
+
+#define value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	(1 << n) : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) \
+	(value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) \
+	set__AUDCFG_FSYN_CFG__FS_EN(ip, \
+	value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n))
+
+/* NSB */
+
+#define shift__AUDCFG_FSYN_CFG__NSB(ip) 10
+#define mask__AUDCFG_FSYN_CFG__NSB(ip) 0xf
+#define get__AUDCFG_FSYN_CFG__NSB(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NSB(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NSB(ip) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NSB(ip)) << shift__AUDCFG_FSYN_CFG__NSB(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) (0 << n)
+#define mask__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) \
+	(value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) \
+	set__AUDCFG_FSYN_CFG__NSB(ip, value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, \
+	n))
+
+#define value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) (1 << n)
+#define mask__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) \
+	(value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) \
+	set__AUDCFG_FSYN_CFG__NSB(ip, value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, \
+	n))
+
+/* NPDA */
+
+#define shift__AUDCFG_FSYN_CFG__NPDA(ip) 14
+#define mask__AUDCFG_FSYN_CFG__NPDA(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__NPDA(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NPDA(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NPDA(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NPDA(ip)) << shift__AUDCFG_FSYN_CFG__NPDA(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) \
+	(value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) \
+	set__AUDCFG_FSYN_CFG__NPDA(ip, \
+	value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip))
+
+#define value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) \
+	(value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) \
+	set__AUDCFG_FSYN_CFG__NPDA(ip, \
+	value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip))
+
+/* NDIV */
+
+#define shift__AUDCFG_FSYN_CFG__NDIV(ip) 15
+#define mask__AUDCFG_FSYN_CFG__NDIV(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__NDIV(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NDIV(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NDIV(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NDIV(ip)) << shift__AUDCFG_FSYN_CFG__NDIV(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) \
+	(value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) \
+	set__AUDCFG_FSYN_CFG__NDIV(ip, \
+	value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip))
+
+#define value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) \
+	(value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) \
+	set__AUDCFG_FSYN_CFG__NDIV(ip, \
+	value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip))
+
+/* BW_SEL */
+
+#define shift__AUDCFG_FSYN_CFG__BW_SEL(ip) 16
+#define mask__AUDCFG_FSYN_CFG__BW_SEL(ip) 0x3
+#define get__AUDCFG_FSYN_CFG__BW_SEL(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__BW_SEL(ip)) & \
+	mask__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__BW_SEL(ip) \
+	<< shift__AUDCFG_FSYN_CFG__BW_SEL(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__BW_SEL(ip)) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) 0x2
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) 0x3
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip))
+
+/* REF_CLK_IN */
+
+#define shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 23 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? 24 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 23 : 24)))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 0x3 : 0x1)))
+#define get__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)) & \
+	mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_CFG(ip)) & \
+	~(mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	0x0 : -1))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) (ip->ver \
+	< ver__AUDCFG_FSYN__65_3_1 ? 0x0 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 \
+	? 0x1 : 0x0))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	0x2 : 0x1))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip))
+
+
+
+/*
+ * AUDCFG_FSYN_MD
+ */
+
+#define offset__AUDCFG_FSYN_MD(ip, n) ((n + 1) * 0x10 + 0x00)
+#define get__AUDCFG_FSYN_MD(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n))
+#define set__AUDCFG_FSYN_MD(ip, n, value) writel((value), ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n))
+
+/* MD */
+
+#define shift__AUDCFG_FSYN_MD__MD(ip, n) 0
+#define mask__AUDCFG_FSYN_MD__MD(ip, n) 0x1f
+#define get__AUDCFG_FSYN_MD__MD(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n)) >> shift__AUDCFG_FSYN_MD__MD(ip, n)) & \
+	mask__AUDCFG_FSYN_MD__MD(ip, n))
+#define set__AUDCFG_FSYN_MD__MD(ip, n, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n)) & ~(mask__AUDCFG_FSYN_MD__MD(ip, n) << \
+	shift__AUDCFG_FSYN_MD__MD(ip, n))) | (((value) & \
+	mask__AUDCFG_FSYN_MD__MD(ip, n)) << shift__AUDCFG_FSYN_MD__MD(ip, n)), \
+	ip->base + offset__AUDCFG_FSYN_MD(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_PE
+ */
+
+#define offset__AUDCFG_FSYN_PE(ip, n) ((n + 1) * 0x10 + 0x04)
+#define get__AUDCFG_FSYN_PE(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n))
+#define set__AUDCFG_FSYN_PE(ip, n, value) writel((value), ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n))
+
+/* PE */
+
+#define shift__AUDCFG_FSYN_PE__PE(ip, n) 0
+#define mask__AUDCFG_FSYN_PE__PE(ip, n) 0xffff
+#define get__AUDCFG_FSYN_PE__PE(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n)) >> shift__AUDCFG_FSYN_PE__PE(ip, n)) & \
+	mask__AUDCFG_FSYN_PE__PE(ip, n))
+#define set__AUDCFG_FSYN_PE__PE(ip, n, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n)) & ~(mask__AUDCFG_FSYN_PE__PE(ip, n) << \
+	shift__AUDCFG_FSYN_PE__PE(ip, n))) | (((value) & \
+	mask__AUDCFG_FSYN_PE__PE(ip, n)) << shift__AUDCFG_FSYN_PE__PE(ip, n)), \
+	ip->base + offset__AUDCFG_FSYN_PE(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_SDIV
+ */
+
+#define offset__AUDCFG_FSYN_SDIV(ip, n) ((n + 1) * 0x10 + 0x08)
+#define get__AUDCFG_FSYN_SDIV(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+#define set__AUDCFG_FSYN_SDIV(ip, n, value) writel((value), ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+
+/* SDIV */
+
+#define shift__AUDCFG_FSYN_SDIV__SDIV(ip, n) 0
+#define mask__AUDCFG_FSYN_SDIV__SDIV(ip, n) 0x7
+#define get__AUDCFG_FSYN_SDIV__SDIV(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n)) >> shift__AUDCFG_FSYN_SDIV__SDIV(ip, \
+	n)) & mask__AUDCFG_FSYN_SDIV__SDIV(ip, n))
+#define set__AUDCFG_FSYN_SDIV__SDIV(ip, n, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_SDIV(ip, n)) & \
+	~(mask__AUDCFG_FSYN_SDIV__SDIV(ip, n) << \
+	shift__AUDCFG_FSYN_SDIV__SDIV(ip, n))) | (((value) & \
+	mask__AUDCFG_FSYN_SDIV__SDIV(ip, n)) << \
+	shift__AUDCFG_FSYN_SDIV__SDIV(ip, n)), ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_PROGEN
+ */
+
+#define offset__AUDCFG_FSYN_PROGEN(ip, n) ((n + 1) * 0x10 + 0x0c)
+#define get__AUDCFG_FSYN_PROGEN(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n))
+#define set__AUDCFG_FSYN_PROGEN(ip, n, value) writel((value), ip->base \
+	+ offset__AUDCFG_FSYN_PROGEN(ip, n))
+
+/* PROG_EN */
+
+#define shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n) 0
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n) 0x1
+#define get__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n)) >> \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n)) & \
+	mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_PROGEN(ip, n)) & \
+	~(mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n))) | (((value) & \
+	mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n)) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n)), ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n))
+
+#define value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n) 0x0
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n) \
+	(value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n) \
+	set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, \
+	value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n))
+
+#define value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n) 0x1
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n) \
+	(value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n) \
+	set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, \
+	value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n))
+
+#endif
diff --git a/sound/stm/spdif_player.c b/sound/stm/spdif_player.c
new file mode 100644
index 0000000..37d114b
--- /dev/null
+++ b/sound/stm/spdif_player.c
@@ -0,0 +1,1665 @@
+/*
+ *   STMicroelectronics System-on-Chips' SPDIF player driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/cacheflush.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+
+#define COMPONENT spdif_player
+#include "common.h"
+#include "reg_aud_spdif.h"
+
+
+
+/*
+ * Some hardware-related definitions
+ */
+
+#define DEFAULT_OVERSAMPLING 128
+
+/* The sample count field (MEMREAD in CTRL register) is 17 bits wide */
+#define MAX_SAMPLES_PER_PERIOD ((1 << 17) - 1)
+
+#define PREAMBLE_BYTES 8
+
+
+/*
+ * SPDIF player instance definition
+ */
+
+enum snd_stm_spdif_player_input_mode {
+	SNDRV_STM_SPDIF_INPUT_MODE_NORMAL,
+	SNDRV_STM_SPDIF_INPUT_MODE_RAW
+};
+
+enum snd_stm_spdif_player_encoding_mode {
+	SNDRV_STM_SPDIF_ENCODING_MODE_PCM,
+	SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED
+};
+
+struct snd_stm_spdif_player_settings {
+	enum snd_stm_spdif_player_input_mode input_mode;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode;
+	struct snd_aes_iec958 iec958;
+	unsigned char iec61937_preamble[PREAMBLE_BYTES]; /* Used in */
+	unsigned int iec61937_audio_repetition;          /* encoded */
+	unsigned int iec61937_pause_repetition;          /* mode */
+};
+
+struct snd_stm_spdif_player {
+	/* System informations */
+	struct snd_stm_spdif_player_info *info;
+	struct device *device;
+	struct snd_pcm *pcm;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+	unsigned long fifo_phys_address;
+	unsigned int irq;
+	unsigned int fdma_channel;
+
+	/* Environment settings */
+	struct snd_stm_fsynth_channel *fsynth_channel;
+	struct snd_stm_conv *conv;
+
+	/* Default settings (controlled by controls ;-) */
+	struct snd_stm_spdif_player_settings default_settings;
+	spinlock_t default_settings_lock; /* Protects default_settings */
+
+	/* Runtime data */
+	struct snd_stm_buffer *buffer;
+	struct snd_info_entry *proc_entry;
+	struct snd_pcm_substream *substream;
+	int fdma_max_transfer_size;
+	struct stm_dma_params fdma_params;
+	struct stm_dma_req *fdma_request;
+	struct snd_stm_spdif_player_settings stream_settings;
+	int stream_iec958_status_cnt;
+	int stream_iec958_subcode_cnt;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Playing engine implementation
+ */
+
+static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
+{
+	irqreturn_t result = IRQ_NONE;
+	struct snd_stm_spdif_player *spdif_player = dev_id;
+	unsigned int status;
+
+	snd_stm_printd(2, "snd_stm_spdif_player_irq_handler(irq=%d, "
+			"dev_id=0x%p)\n", irq, dev_id);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Get interrupt status & clear them immediately */
+	preempt_disable();
+	status = get__AUD_SPDIF_ITS(spdif_player);
+	set__AUD_SPDIF_ITS_CLR(spdif_player, status);
+	preempt_enable();
+
+	/* Underflow? */
+	if (unlikely(status &
+			mask__AUD_SPDIF_ITS__UNF__PENDING(spdif_player))) {
+		snd_stm_printe("Underflow detected in SPDIF player '%s'!\n",
+				spdif_player->device->bus_id);
+		result = IRQ_HANDLED;
+	}
+
+	/* Period successfully played */
+	if (likely(status &
+			mask__AUD_SPDIF_ITS__NSAMPLE__PENDING(spdif_player)))
+		do {
+			snd_assert(spdif_player->substream, break);
+
+			snd_stm_printd(2, "Period elapsed ('%s')\n",
+					spdif_player->device->bus_id);
+			snd_pcm_period_elapsed(spdif_player->substream);
+
+			result = IRQ_HANDLED;
+		} while (0);
+
+	/* Some alien interrupt??? */
+	snd_assert(result == IRQ_HANDLED);
+
+	return result;
+}
+
+/* In normal mode we are preparing SPDIF formating "manually".
+ * It means:
+ * 1. A lot of parsing...
+ * 2. MMAPing is impossible...
+ * 3. We can handle some other formats! */
+static struct snd_pcm_hardware snd_stm_spdif_player_hw_normal = {
+	.info		= (SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S24_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 2,
+
+	.periods_min	= 2,
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* Values below were worked out mostly basing on ST media player
+	 * requirements. They should, however, fit most "normal" cases...
+	 * Note 1: that these value must be also calculated not to exceed
+	 * NSAMPLE interrupt counter size (19 bits) - MAX_SAMPLES_PER_PERIOD.
+	 * Note 2: period_bytes_min defines minimum time between period
+	 * (NSAMPLE) interrupts... Keep it large enough not to kill
+	 * the system... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+/* In raw mode SPDIF formatting must be prepared by user. Every sample
+ * (one channel) is a 32 bits word containing up to 24 bits of data
+ * and 4 SPDIF control bits: V(alidty flag), U(ser data), C(hannel status),
+ * P(arity bit):
+ *
+ *      +---------------+---------------+---------------+---------------+
+ *      |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
+ * bit: |1|0|9|8|6|7|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
+ *      +---------------+---------------+---------------+-------+-------+
+ *      |M                                             L|       |       |
+ *      |S          sample data (up to 24 bits)        S|0|0|0|0|V|U|C|0|
+ *      |B                                             B|       |       |
+ *      +-----------------------------------------------+-------+-------+
+ *
+ * SPDIF player sends subframe's sync preamble first (thanks at least
+ * for this ;-)), than data starting from LSB (so samples smaller than
+ * 24 bits should be aligned to MSB and have zeros as LSBs), than VUC bits
+ * and finally adds a parity bit (thanks again ;-).
+ */
+static struct snd_pcm_hardware snd_stm_spdif_player_hw_raw = {
+	.info		= (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE),
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
+
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
+	.rate_min	= 32000,
+	.rate_max	= 192000,
+
+	.channels_min	= 2,
+	.channels_max	= 2,
+
+	.periods_min	= 2,
+	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
+
+	/* See above... */
+	.period_bytes_min = 4096, /* 1024 frames @ 32kHz, 16 bits, 2 ch. */
+	.period_bytes_max = 81920, /* 2048 frames @ 192kHz, 32 bits, 10 ch. */
+	.buffer_bytes_max = 81920 * 3, /* 3 worst-case-periods */
+};
+
+static int snd_stm_spdif_player_open(struct snd_pcm_substream *substream)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_open(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Get attached converter handle */
+
+	spdif_player->conv = snd_stm_conv_get_attached(&platform_bus_type,
+			spdif_player->device->bus_id);
+	if (spdif_player->conv)
+		snd_stm_printd(1, "Converter '%s' attached to '%s'...\n",
+				spdif_player->conv->name,
+				spdif_player->device->bus_id);
+	else
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+				spdif_player->device->bus_id);
+
+	/* Get default data */
+
+	spin_lock(&spdif_player->default_settings_lock);
+	spdif_player->stream_settings = spdif_player->default_settings;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	/* Set up constraints & pass hardware capabilities info to ALSA */
+
+	/* It is better when buffer size is an integer multiple of period
+	 * size... Such thing will ensure this :-O */
+	result = snd_pcm_hw_constraint_integer(runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (result < 0) {
+		snd_stm_printe("Can't set periods constraint!\n");
+		return result;
+	}
+
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			spdif_player->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL)
+		runtime->hw = snd_stm_spdif_player_hw_normal;
+	else
+		runtime->hw = snd_stm_spdif_player_hw_raw;
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_close(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_close(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (snd_stm_buffer_is_allocated(spdif_player->buffer)) {
+		/* Free buffer */
+		snd_stm_buffer_free(spdif_player->buffer);
+
+		/* Free FDMA parameters */
+
+		dma_params_free(&spdif_player->fdma_params);
+		dma_req_free(spdif_player->fdma_channel,
+				spdif_player->fdma_request);
+	}
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int buffer_bytes, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_WRITE,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = spdif_player->info->fdma_initiator,
+	};
+
+	snd_stm_printd(1, "snd_stm_spdif_player_hw_params(substream=0x%p,"
+			" hw_params=0x%p)\n", substream, hw_params);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This function may be called many times, so let's be prepared... */
+	if (snd_stm_buffer_is_allocated(spdif_player->buffer))
+		snd_stm_spdif_player_hw_free(substream);
+
+	/* Allocate buffer */
+
+	buffer_bytes = params_buffer_bytes(hw_params);
+	result = snd_stm_buffer_alloc(spdif_player->buffer, substream,
+			buffer_bytes);
+	if (!spdif_player->buffer) {
+		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
+				buffer_bytes, spdif_player->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
+	}
+
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			spdif_player->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
+			"to %d.\n", transfer_size);
+
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= spdif_player->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1) {
+		/* FDMA request trigger control was introduced in
+		 * STx7111... */
+		snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+				return -EINVAL);
+		snd_assert(transfer_size <=
+				mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(
+				spdif_player), return -EINVAL);
+		set__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(spdif_player,
+				transfer_size);
+	}
+
+	/* Configure FDMA transfer */
+
+	spdif_player->fdma_request = dma_req_config(spdif_player->fdma_channel,
+			spdif_player->info->fdma_request_line,
+			&fdma_req_config);
+	if (!spdif_player->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", spdif_player->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
+
+	dma_params_init(&spdif_player->fdma_params, MODE_PACED,
+			STM_DMA_LIST_CIRC);
+
+	dma_params_DIM_1_x_0(&spdif_player->fdma_params);
+
+	dma_params_req(&spdif_player->fdma_params, spdif_player->fdma_request);
+
+	dma_params_addrs(&spdif_player->fdma_params, runtime->dma_addr,
+			spdif_player->fifo_phys_address, buffer_bytes);
+
+	result = dma_compile_list(spdif_player->fdma_channel,
+				&spdif_player->fdma_params, GFP_KERNEL);
+	if (result < 0) {
+		snd_stm_printe("Can't compile FDMA parameters for player"
+				" '%s'!\n", spdif_player->device->bus_id);
+		goto error_compile_list;
+	}
+
+	return 0;
+
+error_compile_list:
+	dma_req_free(spdif_player->fdma_channel,
+			spdif_player->fdma_request);
+error_req_config:
+	snd_stm_buffer_free(spdif_player->buffer);
+error_buf_alloc:
+	return result;
+}
+
+static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int oversampling;
+	unsigned long status;
+	struct snd_aes_iec958 *iec958;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_prepare(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+
+	/* Configure SPDIF-PCM synchronisation */
+
+	/* TODO */
+
+	/* Get oversampling value from connected converter */
+
+	if (spdif_player->conv) {
+		unsigned int format =
+				snd_stm_conv_get_format(spdif_player->conv);
+
+		snd_assert((format & SND_STM_FORMAT__MASK) ==
+				SND_STM_FORMAT__SPDIF, return -EINVAL);
+
+		oversampling = snd_stm_conv_get_oversampling(
+				spdif_player->conv);
+		if (oversampling == 0)
+			oversampling = DEFAULT_OVERSAMPLING;
+	} else {
+		oversampling = DEFAULT_OVERSAMPLING;
+	}
+
+	snd_stm_printd(1, "Player %s: sampling frequency %d, oversampling %d\n",
+			spdif_player->device->bus_id, runtime->rate,
+			oversampling);
+
+	snd_assert(oversampling > 0, return -EINVAL);
+
+	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
+	 * so oversampling must be multiple of 128... */
+	snd_assert(oversampling % 128 == 0, return -EINVAL);
+
+	/* Set up frequency synthesizer */
+
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth_channel,
+			runtime->rate * oversampling);
+
+	/* Configure SPDIF player frequency divider
+	 *
+	 *                        Fdacclk
+	 * divider = ------------------------------- =
+	 *            2 * Fs * bits_in_output_frame
+	 *
+	 *            Fs * oversampling     oversampling
+	 *         = ------------------- = --------------
+	 *            2 * Fs * (32 * 2)         128
+	 * where:
+	 *   - Fdacclk - frequency of DAC clock signal, known also as PCMCLK,
+	 *               MCLK (master clock), "system clock" etc.
+	 *   - Fs - sampling rate (frequency)
+	 */
+
+	set__AUD_SPDIF_CTRL__CLK_DIV(spdif_player, oversampling / 128);
+
+	/* Configure NSAMPLE interrupt (in samples,
+	 * so period size times channels) */
+
+	set__AUD_SPDIF_CTRL__MEMREAD(spdif_player, runtime->period_size * 2);
+
+	/* Reset IEC958 software formatting counters */
+
+	spdif_player->stream_iec958_status_cnt = 0;
+	spdif_player->stream_iec958_subcode_cnt = 0;
+
+	/* Set VUC register settings */
+
+	/* Channel status */
+	iec958 = &spdif_player->stream_settings.iec958;
+	status = iec958->status[0] | iec958->status[1] << 8 |
+		iec958->status[2] << 16 | iec958->status[3] << 24;
+	set__AUD_SPDIF_CL1__CL1(spdif_player, status);
+	set__AUD_SPDIF_CL2_CR2_UV__CL2(spdif_player, iec958->status[4] & 0xf);
+	set__AUD_SPDIF_CR1__CR1(spdif_player, status);
+	set__AUD_SPDIF_CL2_CR2_UV__CR2(spdif_player, iec958->status[4] & 0xf);
+
+	/* User data - well, can't do too much here... */
+	set__AUD_SPDIF_CL2_CR2_UV__LU(spdif_player, 0);
+	set__AUD_SPDIF_CL2_CR2_UV__RU(spdif_player, 0);
+
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM) {
+		/* Linear PCM: validity bit are zeroed */
+		set__AUD_SPDIF_CL2_CR2_UV__LV(spdif_player, 0);
+		set__AUD_SPDIF_CL2_CR2_UV__RV(spdif_player, 0);
+	} else {
+		struct snd_stm_spdif_player_settings *settings =
+				&spdif_player->stream_settings;
+
+		/* Encoded mode: validity bits are one */
+		set__AUD_SPDIF_CL2_CR2_UV__LV(spdif_player, 1);
+		set__AUD_SPDIF_CL2_CR2_UV__RV(spdif_player, 1);
+
+		/* Number of frames is data/pause bursts */
+		set__AUD_SPDIF_BST_FL__DBURST(spdif_player,
+				settings->iec61937_audio_repetition);
+		set__AUD_SPDIF_BST_FL__PDBURST(spdif_player,
+				settings->iec61937_pause_repetition);
+
+		/* IEC61937 Preamble */
+		set__AUD_SPDIF_PA_PB__PA(spdif_player,
+				settings->iec61937_preamble[0] |
+				settings->iec61937_preamble[1] << 8);
+		set__AUD_SPDIF_PA_PB__PB(spdif_player,
+				settings->iec61937_preamble[2] |
+				settings->iec61937_preamble[3] << 8);
+		set__AUD_SPDIF_PC_PD__PC(spdif_player,
+				settings->iec61937_preamble[4] |
+				settings->iec61937_preamble[5] << 8);
+		set__AUD_SPDIF_PC_PD__PD(spdif_player,
+				settings->iec61937_preamble[6] |
+				settings->iec61937_preamble[7] << 8);
+
+		/* TODO: set AUD_SPDIF_PAU_LAT NPD_BURST somehow... */
+	}
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
+		*substream)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_start(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Un-reset SPDIF player */
+
+	set__AUD_SPDIF_RST__SRSTP__RUNNING(spdif_player);
+
+	/* Launch FDMA transfer */
+
+	result = dma_xfer_list(spdif_player->fdma_channel,
+			&spdif_player->fdma_params);
+	if (result != 0) {
+		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
+				spdif_player->device->bus_id);
+		return -EINVAL;
+	}
+
+	/* Launch SPDIF player */
+
+	spdif_player->substream = substream;
+
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		set__AUD_SPDIF_CTRL__MODE__PCM(spdif_player);
+	else
+		set__AUD_SPDIF_CTRL__MODE__ENCODED(spdif_player);
+
+	/* Enable player interrupts */
+
+	set__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(spdif_player);
+	set__AUD_SPDIF_IT_EN_SET__UNF__SET(spdif_player);
+
+	/* Wake up & unmute converter */
+
+	if (spdif_player->conv) {
+		snd_stm_conv_enable(spdif_player->conv);
+		snd_stm_conv_unmute(spdif_player->conv);
+	}
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_stop(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* Mute & shutdown converter */
+
+	if (spdif_player->conv) {
+		snd_stm_conv_mute(spdif_player->conv);
+		snd_stm_conv_disable(spdif_player->conv);
+	}
+
+	/* Disable interrupts */
+
+	set__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(spdif_player);
+	set__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(spdif_player);
+
+	/* Stop SPDIF player */
+
+	set__AUD_SPDIF_CTRL__MODE__OFF(spdif_player);
+	spdif_player->substream = NULL;
+
+	/* Stop FDMA transfer */
+
+	dma_stop_channel(spdif_player->fdma_channel);
+
+	/* Reset SPDIF player */
+
+	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_pause(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_pause(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* "Mute" player
+	 * Documentation describes this mode in a wrong way - data is _not_
+	 * consumed in the "mute" mode, so it is actually a "pause" mode */
+
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		set__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(spdif_player);
+	else
+		set__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(spdif_player);
+
+	return 0;
+}
+
+static inline int snd_stm_spdif_player_release(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_release(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	/* "Unmute" player */
+
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+		set__AUD_SPDIF_CTRL__MODE__PCM(spdif_player);
+	else
+		set__AUD_SPDIF_CTRL__MODE__ENCODED(spdif_player);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_trigger(struct snd_pcm_substream *substream,
+		int command)
+{
+	snd_stm_printd(1, "snd_stm_spdif_player_trigger(substream=0x%p,"
+			" command=%d)\n", substream, command);
+
+	switch (command) {
+	case SNDRV_PCM_TRIGGER_START:
+		return snd_stm_spdif_player_start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+		return snd_stm_spdif_player_stop(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return snd_stm_spdif_player_pause(substream);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return snd_stm_spdif_player_release(substream);
+	default:
+		return -EINVAL;
+	}
+}
+
+static snd_pcm_uframes_t snd_stm_spdif_player_pointer(struct snd_pcm_substream
+		*substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int residue;
+	snd_pcm_uframes_t pointer;
+
+	snd_stm_printd(2, "snd_stm_spdif_player_pointer(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	residue = get_dma_residue(spdif_player->fdma_channel);
+	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
+
+	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+			" bytes...\n", residue, runtime->dma_bytes);
+	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+			pointer, pointer);
+
+	return pointer;
+}
+
+#define VUC_MASK 0xf
+#define V_BIT (1 << 3)
+#define U_BIT (1 << 2)
+#define C_BIT (1 << 1)
+
+#define GET_SAMPLE(kernel_var, user_ptr, memory_format) \
+	do { \
+		__get_user(kernel_var, (memory_format __user *)user_ptr); \
+		(*((memory_format __user **)&user_ptr))++; \
+	} while (0);
+
+static void snd_stm_spdif_player_format_frame(struct snd_stm_spdif_player
+		*spdif_player, unsigned long *left_subframe,
+		unsigned long *right_subframe)
+{
+	unsigned char data;
+
+	snd_assert(spdif_player, return);
+	snd_stm_magic_assert(spdif_player, return);
+
+	/* Clean VUC bits */
+	*left_subframe &= ~VUC_MASK;
+	*right_subframe &= ~VUC_MASK;
+
+	/* Validity bit should be set to one when non-PCM data are
+	 * transmitted... */
+	if (spdif_player->stream_settings.encoding_mode) {
+		*left_subframe |= V_BIT;
+		*right_subframe |= V_BIT;
+	}
+
+	/* User data consists of both subframe U-bits */
+	data = spdif_player->stream_settings.iec958.subcode[
+			spdif_player->stream_iec958_subcode_cnt / 8];
+	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
+		*left_subframe |= U_BIT;
+	spdif_player->stream_iec958_subcode_cnt++;
+	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
+		*right_subframe |= U_BIT;
+	spdif_player->stream_iec958_subcode_cnt =
+			(spdif_player->stream_iec958_subcode_cnt + 1) % 1176;
+
+	/* Channel status bit shall be the same for both subframes
+	 * (except channel number field, which we ignore.) */
+	data = spdif_player->stream_settings.iec958.status[
+			spdif_player->stream_iec958_status_cnt / 8];
+	if (data & (1 << (spdif_player->stream_iec958_status_cnt % 8))) {
+		*left_subframe |= C_BIT;
+		*right_subframe |= C_BIT;
+	}
+	spdif_player->stream_iec958_status_cnt =
+			(spdif_player->stream_iec958_status_cnt + 1) % 192;
+}
+
+static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
+		int channel, snd_pcm_uframes_t pos,
+		void __user *src, snd_pcm_uframes_t count)
+{
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(2, "snd_stm_spdif_player_copy(substream=0x%p, "
+			"channel=%d, pos=%lu, buf=0x%p, count=%lu)\n",
+			substream, channel, pos, src, count);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
+		unsigned long *dest = (unsigned long *)(runtime->dma_area +
+				frames_to_bytes(runtime, pos));
+		int i;
+
+		if (!access_ok(VERIFY_READ, src, frames_to_bytes(runtime,
+						count)))
+			return -EFAULT;
+
+		snd_stm_printd(2, "Formatting SPDIF frame (format=%d)\n",
+				runtime->format);
+
+#if 0
+		{
+			unsigned char data[64];
+
+			copy_from_user(data, src, 64);
+
+			snd_stm_printd(0, "Input:\n");
+			snd_stm_hex_dump(data, 64);
+		}
+#endif
+
+		for (i = 0; i < count; i++) {
+			unsigned long left_subframe, right_subframe;
+
+			switch (runtime->format) {
+			case SNDRV_PCM_FORMAT_S32_LE:
+				GET_SAMPLE(left_subframe, src, u32);
+				GET_SAMPLE(right_subframe, src, u32);
+				break;
+			case SNDRV_PCM_FORMAT_S24_LE:
+				/* 24-bits sample are in lower 3 bytes,
+				 * while we want them in upper 3... ;-) */
+				GET_SAMPLE(left_subframe, src, u32);
+				left_subframe <<= 8;
+				GET_SAMPLE(right_subframe, src, u32);
+				right_subframe <<= 8;
+				break;
+			default:
+				snd_BUG();
+				return -EINVAL;
+			}
+
+			snd_stm_spdif_player_format_frame(spdif_player,
+					&left_subframe, &right_subframe);
+
+			*(dest++) = left_subframe;
+			*(dest++) = right_subframe;
+		}
+
+#if 0
+		snd_stm_printd(0, "Output:\n");
+		snd_stm_hex_dump(runtime->dma_area +
+				frames_to_bytes(runtime, pos), 64);
+#endif
+	} else {
+		/* RAW mode */
+		if (copy_from_user(runtime->dma_area +
+				frames_to_bytes(runtime, pos), src,
+				frames_to_bytes(runtime, count)) != 0)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_silence(struct snd_pcm_substream *substream,
+		int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	int result = 0;
+	struct snd_stm_spdif_player *spdif_player =
+		snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printd(2, "snd_stm_spdif_player_silence(substream=0x%p, "
+			"channel=%d, pos=%lu, count=%lu)\n",
+			substream, channel, pos, count);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
+		unsigned long *buffer = (unsigned long *)(runtime->dma_area +
+				frames_to_bytes(runtime, pos));
+		unsigned long left_subframe = 0;
+		unsigned long right_subframe = 0;
+		int i;
+
+		for (i = 0; i < count; i++) {
+			snd_stm_spdif_player_format_frame(spdif_player,
+					&left_subframe, &right_subframe);
+			*(buffer++) = left_subframe;
+			*(buffer++) = right_subframe;
+		}
+	} else {
+		/* RAW mode */
+		result = snd_pcm_format_set_silence(runtime->format,
+				runtime->dma_area +
+				frames_to_bytes(runtime, pos),
+				runtime->channels * count);
+	}
+
+	return result;
+}
+
+static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
+	.open =      snd_stm_spdif_player_open,
+	.close =     snd_stm_spdif_player_close,
+	.mmap =      snd_stm_buffer_mmap,
+	.ioctl =     snd_pcm_lib_ioctl,
+	.hw_params = snd_stm_spdif_player_hw_params,
+	.hw_free =   snd_stm_spdif_player_hw_free,
+	.prepare =   snd_stm_spdif_player_prepare,
+	.trigger =   snd_stm_spdif_player_trigger,
+	.pointer =   snd_stm_spdif_player_pointer,
+	.copy =      snd_stm_spdif_player_copy,
+	.silence =   snd_stm_spdif_player_silence,
+};
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_spdif_player_ctl_default_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.iec958 = spdif_player->default_settings.iec958;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_default_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	if (snd_stm_iec958_cmp(&spdif_player->default_settings.iec958,
+				&ucontrol->value.iec958) != 0) {
+		spdif_player->default_settings.iec958 = ucontrol->value.iec958;
+		changed = 1;
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+/* "Raw Data" switch controls data input mode - "RAW" means that played
+ * data are already properly formated (VUC bits); in "normal" mode
+ * this data will be added by driver according to setting passed in\
+ * following controls */
+
+static int snd_stm_spdif_player_ctl_raw_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+			(spdif_player->default_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_RAW);
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_raw_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	enum snd_stm_spdif_player_input_mode input_mode;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	if (ucontrol->value.integer.value[0])
+		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_RAW;
+	else
+		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_NORMAL;
+
+	spin_lock(&spdif_player->default_settings_lock);
+	changed = (input_mode != spdif_player->default_settings.input_mode);
+	spdif_player->default_settings.input_mode = input_mode;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+/* "Encoded Data" switch selects linear PCM or encoded operation of
+ * SPDIF player - the difference is in generating mute data; PCM mode
+ * will generate NULL data, encoded - pause bursts */
+
+static int snd_stm_spdif_player_ctl_encoded_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+			(spdif_player->default_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED);
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_encoded_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	if (ucontrol->value.integer.value[0])
+		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED;
+	else
+		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_PCM;
+
+	spin_lock(&spdif_player->default_settings_lock);
+	changed = (encoding_mode !=
+			spdif_player->default_settings.encoding_mode);
+	spdif_player->default_settings.encoding_mode = encoding_mode;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+/* Three following controls are valid for encoded mode only - they
+ * control IEC 61937 preamble and data burst periods (see mentioned
+ * standard for more informations) */
+
+static int snd_stm_spdif_player_ctl_preamble_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = PREAMBLE_BYTES;
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_preamble_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p"
+			", ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	memcpy(ucontrol->value.bytes.data,
+			spdif_player->default_settings.iec61937_preamble,
+			PREAMBLE_BYTES);
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_preamble_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p"
+			", ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	if (memcmp(spdif_player->default_settings.iec61937_preamble,
+			ucontrol->value.bytes.data, PREAMBLE_BYTES) != 0) {
+		changed = 1;
+		memcpy(spdif_player->default_settings.iec61937_preamble,
+				ucontrol->value.bytes.data, PREAMBLE_BYTES);
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+static int snd_stm_spdif_player_ctl_repetition_info(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xffff;
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_audio_repetition_get(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+		spdif_player->default_settings.iec61937_audio_repetition;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_audio_repetition_put(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	if (spdif_player->default_settings.iec61937_audio_repetition !=
+			ucontrol->value.integer.value[0]) {
+		changed = 1;
+		spdif_player->default_settings.iec61937_audio_repetition =
+				ucontrol->value.integer.value[0];
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+static int snd_stm_spdif_player_ctl_pause_repetition_get(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+		spdif_player->default_settings.iec61937_pause_repetition;
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_ctl_pause_repetition_put(struct snd_kcontrol
+		*kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	spin_lock(&spdif_player->default_settings_lock);
+	if (spdif_player->default_settings.iec61937_pause_repetition !=
+			ucontrol->value.integer.value[0]) {
+		changed = 1;
+		spdif_player->default_settings.iec61937_pause_repetition =
+				ucontrol->value.integer.value[0];
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_spdif_player_ctls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_iec958_info,
+		.get = snd_stm_spdif_player_ctl_default_get,
+		.put = snd_stm_spdif_player_ctl_default_put,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_con,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_pro,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Raw Data ", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_boolean_info,
+		.get = snd_stm_spdif_player_ctl_raw_get,
+		.put = snd_stm_spdif_player_ctl_raw_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Encoded Data ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_boolean_info,
+		.get = snd_stm_spdif_player_ctl_encoded_get,
+		.put = snd_stm_spdif_player_ctl_encoded_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Preamble ", PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_preamble_info,
+		.get = snd_stm_spdif_player_ctl_preamble_get,
+		.put = snd_stm_spdif_player_ctl_preamble_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Audio Burst Period ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_repetition_info,
+		.get = snd_stm_spdif_player_ctl_audio_repetition_get,
+		.put = snd_stm_spdif_player_ctl_audio_repetition_put,
+	}, {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("Pause Burst Period ",
+				PLAYBACK, DEFAULT),
+		.info = snd_stm_spdif_player_ctl_repetition_info,
+		.get = snd_stm_spdif_player_ctl_pause_repetition_get,
+		.put = snd_stm_spdif_player_ctl_pause_repetition_put,
+	}
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_SPDIF_%s (offset 0x%02x) =" \
+				" 0x%08x\n", __stringify(r), \
+				offset__AUD_SPDIF_##r(spdif_player), \
+				get__AUD_SPDIF_##r(spdif_player))
+
+static void snd_stm_spdif_player_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_spdif_player *spdif_player = entry->private_data;
+
+	snd_assert(spdif_player, return);
+	snd_stm_magic_assert(spdif_player, return);
+
+	DUMP_REGISTER(RST);
+	DUMP_REGISTER(DATA);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(ITS_CLR);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(IT_EN_SET);
+	DUMP_REGISTER(IT_EN_CLR);
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(PA_PB);
+	DUMP_REGISTER(PC_PD);
+	DUMP_REGISTER(CL1);
+	DUMP_REGISTER(CR1);
+	DUMP_REGISTER(CL2_CR2_UV);
+	DUMP_REGISTER(PAU_LAT);
+	DUMP_REGISTER(BST_FL);
+	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1)
+		DUMP_REGISTER(CONFIG);
+}
+
+static int snd_stm_spdif_player_register(struct snd_device *snd_device)
+{
+	int result;
+	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
+	int i;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_register(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	snd_stm_printd(0, "--- Registering player '%s'...\n",
+			spdif_player->device->bus_id);
+
+	/* Initialize hardware (format etc.) */
+
+	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
+
+	/* TODO: well, hardcoded - shall anyone use it?
+	 * And what it actually means? */
+	set__AUD_SPDIF_CTRL__RND__NO_ROUNDING(spdif_player);
+
+	set__AUD_SPDIF_CTRL__IDLE__NORMAL(spdif_player);
+
+	/* Hardware stuffing is not implemented yet... */
+	/* TODO: oh, is that so? */
+	set__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(spdif_player);
+
+	/* Get frequency synthesizer channel */
+
+	snd_assert(spdif_player->info->fsynth_bus_id != NULL, return -EINVAL);
+	snd_stm_printd(0, "Player connected to %s's output %d.\n",
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+
+	spdif_player->fsynth_channel = snd_stm_fsynth_get_channel(
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+	snd_assert(spdif_player->fsynth_channel != NULL, return -EINVAL);
+
+	/* Registers view in ALSA's procfs */
+
+	snd_stm_info_register(&spdif_player->proc_entry,
+			spdif_player->device->bus_id,
+			snd_stm_spdif_player_dump_registers, spdif_player);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(&platform_bus_type,
+			spdif_player->device->bus_id, snd_device->card,
+			spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	result = snd_stm_fsynth_add_adjustement_ctl(
+			spdif_player->fsynth_channel, snd_device->card,
+			spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
+		snd_stm_spdif_player_ctls[i].device =
+				spdif_player->info->card_device;
+		result = snd_ctl_add(snd_device->card,
+				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
+				spdif_player));
+		if (result < 0) {
+			snd_stm_printe("Failed to add SPDIF ALSA control!\n");
+			return result;
+		}
+		snd_stm_spdif_player_ctls[i].index++;
+	}
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_spdif_player_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
+
+	snd_stm_printd(1, "snd_stm_spdif_player_disconnect(snd_device=0x%p)\n",
+			snd_device);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	snd_stm_info_unregister(spdif_player->proc_entry);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_spdif_player_snd_device_ops = {
+	.dev_register = snd_stm_spdif_player_register,
+	.dev_disconnect = snd_stm_spdif_player_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_spdif_player_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_spdif_player *spdif_player;
+	struct snd_card *card = snd_stm_card_get();
+	int buffer_bytes_max;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
+	if (!spdif_player) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(spdif_player);
+	spdif_player->info = pdev->dev.platform_data;
+	snd_assert(spdif_player->info != NULL, return -EINVAL);
+	spdif_player->ver = spdif_player->info->ver;
+	snd_assert(spdif_player->ver > 0, return -EINVAL);
+	spdif_player->device = &pdev->dev;
+
+	spin_lock_init(&spdif_player->default_settings_lock);
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &spdif_player->mem_region,
+			&spdif_player->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+	spdif_player->fifo_phys_address = spdif_player->mem_region->start +
+			offset__AUD_SPDIF_DATA(spdif_player);
+	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+			spdif_player->fifo_phys_address);
+
+	result = snd_stm_irq_request(pdev, &spdif_player->irq,
+			snd_stm_spdif_player_irq_handler, spdif_player);
+	if (result < 0) {
+		snd_stm_printe("IRQ request failed!\n");
+		goto error_irq_request;
+	}
+
+	result = snd_stm_fdma_request(pdev, &spdif_player->fdma_channel);
+	if (result < 0) {
+		snd_stm_printe("FDMA request failed!\n");
+		goto error_fdma_request;
+	}
+
+	/* FDMA transfer size depends (among others ;-) on FIFO length,
+	 * which is:
+	 * - 6 cells (24 bytes) in STx710x and STx7200 cut 1.0
+	 * - 30 cells (120 bytes) in STx7111 and STx7200 cut 2.0. */
+
+	if (spdif_player->ver < ver__AUD_SPDIF__65_2_0)
+		spdif_player->fdma_max_transfer_size = 2;
+	else if (spdif_player->ver == ver__AUD_SPDIF__65_2_0)
+		spdif_player->fdma_max_transfer_size = 4;
+	else
+		spdif_player->fdma_max_transfer_size = 20;
+
+	/* Get component caps */
+
+	snd_stm_printd(0, "Player's name is '%s'\n", spdif_player->info->name);
+
+	/* Create ALSA lowlevel device */
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, spdif_player,
+			&snd_stm_spdif_player_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA PCM device */
+
+	result = snd_pcm_new(card, NULL, spdif_player->info->card_device, 1, 0,
+			&spdif_player->pcm);
+	if (result < 0) {
+		snd_stm_printe("ALSA PCM instance creation failed!\n");
+		goto error_pcm;
+	}
+	spdif_player->pcm->private_data = spdif_player;
+	strcpy(spdif_player->pcm->name, spdif_player->info->name);
+
+	snd_pcm_set_ops(spdif_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_stm_spdif_player_spdif_ops);
+
+	/* Initialize buffer */
+
+	buffer_bytes_max = snd_stm_spdif_player_hw_normal.buffer_bytes_max;
+	if (buffer_bytes_max < snd_stm_spdif_player_hw_raw.buffer_bytes_max)
+		buffer_bytes_max = snd_stm_spdif_player_hw_raw.buffer_bytes_max;
+	spdif_player->buffer = snd_stm_buffer_create(spdif_player->pcm,
+			spdif_player->device, buffer_bytes_max);
+	if (!spdif_player->buffer) {
+		snd_stm_printe("Cannot initialize buffer!\n");
+		result = -ENOMEM;
+		goto error_buffer_create;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, spdif_player);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_buffer_create:
+	/* snd_pcm_free() is not available - PCM device will be released
+	 * during card release */
+error_pcm:
+	snd_device_free(card, spdif_player);
+error_device:
+	snd_stm_fdma_release(spdif_player->fdma_channel);
+error_fdma_request:
+	snd_stm_irq_release(spdif_player->irq, spdif_player);
+error_irq_request:
+	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
+error_memory_request:
+	snd_stm_magic_clear(spdif_player);
+	kfree(spdif_player);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_spdif_player_remove(struct platform_device *pdev)
+{
+	struct snd_stm_spdif_player *spdif_player = platform_get_drvdata(pdev);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+
+	snd_stm_buffer_dispose(spdif_player->buffer);
+	snd_stm_fdma_release(spdif_player->fdma_channel);
+	snd_stm_irq_release(spdif_player->irq, spdif_player);
+	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
+
+	snd_stm_magic_clear(spdif_player);
+	kfree(spdif_player);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_spdif_player_driver = {
+	.driver = {
+		.name = "snd_spdif_player",
+	},
+	.probe = snd_stm_spdif_player_probe,
+	.remove = snd_stm_spdif_player_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_spdif_player_init(void)
+{
+	return platform_driver_register(&snd_stm_spdif_player_driver);
+}
+
+void snd_stm_spdif_player_exit(void)
+{
+	platform_driver_unregister(&snd_stm_spdif_player_driver);
+}
diff --git a/sound/stm/stx710x.c b/sound/stm/stx710x.c
new file mode 100644
index 0000000..f036da5
--- /dev/null
+++ b/sound/stm/stx710x.c
@@ -0,0 +1,565 @@
+/*
+ *   STMicrolectronics STx7100 SoC description & audio glue driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#define COMPONENT stx710x
+#include "common.h"
+#include "reg_710x_audcfg.h"
+
+
+
+/*
+ * ALSA module parameters
+ */
+
+static int index = -1; /* First available index */
+static char *id = "STx710x"; /* Default card ID */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for STx710x audio subsystem card.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for STx710x audio subsystem card.");
+
+
+
+/*
+ * Audio subsystem components & platform devices
+ */
+
+/* STx710x audio glue */
+
+static struct platform_device stx710x_glue = {
+	.name          = "snd_stx710x_glue",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210200,
+			.end   = 0x19210203,
+		},
+	},
+};
+
+/* Frequency synthesizer */
+
+static struct snd_stm_fsynth_info fsynth_info = {
+	/* .ver = see snd_stm_stx710x_init() */
+	.channels_from = 0,
+	.channels_to = 2,
+};
+
+static struct platform_device fsynth = {
+	.name          = "snd_fsynth",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210000,
+			.end   = 0x1921003f,
+		},
+	},
+	.dev.platform_data = &fsynth_info,
+};
+
+/* Internal DAC */
+
+static struct snd_stm_conv_int_dac_info conv_int_dac_info = {
+	.name = "Internal audio DAC",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 1,
+	.source_bus_id = "snd_pcm_player.1",
+};
+
+static struct platform_device conv_int_dac = {
+	.name          = "snd_conv_int_dac",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210100,
+			.end   = 0x19210103,
+		},
+	},
+	.dev.platform_data = &conv_int_dac_info,
+};
+
+/* PCM players */
+
+struct snd_stm_pcm_player_info pcm_player_0_info = {
+	.name = "PCM player #0",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 0,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 0,
+	.channels = 10,
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+};
+
+static struct platform_device pcm_player_0 = {
+	.name          = "snd_pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101000,
+			.end   = 0x18101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 144,
+			.end   = 144,
+		},
+	},
+	.dev.platform_data = &pcm_player_0_info,
+};
+
+struct snd_stm_pcm_player_info pcm_player_1_info = {
+	.name = "PCM player #1",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 1,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 1,
+	.channels = 2,
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "snd_pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101800,
+			.end   = 0x18101827,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 145,
+			.end   = 145,
+		},
+	},
+	.dev.platform_data = &pcm_player_1_info,
+};
+
+/* SPDIF player */
+
+struct snd_stm_spdif_player_info spdif_player_info = {
+	.name = "SPDIF player",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 2,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 2,
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+};
+
+static struct platform_device spdif_player = {
+	.name          = "snd_spdif_player",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103000,
+			.end   = 0x1810303f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 147,
+			.end   = 147,
+		},
+	},
+	.dev.platform_data = &spdif_player_info,
+};
+
+/* HDMI-connected I2S to SPDIF converter */
+
+static struct snd_stm_conv_i2sspdif_info conv_i2sspdif_info = {
+	.name = "I2S to SPDIF converter",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 0,
+	.source_bus_id = "snd_pcm_player.0",
+};
+
+static struct platform_device conv_i2sspdif = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103800,
+			.end   = 0x18103a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 142,
+			.end   = 142,
+		},
+	},
+	.dev.platform_data = &conv_i2sspdif_info,
+};
+
+/* PCM reader */
+
+struct snd_stm_pcm_reader_info pcm_reader_info = {
+	.name = "PCM reader",
+	/* .ver = see snd_stm_stx710x_init() */
+	.card_device = 3,
+	.channels = 2,
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+};
+
+static struct platform_device pcm_reader = {
+	.name          = "snd_pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18102000,
+			.end   = 0x18102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 146,
+			.end   = 146,
+		},
+	},
+	.dev.platform_data = &pcm_reader_info,
+};
+
+static struct platform_device *snd_stm_stx710x_devices[] = {
+	&stx710x_glue,
+	&fsynth,
+	&pcm_player_0,
+	&pcm_player_1,
+	&conv_int_dac,
+	&spdif_player,
+	&conv_i2sspdif,
+	&pcm_reader,
+};
+
+
+
+/*
+ * Audio glue driver implementation
+ */
+
+struct snd_stm_stx710x_glue {
+	int ver;
+
+	struct resource *mem_region;
+	void *base;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+static void snd_stm_stx710x_glue_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_stx710x_glue *stx710x_glue = entry->private_data;
+
+	snd_assert(stx710x_glue, return);
+	snd_stm_magic_assert(stx710x_glue, return);
+
+	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
+			get__710X_AUDCFG_IO_CTRL(stx710x_glue));
+}
+
+static int __init snd_stm_stx710x_glue_register(struct snd_device *snd_device)
+{
+	struct snd_stm_stx710x_glue *stx710x_glue = snd_device->device_data;
+
+	snd_assert(stx710x_glue, return -EINVAL);
+	snd_stm_magic_assert(stx710x_glue, return -EINVAL);
+
+	/* Enable audio outputs */
+
+	set__710X_AUDCFG_IO_CTRL(stx710x_glue,
+		mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx710x_glue));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&stx710x_glue->proc_entry, "stx710x_glue",
+			snd_stm_stx710x_glue_dump_registers, stx710x_glue);
+
+	return 0;
+}
+
+static int __exit snd_stm_stx710x_glue_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_stx710x_glue *stx710x_glue = snd_device->device_data;
+
+	snd_assert(stx710x_glue, return -EINVAL);
+	snd_stm_magic_assert(stx710x_glue, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(stx710x_glue->proc_entry);
+
+	/* Disable audio outputs */
+
+	set__710X_AUDCFG_IO_CTRL(stx710x_glue,
+		mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(stx710x_glue) |
+		mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(stx710x_glue));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_stx710x_glue_snd_device_ops = {
+	.dev_register = snd_stm_stx710x_glue_register,
+	.dev_disconnect = snd_stm_stx710x_glue_disconnect,
+};
+
+static int __init snd_stm_stx710x_glue_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_stx710x_glue *stx710x_glue;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	stx710x_glue = kzalloc(sizeof(*stx710x_glue), GFP_KERNEL);
+	if (!stx710x_glue) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(stx710x_glue);
+
+	result = snd_stm_memory_request(pdev, &stx710x_glue->mem_region,
+			&stx710x_glue->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* ALSA component */
+
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
+			stx710x_glue, &snd_stm_stx710x_glue_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, stx710x_glue);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(stx710x_glue->mem_region, stx710x_glue->base);
+error_memory_request:
+	snd_stm_magic_clear(stx710x_glue);
+	kfree(stx710x_glue);
+error_alloc:
+	return result;
+}
+
+static int __exit snd_stm_stx710x_glue_remove(struct platform_device *pdev)
+{
+	struct snd_stm_stx710x_glue *stx710x_glue =
+			platform_get_drvdata(pdev);
+
+	snd_assert(stx710x_glue, return -EINVAL);
+	snd_stm_magic_assert(stx710x_glue, return -EINVAL);
+
+	snd_stm_memory_release(stx710x_glue->mem_region, stx710x_glue->base);
+
+	snd_stm_magic_clear(stx710x_glue);
+	kfree(stx710x_glue);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_stx710x_glue_driver = {
+	.driver = {
+		.name = "snd_stx710x_glue",
+	},
+	.probe = snd_stm_stx710x_glue_probe,
+	.remove = snd_stm_stx710x_glue_remove,
+};
+
+
+
+/*
+ * Audio initialization
+ */
+
+static int __init snd_stm_stx710x_init(void)
+{
+	int result;
+	const char *soc_type;
+	struct snd_card *card;
+
+	snd_stm_printd(0, "snd_stm_stx710x_init()\n");
+
+	switch (cpu_data->type) {
+	case CPU_STB7100:
+		soc_type = "STx7100";
+
+		/* FDMA request line configuration */
+		pcm_player_0_info.fdma_request_line = 26;
+		pcm_player_1_info.fdma_request_line = 27;
+		spdif_player_info.fdma_request_line = 29;
+		pcm_reader_info.fdma_request_line = 28;
+
+		/* IP versions */
+		fsynth_info.ver = 1;
+		pcm_reader_info.ver = 1;
+		if (cpu_data->cut_major < 3) {
+			/* STx7100 cut < 3.0 */
+			pcm_player_0_info.ver = 1;
+			pcm_player_1_info.ver = 1;
+		} else {
+			/* STx7100 cut >= 3.0 */
+			pcm_player_0_info.ver = 2;
+			pcm_player_1_info.ver = 2;
+		}
+		conv_int_dac_info.ver = 1;
+		spdif_player_info.ver = 1;
+		conv_i2sspdif_info.ver = 1;
+
+		break;
+
+	case CPU_STB7109:
+		soc_type = "STx7109";
+
+		/* FDMA request line configuration */
+		pcm_player_0_info.fdma_request_line = 24;
+		pcm_player_1_info.fdma_request_line = 25;
+		spdif_player_info.fdma_request_line = 27;
+		pcm_reader_info.fdma_request_line = 26;
+
+		/* IP versions */
+		fsynth_info.ver = 2;
+		pcm_reader_info.ver = 2;
+		if (cpu_data->cut_major < 3) {
+			/* STx7109 cut < 3.0 */
+			pcm_player_0_info.ver = 3;
+			pcm_player_1_info.ver = 3;
+		} else {
+			/* STx7109 cut >= 3.0 */
+			pcm_player_0_info.ver = 4;
+			pcm_player_1_info.ver = 4;
+		}
+		conv_int_dac_info.ver = 2;
+		spdif_player_info.ver = 2;
+		conv_i2sspdif_info.ver = 2;
+
+		break;
+
+	default:
+		snd_stm_printe("Not supported (other than STx7100 or STx7109)"
+				" SOC detected!\n");
+		result = -EINVAL;
+		goto error_soc_type;
+	}
+
+	result = platform_driver_register(&snd_stm_stx710x_glue_driver);
+	if (result != 0) {
+		snd_stm_printe("Failed to register audio glue driver!\n");
+		goto error_driver_register;
+	}
+
+	card = snd_stm_card_new(index, id, THIS_MODULE);
+	if (card == NULL) {
+		snd_stm_printe("ALSA card creation failed!\n");
+		result = -ENOMEM;
+		goto error_card_new;
+	}
+	strcpy(card->driver, soc_type);
+	snprintf(card->shortname, 31, "%s audio subsystem", soc_type);
+	snprintf(card->longname, 79, "STMicroelectronics %s cut %d.%d SOC "
+			"audio subsystem", soc_type, cpu_data->cut_major,
+			cpu_data->cut_minor);
+
+	result = snd_stm_add_plaform_devices(snd_stm_stx710x_devices,
+			ARRAY_SIZE(snd_stm_stx710x_devices));
+	if (result != 0) {
+		snd_stm_printe("Failed to add platform devices!\n");
+		goto error_add_devices;
+	}
+
+	result = snd_stm_card_register();
+	if (result != 0) {
+		snd_stm_printe("Failed to register ALSA cards!\n");
+		goto error_card_register;
+	}
+
+	return 0;
+
+error_card_register:
+	snd_stm_remove_plaform_devices(snd_stm_stx710x_devices,
+			ARRAY_SIZE(snd_stm_stx710x_devices));
+error_add_devices:
+	snd_stm_card_free();
+error_card_new:
+	platform_driver_unregister(&snd_stm_stx710x_glue_driver);
+error_driver_register:
+error_soc_type:
+	return result;
+}
+
+static void __exit snd_stm_stx710x_exit(void)
+{
+	snd_stm_printd(0, "snd_stm_stx710x_exit()\n");
+
+	snd_stm_card_free();
+
+	snd_stm_remove_plaform_devices(snd_stm_stx710x_devices,
+			ARRAY_SIZE(snd_stm_stx710x_devices));
+
+	platform_driver_unregister(&snd_stm_stx710x_glue_driver);
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STx710x audio driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_stx710x_init);
+module_exit(snd_stm_stx710x_exit);
diff --git a/sound/stm/stx7111.c b/sound/stm/stx7111.c
new file mode 100644
index 0000000..a0f7f6e
--- /dev/null
+++ b/sound/stm/stx7111.c
@@ -0,0 +1,591 @@
+/*
+ *   STMicrolectronics STx7111 SoC description & audio glue driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#define COMPONENT stx7111
+#include "common.h"
+#include "reg_7111_audcfg.h"
+
+
+
+/*
+ * ALSA module parameters
+ */
+
+static int index = -1; /* First available index */
+static char *id = "STx7111"; /* Default card ID */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for STx7111 audio subsystem card.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for STx7111 audio subsystem card.");
+
+
+
+/*
+ * Audio subsystem components & platform devices
+ */
+
+/* STx7111 audio glue */
+
+static struct platform_device stx7111_glue = {
+	.name          = "snd_stx7111_glue",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210200,
+			.end   = 0xfe21020b,
+		},
+	}
+};
+
+/* Frequency synthesizers */
+
+static struct platform_device fsynth = {
+	.name          = "snd_fsynth",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210000,
+			.end   = 0xfe21004f,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.ver = 4,
+		.channels_from = 0,
+		.channels_to = 2,
+	},
+};
+
+/* Internal DACs */
+
+static struct platform_device conv_int_dac = {
+	.name          = "snd_conv_int_dac",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210100,
+			.end   = 0xfe210103,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_conv_int_dac_info) {
+		.name = "Internal audio DAC",
+		.ver = 4,
+		.card_device = 1,
+		.source_bus_id = "snd_pcm_player.1",
+	},
+};
+
+/* PCM players  */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "snd_pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104d00,
+			.end   = 0xfd104d27,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1400),
+			.end   = evt2irq(0x1400),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #0",
+		.ver = 6,
+		.card_device = 0,
+		.fsynth_bus_id = "snd_fsynth",
+		.fsynth_output = 0,
+		.channels = 8,
+		.fdma_initiator = 0,
+		.fdma_request_line = 27,
+	},
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "snd_pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd101800,
+			.end   = 0xfd101827,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1420),
+			.end   = evt2irq(0x1420),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #1",
+		.ver = 6,
+		.card_device = 1,
+		.fsynth_bus_id = "snd_fsynth",
+		.fsynth_output = 1,
+		.channels = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 28,
+	},
+};
+
+/*
+ * SPDIF player
+ */
+
+static struct platform_device spdif_player = {
+	.name          = "snd_spdif_player",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104c00,
+			.end   = 0xfd104c43,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1460),
+			.end   = evt2irq(0x1460),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player",
+		.ver = 4,
+		.card_device = 2,
+		.fsynth_bus_id = "snd_fsynth",
+		.fsynth_output = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 30,
+	},
+};
+
+/* I2S to SPDIF converters */
+
+static struct platform_device conv_i2sspdif_0 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105000,
+			.end   = 0xfd105223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x13c0),
+			.end   = evt2irq(0x13c0),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #0",
+		.ver = 4,
+		.card_device = 0,
+		.source_bus_id = "snd_pcm_player.0",
+	},
+};
+
+static struct platform_device conv_i2sspdif_1 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105400,
+			.end   = 0xfd105623,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0a80),
+			.end   = evt2irq(0x0a80),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #1",
+		.ver = 4,
+		.card_device = 0,
+		.source_bus_id = "snd_pcm_player.0",
+	},
+};
+
+static struct platform_device conv_i2sspdif_2 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105800,
+			.end   = 0xfd105a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0b00),
+			.end   = evt2irq(0x0b00),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #2",
+		.ver = 4,
+		.card_device = 0,
+		.source_bus_id = "snd_pcm_player.0",
+	},
+};
+
+static struct platform_device conv_i2sspdif_3 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105c00,
+			.end   = 0xfd105e23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0b20),
+			.end   = evt2irq(0x0b20),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #3",
+		.ver = 4,
+		.card_device = 0,
+		.source_bus_id = "snd_pcm_player.0",
+	},
+};
+
+/* PCM reader */
+
+#if 0 /* MB618 has no audio input, so there is no way to test it... */
+static struct platform_device pcm_reader = {
+	.name          = "snd_pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd102000,
+			.end   = 0xfd102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1440),
+			.end   = evt2irq(0x1440),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
+		.name = "PCM reader",
+		.ver = 4,
+		.card_device = 3,
+		.channels = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 29,
+	},
+};
+#endif
+
+static struct platform_device *snd_stm_stx7111_devices[] = {
+	&stx7111_glue,
+	&fsynth,
+	&conv_int_dac,
+	&pcm_player_0,
+	&pcm_player_1,
+	&spdif_player,
+	&conv_i2sspdif_0,
+	&conv_i2sspdif_1,
+	&conv_i2sspdif_2,
+	&conv_i2sspdif_3,
+#if 0 /* MB618 has no audio input, so there is no way to test it... */
+	&pcm_reader,
+#endif
+};
+
+
+
+/*
+ * Audio glue driver implementation
+ */
+
+struct snd_stm_stx7111_glue {
+	int ver;
+
+	struct resource *mem_region;
+	void *base;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+static void snd_stm_stx7111_glue_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_stx7111_glue *stx7111_glue = entry->private_data;
+
+	snd_assert(stx7111_glue, return);
+	snd_stm_magic_assert(stx7111_glue, return);
+
+	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
+			get__7111_AUDCFG_IO_CTRL(stx7111_glue));
+}
+
+static int __init snd_stm_stx7111_glue_register(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7111_glue *stx7111_glue = snd_device->device_data;
+
+	snd_assert(stx7111_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7111_glue, return -EINVAL);
+
+	/* Enable audio outputs */
+
+	set__7111_AUDCFG_IO_CTRL(stx7111_glue,
+		mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(stx7111_glue) |
+		mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(stx7111_glue) |
+		mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx7111_glue));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&stx7111_glue->proc_entry, "stx7111_glue",
+			snd_stm_stx7111_glue_dump_registers, stx7111_glue);
+
+	return 0;
+}
+
+static int __exit snd_stm_stx7111_glue_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7111_glue *stx7111_glue = snd_device->device_data;
+
+	snd_assert(stx7111_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7111_glue, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(stx7111_glue->proc_entry);
+
+	/* Disable audio outputs */
+
+	set__7111_AUDCFG_IO_CTRL(stx7111_glue,
+		mask__7111_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(stx7111_glue) |
+		mask__7111_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(stx7111_glue) |
+		mask__7111_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx7111_glue));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_stx7111_glue_snd_device_ops = {
+	.dev_register = snd_stm_stx7111_glue_register,
+	.dev_disconnect = snd_stm_stx7111_glue_disconnect,
+};
+
+static int __init snd_stm_stx7111_glue_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_stx7111_glue *stx7111_glue;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	stx7111_glue = kzalloc(sizeof(*stx7111_glue), GFP_KERNEL);
+	if (!stx7111_glue) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(stx7111_glue);
+
+	result = snd_stm_memory_request(pdev, &stx7111_glue->mem_region,
+			&stx7111_glue->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* ALSA component */
+
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
+			stx7111_glue, &snd_stm_stx7111_glue_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, stx7111_glue);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(stx7111_glue->mem_region, stx7111_glue->base);
+error_memory_request:
+	snd_stm_magic_clear(stx7111_glue);
+	kfree(stx7111_glue);
+error_alloc:
+	return result;
+}
+
+static int __exit snd_stm_stx7111_glue_remove(struct platform_device *pdev)
+{
+	struct snd_stm_stx7111_glue *stx7111_glue =
+			platform_get_drvdata(pdev);
+
+	snd_assert(stx7111_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7111_glue, return -EINVAL);
+
+	snd_stm_memory_release(stx7111_glue->mem_region, stx7111_glue->base);
+
+	snd_stm_magic_clear(stx7111_glue);
+	kfree(stx7111_glue);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_stx7111_glue_driver = {
+	.driver = {
+		.name = "snd_stx7111_glue",
+	},
+	.probe = snd_stm_stx7111_glue_probe,
+	.remove = snd_stm_stx7111_glue_remove,
+};
+
+
+
+/*
+ * Audio initialization
+ */
+
+static int __init snd_stm_stx7111_init(void)
+{
+	int result;
+	struct snd_card *card;
+
+	snd_stm_printd(0, "snd_stm_stx7111_init()\n");
+
+	/* TODO: 7111 is identified now as ST40-300... */
+	if (cpu_data->type != CPU_ST40_300) {
+		snd_stm_printe("Not supported (other than STx7111) SOC "
+				"detected!\n");
+		result = -EINVAL;
+		goto error_soc_type;
+	}
+
+	/* Cut 2.0 presumably will bring something new into the
+	 * matter, so above configuration must be checked!
+	 * - transfer_sizes (FIFO sizes has changed) */
+	WARN_ON(cpu_data->cut_major > 1);
+
+	/* Ugly but quick hack to have SPDIF player & I2S to SPDIF
+	 * converters enabled without loading STMFB...
+	 * TODO: do this in some sane way! */
+	{
+		void *hdmi_gpout = ioremap(0xfd104020, 4);
+		writel(readl(hdmi_gpout) | 0x3, hdmi_gpout);
+		iounmap(hdmi_gpout);
+	}
+
+	result = platform_driver_register(&snd_stm_stx7111_glue_driver);
+	result = 0;
+	if (result != 0) {
+		snd_stm_printe("Failed to register audio glue driver!\n");
+		goto error_driver_register;
+	}
+
+	card = snd_stm_card_new(index, id, THIS_MODULE);
+	if (card == NULL) {
+		snd_stm_printe("ALSA card creation failed!\n");
+		result = -ENOMEM;
+		goto error_card_new;
+	}
+	strcpy(card->driver, "STx7111");
+	strcpy(card->shortname, "STx7111 audio subsystem");
+	snprintf(card->longname, 79, "STMicroelectronics STx7111 cut %d "
+			"SOC audio subsystem", cpu_data->cut_major);
+
+	result = snd_stm_add_plaform_devices(snd_stm_stx7111_devices,
+			ARRAY_SIZE(snd_stm_stx7111_devices));
+	if (result != 0) {
+		snd_stm_printe("Failed to add platform devices!\n");
+		goto error_add_devices;
+	}
+
+	result = snd_stm_card_register();
+	if (result != 0) {
+		snd_stm_printe("Failed to register ALSA cards!\n");
+		goto error_card_register;
+	}
+
+	return 0;
+
+error_card_register:
+	snd_stm_remove_plaform_devices(snd_stm_stx7111_devices,
+			ARRAY_SIZE(snd_stm_stx7111_devices));
+error_add_devices:
+	snd_stm_card_free();
+error_card_new:
+	platform_driver_unregister(&snd_stm_stx7111_glue_driver);
+error_driver_register:
+error_soc_type:
+	return result;
+}
+
+static void __exit snd_stm_stx7111_exit(void)
+{
+	snd_stm_printd(0, "snd_stm_stx7111_exit()\n");
+
+	snd_stm_card_free();
+
+	snd_stm_remove_plaform_devices(snd_stm_stx7111_devices,
+			ARRAY_SIZE(snd_stm_stx7111_devices));
+
+	platform_driver_unregister(&snd_stm_stx7111_glue_driver);
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STx7111 audio driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_stx7111_init);
+module_exit(snd_stm_stx7111_exit);
diff --git a/sound/stm/stx7200.c b/sound/stm/stx7200.c
new file mode 100644
index 0000000..cf5e154
--- /dev/null
+++ b/sound/stm/stx7200.c
@@ -0,0 +1,887 @@
+/*
+ *   STMicrolectronics STx7200 SoC description & audio glue driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/irq-ilc.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#define COMPONENT stx7200
+#include "common.h"
+#include "reg_7200_audcfg.h"
+
+
+
+/*
+ * ALSA module parameters
+ */
+
+static int index = -1; /* First available index */
+static char *id = "STx7200"; /* Default card ID */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for STx7200 audio subsystem card.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for STx7200 audio subsystem card.");
+
+
+
+/*
+ * Audio subsystem components & platform devices
+ */
+
+/* STx7200 audio glue */
+
+static struct platform_device stx7200 = {
+	.name          = "snd_stx7200_glue",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601200,
+			.end   = 0xfd60120b,
+		},
+	}
+};
+
+/* Frequency synthesizers */
+
+static struct platform_device fsynth_0 = {
+	.name          = "snd_fsynth",
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601000,
+			.end   = 0xfd60104f,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		/* .ver = see snd_stm_stx7200_init() */
+		.channels_from = 0,
+		.channels_to = 3,
+	},
+};
+
+static struct platform_device fsynth_1 = {
+	.name          = "snd_fsynth",
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601100,
+			.end   = 0xfd60114f,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		/* .ver = see snd_stm_stx7200_init() */
+		.channels_from = 2,
+		.channels_to = 3,
+	},
+};
+
+/* Internal DACs */
+
+static struct platform_device conv_int_dac_0 = {
+	.name          = "snd_conv_int_dac",
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601400,
+			.end   = 0xfd601403,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_conv_int_dac_info) {
+		.name = "Internal audio DAC #0",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 0,
+		.source_bus_id = "snd_pcm_player.0",
+	},
+};
+
+static struct platform_device conv_int_dac_1 = {
+	.name          = "snd_conv_int_dac",
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601500,
+			.end   = 0xfd601503,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_conv_int_dac_info) {
+		.name = "Internal audio DAC #1 (slave)",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 1,
+		.source_bus_id = "snd_pcm_player.1",
+	},
+};
+
+/* PCM players connected to internal DACs */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "snd_pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd101000,
+			.end   = 0xfd101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(39),
+			.end   = ILC_IRQ(39),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #0",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 0,
+		.fsynth_bus_id = "snd_fsynth.0",
+		.fsynth_output = 0,
+		.channels = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 33,
+	},
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "snd_pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd102000,
+			.end   = 0xfd102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(40),
+			.end   = ILC_IRQ(40),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #1",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 1,
+		.fsynth_bus_id = "snd_fsynth.0",
+		.fsynth_output = 1,
+		.channels = 6,
+		.fdma_initiator = 0,
+		.fdma_request_line = 34,
+	},
+};
+
+/* PCM players with digital outputs */
+
+static struct platform_device pcm_player_2 = {
+	.name          = "snd_pcm_player",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd103000,
+			.end   = 0xfd103027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(41),
+			.end   = ILC_IRQ(41),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #2",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 2,
+		.fsynth_bus_id = "snd_fsynth.0",
+		.fsynth_output = 2,
+		.channels = 8,
+		.fdma_initiator = 0,
+		.fdma_request_line = 35,
+	},
+};
+
+static struct platform_device pcm_player_3 = {
+	.name          = "snd_pcm_player",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104000,
+			.end   = 0xfd104027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(42),
+			.end   = ILC_IRQ(42),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #3",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 3,
+		.fsynth_bus_id = "snd_fsynth.0",
+		.fsynth_output = 3,
+		.channels = 10,
+		.fdma_initiator = 0,
+		.fdma_request_line = 36,
+	},
+};
+
+/* SPDIF player */
+
+static struct platform_device spdif_player = {
+	.name          = "snd_spdif_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105000,
+			/* .end = see snd_stm_stx7200_init() */
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(37),
+			.end   = ILC_IRQ(37),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 5,
+		.fsynth_bus_id = "snd_fsynth.1",
+		.fsynth_output = 3,
+		.fdma_initiator = 0,
+		.fdma_request_line = 38,
+	},
+};
+
+/* HDMI output devices
+ * Cut 1.0: Please note that "HDTVOutBaseAddress" (0xFD10C000) from page 54
+ * of "7200 Programming Manual, Volume 2" is wrong. The correct HDMI players
+ * subsystem base address is "HDMIPlayerBaseAddress" (0xFD106000) from
+ * page 488 of the manual.
+ * Cut 2.0: HDTVout IP is identical to STx7111's one and the base address
+ * is 0xFD112000. */
+
+static struct platform_device hdmi_pcm_player = {
+	.name          = "snd_pcm_player",
+	.id            = 4, /* HDMI PCM player is no. 4 */
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			/* .start = see snd_stm_stx7200_init() */
+			/* .end = see snd_stm_stx7200_init() */
+			.start = 0xfd112d00,
+			.end   = 0xfd112d27,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(62),
+			.end   = ILC_IRQ(62),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player HDMI",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 4,
+		.fsynth_bus_id = "snd_fsynth.1",
+		.fsynth_output = 2,
+		.channels = 8,
+		.fdma_initiator = 0,
+		.fdma_request_line = 39,
+	},
+};
+
+static struct platform_device hdmi_spdif_player = {
+	.name          = "snd_spdif_player",
+	.id            = 1, /* HDMI SPDIF player is no. 1 */
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			/* .start = see snd_stm_stx7200_init() */
+			/* .end = see snd_stm_stx7200_init() */
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(63),
+			.end   = ILC_IRQ(63),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player HDMI",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 6,
+		.fsynth_bus_id = "snd_fsynth.1",
+		.fsynth_output = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 40,
+	},
+};
+
+/* Not available in cut 1.0! */
+static struct platform_device hdmi_conv_i2sspdif_0 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd113000,
+			.end   = 0xfd113223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(64),
+			.end   = ILC_IRQ(64),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #0",
+		.ver = 4,
+		.card_device = 4,
+		.source_bus_id = "snd_pcm_player.4",
+	},
+};
+
+/* Not available in cut 1.0! */
+static struct platform_device hdmi_conv_i2sspdif_1 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd113400,
+			.end   = 0xfd113623,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(65),
+			.end   = ILC_IRQ(65),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #1",
+		.ver = 4,
+		.card_device = 4,
+		.source_bus_id = "snd_pcm_player.4",
+	},
+};
+
+/* Not available in cut 1.0! */
+static struct platform_device hdmi_conv_i2sspdif_2 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd113800,
+			.end   = 0xfd113a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(66),
+			.end   = ILC_IRQ(66),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #2",
+		.ver = 4,
+		.card_device = 4,
+		.source_bus_id = "snd_pcm_player.4",
+	},
+};
+
+/* Not available in cut 1.0! */
+static struct platform_device hdmi_conv_i2sspdif_3 = {
+	.name          = "snd_conv_i2sspdif",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd113c00,
+			.end   = 0xfd113e23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(67),
+			.end   = ILC_IRQ(67),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2sspdif_info) {
+		.name = "I2S to SPDIF converter #3",
+		.ver = 4,
+		.card_device = 4,
+		.source_bus_id = "snd_pcm_player.4",
+	},
+};
+
+/* PCM readers */
+
+static struct platform_device pcm_reader_0 = {
+	.name          = "snd_pcm_reader",
+	/* .id = see snd_stm_stx7200_init() */
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd100000,
+			.end   = 0xfd100027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(38),
+			.end   = ILC_IRQ(38),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
+		.name = "PCM reader",
+		/* .ver = see snd_stm_stx7200_init() */
+		.card_device = 7,
+		.channels = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 37,
+	},
+};
+
+/* Not available in cut 1.0! */
+static struct platform_device pcm_reader_1 = {
+	.name          = "snd_pcm_reader",
+	.id = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd114000,
+			.end   = 0xfd114027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(35),
+			.end   = ILC_IRQ(35),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
+		.name = "PCM reader",
+		.ver = 5,
+		.card_device = 8,
+		.channels = 8,
+		.fdma_initiator = 0,
+		.fdma_request_line = 51,
+	},
+};
+
+
+
+static struct platform_device *snd_stm_stx7200_devices[] = {
+	&stx7200,
+	&fsynth_0,
+	&fsynth_1,
+	&conv_int_dac_0,
+	&conv_int_dac_1,
+	&pcm_player_0,
+	&pcm_player_1,
+	&pcm_player_2,
+	&pcm_player_3,
+	&spdif_player,
+	&hdmi_pcm_player,
+	&hdmi_spdif_player,
+	&pcm_reader_0,
+};
+
+static struct platform_device *snd_stm_stx7200c2_devices[] = {
+	&hdmi_conv_i2sspdif_0,
+	&hdmi_conv_i2sspdif_1,
+	&hdmi_conv_i2sspdif_2,
+	&hdmi_conv_i2sspdif_3,
+	&pcm_reader_1,
+};
+
+
+
+/*
+ * Audio glue driver implementation
+ */
+
+struct snd_stm_stx7200_glue {
+	int ver;
+
+	struct resource *mem_region;
+	void *base;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+static void snd_stm_stx7200_glue_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_stx7200_glue *stx7200_glue = entry->private_data;
+
+	snd_assert(stx7200_glue, return);
+	snd_stm_magic_assert(stx7200_glue, return);
+
+	snd_iprintf(buffer, "AUDCFG_IOMUX_CTRL (offset 0x00) = 0x%08x\n",
+			get__7200_AUDCFG_IOMUX_CTRL(stx7200_glue));
+	snd_iprintf(buffer, "AUDCFG_HDMI_CTRL (offset 0x04) = 0x%08x\n",
+			get__7200_AUDCFG_HDMI_CTRL(stx7200_glue));
+	snd_iprintf(buffer, "AUDCFG_RECOVERY_CTRL (offset 0x08) = 0x%08x\n",
+			get__7200_AUDCFG_RECOVERY_CTRL(stx7200_glue));
+}
+
+static int __init snd_stm_stx7200_glue_register(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7200_glue *stx7200_glue = snd_device->device_data;
+
+	snd_assert(stx7200_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7200_glue, return -EINVAL);
+
+	/* Enable audio outputs */
+
+	set__7200_AUDCFG_IOMUX_CTRL(stx7200_glue,
+		mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__ENABLE(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__OUTPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__OUTPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__OUTPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__OUTPUT(stx7200_glue));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&stx7200_glue->proc_entry, "stx7200_glue",
+			snd_stm_stx7200_glue_dump_registers, stx7200_glue);
+
+	return 0;
+}
+
+static int __exit snd_stm_stx7200_glue_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7200_glue *stx7200_glue = snd_device->device_data;
+
+	snd_assert(stx7200_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7200_glue, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(stx7200_glue->proc_entry);
+
+	/* Disable audio outputs */
+
+	set__7200_AUDCFG_IOMUX_CTRL(stx7200_glue,
+		mask__7200_AUDCFG_IOMUX_CTRL__SPDIF_EN__DISABLE(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA2_EN__INPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA1_EN__INPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__DATA0_EN__INPUT(stx7200_glue) |
+		mask__7200_AUDCFG_IOMUX_CTRL__PCM_CLK_EN__INPUT(stx7200_glue));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_stx7200_glue_snd_device_ops = {
+	.dev_register = snd_stm_stx7200_glue_register,
+	.dev_disconnect = snd_stm_stx7200_glue_disconnect,
+};
+
+static int __init snd_stm_stx7200_glue_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_stx7200_glue *stx7200_glue;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	stx7200_glue = kzalloc(sizeof(*stx7200_glue), GFP_KERNEL);
+	if (!stx7200_glue) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(stx7200_glue);
+
+	result = snd_stm_memory_request(pdev, &stx7200_glue->mem_region,
+			&stx7200_glue->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* ALSA component */
+
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
+			stx7200_glue, &snd_stm_stx7200_glue_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, stx7200_glue);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(stx7200_glue->mem_region, stx7200_glue->base);
+error_memory_request:
+	snd_stm_magic_clear(stx7200_glue);
+	kfree(stx7200_glue);
+error_alloc:
+	return result;
+}
+
+static int __exit snd_stm_stx7200_glue_remove(struct platform_device *pdev)
+{
+	struct snd_stm_stx7200_glue *stx7200_glue =
+			platform_get_drvdata(pdev);
+
+	snd_assert(stx7200_glue, return -EINVAL);
+	snd_stm_magic_assert(stx7200_glue, return -EINVAL);
+
+	snd_stm_memory_release(stx7200_glue->mem_region, stx7200_glue->base);
+
+	snd_stm_magic_clear(stx7200_glue);
+	kfree(stx7200_glue);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_stx7200_glue_driver = {
+	.driver = {
+		.name = "snd_stx7200_glue",
+	},
+	.probe = snd_stm_stx7200_glue_probe,
+	.remove = snd_stm_stx7200_glue_remove,
+};
+
+
+
+/*
+ * Audio initialization
+ */
+
+#define SET_VER(_info_struct_, _device_, _ver_) \
+		(((struct _info_struct_ *)_device_.dev.platform_data)->ver = \
+		_ver_)
+
+static int __init snd_stm_stx7200_init(void)
+{
+	int result;
+	struct snd_card *card;
+
+	snd_stm_printd(0, "snd_stm_stx7200_init()\n");
+
+	if (cpu_data->type != CPU_STX7200) {
+		snd_stm_printe("Not supported (other than STx7200) SOC "
+				"detected!\n");
+		result = -EINVAL;
+		goto error_soc_type;
+	}
+
+	/* We assume farther that MEM resource is first, lets check it... */
+	snd_assert(spdif_player.resource[0].flags == IORESOURCE_MEM,
+			return -EINVAL);
+	snd_assert(hdmi_pcm_player.resource[0].flags == IORESOURCE_MEM,
+			return -EINVAL);
+	snd_assert(hdmi_spdif_player.resource[0].flags == IORESOURCE_MEM,
+			return -EINVAL);
+
+	switch (cpu_data->cut_major) {
+	case 1:
+		SET_VER(snd_stm_fsynth_info, fsynth_0, 3);
+		SET_VER(snd_stm_fsynth_info, fsynth_1, 3);
+
+		SET_VER(snd_stm_conv_int_dac_info, conv_int_dac_0, 3);
+		SET_VER(snd_stm_conv_int_dac_info, conv_int_dac_1, 3);
+
+		SET_VER(snd_stm_pcm_player_info, pcm_player_0, 5);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_1, 5);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_2, 5);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_3, 5);
+
+		SET_VER(snd_stm_spdif_player_info, spdif_player, 3);
+		spdif_player.resource[0].end = 0xfd10503f;
+
+		SET_VER(snd_stm_pcm_player_info, hdmi_pcm_player, 5);
+		hdmi_pcm_player.resource[0].start = 0xfd106d00;
+		hdmi_pcm_player.resource[0].end = 0xfd106d27;
+
+		SET_VER(snd_stm_spdif_player_info, hdmi_spdif_player, 3);
+		hdmi_spdif_player.resource[0].start = 0xfd106c00;
+		hdmi_spdif_player.resource[0].end = 0xfd106c3f;
+
+		SET_VER(snd_stm_pcm_reader_info, pcm_reader_0, 3);
+		pcm_reader_0.id = -1; /* Only one reader */
+
+		break;
+
+	case 2:
+		SET_VER(snd_stm_fsynth_info, fsynth_0, 5);
+		SET_VER(snd_stm_fsynth_info, fsynth_1, 5);
+
+		SET_VER(snd_stm_conv_int_dac_info, conv_int_dac_0, 4);
+		SET_VER(snd_stm_conv_int_dac_info, conv_int_dac_1, 4);
+
+		SET_VER(snd_stm_pcm_player_info, pcm_player_0, 6);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_1, 6);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_2, 6);
+		SET_VER(snd_stm_pcm_player_info, pcm_player_3, 6);
+
+		SET_VER(snd_stm_spdif_player_info, spdif_player, 4);
+		spdif_player.resource[0].end = 0xfd105043;
+
+		SET_VER(snd_stm_pcm_player_info, hdmi_pcm_player, 6);
+		hdmi_pcm_player.resource[0].start = 0xfd112d00;
+		hdmi_pcm_player.resource[0].end = 0xfd112d27;
+
+		SET_VER(snd_stm_spdif_player_info, hdmi_spdif_player, 4);
+		hdmi_spdif_player.resource[0].start = 0xfd112c00;
+		hdmi_spdif_player.resource[0].end = 0xfd112c43;
+
+		SET_VER(snd_stm_pcm_reader_info, pcm_reader_0, 5);
+		pcm_reader_0.id = 0;
+		SET_VER(snd_stm_pcm_reader_info, pcm_reader_1, 5);
+
+		break;
+
+	default:
+		snd_stm_printe("Not supported STx7200 cut %d detected!\n",
+				cpu_data->cut_major);
+		return -EINVAL;
+	}
+
+	/* Ugly but quick hack to have HDMI SPDIF player & I2S to SPDIF
+	 * converters enabled without loading STMFB...
+	 * TODO: do this in some sane way! */
+	{
+		void *hdmi_gpout;
+
+		if (cpu_data->cut_major == 1)
+			hdmi_gpout = ioremap(0xfd106020, 4);
+		else
+			hdmi_gpout = ioremap(0xfd112020, 4);
+
+		writel(readl(hdmi_gpout) | 0x3, hdmi_gpout);
+		iounmap(hdmi_gpout);
+	}
+
+	result = platform_driver_register(&snd_stm_stx7200_glue_driver);
+	if (result != 0) {
+		snd_stm_printe("Failed to register audio glue driver!\n");
+		goto error_driver_register;
+	}
+
+	card = snd_stm_card_new(index, id, THIS_MODULE);
+	if (card == NULL) {
+		snd_stm_printe("ALSA card creation failed!\n");
+		result = -ENOMEM;
+		goto error_card_new;
+	}
+	strcpy(card->driver, "STx7200");
+	strcpy(card->shortname, "STx7200 audio subsystem");
+	snprintf(card->longname, 79, "STMicroelectronics STx7200 cut %d "
+			"SOC audio subsystem", cpu_data->cut_major);
+
+	result = snd_stm_add_plaform_devices(snd_stm_stx7200_devices,
+			ARRAY_SIZE(snd_stm_stx7200_devices));
+	if (result != 0) {
+		snd_stm_printe("Failed to add platform devices!\n");
+		goto error_add_devices;
+	}
+
+	if (cpu_data->cut_major == 2) {
+		result = snd_stm_add_plaform_devices(snd_stm_stx7200c2_devices,
+				ARRAY_SIZE(snd_stm_stx7200c2_devices));
+		if (result != 0) {
+			snd_stm_printe("Failed to add cut 2 platform "
+					"devices!\n");
+			goto error_add_devices_c2;
+		}
+	}
+
+	result = snd_stm_card_register();
+	if (result != 0) {
+		snd_stm_printe("Failed to register ALSA cards (%d)!\n", result);
+		goto error_card_register;
+	}
+
+	return 0;
+
+error_card_register:
+	if (cpu_data->cut_major == 2)
+		snd_stm_remove_plaform_devices(snd_stm_stx7200c2_devices,
+				ARRAY_SIZE(snd_stm_stx7200c2_devices));
+error_add_devices_c2:
+	snd_stm_remove_plaform_devices(snd_stm_stx7200_devices,
+			ARRAY_SIZE(snd_stm_stx7200_devices));
+error_add_devices:
+	snd_stm_card_free();
+error_card_new:
+	platform_driver_unregister(&snd_stm_stx7200_glue_driver);
+error_driver_register:
+error_soc_type:
+	return result;
+}
+
+static void __exit snd_stm_stx7200_exit(void)
+{
+	snd_stm_printd(0, "snd_stm_stx7200_exit()\n");
+
+	snd_stm_card_free();
+
+	if (cpu_data->cut_major == 2)
+		snd_stm_remove_plaform_devices(snd_stm_stx7200c2_devices,
+				ARRAY_SIZE(snd_stm_stx7200c2_devices));
+
+	snd_stm_remove_plaform_devices(snd_stm_stx7200_devices,
+			ARRAY_SIZE(snd_stm_stx7200_devices));
+
+	platform_driver_unregister(&snd_stm_stx7200_glue_driver);
+}
+
+MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STx7200 audio driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_stx7200_init);
+module_exit(snd_stm_stx7200_exit);
diff --git a/sound/stm/synchro.c b/sound/stm/synchro.c
new file mode 100644
index 0000000..96336e0
--- /dev/null
+++ b/sound/stm/synchro.c
@@ -0,0 +1,50 @@
+/*
+ *   Audio playback synchronization routines for STMicroelectronics' SoCs
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+
+#define COMPONENT synchro
+#include "common.h"
+
+
+
+/*
+ * Implementation
+ */
+
+/* TODO */
+
+
+
+/*
+ * Initialization
+ */
+
+int snd_stm_synchro_init(void)
+{
+	return 0;
+}
+
+void snd_stm_synchro_exit(void)
+{
+}
