diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/assoc.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/assoc.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/assoc.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/assoc.c	2008-05-09 06:24:58.000000000 +0200
@@ -627,16 +627,15 @@ static void _rtmp_hexdump(int level, con
 			 size_t len, int show)
 {
 	size_t i;
-	if (level & RTDebugLevel) {
-		printk("%s - hexdump(len=%lu):", title, (unsigned long) len);
-		if (show) {
-			for (i = 0; i < len; i++)
-				printk(" %02x", buf[i]);
-		} else {
-			printk(" [REMOVED]");
-		}
-		printk("\n");
+
+	DBGPRINT(level, "%s - hexdump(len=%lu):", title, (unsigned long)len);
+	if (show) {
+		for (i = 0; i < len; i++)
+			DBGPRINT_RAW(level, " %02x", buf[i]);
+	} else {
+		DBGPRINT_RAW(level, " [REMOVED]");
 	}
+	DBGPRINT_RAW(level, "\n");
 }
 
 void rtmp_hexdump(int level, const char *title, const u8 *buf, size_t len)
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/auth_rsp.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/auth_rsp.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/auth_rsp.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/auth_rsp.c	2008-05-09 06:24:58.000000000 +0200
@@ -128,7 +128,9 @@ VOID PeerDeauthAction(
     {
         if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(Addr2, &pAd->PortCfg.Bssid))
         {
-            DBGPRINT(RT_DEBUG_TRACE,"AUTH_RSP - receive DE-AUTH from our AP\n");
+            DBGPRINT(RT_DEBUG_TRACE,
+					"AUTH_RSP - receive DE-AUTH from our AP Reason=%d\n",
+					le16_to_cpu(Reason));
             LinkDown(pAd, TRUE);
         }
     }
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/connect.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/connect.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/connect.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/connect.c	2008-05-09 06:53:30.000000000 +0200
@@ -618,6 +618,7 @@ VOID CntlWaitJoinProc(
 				DBGPRINT(RT_DEBUG_TRACE, "CNTL - join the IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
 					pAd->PortCfg.Bssid[0],pAd->PortCfg.Bssid[1],pAd->PortCfg.Bssid[2],
 					pAd->PortCfg.Bssid[3],pAd->PortCfg.Bssid[4],pAd->PortCfg.Bssid[5]);
+				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 			}
 			// 2. joined a new INFRA network, start from authentication
 			else
@@ -632,7 +633,7 @@ VOID CntlWaitJoinProc(
 				{
 					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeOpen);
 				}
-
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - authenticating\n");
 				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
 							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
 
@@ -643,6 +644,8 @@ VOID CntlWaitJoinProc(
 		{
 			// 3. failed, try next BSS
 			pAd->MlmeAux.BssIdx++;
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - trying next BSS - #%d\n",
+					pAd->MlmeAux.BssIdx);
 			IterateOnBssTab(pAd);
 		}
 	}
@@ -874,6 +877,7 @@ VOID LinkUp(
 		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
+
 	//
 	// ASSOC - DisassocTimeoutAction
 	// CNTL - Dis-associate successful
@@ -1016,6 +1020,7 @@ VOID LinkUp(
 	//
 	RTUSBReadMACRegister(pAd, TXRX_CSR4, &CurTxRxCsr4->word);
 	NewTxRxCsr4->word = CurTxRxCsr4->word;
+	
 	if ((pAd->PortCfg.Channel <= 14) &&
 		((pAd->PortCfg.PhyMode == PHY_11B) ||
 		 (pAd->PortCfg.PhyMode == PHY_11BG_MIXED) ||
@@ -1031,7 +1036,6 @@ VOID LinkUp(
 	if (NewTxRxCsr4->word!= CurTxRxCsr4->word)
 		RTUSBWriteMACRegister(pAd, TXRX_CSR4, NewTxRxCsr4->word);
 
-
 	pAd->Mlme.PeriodicRound = 0;		// re-schedule MlmePeriodicExec()
 	pAd->bConfigChanged = FALSE;		// Reset config flag
 	pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
@@ -1072,9 +1076,9 @@ VOID LinkDown(
 	DBGPRINT(RT_DEBUG_TRACE, "!!! LINK DOWN !!!\n");
 
 	if (!CurTxRxCsr4) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
-	} 	
+	}
 
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
 
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/mlme.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/mlme.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/mlme.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/mlme.c	2008-05-12 06:41:33.000000000 +0200
@@ -235,10 +235,13 @@ NDIS_STATUS MlmeInit(
 {
 	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
 
-	DBGPRINT(RT_DEBUG_TRACE, "--> MLME Initialize\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--> MlmeInit\n");
 
 	do
 	{
+		pAd->Mlme.Running = FALSE;
+
+		NdisAllocateSpinLock(&pAd->Mlme.Queue.Lock);
 		Status = MlmeQueueInit(&pAd->Mlme.Queue);
 		if(Status != NDIS_STATUS_SUCCESS)
 			break;
@@ -252,9 +255,6 @@ NDIS_STATUS MlmeInit(
 			break;
 		}
 
-		pAd->Mlme.bRunning = FALSE;
-		NdisAllocateSpinLock(&pAd->Mlme.TaskLock);
-
 		// initialize table
 		BssTableInit(&pAd->ScanTab);
 
@@ -279,10 +279,7 @@ NDIS_STATUS MlmeInit(
 		MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
 
 		// Init mlme periodic timer
-		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, &MlmePeriodicExec);
-
-		// Set mlme periodic timer
-		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, &MlmePeriodicExecTimeout);
 
 		// software-based RX Antenna diversity
 		RTMPInitTimer(pAd, &pAd->RxAnt.RxAntDiversityTimer, &AsicRxAntEvalTimeout);
@@ -292,7 +289,7 @@ NDIS_STATUS MlmeInit(
 
 	} while (FALSE);
 
-	DBGPRINT(RT_DEBUG_TRACE, "<-- MLME Initialize\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<-- MlmeInit\n");
 
 	return Status;
 }
@@ -306,66 +303,44 @@ NDIS_STATUS MlmeInit(
 	Note:
 		This function is invoked from MPSetInformation and MPReceive;
 		This task guarantee only one MlmeHandler will run.
-
 	==========================================================================
  */
 VOID MlmeHandler(
 	IN PRTMP_ADAPTER pAd)
 {
 	MLME_QUEUE_ELEM	*Elem = NULL;
-	unsigned long			IrqFlags;
-
-	// Only accept MLME and Frame from peer side, no other (control/data) frame should
-	// get into this state machine
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+	unsigned long			flags;
 
+	// Only accept MLME and Frame from peer side, no other (control/data)
+	// frame should get into this state machine
 
-	if(pAd->Mlme.bRunning)
+	// We fix the multiple context service drop problem identified by
+	// Ben Hutchings in an SMP- safe way by combining TaskLock and Queue.Lock
+	// per his suggestion.
+	NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock);
+	if(pAd->Mlme.Running)
 	{
-		NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+		NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 		return;
 	}
-	else
-	{
-		pAd->Mlme.bRunning = TRUE;
-	}
-
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+	pAd->Mlme.Running = TRUE;
 
+	// If there's a bubble, wait for it to collapse before proceeding.
+    while (MlmeGetHead(&pAd->Mlme.Queue, &Elem)) {
+		smp_read_barrier_depends();
+		if (!Elem->Occupied) break;
 
-	while (TRUE) {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS) ||
-			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
-			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, "Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %d)\n", pAd->Mlme.Queue.Num);
-			break;
-		}
-
-		NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
-		if (!MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
-			NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
-			break;
-		}
-		NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
-
-		//From message type, determine which state machine I should drive
-		if (pAd->PortCfg.BssType == BSS_MONITOR)
-			continue;
+		NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 
 		if (Elem->MsgType == RT_CMD_RESET_MLME)
 		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! reset MLME state machine !!!\n");
+			DBGPRINT(RT_DEBUG_TRACE, "-  %s: reset MLME state machine !!!\n",
+					__FUNCTION__);
 			MlmeRestartStateMachine(pAd);
 			MlmePostRestartStateMachine(pAd);
-			Elem->Occupied = FALSE;
-			Elem->MsgLen = 0;
-			continue;
 		}
-
-
-		// if dequeue success
-		switch (Elem->Machine)
+        //From message type, determine which state machine I should drive
+		else if (pAd->PortCfg.BssType != BSS_MONITOR) switch (Elem->Machine)
 		{
 			case ASSOC_STATE_MACHINE:
 				StateMachinePerformAction(pAd, &pAd->Mlme.AssocMachine, Elem);
@@ -386,19 +361,25 @@ VOID MlmeHandler(
 				StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine, Elem);
 				break;
 			default:
-				DBGPRINT(RT_DEBUG_TRACE, "ERROR: Illegal machine in MlmeHandler()\n");
+				DBGPRINT(RT_DEBUG_ERROR, "ERROR: Illegal machine in MlmeHandler()\n");
 				break;
 		} // end of switch
 
 		// free MLME element
-		Elem->Occupied = FALSE;
-		Elem->MsgLen = 0;
+        smp_mb();
+        Elem->Occupied = FALSE;	// sic - bb
+		NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock);
+		MlmeDequeue(&pAd->Mlme.Queue);
 	}
+	pAd->Mlme.Running = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
+}
 
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
-	pAd->Mlme.bRunning = FALSE;
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
-
+VOID MlmeStart(
+	IN PRTMP_ADAPTER pAd)
+{
+	// Set mlme periodic timer
+	RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
 }
 
 /*
@@ -418,23 +399,15 @@ VOID MlmeHalt(
 
 	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeHalt\n");
 
+	MlmeRestartStateMachine(pAd);
+
 	// Cancel pending timers
-	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer);
-	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer);
-	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer);
-	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer);
-	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
-	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer);
 	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer);
 	RTMPCancelTimer(&pAd->Mlme.LinkDownTimer);
 
+	msleep(500); //RTMPusecDelay(500000); // 0.5 sec to guarantee timer canceled
 
-	RTMPusecDelay(500000);	  // 0.5 sec to guarantee timer canceled
-
-	MlmeQueueDestroy(&pAd->Mlme.Queue);
-	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
-
-	MlmeFreeMemoryHandler(pAd); //Free MLME memory handler
+	MlmeQueueInit(&pAd->Mlme.Queue);
 
 	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeHalt\n");
 }
@@ -444,7 +417,7 @@ VOID MlmeSuspend(
 	IN BOOLEAN linkdown)
 {
 	MLME_QUEUE_ELEM		*Elem = NULL;
-	unsigned long				IrqFlags;
+	unsigned long				flags;
 
 	DBGPRINT(RT_DEBUG_TRACE, "==>MlmeSuspend\n");
 
@@ -458,10 +431,10 @@ VOID MlmeSuspend(
 
 	while (TRUE)
 	{
-		NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
-		if(pAd->Mlme.bRunning)
+		NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock);
+		if(pAd->Mlme.Running)
 		{
-			NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+			NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 			if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 				return;
 
@@ -469,25 +442,25 @@ VOID MlmeSuspend(
 		}
 		else
 		{
-			pAd->Mlme.bRunning = TRUE;
-			NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+			pAd->Mlme.Running = TRUE;
+			NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 			break;
 		}
 	}
 
 	// Remove all Mlme queues elements
-	NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
-	while (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
+	NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock);
+	while (MlmeGetHead(&pAd->Mlme.Queue, &Elem)) {
 		// free MLME element
+		MlmeDequeue(&pAd->Mlme.Queue);
 		Elem->Occupied = FALSE;
-		Elem->MsgLen = 0;
 	}
-	NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock, IrqFlags);
+	NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 
 	// Remove running state
-	NdisAcquireSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
-	pAd->Mlme.bRunning = FALSE;
-	NdisReleaseSpinLock(&pAd->Mlme.TaskLock, IrqFlags);
+	NdisAcquireSpinLock(&pAd->Mlme.Queue.Lock);
+	pAd->Mlme.Running = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.Queue.Lock);
 
 	RTUSBCleanUpMLMEWaitQueue(pAd);
 	RTUSBCleanUpMLMEBulkOutQueue(pAd);
@@ -546,21 +519,36 @@ VOID MlmeResume(
  */
 
 #define ADHOC_BEACON_LOST_TIME		(10*HZ)  // 4 sec
-VOID MlmePeriodicExec(
+
+// interrupt context (timer handler)
+VOID MlmePeriodicExecTimeout(
 	IN	unsigned long data)
 {
 	RTMP_ADAPTER	*pAd = (RTMP_ADAPTER *)data;
-	unsigned long			IrqFlags;
+	RTUSBEnqueueInternalCmd(pAd, RT_OID_PERIODIC_EXECUT);
+}
+
+// process context
+VOID MlmePeriodicExec(
+	IN	PRTMP_ADAPTER pAd)
+{
+	unsigned long			flags;
 
 	// Timer need to reset every time, so using do-while loop
 	do
 	{
 		if (pAd->PortCfg.BssType == BSS_MONITOR)
 		{
-			RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
-			return;
+			DBGPRINT(RT_DEBUG_TRACE, "==> MlmePeriodicExec Monitor Mode\n");
+			break;
 		}
+		DBGPRINT(RT_DEBUG_TRACE, "==> MlmePeriodicExec\n");
 
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		{
+			DBGPRINT(RT_DEBUG_INFO, "- MlmePeriodicExec scan active\n");
+			break;
+		}
 		if ((pAd->PortCfg.bHardwareRadio == TRUE) &&
 			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
 			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
@@ -573,13 +561,14 @@ VOID MlmePeriodicExec(
 		if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
 			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) ||
 			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_MEASUREMENT)) ||
-			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)))
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS))) {
+			DBGPRINT(RT_DEBUG_INFO, "- MlmePeriodicExec Hlt or Radio Off\n");
 			break;
-
+		}
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING))
 		{
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING);
-			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event B!\n");
+			DBGPRINT(RT_DEBUG_INFO, "NDIS_STATUS_MEDIA_DISCONNECT Event B!\n");
 		}
 
 		//
@@ -587,6 +576,7 @@ VOID MlmePeriodicExec(
 		//
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
 		{
+			DBGPRINT(RT_DEBUG_INFO, "- MlmePeriodicExec NIC not exist\n");
 			RTUSBRejectPendingPackets(pAd);
 			break;
 		}
@@ -601,13 +591,18 @@ VOID MlmePeriodicExec(
 			PCmdQElmt	cmdqelmt;
 
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+			DBGPRINT(RT_DEBUG_ERROR, "- (%s) mgmt ring full, count=%d\n",
+					__FUNCTION__, pAd->RalinkCounters.MgmtRingFullCount);
 
-			NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+			NdisAcquireSpinLock(&pAd->CmdQLock);
 			while (pAd->CmdQ.size > 0)
 			{
 				RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
-				if(cmdqelmt == NULL)//Thomas
+				if(cmdqelmt == NULL) {	//Thomas
+				DBGPRINT(RT_DEBUG_INFO,
+						"- MlmePeriodicExec (cmdqelmt==NULL)\n");
 					break;
+				}
 				if (cmdqelmt->CmdFromNdis == TRUE)
 				{
 					if ((cmdqelmt->command != RT_OID_MULTI_READ_MAC) &&
@@ -625,31 +620,35 @@ VOID MlmePeriodicExec(
 				else
 					cmdqelmt->InUse = FALSE;
 			}
-			NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+			NdisReleaseSpinLock(&pAd->CmdQLock);
 
 			RTUSBEnqueueInternalCmd(pAd, RT_OID_RESET_FROM_ERROR);
-
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "<---MlmePeriodicExec (Mgmt Ring Full)\n");
 			break;
 		}
 		pAd->RalinkCounters.MgmtRingFullCount = 0;
 
-		RTUSBEnqueueInternalCmd(pAd, RT_OID_PERIODIC_EXECUT); //STAMlmePeriodicExec(pAd);
-
-		RTUSBMlmeUp(pAd);
-
-	}	while (0);
+		DBGPRINT(RT_DEBUG_INFO, "- MlmePeriodicExec call STAExec\n");
+		STAMlmePeriodicExec(pAd);
 
+	} while (0);
 
 	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
 		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
 	{
-		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+		/* Only start the next period if we haven't been told to close while
+		 * waiting for register I/O to complete. Otherwise, we can get into
+		 * trouble when we (redundantly) start the timer on the next open.
+		 * - bb */
+		if (netif_running(pAd->net_dev)) {
+			RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+		}
 	}
 
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmePeriodicExec\n");
 }
 
+// process context
 VOID STAMlmePeriodicExec(
 	IN	PRTMP_ADAPTER pAd)
 {
@@ -660,18 +659,15 @@ VOID STAMlmePeriodicExec(
 #endif
 
 	if(!CurTxRxCsr4) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
 
 	// WPA MIC error should block association attempt for 60 seconds
 	if (pAd->PortCfg.bBlockAssoc && (time_after(pAd->Mlme.Now, pAd->PortCfg.LastMicErrorTime + (60 * HZ))))
 		pAd->PortCfg.bBlockAssoc = FALSE;
-
-	DBGPRINT(RT_DEBUG_INFO,"MMCHK - PortCfg.Ssid[%d]=%c%c%c%c... MlmeAux.Ssid[%d]=%c%c%c%c...\n",
-			pAd->PortCfg.SsidLen, pAd->PortCfg.Ssid[0], pAd->PortCfg.Ssid[1], pAd->PortCfg.Ssid[2], pAd->PortCfg.Ssid[3],
-			pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid[0], pAd->MlmeAux.Ssid[1], pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]);
-
+	DBGPRINT(RT_DEBUG_INFO, "MMCHK - PortCfg.Ssid=%s ... MlmeAux.Ssid=%s\n",
+			pAd->PortCfg.Ssid, pAd->MlmeAux.Ssid);
 
 	// add the most up-to-date h/w raw counters into software variable, so that
 	// the dynamic tuning mechanism below are based on most up-to-date information
@@ -887,13 +883,15 @@ VOID STAMlmePeriodicExec(
 				{
 					MLME_SCAN_REQ_STRUCT	   ScanReq;
 
-					//if (time_after(pAd->Mlme.Now, pAd->PortCfg.LastScanTime + 10 * HZ))
 					if (time_after(pAd->Mlme.Now - INITIAL_JIFFIES, pAd->PortCfg.LastScanTime + 10 * HZ))
 					{
 						DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new ACTIVE scan SSID[%s]\n", pAd->MlmeAux.AutoReconnectSsid);
 						ScanParmFill(pAd, &ScanReq, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen, BSS_ANY, SCAN_ACTIVE);
-						MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+						MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+								sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
 						pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+						RTUSBMlmeUp(pAd);
+
 						// Reset Missed scan number
 						pAd->PortCfg.LastScanTime = pAd->Mlme.Now;
 					}
@@ -1464,7 +1462,7 @@ VOID MlmeDynamicTxRateSwitching(
 	if (TxTotalCnt)
 		TxErrorRatio = ((pAd->RalinkCounters.OneSecTxRetryOkCount + pAd->RalinkCounters.OneSecTxFailCount) *100) / TxTotalCnt;
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE,"%d: NDIS push BE=%d, BK=%d, VI=%d, VO=%d, TX/RX AGGR=<%d,%d>, p-NDIS=%d, RSSI=%d, ACKbmap=%03x, PER=%d%%\n",
+	DBGPRINT(RT_DEBUG_TRACE,"%d: NDIS push BE=%d, BK=%d, VI=%d, VO=%d, TX/RX AGGR=<%d,%d>, p-NDIS=%d, RSSI=%d, ACKbmap=%03x, PER=%d%%\n",
 		RateIdToMbps[CurrRate],
 		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE],
 		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK],
@@ -1596,7 +1594,7 @@ VOID MlmeDynamicTxRateSwitching(
 			((pAd->DrsCounters.PER[CurrRate]+5) > pAd->DrsCounters.PER[UpRate]))
 		{
 			// we believe this is a noisy environment. better stay at UpRate
-			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: #### enter Noisy environment ####\n");
+			DBGPRINT(RT_DEBUG_TRACE,"DRS: #### enter Noisy environment ####\n");
 			pAd->DrsCounters.fNoisyEnvironment = TRUE;
 
 			// 2004-3-14 when claiming noisy environment, we're not only switch back
@@ -1629,7 +1627,7 @@ VOID MlmeDynamicTxRateSwitching(
 			if (JumpUpRate > pAd->PortCfg.MaxTxRate)
 				JumpUpRate = pAd->PortCfg.MaxTxRate;
 
-			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: #### leave Noisy environment ####, RSSI=%d, JumpUpRate=%d\n",
+			DBGPRINT(RT_DEBUG_TRACE,"DRS: #### leave Noisy environment ####, RSSI=%d, JumpUpRate=%d\n",
 				dbm, RateIdToMbps[JumpUpRate]);
 
 			if (JumpUpRate > CurrRate)
@@ -1652,7 +1650,7 @@ VOID MlmeDynamicTxRateSwitching(
 			(pAd->DrsCounters.TxQuality[CurrRate] <= 1) &&
 			(pAd->DrsCounters.TxQuality[UpRate] <= 1))
 		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE,"DRS: 2 NULL frames at UpRate = %d Mbps\n",RateIdToMbps[UpRate]);
+			DBGPRINT(RT_DEBUG_TRACE,"DRS: 2 NULL frames at UpRate = %d Mbps\n",RateIdToMbps[UpRate]);
 			RTMPSendNullFrame(pAd, UpRate);
 		}
 
@@ -1815,7 +1813,7 @@ VOID MlmeSetPsmBit(
 	TXRX_CSR4_STRUC *csr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
 
 	if(!csr4) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
 
@@ -1834,11 +1832,12 @@ VOID MlmeSetTxPreamble(
 	TXRX_CSR4_STRUC *csr4 = kzalloc(sizeof(TXRX_CSR4_STRUC), GFP_KERNEL);
 
 	if(!csr4) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
 
 	RTUSBReadMACRegister(pAd, TXRX_CSR4, &csr4->word);
+
 	if (TxPreamble == Rt802_11PreambleShort)
 	{
 		// NOTE: 1Mbps should always use long preamble
@@ -2106,7 +2105,7 @@ VOID MlmeRadioOff(
 			memcpy(MsgElem.Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
 
 			MlmeDisassocReqAction(pAd, &MsgElem);
-			RTMPusecDelay(1000);
+			msleep(1);	//RTMPusecDelay(1000);
 		}
 
 		// Set Radio off flag will turn off RTUSBKickBulkOut function
@@ -2141,7 +2140,8 @@ VOID MlmeRadioOff(
 	{
 		if (atomic_read(&pAd->PendingRx) > 0)
 		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+			DBGPRINT(RT_DEBUG_TRACE,
+					"- (%s) BulkIn IRP Pending!!!\n", __FUNCTION__);
 			RTUSB_VendorRequest(pAd,
 				0,
 				DEVICE_VENDOR_REQUEST_OUT,
@@ -2157,7 +2157,8 @@ VOID MlmeRadioOff(
 			(pAd->BulkOutPending[2] == TRUE) ||
 			(pAd->BulkOutPending[3] == TRUE))
 		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+			DBGPRINT(RT_DEBUG_TRACE,
+					"- (%s) BulkOut IRP Pending!!!\n", __FUNCTION__);
 			if (i == 0)
 			{
 				RTUSBCancelPendingBulkOutIRP(pAd);
@@ -2165,7 +2166,7 @@ VOID MlmeRadioOff(
 			}
 		}
 
-		RTMPusecDelay(500000);
+		msleep(500);	//RTMPusecDelay(500000);
 	}
 
 	// Clean up old bss table
@@ -3217,8 +3218,9 @@ NDIS_STATUS MlmeQueueInit(
 	IN MLME_QUEUE *Queue)
 {
 	INT i;
+	unsigned long			flags;
 
-	NdisAllocateSpinLock(&Queue->Lock);
+	NdisAcquireSpinLock(&(Queue->Lock));
 
 	Queue->Num	= 0;
 	Queue->Head = 0;
@@ -3230,6 +3232,7 @@ NDIS_STATUS MlmeQueueInit(
 		Queue->Entry[i].MsgLen = 0;
 		memset(Queue->Entry[i].Msg, 0, MAX_LEN_OF_MLME_BUFFER);
 	}
+	NdisReleaseSpinLock(&(Queue->Lock));
 
 	return NDIS_STATUS_SUCCESS;
 }
@@ -3254,7 +3257,7 @@ BOOLEAN MlmeEnqueue(
 {
 	INT Tail;
 	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
-	unsigned long		IrqFlags;
+	unsigned long		flags;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
@@ -3270,24 +3273,37 @@ BOOLEAN MlmeEnqueue(
 
 	if (pAd->MLMEThr_pid > 0)
 	{
-		NdisAcquireSpinLock(&Queue->Lock, IrqFlags);
+		NdisAcquireSpinLock(&Queue->Lock);
 		if (Queue->Num == MAX_LEN_OF_MLME_QUEUE) {
-			NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+			NdisReleaseSpinLock(&Queue->Lock);
 			DBGPRINT_ERR("MlmeEnqueue: full, msg dropped and may corrupt MLME\n");
 			return FALSE;
 		}
+		// If another context preempts us, it uses the next element - sic. bb
 		Tail = Queue->Tail++;
 		Queue->Tail %= MAX_LEN_OF_MLME_QUEUE;
 		Queue->Num++;
-		NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
 
-		Queue->Entry[Tail].Occupied = TRUE;
+	// We guard against Ben Hutchings' incomplete queue element problem by not
+	// setting the Occupied flag until the memcpy is done. The ocurrence of a
+	// refresh cycle during a copy can stretch the time by up to 100 usec
+	// (well, quite a few usec, anyway); not good when interrupts are disabled.
+	// Note that this can leave a bubble in the queue, but it will have
+	// disappeared by the time this thread gets around to calling MlmeHandler.
+	// All items will be handled in their proper order, but possibly not in the
+	// context in which they were added. - bb
+		NdisReleaseSpinLock(&Queue->Lock);
+		DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueue, num=%d\n",Queue->Num);
+
 		Queue->Entry[Tail].Machine = Machine;
 		Queue->Entry[Tail].MsgType = MsgType;
 		Queue->Entry[Tail].MsgLen  = MsgLen;
 		memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
 
-		DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueue, num=%d\n",Queue->Num);
+		//MlmeHandler will stop when it finds this false.
+    	smp_wmb();
+    	Queue->Entry[Tail].Occupied = TRUE;
+
 	}
 
 	return TRUE;
@@ -3313,16 +3329,18 @@ BOOLEAN MlmeEnqueueForRecv(
 	PFRAME_802_11	pFrame = (PFRAME_802_11)Msg;
 	ULONG			MsgType;
 	MLME_QUEUE		*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
-	unsigned long			IrqFlags;
+	unsigned long	flags;
 
-	if((pAd->MLMEThr_pid <= 0))
+	if((pAd->MLMEThr_pid <= 0)) {
+		DBGPRINT_ERR("MlmeEnqueueForRecv: MLME Thread inactive\n");
 		return FALSE;
-
+	}
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) {
+		DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueueForRecv: Halt in progress\n");
 		return FALSE;
-
+	}
 	// First check the size, it MUST not exceed the mlme queue size
 	if (MsgLen > MAX_LEN_OF_MLME_BUFFER)
 	{
@@ -3343,27 +3361,28 @@ BOOLEAN MlmeEnqueueForRecv(
 			CHAR CfgData[MAX_CFG_BUFFER_LEN+1] = {0};
 			if (BackDoorProbeRspSanity(pAd, Msg, MsgLen, CfgData))
 			{
-				printk("MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n", (int)strlen(CfgData), CfgData);
+				DBGPRINT(RT_DEBUG_INFO,
+						"MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n",
+						(int)strlen(CfgData), CfgData);
 				pAd->PortCfg.bGetAPConfig = FALSE;
 			}
 		}
 	}
 
-
-	NdisAcquireSpinLock(&Queue->Lock, IrqFlags);
+	NdisAcquireSpinLock(&Queue->Lock);
 	if (Queue->Num == MAX_LEN_OF_MLME_QUEUE) {
-		NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+		NdisReleaseSpinLock(&Queue->Lock);
 		DBGPRINT_ERR("MlmeEnqueueForRecv: full and dropped\n");
 		return FALSE;
 	}
 	Tail = Queue->Tail++;
 	Queue->Tail %= MAX_LEN_OF_MLME_QUEUE;
 	Queue->Num++;
-	NdisReleaseSpinLock(&Queue->Lock, IrqFlags);
+	NdisReleaseSpinLock(&Queue->Lock);
 	DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueueForRecv, num=%d\n",Queue->Num);
 
 	// OK, we got all the informations, it is time to put things into queue
-	Queue->Entry[Tail].Occupied = TRUE;
+	// See MlmeEnqueue note for use of Occupied flag.
 	Queue->Entry[Tail].Machine = Machine;
 	Queue->Entry[Tail].MsgType = MsgType;
 	Queue->Entry[Tail].MsgLen  = MsgLen;
@@ -3372,40 +3391,53 @@ BOOLEAN MlmeEnqueueForRecv(
 	Queue->Entry[Tail].bReqIsFromNdis = FALSE;
 	Queue->Entry[Tail].Channel = pAd->LatchRfRegs.Channel;
 	memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
-
-	RTUSBMlmeUp(pAd);
+    smp_wmb();
+    Queue->Entry[Tail].Occupied = TRUE;
 
 	return TRUE;
 }
 
-/*! \brief	 Dequeue a message from the MLME Queue
+/*! \brief   Get the first message from the MLME Queue
  * 			WARNING: Must be call with Mlme.Queue.Lock held
- *	\param	*Queue	  The MLME Queue
- *	\param	*Elem	  The message dequeued from MLME Queue
- *	\return  TRUE if the Elem contains something, FALSE otherwise
- *	\pre
- *	\post
+ *  \param  *Queue    The MLME Queue
+ *  \param  *Elem     The message dequeued from MLME Queue
+ *  \return  TRUE if the Elem contains something, FALSE otherwise
+ *  \pre
+ *  \post
+ */
+BOOLEAN MlmeGetHead(
+    IN MLME_QUEUE *Queue,
+    OUT MLME_QUEUE_ELEM **Elem)
+{
+    if (Queue->Num == 0)
+	    return FALSE;
+    *Elem = &Queue->Entry[Queue->Head];
+    return TRUE;
+}
+
+/*! \brief   Remove the first message from the MLME Queue
+ * 			WARNING: Must be call with Mlme.Queue.Lock held
+ *  \param  *Queue    The MLME Queue
+ *  \return  TRUE if a message was removed, FALSE if the queue was empty
+ *  \pre
+ *  \post
  */
 BOOLEAN MlmeDequeue(
-	IN MLME_QUEUE *Queue,
-	OUT MLME_QUEUE_ELEM **Elem)
+    IN MLME_QUEUE *Queue)
 {
+    if (Queue->Num == 0)
+	    return FALSE;
+    Queue->Head = (Queue->Head + 1) % MAX_LEN_OF_MLME_QUEUE;
+    Queue->Num--;
+    DBGPRINT(RT_DEBUG_INFO, "MlmeDequeue, num=%d\n",Queue->Num);
 
-	if (Queue->Num == 0)
-		return FALSE;
-
-	*Elem = &Queue->Entry[Queue->Head++];
-	Queue->Head %= MAX_LEN_OF_MLME_QUEUE;
-	Queue->Num--;
-	DBGPRINT(RT_DEBUG_INFO, "MlmeDequeue, num=%d\n",Queue->Num);
-
-	return TRUE;
+    return TRUE;
 }
 
 VOID MlmeRestartStateMachine(
 	IN	PRTMP_ADAPTER	pAd)
 {
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MlmeRestartStateMachine !!!\n");
+	DBGPRINT(RT_DEBUG_TRACE, "!!! MlmeRestartStateMachine !!!\n");
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);
 
@@ -3446,9 +3478,9 @@ VOID MlmePostRestartStateMachine(
 	// Since MlmeRestartStateMachine will do nothing when Mlme is running.
 	//
 	while (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS))
-		RTMPusecDelay(100000);
+		msleep(100);	//RTMPusecDelay(100000);
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MlmePostRestartStateMachine !!!\n");
+	DBGPRINT(RT_DEBUG_TRACE, "!!! MlmePostRestartStateMachine !!!\n");
 
 	// Change back to original channel in case of doing scan
 	AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
@@ -3468,15 +3500,15 @@ VOID MlmePostRestartStateMachine(
 VOID MlmeQueueDestroy(
 	IN MLME_QUEUE *pQueue)
 {
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
-	NdisAcquireSpinLock(&(pQueue->Lock), IrqFlags);
+	NdisAcquireSpinLock(&(pQueue->Lock));
 
 	pQueue->Num  = 0;
 	pQueue->Head = 0;
 	pQueue->Tail = 0;
 
-	NdisReleaseSpinLock(&(pQueue->Lock), IrqFlags);
+	NdisReleaseSpinLock(&(pQueue->Lock));
 	NdisFreeSpinLock(&(pQueue->Lock));
 }
 
@@ -3997,7 +4029,7 @@ VOID AsicAntennaSelect(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	UCHAR			Channel)
 {
-	ULONG	*value = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	ULONG *value = kzalloc(sizeof(ULONG), GFP_KERNEL);
 	ABGBAND_STATE	BandState;
 
 
@@ -4005,9 +4037,10 @@ VOID AsicAntennaSelect(
 		Channel, AntStr[pAd->Antenna.field.TxDefaultAntenna], AntStr[pAd->Antenna.field.RxDefaultAntenna]);
 
 	if(!value) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
+
 	if (Channel <= 14)
 		BandState = BG_BAND;
 	else
@@ -4716,7 +4749,7 @@ VOID AsicDisableSync(
 	DBGPRINT(RT_DEBUG_TRACE, "--->Disable TSF synchronization\n");
 
 	if(!csr) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
 
@@ -4745,13 +4778,12 @@ VOID AsicEnableBssSync(
 	DBGPRINT(RT_DEBUG_TRACE, "--->AsicEnableBssSync(INFRA mode)\n");
 
 	if(!csr) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
 
 	RTUSBReadMACRegister(pAd, TXRX_CSR9, &csr->word);
 
-
 	csr->field.BeaconInterval = pAd->PortCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
 	csr->field.bTsfTicking = 1;
 	csr->field.TsfSyncMode = 1; // sync TSF in INFRASTRUCTURE mode
@@ -4821,7 +4853,6 @@ VOID AsicEnableIbssSync(
 	csr9->field.bBeaconGen = 1;
 	RTUSBWriteMACRegister(pAd, TXRX_CSR9, csr9->word);
 	kfree(csr9);
-
 }
 
 /*
@@ -4960,22 +4991,22 @@ VOID AsicSetSlotTime(
 	MAC_CSR9_STRUC *Csr9 = kzalloc(sizeof(MAC_CSR9_STRUC), GFP_KERNEL);
 
 	if(!Csr9) {
-                DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return;
 	}
+
 	if ( pAd->PortCfg.Channel > 14)  //check if in the A band
 		bUseShortSlotTime = TRUE;
 
-	if (bUseShortSlotTime && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
-	{
+	if (bUseShortSlotTime && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)) {
 		kfree(Csr9);
 		return;
 	}
-	else if ((!bUseShortSlotTime) && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)))
-	{
+	else if ((!bUseShortSlotTime) && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))) {
 		kfree(Csr9);
 		return;
 	}
+
 	if (bUseShortSlotTime)
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
 	else
@@ -4993,9 +5024,8 @@ VOID AsicSetSlotTime(
 
 	RTUSBWriteMACRegister(pAd, MAC_CSR9, Csr9->word);
 
-
 	DBGPRINT(RT_DEBUG_TRACE, "AsicSetSlotTime(=%d us)\n", Csr9->field.SlotTime);
-        kfree(Csr9);
+	kfree(Csr9);
 }
 
 /*
@@ -5195,8 +5225,9 @@ VOID AsicAddSharedKeyEntry(
 	IN PUCHAR		 pRxMic)
 {
 	INT   i;
-	ULONG offset, csr0;
-	SEC_CSR1_STRUC csr1;
+	ULONG offset;
+	ULONG *csr0 = kzalloc(sizeof(ULONG), GFP_KERNEL);
+	SEC_CSR1_STRUC *csr1 = kzalloc(sizeof(SEC_CSR1_STRUC), GFP_KERNEL);
 
 		union aaa {
 		ULONG	temp_ul;
@@ -5208,8 +5239,13 @@ VOID AsicAddSharedKeyEntry(
 			} temp_uc;
 	} ddd;
 
+	if (!csr0 || !csr1) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+    return;
+  }
+
 	DBGPRINT(RT_DEBUG_TRACE, "AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg], BssIndex*4 + KeyIdx);
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Key =");
+	DBGPRINT(RT_DEBUG_TRACE, "   Key =");
 	for (i = 0; i < 16; i++)
 	{
 		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pKey[i]);
@@ -5217,7 +5253,7 @@ VOID AsicAddSharedKeyEntry(
 	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 	if (pRxMic)
 	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Rx MIC Key = ");
+		DBGPRINT(RT_DEBUG_TRACE, "   Rx MIC Key = ");
 		for (i = 0; i < 8; i++)
 		{
 			DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pRxMic[i]);
@@ -5226,7 +5262,7 @@ VOID AsicAddSharedKeyEntry(
 	}
 	if (pTxMic)
 	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, "	   Tx MIC Key = ");
+		DBGPRINT(RT_DEBUG_TRACE, "   Tx MIC Key = ");
 		for (i = 0; i < 8; i++)
 		{
 			DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pTxMic[i]);
@@ -5237,8 +5273,8 @@ VOID AsicAddSharedKeyEntry(
 	//
 	// enable this key entry
 	//
-	RTUSBReadMACRegister(pAd, SEC_CSR0, &csr0);
-	csr0 = csr0 & ~BIT32[BssIndex*4 + KeyIdx];	   // turrn off   the valid bit
+	RTUSBReadMACRegister(pAd, SEC_CSR0, csr0);
+	*csr0 = *csr0 & ~BIT32[BssIndex*4 + KeyIdx];	// turn off the valid bit
 	RTUSBWriteMACRegister(pAd, SEC_CSR0, csr0);
 
 
@@ -5287,23 +5323,25 @@ VOID AsicAddSharedKeyEntry(
 	//
 	// Update cipher algorithm. STA always use BSS0
 	//
-	RTUSBReadMACRegister(pAd, SEC_CSR1, &csr1.word);
+	RTUSBReadMACRegister(pAd, SEC_CSR1, &csr1->word);
 	if (KeyIdx == 0)
-		csr1.field.Bss0Key0CipherAlg = CipherAlg;
+		csr1->field.Bss0Key0CipherAlg = CipherAlg;
 	else if (KeyIdx == 1)
-		csr1.field.Bss0Key1CipherAlg = CipherAlg;
+		csr1->field.Bss0Key1CipherAlg = CipherAlg;
 	else if (KeyIdx == 2)
-		csr1.field.Bss0Key2CipherAlg = CipherAlg;
+		csr1->field.Bss0Key2CipherAlg = CipherAlg;
 	else
-		csr1.field.Bss0Key3CipherAlg = CipherAlg;
-	RTUSBWriteMACRegister(pAd, SEC_CSR1, csr1.word);
+		csr1->field.Bss0Key3CipherAlg = CipherAlg;
+	RTUSBWriteMACRegister(pAd, SEC_CSR1, csr1->word);
 
 	//
 	// enable this key entry
 	//
-	RTUSBReadMACRegister(pAd, SEC_CSR0, &csr0);
-	csr0 |= BIT32[BssIndex*4 + KeyIdx]; 	// turrn on the valid bit
+	RTUSBReadMACRegister(pAd, SEC_CSR0, csr0);
+	*csr0 |= BIT32[BssIndex*4 + KeyIdx]; 	// turrn on the valid bit
 	RTUSBWriteMACRegister(pAd, SEC_CSR0, csr0);
+	kfree(csr0);
+	kfree(csr1);
 }
 
 VOID AsicRemoveSharedKeyEntry(
@@ -5944,7 +5982,7 @@ NDIS_STATUS MlmeInitMemoryHandler(
 	NDIS_STATUS 				Status = NDIS_STATUS_SUCCESS;
 	UINT						i;
 
-	DBGPRINT(RT_DEBUG_INFO,"==> MlmeInitMemory\n");
+	DBGPRINT(RT_DEBUG_TRACE,"==> MlmeInitMemoryHandler\n");
 	pAd->Mlme.MemHandler.MemoryCount = 0;
 	pAd->Mlme.MemHandler.pInUseHead = NULL;
 	pAd->Mlme.MemHandler.pInUseTail = NULL;
@@ -6004,17 +6042,20 @@ NDIS_STATUS MlmeInitMemoryHandler(
 			pAd->Mlme.MemHandler.pUnUseTail = Current;
 
 	}
-
 	if (pAd->Mlme.MemHandler.MemoryCount < Number)
 	{
 		Status = NDIS_STATUS_RESOURCES;
-		DBGPRINT(RT_DEBUG_TRACE, "MlmeInitMemory Initial failed [Require=%d, available=%d]\n", Number, pAd->Mlme.MemHandler.MemoryCount);
+		DBGPRINT(RT_DEBUG_TRACE,
+				"MlmeInitMemoryHandler failed [Require=%d, available=%d]\n",
+				Number, pAd->Mlme.MemHandler.MemoryCount);
+		MlmeFreeMemoryHandler(pAd);
+	}
+	else {
+		pAd->Mlme.MemHandler.InUseCount = 0;
+		pAd->Mlme.MemHandler.UnUseCount = Number;
+		pAd->Mlme.MemHandler.PendingCount = 0;
 	}
-
-	pAd->Mlme.MemHandler.InUseCount = 0;
-	pAd->Mlme.MemHandler.UnUseCount = Number;
-	pAd->Mlme.MemHandler.PendingCount = 0;
-	DBGPRINT(RT_DEBUG_INFO, "<== MlmeInitMemory\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeInitMemoryHandler Status=%d\n",Status);
 
 	return (Status);
 }
@@ -6037,7 +6078,7 @@ VOID MlmeFreeMemoryHandler(
 {
 	PMLME_MEMORY_STRUCT 	 pMlmeMemoryStruct = NULL;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeFreeMemoryHandler\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->MlmeFreeMemoryHandler\n");
 
 	//Free nonpaged memory, free it in the *In-used* link list.
 	while (pAd->Mlme.MemHandler.pInUseHead != NULL)
@@ -6070,7 +6111,7 @@ VOID MlmeFreeMemoryHandler(
 		}
 	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---MlmeFreeMemoryHandler\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeFreeMemoryHandler\n");
 }
 
 /*
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/mlme.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/mlme.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/mlme.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/mlme.h	2008-05-09 06:24:58.000000000 +0200
@@ -321,6 +321,7 @@ typedef struct {
 } BSS_TABLE, *PBSS_TABLE;
 
 typedef struct _MLME_QUEUE_ELEM {
+    UCHAR             Msg[MAX_LEN_OF_MLME_BUFFER];
     ULONG             Machine;
     ULONG             MsgType;
     ULONG             MsgLen;
@@ -330,7 +331,6 @@ typedef struct _MLME_QUEUE_ELEM {
     UCHAR             Channel;
     BOOLEAN           Occupied;
     BOOLEAN           bReqIsFromNdis;
-    UCHAR             Msg[MAX_LEN_OF_MLME_BUFFER];
 } MLME_QUEUE_ELEM, *PMLME_QUEUE_ELEM;
 
 typedef struct _MLME_QUEUE {
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/oid.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/oid.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/oid.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/oid.h	2008-05-09 06:24:58.000000000 +0200
@@ -49,6 +49,7 @@
 #endif
 
 #define RT_PRIV_IOCTL								(SIOCIWFIRSTPRIV + 0x01)
+#define RT_PRIV_IOCTL_WPA_SUPPLICANT				(SIOCIWFIRSTPRIV + 0x0E)
 #define RTPRIV_IOCTL_SET							(SIOCIWFIRSTPRIV + 0x02)
 
 #ifdef DBG
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt2x00debug.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt2x00debug.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt2x00debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt2x00debug.c	2008-05-09 06:38:04.000000000 +0200
@@ -0,0 +1,324 @@
+/*
+	Copyright (C) 2004 - 2007 rt2x00 SourceForge Project
+	<http://rt2x00.serialmonkey.com>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the
+	Free Software Foundation, Inc.,
+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+	Module: rt2x00lib
+	Abstract: rt2x00 debugfs specific routines.
+ */
+
+#ifdef RT2X00DEBUGFS
+
+#include <linux/debugfs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+
+#include "rt_config.h"
+
+#define PRINT_LINE_LEN_MAX 32
+
+struct rt2x00debug_intf {
+	/*
+	 * Pointer to driver structure where
+	 * this debugfs entry belongs to.
+	 */
+	struct rt2x00_dev *rt2x00dev;
+
+	/*
+	 * Reference to the rt2x00debug structure
+	 * which can be used to communicate with
+	 * the registers.
+	 */
+	const struct rt2x00debug *debug;
+
+	/*
+	 * Debugfs entries for:
+	 * - driver folder
+	 * - driver file
+	 * - chipset file
+	 * - register offset/value files
+	 * - eeprom offset/value files
+	 * - bbp offset/value files
+	 * - rf offset/value files
+	 */
+	struct dentry *driver_folder;
+	struct dentry *driver_entry;
+	struct dentry *chipset_entry;
+	struct dentry *csr_off_entry;
+	struct dentry *csr_val_entry;
+	struct dentry *eeprom_off_entry;
+	struct dentry *eeprom_val_entry;
+	struct dentry *bbp_off_entry;
+	struct dentry *bbp_val_entry;
+	struct dentry *rf_off_entry;
+	struct dentry *rf_val_entry;
+
+	/*
+	 * Driver and chipset files will use a data buffer
+	 * that has been created in advance. This will simplify
+	 * the code since we can use the debugfs functions.
+	 */
+	struct debugfs_blob_wrapper driver_blob;
+	struct debugfs_blob_wrapper chipset_blob;
+
+	/*
+	 * Requested offset for each register type.
+	 */
+	unsigned int offset_csr;
+	unsigned int offset_eeprom;
+	unsigned int offset_bbp;
+	unsigned int offset_rf;
+};
+
+static int rt2x00debug_file_open(struct inode *inode, struct file *file)
+{
+	struct rt2x00debug_intf *intf = inode->i_private;
+
+	file->private_data = inode->i_private;
+
+	if (!try_module_get(intf->debug->owner))
+		return -EBUSY;
+
+	return 0;
+}
+
+static int rt2x00debug_file_release(struct inode *inode, struct file *file)
+{
+	struct rt2x00debug_intf *intf = file->private_data;
+
+	module_put(intf->debug->owner);
+
+	return 0;
+}
+
+#define RT2X00DEBUGFS_OPS_READ(__name, __format, __type)	\
+static ssize_t rt2x00debug_read_##__name(struct file *file,	\
+					 char __user *buf,	\
+					 size_t length,		\
+					 loff_t *offset)	\
+{								\
+	struct rt2x00debug_intf *intf =	file->private_data;	\
+	const struct rt2x00debug *debug = intf->debug;		\
+	char line[16];						\
+	size_t size;						\
+	__type value;						\
+								\
+	if (*offset)						\
+		return 0;					\
+								\
+	if (intf->offset_##__name >= debug->__name.word_count)	\
+		return -EINVAL;					\
+								\
+	debug->__name.read(intf->rt2x00dev,			\
+			   intf->offset_##__name, &value);	\
+								\
+	size = sprintf(line, __format, value);			\
+								\
+	if (copy_to_user(buf, line, size))			\
+		return -EFAULT;					\
+								\
+	*offset += size;					\
+	return size;						\
+}
+
+#define RT2X00DEBUGFS_OPS_WRITE(__name, __type)			\
+static ssize_t rt2x00debug_write_##__name(struct file *file,	\
+					  const char __user *buf,\
+					  size_t length,	\
+					  loff_t *offset)	\
+{								\
+	struct rt2x00debug_intf *intf =	file->private_data;	\
+	const struct rt2x00debug *debug = intf->debug;		\
+	char line[16];						\
+	size_t size;						\
+	__type value;						\
+								\
+	if (*offset)						\
+		return 0;					\
+								\
+	if (!capable(CAP_NET_ADMIN))				\
+		return -EPERM;					\
+								\
+	if (intf->offset_##__name >= debug->__name.word_count)	\
+		return -EINVAL;					\
+								\
+	if (copy_from_user(line, buf, length))			\
+		return -EFAULT;					\
+								\
+	size = strlen(line);					\
+	value = simple_strtoul(line, NULL, 0);			\
+								\
+	debug->__name.write(intf->rt2x00dev,			\
+			    intf->offset_##__name, value);	\
+								\
+	*offset += size;					\
+	return size;						\
+}
+
+#define RT2X00DEBUGFS_OPS(__name, __format, __type)		\
+RT2X00DEBUGFS_OPS_READ(__name, __format, __type);		\
+RT2X00DEBUGFS_OPS_WRITE(__name, __type);			\
+								\
+static const struct file_operations rt2x00debug_fop_##__name = {\
+	.owner		= THIS_MODULE,				\
+	.read		= rt2x00debug_read_##__name,		\
+	.write		= rt2x00debug_write_##__name,		\
+	.open		= rt2x00debug_file_open,		\
+	.release	= rt2x00debug_file_release,		\
+};
+
+RT2X00DEBUGFS_OPS(csr, "0x%.8x\n", u32);
+RT2X00DEBUGFS_OPS(eeprom, "0x%.4x\n", u16);
+RT2X00DEBUGFS_OPS(bbp, "0x%.2x\n", u8);
+RT2X00DEBUGFS_OPS(rf, "0x%.8x\n", u32);
+
+static struct dentry *rt2x00debug_create_file_driver(const char *name,
+						     struct rt2x00debug_intf
+						     *intf,
+						     struct debugfs_blob_wrapper
+						     *blob)
+{
+	char *data;
+
+	data = kzalloc(3 * PRINT_LINE_LEN_MAX, GFP_KERNEL);
+	if (!data)
+		return NULL;
+
+	blob->data = data;
+	data += sprintf(data, "driver: %s\n", DRIVER_NAME);
+	data += sprintf(data, "version: %s\n", DRIVER_VERSION);
+	data += sprintf(data, "compiled: %s %s\n", __DATE__, __TIME__);
+	blob->size = strlen(blob->data);
+
+	return debugfs_create_blob(name, S_IRUGO, intf->driver_folder, blob);
+}
+
+static struct dentry *rt2x00debug_create_file_chipset(const char *name,
+						      struct rt2x00debug_intf
+						      *intf,
+						      struct
+						      debugfs_blob_wrapper
+						      *blob)
+{
+	const struct rt2x00debug *debug = intf->debug;
+	char *data;
+
+	data = kzalloc(4 * PRINT_LINE_LEN_MAX, GFP_KERNEL);
+	if (!data)
+		return NULL;
+
+	blob->data = data;
+	data += sprintf(data, "csr length: %d\n", debug->csr.word_count);
+	data += sprintf(data, "eeprom length: %d\n", debug->eeprom.word_count);
+	data += sprintf(data, "bbp length: %d\n", debug->bbp.word_count);
+	data += sprintf(data, "rf length: %d\n", debug->rf.word_count);
+	blob->size = strlen(blob->data);
+
+	return debugfs_create_blob(name, S_IRUGO, intf->driver_folder, blob);
+}
+
+void rt2x00debug_register(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2x00debug *debug = rt2x00dev->ops->debugfs;
+	struct rt2x00debug_intf *intf;
+
+	intf = kzalloc(sizeof(struct rt2x00debug_intf), GFP_KERNEL);
+	if (!intf)
+		return;
+
+	intf->debug = debug;
+	intf->rt2x00dev = rt2x00dev;
+	rt2x00dev->debugfs_intf = intf;
+
+	intf->driver_folder =
+	    debugfs_create_dir(DRIVER_NAME, NULL);
+	if (IS_ERR(intf->driver_folder))
+		goto exit;
+
+	intf->driver_entry =
+	    rt2x00debug_create_file_driver("driver", intf, &intf->driver_blob);
+	if (IS_ERR(intf->driver_entry))
+		goto exit;
+
+	intf->chipset_entry =
+	    rt2x00debug_create_file_chipset("chipset",
+					    intf, &intf->chipset_blob);
+	if (IS_ERR(intf->chipset_entry))
+		goto exit;
+
+#define RT2X00DEBUGFS_CREATE_ENTRY(__intf, __name)		\
+({								\
+	(__intf)->__name##_off_entry =				\
+	    debugfs_create_u32(__stringify(__name) "_offset",	\
+			       S_IRUGO | S_IWUSR,		\
+			       (__intf)->driver_folder,		\
+			       &(__intf)->offset_##__name);	\
+	if (IS_ERR((__intf)->__name##_off_entry))		\
+		goto exit;					\
+								\
+	(__intf)->__name##_val_entry =				\
+	    debugfs_create_file(__stringify(__name) "_value",	\
+				S_IRUGO | S_IWUSR,		\
+				(__intf)->driver_folder,	\
+				(__intf), &rt2x00debug_fop_##__name);\
+	if (IS_ERR((__intf)->__name##_val_entry))		\
+		goto exit;					\
+})
+
+	RT2X00DEBUGFS_CREATE_ENTRY(intf, csr);
+	RT2X00DEBUGFS_CREATE_ENTRY(intf, eeprom);
+	RT2X00DEBUGFS_CREATE_ENTRY(intf, bbp);
+	RT2X00DEBUGFS_CREATE_ENTRY(intf, rf);
+
+#undef RT2X00DEBUGFS_CREATE_ENTRY
+
+	return;
+
+exit:
+	rt2x00debug_deregister(rt2x00dev);
+
+	return;
+}
+
+void rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;
+
+	if (unlikely(!intf))
+		return;
+
+	debugfs_remove(intf->rf_val_entry);
+	debugfs_remove(intf->rf_off_entry);
+	debugfs_remove(intf->bbp_val_entry);
+	debugfs_remove(intf->bbp_off_entry);
+	debugfs_remove(intf->eeprom_val_entry);
+	debugfs_remove(intf->eeprom_off_entry);
+	debugfs_remove(intf->csr_val_entry);
+	debugfs_remove(intf->csr_off_entry);
+	debugfs_remove(intf->chipset_entry);
+	debugfs_remove(intf->driver_entry);
+	debugfs_remove(intf->driver_folder);
+	kfree(intf->chipset_blob.data);
+	kfree(intf->driver_blob.data);
+	kfree(intf);
+
+	rt2x00dev->debugfs_intf = NULL;
+}
+#endif /* RT2X00DEBUGFS */
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt2x00debug.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt2x00debug.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt2x00debug.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt2x00debug.h	2008-05-09 06:24:58.000000000 +0200
@@ -20,57 +20,54 @@
 
 /*
 	Module: rt2x00debug
-	Abstract: Data structures for the rt2x00debug module.
-	Supported chipsets: RT2460, RT2560, RT2570,
-	rt2561, rt2561s, rt2661 & rt2573.
+	Abstract: Data structures for the rt2x00debug.
  */
 
-typedef void (debug_access_t)(void *dev, const unsigned long word, void *data);
+#ifndef RT2X00DEBUG_H
+#define RT2X00DEBUG_H
 
-struct rt2x00debug_reg {
-	debug_access_t *read;
-	debug_access_t *write;
+#include "rt_config.h"
 
-	unsigned int word_size;
-	unsigned int length;
-};
+struct rt2x00_dev;
 
-struct rt2x00debug {
-	/*
-	 * Name of the interface.
-	 */
-	char intf_name[16];
+#define RT2X00DEBUGFS_REGISTER_ENTRY(__name, __type)		\
+struct reg##__name {						\
+	void (*read)(const struct rt2x00_dev *rt2x00dev,	\
+		     const unsigned int word, __type *data);	\
+	void (*write)(const struct rt2x00_dev *rt2x00dev,	\
+		      const unsigned int word, __type data);	\
+								\
+	unsigned int word_size;					\
+	unsigned int word_count;				\
+} __name
 
+struct rt2x00debug {
 	/*
 	 * Reference to the modules structure.
 	 */
 	struct module *owner;
 
 	/*
-	 * Driver module information
+	 * Register access entries.
 	 */
-	char *mod_name;
-	char *mod_version;
+	RT2X00DEBUGFS_REGISTER_ENTRY(csr, u32);
+	RT2X00DEBUGFS_REGISTER_ENTRY(eeprom, u16);
+	RT2X00DEBUGFS_REGISTER_ENTRY(bbp, u8);
+	RT2X00DEBUGFS_REGISTER_ENTRY(rf, u32);
+};
 
-	/*
-	 * Register access information.
-	 */
-	struct rt2x00debug_reg reg_csr;
-	struct rt2x00debug_reg reg_eeprom;
-	struct rt2x00debug_reg reg_bbp;
+struct rt2x00_ops {
+	const struct rt2x00debug *debugfs;
+};
 
-	/*
-	 * Pointer to driver structure where
-	 * this debugfs entry belongs to.
-	 */
-	void *dev;
+struct rt2x00_dev {
+	RTMP_ADAPTER *pAd;
 
-	/*
-	 * Pointer to rt2x00debug private data,
-	 * individual driver should not touch this.
-	 */
-	void *priv;
+	const struct rt2x00debug_intf *debugfs_intf;
+	struct rt2x00_ops *ops;
 };
 
-extern int rt2x00debug_register(struct rt2x00debug *debug);
-extern void rt2x00debug_deregister(struct rt2x00debug *debug);
+void rt2x00debug_register(struct rt2x00_dev *rt2x00dev);
+void rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev);
+
+#endif /* RT2X00DEBUG_H */
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt73.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt73.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt73.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt73.h	2008-05-09 06:24:59.000000000 +0200
@@ -298,26 +298,29 @@ typedef struct _HW_PAIRWISE_TA_ENTRY {  
 //
 #ifdef BIG_ENDIAN
 typedef	struct	_TXD_STRUC {
-	//Word 0
-	ULONG       Reserved:7;
-	ULONG       bWaitingDmaDoneInt:1; // pure s/w flag. 1:TXD been filled with data and waiting for TxDoneISR for housekeeping
-	ULONG       BbpTxPower:8;
-	ULONG       PktId:8;            // driver assigned packet ID to categorize TXResult in TxDoneInterrupt
-	ULONG       FrameOffset:8;      // frame start offset inside ASIC TXFIFO (after TXINFO field)
-
-	// Word	1
-	ULONG       Eiv;
-
-	// Word	2
-	ULONG       Iv;
+	// Word 0
+	ULONG       CipherAlg:3;
+	ULONG       Burst2:1;			// definition as same as "Burst", for backward compatible set this one to the same as "Burst" set.
+	ULONG       DataByteCnt:12;
+	ULONG       KeyIndex:6;         // Key index (0~31) to the pairwise KEY table; or
+									// 0~3 to shared KEY table 0 (BSS0). STA always use BSS0
+									// 4~7 to shared KEY table 1 (BSS1)
+									// 8~11 to shared KEY table 2 (BSS2)
+									// 12~15 to shared KEY table 3 (BSS3)
 
-	// Word	3
-	ULONG      	PlcpLengthHigh:8;
-	ULONG      	PlcpLengthLow:8;
-	ULONG      	PlcpService:8;
-	ULONG      	PlcpSignal:8;
+	ULONG       KeyTable:1;        	// 1: use per-client pairwise KEY table, 0: shared KEY table
+	ULONG       TkipMic:1;         	// 1: ASIC is responsible for appending TKIP MIC if TKIP is inused
+	ULONG		RetryMd:1;         	// 1: Long retry (4 times), 0: short retry (7 times)
+	ULONG		IFS:1;             	// 1: require a BACKOFF before this frame, 0:SIFS before this frame
+	ULONG      	Ofdm:1;				// 1: TX using OFDM rates
+	ULONG		Timestamp:1;		// 1: MAC auto overwrite current TSF into frame body
+	ULONG		ACK:1;             	// 1: ACK is required
+	ULONG		MoreFrag:1;			// 1: More fragment following this frame
+	ULONG		Drop:1;				// 0: skip this frame, 1:valid frame inside
+	ULONG		Burst:1;			// 1: Contiguously used current End Ponit, eg, Fragment packet should turn on.
+									//	Tell EDCA that the next frame belongs to the same "burst" even though TXOP=0
 
-	//Word 4
+	// Word	1
 	ULONG       BufCount:3;         // number of buffers in this TXD
 	ULONG       HwSeq:1;            // MAC auto replace the 12-bit frame sequence #
 	ULONG       :6;
@@ -327,27 +330,31 @@ typedef	struct	_TXD_STRUC {
 	ULONG       Aifsn:4;
 	ULONG       HostQId:4;          // EDCA/HCCA queue ID
 
-	//Word 5
-	ULONG       CipherAlg:3;
-	ULONG       Burst2:1;            // definition as same as "Burst", for backward compatible set this one to the same as "Burst" set.
-	ULONG       DataByteCnt:12;
-	ULONG       KeyIndex:6;         // Key index (0~31) to the pairwise KEY table; or
-									// 0~3 to shared KEY table 0 (BSS0). STA always use BSS0
-									// 4~7 to shared KEY table 1 (BSS1)
-									// 8~11 to shared KEY table 2 (BSS2)
-									// 12~15 to shared KEY table 3 (BSS3)
-	ULONG       KeyTable:1;         	// 1: use per-client pairwise KEY table, 0: shared KEY table
-	ULONG       TkipMic:1;          	// 1: ASIC is responsible for appending TKIP MIC if TKIP is inused
-	ULONG		RetryMd:1;          	// 1: Long retry (4 times), 0: short retry (7 times)
-	ULONG		IFS:1;              	// 1: require a BACKOFF before this frame, 0:SIFS before this frame
-	ULONG       	Ofdm:1;             	// 1: TX using OFDM rates
-	ULONG		Timestamp:1;    	// 1: MAC auto overwrite current TSF into frame body
-	ULONG		ACK:1;              	// 1: ACK is required
-	ULONG		MoreFrag:1;		// 1: More fragment following this frame
-	ULONG		Drop:1;			// 0: skip this frame, 1:valid frame inside
-	ULONG		Burst:1;		// 1: Contiguously used current End Ponit, eg, Fragment packet should turn on.
-						//	Tell EDCA that the next frame belongs to the same "burst" even though TXOP=0
+	// Word	2
+	ULONG      	PlcpLengthHigh:8;
+	ULONG      	PlcpLengthLow:8;
+	ULONG      	PlcpService:8;
+	ULONG      	PlcpSignal:8;
 
+	// Word	3
+	ULONG       Iv;
+
+	// Word	4
+	ULONG       Eiv;
+
+	// Word 5
+	ULONG       Reserved:7;
+	ULONG       bWaitingDmaDoneInt:1; // pure s/w flag. 1:TXD been filled with data and waiting for TxDoneISR for housekeeping
+	ULONG       BbpTxPower:8;
+	ULONG       PktId:8;            // driver assigned packet ID to categorize TXResult in TxDoneInterrupt
+	ULONG       FrameOffset:8;      // frame start offset inside ASIC TXFIFO (after TXINFO field)
+
+	// the above 24-byte is called TXINFO and will be DMAed to MAC block through TXFIFO.
+	// MAC block use this TXINFO to control the transmission behavior of this frame.
+
+	// The following fields are not used by MAC block. They are used by DMA block and HOST
+	// driver only. Once a frame has been DMA to ASIC, all the following fields are useless
+	// to ASIC.
 }	TXD_STRUC, *PTXD_STRUC;
 #else
 typedef	struct	_TXD_STRUC {
@@ -417,23 +424,7 @@ typedef	struct	_TXD_STRUC {
 //
 #ifdef BIG_ENDIAN
 typedef	struct	_RXD_STRUC	{
-	//Word 0
-	ULONG		Rsv3;	// BufPhyAddr;
-
-	//Word 1
-	ULONG		Rsv2;
-
-	//Word 2
-	ULONG		Iv;                 // received IV if originally encrypted; for replay attack checking
-
-	//Word 3
-	ULONG		Rsv1:1;
-	ULONG		FrameOffset:7;
-	ULONG		Rsv0:8;
-	ULONG		PlcpRssi:8;         // RSSI reported by BBP
-	ULONG		PlcpSignal:8;       // RX raw data rate reported by BBP
-
-	//Word 4
+	// Word	0
 	ULONG		CipherAlg:3;
 	ULONG		Rsv:1;
 	ULONG		DataByteCnt:12;
@@ -449,6 +440,43 @@ typedef	struct	_RXD_STRUC	{
 	ULONG		Drop:1;             // 1: drop without receiving to HOST
 	ULONG		Owner:1;            // 1: owned by ASIC, 0: owned by HOST driver
 
+	// Word 1
+	ULONG		Rsv1:1;
+	ULONG		FrameOffset:7;
+	ULONG		Rsv0:8;
+	ULONG		PlcpRssi:8;         // RSSI reported by BBP
+	ULONG		PlcpSignal:8;       // RX raw data rate reported by BBP
+
+	// Word 2
+	ULONG		Iv;                 // received IV if originally encrypted; for replay attack checking
+
+	// Word 3
+	ULONG       Eiv;                // received EIV if originally encrypted; for replay attack checking
+
+	// Word 4
+	ULONG		Rsv2;
+
+	// The above 20-byte is called RXINFO and is prepared by MAC RX block and passed
+	// the HOST driver.
+
+	// The following fields are for DMA block and HOST usage only. Can't be touched
+	// by ASIC MAC block.
+
+	// Word	5
+	ULONG		Rsv3;	// BufPhyAddr;
+#if 0
+	// Word	6~15
+	ULONG       Rsv3;
+	ULONG       Rsv4;
+	ULONG       Rsv5;
+	ULONG       Rsv6;
+	ULONG       Rsv7;
+	ULONG       Rsv8;
+	ULONG       Rsv9;
+	ULONG       Rsv10;
+	ULONG       Rsv11;
+	ULONG       Rsv12;
+#endif
 }	RXD_STRUC, *PRXD_STRUC;
 #else
 typedef	struct	_RXD_STRUC	{
@@ -824,7 +852,7 @@ typedef	union	_MAC_CSR9_STRUC	{
 //
 // MAC_CSR11: Power saving transition time register
 //
-#ifdef BG_ENDIAN
+#ifdef BIG_ENDIAN
 typedef union _MAC_CSR11_STRUC {
 	struct {
 		ULONG       :12;
@@ -861,7 +889,7 @@ typedef	union	_MAC_CSR12_STRUC	{
 		ULONG		CurrentPowerState:1;	// 0:sleep, 1:awake
 	}	field;
 	ULONG			word;
-}	PMAC_CSR12_STRUC, *PMAC_CSR12_STRUC;
+}	MAC_CSR12_STRUC, *PMAC_CSR12_STRUC;
 #else
 typedef	union	_MAC_CSR12_STRUC	{
 	struct	{
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt_config.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt_config.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rt_config.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rt_config.h	2008-05-09 06:24:59.000000000 +0200
@@ -36,12 +36,17 @@
 #ifndef	__RT_CONFIG_H__
 #define	__RT_CONFIG_H__
 
+// Propagate predefined compiler variables asap - bb.
+#if defined(__BIG_ENDIAN) || defined(__BIG_ENDIAN__) || defined(_BIG_ENDIAN)
+#define BIG_ENDIAN TRUE
+#endif /* __BIG_ENDIAN */
+
 #define PROFILE_PATH                "/etc/Wireless/RT73STA/rt73sta.dat"
 #define NIC_DEVICE_NAME             "RT73STA"
 #define RT2573_IMAGE_FILE_NAME      "rt73.bin"
 #define DRIVER_NAME                 "rt73"
 #define DRIVER_VERSION		    "1.0.3.6 CVS"
-#define DRIVER_RELDATE              "2007091001"
+#define DRIVER_RELDATE              "2008050900"
 
 // Query from UI
 #define DRV_MAJORVERSION        1
@@ -76,9 +81,9 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
+#include <linux/delay.h>		// For udelay, mdelay
 #include <linux/wireless.h>
 #include <linux/proc_fs.h>
-#include <linux/delay.h>
 #include <linux/if_arp.h>
 #include <linux/ctype.h>
 #include <linux/sched.h>
@@ -185,7 +190,6 @@ typedef union _LARGE_INTEGER {
 //
 //	Miniport defined header files
 //
-#include	"rt2x00debug.h"
 #include	"rtmp_type.h"
 #include	"rtmp_def.h"
 #include    "oid.h"
@@ -193,14 +197,19 @@ typedef union _LARGE_INTEGER {
 #include    "md5.h"
 #include    "wpa.h"
 #include	"rtmp.h"
+#include	"rt2x00debug.h"
 
-
-#define MEM_ALLOC_FLAG      (GFP_DMA | GFP_ATOMIC)
+#define MEM_ALLOC_FLAG      (GFP_DMA | GFP_KERNEL)
 
 #ifndef KERNEL_VERSION
 #define KERNEL_VERSION(a,b,c) ((a)*65536+(b)*256+(c))
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25)
+/* 2.6 compatibility */
+#define SET_NETDEV_DEV(net, pdev) do { } while (0)
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,29)
 static inline unsigned int jiffies_to_msecs(const unsigned long j)
 {
@@ -236,20 +245,33 @@ static inline unsigned long msecs_to_jif
 	return (m * HZ + 999) / 1000;
 #endif
 }
+#endif
 
-static inline void msleep(unsigned long msecs)
-{
-        set_current_state(TASK_UNINTERRUPTIBLE);
-        schedule_timeout(msecs_to_jiffies(msecs) + 1);
-}
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,35) )
+// This forward compatibility macro appeared in 2.4.35 and
+// is copied from that patch file - bb.
+#define msleep(x)	do { set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000 + 2); \
+			} while (0)
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define reserve_module(x)	try_module_get(x)
+#define release_module(x)	module_put(x)
 #define rtusb_submit_urb(purb) usb_submit_urb(purb, GFP_KERNEL)
 #else
+#define usb_get_dev			usb_inc_dev_use
+#define usb_put_dev			usb_dec_dev_use
+#define reserve_module(x)  	MOD_INC_USE_COUNT
+#define release_module(x)	MOD_DEC_USE_COUNT
 #define rtusb_submit_urb(purb) usb_submit_urb(purb)
 #endif
 
+// 2.5.44? 2.5.26?
+#ifndef smp_read_barrier_depends
+#define smp_read_barrier_depends() ((void)0)
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
 #define RTUSB_UNLINK_URB(urb)	usb_kill_urb(urb)
 #else
@@ -264,6 +286,12 @@ static inline void msleep(unsigned long 
 
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
+#define SET_MODULE_OWNER(some_struct) do { } while (0)
+#define dev_get_by_name(slot_name) dev_get_by_name(&init_net, slot_name)
+#define first_net_device() first_net_device(&init_net)
+#endif
+
 #ifndef USB_ST_NOERROR
 #define  USB_ST_NOERROR     0
 #endif
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_def.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_def.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_def.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_def.h	2008-05-09 07:15:58.000000000 +0200
@@ -40,12 +40,6 @@
 //
 //	Debug information verbosity: lower values indicate higher urgency
 //
-
-#ifdef __BIG_ENDIAN
-#warning "Big endian support is still experimental, use at your own risk."
-#define BIG_ENDIAN
-#endif
-
 #define RT_DEBUG_OFF		0
 #define RT_DEBUG_ERROR		1
 #define RT_DEBUG_WARN		2
@@ -822,12 +816,13 @@ typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH
  /* ASUS */\
  {USB_DEVICE(0x0b05,0x1723)},\
  {USB_DEVICE(0x0b05,0x1724)},\
- /* Buffalo */\                                                                                                                     
+ /* Buffalo */\
  {USB_DEVICE(0x0411,0x00f4)},\
  /* Belkin */\
  {USB_DEVICE(0x050d,0x7050)},\
  {USB_DEVICE(0x050d,0x705a)},\
  {USB_DEVICE(0x050d,0x905b)},\
+ {USB_DEVICE(0x050d,0x905c)},\
  /* Billionton */\
  {USB_DEVICE(0x1631,0xc019)},\
  /* CNet */\
@@ -835,10 +830,13 @@ typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH
  {USB_DEVICE(0x1371,0x9032)},\
  /* Conceptronic */\
  {USB_DEVICE(0x14b2,0x3c22)},\
+ /* Corega */\
+ {USB_DEVICE(0x07aa, 0x002e)}, /* CG-WLUSB2GPX*/\
  /* D-Link */\
  {USB_DEVICE(0x07d1,0x3c03)},\
  {USB_DEVICE(0x07d1,0x3c04)},\
  {USB_DEVICE(0x07d1,0x3c06)},\
+ {USB_DEVICE(0x07d1,0x3c07)},\
  /* Gemtek*/\
  {USB_DEVICE(0x15a9,0x0004)},\
  /* Gigabyte */\
@@ -854,6 +852,7 @@ typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH
  {USB_DEVICE(0x13b1,0x0023)},\
  /* MSI */\
  {USB_DEVICE(0x0db0,0x6877)},\
+ {USB_DEVICE(0x0db0,0x6874)},\
  {USB_DEVICE(0x0db0,0xa861)},\
  {USB_DEVICE(0x0db0,0xa874)},\
  /* Ralink */\
@@ -873,7 +872,7 @@ typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH
  {USB_DEVICE(0x2019,0xab50)},\
  /* Senao */\
  {USB_DEVICE(0x1740,0x7100)},\
- {USB_DEVICE(0,0)}} /* end marker */
+ {0}} /* end marker */
 
 
 #endif	// __RTMP_DEF_H__
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp.h	2008-05-09 06:24:59.000000000 +0200
@@ -125,6 +125,8 @@ typedef struct usb_ctrlrequest devctrlre
 typedef LONG		NTSTATUS;
 typedef NTSTATUS	*PNTSTATUS;
 
+#define KPRINT(Level, fmt, args...) \
+	printk(Level DRIVER_NAME ": " fmt, ## args)
 //
 //	Macro for debugging information
 //
@@ -143,7 +145,7 @@ extern ULONG	RTDebugLevel;
 {																	\
 	if (RT_DEBUG_ERROR & RTDebugLevel)										\
 	{																\
-		printk(KERN_DEBUG DRIVER_NAME " ERROR!!! " fmt, ## args);	\
+		printk(KERN_DEBUG DRIVER_NAME ": ERROR!!! " fmt, ## args);	\
 	}																\
 }
 
@@ -188,29 +190,29 @@ extern ULONG	RTDebugLevel;
 	spin_lock_init(lock);			\
 }
 #if 0
-#define NdisReleaseSpinLock(lock, flagg)    \
+#define NdisReleaseSpinLock(lock)    \
 {											\
 	if (in_interrupt())						\
-		spin_unlock_irqrestore(lock, flagg);\
+		spin_unlock_irqrestore(lock, flags);\
 	else									\
 		spin_unlock(lock);					\
 }
 
-#define NdisAcquireSpinLock(lock, flagg)    \
+#define NdisAcquireSpinLock(lock)    \
 {											\
 	if (in_interrupt())						\
-		spin_lock_irqsave(lock, flagg);		\
+		spin_lock_irqsave(lock, flags);		\
 	else									\
 		spin_lock(lock);					\
 }
 #else
-#define NdisReleaseSpinLock(lock, flagg)	\
+#define NdisReleaseSpinLock(lock)	\
 {											\
-	spin_unlock_irqrestore(lock, (unsigned long)flagg);	\
+	spin_unlock_irqrestore(lock, (unsigned long)flags);	\
 }
-#define NdisAcquireSpinLock(lock, flagg)	\
+#define NdisAcquireSpinLock(lock)	\
 {											\
-	spin_lock_irqsave(lock, flagg);			\
+	spin_lock_irqsave(lock, flags);			\
 }
 #endif
 
@@ -661,7 +663,6 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
 	(_t)->bWaitingBulkOut = FALSE;		\
 	(_t)->BulkOutSize= 0;				\
 	(_p)->NextBulkOutIndex[_b] = (((_p)->NextBulkOutIndex[_b] + 1) % TX_RING_SIZE);	\
-	atomic_dec(&(_p)->TxCount); \
 }
 
 #define	LOCAL_TX_RING_EMPTY(_p, _i)		(((_p)->TxContext[_i][(_p)->NextBulkOutIndex[_i]].InUse) == FALSE)
@@ -1079,8 +1080,7 @@ typedef struct _MLME_STRUCT {
 	ULONG					ChannelQuality;  // 0..100, Channel Quality Indication for Roaming
 	unsigned long				Now;			 // latch the value of NdisGetSystemUpTime()
 
-	BOOLEAN 				bRunning;
-	spinlock_t				TaskLock;
+	BOOLEAN 				Running;
 	MLME_QUEUE				Queue;
 
 	UINT					ShiftReg;
@@ -1347,7 +1347,6 @@ typedef struct _RTMP_ADAPTER
 	struct usb_config_descriptor	*config;
 	devctrlrequest					*devreq;
 
-	struct rt2x00debug debug;
 	INT	EAPOLVer;
 
 	/* The device we're working with
@@ -1359,7 +1358,8 @@ typedef struct _RTMP_ADAPTER
 	struct semaphore	mlme_semaphore;			/* to sleep thread on	*/
 	struct semaphore	RTUSBCmd_semaphore;		/* to sleep thread on	*/
 
-	struct completion	notify;					/* thread begin/end	 */
+	struct completion	mlmenotify;				/* thread begin/end	 */
+	struct completion	cmdnotify;				/* thread begin/end	 */
 	pid_t			MLMEThr_pid;
 	pid_t			RTUSBCmdThr_pid;
 
@@ -1387,9 +1387,13 @@ typedef struct _RTMP_ADAPTER
 	HEADER_802_11			NullFrame;
 
 	// configuration: read from Registry & E2PROM
-	BOOLEAN 				bLocalAdminMAC; 					// Use user changed MAC
-	UCHAR					PermanentAddress[MAC_ADDR_LEN]; 	// Factory default MAC address
-	UCHAR					CurrentAddress[MAC_ADDR_LEN];		// User changed MAC address
+	BOOLEAN bLocalAdminMAC; 					// Use user changed MAC
+
+	// Factory default MAC address
+	UCHAR	PermanentAddress[MAC_ADDR_LEN] ALIGN_USB_RCV;
+
+	// User changed MAC address
+	UCHAR	CurrentAddress[MAC_ADDR_LEN];
 
 	MLME_STRUCT 			Mlme;
 
@@ -1545,16 +1549,13 @@ typedef struct _RTMP_ADAPTER
 	// SpinLocks
 	spinlock_t			SendTxWaitQueueLock[4]; // SendTxWaitQueue spinlock
 
-	spinlock_t			DataQLock[4];
 	spinlock_t			DeQueueLock[4];
 
 	spinlock_t			MLMEWaitQueueLock;	// SendTxWaitQueue spinlock
 	spinlock_t			CmdQLock;			// SendTxWaitQueue spinlock
 	spinlock_t			BulkOutLock[4];		// SendTxWaitQueue spinlock for 4 ACs
 
-//	spinlock_t			ControlLock;		// SendTxWaitQueue spinlock
 	spinlock_t			MLMEQLock;			// SendTxWaitQueue spinlock
-//	spinlock_t			GenericLock;		// SendTxWaitQueue spinlock
 
 	/////////////////////
 	// Transmit Path
@@ -1578,6 +1579,7 @@ typedef struct _RTMP_ADAPTER
 	UCHAR					PopMgmtIndex;				// Next SW management ring index
 	atomic_t				MgmtQueueSize;				// Number of Mgmt request stored in MgmtRing
 	UCHAR					NextRxBulkInIndex;
+	UCHAR					CurRxBulkInIndex;
 
 	// 4 sets of Bulk Out index and pending flag
 	UCHAR					NextBulkOutIndex[4];
@@ -1587,9 +1589,7 @@ typedef struct _RTMP_ADAPTER
 	ULONG					PrioRingTxCnt;
 	UCHAR					PrioRingFirstIndex;
 
-	atomic_t				TxCount;		// Number of Bulkout waiting to be send.
-	LONG					PendingTx;
-
+	atomic_t				PendingTx;		// Number of Bulkout waiting to be send.
 	// Data related context and AC specified, 4 AC supported
 	TX_CONTEXT				TxContext[4][TX_RING_SIZE];
 	LONG					NumPacketsQueued[4];
@@ -1612,7 +1612,6 @@ typedef struct _RTMP_ADAPTER
 	// Flags for bulk out data priority
 	ULONG					BulkFlags;
 
-//	spinlock_t				MemLock;	// need to check
 	ULONG					BulkOutDataOneSecCount;
 	ULONG					BulkInDataOneSecCount;
 	ULONG					BulkLastOneSecCount; // BulkOutDataOneSecCount + BulkInDataOneSecCount
@@ -1666,7 +1665,8 @@ long rt_abs(long arg);
 //
 // Routines in rtmp_init.c
 //
-VOID CreateThreads( struct net_device *net_dev );
+VOID CreateThreads(PRTMP_ADAPTER pAd);
+void KillThreads(PRTMP_ADAPTER pAd);
 
 NDIS_STATUS NICInitTransmit(
 	IN	PRTMP_ADAPTER	 pAd );
@@ -1679,7 +1679,7 @@ VOID ReleaseAdapter(
     IN  BOOLEAN         IsFree,
     IN  BOOLEAN         IsOnlyTx);
 
-NDIS_STATUS	RTMPInitAdapterBlock(
+VOID	RTMPInitAdapterBlock(
 	IN	PRTMP_ADAPTER	pAd);
 
 NDIS_STATUS	RTUSBWriteHWMACAddress(
@@ -2003,6 +2003,9 @@ NDIS_STATUS MlmeInit(
 VOID MlmeHandler(
 	IN PRTMP_ADAPTER pAd);
 
+VOID MlmeStart(
+	IN PRTMP_ADAPTER pAd);
+
 VOID MlmeHalt(
 	IN PRTMP_ADAPTER pAd) ;
 
@@ -2013,9 +2016,12 @@ VOID MlmeSuspend(
 VOID MlmeResume(
 	IN	PRTMP_ADAPTER	pAd);
 
-VOID MlmePeriodicExec(
+VOID MlmePeriodicExecTimeout(
 	IN	unsigned long data);
 
+VOID MlmePeriodicExec(
+	IN	PRTMP_ADAPTER pAd);
+
 VOID STAMlmePeriodicExec(
 	IN	PRTMP_ADAPTER pAd);
 
@@ -2089,9 +2095,12 @@ BOOLEAN MlmeEnqueueForRecv(
 	IN VOID *Msg,
 	IN UCHAR Signal);
 
+BOOLEAN MlmeGetHead(
+    IN MLME_QUEUE *Queue,
+    OUT MLME_QUEUE_ELEM **Elem);
+
 BOOLEAN MlmeDequeue(
-	IN MLME_QUEUE *Queue,
-	OUT MLME_QUEUE_ELEM **Elem);
+    IN MLME_QUEUE *Queue);
 
 VOID MlmeRestartStateMachine(
 	IN	PRTMP_ADAPTER	pAd);
@@ -2890,6 +2899,9 @@ VOID	RTMPDeQueuePacket(
 VOID	RTUSBRxPacket(
 	IN	 unsigned long data);
 
+VOID	RTUSBDequeueRxPackets(
+	IN	PRTMP_ADAPTER	pAd);
+
 VOID	RTUSBDequeueMLMEPacket(
 	IN	PRTMP_ADAPTER	pAd);
 
@@ -3513,6 +3525,9 @@ static inline VOID	RTMPFrameEndianChange
 				// swab 16 bit fields - CapabilityInfo field
 				pMacHdr += sizeof(USHORT);
 				*(USHORT *)pMacHdr = SWAP16(*(USHORT *)pMacHdr);
+
+				// swab AtimWin is too tough to do here because
+				// its preceeded by IEs
 				break;
 
 			case SUBTYPE_DEAUTH:
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_info.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_info.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_info.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_info.c	2008-05-09 06:24:59.000000000 +0200
@@ -40,7 +40,6 @@
 #include	"rt_config.h"
 #include <net/iw_handler.h>
 
-
 #ifdef DBG
 extern ULONG	RTDebugLevel;
 #endif
@@ -109,10 +108,12 @@ struct iw_priv_args privtab[] = {
 
 };
 
-static struct {
+struct rt_priv_support {
 	CHAR *name;
 	INT (*set_proc)(PRTMP_ADAPTER pAdapter, PUCHAR arg);
-} *PRTMP_PRIVATE_SET_PROC, RTMP_PRIVATE_SUPPORT_PROC[] = {
+};
+
+static struct rt_priv_support RTMP_PRIVATE_SUPPORT_PROC[] = {
 	{"DriverVersion",				Set_DriverVersion_Proc},
 	{"CountryRegion",				Set_CountryRegion_Proc},
 	{"CountryRegionABand",			Set_CountryRegionABand_Proc},
@@ -183,9 +184,10 @@ int rt_ioctl_siwfreq(struct net_device *
     if (pAdapter->RTUSBCmdThr_pid < 0)
         return -ENETDOWN;
 
-	if (freq->e > 1)
+	if (freq->e > 1) {
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		return -EINVAL;
-
+	}
 	if((freq->e == 0) && (freq->m <= 1000))
 		chan = freq->m;	// Setting by channel number
 	else
@@ -577,8 +579,10 @@ int rt_ioctl_siwscan(struct net_device *
     if (pAdapter->RTUSBCmdThr_pid < 0)
         return -ENETDOWN;
 
-	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		return 0;
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
+		DBGPRINT(RT_DEBUG_TRACE,"<===rt_ioctl_siwscan still scanning\n");
+		return -EINPROGRESS;
+	}
 	do{
 		Now = jiffies;
 
@@ -597,6 +601,8 @@ int rt_ioctl_siwscan(struct net_device *
 
 		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE  && (pAdapter->MLMEThr_pid > 0))
 		{
+			DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle (state=%d)\n",
+					__FUNCTION__, pAdapter->Mlme.CntlMachine.CurrState);
 			MlmeEnqueue(pAdapter,
                         MLME_CNTL_STATE_MACHINE,
                         RT_CMD_RESET_MLME,
@@ -622,6 +628,7 @@ int rt_ioctl_siwscan(struct net_device *
 		//StateMachineTouched = TRUE;
 
 	}while(0);
+	DBGPRINT(RT_DEBUG_TRACE,"<===rt_ioctl_siwscan\n");
 	return 0;
 }
 
@@ -860,7 +867,8 @@ rt_ioctl_giwscan(struct net_device *dev,
 
 	}
 	data->length = current_ev - extra;
-	DBGPRINT(RT_DEBUG_ERROR,"===>rt_ioctl_giwscan. %d(%d) BSS returned\n",i , pAdapter->ScanTab.BssNr);
+	DBGPRINT(RT_DEBUG_TRACE,"<===rt_ioctl_giwscan. %d(%d) BSS returned\n",
+			i, pAdapter->ScanTab.BssNr);
 	return 0;
 }
 #endif
@@ -874,14 +882,10 @@ int rt_ioctl_siwessid(struct net_device 
 	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
 	ULONG		Length;
 
-    //check if the interface is down
-    if (pAdapter->RTUSBCmdThr_pid < 0)
-        return -ENETDOWN;
-
     memset(&Ssid, 0, sizeof(NDIS_802_11_SSID));
 
 	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-	Length = data->length - 1;
+	Length = data->length - 1;	// minus null character
 	#else
 	Length = data->length;
 	#endif
@@ -902,46 +906,37 @@ int rt_ioctl_siwessid(struct net_device 
 	else
 	{
 		Ssid.SsidLength = 0;  // ANY ssid
-        memcpy(Ssid.Ssid, "", 0);
+		Ssid.Ssid[0] = 0;
 
 		// reset to infra/open/none as the user set ANY ssid
         // $ iwconfig [interface] essid ""
 		pAdapter->PortCfg.BssType = BSS_INFRA;
-		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;//FIXME whaa? - bb
 		pAdapter->PortCfg.WepStatus  = Ndis802_11EncryptionDisabled;
     }
 
 	pSsid = &Ssid;
+	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
 
-	if ((pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) && (pAdapter->MLMEThr_pid > 0))
+	if ((pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE))
 	{
+		DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle\n",
+				__FUNCTION__);
 		MlmeEnqueue(pAdapter,
                     MLME_CNTL_STATE_MACHINE,
                     RT_CMD_RESET_MLME,
                     0,
                     NULL);
     }
-
-	// tell CNTL state machine to call NdisMSetInformationComplete() after completing
-	// this request, because this request is initiated by NDIS.
-
-	// To prevent some kernel thread is very low priority ...so essid copy immediately for later wpapsk counting.
-	if ((pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA) && (pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone))
-		memcpy(pAdapter->MlmeAux.Ssid, Ssid.Ssid, Ssid.SsidLength);
-
-	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-	DBGPRINT(RT_DEBUG_TRACE,"===>rt_ioctl_siwessid:: (Ssid.SsidLength = %d, %s)\n",Ssid.SsidLength, Ssid.Ssid);
-
-	if (pAdapter->MLMEThr_pid > 0)
-	{
-		MlmeEnqueue(pAdapter,
-					MLME_CNTL_STATE_MACHINE,
-					OID_802_11_SSID,
-					sizeof(NDIS_802_11_SSID),
-					(VOID *)pSsid);
-	}
+	MlmeEnqueue(pAdapter,
+				MLME_CNTL_STATE_MACHINE,
+				OID_802_11_SSID,
+				sizeof(NDIS_802_11_SSID),
+				(VOID *)pSsid);
 	RTUSBMlmeUp(pAdapter);
-
+	DBGPRINT(RT_DEBUG_TRACE,
+			"<-- rt_ioctl_siwessid:: (Ssid.SsidLength = %d, %s)\n",
+			Ssid.SsidLength, Ssid.Ssid);
 	return 0;
 }
 
@@ -1017,8 +1012,10 @@ int rt_ioctl_siwrts(struct net_device *d
 
 	if (rts->disabled)
 		val = MAX_RTS_THRESHOLD;
-	else if (rts->value < 0 || rts->value > MAX_RTS_THRESHOLD)
+	else if (rts->value < 0 || rts->value > MAX_RTS_THRESHOLD) {
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		return -EINVAL;
+	}
 	else if (rts->value == 0)
 		val = MAX_RTS_THRESHOLD;
 	else
@@ -1063,9 +1060,10 @@ int rt_ioctl_siwfrag(struct net_device *
 		val = __cpu_to_le16(rts->value & ~0x1); /* even numbers only */
 	else if (rts->value == 0)
 		val = MAX_FRAG_THRESHOLD;
-	else
+	else {
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		return -EINVAL;
-
+	}
 	pAdapter->PortCfg.FragmentThreshold = val;
 	return 0;
 }
@@ -1129,14 +1127,20 @@ int rt_ioctl_siwencode(struct net_device
 	if ((erq->flags & IW_ENCODE_DISABLED) == 0)
 	{
 		/* Enable crypto. */
-		if (erq->length > IFNAMSIZ)
+		if (erq->length > IFNAMSIZ) {
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid length argument (%d)\n",
+					__FUNCTION__, erq->length);
 			return -EINVAL;
-
+		}
 		/* Old solution to take  default key  */
 		index = (erq->flags & IW_ENCODE_INDEX) ;
-		if((index < 0) || (index > NR_WEP_KEYS))
+		if((index < 0) || (index > NR_WEP_KEYS)) {
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid index argument (%d)\n",
+					__FUNCTION__, index);
 			return -EINVAL;
-		DBGPRINT(RT_DEBUG_TRACE," erq->flags = %x\n",erq->flags);
+		}
+		DBGPRINT(RT_DEBUG_TRACE,"- %s: erq->length=%d, erq->flags=0x%04x\n",
+				__FUNCTION__, erq->length, erq->flags);
 
 		if (index != 0)
 		{
@@ -1147,10 +1151,13 @@ int rt_ioctl_siwencode(struct net_device
 		{
 			/* New solution to take  default key  when old way not work, not change KeyMaterial*/
 			memcpy(&kid, keybuf, 1 );
-			if((index < 0) || (index >= NR_WEP_KEYS))
+			if((index < 0) || (index >= NR_WEP_KEYS)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				return -EINVAL;
-
-			DBGPRINT(RT_DEBUG_TRACE,"kid = %d , erq->length = %d\n",kid, erq->length);
+			}
+			DBGPRINT(RT_DEBUG_TRACE,"kid = %d , erq->length = %d\n",
+					kid, erq->length);
 			if (kid > 0)
 				pAdapter->PortCfg.DefaultKeyId = kid-1;
 			else
@@ -1158,31 +1165,37 @@ int rt_ioctl_siwencode(struct net_device
 		}
 		else
 		{
-			DBGPRINT(RT_DEBUG_TRACE,"DefaultKeyId = %d , erq->length = %d, flags 0x%x\n",pAdapter->PortCfg.DefaultKeyId, erq->length,erq->flags);
+			DBGPRINT(RT_DEBUG_TRACE, "- %s: DefaultKeyId = %d, erq->length=%d, erq->flags=0x%04x\n", __FUNCTION__, pAdapter->PortCfg.DefaultKeyId, erq->length, erq->flags);
 			len = erq->length;
 			if(len > WEP_LARGE_KEY_LEN)
 				len = WEP_LARGE_KEY_LEN;
 
-			// If this instruction default key
-			memset(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, 0, MAX_LEN_OF_KEY);
-			memcpy(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, keybuf, len);
-			memcpy(WepKey.keyinfo.KeyMaterial, keybuf, len);
-			WepKey.keyinfo.KeyIndex = 0x80000000 + pAdapter->PortCfg.DefaultKeyId;
-			WepKey.keyinfo.KeyLength = len;
-			pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen =(UCHAR) (len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN);
-			DBGPRINT(RT_DEBUG_TRACE,"SharedKey	");
-			for (i=0; i < 5;i++)
-				DBGPRINT_RAW(RT_DEBUG_TRACE,"	%x ", pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key[i]);
-			DBGPRINT(RT_DEBUG_TRACE,   "\n");
-			// need to enqueue cmd to thread
-			RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey.keyinfo) + len - 1);
-
-		}
-
-	}
-	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::AuthMode=%x\n",pAdapter->PortCfg.AuthMode);
-	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",pAdapter->PortCfg.DefaultKeyId , pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen);
-	DBGPRINT(RT_DEBUG_TRACE, "==>rt_ioctl_siwencode::WepStatus=%x\n",pAdapter->PortCfg.WepStatus);
+			// If we're just turning on encryption, don't try to set key - bb
+			if (len) {
+				// If this instruction default key
+				memset(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, 0, MAX_LEN_OF_KEY);
+				memcpy(pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, keybuf, len);
+				memcpy(WepKey.keyinfo.KeyMaterial, keybuf, len);
+				WepKey.keyinfo.KeyIndex = 0x80000000 + pAdapter->PortCfg.DefaultKeyId;
+				WepKey.keyinfo.KeyLength = len;
+				pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen =(UCHAR) (len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN);
+				DBGPRINT(RT_DEBUG_TRACE,"SharedKey ");
+				for (i=0; i < 5;i++)
+					DBGPRINT_RAW(RT_DEBUG_TRACE," %02x ", pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].Key[i]);
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+				// need to enqueue cmd to thread
+				RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey.keyinfo) + len - 1);
+			}
+		}
+	} /* End if (encoding not disabled) */
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: AuthMode=%d"
+			" DefaultKeyId=%d, KeyLen=%d, WepStatus=%d\n",
+			__FUNCTION__,
+			pAdapter->PortCfg.AuthMode,
+			pAdapter->PortCfg.DefaultKeyId,
+			pAdapter->SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen,
+			pAdapter->PortCfg.WepStatus);
 	return 0;
 }
 
@@ -1247,26 +1260,31 @@ rt_ioctl_setparam(struct net_device *dev
 			 void *w, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = (PRTMP_ADAPTER) dev->priv;
+	struct rt_priv_support *PRTMP_PRIVATE_SET_PROC;
 	char *this_char = extra;
 	char *value;
 	int  Status=0;
 
+	DBGPRINT(RT_DEBUG_TRACE, "--> %s\n", __FUNCTION__);
+
     //check if the interface is down
     if (pAdapter->RTUSBCmdThr_pid < 0)
         return -ENETDOWN;
 
-	if (!*this_char)
-		return Status;
-
+	if (!*this_char) {
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
+		return -EINVAL;
+	}
 	if ((value = rtstrchr(this_char, '=')) != NULL)
 		*value++ = 0;
 
-	if (!value)
-		return Status;
-
+	else {
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
+		return -EINVAL;
+	}
 	// reject setting nothing besides ANY ssid(ssidLen=0)
 	if (!*value && (strcmp(this_char, "SSID") != 0))
-		return Status;
+		return -ENOSYS;
 
 	for (PRTMP_PRIVATE_SET_PROC = RTMP_PRIVATE_SUPPORT_PROC; PRTMP_PRIVATE_SET_PROC->name; PRTMP_PRIVATE_SET_PROC++)
 	{
@@ -1274,6 +1292,8 @@ rt_ioctl_setparam(struct net_device *dev
 		{
 			if(!PRTMP_PRIVATE_SET_PROC->set_proc(pAdapter, value))
 			{	//FALSE:Set private failed then return Invalid argument
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
 			}
 			break;	//Exit for loop.
@@ -1393,7 +1413,6 @@ INT RTMPSetInformation(
 	INT 								Status = NDIS_STATUS_SUCCESS;
 	ULONG								AntDiv;
 	BOOLEAN 							RadioState;
-    BOOLEAN							    StateMachineTouched = FALSE;
 
 #if WPA_SUPPLICANT_SUPPORT
     PNDIS_802_11_WEP			        pWepKey =NULL;
@@ -1406,8 +1425,11 @@ INT RTMPSetInformation(
 
 	switch(cmd & 0x7FFF) {
 		case RT_OID_802_11_COUNTRY_REGION:
-			if (wrq->u.data.length < sizeof(UCHAR))
+			if (wrq->u.data.length < sizeof(UCHAR)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else if (!(pAdapter->PortCfg.CountryRegion & 0x80) && !(pAdapter->PortCfg.CountryRegionForABand & 0x80))	// Only avaliable when EEPROM not programming
 			{
 				ULONG	Country;
@@ -1457,21 +1479,27 @@ INT RTMPSetInformation(
 			Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_BSSID_LIST_SCAN, TRUE, NULL, 0);
 			break;
 		case OID_802_11_SSID:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_SSID))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_SSID)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&Ssid, wrq->u.data.pointer, wrq->u.data.length);
 				pSsid = &Ssid;
 
-				if (pSsid->SsidLength > MAX_LEN_OF_SSID)
+				if (pSsid->SsidLength > MAX_LEN_OF_SSID) {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status = -EINVAL;
+				}
 				else
 				{
 					// reset SSID to null
 					if (pSsid->SsidLength == 0)
 					{
-						memcpy(pSsid->Ssid, "", 0);
+						Ssid.Ssid[0] = 0;
 					}
 
 					RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_SSID, TRUE, pSsid, sizeof(NDIS_802_11_SSID));
@@ -1480,8 +1508,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_BSSID:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_MAC_ADDRESS))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_MAC_ADDRESS)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&Bssid, wrq->u.data.pointer, wrq->u.data.length);
@@ -1492,8 +1523,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case RT_OID_802_11_RADIO:
-			if (wrq->u.data.length != sizeof(BOOLEAN))
+			if (wrq->u.data.length != sizeof(BOOLEAN)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&RadioState, wrq->u.data.pointer, wrq->u.data.length);
@@ -1510,8 +1544,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case RT_OID_802_11_PHY_MODE:
-			if (wrq->u.data.length != sizeof(RT_802_11_PHY_MODE))
+			if (wrq->u.data.length != sizeof(RT_802_11_PHY_MODE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&PhyMode, wrq->u.data.pointer, wrq->u.data.length);
@@ -1520,8 +1557,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case RT_OID_802_11_STA_CONFIG:
-			if (wrq->u.data.length != sizeof(RT_802_11_STA_CONFIG))
+			if (wrq->u.data.length != sizeof(RT_802_11_STA_CONFIG)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&StaConfig, wrq->u.data.pointer, wrq->u.data.length);
@@ -1536,8 +1576,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_DESIRED_RATES:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_RATES))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RATES)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&aryRates, wrq->u.data.pointer, wrq->u.data.length);
@@ -1553,8 +1596,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case RT_OID_802_11_PREAMBLE:
-			if (wrq->u.data.length != sizeof(RT_802_11_PREAMBLE))
+			if (wrq->u.data.length != sizeof(RT_802_11_PREAMBLE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&Preamble, wrq->u.data.pointer, wrq->u.data.length);
@@ -1564,6 +1610,8 @@ INT RTMPSetInformation(
 				}
 				else
 				{
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status = -EINVAL;
 					break;
 				}
@@ -1571,8 +1619,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_WEP_STATUS:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_WEP_STATUS))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_WEP_STATUS)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&WepStatus, wrq->u.data.pointer, wrq->u.data.length);
@@ -1592,6 +1643,8 @@ INT RTMPSetInformation(
 				}
 				else
 				{
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status	= -EINVAL;
 					break;
 				}
@@ -1599,13 +1652,18 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_AUTHENTICATION_MODE:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_AUTHENTICATION_MODE))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_AUTHENTICATION_MODE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&AuthMode, wrq->u.data.pointer, wrq->u.data.length);
 				if (AuthMode > Ndis802_11AuthModeMax)
 				{
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status	= -EINVAL;
 					break;
 				}
@@ -1623,8 +1681,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_INFRASTRUCTURE_MODE:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_INFRASTRUCTURE))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_INFRASTRUCTURE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&BssType, wrq->u.data.pointer, wrq->u.data.length);
@@ -1658,6 +1719,8 @@ INT RTMPSetInformation(
 				}
 				else
 				{
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status	= -EINVAL;
 					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (unknown)\n");
 				}
@@ -1668,6 +1731,8 @@ INT RTMPSetInformation(
 	    case OID_802_11_REMOVE_WEP:
             DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_WEP\n");
             if (wrq->u.data.length != sizeof(NDIS_802_11_KEY_INDEX)){
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 		        Status = -EINVAL;
             }
             else
@@ -1677,12 +1742,16 @@ INT RTMPSetInformation(
 		        if (KeyIdx & 0x80000000)
 		        {
 			        // Should never set default bit when remove key
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 			        Status = -EINVAL;
 		        }
 		        else
 		        {
 			        KeyIdx = KeyIdx & 0x0fffffff;
 			        if (KeyIdx >= 4){
+						DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+								__FUNCTION__);
 				        Status = -EINVAL;
 			        }
 			        else
@@ -1704,21 +1773,30 @@ INT RTMPSetInformation(
 			DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_RESET_COUNTERS (=%d)\n", pAdapter->Counters8023.GoodReceives);
 			break;
 		case OID_802_11_RTS_THRESHOLD:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_RTS_THRESHOLD))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RTS_THRESHOLD)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&RtsThresh, wrq->u.data.pointer, wrq->u.data.length);
-				if (RtsThresh > MAX_RTS_THRESHOLD)
+				if (RtsThresh > MAX_RTS_THRESHOLD) {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status	= -EINVAL;
+				}
 				else
 					pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
 			}
 			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_RTS_THRESHOLD (=%d)\n",RtsThresh);
 			break;
 		case OID_802_11_FRAGMENTATION_THRESHOLD:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_FRAGMENTATION_THRESHOLD))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_FRAGMENTATION_THRESHOLD)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&FragThresh, wrq->u.data.pointer, wrq->u.data.length);
@@ -1730,8 +1808,11 @@ INT RTMPSetInformation(
 						pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
 						pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
 					}
-					else
+					else {
+						DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+								__FUNCTION__);
 						Status	= -EINVAL;
+					}
 				}
 				else
 					pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
@@ -1739,8 +1820,11 @@ INT RTMPSetInformation(
 			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_FRAGMENTATION_THRESHOLD (=%d) \n",FragThresh);
 			break;
 		case OID_802_11_POWER_MODE:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_POWER_MODE))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_POWER_MODE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&PowerMode, wrq->u.data.pointer, wrq->u.data.length);
@@ -1777,27 +1861,39 @@ INT RTMPSetInformation(
 					pAdapter->PortCfg.WindowsBatteryPowerMode = PowerMode;
 					pAdapter->PortCfg.DefaultListenCount = 3;
 				}
-				else
+				else {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status = -EINVAL;
+				}
 			}
 			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_POWER_MODE (=%d)\n",PowerMode);
 			break;
 		case OID_802_11_TX_POWER_LEVEL:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_TX_POWER_LEVEL))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_TX_POWER_LEVEL)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&TxPowerLevel, wrq->u.data.pointer, wrq->u.data.length);
-				if (TxPowerLevel > MAX_TX_POWER_LEVEL)
+				if (TxPowerLevel > MAX_TX_POWER_LEVEL) {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status	= -EINVAL;
+				}
 				else
 					pAdapter->PortCfg.TxPower = (UCHAR)TxPowerLevel;
 			}
 			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_TX_POWER_LEVEL (=%d) \n",TxPowerLevel);
 			break;
 		case RT_OID_802_11_TX_POWER_LEVEL_1:
-			if (wrq->u.data.length	< sizeof(ULONG))
+			if (wrq->u.data.length	< sizeof(ULONG)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				ULONG	PowerTemp;
@@ -1815,8 +1911,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_PRIVACY_FILTER:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_PRIVACY_FILTER))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_PRIVACY_FILTER)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				NDIS_802_11_PRIVACY_FILTER	Filter;
@@ -1824,14 +1923,20 @@ INT RTMPSetInformation(
 				Status = copy_from_user(&Filter, wrq->u.data.pointer, wrq->u.data.length);
 				if ((Filter == Ndis802_11PrivFilterAcceptAll) || (Filter == Ndis802_11PrivFilter8021xWEP))
 					pAdapter->PortCfg.PrivacyFilter = Filter;
-				else
+				else {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
 					Status = -EINVAL;
+				}
 			}
 			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_PRIVACY_FILTER (=%d) \n",pAdapter->PortCfg.PrivacyFilter);
 			break;
 		case OID_802_11_NETWORK_TYPE_IN_USE:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_TYPE))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_TYPE)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&NetType, wrq->u.data.pointer, wrq->u.data.length);
@@ -1841,8 +1946,11 @@ INT RTMPSetInformation(
 			break;
 
 		case OID_802_11_RX_ANTENNA_SELECTED:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&AntDiv, wrq->u.data.pointer, wrq->u.data.length);
@@ -1850,8 +1958,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_TX_ANTENNA_SELECTED:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_ANTENNA)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status = -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&AntDiv, wrq->u.data.pointer, wrq->u.data.length);
@@ -1894,12 +2005,12 @@ INT RTMPSetInformation(
 					// Start STA supplicant state machine
 					pAdapter->PortCfg.WpaState = SS_START;
 
-					DBGPRINT(RT_DEBUG_TRACE,"PskKey =  Len = %d \n ",pKey->KeyLength);
+					DBGPRINT(RT_DEBUG_TRACE,"PskKey =  Len = %d \n",pKey->KeyLength);
 					for (i = 0; i < 32; i++)
 					{
 						DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pAdapter->PortCfg.PskKey.Key[i]);
 					}
-					DBGPRINT(RT_DEBUG_TRACE,"\n");
+					DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");
 					// Use RaConfig as PSK agent.
 					// Start STA supplicant state machine
 					pAdapter->PortCfg.WpaState = SS_START;
@@ -1986,8 +2097,11 @@ INT RTMPSetInformation(
 			break;
 #if WPA_SUPPLICANT_SUPPORT
 		case OID_802_11_SET_IEEE8021X:
-			if (wrq->u.data.length != sizeof(BOOLEAN))
+			if (wrq->u.data.length != sizeof(BOOLEAN)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
                 Status  = -EINVAL;
+			}
             else
             {
                 Status = copy_from_user(&IEEE8021xState, wrq->u.data.pointer, wrq->u.data.length);
@@ -2002,7 +2116,7 @@ INT RTMPSetInformation(
                      idx = pAdapter->PortCfg.DefaultKeyId;
                      //for (idx=0; idx < 4; idx++)
                      {
-                          DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic for static wep mode =>\n");
+                          DBGPRINT(RT_DEBUG_TRACE, "Set WEP key to Asic for static wep mode =>\n");
 
                           if(pAdapter->PortCfg.DesireSharedKey[idx].KeyLen != 0)
                           {
@@ -2021,8 +2135,11 @@ INT RTMPSetInformation(
 			}
 			break;
 		case OID_802_11_SET_IEEE8021X_REQUIRE_KEY:
-			if (wrq->u.data.length != sizeof(BOOLEAN))
+			if (wrq->u.data.length != sizeof(BOOLEAN)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				 Status  = -EINVAL;
+			}
             else
             {
                 Status = copy_from_user(&IEEE8021x_required_keys, wrq->u.data.pointer, wrq->u.data.length);
@@ -2119,8 +2236,11 @@ INT RTMPSetInformation(
 	        break;
 #endif
 		case OID_802_11_CONFIGURATION:
-			if (wrq->u.data.length != sizeof(NDIS_802_11_CONFIGURATION))
+			if (wrq->u.data.length != sizeof(NDIS_802_11_CONFIGURATION)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 				Status	= -EINVAL;
+			}
 			else
 			{
 				Status = copy_from_user(&Config, wrq->u.data.pointer, wrq->u.data.length);
@@ -2166,6 +2286,8 @@ INT RTMPSetInformation(
 		    {
 		        if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
 			    {
+					DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle\n",
+							__FUNCTION__);
 				    MlmeEnqueue(pAdapter,
 				                MLME_CNTL_STATE_MACHINE,
 				                RT_CMD_RESET_MLME,
@@ -2178,8 +2300,7 @@ INT RTMPSetInformation(
 						    OID_802_11_DISASSOCIATE,
 						    0,
 						    NULL);
-
-		        StateMachineTouched = TRUE;
+				RTUSBMlmeUp(pAdapter);
 		    }
 		    break;
 		case OID_802_11_PMKID:
@@ -2234,8 +2355,11 @@ INT RTMPSetInformation(
 		   }
 		   break;
 		case RT_OID_WPA_SUPPLICANT_SUPPORT:
-		    if (wrq->u.data.length != sizeof(BOOLEAN))
+		    if (wrq->u.data.length != sizeof(BOOLEAN)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 		        Status  = -EINVAL;
+			}
 		    else
 		    {
 		        Status = copy_from_user(&wpa_supplicant_enable, wrq->u.data.pointer, wrq->u.data.length);
@@ -2244,8 +2368,11 @@ INT RTMPSetInformation(
 		    }
 		    break;
 		case OID_802_11_RCV_BEACON:
-		    if (wrq->u.data.length != sizeof(BOOLEAN))
+		    if (wrq->u.data.length != sizeof(BOOLEAN)) {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
 		        Status  = -EINVAL;
+			}
 		    else
 		    {
 		        Status = copy_from_user(&start_send_beacon_up, wrq->u.data.pointer, wrq->u.data.length);
@@ -2741,7 +2868,7 @@ INT rt73_ioctl(
 		return -ENETDOWN;
 	}
 
-    	if (pAd->RTUSBCmdThr_pid < 0)
+   	if (pAd->RTUSBCmdThr_pid < 0)
 		return -ENETDOWN;
 
 	switch(cmd)
@@ -2758,6 +2885,7 @@ INT rt73_ioctl(
 			strcpy(wrq->u.name, "RT73 WLAN");
 			break;
 		case SIOCSIWESSID:	//Set ESSID
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWESSID\n");
 			erq = &wrq->u.essid;
 			memset(&Ssid, 0, sizeof(NDIS_802_11_SSID));
 			if (erq->flags)
@@ -2774,11 +2902,13 @@ INT rt73_ioctl(
 			else
 			{
 				Ssid.SsidLength = 0;  // ANY ssid
-				memcpy(pSsid->Ssid, "", 0);
+				Ssid.Ssid[0] = 0;
 			}
 			pSsid = &Ssid;
 			if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
 			{
+				DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle\n",
+						__FUNCTION__);
 				MlmeEnqueue(pAd,
 				            MLME_CNTL_STATE_MACHINE,
 				            RT_CMD_RESET_MLME,
@@ -2979,6 +3109,8 @@ INT rt73_ioctl(
 					sizeof(NDIS_802_11_MAC_ADDRESS));
 			if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
 			{
+				DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle\n",
+						__FUNCTION__);
 				MlmeEnqueue(pAd,
 				            MLME_CNTL_STATE_MACHINE,
 				            RT_CMD_RESET_MLME,
@@ -3076,7 +3208,7 @@ INT rt73_ioctl(
 			}
 			else
 			{
-				Status	= -EINVAL;
+				Status = -EINVAL;
 				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCSIWMODE (unknown)\n");
 			}
 			// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
@@ -3094,6 +3226,7 @@ INT rt73_ioctl(
 			Status = -EOPNOTSUPP;
 			break;
 		case RT_PRIV_IOCTL:
+		case RT_PRIV_IOCTL_WPA_SUPPLICANT:
 			subcmd = wrq->u.data.flags;
 			if( subcmd & OID_GET_SET_TOGGLE)
 				Status = RTMPSetInformation(pAd, rq, subcmd);
@@ -3101,51 +3234,79 @@ INT rt73_ioctl(
 				Status = RTMPQueryInformation(pAd, rq, subcmd);
 			break;
 		case SIOCGIWPRIV:
+			DBGPRINT(RT_DEBUG_TRACE, "IOCTL::SIOCGIWPRIV\n");
 			if (wrq->u.data.pointer) {
-				if ( access_ok(VERIFY_WRITE, wrq->u.data.pointer, sizeof(privtab)) != TRUE)
-					break;
-				wrq->u.data.length = sizeof(privtab) / sizeof(privtab[0]);
-				if (copy_to_user(wrq->u.data.pointer, privtab, sizeof(privtab)))
-					Status = -EFAULT;
+				if (access_ok(VERIFY_WRITE,
+							wrq->u.data.pointer, sizeof(privtab))) {
+					wrq->u.data.length = sizeof(privtab) / sizeof(privtab[0]);
+					if (copy_to_user(wrq->u.data.pointer,
+								privtab, sizeof(privtab)) == 0) {
+						break;
+					}
+				}
+				Status = -EFAULT;
+			}
+			else {
+				DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+						__FUNCTION__);
+				Status = -EINVAL;
 			}
 			break;
 		case RTPRIV_IOCTL_SET:
 			{
-				CHAR *this_char;
+				CHAR *this_char = NULL;
 				CHAR *value;
+				struct rt_priv_support *PRTMP_PRIVATE_SET_PROC;
 
-				if( access_ok(VERIFY_READ, wrq->u.data.pointer, wrq->u.data.length)!=TRUE )
-					break;
+				do {
+				DBGPRINT(RT_DEBUG_TRACE, "IOCTL::RTPRIV_IOCTL_SET\n");
 
-				this_char = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
+				if(access_ok(VERIFY_READ,
+							wrq->u.data.pointer, wrq->u.data.length)!=TRUE )
+				{
+					Status = -EFAULT;
+					break;
+				}
+				this_char = kmalloc(wrq->u.data.length + 1, MEM_ALLOC_FLAG);
 				if(this_char == NULL)
 				{
 					Status = -ENOMEM;
 					break;
 				}
-
-				Status = copy_from_user(this_char, wrq->u.data.pointer, wrq->u.data.length);
-
-				if (!*this_char)
+				Status = copy_from_user(this_char,
+						wrq->u.data.pointer, wrq->u.data.length);
+				if (Status)
+				{
+					Status = -EFAULT;
 					break;
+				}
+				this_char[wrq->u.data.length] = 0;
 
 				if ((value = rtstrchr(this_char, '=')) != NULL)
 					*value++ = 0;
-
-				if (!value)
+				else {
+					DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n",
+							__FUNCTION__);
+					Status = -EINVAL;
 					break;
-
+				}
 				// reject setting nothing besides ANY ssid(ssidLen=0)
 				if (!*value && (strcmp(this_char, "SSID") != 0))
+				{
+					Status = -ENOSYS;
 					break;
-
-				for (PRTMP_PRIVATE_SET_PROC = RTMP_PRIVATE_SUPPORT_PROC; PRTMP_PRIVATE_SET_PROC->name; PRTMP_PRIVATE_SET_PROC++)
+				}
+				for (PRTMP_PRIVATE_SET_PROC = RTMP_PRIVATE_SUPPORT_PROC;
+					PRTMP_PRIVATE_SET_PROC->name; PRTMP_PRIVATE_SET_PROC++)
 				{
 					if (!strcmp(this_char, PRTMP_PRIVATE_SET_PROC->name))
 					{
 						if(!PRTMP_PRIVATE_SET_PROC->set_proc(pAd, value))
-						{	//FALSE:Set private failed then return Invalid argument
+						{	//FALSE:Set private failed return Invalid argument
 							Status = -EINVAL;
+							DBGPRINT(RT_DEBUG_ERROR,
+									"IOCTL::(iwpriv) %s failed]\n",
+									PRTMP_PRIVATE_SET_PROC->name);
 						}
 						break;	//Exit for loop.
 					}
@@ -3154,9 +3315,12 @@ INT rt73_ioctl(
 				if(PRTMP_PRIVATE_SET_PROC->name == NULL)
 				{  //Not found argument
 					Status = -EINVAL;
-					DBGPRINT(RT_DEBUG_TRACE, "IOCTL::(iwpriv) Command not Support [%s=%s]\n", this_char, value);
+					DBGPRINT(RT_DEBUG_ERROR,
+							"IOCTL::(iwpriv) Command not Support [%s=%s]\n",
+							this_char, value);
 					break;
 				}
+				} while (0);
 				if(this_char != NULL){
 					kfree(this_char);
 				}
@@ -3392,27 +3556,31 @@ NDIS_STATUS	RTMPWPAAddKeyProc(
 	DBGPRINT(RT_DEBUG_TRACE, "pAd->SharedKey[%d].CipherAlg = %d\n", KeyIdx, pAd->SharedKey[KeyIdx].CipherAlg);
 
 #if 0
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "%s Key #%d", CipherName[pAd->SharedKey[KeyIdx].CipherAlg],KeyIdx);
+	DBGPRINT(RT_DEBUG_TRACE, "%s Key #%d", CipherName[pAd->SharedKey[KeyIdx].CipherAlg],KeyIdx);
 	for (i = 0; i < 16; i++)
 	{
 		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].Key[i]);
 	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 Rx MIC Key = ");
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	DBGPRINT(RT_DEBUG_TRACE, "        Rx MIC Key = ");
 	for (i = 0; i < 8; i++)
 	{
 		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].RxMic[i]);
 	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 Tx MIC Key = ");
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	DBGPRINT(RT_DEBUG_TRACE, "        Tx MIC Key = ");
 	for (i = 0; i < 8; i++)
 	{
 		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].TxMic[i]);
 	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 RxTSC = ");
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+	DBGPRINT(RT_DEBUG_TRACE, "        RxTSC = ");
 	for (i = 0; i < 6; i++)
 	{
 		DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x:", pAd->SharedKey[KeyIdx].RxTsc[i]);
 	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n	 BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
+	DBGPRINT(RT_DEBUG_TRACE, "    ");
+	DBGPRINT(RT_DEBUG_TRACE, "BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
 		pKey->BSSID[0],pKey->BSSID[1],pKey->BSSID[2],pKey->BSSID[3],pKey->BSSID[4],pKey->BSSID[5]);
 #endif
 	AsicAddSharedKeyEntry(pAd,
@@ -3969,7 +4137,7 @@ INT Set_SSID_Proc(
 		else
 		{
 			Ssid.SsidLength = 0; //ANY ssid
-            memcpy(Ssid.Ssid, "", 0);
+			Ssid.Ssid[0] = 0;
 
 			// reset to infra/open/none as the user sets ANY ssid
             // $ iwpriv [interface] set SSID=""
@@ -3982,6 +4150,8 @@ INT Set_SSID_Proc(
 
 		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
 		{
+			DBGPRINT(RT_DEBUG_INFO,"- %s:: CNTL SM not idle\n",
+					__FUNCTION__);
 			MlmeEnqueue(pAdapter,
                         MLME_CNTL_STATE_MACHINE,
                         RT_CMD_RESET_MLME,
@@ -4938,25 +5108,27 @@ INT Set_WPAPSK_Proc(
 	IN	PRTMP_ADAPTER	pAdapter,
 	IN	PUCHAR			arg)
 {
-	UCHAR					keyMaterial[40];
-	INT 					Status;
+	int					KeyLen = strnlen(arg, 64);
+	UCHAR				keyMaterial[40];
+	INT 				Status;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> Set_WPAPSK_Proc: key len=%d\n", KeyLen);
 
 	if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&\
 		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&\
-		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) )
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) ) {
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: invalid auth\n", __FUNCTION__);
 		return TRUE;	// do nothing
+	}
 
-	DBGPRINT(RT_DEBUG_TRACE, "Set_WPAPSK_Proc::(WPAPSK=%s)\n", arg);
-
-	memset(keyMaterial, 0, 40);
-
-	if ((strlen(arg) < 8) || (strlen(arg) > 64))
+	if (KeyLen < 8 || arg[KeyLen])
 	{
-		DBGPRINT(RT_DEBUG_TRACE, "Set failed!!(WPAPSK=%s), WPAPSK key-string required 8 ~ 64 characters \n", arg);
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: invalid key length\n", __FUNCTION__);
 		return FALSE;
 	}
+	memset(keyMaterial, 0, sizeof(keyMaterial));
 
-	if (strlen(arg) == 64)
+	if (KeyLen == 64)
 	{
 		AtoH(arg, keyMaterial, 32);
 		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
@@ -4974,10 +5146,10 @@ INT Set_WPAPSK_Proc(
 	{
 		//RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, sizeof(Key));
 		Status = RTMPWPANoneAddKeyProc(pAdapter, &keyMaterial[0]);
-
-		if (Status != NDIS_STATUS_SUCCESS)
+		if (Status != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE, "<-- %s: add key failed\n", __FUNCTION__);
 			return FALSE;
-
+		}
 		pAdapter->PortCfg.WpaState = SS_NOTUSE;
 	}
 	else	// Use RaConfig as PSK agent.
@@ -4986,6 +5158,7 @@ INT Set_WPAPSK_Proc(
 		pAdapter->PortCfg.WpaState = SS_START;
 	}
 
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: OK\n", __FUNCTION__);
 	return TRUE;
 }
 
@@ -5217,13 +5390,13 @@ VOID RTMPIoctlBBP(
 					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
 				}
 				else
-				{//Invalid parametes, so default printk all bbp
+				{//Invalid parametes, so default KPRINT all bbp
 					bIsPrintAllBBP = TRUE;
 					goto next;
 				}
 			}
 			else
-			{ //Invalid parametes, so default printk all bbp
+			{ //Invalid parametes, so default KPRINT all bbp
 				bIsPrintAllBBP = TRUE;
 				goto next;
 			}
@@ -5243,13 +5416,13 @@ VOID RTMPIoctlBBP(
 					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
 				}
 				else
-				{//Invalid parametes, so default printk all bbp
+				{//Invalid parametes, so default KPRINT all bbp
 					bIsPrintAllBBP = TRUE;
 					goto next;
 				}
 			}
 			else
-			{ //Invalid parametes, so default printk all bbp
+			{ //Invalid parametes, so default KPRINT all bbp
 				bIsPrintAllBBP = TRUE;
 				goto next;
 			}
@@ -5371,7 +5544,7 @@ VOID RTMPIoctlMAC(
 					DBGPRINT(RT_DEBUG_INFO, "msg=%s\n", msg);
 				}
 				else
-				{//Invalid parametes, so default printk all bbp
+				{//Invalid parametes, so default KPRINT all bbp
 					goto next;
 				}
 			}
@@ -5658,7 +5831,7 @@ VOID RTMPMakeRSNIE(
 		// Modify AKM
 		pAdapter->PortCfg.RSN_IE[19] = ((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
 
-		DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA2PSK GroupC=%d, PairC=%d\n",pAdapter->PortCfg.GroupCipher ,
+		DBGPRINT(RT_DEBUG_TRACE,"WPA2PSK GroupC=%d, PairC=%d\n",pAdapter->PortCfg.GroupCipher ,
 			pAdapter->PortCfg.PairCipher);
 
 		pAdapter->PortCfg.RSN_IELen = CipherWpa2TemplateLen;
@@ -5673,7 +5846,7 @@ VOID RTMPMakeRSNIE(
 		// Modify AKM
 		pAdapter->PortCfg.RSN_IE[23] = ((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
 
-		DBGPRINT_RAW(RT_DEBUG_TRACE,"WPAPSK GroupC = %d, PairC=%d ,  \n ",pAdapter->PortCfg.GroupCipher ,
+		DBGPRINT(RT_DEBUG_TRACE,"WPAPSK GroupC = %d, PairC=%d ,  \n",pAdapter->PortCfg.GroupCipher ,
 			pAdapter->PortCfg.PairCipher);
 
 		pAdapter->PortCfg.RSN_IELen = CipherWpaPskTkipLen;
@@ -5701,7 +5874,7 @@ NDIS_STATUS RTMPWPANoneAddKeyProc(
 	pKey = kmalloc(BufLen, MEM_ALLOC_FLAG);
 	if (pKey == NULL)
 	{
-		DBGPRINT(RT_DEBUG_TRACE, "RTMPWPANoneAddKeyProc() allocate memory failed \n");
+		DBGPRINT(RT_DEBUG_ERROR, "RTMPWPANoneAddKeyProc() allocate memory failed \n");
 		Status = NDIS_STATUS_FAILURE;
 		return	Status;
 	}
@@ -5730,6 +5903,7 @@ INT RTMPIoctlAdhocOfdm(
 
 	if (wrq->u.data.length != 1)
 	{
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		Status = -EINVAL;
 		return (Status);
 
@@ -5746,6 +5920,7 @@ INT RTMPIoctlAdhocOfdm(
 			pAdapter->PortCfg.AdhocMode = 2;
 		else
 		{
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 			Status = -EINVAL;
 			return (Status);
 		}
@@ -5766,6 +5941,7 @@ INT RTMPIoctlSetAuth(
 
 	if (wrq->u.data.length != 1)
 	{
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		Status = -EINVAL;
 		return (Status);
 
@@ -5786,6 +5962,7 @@ INT RTMPIoctlSetAuth(
 			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
 		else
 		{
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 			Status = -EINVAL;
 			return (Status);
 		}
@@ -5807,6 +5984,7 @@ INT RTMPIoctlSetEncryp(
 
 	if (wrq->u.data.length != 1)
 	{
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		Status = -EINVAL;
 		return (Status);
 	}
@@ -5843,6 +6021,7 @@ INT RTMPIoctlSetEncryp(
 		}
 		else
 		{
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 			Status = -EINVAL;
 			return (Status);
 		}
@@ -5865,22 +6044,32 @@ INT RTMPIoctlSetWpapsk(
 	UCHAR			keyMaterial[40];
 	INT 			Status = 0;
 
-	if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&\
-		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&\
-		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) )
-		return TRUE;	// do nothing
-
-	Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
-
-	memset(keyMaterial, 0, 40);
-
+	DBGPRINT(RT_DEBUG_TRACE, "--> %s: key len=%d\n",
+			__FUNCTION__, wrq->u.data.length);
+	if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&
+		(pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone) ) {
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: invalid auth\n", __FUNCTION__);
+		return 0;	// do nothing
+	}
 	if ((wrq->u.data.length < 8) || (wrq->u.data.length > 64))
 	{
-		DBGPRINT(RT_DEBUG_TRACE, "Set failed!!(WPAPSK=%s), WPAPSK key-string required 8 ~ 64 characters \n", arg);
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: invalid key len(%d)\n",
+				__FUNCTION__, wrq->u.data.length);
 		Status = -EINVAL;
 		return (Status);
 	}
-	else if (wrq->u.data.length == 64)
+	Status = copy_from_user(arg, wrq->u.data.pointer, wrq->u.data.length);
+	if (Status) {
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: key copy failed (len=%d)\n",
+				__FUNCTION__, wrq->u.data.length);
+		Status = -EFAULT;
+		return (Status);
+	}
+	arg[wrq->u.data.length] = 0;
+	memset(keyMaterial, 0, 40);
+
+	if (wrq->u.data.length == 64)
 	{
 		AtoH(arg, keyMaterial, 32);
 		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
@@ -5893,15 +6082,16 @@ INT RTMPIoctlSetWpapsk(
 
 	RTMPMakeRSNIE(pAdapter, pAdapter->PortCfg.GroupCipher);
 
-	if(pAdapter->PortCfg.BssType == BSS_ADHOC &&\
+	if(pAdapter->PortCfg.BssType == BSS_ADHOC &&
 	   pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
 	{
 		//RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, sizeof(Key));
 		Status = RTMPWPANoneAddKeyProc(pAdapter, &keyMaterial[0]);
 
-		if (Status != NDIS_STATUS_SUCCESS)
+		if (Status != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE, "<-- %s: add key failed\n", __FUNCTION__);
 			return -ENOMEM;
-
+		}
 		pAdapter->PortCfg.WpaState = SS_NOTUSE;
 	}
 	else	 // Use RaConfig as PSK agent.
@@ -5910,7 +6100,7 @@ INT RTMPIoctlSetWpapsk(
 		pAdapter->PortCfg.WpaState = SS_START;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, "RTMPIoctlSetWpapsk::(WPAPSK=%s)\n", arg);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: (WPAPSK=%s)\n", __FUNCTION__, arg);
 
 	return (Status);
 }
@@ -5924,6 +6114,7 @@ INT RTMPIoctlSetPsm(
 
 	if (wrq->u.data.length != 1)
 	{
+		DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 		Status = -EINVAL;
 		return (Status);
 	}
@@ -5966,6 +6157,7 @@ INT RTMPIoctlSetPsm(
 		}
 		else
 		{
+			DBGPRINT(RT_DEBUG_ERROR,"- %s: Invalid argument\n", __FUNCTION__);
 			Status = -EINVAL;
 			return (Status);
 		}
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_init.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_init.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_init.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_init.c	2008-05-09 10:23:01.000000000 +0200
@@ -37,7 +37,7 @@
 
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#define RT_USB_ALLOC_URB(iso)	usb_alloc_urb(iso, GFP_ATOMIC);
+#define RT_USB_ALLOC_URB(iso)	usb_alloc_urb(iso, GFP_KERNEL);
 #else
 #define RT_USB_ALLOC_URB(iso)	usb_alloc_urb(iso);
 #endif
@@ -155,30 +155,68 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 };
 #define	NUM_MAC_REG_PARMS	(sizeof(MACRegTable) / sizeof(RTMP_REG_PAIR))
 
-VOID CreateThreads( struct net_device *net_dev )
+VOID CreateThreads(PRTMP_ADAPTER pAd)
 {
-	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) net_dev->priv;
-
 	// Creat MLME Thread
-	pAd->MLMEThr_pid= -1;
-
 	pAd->MLMEThr_pid = kernel_thread(MlmeThread, pAd, CLONE_VM);
 	if (pAd->MLMEThr_pid < 0) {
-		printk (KERN_WARNING "%s: unable to start mlme thread\n",pAd->net_dev->name);
+		DBGPRINT(RT_DEBUG_ERROR, "%s: unable to start mlme thread for %s\n",
+				__FUNCTION__, pAd->net_dev->name);
+		KPRINT(KERN_WARNING, "%s: unable to start mlme thread\n",
+				pAd->net_dev->name);
 	}
 
 	// Creat Command Thread
-	pAd->RTUSBCmdThr_pid= -1;
-
 	pAd->RTUSBCmdThr_pid = kernel_thread(RTUSBCmdThread, pAd, CLONE_VM);
 	if (pAd->RTUSBCmdThr_pid < 0) {
-		printk (KERN_WARNING "%s: unable to start RTUSBCmd thread\n",pAd->net_dev->name);
+		DBGPRINT(RT_DEBUG_ERROR, "%s: unable to start Cmd thread for %s\n",
+				__FUNCTION__, pAd->net_dev->name);
+		KPRINT(KERN_WARNING, "%s: unable to start Cmd thread\n",
+				pAd->net_dev->name);
 	}
+	DBGPRINT(RT_DEBUG_INFO, "-  (%s) Mlme pid=%d, Cmd pid=%d\n",
+			__FUNCTION__, pAd->MLMEThr_pid, pAd->RTUSBCmdThr_pid);
+}
 
-	/* Wait for the thread to start */
-	wait_for_completion(&(pAd->notify));
+void KillThreads(PRTMP_ADAPTER pAd)
+{
+	int             ret;
 
-}
+	if (pAd->MLMEThr_pid > 0)
+	{
+		ret = kill_proc (pAd->MLMEThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "%s(%s): unable to signal mlme thread"
+					" (pid=%d, err=%d)\n",
+					__FUNCTION__, pAd->net_dev->name, pAd->MLMEThr_pid, ret);
+			KPRINT(KERN_ERR, "(%s) unable to signal mlme thread"
+					" (pid=%d, err=%d)\n",
+					pAd->net_dev->name, pAd->MLMEThr_pid, ret);
+			//return ret;		Fix process killing
+		}
+		else wait_for_completion (&pAd->mlmenotify);
+	}
+	if (pAd->RTUSBCmdThr_pid> 0)
+	{
+		ret = kill_proc (pAd->RTUSBCmdThr_pid, SIGTERM, 1);
+		if (ret)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "%s(%s): unable to signal cmd thread"
+					" (pid=%d, err=%d)\n",
+					__FUNCTION__, pAd->net_dev->name, pAd->MLMEThr_pid, ret);
+			KPRINT(KERN_ERR, "(%s) unable to signal cmd thread"
+					" (pid=%d, err=%d)\n",
+					pAd->net_dev->name, pAd->RTUSBCmdThr_pid, ret);
+			//return ret;		Fix process killing
+		}
+		else wait_for_completion (&pAd->cmdnotify);
+	}
+	// reset mlme & command thread
+    pAd->MLMEThr_pid = -1;
+	pAd->RTUSBCmdThr_pid = -1;
+
+} /* End KillThreads () */
 
 NDIS_STATUS NICInitTransmit(
 	IN	PRTMP_ADAPTER	 pAd )
@@ -205,7 +243,6 @@ NDIS_STATUS NICInitTransmit(
 
 	pAd->PrivateInfo.TxRingFullCnt = 0;
 
-	pAd->NextRxBulkInIndex	   = 0;	// Rx Bulk pointer
 	pAd->NextMLMEIndex		   = 0;
 	pAd->PushMgmtIndex		   = 0;
 	pAd->PopMgmtIndex		   = 0;
@@ -496,7 +533,8 @@ NDIS_STATUS NICInitRecv(
 
 
 	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitRecv\n");
-	pAd->NextRxBulkInIndex = 0;
+	pAd->NextRxBulkInIndex = 0;	// Rx Bulk pointer
+	pAd->CurRxBulkInIndex = 0;
 	atomic_set( &pAd->PendingRx, 0);
 	for (i = 0; i < RX_RING_SIZE; i++)
 	{
@@ -521,10 +559,12 @@ NDIS_STATUS NICInitRecv(
 
 		pRxContext->pAd	= pAd;
 		pRxContext->InUse = FALSE;
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
 		pRxContext->IRPPending	= FALSE;
 	}
+	if (Status) ReleaseAdapter(pAd, TRUE, FALSE);
 
-	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitRecv\n");
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitRecv status=%d\n", Status);
 	return Status;
 }
 
@@ -534,9 +574,7 @@ NDIS_STATUS NICInitRecv(
 //		ReleaseAdapter
 //
 //	DESCRIPTION
-//		Calls USB_InterfaceStop and frees memory allocated for the URBs
-//		calls NdisMDeregisterDevice and frees the memory
-//		allocated in VNetInitialize for the Adapter Object
+//		Frees memory allocated for URBs and transfer buffers.
 //
 //	INPUT
 //		Adapter 	Pointer to RTMP_ADAPTER structure
@@ -698,18 +736,15 @@ VOID ReleaseAdapter(
 		Adapter		Pointer to our adapter
 
 	Return Value:
-		NDIS_STATUS_SUCCESS
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_RESOURCES
+		None.
 
 	Note:
 
 	========================================================================
 */
-NDIS_STATUS	RTMPInitAdapterBlock(
+void RTMPInitAdapterBlock(
 	IN	PRTMP_ADAPTER	pAd)
 {
-	NDIS_STATUS		Status=NDIS_STATUS_SUCCESS;
 	UINT			i;
 	PCmdQElmt		cmdqelmt;
 
@@ -756,17 +791,18 @@ NDIS_STATUS	RTMPInitAdapterBlock(
 		}
 		RTUSBInitializeCmdQ(&pAd->CmdQ);
 
-		init_MUTEX(&(pAd->usbdev_semaphore));
-		init_MUTEX(&(pAd->mlme_semaphore));
-		down(&pAd->mlme_semaphore);
-		init_MUTEX(&(pAd->RTUSBCmd_semaphore));
-		down(&pAd->RTUSBCmd_semaphore);
+		pAd->MLMEThr_pid= -1;
+		pAd->RTUSBCmdThr_pid= -1;
+
+		init_MUTEX_LOCKED(&(pAd->usbdev_semaphore));
+		init_MUTEX_LOCKED(&(pAd->mlme_semaphore));
+		init_MUTEX_LOCKED(&(pAd->RTUSBCmd_semaphore));
 
-		init_completion (&pAd->notify); 	// event initially non-signalled
+		init_completion (&pAd->mlmenotify);	// event initially non-signalled
+		init_completion (&pAd->cmdnotify); 	// event initially non-signalled
 
 		////////////////////////
 		// Spinlock
-		NdisAllocateSpinLock(&pAd->MLMEQLock);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[0]);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[1]);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[2]);
@@ -780,59 +816,69 @@ NDIS_STATUS	RTMPInitAdapterBlock(
 		NdisAllocateSpinLock(&pAd->DeQueueLock[1]);
 		NdisAllocateSpinLock(&pAd->DeQueueLock[2]);
 		NdisAllocateSpinLock(&pAd->DeQueueLock[3]);
-		NdisAllocateSpinLock(&pAd->DataQLock[0]);
-		NdisAllocateSpinLock(&pAd->DataQLock[1]);
-		NdisAllocateSpinLock(&pAd->DataQLock[2]);
-		NdisAllocateSpinLock(&pAd->DataQLock[3]);
 
 		NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock);
+		NdisAllocateSpinLock(&pAd->MLMEQLock);
 
 	}	while (FALSE);
 
 	DBGPRINT(RT_DEBUG_TRACE, "<-- RTMPInitAdapterBlock\n");
-
-	return Status;
 }
 
 NDIS_STATUS	RTUSBWriteHWMACAddress(
 	IN	PRTMP_ADAPTER		pAd)
 {
-	MAC_CSR2_STRUC		StaMacReg0;
-	MAC_CSR3_STRUC		StaMacReg1;
+	MAC_CSR2_STRUC		*StaMacReg0 = kzalloc(sizeof(MAC_CSR2_STRUC), GFP_KERNEL);
+	MAC_CSR3_STRUC		*StaMacReg1 = kzalloc(sizeof(MAC_CSR3_STRUC), GFP_KERNEL);
 	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
 	PUCHAR			curMAC;
 	int			t;
 
+	if (!StaMacReg0 || !StaMacReg1) {
+		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
+    return -ENOMEM;
+  }
 	if (pAd->bLocalAdminMAC != TRUE)
 	{
 		if (!memcmp(pAd->net_dev->dev_addr, "\x00\x00\x00\x00\x00\x00", 6)) {
-			printk(KERN_INFO "***rt73***: Interface goes up for the first time, activating permanent MAC\n");
+			KPRINT(KERN_INFO, "using permanent MAC addr\n");
+			DBGPRINT(RT_DEBUG_INFO, "-   using permanent MAC addr\n");
 			curMAC = pAd->PermanentAddress;
+			// Also meets 2.6.24 pre-up requirements - bb
+			memcpy(pAd->net_dev->dev_addr, curMAC, pAd->net_dev->addr_len);
 		} else {
-			printk(KERN_INFO "***rt73***: net_device supplies MAC, activating this one\n");
+			KPRINT(KERN_INFO, "using net dev supplied MAC addr\n");
+			DBGPRINT(RT_DEBUG_INFO, "-   using net dev supplied MAC addr\n");
 			curMAC = pAd->net_dev->dev_addr;
 		}
 
-		printk(KERN_INFO "***rt73***: Active MAC is: %02x:%02x:%02x:%02x:%02x:%02x.\n", curMAC[0], curMAC[1], curMAC[2], curMAC[3], curMAC[4], curMAC[5]);
+		KPRINT(KERN_INFO, "Active MAC addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			curMAC[0], curMAC[1], curMAC[2], curMAC[3], curMAC[4], curMAC[5]);
 		for (t=0; t<6; t++) pAd->CurrentAddress[t] = curMAC[t];
 	}
 
 	// Write New MAC address to MAC_CSR2 & MAC_CSR3 & let ASIC know our new MAC
-	StaMacReg0.field.Byte0 = pAd->CurrentAddress[0];
-	StaMacReg0.field.Byte1 = pAd->CurrentAddress[1];
-	StaMacReg0.field.Byte2 = pAd->CurrentAddress[2];
-	StaMacReg0.field.Byte3 = pAd->CurrentAddress[3];
-	StaMacReg1.field.Byte4 = pAd->CurrentAddress[4];
-	StaMacReg1.field.Byte5 = pAd->CurrentAddress[5];
-	StaMacReg1.field.U2MeMask = 0xff;
-
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
-			pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]);
+	StaMacReg0->field.Byte0 = pAd->CurrentAddress[0];
+	StaMacReg0->field.Byte1 = pAd->CurrentAddress[1];
+	StaMacReg0->field.Byte2 = pAd->CurrentAddress[2];
+	StaMacReg0->field.Byte3 = pAd->CurrentAddress[3];
+	StaMacReg1->field.Byte4 = pAd->CurrentAddress[4];
+	StaMacReg1->field.Byte5 = pAd->CurrentAddress[5];
+	StaMacReg1->field.U2MeMask = 0xff;
+
+	KPRINT(KERN_INFO, "Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
+		pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]);
+	DBGPRINT(RT_DEBUG_INFO, "- %s: Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		__FUNCTION__,
+		pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
+		pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]);
 
-	RTUSBWriteMACRegister(pAd, MAC_CSR2, StaMacReg0.word);
-	RTUSBWriteMACRegister(pAd, MAC_CSR3, StaMacReg1.word);
+	RTUSBWriteMACRegister(pAd, MAC_CSR2, StaMacReg0->word);
+	RTUSBWriteMACRegister(pAd, MAC_CSR3, StaMacReg1->word);
 
+	kfree(StaMacReg0);
+	kfree(StaMacReg1);
 	return Status;
 }
 
@@ -855,7 +901,7 @@ NDIS_STATUS	RTUSBWriteHWMACAddress(
 VOID NICReadEEPROMParameters(
 	IN	PRTMP_ADAPTER	pAd)
 {
-	USHORT  i, value2;
+	USHORT					i, value2;
 	USHORT  *value = kzalloc(sizeof(USHORT), GFP_KERNEL);
 	EEPROM_ANTENNA_STRUC	Antenna;
 	EEPROM_VERSION_STRUC  *Version = kzalloc(sizeof(EEPROM_VERSION_STRUC), GFP_KERNEL);
@@ -869,10 +915,12 @@ VOID NICReadEEPROMParameters(
 		return;
 	}
 	//Read MAC address.
-	RTUSBReadEEPROM(pAd, EEPROM_MAC_ADDRESS_BASE_OFFSET, pAd->PermanentAddress, MAC_ADDR_LEN);
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			pAd->PermanentAddress[0], pAd->PermanentAddress[1], pAd->PermanentAddress[2],
-			pAd->PermanentAddress[3], pAd->PermanentAddress[4], pAd->PermanentAddress[5]);
+	RTUSBReadEEPROM(pAd, EEPROM_MAC_ADDRESS_BASE_OFFSET,
+					pAd->PermanentAddress, MAC_ADDR_LEN);
+	DBGPRINT(RT_DEBUG_INFO, "- Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+			pAd->PermanentAddress[0], pAd->PermanentAddress[1],
+			pAd->PermanentAddress[2], pAd->PermanentAddress[3],
+			pAd->PermanentAddress[4], pAd->PermanentAddress[5]);
 
 	// Init the channel number for TX channel power
 	// 0. 11b/g
@@ -897,6 +945,7 @@ VOID NICReadEEPROMParameters(
 	RTUSBReadEEPROM(pAd, EEPROM_VERSION_OFFSET, (PUCHAR)&Version->word, 2);
 	pAd->EepromVersion = Version->field.Version + Version->field.FaeReleaseNumber * 256;
 	DBGPRINT(RT_DEBUG_TRACE, "E2PROM: Version = %d, FAE release #%d\n", Version->field.Version, Version->field.FaeReleaseNumber);
+
 	// Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd
 	RTUSBReadEEPROM(pAd, EEPROM_BBP_BASE_OFFSET, (PUCHAR)(pAd->EEPROMDefaultValue), 2 * NUM_EEPROM_BBP_PARMS);
 
@@ -948,7 +997,7 @@ VOID NICReadEEPROMParameters(
 		else
 			pAd->TxPower[i].Power = ChannelTxPower[i];
 
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[i].Channel, pAd->TxPower[i].Power);
+		DBGPRINT(RT_DEBUG_INFO, "Tx power for channel %d : 0x%02x\n", pAd->TxPower[i].Channel, (UCHAR)(pAd->TxPower[i].Power));
 	}
 
 	// 1. UNI 36 - 64, HipperLAN 2 100 - 140, UNI 140 - 165
@@ -960,7 +1009,7 @@ VOID NICReadEEPROMParameters(
 			pAd->TxPower[i + 14].Power = 24;
 		else
 			pAd->TxPower[i + 14].Power = ChannelTxPower[i];
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[i + 14].Channel, pAd->TxPower[i + 14].Power);
+		DBGPRINT(RT_DEBUG_INFO, "Tx power for channel %d : 0x%02x\n", pAd->TxPower[i + 14].Channel, (UCHAR)(pAd->TxPower[i + 14].Power));
 	}
 
 	//
@@ -978,7 +1027,7 @@ VOID NICReadEEPROMParameters(
 		else
 			pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power = ChannelTxPower[i + 1];
 
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Channel, pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power);
+		DBGPRINT(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Channel, pAd->TxPower[J52_CHANNEL_START_OFFSET + i].Power);
 	}
 
 	// Read TSSI reference and TSSI boundary for temperature compensation.
@@ -1036,8 +1085,8 @@ VOID NICReadEEPROMParameters(
 			pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2], pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
 			pAd->TxAgcStepA, pAd->bAutoTxAgcA);
 	}
-
 	pAd->BbpRssiToDbmDelta = 0x79;
+
 	RTUSBReadEEPROM(pAd, EEPROM_FREQ_OFFSET, (PUCHAR)value, 2);
 	if ((*value & 0xFF00) == 0xFF00)
 	{
@@ -1045,7 +1094,7 @@ VOID NICReadEEPROMParameters(
 	}
 	else
 	{
-		pAd->RFProgSeq = (*value & 0x0300) >> 8;  // bit 8,9
+		pAd->RFProgSeq = (*value & 0x0300) >> 8;	// bit 8,9
 	}
 
 	*value &= 0x00FF;
@@ -1058,7 +1107,7 @@ VOID NICReadEEPROMParameters(
 	//CountryRegion byte offset = 0x25
 	*value = pAd->EEPROMDefaultValue[2] >> 8;
 	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;
-    if ((*value <= REGION_MAXIMUM_BG_BAND) && (value2 <= REGION_MAXIMUM_A_BAND))
+	if ((*value <= REGION_MAXIMUM_BG_BAND) && (value2 <= REGION_MAXIMUM_A_BAND))
 	{
 		pAd->PortCfg.CountryRegion = ((UCHAR) *value) | 0x80;
 		pAd->PortCfg.CountryRegionForABand = ((UCHAR) value2) | 0x80;
@@ -1071,6 +1120,7 @@ VOID NICReadEEPROMParameters(
 	RTUSBReadEEPROM(pAd, EEPROM_RSSI_BG_OFFSET, (PUCHAR)value, 2);
 	pAd->BGRssiOffset1 = *value & 0x00ff;
 	pAd->BGRssiOffset2 = (*value >> 8);
+
 	// Validate 11b/g RSSI_1 offset.
 	if ((pAd->BGRssiOffset1 < -10) || (pAd->BGRssiOffset1 > 10))
 		pAd->BGRssiOffset1 = 0;
@@ -1110,7 +1160,6 @@ VOID NICReadEEPROMParameters(
 		LedSetting->field.PolarityGPIO_4 = 0; // Active High.
 		LedSetting->field.LedMode = LED_MODE_DEFAULT;
 	}
-	pAd->LedCntl.word = 0;
 	pAd->LedCntl.field.LedMode = LedSetting->field.LedMode;
 	pAd->LedCntl.field.PolarityRDY_G = LedSetting->field.PolarityRDY_G;
 	pAd->LedCntl.field.PolarityRDY_A = LedSetting->field.PolarityRDY_A;
@@ -1295,7 +1344,6 @@ NDIS_STATUS	NICInitializeAsic(
 		DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 		return -ENOMEM;
 	}
-
 	*Value = 0xff;
 	RTUSBReadMACRegister(pAd, MAC_CSR0, Version);
 
@@ -1341,6 +1389,7 @@ NDIS_STATUS	NICInitializeAsic(
 	RTUSBReadMACRegister(pAd, STA_CSR0, Counter);
 	RTUSBReadMACRegister(pAd, STA_CSR1, Counter);
 	RTUSBReadMACRegister(pAd, STA_CSR2, Counter);
+
 	// assert HOST ready bit
 	RTUSBWriteMACRegister(pAd, MAC_CSR1, 0x4);
 
@@ -1452,14 +1501,12 @@ VOID NICUpdateRawCounters(
 	// Update RX Overflow counter
 	RTUSBReadMACRegister(pAd, STA_CSR2, &StaCsr2->word);
 	pAd->Counters8023.RxNoBuffer += (StaCsr2->field.RxOverflowCount + StaCsr2->field.RxFifoOverflowCount);
-
 	// Update BEACON sent count
 	RTUSBReadMACRegister(pAd, STA_CSR3, &StaCsr3->word);
 	pAd->RalinkCounters.OneSecBeaconSentCnt += StaCsr3->field.TxBeaconCount;
 
 	RTUSBReadMACRegister(pAd, STA_CSR4, &StaCsr4->word);
 	RTUSBReadMACRegister(pAd, STA_CSR5, &StaCsr5->word);
-
 	// 1st - Transmit Success
 	OldValue = pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart;
 	pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart += (StaCsr4->field.TxOneRetryCount + StaCsr4->field.TxNoRetryCount + StaCsr5->field.TxMultiRetryCount);
@@ -1569,16 +1616,16 @@ INT LoadFirmware (PRTMP_ADAPTER pAd, cha
 
 	// Access firmware file
 	if ((status = request_firmware(&fw_entry, firmName, udevice))) {
-		printk(KERN_ERR "rt73: Failed to request_firmware. "
+		KPRINT(KERN_ERR, "Failed to request_firmware. "
 				"Check your firmware file location\n");
 		goto fw_error;
 	}
 
 	if (fw_entry->size != FIRMWARE_IMAGE_SIZE) {
-		printk(KERN_ERR "rt73: Firmware file size error "
+		KPRINT(KERN_ERR, "Firmware file size error "
 			"(%d instead of %d)\n",
 			fw_entry->size, FIRMWARE_IMAGE_SIZE);
-		status = EBADF;
+		status = -EBADF;
 		goto error;
 	}
 
@@ -1592,9 +1639,9 @@ INT LoadFirmware (PRTMP_ADAPTER pAd, cha
 	crc = ByteCRC16(0x00, crc);
 
 	if (crc != ((fw_entry->data[size] << 8) | fw_entry->data[size + 1])) {
-		printk(KERN_ERR "rt73: Firmware CRC error "
+		KPRINT(KERN_ERR, "Firmware CRC error "
 				"Check your firmware file integrity\n");
-		status = EBADF;
+		status = -EBADF;
 		goto error;
 	}
 
@@ -1607,8 +1654,8 @@ INT LoadFirmware (PRTMP_ADAPTER pAd, cha
 	}
 
 	if (!reg) {
-		printk(KERN_ERR "rt73: Unstable hardware\n");
-		status = EBUSY;
+		KPRINT(KERN_ERR, "Unstable hardware\n");
+		status = -EBUSY;
 		goto error;
 	}
 
@@ -1621,7 +1668,7 @@ INT LoadFirmware (PRTMP_ADAPTER pAd, cha
 #endif
 		if ((status = RTUSBMultiWrite(pAd, FIRMWARE_IMAGE_BASE + i,
 						&buf, sizeof(buf))) < 0) {
-			printk(KERN_ERR "rt73: Firmware loading error\n");
+			KPRINT(KERN_ERR, "Firmware loading error\n");
 			goto error;
 		}
 		loaded += status;
@@ -1630,15 +1677,15 @@ INT LoadFirmware (PRTMP_ADAPTER pAd, cha
 
 	if (loaded < FIRMWARE_IMAGE_SIZE) {
 		// Should never happen
-		printk(KERN_ERR "rt73: Firmware loading incomplete\n");
-		status = EIO;
+		KPRINT(KERN_ERR, "Firmware loading incomplete\n");
+		status = -EIO;
 		goto error;
 	}
 
 
 	// Send 'run firmware' request to device
 	if ((status = RTUSBFirmwareRun(pAd)) < 0) {
-		printk(KERN_ERR "rt73: Device refuses to run firmware\n");
+		KPRINT(KERN_ERR, "Device refuses to run firmware\n");
 		goto error;
 	}
 
@@ -1867,21 +1914,21 @@ VOID	RTMPMoveMemory(
 #ifdef RTMP_EMBEDDED
 	if(Length <= 8)
 	{
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
-		*(((PUCHAR)pDest)++) = *(((PUCHAR)pSrc)++);
+		*(PUCHAR)pDest++ = *(PUCHAR)pSrc++;
 		if(--Length == 0)	return;
 	}
 	else
@@ -2265,7 +2312,6 @@ VOID RTMPCckBbpTuning(
 	IN	UINT			TxRate)
 {
 	CHAR		Bbp94 = 0xFF;
-	USHORT		Value = 0;
 
 	//
 	// Do nothing if TxPowerEnable == FALSE
@@ -2297,8 +2343,8 @@ VOID RTMPCckBbpTuning(
 
 	if ((Bbp94 >= 0) && (Bbp94 <= 0x0C))
 	{
-		Value = (Bbp94 << 8) + BBP_R94;
-        RTUSBEnqueueCmdFromNdis(pAd, RT_OID_VENDOR_WRITE_BBP, TRUE, (PVOID) &Value, sizeof(Value));
+		// sb safe, because we're now in process context.
+		RTUSBWriteBBPRegister(pAd, BBP_R94, Bbp94);
 	}
 }
 
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_main.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_main.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_main.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_main.c	2008-05-09 08:37:23.000000000 +0200
@@ -38,16 +38,21 @@
 
 ULONG	RTDebugLevel = RT_DEBUG_OFF;
 static ULONG	debug = RT_DEBUG_OFF;
+static char *ifname = NULL;
 static char *firmName = RT2573_IMAGE_FILE_NAME;
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 MODULE_PARM(debug, "i");
+MODULE_PARM(ifname, "s");
+MODULE_PARM(firmName, "s");
 #else
 module_param(debug, int, 0);
+module_param(ifname, charp, 0444);
 module_param(firmName, charp, S_IRUGO );
 #endif
 
 MODULE_PARM_DESC(debug, "Debug mask: n selects filter, 0 for none");
+MODULE_PARM_DESC(ifname, "Network device name (default wlan%d)");
 MODULE_PARM_DESC(firmName, "Permit to load a different firmware: (default: rt73.bin) ");
 
 // Following information will be show when you run 'modinfo'
@@ -61,8 +66,6 @@ MODULE_LICENSE("GPL");
  * packets that have a "complete" function are sent here. This way, the
  * completion is run out of kernel context, and doesn't block the rest of
  * the stack. */
-static int mlme_kill;
-static int RTUSBCmd_kill;
 
 extern	const struct iw_handler_def rt73_iw_handler_def;
 
@@ -223,7 +226,7 @@ VOID RTUSBHalt(
 	MLME_QUEUE_ELEM          MsgElem;
 	INT                      i;
 
-	DBGPRINT(RT_DEBUG_TRACE, "====> RTUSBHalt\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--> RTUSBHalt\n");
 
 	//
 	// before set flag fRTMP_ADAPTER_HALT_IN_PROGRESS,
@@ -263,6 +266,12 @@ VOID RTUSBHalt(
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 
+	// We want to wait until all pending receives and sends to the
+	// device object. We cancel any
+	// irps. Wait until sends and receives have stopped.
+	//
+	RTUSBCancelPendingIRPs(pAd);
+
 	RTUSBCleanUpMLMEWaitQueue(pAd);
 	RTUSBCleanUpMLMEBulkOutQueue(pAd);
 
@@ -275,20 +284,11 @@ VOID RTUSBHalt(
     // Sleep 50 milliseconds so pending io might finish normally
 	RTMPusecDelay(50000);
 
-	// We want to wait until all pending receives and sends to the
-	// device object. We cancel any
-	// irps. Wait until sends and receives have stopped.
-	//
-	RTUSBCancelPendingIRPs(pAd);
-
-    // Free the entire adapter object
-	ReleaseAdapter(pAd, IsFree, FALSE);
-
-	// reset mlme & command thread
-    pAd->MLMEThr_pid = -1;
-	pAd->RTUSBCmdThr_pid = -1;
-
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+	// initialize table
+	BssTableInit(&pAd->ScanTab);
+	RTMP_CLEAR_FLAGS(pAd);
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON|fOP_STATUS_ADHOC_ON);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- RTUSBHalt\n");
 }
 
 VOID CMDHandler(
@@ -297,26 +297,32 @@ VOID CMDHandler(
 	PCmdQElmt	cmdqelmt;
 	PUCHAR	    pData;
 	NDIS_STATUS	NdisStatus = NDIS_STATUS_SUCCESS;
-  unsigned long IrqFlags;
+	unsigned long flags;
     ULONG       Now;
 
 	while (pAd->CmdQ.size > 0)
 	{
 
 		NdisStatus = NDIS_STATUS_SUCCESS;
-		NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+		NdisAcquireSpinLock(&pAd->CmdQLock);
 		RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
-		NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+		NdisReleaseSpinLock(&pAd->CmdQLock);
+
+        DBGPRINT(RT_DEBUG_INFO, "- %s: Cmd = %04x\n",
+				__FUNCTION__, cmdqelmt == NULL? 0xdeadbeef: cmdqelmt->command);
+
 		if (cmdqelmt == NULL)
 			break;
 		pData = cmdqelmt->buffer;
-
-        //DBGPRINT_RAW(RT_DEBUG_INFO, "Cmd = %x\n", cmdqelmt->command);
 		switch (cmdqelmt->command)
 		{
 			case RT_OID_CHECK_GPIO:
 			{
 				ULONG data;
+
+				DBGPRINT(RT_DEBUG_TRACE, "- (%s)::RT_OID_CHECK_GPIO\n",
+						__FUNCTION__);
+
 				// Read GPIO pin7 as Hardware controlled radio state
 				RTUSBReadMACRegister(pAd, MAC_CSR13, &data);
 				if (data & 0x80)
@@ -347,7 +353,7 @@ VOID CMDHandler(
 			break;
 
 			case RT_OID_PERIODIC_EXECUT:
-			    STAMlmePeriodicExec(pAd);
+			    MlmePeriodicExec(pAd);
 			break;
 
 			case OID_802_11_BSSID_LIST_SCAN:
@@ -567,7 +573,7 @@ VOID CMDHandler(
 			{
 				INT 	Index;
 
-		        DBGPRINT_RAW(RT_DEBUG_ERROR, "RT_OID_USB_RESET_BULK_OUT\n");
+		        DBGPRINT(RT_DEBUG_ERROR, "RT_OID_USB_RESET_BULK_OUT\n");
 
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
 
@@ -576,7 +582,7 @@ VOID CMDHandler(
 				RTUSBCleanUpDataBulkOutQueue(pAd);
 
 				NICInitializeAsic(pAd);
-				ReleaseAdapter(pAd, FALSE, TRUE);   // unlink urb releated tx context
+				//ReleaseAdapter(pAd, FALSE, TRUE);   // unlink urb releated tx context
 				NICInitTransmit(pAd);
 
 				RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
@@ -605,7 +611,7 @@ VOID CMDHandler(
 			case RT_OID_USB_RESET_BULK_IN:
 		    {
 			    int	i;
-				DBGPRINT_RAW(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
+				DBGPRINT(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
 				NICInitializeAsic(pAd);
 				//RTUSBWriteMACRegister(pAd, TXRX_CSR0, 0x025eb032); // ??
@@ -717,6 +723,9 @@ VOID CMDHandler(
 			{
 				UINT	i = 0;
 
+				DBGPRINT(RT_DEBUG_TRACE, "- (%s)::RT_OID_RESET_FROM_ERROR\n",
+						__FUNCTION__);
+
 				RTUSBRejectPendingPackets(pAd);//reject all NDIS packets waiting in TX queue
 				RTUSBCleanUpDataBulkOutQueue(pAd);
 				MlmeSuspend(pAd, FALSE);
@@ -734,7 +743,8 @@ VOID CMDHandler(
 				{
 				    if (atomic_read(&pAd->PendingRx) > 0)
 					{
-						DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+						DBGPRINT(RT_DEBUG_TRACE,
+								"- (%s) BulkIn IRP Pending!!!\n", __FUNCTION__);
 						RTUSB_VendorRequest(pAd,
 											0,
 											DEVICE_VENDOR_REQUEST_OUT,
@@ -750,7 +760,8 @@ VOID CMDHandler(
 						(pAd->BulkOutPending[2] == TRUE) ||
 						(pAd->BulkOutPending[3] == TRUE))
 					{
-						DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+						DBGPRINT(RT_DEBUG_TRACE,
+							"- (%s) BulkOut IRP Pending!!!\n", __FUNCTION__);
 						if (i == 0)
 						{
 							RTUSBCancelPendingBulkOutIRP(pAd);
@@ -789,7 +800,7 @@ VOID CMDHandler(
 			break;
 
 			case RT_OID_LINK_DOWN:
-				DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(RT_OID_LINK_DOWN)\n");
+				DBGPRINT(RT_DEBUG_TRACE, "LinkDown(RT_OID_LINK_DOWN)\n");
 				LinkDown(pAd, TRUE);
 			break;
 
@@ -798,7 +809,7 @@ VOID CMDHandler(
 				UCHAR	Offset, Value;
 				Offset = *((PUCHAR)pData);
 				Value = *((PUCHAR)(pData + 1));
-				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%02x	value = 0x%02x\n", Offset, Value);
+				DBGPRINT(RT_DEBUG_INFO, "offset = 0x%02x	value = 0x%02x\n", Offset, Value);
 				RTUSBWriteBBPRegister(pAd, Offset, Value);
 			}
 			break;
@@ -808,9 +819,9 @@ VOID CMDHandler(
 				UCHAR	Offset = *((PUCHAR)pData);
 				PUCHAR	pValue = (PUCHAR)(pData + 1);
 
-				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%02x\n", Offset);
+				DBGPRINT(RT_DEBUG_INFO, "offset = 0x%02x\n", Offset);
 				RTUSBReadBBPRegister(pAd, Offset, pValue);
-				DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%02x\n", *pValue);
+				DBGPRINT(RT_DEBUG_INFO, "value = 0x%02x\n", *pValue);
 			}
 			break;
 
@@ -818,7 +829,7 @@ VOID CMDHandler(
 			{
 				ULONG	Value = *((PULONG)pData);
 
-				DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%08x\n", Value);
+				DBGPRINT(RT_DEBUG_INFO, "value = 0x%08x\n", Value);
 				RTUSBWriteRFRegister(pAd, Value);
 			}
 			break;
@@ -876,13 +887,13 @@ VOID CMDHandler(
 				RTUSBReadMACRegister(pAd, PHY_CSR6, &Value2);
 				if (*pData == 1)
 				{
-					DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Flip\n");
+					DBGPRINT(RT_DEBUG_INFO, "I/Q Flip\n");
 					Value1 = Value1 | 0x0004;
 					Value2 = Value2 | 0x0004;
 				}
 				else
 				{
-					DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Not Flip\n");
+					DBGPRINT(RT_DEBUG_INFO, "I/Q Not Flip\n");
 					Value1 = Value1 & 0xFFFB;
 					Value2 = Value2 & 0xFFFB;
 				}
@@ -1029,16 +1040,20 @@ VOID CMDHandler(
 				ULONG	KeyIdx;
 				PNDIS_802_11_WEP	pWepKey;
 
-				DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_WEP  \n");
+				DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_WEP\n");
 
 				pWepKey = (PNDIS_802_11_WEP)pData;
 				KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
 
 				// it is a shared key
-				if ((KeyIdx >= 4) || ((pWepKey->KeyLength != 5) && (pWepKey->KeyLength != 13)))
+				if ((KeyIdx >= 4) ||
+					((pWepKey->KeyLength != 5) && (pWepKey->KeyLength != 13)))
 				{
 					NdisStatus = NDIS_STATUS_FAILURE;
-					DBGPRINT(RT_DEBUG_ERROR, "CMDHandler::OID_802_11_ADD_WEP, INVALID_DATA!!\n");
+					DBGPRINT(RT_DEBUG_ERROR,
+							"CMDHandler::OID_802_11_ADD_WEP "
+							"Invalid index(%d) or len(%d)\n",
+							KeyIdx, pWepKey->KeyLength);
 				}
 				else
 				{
@@ -1052,7 +1067,13 @@ VOID CMDHandler(
 						// Default key for tx (shared key)
 						pAd->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
 					}
-					AsicAddSharedKeyEntry(pAd, 0, (UCHAR)KeyIdx, CipherAlg, pWepKey->KeyMaterial, NULL, NULL);
+					AsicAddSharedKeyEntry(pAd,
+										0,
+										(UCHAR)KeyIdx,
+										CipherAlg,
+										pWepKey->KeyMaterial,
+										NULL,
+										NULL);
 					DBGPRINT(RT_DEBUG_TRACE, "CMDHandler::OID_802_11_ADD_WEP (KeyIdx=%d, Len=%d-byte)\n", KeyIdx, pWepKey->KeyLength);
 				}
 			}
@@ -1371,133 +1392,140 @@ VOID CMDHandler(
 #define EEPROM_BASE			0x0000
 #define EEPROM_SIZE			0x0100
 #define BBP_SIZE			0x0080
+#define RF_SIZE				0x0014
 
+#define CSR_OFFSET(__word)	( CSR_REG_BASE + ((__word) * sizeof(u32)) )
 
-static void rt73usb_read_csr(void *dev, const unsigned long word,
-		void *data)
+static void rt73usb_read_csr(const struct rt2x00_dev *rt2x00dev,
+			     const unsigned int word, u32 *data)
 {
-	RTMP_ADAPTER *pAd = dev;
-
-	RTUSBReadMACRegister(pAd, CSR_REG_BASE + (word * sizeof(u32)), (u32*)data);
+	RTUSBReadMACRegister(rt2x00dev->pAd, CSR_OFFSET(word), data);
 }
 
-static void rt73usb_write_csr(void *dev, const unsigned long word,
-	void *data)
+static void rt73usb_write_csr(const struct rt2x00_dev *rt2x00dev,
+			      const unsigned int word, u32 data)
 {
-	RTMP_ADAPTER *pAd = dev;
+	RTUSBWriteMACRegister(rt2x00dev->pAd, CSR_OFFSET(word), data);
+}
+
 
-	RTUSBWriteMACRegister(pAd, word, *((u32*)data));
+static void rt73usb_read_eeprom(const struct rt2x00_dev *rt2x00dev,
+			        const unsigned int word, u16 *data)
+{
+	RTUSBReadEEPROM(rt2x00dev->pAd, word * sizeof(u16), (PUCHAR)data, sizeof(u16));
 }
 
-static void rt73usb_read_eeprom(void *dev, const unsigned long word,
-		void *data)
+static void rt73usb_write_eeprom(const struct rt2x00_dev *rt2x00dev,
+			         const unsigned int word, u16 data)
 {
-	RTMP_ADAPTER *pAd = dev;
 
-	RTUSBReadEEPROM(pAd, word * sizeof(u16), ((u8*)data), 2);
 }
 
-static void rt73usb_write_eeprom(void *dev, const unsigned long word,
-	void *data)
+static void rt73usb_read_bbp(const struct rt2x00_dev *rt2x00dev,
+			     const unsigned int word, u8 *data)
 {
-	/* DANGEROUS, DON'T DO THIS! */
+	RTUSBReadBBPRegister(rt2x00dev->pAd, word, data);
 }
 
-static void rt73usb_read_bbp(void *dev, const unsigned long word,
-		void *data)
+static void rt73usb_write_bbp(const struct rt2x00_dev *rt2x00dev,
+			      const unsigned int word, u8 data)
 {
-	RTMP_ADAPTER *pAd = dev;
-
-	RTUSBReadBBPRegister(pAd, (u8)word, ((u8*)data));
+	RTUSBWriteBBPRegister(rt2x00dev->pAd, word, data);
 }
 
-static void rt73usb_write_bbp(void *dev, const unsigned long word,
-	void *data)
+static void rt2500usb_read_rf(const struct rt2x00_dev *rt2x00dev,
+			     const unsigned int word, u32 *data)
 {
-	RTMP_ADAPTER *pAd = dev;
-
-	RTUSBWriteBBPRegister(pAd, word, *((u8*)data));
+	*data = 0;
 }
 
-static void rt73usb_open_debugfs(RTMP_ADAPTER *pAd)
+static void rt2500usb_write_rf(const struct rt2x00_dev *rt2x00dev,
+			      const unsigned int word, u32 data)
 {
-	struct rt2x00debug *debug = &pAd->debug;
+}
+
+static const struct rt2x00debug rt73usb_rt2x00debug = {
+	.owner	= THIS_MODULE,
+	.csr	= {
+		.read		= rt73usb_read_csr,
+		.write		= rt73usb_write_csr,
+		.word_size	= sizeof(u32),
+		.word_count	= CSR_REG_SIZE / sizeof(u32),
+	},
+	.eeprom	= {
+		.read		= rt73usb_read_eeprom,
+		.write		= rt73usb_write_eeprom,
+		.word_size	= sizeof(u16),
+		.word_count	= EEPROM_SIZE / sizeof(u16),
+	},
+	.bbp	= {
+		.read		= rt73usb_read_bbp,
+		.write		= rt73usb_write_bbp,
+		.word_size	= sizeof(u8),
+		.word_count	= BBP_SIZE / sizeof(u8),
+	},
+	.rf	= {
+		.read		= rt73usb_read_rf,
+		.write		= rt73usb_write_rf,
+		.word_size	= sizeof(u32),
+		.word_count	= RF_SIZE / sizeof(u32),
+	},
+};
 
-	debug->owner 			= THIS_MODULE;
-	debug->mod_name			= DRIVER_NAME;
-	debug->mod_version		= DRIVER_VERSION;
-	debug->reg_csr.read		= rt73usb_read_csr;
-	debug->reg_csr.write		= rt73usb_write_csr;
-	debug->reg_csr.word_size	= sizeof(u32);
-	debug->reg_csr.length		= CSR_REG_SIZE;
-	debug->reg_eeprom.read		= rt73usb_read_eeprom;
-	debug->reg_eeprom.write		= rt73usb_write_eeprom;
-	debug->reg_eeprom.word_size	= sizeof(u16);
-	debug->reg_eeprom.length	= EEPROM_SIZE;
-	debug->reg_bbp.read		= rt73usb_read_bbp;
-	debug->reg_bbp.write		= rt73usb_write_bbp;
-	debug->reg_bbp.word_size	= sizeof(u8);
-	debug->reg_bbp.length		= BBP_SIZE;
-	debug->dev 			= pAd;
+static struct rt2x00_dev _rt2x00dev;
+static struct rt2x00_ops _ops;
 
-	snprintf(debug->intf_name, sizeof(debug->intf_name),
-		"%s", pAd->net_dev->name);
+static void rt73usb_open_debugfs(RTMP_ADAPTER *pAd)
+{
+	_rt2x00dev.pAd = pAd;
+	_rt2x00dev.ops = &_ops;
+	_rt2x00dev.ops->debugfs = &rt73usb_rt2x00debug;
 
-	if (rt2x00debug_register(debug))
-		printk(KERN_ERR "Failed to register debug handler.\n");
+	rt2x00debug_register(&_rt2x00dev);
 }
 
 static void rt73usb_close_debugfs(RTMP_ADAPTER *pAd)
 {
-	rt2x00debug_deregister(&pAd->debug);
+	rt2x00debug_deregister(&_rt2x00dev);
 }
 #else /* RT2X00DEBUGFS */
 static inline void rt73usb_open_debugfs(RTMP_ADAPTER *pAd){}
 static inline void rt73usb_close_debugfs(RTMP_ADAPTER *pAd){}
 #endif /* RT2X00DEBUGFS */
 
-static int usb_rtusb_open(struct net_device *net_dev)
+static inline int common_probe(PRTMP_ADAPTER pAd)
 {
-	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
-	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
-	UCHAR           TmpPhy;
-	int ret = 0;
-
-	printk("rt73 driver version - %s\n", DRIVER_VERSION);
-	if ( !OPSTATUS_TEST_FLAG (pAd,fOP_STATUS_FIRMWARE_LOAD) ) {
-		DBGPRINT(RT_DEBUG_ERROR, "Firmware not load");
-		ret = -EIO;
-		goto out_firmware_error;
+	//struct net_device   *netdev = pAd->net_dev;
+	int		Status = 0;
+	UCHAR   TmpPhy;
+
+	if (!reserve_module(THIS_MODULE)) {
+		KPRINT(KERN_CRIT, "cannot reserve module\n");
+		return -1;
+	}
+	Status = LoadFirmware(pAd, firmName);
+	if (Status) {
+		DBGPRINT(RT_DEBUG_ERROR, "- %s: Failed to load Firmware.\n",
+				__FUNCTION__);
+		KPRINT(KERN_CRIT, "Failed to load Firmware.\n");
+		goto out;
 	}
 
-	init_MUTEX(&(pAd->usbdev_semaphore));
-
-	// init mediastate to disconnected
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-
-	pAd->rx_bh.func = RTUSBRxPacket;
-	pAd->rx_bk.func = rtusb_bulkrx;
-
 	// Initialize pAd->PortCfg to manufacture default
 	PortCfgInit(pAd);
 
-
 	// Init  RTMP_ADAPTER CmdQElements
-	Status = RTMPInitAdapterBlock(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		return Status;
-	}
+	RTMPInitAdapterBlock(pAd);
 
     //
 	// Init send data structures and related parameters
     //
-	Status = NICInitTransmit(pAd);
+	Status = NICInitTransmit(pAd);	// First dynamic memory alloc
 	if (Status != NDIS_STATUS_SUCCESS)
 	{
-		return Status;
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: Status=%d\n", __FUNCTION__, Status);
+		goto out;
 	}
-
 	//
 	// Init receive data structures and related parameters
 	//
@@ -1506,10 +1534,16 @@ static int usb_rtusb_open(struct net_dev
 	{
 		goto out;
 	}
-
+	//
+	// initialize MLME
+    //
+	Status = MlmeInit(pAd);
+	if(Status != NDIS_STATUS_SUCCESS)
+	{
+		goto out;
+	}
 	// Initialize Asics
-	NICInitializeAsic(pAd);
-
+	NICInitializeAsic(pAd);		// First USB I/O
 	//
 	// Read additional info from NIC such as MAC address
 	// This function must called after register CSR base address
@@ -1528,177 +1562,151 @@ static int usb_rtusb_open(struct net_dev
 		pAd->BbpTuning.R17LowerBoundG += 0x10;
 		pAd->BbpTuning.R17UpperBoundG += 0x10;
 	}
-
 	// hardware initialization after all parameters are acquired from
 	// Registry or E2PROM
 	TmpPhy = pAd->PortCfg.PhyMode;
 	pAd->PortCfg.PhyMode = 0xff;
 	RTMPSetPhyMode(pAd, TmpPhy);
+    // USB_ID info for UI
+    pAd->VendorDesc = 0x148F2573;
+
+	//pAd->rx_bh.data = (unsigned long)pAd;
+	pAd->rx_bh.func = RTUSBRxPacket;
+	pAd->rx_bk.func = rtusb_bulkrx;
 
+	CreateThreads(pAd);
 
-	//
-	// initialize MLME
-    //
-	Status = MlmeInit(pAd);
-	if(Status != NDIS_STATUS_SUCCESS)
-	{
-		goto out;
-	}
+out:
+	release_module(THIS_MODULE);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: Status = %d\n", __FUNCTION__, Status);
+	return Status;
 
-	// mlmethread & RTUSBCmd flag restart
-	mlme_kill = 0;
-	RTUSBCmd_kill = 0;
+} /* End common_probe () */
+
+static int usb_rtusb_open(struct net_device *net_dev)
+{
+	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
+	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
 
-	CreateThreads(net_dev);
+	DBGPRINT(RT_DEBUG_TRACE, "--> %s: driver version - %s\n",
+			__FUNCTION__, DRIVER_VERSION);
+	KPRINT(KERN_INFO, "driver version - %s\n", DRIVER_VERSION);
+	if (!reserve_module(THIS_MODULE)) {
+		KPRINT(KERN_CRIT, "cannot reserve module\n");
+		Status = -1;
+		goto out;
+	}
+	if ( !OPSTATUS_TEST_FLAG (pAd,fOP_STATUS_FIRMWARE_LOAD) ) {
+		KPRINT(KERN_ERR, "Firmware not load\n");
+		DBGPRINT(RT_DEBUG_ERROR, "Firmware not loaded\n");
+		Status = -EIO;
+		goto out_firmware_error;
+	}
+	RTMP_CLEAR_FLAGS(pAd);
 
 	// at every open handler, copy mac address.
-	if (!memcmp(net_dev->dev_addr, "\x00\x00\x00\x00\x00\x00", 6))
-		memcpy(pAd->net_dev->dev_addr, pAd->CurrentAddress, pAd->net_dev->addr_len);
-	else
-		memcpy(pAd->CurrentAddress, pAd->net_dev->dev_addr, pAd->net_dev->addr_len);
+	NICInitializeAsic(pAd);		// First USB I/O
+#ifdef	INIT_FROM_EEPROM
+	NICInitAsicFromEEPROM(pAd);
+#endif
+	RTUSBWriteHWMACAddress(pAd);
+
+	// needed for open after close because CipherAlg lost on close - bb
+	AsicAddSharedKeyEntry(pAd,
+						0,
+						pAd->PortCfg.DefaultKeyId,
+						pAd->SharedKey[pAd->PortCfg.DefaultKeyId].CipherAlg,
+						pAd->SharedKey[pAd->PortCfg.DefaultKeyId].Key,
+						NULL,
+						NULL);
+	// init mediastate to disconnected
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
 	// Clear Reset Flag before starting receiving/transmitting
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
 
-
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 	{
 		RTUSBBulkReceive(pAd);
         RTUSBWriteMACRegister(pAd, TXRX_CSR0, 0x025eb032);    // enable RX of MAC block, Staion not drop control frame
-        // Initialize RF register to default value
-	    AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
-	    AsicLockChannel(pAd, pAd->PortCfg.Channel);
 	}
-
-
-    // USB_ID info for UI
-    pAd->VendorDesc = 0x148F2573;
+	MlmeStart(pAd);
 
 	// Start net_dev interface tx /rx
-	netif_start_queue(net_dev);
-
-	netif_carrier_on(net_dev);
+	netif_carrier_on(net_dev);	// FIXME should reflect state of radio - bb
 	netif_wake_queue(net_dev);
-	return 0;
 
+	/* unlock the device pointers */
+	up(&(pAd->usbdev_semaphore));
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: OK\n", __FUNCTION__);
+	return 0;
 
-out:
-	ReleaseAdapter(pAd, TRUE, FALSE);
 out_firmware_error:
-	return ret;
+	release_module(THIS_MODULE);
+out:
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: Status=%d\n", __FUNCTION__, Status);
+	return Status;
 
-}
+} /* End usb_rtusb_open () */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 static int usb_rtusb_close(struct net_device *net_dev)
 {
 	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
-	int             ret;
-	int		i = 0;
 
 	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup);
 	DECLARE_WAITQUEUE (wait, current);
 
-	DBGPRINT(RT_DEBUG_TRACE,"-->rt73_close\n");
+	DBGPRINT(RT_DEBUG_TRACE,"-->usb_rtusb_close\n");
 
-	netif_carrier_off(pAd->net_dev);
+	netif_carrier_off(pAd->net_dev);// FIXME should reflect state of radio - bb
 	netif_stop_queue(pAd->net_dev);
 
-	DBGPRINT(RT_DEBUG_INFO,"Ensure there are no more active urbs \n");
 	// ensure there are no more active urbs.
 	add_wait_queue (&unlink_wakeup, &wait);
 	pAd->wait = &unlink_wakeup;
-	// maybe wait for deletions to finish.
-	while ((i < 10) && atomic_read(&pAd->PendingRx) > 0) {
-		//msleep(UNLINK_TIMEOUT_MS);
-		i++;
-		DBGPRINT (RT_DEBUG_INFO,"waited for %d urb to complete\n", atomic_read(&pAd->PendingRx));
-	}
+
 	pAd->wait = NULL;
 	remove_wait_queue (&unlink_wakeup, &wait);
 
-	if (pAd->MLMEThr_pid >= 0)
-	{
-		mlme_kill = 1;
-		RTUSBMlmeUp(pAd);
-		wmb(); // need to check
-		ret = kill_proc (pAd->MLMEThr_pid, SIGTERM, 1);
-		if (ret)
-		{
-			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
-			//return ret;		Fix process killing
-		}
-		wait_for_completion (&pAd->notify);
-	}
-	if (pAd->RTUSBCmdThr_pid>= 0)
-	{
-		RTUSBCmd_kill = 1;
-		RTUSBCMDUp(pAd);
-		wmb(); // need to check
-		ret = kill_proc (pAd->RTUSBCmdThr_pid, SIGTERM, 1);
-		if (ret)
-		{
-			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
-			//return ret;		Fix process killing
-		}
-	    wait_for_completion (&pAd->notify);
-	}
+	/* lock the device pointers */
+	down_interruptible(&pAd->usbdev_semaphore);
 
 	RTUSBHalt(pAd, TRUE);
-	DBGPRINT(RT_DEBUG_TRACE,"<--rt73_close\n");
+
+	DBGPRINT(RT_DEBUG_TRACE,"<--usb_rtusb_close\n");
+	KPRINT(KERN_INFO, "closed\n");
+	release_module(THIS_MODULE);
 
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 INT MlmeThread(
     IN void * Context)
 {
 	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.4)\n", __FUNCTION__);
+
 	daemonize();
 	current->flags |= PF_NOFREEZE;
-	/* signal that we've started the thread */
-	complete(&(pAd->notify));
-#if 1
-	while (1)
-	{
-		//if(down_interruptible(&pAd->mlme_semaphore))
-			//break;
-
-		/* lock the device pointers */
-		down(&(pAd->mlme_semaphore));
-
-		if (mlme_kill)
-			break;
 
+	/* Bail on any enabled signal */
+	while (down_interruptible(&pAd->mlme_semaphore) == 0)
+	{
 		/* lock the device pointers , need to check if required*/
-		down(&(pAd->usbdev_semaphore));
+		if (down_interruptible(&(pAd->usbdev_semaphore))) break;
+
+		// Always call Bulk routine, even reset bulk.
+		// The protectioon of rest bulk should be in BulkOut routine
+		RTUSBKickBulkOut(pAd);
+		RTUSBDequeueRxPackets(pAd);
 		MlmeHandler(pAd);
 
 		/* unlock the device pointers */
 		up(&(pAd->usbdev_semaphore));
 	}
-#else
-	// I tried this way for thread handling
-	while(1)
-	{
-		timeout = next_tick;
-		do {
-			timeout = interruptible_sleep_on_timeout (&pAd->MLMEThr_wait, timeout);
-			/* make swsusp happy with our thread */
-			if (current->flags & PF_FREEZE)
-				refrigerator(PF_FREEZE);
-			DBGPRINT(RT_DEBUG_TRACE, "current->flags  = 0x%x\n",current->flags );
-		} while (!signal_pending (current) && (timeout > 0));
-
-		if (signal_pending (current)) {
-			flush_signals(current);
-		}
-
-		if (mlme_kill)
-			break;
-	}
-#endif
 
 	/* notify the exit routine that we're actually exiting now
 	 *
@@ -1714,8 +1722,8 @@ INT MlmeThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	complete_and_exit (&pAd->notify, 0);
-	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<-- MlmeThread\n");
+	complete_and_exit (&pAd->mlmenotify, 0);
 
 }
 INT RTUSBCmdThread(
@@ -1723,24 +1731,16 @@ INT RTUSBCmdThread(
 {
 	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.4)\n", __FUNCTION__);
+
 	daemonize();
 	current->flags |= PF_NOFREEZE;
-	/* signal that we've started the thread */
-	complete(&(pAd->notify));
 
-	while (1)
+	/* Bail on any enabled signal */
+	while (down_interruptible(&pAd->RTUSBCmd_semaphore) == 0)
 	{
-		//if(down_interruptible(&pAd->mlme_semaphore))
-			//break;
-
-		/* lock the device pointers */
-		down(&(pAd->RTUSBCmd_semaphore));
-
-		if (RTUSBCmd_kill)
-			break;
-
 		/* lock the device pointers , need to check if required*/
-		down(&(pAd->usbdev_semaphore));
+		if (down_interruptible(&(pAd->usbdev_semaphore))) break;
 		CMDHandler(pAd);
 
 		/* unlock the device pointers */
@@ -1761,32 +1761,35 @@ INT RTUSBCmdThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	complete_and_exit (&pAd->notify, 0);
-	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBCmdThread\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<-- RTUSBCmdThread\n");
+	complete_and_exit (&pAd->cmdnotify, 0);
 
 }
 
 static void *usb_rtusb_probe(struct usb_device *dev, UINT interface,
 				const struct usb_device_id *id_table)
 {
-		PRTMP_ADAPTER       pAd;
+	PRTMP_ADAPTER       pAd;
 	int                 i;
 	struct net_device   *netdev;
 	int                 res = -ENOMEM;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.4)\n", __FUNCTION__);
+
+	usb_get_dev(dev);
 	for (i = 0; i < rtusb_usb_id_len; i++)
 	{
 		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
 			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
 		{
-			DBGPRINT(RT_DEBUG_TRACE, "idVendor = 0x%x, idProduct = 0x%x \n",
+			KPRINT(KERN_INFO, "idVendor = 0x%x, idProduct = 0x%x \n",
 					le16_to_cpu(dev->descriptor.idVendor),
 					le16_to_cpu(dev->descriptor.idProduct));
 			break;
 		}
 	}
 	if (i == rtusb_usb_id_len) {
-		printk("Device Descriptor not matching\n");
+		KPRINT(KERN_CRIT, "Device Descriptor not matching\n");
 		goto out_noalloc;
 	}
 
@@ -1795,12 +1798,13 @@ static void *usb_rtusb_probe(struct usb_
 	   exceed 128KB and fail.  So we allocate it separately. */
 	pAd = kzalloc(sizeof (*pAd), GFP_KERNEL);
 	if (!pAd) {
-		printk("couldn't allocate RTMP_ADAPTER\n");
+		KPRINT(KERN_CRIT, "couldn't allocate RTMP_ADAPTER\n");
 		goto out_noalloc;
 	}
 
 	netdev = alloc_etherdev(0);
 	if (!netdev) {
+		KPRINT(KERN_CRIT, "alloc_etherdev failed\n");
 		goto out_nonetdev;
 	}
 
@@ -1815,9 +1819,8 @@ static void *usb_rtusb_probe(struct usb_
 	netdev->open = usb_rtusb_open;
 	netdev->hard_start_xmit = RTMPSendPackets;
 	netdev->stop = usb_rtusb_close;
-	netdev->priv = pAd;
 	netdev->get_stats = rt73_get_ether_stats;
-#if WIRELESS_EXT >= 15
+#if WIRELESS_EXT >= 12
 #if WIRELESS_EXT < 17
 	netdev->get_wireless_stats = rt73_get_wireless_stats;
 #endif
@@ -1833,6 +1836,11 @@ static void *usb_rtusb_probe(struct usb_
 
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
+	pAd->MLMEThr_pid= -1;
+	pAd->RTUSBCmdThr_pid= -1;
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+
 	{// find available
 		int 	i=0;
 		char	slot_name[IFNAMSIZ];
@@ -1841,15 +1849,20 @@ static void *usb_rtusb_probe(struct usb_
         struct  usb_interface_descriptor *as;
         struct  usb_endpoint_descriptor *ep;
 
+    	if (ifname == NULL)
+			strcpy(netdev->name, "wlan%d");
+    	else
+			strncpy(netdev->name, ifname, IFNAMSIZ);
+
 		for (i = 0; i < 8; i++)
 		{
-			sprintf(slot_name, "wlan%d", i);
+			sprintf(slot_name, netdev->name, i);
 
 			read_lock_bh(&dev_base_lock); // avoid multiple init
 			for (device = first_net_device(); device != NULL;
 					device = next_net_device(device))
 			{
-				if (strncmp(device->name, slot_name, 4) == 0)
+				if (strncmp(device->name, slot_name, IFNAMSIZ) == 0)
 				{
 					break;
 				}
@@ -1861,11 +1874,12 @@ static void *usb_rtusb_probe(struct usb_
 		if(i == 8)
 		{
 			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
+			KPRINT(KERN_CRIT, "No available slot name\n");
 			goto out;
 		}
 
-		sprintf(netdev->name, "wlan%d", i);
-		DBGPRINT(RT_DEBUG_ERROR, "usb device name %s\n",netdev->name);
+		sprintf(netdev->name, slot_name, i);
+		DBGPRINT(RT_DEBUG_INFO, "usb device name %s\n",netdev->name);
 
         /* get Max Packet Size from usb_dev endpoint */
 //        ifp = dev->actconfig->interface + i;
@@ -1878,16 +1892,15 @@ static void *usb_rtusb_probe(struct usb_
 
 	}
 
-	//pAd->rx_bh.data = (unsigned long)pAd;
-	pAd->rx_bh.func = RTUSBRxPacket;
-	pAd->rx_bk.func = rtusb_bulkrx;
-
 	res = register_netdev(netdev);
 	if (res) {
-		printk("register_netdev failed err=%d\n",res);
+		KPRINT(KERN_CRIT, "register_netdev failed err=%d\n",res);
 		goto out;
 	}
+	res = common_probe(pAd);
+	if (res) goto out;
 
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: adapter present\n", __FUNCTION__);
 	return pAd;
 
 out:
@@ -1895,8 +1908,8 @@ out:
 out_nonetdev:
 	kfree(pAd);
 out_noalloc:
-	MOD_DEC_USE_COUNT;
-	usb_dec_dev_use(dev);
+	usb_put_dev(dev);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: adapter=NULL\n", __FUNCTION__);
 	return NULL;
 }
 
@@ -1905,122 +1918,66 @@ static void usb_rtusb_disconnect(struct 
 {
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) ptr;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s\n", __FUNCTION__);
 
-	if (!pAd)
+	if (!pAd) {
+		DBGPRINT(RT_DEBUG_ERROR, "- (%s) NULL adapter ptr!\n", __FUNCTION__);
 		return;
+	}
+	netif_device_detach(pAd->net_dev);
 
-	tasklet_kill(&pAd->rx_bh);
-	tasklet_kill(&pAd->rx_bk);
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
 	// for debug, wait to show some messages to /proc system
 	udelay(1);
 	//After Add Thread implementation, Upon exec there, pAd->net_dev seems becomes NULL,
 	//need to check why???
 	//assert(pAd->net_dev != NULL)
+	// Can call close function - bb
 	if(pAd->net_dev != NULL)
 	{
-		printk("unregister_netdev()\n");
+		DBGPRINT(RT_DEBUG_INFO, "unregister_netdev\n");
 		unregister_netdev (pAd->net_dev);
 	}
 	udelay(1);
 	udelay(1);
 
-	while (MOD_IN_USE > 0) {
-		MOD_DEC_USE_COUNT;
-	}
-	udelay(1);
-	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
-
-}
-
-#else
-static int usb_rtusb_close(struct net_device *net_dev)
-{
-	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER) net_dev->priv;
-	int             ret;
-	int	            i = 0;
-
-	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup);
-	DECLARE_WAITQUEUE (wait, current);
-
-	DBGPRINT(RT_DEBUG_TRACE,"-->rt73_close \n");
-
-	netif_carrier_off(pAd->net_dev);
-	netif_stop_queue(pAd->net_dev);
-
-	// ensure there are no more active urbs.
-	add_wait_queue (&unlink_wakeup, &wait);
-	pAd->wait = &unlink_wakeup;
-
-	// maybe wait for deletions to finish.
-	while ((i < 25) && atomic_read(&pAd->PendingRx) > 0) {
-#if LINUX_VERSION_CODE >KERNEL_VERSION(2,6,9)
-
-		msleep(UNLINK_TIMEOUT_MS);
-#endif
-		i++;
-	}
-	pAd->wait = NULL;
-	remove_wait_queue (&unlink_wakeup, &wait);
+	tasklet_kill(&pAd->rx_bh);
+	tasklet_kill(&pAd->rx_bk);
+	KillThreads(pAd);
 
-	if (pAd->MLMEThr_pid >= 0)
-	{
-		mlme_kill = 1;
-		RTUSBMlmeUp(pAd);
-		wmb(); // need to check
-		ret = kill_proc (pAd->MLMEThr_pid, SIGTERM, 1);
-		if (ret)
-		{
-			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
-			//return ret;
-		}
-		wait_for_completion (&pAd->notify);
-	}
-	if (pAd->RTUSBCmdThr_pid>= 0)
-	{
-		RTUSBCmd_kill = 1;
-		RTUSBCMDUp(pAd);
-		wmb(); // need to check
-		ret = kill_proc (pAd->RTUSBCmdThr_pid, SIGTERM, 1);
-		if (ret)
-		{
-			printk (KERN_ERR "%s: unable to signal thread\n", pAd->net_dev->name);
-			//return ret;
-		}
-		wait_for_completion (&pAd->notify);
-	}
-	RTUSBHalt(pAd, TRUE);
+	ReleaseAdapter(pAd, TRUE, FALSE);	// Free URB and transfer buffer memory.
+	MlmeFreeMemoryHandler(pAd);
 
-	DBGPRINT(RT_DEBUG_TRACE,"<--rt73_close \n");
+	free_netdev(pAd->net_dev);
+	kfree(pAd);
+	usb_put_dev(dev);
 
-	return 0;
+	DBGPRINT(RT_DEBUG_TRACE,"<-- %s\n", __FUNCTION__);
+	KPRINT(KERN_INFO, "disconnected\n");
 }
 
+#else	// Kernel version > 2.5.0
 INT MlmeThread(
     IN void * Context)
 {
 	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
 
-	daemonize("rt73");
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.6)\n", __FUNCTION__);
+
+	daemonize("rt73Mlme");
 	allow_signal(SIGTERM);
 	current->flags |= PF_NOFREEZE;
-	/* signal that we've started the thread */
-	complete(&(pAd->notify));
 
-	while (1)
+	/* Bail on any enabled signal */
+	while (down_interruptible(&pAd->mlme_semaphore) == 0)
 	{
-		//if(down_interruptible(&pAd->mlme_semaphore))
-			//break;
-
-		/* lock the device pointers */
-		down(&(pAd->mlme_semaphore));
-
-		if (mlme_kill)
-			break;
-
 		/* lock the device pointers , need to check if required*/
-		down(&(pAd->usbdev_semaphore));
+		if (down_interruptible(&(pAd->usbdev_semaphore))) break;
 
+		// Always call Bulk routine, even reset bulk.
+		// The protectioon of rest bulk should be in BulkOut routine
+		RTUSBKickBulkOut(pAd);
+		RTUSBDequeueRxPackets(pAd);
 		MlmeHandler(pAd);
 
 		/* unlock the device pointers */
@@ -2041,8 +1998,8 @@ INT MlmeThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	complete_and_exit (&pAd->notify, 0);
-	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<-- MlmeThread\n");
+	complete_and_exit (&pAd->mlmenotify, 0);
 }
 
 INT RTUSBCmdThread(
@@ -2050,26 +2007,17 @@ INT RTUSBCmdThread(
 {
 	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)Context;
 
-	daemonize("rt73");
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.6)\n", __FUNCTION__);
+
+	daemonize("rt73Cmd");
 	allow_signal(SIGTERM);
 	current->flags |= PF_NOFREEZE;
-	/* signal that we've started the thread */
-	complete(&(pAd->notify));
 
-	while (1)
+	/* Bail on any enabled signal */
+	while (down_interruptible(&pAd->RTUSBCmd_semaphore) == 0)
 	{
-		//if(down_interruptible(&pAd->mlme_semaphore))
-			//break;
-
-		/* lock the device pointers */
-		down(&(pAd->RTUSBCmd_semaphore));
-
-		if (RTUSBCmd_kill)
-			break;
-
 		/* lock the device pointers , need to check if required*/
-		down(&(pAd->usbdev_semaphore));
-
+		if (down_interruptible(&(pAd->usbdev_semaphore))) break;
 		CMDHandler(pAd);
 
 		/* unlock the device pointers */
@@ -2090,7 +2038,8 @@ INT RTUSBCmdThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	complete_and_exit (&pAd->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE,"<-- %s\n", __FUNCTION__);
+	complete_and_exit (&pAd->cmdnotify, 0);
 }
 
 static int usb_rtusb_probe (struct usb_interface *intf,
@@ -2102,21 +2051,22 @@ static int usb_rtusb_probe (struct usb_i
 	struct net_device   *netdev;
 	int                 res = -ENOMEM;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s (2.6)\n", __FUNCTION__);
+
 	usb_get_dev(dev);
 	for (i = 0; i < rtusb_usb_id_len; i++)
 	{
 		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
 			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
 		{
-			/* printk("idVendor = 0x%x, idProduct = 0x%x \n",
+			KPRINT(KERN_INFO, "idVendor = 0x%x, idProduct = 0x%x \n",
 					le16_to_cpu(dev->descriptor.idVendor),
 					le16_to_cpu(dev->descriptor.idProduct));
-			*/
 			break;
 		}
 	}
 	if (i == rtusb_usb_id_len) {
-		printk("Device Descriptor not matching\n");
+		KPRINT(KERN_CRIT, "Device Descriptor not matching\n");
 		goto out_noalloc;
 	}
 
@@ -2125,13 +2075,13 @@ static int usb_rtusb_probe (struct usb_i
 	   exceed 128KB and fail.  So we allocate it separately. */
 	pAd = kzalloc(sizeof (*pAd), GFP_KERNEL);
 	if (!pAd) {
-		printk("couldn't allocate RTMP_ADAPTER\n");
+		KPRINT(KERN_CRIT, "couldn't allocate RTMP_ADAPTER\n");
 		goto out_noalloc;
 	}
 
 	netdev = alloc_etherdev(0);
 	if (!netdev) {
-		printk("alloc_etherdev failed\n");
+		KPRINT(KERN_CRIT, "alloc_etherdev failed\n");
 		goto out_nonetdev;
 	}
 
@@ -2145,7 +2095,6 @@ static int usb_rtusb_probe (struct usb_i
 
 	netdev->open = usb_rtusb_open;
 	netdev->stop = usb_rtusb_close;
-	netdev->priv = pAd;
 	netdev->hard_start_xmit = RTMPSendPackets;
 	netdev->get_stats = rt73_get_ether_stats;
 
@@ -2160,7 +2109,7 @@ static int usb_rtusb_probe (struct usb_i
 	netdev->hard_header_len = 14;
 	netdev->mtu = 1500;
 	netdev->addr_len = 6;
-	netdev->weight = 64;
+	//netdev->weight = 64;	// Used only for poll. N/A in 2.6.24 - bb
 
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
@@ -2176,10 +2125,14 @@ static int usb_rtusb_probe (struct usb_i
         struct  usb_host_interface *iface_desc;
         struct  usb_endpoint_descriptor *endpoint;
 
+    	if (ifname == NULL)
+			strcpy(pAd->net_dev->name, "wlan%d");
+    	else
+			strncpy(pAd->net_dev->name, ifname, IFNAMSIZ);
 
 		for (i = 0; i < 8; i++)
 		{
-			sprintf(slot_name, "wlan%d", i);
+			sprintf(slot_name, pAd->net_dev->name, i);
 
 #if 1
 			if(dev_get_by_name(slot_name)==NULL)
@@ -2189,7 +2142,7 @@ static int usb_rtusb_probe (struct usb_i
 			for (device = first_net_device(); device != NULL;
 					device = next_net_device(device))
 			{
-				if (strncmp(device->name, slot_name, 4) == 0)
+				if (strncmp(device->name, slot_name, IFNAMSIZ) == 0)
 				{
 					break;
 				}
@@ -2202,10 +2155,11 @@ static int usb_rtusb_probe (struct usb_i
 		if(i == 8)
 		{
 			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
-			return res;
+			KPRINT(KERN_CRIT, "No available slot name\n");
+			goto out;
 		}
 
-		sprintf(pAd->net_dev->name, "wlan%d", i);
+		sprintf(pAd->net_dev->name, slot_name, i);
 		DBGPRINT(RT_DEBUG_ERROR, "usb device name %s\n", pAd->net_dev->name);
 
 
@@ -2221,26 +2175,19 @@ static int usb_rtusb_probe (struct usb_i
 
 	}
 
-    //bottom half data is assign at  each task_scheduler
-	//pAd->rx_bh.data = (unsigned long)pAd;
-	pAd->rx_bh.func = RTUSBRxPacket;
-
-
 	res = register_netdev(netdev);
 	if (res) {
-		printk("register_netdev failed err=%d\n",res);
+		KPRINT(KERN_CRIT, "register_netdev failed err=%d\n",res);
 		goto out;
 	}
 
 	usb_set_intfdata(intf, pAd);
 
-
 	rt73usb_open_debugfs(pAd);
-	res = LoadFirmware(pAd, firmName);
-	if (res) {
-		DBGPRINT(RT_DEBUG_ERROR, "Failed to request Firmware.\n");
-		goto out;
-	}
+	res = common_probe(pAd);
+	if (res) goto out;
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: res=%d\n", __FUNCTION__, res);
 	return 0;
 
 out:
@@ -2248,7 +2195,8 @@ out:
 out_nonetdev:
 	kfree(pAd);
 out_noalloc:
-	module_put(THIS_MODULE);
+	usb_put_dev(dev);
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: res=%d\n", __FUNCTION__, res);
 	return res;
 }
 
@@ -2257,41 +2205,52 @@ static void usb_rtusb_disconnect(struct 
 	struct usb_device   *dev = interface_to_usbdev(intf);
 	PRTMP_ADAPTER       pAd = (PRTMP_ADAPTER)NULL;
 
+	DBGPRINT(RT_DEBUG_TRACE,"--> %s\n", __FUNCTION__);
+
 	pAd = usb_get_intfdata(intf);
+	if (!pAd) {
+		DBGPRINT(RT_DEBUG_ERROR, "- (%s) NULL adapter ptr!\n", __FUNCTION__);
+		return;
+	}
+	netif_device_detach(pAd->net_dev);
 
 	usb_set_intfdata(intf, NULL);
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
-	DBGPRINT(RT_DEBUG_ERROR,"unregister usbnet usb-%s-%s\n",
+	DBGPRINT(RT_DEBUG_INFO,"disconnect usbnet usb-%s-%s\n",
 		dev->bus->bus_name, dev->devpath);
-	if (!pAd)
-		return;
 
 	rt73usb_close_debugfs(pAd);
 
-	tasklet_kill(&pAd->rx_bh);
-	tasklet_kill(&pAd->rx_bk);
 	// for debug, wait to show some messages to /proc system
 	udelay(1);
 	//After Add Thread implementation, Upon exec there, pAd->net_dev seems becomes NULL,
 	//need to check why???
 	//assert(pAd->net_dev != NULL)
+	// Can call close function - bb
 	if(pAd->net_dev!= NULL)
 	{
-		//printk("unregister_netdev()\n");
+		DBGPRINT(RT_DEBUG_INFO, "unregister_netdev\n");
 		unregister_netdev (pAd->net_dev);
 	}
 	udelay(1);
-	flush_scheduled_work ();
-	udelay(1);
+
+	tasklet_kill(&pAd->rx_bh);
+	tasklet_kill(&pAd->rx_bk);
+	KillThreads(pAd);
+
+    // Free the entire adapter object
+	ReleaseAdapter(pAd, TRUE, FALSE);
+	MlmeFreeMemoryHandler(pAd); //Free MLME memory handler
 
 	free_netdev(pAd->net_dev);
 	kfree(pAd);
 	usb_put_dev(dev);
-	udelay(1);
-	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- %s\n", __FUNCTION__);
+	KPRINT(KERN_INFO, "disconnected\n");
 
 }
-#endif
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) */
 
 
 //
@@ -2299,7 +2258,7 @@ static void usb_rtusb_disconnect(struct 
 //
 INT __init usb_rtusb_init(void)
 {
-    //printk("rtusb init ====>\n");
+    KPRINT(KERN_INFO, "init\n");
 	#ifdef DBG
     RTDebugLevel = debug;
 	#else
@@ -2312,30 +2271,27 @@ INT __init usb_rtusb_init(void)
 	return usb_register(&rtusb_driver);
 }
 
-//
-// Driver module unload function
-//
-VOID __exit usb_rtusb_exit(void)
-{
-	udelay(1);
-	udelay(1);
-	usb_deregister(&rtusb_driver);
-
-	//printk("<=== rtusb exit\n");
-}
-
 static int __init rt73_wlan_opt(char *str)
 {
 	if (!str || !*str)
 		return -EINVAL;
-
 	if (!strncmp(str, "debug:", 6)) {
 		debug = simple_strtoul(str + 6, NULL, 0);
 	}
-
 	return 0;
 }
 
+//
+// Driver module unload function
+//
+VOID __exit usb_rtusb_exit(void)
+{
+	udelay(1);
+	udelay(1);
+	usb_deregister(&rtusb_driver);
+
+	KPRINT(KERN_INFO, "exit\n");
+}
 /**************************************/
 __setup("rt73wlan=", rt73_wlan_opt);
 module_init(usb_rtusb_init);
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_tkip.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_tkip.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_tkip.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_tkip.c	2008-05-09 09:10:12.000000000 +0200
@@ -380,19 +380,19 @@ BOOLEAN	    RTMPTkipCompareMICValue(
 	// Since the MIC value might cross MPDUs.
 	if(!NdisEqualMemory(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8))
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Orig MIC value =");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "Orig MIC value =");  //MIC error.
 		for (i = 0; i < 8; i++)
 		{
-			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "%02x:", OldMic[i]);  //MIC error.
 		}
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated MIC value =");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "Calculated MIC value =");  //MIC error.
 		for (i = 0; i < 8; i++)
 		{
-			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
 		}
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "\n");  //MIC error.
 		return (FALSE);
 	}
 	return (TRUE);
@@ -459,19 +459,19 @@ BOOLEAN	    RTMPTkipCompareMICValueWithL
 	// Since the MIC value might cross MPDUs.
 	if(!NdisEqualMemory(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8))
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Orig MIC value =");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "Orig MIC value =");  //MIC error.
 		for (i = 0; i < 8; i++)
 		{
-			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "%02x:", OldMic[i]);  //MIC error.
 		}
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
-		DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated MIC value =");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, "Calculated MIC value =");  //MIC error.
 		for (i = 0; i < 8; i++)
 		{
-			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
 		}
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "\n");  //MIC error.
 		return (FALSE);
 	}
 	return (TRUE);
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_type.h linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_type.h
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtmp_type.h	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtmp_type.h	2008-05-09 06:24:59.000000000 +0200
@@ -38,35 +38,18 @@
 // Put platform dependent declaration here
 // For example, linux type definition
 
+#ifdef RTMP_EMBEDDED
+#define ALIGN_USB_RCV  __attribute__ ((aligned(2)))
+#else
+#define ALIGN_USB_RCV
+#endif
+
 //#ifdef  Linux
 typedef u16      UINT16;
 typedef u32      UINT32;
 typedef u64      UINT64;
 //#endif
 
-#ifndef Win32
-#define Win32
-
-#undef  BIG_ENDIAN          // Only little endian for WIN32 system
-
-//
-// Following type define have been already define in
-// %include%\basetsd.h     eg. c:\winddk\3790\inc\wxp\basetsd.h
-//     Defined  Win2k      WinXP
-//     UINT16     X           O
-//     UINT32     O           O
-//     UINT64     X           O
-#ifdef NDIS50_MINIPORT
-
-typedef unsigned short      UINT16;
-//typedef   unsigned long       UINT32;
-typedef unsigned __int64    UINT64;
-
-#endif //#ifdef NDIS50_MINIPORT
-
-#endif //#ifndef Win32
-
-
 // Endian byte swapping codes
 #define SWAP16(x) \
     ((UINT16)( \
@@ -113,7 +96,7 @@ typedef unsigned __int64    UINT64;
 #ifdef RTMP_EMBEDDED
 #define PACKED  __attribute__ ((packed))
 #else
-#define PACKED
+#define PACKED		// FIXME Whaaa?
 #endif  // RTMP_EMBEDDED
 
 
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_bulk.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_bulk.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_bulk.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_bulk.c	2008-05-09 06:24:59.000000000 +0200
@@ -59,104 +59,101 @@ VOID RTUSBBulkOutDataPacketComplete(purb
 	PRTMP_ADAPTER	pAd;
 	NTSTATUS		status;
 	UCHAR			BulkOutPipeId;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutDataPacketComplete\n");
 	pTxContext= (PTX_CONTEXT)pUrb->context;
 	pAd = pTxContext->pAd;
 	status = pUrb->status;
+	atomic_dec(&pAd->PendingTx);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingTx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingTx));
 
 	// Store BulkOut PipeId
 	BulkOutPipeId = pTxContext->BulkOutPipeId;
+	pAd->TxRingTotalNumber[BulkOutPipeId]--;// sync. to PendingTx
 	pAd->BulkOutDataOneSecCount++;
 
-	if (status == USB_ST_NOERROR)
-	{
-		DBGPRINT_RAW(RT_DEBUG_INFO, "BulkOutDataPacketComplete %d (STATUS_SUCCESS)\n", BulkOutPipeId);
-
-		if (pTxContext->LastOne == TRUE)
-		{
-			pAd->Counters.GoodTransmits++;
-			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-            pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
-
-			if (!skb_queue_empty(&pAd->SendTxWaitQueue[BulkOutPipeId]))
-			{
-				RTMPDeQueuePacket(pAd, BulkOutPipeId);
-			}
-		}
-		else
-		{
-			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+	switch (status) {
+		case 0:					// OK
+			if (pTxContext->LastOne == TRUE)
 			{
+				pAd->Counters.GoodTransmits++;
 				FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-				pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
-				// Indicate next one is frag data which has highest priority
-				RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
+
+				if (!skb_queue_empty(&pAd->SendTxWaitQueue[BulkOutPipeId])) {
+					RTMPDeQueuePacket(pAd, BulkOutPipeId);
+				}
 			}
-			else
-			{
-				while (pTxContext->LastOne != TRUE)
+			else {
+				if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
 				{
 					FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-					pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
-					pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+
+					// Indicate next one is frag data which has highest priority
+					RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
 				}
+				else {
+					while (pTxContext->LastOne != TRUE) {
+						FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+						pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+						atomic_dec(&pAd->PendingTx);
+						pAd->TxRingTotalNumber[BulkOutPipeId]--;// sync. to PendingTx
+					}
+					FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
+				}
+			}
+			RTUSBMlmeUp(pAd);
+			break;
+
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
+		case -ESHUTDOWN:		// hardware gone = -108
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			break;
 
+		default:
+#if 1	// STATUS_OTHER
+			while (pTxContext->LastOne != TRUE) {
 				FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-				pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+				pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to PendingTx
+				pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
+				atomic_dec(&pAd->PendingTx);
 			}
-		}
-	}
-#if 1	// STATUS_OTHER
-	else
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "BulkOutDataPacketComplete %d (STATUS_OTHER)\n", BulkOutPipeId);
-
-		while (pTxContext->LastOne != TRUE)
-		{
 			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
-			pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
-		}
-		FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-		pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
-
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
-		}
+			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to PendingTx
 
-	}
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				DBGPRINT(RT_DEBUG_ERROR, "Bulk Out Data Packet Failed\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+			}
 #endif
-
-
+			break;
+	}
 	pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
 	//
 	// bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut
 	// bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out.
 	//
-	if ((pTxContext->bWaitingBulkOut == TRUE) && !RTUSB_TEST_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId)))
+	if ((pTxContext->bWaitingBulkOut == TRUE) &&
+	!RTUSB_TEST_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId)))
 	{
 		// Indicate There is data avaliable
 		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
 	}
-
-
-	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 }
 
 // NULL frame use BulkOutPipeId = 0
@@ -165,49 +162,54 @@ VOID RTUSBBulkOutNullFrameComplete(purbb
 	PRTMP_ADAPTER	pAd;
 	PTX_CONTEXT		pNullContext;
 	NTSTATUS		status;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
 	pNullContext= (PTX_CONTEXT)pUrb->context;
 	pAd = pNullContext->pAd;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrameComplete\n");
-
 	// Reset Null frame context flags
 	pNullContext->IRPPending = FALSE;
 	pNullContext->InUse = FALSE;
-
 	status = pUrb->status;
+	atomic_dec(&pAd->PendingTx);
 
-	if (status == USB_ST_NOERROR)
-	{
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingTx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingTx));
+
+	switch (status) {
+		case 0:					// OK
 		// Don't worry about the queue is empty or not, this function will check itself
-		RTMPDeQueuePacket(pAd, 0);
-	}
+			RTMPDeQueuePacket(pAd, 0);
+			RTUSBMlmeUp(pAd);
+			break;
+
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
+		case -ESHUTDOWN:		// hardware gone = -108
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			break;
+
+		default:
 #if 1	// STATUS_OTHER
-	else
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
-		}
-	}
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				DBGPRINT(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+			}
+			break;
 #endif
-
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	}
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	pAd->BulkOutPending[0] = FALSE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutNullFrameComplete\n");
 }
 
 // RTS frame use BulkOutPipeId = PipeID
@@ -216,49 +218,54 @@ VOID RTUSBBulkOutRTSFrameComplete(purbb_
 	PRTMP_ADAPTER	pAd;
 	PTX_CONTEXT		pRTSContext;
 	NTSTATUS		status;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
 	pRTSContext= (PTX_CONTEXT)pUrb->context;
 	pAd = pRTSContext->pAd;
 
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutRTSFrameComplete\n");
-
 	// Reset RTS frame context flags
 	pRTSContext->IRPPending = FALSE;
 	pRTSContext->InUse = FALSE;
-
 	status = pUrb->status;
+	atomic_dec(&pAd->PendingTx);
 
-	if (status == USB_ST_NOERROR)
-	{
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingTx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingTx));
+
+	switch (status) {
+		case 0:					// OK
 		// Don't worry about the queue is empty or not, this function will check itself
-		RTMPDeQueuePacket(pAd, pRTSContext->BulkOutPipeId);
-	}
+			RTMPDeQueuePacket(pAd, pRTSContext->BulkOutPipeId);
+			RTUSBMlmeUp(pAd);
+			break;
+
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
+		case -ESHUTDOWN:		// hardware gone = -108
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			break;
+
+		default:
 #if 1	// STATUS_OTHER
-	else
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out RTS Frame Failed\n");
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
-		}
-	}
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				DBGPRINT(RT_DEBUG_ERROR, "Bulk Out RTS Frame Failed\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+			}
+			break;
 #endif
-
-	NdisAcquireSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
+	}
+	NdisAcquireSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId]);
 	pAd->BulkOutPending[pRTSContext->BulkOutPipeId] = FALSE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId]);
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutRTSFrameComplete\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutRTSFrameComplete\n");
 
 }
 
@@ -268,11 +275,15 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 	PTX_CONTEXT			pMLMEContext;
 	PRTMP_ADAPTER		pAd;
 	NTSTATUS			status;
-	unsigned long				IrqFlags;
+	unsigned long				flags;
 
 	pMLMEContext= (PTX_CONTEXT)pUrb->context;
 	pAd = pMLMEContext->pAd;
 	status = pUrb->status;
+	atomic_dec(&pAd->PendingTx);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingTx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingTx));
 
 	pAd->PrioRingTxCnt--;
 	if (pAd->PrioRingTxCnt < 0)
@@ -284,45 +295,53 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 		pAd->PrioRingFirstIndex = 0;
 	}
 
+#if 0
 	DBGPRINT(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacketComplete::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
 			pAd->PrioRingFirstIndex,
 			pAd->PrioRingTxCnt, pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutMLMEPacketComplete\n");
+#endif
 
 	// Reset MLME context flags
 	pMLMEContext->IRPPending	= FALSE;
 	pMLMEContext->InUse 		= FALSE;
 
-	if (status == USB_ST_NOERROR)
-	{
-		// Don't worry about the queue is empty or not, this function will check itself
-		RTUSBDequeueMLMEPacket(pAd);
-	}
+	switch (status) {
+		case 0:					// OK
+			if (pAd->PrioRingTxCnt > 0) {
+				RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
+			}
+			RTUSBMlmeUp(pAd);
+			break;
+
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
+		case -ESHUTDOWN:		// hardware gone = -108
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			break;
+
+		default:
 #if 1	// STATUS_OTHER
-	else
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out MLME Failed\n");
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
-		}
-	}
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				DBGPRINT(RT_DEBUG_ERROR, "Bulk Out MLME Failed\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+			}
+			break;
 #endif
+	}
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	pAd->BulkOutPending[0] = FALSE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacketComplete\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutMLMEPacketComplete\n");
 
 }
 
@@ -332,47 +351,54 @@ VOID RTUSBBulkOutPsPollComplete(purbb_t 
 	PRTMP_ADAPTER	pAd;
 	PTX_CONTEXT		pPsPollContext;
 	NTSTATUS		status;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
 	pPsPollContext= (PTX_CONTEXT)pUrb->context;
 	pAd = pPsPollContext->pAd;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutPsPollComplete\n");
-
 	// Reset PsPoll context flags
 	pPsPollContext->IRPPending	= FALSE;
 	pPsPollContext->InUse		= FALSE;
-
 	status = pUrb->status;
-	if (status == USB_ST_NOERROR)
-	{
+	atomic_dec(&pAd->PendingTx);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingTx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingTx));
+
+	switch (status) {
+		case 0:					// OK
 		// Don't worry about the queue is empty or not, this function will check itself
-		RTMPDeQueuePacket(pAd, 0);
-	}
+			RTMPDeQueuePacket(pAd, 0);
+			RTUSBMlmeUp(pAd);
+			break;
+
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
+		case -ESHUTDOWN:		// hardware gone = -108
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			break;
+
+		default:
 #if 1	// STATUS_OTHER
-	else
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out PSPoll Failed\n");
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
-		}
-	}
+			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				DBGPRINT(RT_DEBUG_ERROR, "Bulk Out PSPoll Failed\n");
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_OUT);
+			}
+			break;
 #endif
-
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	}
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	pAd->BulkOutPending[0] = FALSE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutPsPollComplete\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutPsPollComplete\n");
 
 }
 
@@ -416,67 +442,29 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 	//		4) The irp was cancelled.
 	//		5) Some other failure from the USB device object.
 	//
-
-	//
-	// Free the IRP  and its mdl because they were	alloced by us
-	//
-#if 0
-	if ( (atomread = (atomic_read(&pRxContext->IrpLock))) == IRPLOCK_CANCE_START)
-	{
-		atomic_dec(&pAd->PendingRx);
-		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_COMPLETE);
-	}
-#endif
 	status = pUrb->status;
 	atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
 	atomic_dec(&pAd->PendingRx);
 
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s status=%d PendingRx=%d\n",
+			__FUNCTION__, status, atomic_read(&pAd->PendingRx));
+
 	switch (status)
 	{
 		case 0:
-			 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
-			{
-				//RTUSBRxPacket(pUrb);
-				pAd->rx_bh.data = (unsigned long)pUrb;
-				tasklet_schedule(&pAd->rx_bh);
-				break;
-
-			}// STATUS_SUCCESS
-			DBGPRINT(RT_DEBUG_INFO,"==> RTUSBBulkRxComplete  (IrpLock) = %d\n", atomic_read(&pRxContext->IrpLock));
+			RTUSBMlmeUp(pAd);
 			break;
 
-		case -ECONNRESET:		// async unlink
+		case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+		case -ENOENT:			// stopped by call to usb_kill_urb
 		case -ESHUTDOWN:		// hardware gone = -108
-			pUrb = NULL;
-			DBGPRINT(RT_DEBUG_ERROR,"==> RTUSBBulkRxComplete Error code = %d\n", status);
-			//tasklet_schedule(&pAd->rx_bh);
+		case -EPROTO:			// unplugged = -71
+			DBGPRINT(RT_DEBUG_ERROR,"=== %s: shutdown status=%d\n",
+					__FUNCTION__, status);
+			pRxContext->InUse = FALSE;
+		default:
 			break;
-
-	}
-#if 0
-	 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
-	{
-		RTUSBRxPacket(pUrb);
-		//tasklet_schedule(&pAd->rx_bh);
-
-	}// STATUS_SUCCESS
-	else
-	{
-		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete Error code = %d\n", status);
-		pRxContext->InUse = FALSE;
-
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk In Failed\n");
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
-		}
 	}
-
-#endif
 }
 
 VOID	RTUSBInitTxDesc(
@@ -548,16 +536,16 @@ VOID	RTUSBBulkOutDataPacket(
 	PTX_CONTEXT	pTxContext;
 	PURB		pUrb;
 	int 		ret = 0;
-	unsigned long		IrqFlags;
+	unsigned long		flags;
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 	if (pAd->BulkOutPending[BulkOutPipeId] == TRUE)
 	{
-		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 		return;
 	}
 	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 
 	pTxContext = &(pAd->TxContext[BulkOutPipeId][Index]);
 
@@ -573,9 +561,9 @@ VOID	RTUSBBulkOutDataPacket(
 	{
 		DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, pTxContext->bWaitingBulkOut != TRUE, Index %d, NextBulkOutIndex %d\n",
 			Index, pAd->NextBulkOutIndex[BulkOutPipeId]);
-		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 		return;
 	}
 	else if (pTxContext->BulkOutSize == 0)
@@ -586,7 +574,7 @@ VOID	RTUSBBulkOutDataPacket(
 		// We will break it when the Key was Zero on RTUSBHardTransmit
 		// And this will cause deadlock that the TxContext always InUse.
 		//
-		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 
 		pTxContext->InUse	   = FALSE;
 		pTxContext->LastOne    = FALSE;
@@ -595,29 +583,30 @@ VOID	RTUSBBulkOutDataPacket(
 		pTxContext->BulkOutSize= 0;
 		pAd->NextBulkOutIndex[BulkOutPipeId] = (pAd->NextBulkOutIndex[BulkOutPipeId] + 1) % TX_RING_SIZE;
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 
 		return;
 	}
+	// FIXME totally hosed logic - bb
 	else if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
 			!(pAd->PortCfg.BssType == BSS_MONITOR && pAd->bAcceptRFMONTx==TRUE))
 	{
 		//
 		// Since there is no connection, so we need to empty the Tx Bulk out Ring.
 		//
-		while (atomic_read(&pAd->TxCount) > 0)
+		while (atomic_read(&pAd->PendingTx) > 0)
 		{
 			DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, since NdisMediaStateDisconnected discard NextBulkOutIndex %d, NextIndex = %d\n",
 				pAd->NextBulkOutIndex[BulkOutPipeId], pAd->NextTxIndex[BulkOutPipeId]);
 
 			FREE_TX_RING(pAd, BulkOutPipeId, pTxContext);
-			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to TxCount
+			pAd->TxRingTotalNumber[BulkOutPipeId]--;    // sync. to PendingTx
 			pTxContext = &(pAd->TxContext[BulkOutPipeId][pAd->NextBulkOutIndex[BulkOutPipeId]]);
 		}
 
-		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[BulkOutPipeId]);
 
 		return;
 	}
@@ -635,8 +624,11 @@ VOID	RTUSBBulkOutDataPacket(
 		DBGPRINT(RT_DEBUG_ERROR, "Submit Tx URB failed %d\n", ret);
 		return;
 	}
+	else {
+		atomic_inc(&pAd->PendingTx);
+	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutDataPacket \n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutDataPacket \n");
 	return;
 }
 
@@ -659,21 +651,21 @@ VOID	RTUSBBulkOutNullFrame(
 	PTX_CONTEXT	pNullContext = &(pAd->NullContext);
 	PURB		pUrb;
 	int 		ret = 0;
-	unsigned long		IrqFlags;
+	unsigned long		flags;
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	if (pAd->BulkOutPending[0] == TRUE)
 	{
-		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 		return;
 	}
 	pAd->BulkOutPending[0] = TRUE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 
 	// Increase Total transmit byte counter
 	pAd->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrame \n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->RTUSBBulkOutNullFrame \n");
 
 	// Clear Null frame bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
@@ -689,8 +681,12 @@ VOID	RTUSBBulkOutNullFrame(
 		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
 		return;
 	}
+	else {
+		atomic_inc(&pAd->PendingTx);
+	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrame \n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutNullFrame PendingTx=%d\n",
+			atomic_read(&pAd->PendingTx));
 	return;
 }
 
@@ -713,7 +709,7 @@ VOID	RTUSBBulkOutRTSFrame(
 	PTX_CONTEXT	pRTSContext = &(pAd->RTSContext);
 	PURB		pUrb;
 	int 		ret = 0;
-	unsigned long		IrqFlags;
+	unsigned long		flags;
 	UCHAR		PipeID=0;
 
 	if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4))
@@ -726,19 +722,19 @@ VOID	RTUSBBulkOutRTSFrame(
 		PipeID= 0;
 
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[PipeID]);
 	if (pAd->BulkOutPending[PipeID] == TRUE)
 	{
-		NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID]);
 		return;
 	}
 	pAd->BulkOutPending[PipeID] = TRUE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[PipeID]);
 
 	// Increase Total transmit byte counter
 	pAd->RalinkCounters.TransmittedByteCount +=  pRTSContext->BulkOutSize;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutRTSFrame \n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->RTUSBBulkOutRTSFrame \n");
 
 	// Clear RTS frame bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_RTS);
@@ -753,8 +749,11 @@ VOID	RTUSBBulkOutRTSFrame(
 		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
 		return;
 	}
+	else {
+		atomic_inc(&pAd->PendingTx);
+	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutRTSFrame \n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutRTSFrame \n");
 	return;
 }
 
@@ -778,18 +777,20 @@ VOID	RTUSBBulkOutMLMEPacket(
 	PTX_CONTEXT		pMLMEContext;
 	PURB			pUrb;
 	int 			ret = 0;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
 	pMLMEContext = &pAd->MLMEContext[Index];
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	if (pAd->BulkOutPending[0] == TRUE)
 	{
-		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 		return;
 	}
 	pAd->BulkOutPending[0] = TRUE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->RTUSBBulkOutMLMEPacket\n");
 
 	// Increase Total transmit byte counter
 	pAd->RalinkCounters.TransmittedByteCount +=  pMLMEContext->BulkOutSize;
@@ -797,12 +798,11 @@ VOID	RTUSBBulkOutMLMEPacket(
 	// Clear MLME bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
+#if 0
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n",
 			pAd->PrioRingFirstIndex,
 			pAd->PrioRingTxCnt, pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutMLMEPacket\n");
-
+#endif
 
 	// Init Tx context descriptor
 	RTUSBInitTxDesc(pAd, pMLMEContext, 0, RTUSBBulkOutMLMEPacketComplete);
@@ -815,8 +815,11 @@ VOID	RTUSBBulkOutMLMEPacket(
 		DBGPRINT(RT_DEBUG_ERROR,"Submit MLME URB failed %d\n", ret);
 		return;
 	}
+	else {
+		atomic_inc(&pAd->PendingTx);
+	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacket \n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutMLMEPacket \n");
 	return;
 }
 
@@ -839,18 +842,18 @@ VOID	RTUSBBulkOutPsPoll(
 	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
 	PURB			pUrb;
 	int 			ret = 0;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
-	NdisAcquireSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisAcquireSpinLock(&pAd->BulkOutLock[0]);
 	if (pAd->BulkOutPending[0] == TRUE)
 	{
-		NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 		return;
 	}
 	pAd->BulkOutPending[0] = TRUE;
-	NdisReleaseSpinLock(&pAd->BulkOutLock[0], IrqFlags);
+	NdisReleaseSpinLock(&pAd->BulkOutLock[0]);
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutPsPoll \n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->RTUSBBulkOutPsPoll \n");
 
 	// Clear PS-Poll bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);
@@ -866,8 +869,11 @@ VOID	RTUSBBulkOutPsPoll(
 		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
 		return;
 	}
+	else {
+		atomic_inc(&pAd->PendingTx);
+	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutPsPoll \n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBBulkOutPsPoll \n");
 	return;
 }
 
@@ -898,31 +904,39 @@ VOID	RTUSBBulkReceive(
 	PURB		pUrb;
 	int 		ret = 0;
 
+	DBGPRINT(RT_DEBUG_TRACE,"RTUSBBulkReceive:: pAd->NextRxBulkInIndex = %d\n",
+			pAd->NextRxBulkInIndex);
+
 	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))||
 		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))||
 		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS)))
 	{
+		DBGPRINT(RT_DEBUG_INFO,"RTUSBBulkReceive:: can't start\n");
 		return;
 	}
 
-	DBGPRINT(RT_DEBUG_INFO,"RTUSBBulkReceive:: pAd->NextRxBulkInIndex = %d\n",pAd->NextRxBulkInIndex);
-
 	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
-	pRxContext->InUse = TRUE;
-	pAd->NextRxBulkInIndex = (pAd->NextRxBulkInIndex + 1) % RX_RING_SIZE;
-
-	atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCELABLE);
-	atomic_inc(&pAd->PendingRx);
+	if (pRxContext->InUse == FALSE) {
 
-	// Init Rx context descriptor
-	memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
-	RTUSBInitRxDesc(pAd, pRxContext);
-
-	pUrb = pRxContext->pUrb;
-	if((ret = rtusb_submit_urb(pUrb))!=0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,"Submit Rx URB failed %d\n", ret);
-		return;
+		// Init Rx context descriptor
+		memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
+		RTUSBInitRxDesc(pAd, pRxContext);
+
+		pUrb = pRxContext->pUrb;
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCELABLE);	// s/w timing
+		if((ret = rtusb_submit_urb(pUrb)) == 0) {
+			pRxContext->InUse = TRUE;
+			atomic_inc(&pAd->PendingRx);
+			pAd->NextRxBulkInIndex = (pAd->NextRxBulkInIndex+1) % RX_RING_SIZE;
+		}
+		else {	// -EPIPE -> disconnected
+			atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
+		}
+		DBGPRINT(RT_DEBUG_TRACE,"<-- %s: Submit Rx URB ret=%d\n",
+				__FUNCTION__, ret);
+	}
+	else {
+		DBGPRINT(RT_DEBUG_TRACE,"<-- %s (Rx Ring full)\n", __FUNCTION__);
 	}
 
 	return;
@@ -970,7 +984,7 @@ VOID	RTUSBKickBulkOut(
 	IN	PRTMP_ADAPTER pAd)
 {
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBKickBulkOut\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->RTUSBKickBulkOut\n");
 
 
 	if (!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
@@ -1081,7 +1095,7 @@ VOID	RTUSBKickBulkOut(
 		}
 	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBKickBulkOut\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBKickBulkOut\n");
 }
 
 /*
@@ -1102,7 +1116,7 @@ VOID	RTUSBCleanUpDataBulkOutQueue(
 {
 	UCHAR			Idx;
 	PTX_CONTEXT 	pTxContext;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
 	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpDataBulkOutQueue\n");
 
@@ -1116,9 +1130,9 @@ VOID	RTUSBCleanUpDataBulkOutQueue(
 			pTxContext->bWaitingBulkOut		= FALSE;
 			pAd->NextBulkOutIndex[Idx] = (pAd->NextBulkOutIndex[Idx] + 1) % TX_RING_SIZE;
 		}
-		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
 		pAd->BulkOutPending[Idx] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpDataBulkOutQueue\n");
@@ -1140,11 +1154,11 @@ VOID	RTUSBCleanUpDataBulkOutQueue(
 VOID	RTUSBCleanUpMLMEBulkOutQueue(
 	IN	PRTMP_ADAPTER	pAd)
 {
-	unsigned long			IrqFlags;
+	unsigned long	flags;	// For "Ndis" spin lock
 
-	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEBulkOutQueue\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->%s\n", __FUNCTION__);
 
-	NdisAcquireSpinLock(&pAd->MLMEQLock, IrqFlags);
+	NdisAcquireSpinLock(&pAd->MLMEQLock);
 	while (pAd->PrioRingTxCnt > 0)
 	{
 		pAd->MLMEContext[pAd->PrioRingFirstIndex].InUse = FALSE;
@@ -1157,9 +1171,9 @@ VOID	RTUSBCleanUpMLMEBulkOutQueue(
 
 		pAd->PrioRingTxCnt--;
 	}
-	NdisReleaseSpinLock(&pAd->MLMEQLock, IrqFlags);
+	NdisReleaseSpinLock(&pAd->MLMEQLock);
 
-	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEBulkOutQueue\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---%s\n", __FUNCTION__);
 }
 
 /*
@@ -1172,6 +1186,7 @@ VOID	RTUSBCleanUpMLMEBulkOutQueue(
 	Return Value:
 
 	Note:
+		Must be called in process context.
 
 	========================================================================
 */
@@ -1179,9 +1194,12 @@ VOID	RTUSBCancelPendingBulkInIRP(
 	IN	PRTMP_ADAPTER	pAd)
 {
 	PRX_CONTEXT	pRxContext;
-	UINT		i;
+	//UINT		i;
+	int			i = pAd->CurRxBulkInIndex;
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE,"--->RTUSBCancelPendingBulkInIRP\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--> %s: %d PendingRx left\n",
+			__FUNCTION__, atomic_read(&pAd->PendingRx));
+#if 0
 	for ( i = 0; i < RX_RING_SIZE; i++)
 	{
 		pRxContext = &(pAd->RxContext[i]);
@@ -1189,9 +1207,28 @@ VOID	RTUSBCancelPendingBulkInIRP(
 		{
 			RTUSB_UNLINK_URB(pRxContext->pUrb);
 		}
-		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_START);
+		pRxContext->InUse = FALSE;
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
 	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE,"<---RTUSBCancelPendingBulkInIRP\n");
+#else
+	// Cancel till we've caught up with newly issued recieves - bb
+	do {
+		pRxContext = &pAd->RxContext[i];
+		if(atomic_read(&pRxContext->IrpLock) == IRPLOCK_CANCELABLE)
+		{
+			RTUSB_UNLINK_URB(pRxContext->pUrb);
+		}
+		if (++i >= RX_RING_SIZE) i = 0;
+	} while (i != pAd->NextRxBulkInIndex);
+#endif
+
+	// maybe wait for cancellations to finish.
+	for (i = 0; atomic_read(&pAd->PendingRx) > 0 && i < 25; i++) {
+		msleep(UNLINK_TIMEOUT_MS);
+	}
+	pAd->CurRxBulkInIndex = pAd->NextRxBulkInIndex = 0;
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: %d PendingRx left\n",
+			__FUNCTION__, atomic_read(&pAd->PendingRx));
 }
 
 /*
@@ -1204,6 +1241,7 @@ VOID	RTUSBCancelPendingBulkInIRP(
 	Return Value:
 
 	Note:
+		Must be called in process context.
 
 	========================================================================
 */
@@ -1217,8 +1255,10 @@ VOID	RTUSBCancelPendingBulkOutIRP(
 	PTX_CONTEXT		pPsPollContext;
 	PTX_CONTEXT		pRTSContext;
 	UINT			i, Idx;
-	unsigned long			IrqFlags;
+	unsigned long			flags;
 
+	DBGPRINT(RT_DEBUG_TRACE, "--> %s: %d PendingTx left\n",
+			__FUNCTION__, atomic_read(&pAd->PendingTx));
 	for (Idx = 0; Idx < 4; Idx++)
 	{
 		for (i = 0; i < TX_RING_SIZE; i++)
@@ -1293,10 +1333,17 @@ VOID	RTUSBCancelPendingBulkOutIRP(
 
 	for (Idx = 0; Idx < 4; Idx++)
 	{
-		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
 		pAd->BulkOutPending[Idx] = FALSE;
-		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx], IrqFlags);
+		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
+	}
+
+	// maybe wait for cancellations to finish.
+	for (i = 0; atomic_read(&pAd->PendingTx) > 0 && i < 25; i++) {
+		msleep(UNLINK_TIMEOUT_MS);
 	}
+	DBGPRINT(RT_DEBUG_TRACE, "<-- %s: %d PendingTx left\n",
+			__FUNCTION__, atomic_read(&pAd->PendingTx));
 }
 
 /*
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_data.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_data.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_data.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_data.c	2008-05-09 06:24:59.000000000 +0200
@@ -78,12 +78,7 @@ VOID REPORT_ETHERNET_FRAME_TO_LLC(
 {
 	struct sk_buff	*pSkb;
 
-#ifdef RTMP_EMBEDDED
-	if ((pSkb = __dev_alloc_skb(DataSize + LENGTH_802_3 + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
-#else
-	if ((pSkb = dev_alloc_skb(DataSize + LENGTH_802_3 + 2)) != NULL)
-#endif
-
+	if ((pSkb = __dev_alloc_skb(DataSize + LENGTH_802_3 + 2, MEM_ALLOC_FLAG)) != NULL)
 	{
 		pSkb->dev = net_dev;
 		skb_reserve(pSkb, 2);	// 16 byte align the IP header
@@ -98,6 +93,8 @@ VOID REPORT_ETHERNET_FRAME_TO_LLC(
 
 		pAd->Counters8023.GoodReceives++;
 	}
+	//DBGPRINT(RT_DEBUG_TRACE, "<-- %s: pSkb %s\n", __FUNCTION__,
+			//pSkb? "found": "n/a");
 }
 
 // Enqueue this frame to MLME engine
@@ -159,7 +156,7 @@ NDIS_STATUS	RTMPSendPacket(
 	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
 	struct sk_buff_head	*pTxQueue;
 	UCHAR			PsMode;
-	unsigned long IrqFlags;
+	unsigned long flags;
 
 	DBGPRINT(RT_DEBUG_INFO, "====> RTMPSendPacket\n");
 
@@ -177,9 +174,9 @@ NDIS_STATUS	RTMPSendPacket(
 	if (pSkb && pAd->PortCfg.BssType == BSS_MONITOR &&
 		   pAd->bAcceptRFMONTx == TRUE)
 	{
-		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE], IrqFlags);
+		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE]);
 		skb_queue_tail(&pAd->SendTxWaitQueue[QID_AC_BE], pSkb);
-		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE], IrqFlags);
+		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QID_AC_BE]);
 		return (NDIS_STATUS_SUCCESS);
 	}
 
@@ -290,7 +287,7 @@ NDIS_STATUS	RTMPSendPacket(
 	RTMP_SET_PACKET_UP(pSkb, UserPriority);
 
 	// Make sure SendTxWait queue resource won't be used by other threads
-	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QueIdx]);
 
 	pTxQueue = &pAd->SendTxWaitQueue[QueIdx];
 
@@ -327,7 +324,7 @@ NDIS_STATUS	RTMPSendPacket(
 		}
 	}
 
-	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx]);
 
 	return (Status);
 }
@@ -501,10 +498,12 @@ NDIS_STATUS RTUSBHardTransmit(
 
 		if (pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE)
 		{
-			DBGPRINT(RT_DEBUG_TRACE,"RTUSBHardTransmit: TX RING full\n");
+			//Modified by Thomas
+			DBGPRINT_ERR("RTUSBHardTransmit: TX RING full\n");
 			//pAd->RalinkCounters.TxRingErrCount++;
 
-			return (NDIS_STATUS_RESOURCES);
+			//return (NDIS_STATUS_RESOURCES);
+			return (NDIS_STATUS_RINGFULL);
 		}
 
 		pTxContext->InUse	= TRUE;
@@ -554,8 +553,7 @@ NDIS_STATUS RTUSBHardTransmit(
 		pTxContext->bWaitingBulkOut = TRUE;
 		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
 
-		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
-		atomic_inc(&pAd->TxCount);
+		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to PendingTx
 		RELEASE_NDIS_PACKET(pAd, pSkb);
 
 		return (NDIS_STATUS_SUCCESS);
@@ -575,12 +573,12 @@ NDIS_STATUS RTUSBHardTransmit(
 	// Check for virtual address allocation, it might fail !!!
 	if (pSrcBufVA == NULL)
 	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, "pSrcBufVA == NULL\n");
+		DBGPRINT(RT_DEBUG_TRACE, "pSrcBufVA == NULL\n");
 		return(NDIS_STATUS_RESOURCES);
 	}
 	if (SrcBufLen < 14)
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "RTUSBHardTransmit --> Skb buffer error !!!\n");
+		DBGPRINT(RT_DEBUG_ERROR, "RTUSBHardTransmit --> Skb buffer error !!!\n");
 		return (NDIS_STATUS_FAILURE);
 	}
 
@@ -634,7 +632,7 @@ NDIS_STATUS RTUSBHardTransmit(
 		((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->PortCfg.MicErrCnt >= 2)) &&
 		(bEAPOLFrame == FALSE))
 	{
-		DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBHardTransmit --> Drop packet before port secured !!!\n");
+		DBGPRINT(RT_DEBUG_INFO, "RTUSBHardTransmit --> Drop packet before port secured !!!\n");
 		return (NDIS_STATUS_FAILURE);
 	}
 
@@ -850,9 +848,11 @@ NDIS_STATUS RTUSBHardTransmit(
 		if ((pTxContext->bWaitingBulkOut == TRUE) || (pTxContext->InUse == TRUE) ||
 			(pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE))
 		{
-			DBGPRINT(RT_DEBUG_TRACE,"RTUSBHardTransmit: TX RING full\n");
+			//Modified by Thomas
+			DBGPRINT_ERR("RTUSBHardTransmit: TX RING full\n");
 			//pAd->RalinkCounters.TxRingErrCount++;
-			return (NDIS_STATUS_RESOURCES);
+			//return (NDIS_STATUS_RESOURCES);
+			return (NDIS_STATUS_RINGFULL);
 		}
 		pTxContext->InUse	= TRUE;
 
@@ -1038,12 +1038,12 @@ NDIS_STATUS RTUSBHardTransmit(
 				INT i;
 
 				SrcBufLen = 8;		// Set length to MIC length
-				DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated TX MIC value =");
+				DBGPRINT(RT_DEBUG_INFO, "Calculated TX MIC value =");
 				for (i = 0; i < 8; i++)
 				{
 					DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAd->PrivateInfo.Tx.MIC[i]);
 				}
-					DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
+				DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
 
 				if (FreeMpduSize >= SrcBufLen)
 				{
@@ -1169,8 +1169,7 @@ NDIS_STATUS RTUSBHardTransmit(
 			pTxContext->LastOne = FALSE;
 		}
 
-		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
-		atomic_inc(&pAd->TxCount);
+		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to PendingTx
 
 	}	while (NumberRequired > 0);
 
@@ -1186,15 +1185,15 @@ NDIS_STATUS RTUSBHardTransmit(
 		MLME_DISASSOC_REQ_STRUCT	DisassocReq;
 
 		// disassoc from current AP first
-              printk("<0>MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
-		DBGPRINT(RT_DEBUG_TRACE, "MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+		DBGPRINT(RT_DEBUG_INFO, "- (%s) disassociate with current AP after"
+				" sending second continuous EAPOL frame\n",
+				__FUNCTION__);
 		DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
 		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
 					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
 		pAd->PortCfg.bBlockAssoc = TRUE;
-		printk("<0>bBlockAssoc = %d\n", pAd->PortCfg.bBlockAssoc);
 	}
 
 
@@ -1244,7 +1243,7 @@ VOID	RTUSBMlmeHardTransmit(
 	UCHAR			QueIdx;
 	UCHAR			MlmeRate;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
+	DBGPRINT(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
 
 	pAd->PrioRingTxCnt++;
 
@@ -1285,9 +1284,8 @@ VOID	RTUSBMlmeHardTransmit(
 	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
 		MlmeRate = RATE_6;
 
-	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeRate %d	Channel %d\n",MlmeRate, pAd->LatchRfRegs.Channel );
-
-
+	DBGPRINT(RT_DEBUG_INFO, "- %s: Rate %d Channel %d\n",
+			__FUNCTION__, MlmeRate, pAd->LatchRfRegs.Channel );
 
     // Before radar detection done, mgmt frame can not be sent but probe req
 	// Because we need to use probe req to trigger driver to send probe req in passive scan
@@ -1450,7 +1448,7 @@ NDIS_STATUS	RTUSBFreeDescriptorRequest(
 			break;
 
 		default:
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "--->RTUSBFreeDescriptorRequest() -----!! \n");
+			DBGPRINT(RT_DEBUG_ERROR, "--->RTUSBFreeDescriptorRequest() -----!! \n");
 
 			break;
 	}
@@ -1475,18 +1473,18 @@ VOID	RTUSBRejectPendingPackets(
 	IN	PRTMP_ADAPTER	pAd)
 {
 	UCHAR			Index;
-	unsigned long IrqFlags;
+	unsigned long flags;
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
 
 	for (Index = 0; Index < 4; Index++)
 	{
-		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[Index]);
 		skb_queue_purge(&pAd->SendTxWaitQueue[Index]);
-		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[Index]);
 	}
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
+	DBGPRINT(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
 }
 
 /*
@@ -1704,18 +1702,18 @@ VOID	RTMPDeQueuePacket(
 	UCHAR			Count = 0;
 	struct sk_buff_head	*pQueue;
 	UCHAR			QueIdx;
-	unsigned long IrqFlags;
+	unsigned long flags;
 
-	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId]);
 	if (pAd->DeQueueRunning[BulkOutPipeId])
 	{
-		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId]);
 		return;
 	}
 	else
 	{
 		pAd->DeQueueRunning[BulkOutPipeId] = TRUE;
-		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId]);
 	}
 
 	QueIdx = BulkOutPipeId;
@@ -1724,7 +1722,7 @@ VOID	RTMPDeQueuePacket(
 		DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d TxRingTotalNumber= %d !!--\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId]);
 
 	// Make sure SendTxWait queue resource won't be used by other threads
-	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId]);
 
 	// Select Queue
 	pQueue = &pAd->SendTxWaitQueue[BulkOutPipeId];
@@ -1734,10 +1732,16 @@ VOID	RTMPDeQueuePacket(
 	{
 		// Reset is in progress, stop immediately
 		if ( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
 			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 		{
 			DBGPRINT(RT_DEBUG_ERROR,"--RTMPDeQueuePacket %d reset-in-progress !!--\n", BulkOutPipeId);
+			RTUSBFreeSkbBuffer(skb_dequeue(pQueue));
+			continue;
+		}
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 "RTUSBDeQueuePacket scanning. Flags = 0x%x\n",
+				 pAd->Flags);
 			break;
 		}
 
@@ -1754,12 +1758,12 @@ VOID	RTMPDeQueuePacket(
 			// Avaliable ring descriptors are enough for this frame
 			// Call hard transmit
 			// Nitro mode / Normal mode selection
-			NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+			NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId]);
 
 			Status = RTUSBHardTransmit(pAd, pSkb, FragmentRequired, QueIdx);
 
 			// Acquire the resource again, snice we may need to process it in this while-loop.
-			NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+			NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId]);
 
 			if (Status == NDIS_STATUS_FAILURE)
 			{
@@ -1793,11 +1797,11 @@ VOID	RTMPDeQueuePacket(
 	}
 
 	// Release TxSwQueue0 resources
-	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId],  IrqFlags);
+	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId]);
 
-	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId]);
 	pAd->DeQueueRunning[BulkOutPipeId] = FALSE;
-	NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+	NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId]);
 
 }
 
@@ -1806,6 +1810,8 @@ VOID	RTMPDeQueuePacket(
 	 Description:
 		This is the completion routine for the USB_RxPacket which submits
 		a URB to USBD for a transmission.
+	Note:
+		Called in process context.
 	========================================================================
 */
 VOID	RTUSBRxPacket(
@@ -1832,18 +1838,20 @@ VOID	RTUSBRxPacket(
 	wlan_ng_prism2_header	*ph;
 	int				i;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBRxPacket\n");
-
 	pRxContext = (PRX_CONTEXT)pUrb->context;
 	pAd = pRxContext->pAd;
 	net_dev = pAd->net_dev;
+	Status = pUrb->status;
 
-	if( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) )
-		return;
+	DBGPRINT(RT_DEBUG_TRACE, "--> RTUSBRxPacket len=%d, status=%d\n",
+			pRxContext->pUrb->actual_length, Status);
 
+	if(Status || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) ) {
+		DBGPRINT(RT_DEBUG_TRACE, "<-- RTUSBRxPacket disconnected\n");
+		return;
+	}
 	do
 	{
-		DBGPRINT_RAW(RT_DEBUG_INFO, "BulkIn actual length(%d)\n", pRxContext->pUrb->actual_length);
 		if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
 		{
 		pData = pRxContext->TransferBuffer;
@@ -1879,7 +1887,7 @@ VOID	RTUSBRxPacket(
 		if (pAd->PortCfg.BssType == BSS_MONITOR && Status == NDIS_STATUS_SUCCESS)
          	{
  	        	struct sk_buff  *skb;
- 	       		if ((skb = __dev_alloc_skb(2048, GFP_DMA|GFP_ATOMIC)) != NULL)
+ 	       		if ((skb = __dev_alloc_skb(2048, GFP_DMA|GFP_KERNEL)) != NULL)
  	        	{
 				if (pAd->bAcceptRFMONTx == TRUE) {
 					if (pAd->ForcePrismHeader != 1)
@@ -1891,7 +1899,7 @@ VOID	RTUSBRxPacket(
 					// setup the wlan-ng prismheader
 
 				if (skb_headroom(skb) < sizeof(wlan_ng_prism2_header))
-					pskb_expand_head(skb, sizeof(wlan_ng_prism2_header), 0, GFP_ATOMIC);
+					pskb_expand_head(skb, sizeof(wlan_ng_prism2_header), 0, GFP_KERNEL);
 
 				ph = (wlan_ng_prism2_header *)
 					skb_push(skb, sizeof(wlan_ng_prism2_header));
@@ -1949,14 +1957,7 @@ VOID	RTUSBRxPacket(
         			skb->ip_summed = CHECKSUM_NONE;
 	               		netif_rx(skb);
        			}
-
-			if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-				RTUSBBulkReceive(pAd);
-         			continue;
+         	continue;
 		}
 
 		if (Status == NDIS_STATUS_SUCCESS)
@@ -1989,7 +1990,7 @@ VOID	RTUSBRxPacket(
 					// Found retry frame in tuple cache, Discard this frame / fragment
 					// Increase 802.11 counters
 					INC_COUNTER64(pAd->WlanCounters.FrameDuplicateCount);
-					DBGPRINT_RAW(RT_DEBUG_INFO, "duplicate frame %d\n", pHeader->Sequence);
+					DBGPRINT(RT_DEBUG_INFO, "duplicate frame %d\n", pHeader->Sequence);
 					Status = NDIS_STATUS_FAILURE;
 				}
 				else
@@ -2028,6 +2029,7 @@ VOID	RTUSBRxPacket(
 				//
 				if (pHeader->FC.Type == BTYPE_DATA)
 				{
+					DBGPRINT(RT_DEBUG_INFO, "-  %s: data frame\n", __FUNCTION__);
 					// before LINK UP, all DATA frames are rejected
 					if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
 					{
@@ -2069,9 +2071,11 @@ VOID	RTUSBRxPacket(
 					else
 						EAPOLFrame = FALSE;
 
-					if ((pRxD->MyBss == 0) && (EAPOLFrame != TRUE))
+					if ((pRxD->MyBss == 0) && (EAPOLFrame != TRUE)) {
+						DBGPRINT(RT_DEBUG_INFO, "-  %s: !MyBss || !EAPOL\n",
+								__FUNCTION__);
 						break; // give up this frame
-
+					}
 					// Drop NULL (+CF-POLL) (+CF-ACK) data frame
 					if ((pHeader->FC.SubType & 0x04) == 0x04)
 					{
@@ -2091,10 +2095,12 @@ VOID	RTUSBRxPacket(
 					{
 						if (pRxD->CipherAlg == CIPHER_NONE) // unsupported cipher suite
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: nonsup cipher\n", __FUNCTION__);
 							break; // give up this frame
 						}
 						else if (pAd->SharedKey[pRxD->KeyIndex].KeyLen == 0)
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: keylen=0\n", __FUNCTION__);
 							break; // give up this frame since the keylen is invalid.
 						}
 					}
@@ -2107,6 +2113,7 @@ VOID	RTUSBRxPacket(
 							(pAd->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
 							(!NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H)))
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: clear text\n", __FUNCTION__);
 							break; // give up this frame
 						}
 					}
@@ -2123,12 +2130,14 @@ VOID	RTUSBRxPacket(
 						// Drop Mcast/Bcast frame with fragment bit on
 						if (pHeader->FC.MoreFrag)
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: mcast w/more\n", __FUNCTION__);
 							break; // give up this frame
 						}
 
 						// Filter out Bcast frame which AP relayed for us
 						if (pHeader->FC.FrDs && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress))
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: relay mcast\n", __FUNCTION__);
 							break; // give up this frame
 						}
 
@@ -2158,7 +2167,7 @@ VOID	RTUSBRxPacket(
 						if ( pAd->PortCfg.IEEE8021X == TRUE
 						    && (EAP_CODE_SUCCESS == RTMPCheckWPAframeForEapCode(pAd, pData, DataSize, LENGTH_802_1_H)))
 						{
-								DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
+								DBGPRINT(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
 								pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 
 								success = 1;
@@ -2167,7 +2176,7 @@ VOID	RTUSBRxPacket(
 						// build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
 						CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
                     				REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
-						DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPoL DATA to LLC (len=%d) !!!\n", DataSize);
+						DBGPRINT(RT_DEBUG_TRACE, "!!! report EAPoL DATA to LLC (len=%d) !!!\n", DataSize);
 
 						if(success)
 						{
@@ -2179,7 +2188,7 @@ VOID	RTUSBRxPacket(
 								idx = pAd->PortCfg.DefaultKeyId;
 								for (idx=0; idx < 4; idx++)
 								{
-									DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
+									DBGPRINT(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
 
 									if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
 									{
@@ -2211,7 +2220,7 @@ VOID	RTUSBRxPacket(
 
 						break;
 					}
-				    }
+				    } /* End (pAd->PortCfg.WPA_Supplicant == TRUE) */
 			else
 			{
 //#else
@@ -2221,7 +2230,7 @@ VOID	RTUSBRxPacket(
 						{
 							DataSize += LENGTH_802_11;
 							REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
-							DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
+							DBGPRINT(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
 							break;	// end of processing this frame
 						}
 //#endif
@@ -2229,6 +2238,7 @@ VOID	RTUSBRxPacket(
 						if (pHeader->Frag == 0) 	// First or Only fragment
 						{
 							PUCHAR pRemovedLLCSNAP;
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: 1st/only frag\n", __FUNCTION__);
 
 							CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
 							pAd->FragFrame.Flags &= 0xFFFFFFFE;
@@ -2260,14 +2270,14 @@ VOID	RTUSBRxPacket(
 
 									pData2 = pData + Payload1Size + LENGTH_802_3;
 									REPORT_ETHERNET_FRAME_TO_LLC(pAd, pData + Payload1Size, pData2, Payload2Size, pAd->net_dev);
-									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report segregated MSDU2 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+									DBGPRINT(RT_DEBUG_INFO, "!!! report segregated MSDU2 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
 															LENGTH_802_3+Payload2Size, *(pData2 -2), *(pData2 - 1),
 															*pData2, *(pData2+1),*(pData2+2),*(pData2+3),*(pData2+4),*(pData2+5),*(pData2+6),*(pData2+7));
 								}
 								else
 								{
 									REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, pAd->net_dev);
-									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report DATA (no frag) to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+									DBGPRINT(RT_DEBUG_INFO, "!!! report DATA (no frag) to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
 															DataSize, Header802_3[12], Header802_3[13],
 															*pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));
 								}
@@ -2285,6 +2295,7 @@ VOID	RTUSBRxPacket(
 						// Middle & End of fragment burst fragments
 						else
 						{
+							DBGPRINT(RT_DEBUG_INFO, "-  %s: mid/end frag\n", __FUNCTION__);
 							// No LLC-SNAP header in except the first fragment frame
 							if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
 								(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
@@ -2310,6 +2321,7 @@ VOID	RTUSBRxPacket(
 							// Last fragment
 							if (pHeader->FC.MoreFrag == FALSE)
 							{
+								DBGPRINT(RT_DEBUG_INFO, "-  %s: end frag\n", __FUNCTION__);
 								// For TKIP frame, calculate the MIC value
 								if (pRxD->CipherAlg == CIPHER_TKIP)
 								{
@@ -2345,7 +2357,7 @@ VOID	RTUSBRxPacket(
 											pWpaKey->RxMic,
 											DataSize) == FALSE)
 									{
-										DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");
+										DBGPRINT(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");
 										RTMPReportMicError(pAd, pWpaKey);
 										break;	// give up this frame
 									}
@@ -2374,8 +2386,10 @@ VOID	RTUSBRxPacket(
 				//
 				// CASE IV. receive a frame of invalid type
 				//
-				else
+				else {
+					DBGPRINT(RT_DEBUG_INFO, "-  %s: unkn frame\n", __FUNCTION__);
 					break; // give up this frame
+				}
 			} while (FALSE); // ************* exit point *********
 
 		}//if (Status == NDIS_STATUS_SUCCESS)
@@ -2383,6 +2397,7 @@ VOID	RTUSBRxPacket(
 		else if (Status == NDIS_STATUS_RESET)
 		{
 			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
+			DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBRxPacket RESET_BULK\n");
 			return;
 		}
 
@@ -2392,23 +2407,55 @@ VOID	RTUSBRxPacket(
 #endif
 	  }//if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
 
+	} while (0);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBRxPacket\n");
+}
 
+/*
+	========================================================================
+
+	Routine Description:
+		Called only from MLMEThread.
+		Service each packet that is done and not yet serviced.
+
+	Arguments:
+
+	Return Value:
+
+	Note:
+		Called in process context.
+
+	========================================================================
+*/
+VOID	RTUSBDequeueRxPackets(
+	IN	PRTMP_ADAPTER	pAd)
+{
+	int			i = pAd->CurRxBulkInIndex;
+
+	do {
+		PRX_CONTEXT pRxContext = &pAd->RxContext[i];
+
+		if (atomic_read(&pRxContext->IrpLock) != IRPLOCK_COMPLETED ||
+			pRxContext->InUse == FALSE) {
+			break;
+		}
+		RTUSBRxPacket((unsigned long)pRxContext->pUrb);
 		pRxContext->InUse = FALSE;
 
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
 			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
 			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-		{
-			   pAd->rx_bk.data = (unsigned long)pAd;
-			   tasklet_schedule(&pAd->rx_bk);
+			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
+				RTUSBBulkReceive(pAd);
 		}
+		if (++i >= RX_RING_SIZE) i = 0;
+	} while (1);
 
-	} while (0);
+	pAd->CurRxBulkInIndex = i;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBRxPacket Complete\n");
-}
+} /* End RTUSBDequeueRxPackets () */
 
 /*
 	========================================================================
@@ -2427,10 +2474,10 @@ VOID	RTUSBDequeueMLMEPacket(
 	IN	PRTMP_ADAPTER	pAd)
 {
 	PMGMT_STRUC		pMgmt;
-	unsigned long IrqFlags;
+	unsigned long flags;
 
 	DBGPRINT(RT_DEBUG_INFO, "RTUSBDequeueMLMEPacket\n");
-	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock);
 	while ((pAd->PopMgmtIndex != pAd->PushMgmtIndex) || (atomic_read(&pAd->MgmtQueueSize) > 0))
 	{
 		pMgmt = &pAd->MgmtRing[pAd->PopMgmtIndex];
@@ -2439,7 +2486,7 @@ VOID	RTUSBDequeueMLMEPacket(
 		{
 			atomic_dec(&pAd->MgmtQueueSize);
 			pAd->PopMgmtIndex = (pAd->PopMgmtIndex + 1) % MGMT_RING_SIZE;
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock);
 
 			RTUSBMlmeHardTransmit(pAd, pMgmt);
 
@@ -2447,7 +2494,7 @@ VOID	RTUSBDequeueMLMEPacket(
 			pMgmt->pBuffer = NULL;
 			pMgmt->Valid = FALSE;
 
-			NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+			NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock);
 		}
 		else
 		{
@@ -2458,7 +2505,7 @@ VOID	RTUSBDequeueMLMEPacket(
 			break;
 		}
 	}
-	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock);
 }
 
 /*
@@ -2478,11 +2525,11 @@ VOID	RTUSBCleanUpMLMEWaitQueue(
 	IN	PRTMP_ADAPTER	pAd)
 {
 	PMGMT_STRUC		pMgmt;
-	unsigned long IrqFlags;
+	unsigned long flags;
 
 	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEWaitQueue\n");
 
-	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock);
 	while (pAd->PopMgmtIndex != pAd->PushMgmtIndex)
 	{
 		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PopMgmtIndex];
@@ -2497,7 +2544,7 @@ VOID	RTUSBCleanUpMLMEWaitQueue(
 			pAd->PopMgmtIndex = 0;
 		}
 	}
-	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock);
 
 	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEWaitQueue\n");
 }
@@ -2607,24 +2654,24 @@ VOID	MiniportMMRequest(
 	IN	PVOID			pBuffer,
 	IN	ULONG			Length)
 {
-	unsigned long IrqFlags;
+	unsigned long flags;
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "---> MiniportMMRequest\n");
+	DBGPRINT(RT_DEBUG_INFO, "---> MiniportMMRequest\n");
 
 	if (pBuffer)
 	{
 		PMGMT_STRUC	pMgmt;
 
 		// Check management ring free avaliability
-		NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+		NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock);
 		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PushMgmtIndex];
 		// This management cell has been occupied
 		if (pMgmt->Valid == TRUE)
 		{
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock);
 			MlmeFreeMemory(pAd, pBuffer);
 			pAd->RalinkCounters.MgmtRingFullCount++;
-			DBGPRINT_RAW(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
+			DBGPRINT(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
 		}
 		// Insert this request into software managemnet ring
 		else
@@ -2638,7 +2685,7 @@ VOID	MiniportMMRequest(
 			{
 				pAd->PushMgmtIndex = 0;
 			}
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock);
 		}
 	}
 	else
@@ -2655,7 +2702,7 @@ VOID	MiniportMMRequest(
 		RTUSBKickBulkOut(pAd);
 	}
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<--- MiniportMMRequest\n");
+	DBGPRINT(RT_DEBUG_INFO, "<--- MiniportMMRequest\n");
 }
 
 /*
@@ -2901,7 +2948,7 @@ NDIS_STATUS	RTMPCheckRxDescriptor(
 	// Phy errors & CRC errors
 	if (/*(pRxD->PhyErr) ||*/ (pRxD->Crc))
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->Crc error\n")
+		DBGPRINT(RT_DEBUG_ERROR, "pRxD->Crc error\n")
 		return (NDIS_STATUS_FAILURE);
 	}
 
@@ -2912,7 +2959,7 @@ NDIS_STATUS	RTMPCheckRxDescriptor(
 	// Paul 04-03 for OFDM Rx length issue
 	if (pRxD->DataByteCnt > MAX_AGGREGATION_SIZE)
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
+		DBGPRINT(RT_DEBUG_ERROR, "received packet too long\n");
 		return (NDIS_STATUS_FAILURE);
 	}
 
@@ -2926,7 +2973,7 @@ NDIS_STATUS	RTMPCheckRxDescriptor(
 	{
 		UINT i;
 		PUCHAR ptr = (PUCHAR)pHeader;
-		DBGPRINT_RAW(RT_DEBUG_TRACE,"ERROR: CRC ok but CipherErr %d (len = %d, Mcast=%d, Cipher=%s, KeyId=%d)\n",
+		DBGPRINT(RT_DEBUG_TRACE,"ERROR: CRC ok but CipherErr %d (len = %d, Mcast=%d, Cipher=%s, KeyId=%d)\n",
 			pRxD->CipherErr,
 			pRxD->DataByteCnt,
 			pRxD->Mcast | pRxD->Bcast,
@@ -2935,7 +2982,7 @@ NDIS_STATUS	RTMPCheckRxDescriptor(
 #if 1
 		for (i=0;i<64; i+=16)
 		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x - %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+			DBGPRINT(RT_DEBUG_TRACE,"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x - %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
 				*ptr,*(ptr+1),*(ptr+2),*(ptr+3),*(ptr+4),*(ptr+5),*(ptr+6),*(ptr+7),
 				*(ptr+8),*(ptr+9),*(ptr+10),*(ptr+11),*(ptr+12),*(ptr+13),*(ptr+14),*(ptr+15));
 			ptr += 16;
@@ -2950,7 +2997,7 @@ NDIS_STATUS	RTMPCheckRxDescriptor(
 		{
 			pWpaKey = &pAd->SharedKey[pRxD->KeyIndex];
 			RTMPReportMicError(pAd, pWpaKey);
-			DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error\n");
+			DBGPRINT(RT_DEBUG_ERROR,"Rx MIC Value error\n");
 		}
 
 		if ((pRxD->CipherAlg == CIPHER_AES) &&
@@ -3156,7 +3203,8 @@ VOID	RTMPSendNullFrame(
 		RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY,
 			IFS_BACKOFF, TxRate, sizeof(HEADER_802_11), QueIdx, PID_MGMT_FRAME, FALSE);
 
-		DBGPRINT(RT_DEBUG_ERROR, "SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[TxRate]);
+		DBGPRINT(RT_DEBUG_INFO, "- (%s) send NULL Frame @%d Mbps...\n",
+				__FUNCTION__, RateIdToMbps[TxRate]);
 	}
 
 	// Build our URB for USBD
@@ -3296,8 +3344,7 @@ VOID	RTMPSendRTSCTSFrame(
 		pTxContext->bWaitingBulkOut = TRUE;
 
 
-        pAd->TxRingTotalNumber[QueIdx]++;  // sync. to TxCount
-		atomic_inc(&pAd->TxCount);
+        pAd->TxRingTotalNumber[QueIdx]++;  // sync. to PendingTx
 		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx);
 
 	}
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_io.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_io.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/rtusb_io.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/rtusb_io.c	2008-05-09 11:03:14.000000000 +0200
@@ -302,16 +302,16 @@ NTSTATUS	RTUSBReadBBPRegister(
 		//
 		*pValue = pAd->BbpWriteLatch[Id];
 
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		DBGPRINT(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
 		kfree(PhyCsr3);
 		return STATUS_UNSUCCESSFUL;
 	}
 
 	// Prepare for write material
-	PhyCsr3->word         = 0;
-	PhyCsr3->field.fRead      = 1;
-	PhyCsr3->field.Busy     = 1;
-	PhyCsr3->field.RegNum     = Id;
+	PhyCsr3->word 				= 0;
+	PhyCsr3->field.fRead			= 1;
+	PhyCsr3->field.Busy			= 1;
+	PhyCsr3->field.RegNum 		= Id;
 	RTUSBWriteMACRegister(pAd, PHY_CSR3, PhyCsr3->word);
 
 	i = 0;
@@ -335,7 +335,7 @@ NTSTATUS	RTUSBReadBBPRegister(
 		//
 		*pValue = pAd->BbpWriteLatch[Id];
 
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		DBGPRINT(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
 		kfree(PhyCsr3);
 		return STATUS_UNSUCCESSFUL;
 	}
@@ -381,7 +381,7 @@ NTSTATUS	RTUSBWriteBBPRegister(
 
 	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		DBGPRINT(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
 		kfree(PhyCsr3);
 		return STATUS_UNSUCCESSFUL;
 	}
@@ -393,6 +393,7 @@ NTSTATUS	RTUSBWriteBBPRegister(
 	PhyCsr3->field.Busy     = 1;
 	PhyCsr3->field.RegNum     = Id;
 	RTUSBWriteMACRegister(pAd, PHY_CSR3, PhyCsr3->word);
+
 	pAd->BbpWriteLatch[Id] = Value;
 
 	kfree(PhyCsr3);
@@ -434,7 +435,7 @@ NTSTATUS	RTUSBWriteRFRegister(
 
 	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
 	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		DBGPRINT(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
 		kfree(PhyCsr4);
 		return STATUS_UNSUCCESSFUL;
 	}
@@ -618,7 +619,7 @@ NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
 {
 	PCmdQElmt	cmdqelmt = NULL;
     PCmdQElmt	Dcmdqelmt = NULL;
-	unsigned long       IrqFlags;
+	unsigned long       flags;
 
 	if (pAd->RTUSBCmdThr_pid < 0)
 		return (NDIS_STATUS_RESOURCES);
@@ -671,12 +672,12 @@ NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
 	else
 		cmdqelmt->SetOperation = FALSE;
 
-	NdisAcquireSpinLock(&pAd->CmdQLock,  IrqFlags);
+	NdisAcquireSpinLock(&pAd->CmdQLock);
 	EnqueueCmd((&pAd->CmdQ), cmdqelmt);
-	NdisReleaseSpinLock(&pAd->CmdQLock,  IrqFlags);
+	NdisReleaseSpinLock(&pAd->CmdQLock);
 
 #if 1
-	NdisAcquireSpinLock(&pAd->CmdQLock,  IrqFlags);
+	NdisAcquireSpinLock(&pAd->CmdQLock);
 	if( pAd->CmdQ.size > 2048 ){//Thomas add
 		RTUSBDequeueCmd(&pAd->CmdQ, &Dcmdqelmt);
 		if(Dcmdqelmt != NULL){
@@ -687,7 +688,7 @@ NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
 			Dcmdqelmt=NULL;
 		}
 	}
-	NdisReleaseSpinLock(&pAd->CmdQLock,  IrqFlags);
+	NdisReleaseSpinLock(&pAd->CmdQLock);
 #endif
 
 	RTUSBCMDUp(pAd);
@@ -721,11 +722,12 @@ VOID	RTUSBEnqueueInternalCmd(
 	IN	NDIS_OID		Oid)
 {
 	PCmdQElmt	cmdqelmt = NULL;
-	unsigned long       IrqFlags;
+	unsigned long       flags;
 
-	if (pAd->RTUSBCmdThr_pid < 0)
+	if (pAd->RTUSBCmdThr_pid < 0) {
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: no CmdThr\n", __FUNCTION__);
 		return;
-
+	}
 	switch (Oid)
 	{
 		case RT_OID_CHECK_GPIO:
@@ -790,12 +792,14 @@ VOID	RTUSBEnqueueInternalCmd(
 		cmdqelmt->InUse = TRUE;
 		cmdqelmt->command = Oid;
 
-		NdisAcquireSpinLock(&pAd->CmdQLock, IrqFlags);
+		NdisAcquireSpinLock(&pAd->CmdQLock);
 		EnqueueCmd((&pAd->CmdQ), cmdqelmt);
-		NdisReleaseSpinLock(&pAd->CmdQLock, IrqFlags);
+		NdisReleaseSpinLock(&pAd->CmdQLock);
 
 		RTUSBCMDUp(pAd);
+		DBGPRINT(RT_DEBUG_TRACE, "<-- %s: CmdThr up\n", __FUNCTION__);
 	}
+	else DBGPRINT(RT_DEBUG_TRACE, "<-- %s CMDThr in use\n", __FUNCTION__);
 }
 
 /*
@@ -898,31 +902,23 @@ INT	    RTUSB_VendorRequest(
 			DBGPRINT(RT_DEBUG_ERROR,"vendor request direction is failed\n");
 			ret = -1;
 		}
-
-        if (ret < 0)
-			DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d \n",ret);
-
-#if 0
-        // retry
-		if (ret < 0) {
-			int temp_i=0;
-			DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d, \n",ret);
-			ret = 0;
-			do
-			{
-				if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
-					ret=usb_control_msg(pAd->pUsb_Dev, usb_sndctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-				else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
-					ret=usb_control_msg(pAd->pUsb_Dev, usb_rcvctrlpipe( pAd->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-				temp_i++;
-			} while( (ret < 0) && (temp_i <= 1) );
-
-			if( ret >= 0)
-				return ret;
-
+    if (ret < 0) {
+			switch (ret) {
+			case -ECONNRESET:		// async unlink via call to usb_unlink_urb()
+			case -ENOENT:			// stopped by call to usb_kill_urb
+			case -ESHUTDOWN:		// hardware gone = -108
+			case -EPROTO:			// unplugged = -71
+				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
+				DBGPRINT(RT_DEBUG_ERROR,"=== %s: Non-recoverable err = %d\n",
+					__FUNCTION__, ret);
+
+				break;
+
+			default:
+				DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d \n",ret);
+				break;
+			}
 		}
-#endif
-
 	}
 	return ret;
 }
@@ -948,7 +944,7 @@ NTSTATUS	RTUSB_ResetDevice(
 {
 	NTSTATUS		Status = TRUE;
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->USB_ResetDevice\n");
+	DBGPRINT(RT_DEBUG_TRACE, "--->USB_ResetDevice\n");
 	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
 	return Status;
 }
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/sanity.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/sanity.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/sanity.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/sanity.c	2008-05-09 06:24:59.000000000 +0200
@@ -1366,12 +1366,13 @@ BOOLEAN BackDoorProbeRspSanity(
                         {
                             //memcpy((pCfgDataBuf + cfgDataLen), (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
                             memcpy(CfgData, (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
-                            printk("%s\n", CfgData);
+                            KPRINT(KERN_INFO, "%s\n", CfgData);
                             return TRUE;
                         }
                         else
                         {
-                            printk("BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
+                            KPRINT(KERN_INFO,
+								"BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
                             return FALSE;
                         }
                     }
@@ -1382,11 +1383,12 @@ BOOLEAN BackDoorProbeRspSanity(
                         memcpy(CfgData, (eid_ptr->Octet + 4), (eid_ptr->Len - 4));
                         if (cfgDataLen > MAX_CFG_BUFFER_LEN)
                         {
-                            printk("BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
+                            KPRINT(KERN_INFO,
+								"BackDoorProbeRspSanity: cfgDataLen > MAX_CFG_BUFFER_LEN\n");
                             return FALSE;
                         }
                         else
-                            printk("%s", CfgData);
+                            KPRINT(KERN_INFO, "%s", CfgData);
                     }
                     break;
                 }
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/sync.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/sync.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/sync.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/sync.c	2008-05-09 09:24:15.000000000 +0200
@@ -490,7 +490,7 @@ VOID PeerBeaconAtScanAction(
 		CHAR CfgData[MAX_CFG_BUFFER_LEN+1] = {0};
 		if (BackDoorProbeRspSanity(pAd, Elem->Msg, Elem->MsgLen, CfgData))
 		{
-			printk("MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n", (int)strlen(CfgData), CfgData);
+			//DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueueForRecv: CfgData(len:%d):\n%s\n", (int)strlen(CfgData), CfgData);
 			pAd->PortCfg.bGetAPConfig = FALSE;
 		}
 	}
@@ -595,7 +595,7 @@ VOID PeerBeaconAtJoinAction(
 		//    a new JOIN-AUTH-ASSOC sequence.
 		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid))
         {
-            DBGPRINT(RT_DEBUG_TRACE, "SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n", Channel);
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC (%s) - receive desired BEACON Chan=%d\n", __FUNCTION__, Channel);
 
 		    RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer);
 
@@ -860,6 +860,9 @@ VOID PeerBeacon(
 			// collapse into the ADHOC network which has bigger BSSID value.
 			for (i = 0; i < 6; i++)
 			{
+				if (Bssid[i] < pAd->PortCfg.Bssid[i])
+					break;
+
 				if (Bssid[i] > pAd->PortCfg.Bssid[i])
 				{
 					DBGPRINT(RT_DEBUG_TRACE, "SYNC - merge to the IBSS with bigger BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -874,7 +877,7 @@ VOID PeerBeacon(
 			}
 		}
 
-		DBGPRINT(RT_DEBUG_INFO, "SYNC - PeerBeacon from %02x:%02x:%02x:%02x:%02x:%02x - Dtim=%d/%d, Rssi=%02x\n",
+		DBGPRINT(RT_DEBUG_INFO, "SYNC - PeerBeacon from %02x:%02x:%02x:%02x:%02x:%02x - Dtim=%d/%d, Rssi=%ddBm\n",
 			Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5],
 			DtimCount, DtimPeriod, RealRssi);
 
@@ -1515,6 +1518,7 @@ VOID EnqueueBeaconFrame(
 			DBGPRINT(RT_DEBUG_ERROR, "couldn't allocate memory\n");
 			return;
 		}
+
 #ifndef BIG_ENDIAN
 	pTxD = &pAd->BeaconTxD;
 #else
@@ -1545,6 +1549,7 @@ VOID EnqueueBeaconFrame(
     RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
     WriteBackToDescriptor((PUCHAR)pDestTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
 #endif
+
 	kfree(Tsf);
 }
 
@@ -1750,10 +1755,12 @@ VOID BuildChannelList(
 
     DBGPRINT(RT_DEBUG_TRACE,"country code=%d/%d, RFIC=%d, PHY mode=%d, support %d channels\n",
         pAd->PortCfg.CountryRegion, pAd->PortCfg.CountryRegionForABand, pAd->RfIcType, pAd->PortCfg.PhyMode, pAd->ChannelListNum);
+	DBGPRINT(RT_DEBUG_TRACE, "channel #");
     for (i=0;i<index;i++)
     {
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"channel #%d\n", pAd->ChannelList[i].Channel);
+        DBGPRINT_RAW(RT_DEBUG_TRACE," %d", pAd->ChannelList[i].Channel);
     }
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 }
 
 /*
diff -upNr -X /u/condorg/dontdiff.txt linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/wpa.c linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/wpa.c
--- linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73.orig/wpa.c	2008-05-09 06:05:28.000000000 +0200
+++ linux-sh4-2.6.23.16_stm23_0111/drivers/net/wireless/rt73/wpa.c	2008-05-09 06:24:59.000000000 +0200
@@ -588,14 +588,17 @@ VOID	WpaPairMsg1Action(
 	else
 	{
 		INT i;
-		DBGPRINT_RAW(RT_DEBUG_INFO, " PMK = ");
+		DBGPRINT(RT_DEBUG_INFO, " PMK = ");
 		for (i = 0; i < 16; i++)
 			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PskKey.Key[i]);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
 
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n PTK = ");
+		DBGPRINT(RT_DEBUG_INFO, "PTK = ");
 		for (i = 0; i < 64; i++)
 			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PTK[i]);
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n FrameLen = %d\n", FrameLen);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
+
+		DBGPRINT(RT_DEBUG_INFO, "FrameLen = %d\n", FrameLen);
 
 	    hmac_md5(PTK,  LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
 	}
@@ -879,16 +882,20 @@ VOID	WpaPairMsg3Action(
 		DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in msg 3 of 4-way handshake!!!!!!!!!! \n");
 
 	// 3. Check Replay Counter, it has to be larger than last one. No need to be exact one larger
-	if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1)
+	if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1) {
+		DBGPRINT(RT_DEBUG_ERROR, "WPA - (%s) invalid replay ctr\n",
+				__FUNCTION__);
 		return;
-
+	}
 	// Update new replay counter
 	memcpy(pAd->PortCfg.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
 
 	// 4. Double check ANonce
-	if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))
+	if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE)) {
+		DBGPRINT(RT_DEBUG_ERROR, "WPA - (%s) Nonce mismatch\n",
+				__FUNCTION__);
 		return;
-
+	}
 	// 5. Construct Message 4
 	// =====================================
 	// Use Priority Ring & MiniportMMRequest
@@ -1016,7 +1023,6 @@ VOID	WpaPairMsg3Action(
 	// Send using priority queue
 	MiniportMMRequest(pAd, pOutBuffer, FrameLen);
 
-
 	DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg3Action <-----\n");
 }
 
@@ -1103,21 +1109,23 @@ VOID    Wpa2PairMsg3Action(
         DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in msg 3 of 4-way handshake!!!!!!!!!! \n");
 
     // 3. Check Replay Counter, it has to be larger than last one. No need to be exact one larger
-    if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1)
+    if (RTMPCompareMemory(pMsg3->KeyDesc.ReplayCounter, pAd->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) != 1) {
+		DBGPRINT(RT_DEBUG_ERROR, "WPA - (%s) invalid replay ctr\n",
+				__FUNCTION__);
         return;
-
-
+	}
     // Update new replay counter
     memcpy(pAd->PortCfg.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
 
     // 4. Double check ANonce
-    if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))
+    if (!NdisEqualMemory(pAd->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE)) {
+		DBGPRINT(RT_DEBUG_ERROR, "WPA - (%s) Nonce mismatch\n",
+				__FUNCTION__);
         return;
-
-
+	}
     // Obtain GTK
     // 5. Decrypt GTK from Key Data
-    DBGPRINT_RAW(RT_DEBUG_TRACE, "EKD = %d\n", pMsg3->KeyDesc.KeyInfo.EKD_DL);
+    DBGPRINT(RT_DEBUG_INFO, "EKD = %d\n", pMsg3->KeyDesc.KeyInfo.EKD_DL);
     if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
     {
 
@@ -1140,14 +1148,17 @@ VOID    Wpa2PairMsg3Action(
         // Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
         ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, KEYDATA, pMsg3->KeyDesc.KeyData, pMsg3->KeyDesc.KeyDataLen[1]);
 
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "KEYDATA = \n");
+        DBGPRINT(RT_DEBUG_TRACE, "KEYDATA =\n");
+        DBGPRINT(RT_DEBUG_TRACE, " ");
         for (i = 0; i < 100; i++)
         {
-            DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", KEYDATA[i]);
-            if (i%16 == 15)
-                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+            DBGPRINT_RAW(RT_DEBUG_TRACE, " %2x", KEYDATA[i]);
+            if (i%16 == 15) {
+                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+                DBGPRINT(RT_DEBUG_TRACE, " ");
+			}
         }
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 
         ParseKeyData(pAd, KEYDATA, pMsg3->KeyDesc.KeyDataLen[1]);
 
@@ -1276,8 +1287,7 @@ VOID    Wpa2PairMsg3Action(
     // Send using priority queue
     MiniportMMRequest(pAd, pOutBuffer, FrameLen);
 
-
-    DBGPRINT(RT_DEBUG_ERROR, "Wpa2PairMsg3Action <-----\n");
+    DBGPRINT(RT_DEBUG_TRACE, "Wpa2PairMsg3Action <-----\n");
 
 }
 
@@ -1465,14 +1475,12 @@ VOID	WpaGroupMsg1Action(
 	    memcpy(pGroupKey->KeyMaterial, KEYDATA, 32);
 	    memcpy(GTK, KEYDATA, 32);
 
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "GTK = \n");
+        DBGPRINT(RT_DEBUG_TRACE, "AES GTK =");
         for (i = 0; i < 32; i++)
         {
-            DBGPRINT_RAW(RT_DEBUG_TRACE, "%02x ", pGroup->KeyDesc.KeyData[i]);
-            if (i%16 == 15)
-                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+            DBGPRINT_RAW(RT_DEBUG_TRACE, " %02x", pGroup->KeyDesc.KeyData[i]);
         }
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 
 
         // Call Add peer key function
@@ -1493,14 +1501,12 @@ VOID	WpaGroupMsg1Action(
 		// Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
         ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, GTK, pGroup->KeyDesc.KeyData, 32);
 
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "GTK = \n");
+        DBGPRINT(RT_DEBUG_TRACE, "TKIP GTK =");
         for (i = 0; i < 32; i++)
         {
-            DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", GTK[i]);
-            if (i%16 == 15)
-                DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+            DBGPRINT_RAW(RT_DEBUG_TRACE, " %2x", GTK[i]);
         }
-        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+        DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 
         //RTMPWPAAddKeyProc(pAd, pGroupKey);
         //ParseKeyData(pAd, KEYDATA, pGroup->KeyDesc.KeyDataLen[1]);
@@ -1584,10 +1590,11 @@ VOID	WpaGroupMsg1Action(
 	{
 		INT i;
 
-		DBGPRINT_RAW(RT_DEBUG_INFO, "PTK = ");
+		DBGPRINT(RT_DEBUG_INFO, "PTK = ");
 		for (i = 0; i < 64; i++)
 			DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAd->PortCfg.PTK[i]);
-		DBGPRINT_RAW(RT_DEBUG_INFO, "\n FrameLen = %d\n", FrameLen);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");
+		DBGPRINT(RT_DEBUG_INFO, "- FrameLen = %d\n", FrameLen);
 
 		hmac_md5(pAd->PortCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen, Mic);
 	}
@@ -1767,22 +1774,22 @@ VOID ParseKeyData(
     {
         pMyKeyData = pKeyData + *(pKeyData+1) + 2;
         KeyDataLength -= (2 + *(pKeyData+1));
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA RSN IE length %d contained in Msg3 = \n", (2 + *(pKeyData+1)));
+        DBGPRINT(RT_DEBUG_TRACE,"WPA RSN IE length %d contained in Msg3 = \n", (2 + *(pKeyData+1)));
     }
     if ((*pMyKeyData == WPA2RSNIE) && (*(pMyKeyData+1) != 0) && (KeyDataLength >= (2 + *(pMyKeyData+1))))
     {
         pMyKeyData += (*(pMyKeyData+1) + 2);
         KeyDataLength -= (2 + *(pMyKeyData+1));
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"WPA2 RSN IE length %d contained in Msg3 = \n", (2 + *(pMyKeyData+1)));
+        DBGPRINT(RT_DEBUG_TRACE,"WPA2 RSN IE length %d contained in Msg3 = \n", (2 + *(pMyKeyData+1)));
     }
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"KeyDataLength %d   \n", KeyDataLength);
+        DBGPRINT(RT_DEBUG_TRACE,"KeyDataLength %d   \n", KeyDataLength);
     pKDE = (PKDE_ENCAP) pMyKeyData;//Modified by Thomas:for WPA2 crashed  error.
 
     if ((KeyDataLength >= 8) && (KeyDataLength <= sizeof(KDE_ENCAP)))
     {
 	//pKDE = (PKDE_ENCAP) pMyKeyData;
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE = \n");
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->Type %x:", pKDE->Type);
+        DBGPRINT(RT_DEBUG_TRACE,"pKDE = \n");
+        DBGPRINT(RT_DEBUG_TRACE,"pKDE->Type %x:", pKDE->Type);
         DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->Len 0x%x:", pKDE->Len);
         DBGPRINT_RAW(RT_DEBUG_TRACE,"pKDE->OUI %x %x %x :", pKDE->OUI[0],pKDE->OUI[1],pKDE->OUI[2] );
         DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");
@@ -1790,13 +1797,13 @@ VOID ParseKeyData(
 
     if (pKDE->GTKEncap.Kid == 0)
     {
-        DBGPRINT_RAW(RT_DEBUG_ERROR,"GTK Key index zero , error\n");
+        DBGPRINT(RT_DEBUG_ERROR,"GTK Key index zero , error\n");
         return;
     }
 
         GTKLEN = pKDE->Len -6;
 
-        DBGPRINT_RAW(RT_DEBUG_TRACE,"GTK Key[%d] len=%d ", pKDE->GTKEncap.Kid, GTKLEN);
+        DBGPRINT(RT_DEBUG_TRACE,"GTK Key[%d] len=%d ", pKDE->GTKEncap.Kid, GTKLEN);
         for (i = 0; i < GTKLEN; i++)
         {
             DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pKDE->GTKEncap.GTK[i]);
@@ -2052,14 +2059,16 @@ VOID    AES_GTK_KEY_UNWRAP(
         plaintext[i] = R[i];
     }
 
-    DBGPRINT_RAW(RT_DEBUG_TRACE, "plaintext = \n");
+    DBGPRINT(RT_DEBUG_TRACE, "plaintext =");
     for (i = 0; i < (num_blocks *8); i++)
     {
         DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x ", plaintext[i]);
-        if (i%16 == 15)
-            DBGPRINT_RAW(RT_DEBUG_TRACE, "\n ");
+        if (i%16 == 15) {
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
+            DBGPRINT(RT_DEBUG_TRACE, " ");
+		}
     }
-    DBGPRINT_RAW(RT_DEBUG_TRACE, "\n  \n");
+    DBGPRINT_RAW(RT_DEBUG_TRACE, "\n");
 
 
 }
@@ -2089,7 +2098,7 @@ VOID RTMPToWirelessSta(
     	// 1. build a NDIS packet and call RTMPSendPacket();
      	//    be careful about how/when to release this internal allocated NDIS PACKET buffer
 #ifdef RTMP_EMBEDDED
-   		if ((skb = __dev_alloc_skb(FrameLen + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
+   		if ((skb = __dev_alloc_skb(FrameLen + 2, GFP_DMA|GFP_KERNEL)) != NULL)
 #else
     	if ((skb = dev_alloc_skb(FrameLen + 2)) != NULL)
 #endif
