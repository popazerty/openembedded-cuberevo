Basic chip support for the STx7141 and the corrisponding board, the mb628.

There are still some problems with this patch, in particular:

 - the changes to PIO configuration for this chip mean that sysconfig
   registers have to be updated when switching from alt function to
   PIO mode, which is not currently supported in the code. As a
   result some drivers (notably I2C SSC) are currently broken.

 - the interrupt routing is very inefficient, with all interrupts being
   routed through a single INTC2 interrupts.

However it appears to work, and should be enough to get developers up
and running.

Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
Index: linux-2.6.23-stm/arch/sh/Kconfig
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/Kconfig
+++ linux-2.6.23-stm/arch/sh/Kconfig
@@ -530,6 +530,17 @@ config SH_ST_MB618
 	  STB7111-MBOARD, ST board ID: mb618). More information at:
 	  <http://www.stlinux.com/boards/mb618/>
 
+config SH_ST_MB628
+	bool "mb628: STx7141 Mboard"
+	depends on CPU_SUBTYPE_STX7141
+	select SH_ST_EPLD
+	select SH_ST_STEM
+	help
+	  Select STx7141 Mboard if configuring for an
+	  STMicroelectronics STx7141 MBoard (product code:
+	  STi7141-MBOARD, ST board ID: mb628). More information at:
+	  <http://www.stlinux.com/boards/mb628/>
+
 config SH_ST_MB671
 	bool "mb671: STx7200 cut 2.0 Mboard"
 	depends on CPU_SUBTYPE_STX7200
Index: linux-2.6.23-stm/arch/sh/Makefile
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/Makefile
+++ linux-2.6.23-stm/arch/sh/Makefile
@@ -137,6 +137,7 @@ machdir-$(CONFIG_SH_ST_MB442)			+= st/mb
 machdir-$(CONFIG_SH_ST_MB448)			+= st/mb448
 machdir-$(CONFIG_SH_ST_MB519)			+= st/mb519 st/common
 machdir-$(CONFIG_SH_ST_MB618)			+= st/mb618 st/common
+machdir-$(CONFIG_SH_ST_MB628)			+= st/mb628 st/common
 machdir-$(CONFIG_SH_ST_MB671)			+= st/mb671 st/common
 machdir-$(CONFIG_SH_ST_MB680)			+= st/mb680 st/common
 
Index: linux-2.6.23-stm/arch/sh/boards/st/mb628/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/arch/sh/boards/st/mb628/setup.c
@@ -0,0 +1,292 @@
+/*
+ * arch/sh/boards/st/mb628/setup.c
+ *
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STx7141 Mboard support.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/emi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/phy.h>
+#include <linux/lirc.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <asm/irq-ilc.h>
+#include <asm/irl.h>
+#include <asm/mb628/epld.h>
+#include "../common/common.h"
+
+#define FLASH_NOR
+
+static struct platform_device epld_device;
+
+static int ascs[] __initdata = {
+	1 | (ASC1_PIO10 << 8),	/* PIO10 muxed with GMAC0 & DVO */
+	2 | (ASC2_PIO6  << 8)	/* PIO6 muxed with TS(NIM) and OOB_??? */
+};
+
+static void __init mb628_setup(char **cmdline_p)
+{
+	u8 test;
+
+	printk(KERN_INFO "STMicroelectronics STx7141 Mboard initialisation\n");
+
+	stx7141_early_device_init();
+	stx7141_configure_asc(ascs, ARRAY_SIZE(ascs), 0);
+
+	epld_early_init(&epld_device);
+
+	epld_write(0xab, EPLD_TEST);
+	test = epld_read(EPLD_TEST);
+	printk(KERN_INFO "mb628 EPLD version %ld, test %s\n",
+	       epld_read(EPLD_IDENT),
+	       (test == (u8)(~0xab)) ? "passed" : "failed");
+}
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT1,
+};
+
+static struct plat_ssc_data ssc_private_info = {
+	.capability  =
+		ssc0_has(SSC_UNCONFIGURED)	/* SSC1 */	|
+		ssc1_has(SSC_SPI_CAPABILITY)	/* SSC2 */	|
+		ssc2_has(SSC_I2C_CAPABILITY)	/* SSC3 */	|
+		ssc3_has(SSC_I2C_CAPABILITY)	/* SSC4 */	|
+		ssc4_has(SSC_I2C_CAPABILITY)	/* SSC5 */	|
+		ssc5_has(SSC_I2C_CAPABILITY)	/* SSC6 */	|
+		ssc6_has(SSC_I2C_CAPABILITY),	/* SSC7 */
+};
+
+#ifdef FLASH_NOR
+/* J69 must be in position 2-3 to enable the on-board Flash devices (both
+ * NOR and NAND) rather than STEM). */
+/* J89 and J84 must be both in position 1-2 to avoid shorting A15 */
+/* J70 must be in the 2-3 position to enable NOR Flash */
+
+static void set_vpp(struct map_info *info, int enable)
+{
+	epld_write((enable ? EPLD_FLASH_NOTWP : 0) | EPLD_FLASH_NOTRESET,
+		   EPLD_FLASH);
+}
+
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+		.name = "Boot firmware",
+		.size = 0x00040000,
+		.offset = 0x00000000,
+	}, {
+		.name = "Kernel",
+		.size = 0x00100000,
+		.offset = 0x00040000,
+	}, {
+		.name = "Root FS",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0x00140000,
+	}
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start		= 0x00000000,
+			.end		= 32*1024*1024 - 1,
+			.flags		= IORESOURCE_MEM,
+		}
+	},
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+};
+
+#else
+
+/* J70 must be in the 1-2 position to enable NAND Flash */
+static struct mtd_partition nand_partitions[] = {
+	{
+		.name	= "NAND root",
+		.offset	= 0,
+		.size 	= 0x00800000
+	}, {
+		.name	= "NAND home",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct nand_config_data mb628_nand_config = {
+	.emi_bank		= 0,
+	.emi_withinbankoffset	= 0,
+
+	/* Timings for NAND512W3A */
+	.emi_timing_data = &(struct emi_timing_data) {
+		.rd_cycle_time	= 40,		 /* times in ns */
+		.rd_oee_start	= 0,
+		.rd_oee_end	= 10,
+		.rd_latchpoint	= 10,
+		.busreleasetime = 0,
+
+		.wr_cycle_time	= 40,
+		.wr_oee_start	= 0,
+		.wr_oee_end	= 10,
+	},
+
+	.chip_delay		= 40,		/* time in us */
+	.mtd_parts		= nand_partitions,
+	.nr_parts		= ARRAY_SIZE(nand_partitions),
+};
+#endif
+
+static int mb628_phy_reset(void *bus)
+{
+	u8 reg;
+
+	reg = epld_read(EPLD_RESET);
+	reg &= ~EPLD_RESET_MII;
+	epld_write(reg, EPLD_RESET);
+	udelay(150);
+	reg |= EPLD_RESET_MII;
+	epld_write(reg, EPLD_RESET);
+
+	return 1;
+}
+
+static struct plat_stmmacphy_data phy_private_data = {
+	.bus_id = 0,
+	.phy_addr = 1,
+	.phy_mask = 0,
+	.interface = PHY_INTERFACE_MODE_MII,
+	.phy_reset = mb628_phy_reset,
+};
+
+static struct platform_device dp83865_phy_device = {
+	.name		= "stmmacphy",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.name	= "phyirq",
+			.start	= -1,/*FIXME*/
+			.end	= -1,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &phy_private_data,
+	}
+};
+
+static struct platform_device epld_device = {
+	.name		= "epld",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0x05000000,
+			/* Minimum size to ensure mapped by PMB */
+			.end	= 0x05000000+(8*1024*1024)-1,
+			.flags	= IORESOURCE_MEM,
+		}
+	},
+	.dev.platform_data = &(struct plat_epld_data) {
+		 .opsize = 8,
+	},
+};
+
+static struct platform_device *mb628_devices[] __initdata = {
+	&epld_device,
+	&physmap_flash,
+	&dp83865_phy_device,
+};
+
+/* Configuration based on Futarque-RC signals train. */
+lirc_scd_t lirc_scd = {
+	.code = 0x3FFFC028,
+	.codelen = 0x1e,
+	.alt_codelen = 0,
+	.nomtime = 0x1f4,
+	.noiserecov = 0,
+};
+
+static int __init device_init(void)
+{
+	/*
+	 * Can't enable PWM output without conflicting with either
+	 * SSC6 (audio) or USB1A OC (which is disabled because it is broken,
+	 * but would still result in contention).
+	 *
+	 * stx7141_configure_pwm(&pwm_private_info);
+	 */
+	stx7141_configure_ssc(&ssc_private_info);
+	stx7141_configure_usb(0);
+
+	/* This requires fitting jumpers J52A 1-2 and J52B 4-5 */
+	stx7141_configure_usb(1);
+
+	/*
+	 * Disabled because overcurrent detection appears broken on cut 1.
+	 * stx7141_configure_usb(2);
+	 * stx7141_configure_usb(3);
+	 */
+
+	stx7141_configure_ethernet(1, 0, 0, 0);
+#if 0
+	stx7141_configure_lirc(&lirc_scd);
+#endif
+
+#ifndef FLASH_NOR
+	stx7141_configure_nand(&mb628_nand_config);
+	/* The MTD NAND code doesn't understand the concept of VPP,
+	 * (or hardware write protect) so permanently enable it.
+	 */
+	epld_write(EPLD_FLASH_NOTWP | EPLD_FLASH_NOTRESET, EPLD_FLASH);
+#endif
+
+	return platform_add_devices(mb628_devices, ARRAY_SIZE(mb628_devices));
+}
+arch_initcall(device_init);
+
+static void __iomem *mb628_ioport_map(unsigned long port, unsigned int size)
+{
+	/*
+	 * No IO ports on this device, but to allow safe probing pick
+	 * somewhere safe to redirect all reads and writes.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init mb628_init_irq(void)
+{
+}
+
+struct sh_machine_vector mv_mb628 __initmv = {
+	.mv_name		= "mb628",
+	.mv_setup		= mb628_setup,
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= mb628_init_irq,
+	.mv_ioport_map		= mb628_ioport_map,
+};
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/Makefile
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/sh4/Makefile
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= se
 obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= setup-stb7100.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7105)	+= setup-stx7105.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7111)	+= setup-stx7111.o
+obj-$(CONFIG_CPU_SUBTYPE_STX7141)	+= setup-stx7141.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7200)	+= setup-stx7200.o
 
 # Primary on-chip clocks (common)
@@ -30,6 +31,7 @@ clock-$(CONFIG_CPU_SH4)			:= clock-sh4.o
 clock-$(CONFIG_CPU_SUBTYPE_STB7100)	:= clock-stb7100.o
 clock-$(CONFIG_CPU_SUBTYPE_STX7105)	:= clock-stx7105.o
 clock-$(CONFIG_CPU_SUBTYPE_STX7111)	:= clock-stx7111.o
+clock-$(CONFIG_CPU_SUBTYPE_STX7141)	:= clock-stx7141.o
 clock-$(CONFIG_CPU_SUBTYPE_STX7200)	:= clock-stx7200.o
 endif
 
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/clock-stx7141.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/clock-stx7141.c
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2008 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Code to handle the clockgen hardware on the STx7141.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/stm/sysconf.h>
+#include <linux/io.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+
+/* Values for mb628 */
+#define SYSCLKIN	30000000
+#define SYSCLKINALT	30000000
+
+#define CLOCKGENA_BASE_ADDR	0xfe213000	/* Clockgen A */
+#define CLOCKGENB_BASE_ADDR	0xfe000000	/* Clockgen B */
+
+/* Definitions taken from targetpack sti7141_clockgena_regs.xml */
+#define CKGA_PLL0_CFG			0x000
+#define CKGA_PLL1_CFG			0x004
+#define CKGA_POWER_CFG			0x010
+#define CKGA_CLKOPSRC_SWITCH_CFG(x)	(0x014+((x)*0x10))
+#define CKGA_CLKOBS_MUX1_CFG		0x030
+#define CKGA_CLKOBS_MUX2_CFG		0x048
+/* All the following appear to be offsets into clkgen B, despite the name */
+#define CKGA_OSC_DIV_CFG(x)		(0x800+((x)*4))
+#define CKGA_PLL0HS_DIV_CFG(x)		(0x900+((x)*4))
+#define CKGA_PLL0LS_DIV_CFG(x)		(0xa10+(((x)-4)*4))
+#define CKGA_PLL1_DIV_CFG(x)		(0xb00+((x)*4))
+
+static unsigned long clkin[2] = {
+	SYSCLKIN,	/* clk_osc_a */
+	SYSCLKINALT,	/* clk_osc_b */
+};
+
+static struct sysconf_field *clkgena_clkosc_sel_sc;
+
+static void __iomem *clkgena_base, *clkgenb_base;
+
+static struct sysconf_field *clkgend_ddiv, *clkgend_rdiv;
+static struct sysconf_field *clkgend_clk_sel;
+
+/* Clkgen A clk_osc -------------------------------------------------------- */
+
+static void clkgena_clk_osc_init(struct clk *clk)
+{
+	clk->rate = clkin[sysconf_read(clkgena_clkosc_sel_sc)];
+}
+
+static struct clk_ops clkgena_clk_osc_ops = {
+	.init		= clkgena_clk_osc_init,
+};
+
+static struct clk clkgena_clk_osc = {
+	.name		= "clkgena_clk_osc",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &clkgena_clk_osc_ops,
+};
+
+/* Clkgen A PLLs ----------------------------------------------------------- */
+
+static unsigned long pll800_freq(unsigned long input, unsigned long cfg)
+{
+	unsigned long freq, ndiv, pdiv, mdiv;
+
+	mdiv = (cfg >>  0) & 0xff;
+	ndiv = (cfg >>  8) & 0xff;
+	pdiv = (cfg >> 16) & 0x7;
+	freq = (((2 * (input / 1000) * ndiv) / mdiv) /
+		(1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+static unsigned long pll1600_freq(unsigned long input, unsigned long cfg)
+{
+	unsigned long freq, ndiv, mdiv;
+
+	mdiv = (cfg >>  0) & 0x7;
+	ndiv = (cfg >>  8) & 0xff;
+	freq = (((input / 1000) * ndiv) / mdiv) * 1000;
+
+	return freq;
+}
+
+static unsigned long clkgena_pll_freq(unsigned long clk_osc, int pll_num)
+{
+	unsigned long data;
+
+	switch (pll_num) {
+	case 0:
+		data = readl(clkgena_base + CKGA_PLL0_CFG);
+		return pll1600_freq(clk_osc, data);
+	case 1:
+		data = readl(clkgena_base + CKGA_PLL1_CFG);
+		return pll800_freq(clk_osc, data);
+	}
+
+	return 0;
+}
+
+struct pllclk
+{
+	struct clk clk;
+	unsigned long pll_num;
+};
+
+static void pll_clk_recalc(struct clk *clk)
+{
+	struct pllclk *pllclk = container_of(clk, struct pllclk, clk);
+
+	clk->rate = clkgena_pll_freq(clk->parent->rate, pllclk->pll_num);
+}
+
+static struct clk_ops pll_clk_ops = {
+	.recalc		= pll_clk_recalc,
+};
+
+static struct pllclk pllclks[2] = {
+	{
+		.clk = {
+			.name	= "clkgena_pll0_clk",
+			.parent	= &clkgena_clk_osc,
+			.flags	= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops	= &pll_clk_ops,
+		},
+		.pll_num = 0
+	}, {
+		.clk = {
+			.name	= "clkgena_pll1_clk",
+			.parent	= &clkgena_clk_osc,
+			.flags	= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+			.ops	= &pll_clk_ops,
+		},
+		.pll_num = 1
+	}
+};
+
+/* Clkgen A clocks --------------------------------------------------------- */
+
+struct clkgenaclk
+{
+	struct clk clk;
+	unsigned long num;
+};
+
+static void clkgena_clk_init(struct clk *clk)
+{
+	struct clkgenaclk *clkgenaclk =
+		container_of(clk, struct clkgenaclk, clk);
+	unsigned long num = clkgenaclk->num;
+	unsigned long data;
+	unsigned long src_sel;
+
+	data = readl(clkgena_base + CKGA_CLKOPSRC_SWITCH_CFG(num >> 4));
+	src_sel = (data >> ((num & 0xf) * 2)) & 3;
+
+	switch (src_sel) {
+	case 0:
+		clk->parent = &clkgena_clk_osc;
+		break;
+	case 1:
+		clk->parent = &pllclks[0].clk;
+		break;
+	case 2:
+		clk->parent = &pllclks[1].clk;
+		break;
+	case 3:
+		/* clock is stopped */
+		clk->parent = NULL;
+		break;
+	}
+}
+
+static void clkgena_clk_recalc(struct clk *clk)
+{
+	struct clkgenaclk *clkgenaclk =
+		container_of(clk, struct clkgenaclk, clk);
+	unsigned long num = clkgenaclk->num;
+	unsigned long data;
+	unsigned long src_sel;
+	unsigned long div_cfg = 0;
+	unsigned long ratio;
+
+	data = readl(clkgena_base + CKGA_CLKOPSRC_SWITCH_CFG(num >> 4));
+	src_sel = (data >> ((num & 0xf) * 2)) & 3;
+
+	switch (src_sel) {
+	case 0:
+		div_cfg = readl(clkgena_base + CKGA_OSC_DIV_CFG(num));
+		break;
+	case 1:
+		div_cfg = readl(clkgena_base +
+				((num <= 3) ? CKGA_PLL0HS_DIV_CFG(num) :
+				 CKGA_PLL0LS_DIV_CFG(num)));
+		break;
+	case 2:
+		div_cfg = readl(clkgena_base + CKGA_PLL1_DIV_CFG(num));
+		break;
+	case 3:
+		clk->rate = 0;
+		return;
+	}
+
+	if (div_cfg & 0x10000)
+		ratio = 1;
+	else
+		ratio = (div_cfg & 0x1F) + 1;
+
+	clk->rate = clk->parent->rate / ratio;
+}
+
+static struct clk_ops clkgena_clk_ops = {
+	.init		= clkgena_clk_init,
+	.recalc		= clkgena_clk_recalc,
+};
+
+#define CLKGENA_CLK(_num, _name)				\
+	{							\
+		.clk = {					\
+			.name	= _name,			\
+			.flags	= CLK_ALWAYS_ENABLED | 		\
+				CLK_RATE_PROPAGATES,		\
+			.ops	= &clkgena_clk_ops,		\
+		},						\
+		.num = _num,					\
+	 }
+
+static struct clkgenaclk clkgenaclks[] = {
+	CLKGENA_CLK(0, "ic_STNOC"),
+	CLKGENA_CLK(1, "fdma0"),
+	CLKGENA_CLK(2, "fdma1"),
+	CLKGENA_CLK(2, "fdma2"),
+	CLKGENA_CLK(4, "sh4_clk"),		/* ls[0] */
+	CLKGENA_CLK(5, "sh4_clk_498"),		/* ls[1] */
+	CLKGENA_CLK(6, "lx_dmu_cpu"),		/* ls[2] */
+	CLKGENA_CLK(7, "lx_aud_cpu"),		/* ls[3] */
+	CLKGENA_CLK(8, "ic_bdisp_200"),		/* ls[4] */
+	CLKGENA_CLK(9, "ic_disp_200"),		/* ls[5] */
+	CLKGENA_CLK(10, "ic_if_100"),		/* ls[6] */
+	CLKGENA_CLK(11, "disp_pipe_200"),	/* ls[7] */
+	CLKGENA_CLK(12, "blit_proc"),		/* ls[8] */
+	CLKGENA_CLK(13, "ethernet_phy"),	/* ls[9] */
+	CLKGENA_CLK(14, "pci"),			/* ls[10] */
+	CLKGENA_CLK(15, "emi_master"),		/* ls[11] */
+	CLKGENA_CLK(16, "ic_compo_200"),	/* ls[12] */
+	CLKGENA_CLK(17, "ic_if_200"),		/* ls[13] */
+};
+
+/* SH4 generic clocks ------------------------------------------------------ */
+
+static void generic_clk_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate;
+}
+
+static struct clk_ops generic_clk_ops = {
+	.recalc		= generic_clk_recalc,
+};
+
+static struct clk generic_module_clk = {
+	.name		= "module_clk",
+	.parent		= &clkgenaclks[10].clk, /* ic_if_100 */
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &generic_clk_ops,
+};
+
+static struct clk generic_comms_clk = {
+	.name		= "comms_clk",
+	.parent		= &clkgenaclks[10].clk, /* ic_if_100 */
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &generic_clk_ops,
+};
+
+/* Clockgen D clocks ------------------------------------------------------- */
+
+static void clkgend_clk_init(struct clk *clk)
+{
+	int clk_sel = sysconf_read(clkgend_clk_sel);
+	int ddiv = sysconf_read(clkgend_ddiv);
+	int rdiv = sysconf_read(clkgend_rdiv);
+
+	if (rdiv == 0)
+		clk->rate = 0;
+	else
+		clk->rate = (clkin[clk_sel] * ddiv) / rdiv;
+}
+
+static struct clk_ops clkgend_clk_ops = {
+	.init		= clkgend_clk_init,
+};
+
+static struct clk clkgend_clk = {
+	.name		= "lmi2x",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &clkgend_clk_ops,
+};
+
+/* ------------------------------------------------------------------------- */
+
+int __init clk_init(void)
+{
+	int i, ret;
+
+	/* Clockgen A */
+
+	clkgena_clkosc_sel_sc = sysconf_claim(SYS_STA, 1, 0, 0, "clkgena");
+	clkgena_base = ioremap(CLOCKGENA_BASE_ADDR, 0x50);
+	clkgenb_base = ioremap(CLOCKGENB_BASE_ADDR, 0xc00);
+
+	ret = clk_register(&clkgena_clk_osc);
+	clk_enable(&clkgena_clk_osc);
+
+	for (i = 0; i < 2; i++) {
+		ret |= clk_register(&pllclks[i].clk);
+		clk_enable(&pllclks[i].clk);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(clkgenaclks); i++) {
+		ret |= clk_register(&clkgenaclks[i].clk);
+		clk_enable(&clkgenaclks[i].clk);
+	}
+
+	ret = clk_register(&generic_module_clk);
+	clk_enable(&generic_module_clk);
+	ret = clk_register(&generic_comms_clk);
+	clk_enable(&generic_comms_clk);
+
+	/* Propagate the clk osc value down */
+	clk_set_rate(&clkgena_clk_osc, clk_get_rate(&clkgena_clk_osc));
+	clk_put(&clkgena_clk_osc);
+
+	/* Clockgen D */
+
+	clkgend_clk_sel = sysconf_claim(SYS_CFG, 40, 0, 0, "clkgend");
+	clkgend_ddiv = sysconf_claim(SYS_CFG, 11, 1, 8, "clkgend");
+	clkgend_rdiv = sysconf_claim(SYS_CFG, 11, 9, 11, "clkgend");
+
+	ret = clk_register(&clkgend_clk);
+	clk_enable(&clkgend_clk);
+
+	return ret;
+}
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/probe.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/sh4/probe.c
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/probe.c
@@ -160,7 +160,6 @@ int __init detect_cpu_and_cache_system(v
 		/* ST40-300 core */
 		switch (prr_all) {
 		case 0x10:
-			/* STx7105 */
 			cpu_data->type = CPU_STX7105;
 			break;
 		case 0x9500 ... 0x95ff:
@@ -168,8 +167,10 @@ int __init detect_cpu_and_cache_system(v
 			cpu_data->type = CPU_STX7200;
 			break;
 		case 0x9a10:
-			/* STx7111 */
-			boot_cpu_data.type = CPU_ST40_300;
+			boot_cpu_data.type = CPU_STX7111;
+			break;
+		case 0x9b00:
+			boot_cpu_data.type = CPU_STX7141;
 			break;
 		default:
 			cpu_data->type = CPU_SH_NONE;
@@ -200,17 +201,7 @@ int __init detect_cpu_and_cache_system(v
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x690:
-#if 0
-		/* When we tidy up this code... */
-		switch (prr_all) {
-		case 0x9500 ... 0x95ff:
-			cpu_data->type = CPU_STX7200_210;
-			break;
-		default:
-			cpu_data->type = CPU_SH_NONE;
-			break;
-		}
-#endif
+		/* CPU_STx7200 cut 1.0 */
 		boot_cpu_data.type = CPU_STX7200;
 		boot_cpu_data.icache.ways = 2;
 		boot_cpu_data.dcache.ways = 2;
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stx7141.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/sh4/setup-stx7141.c
@@ -0,0 +1,1266 @@
+/*
+ * STx7141 Setup
+ *
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/soc_init.h>
+#include <linux/stm/pio.h>
+#include <linux/phy.h>
+#include <linux/stm/sysconf.h>
+#include <linux/stm/emi.h>
+#include <linux/pata_platform.h>
+#include <linux/stm/fdma-plat.h>
+#include <linux/stm/fdma-reqs.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/irq-ilc.h>
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct {
+	unsigned char syscfg;
+	unsigned char lsb, msb;
+} pio_sysconf[17][8] = {
+	{
+		/* PIO0 doesn't exist */
+	}, {
+		{ 19,  0,  1 },	/* PIO1[0] */
+		{ 19,  2,  3 },	/* PIO1[1] */
+		{ 19,  4,  5 },	/* PIO1[2] */
+		{ 19,  5,  7 },	/* PIO1[3] */
+		{ 19,  8,  8 },	/* PIO1[4] */
+		{ 19,  9,  9 },	/* PIO1[5] */
+		{ 19, 10, 10 },	/* PIO1[6] */
+		{ 19, 11, 11 },	/* PIO1[7] */
+	}, {
+		{ 19, 12, 12 },	/* PIO2[0] */
+		{ 19, 13, 13 },	/* PIO2[1] */
+		{ 19, 14, 14 },	/* PIO2[2] */
+		{ 19, 15, 15 },	/* PIO2[3] */
+		{ 19, 16, 16 },	/* PIO2[4] */
+		{ 19, 17, 17 },	/* PIO2[5] */
+		{ 19, 18, 18 },	/* PIO2[6] */
+		{ 19, 19, 19 },	/* PIO2[7] */
+	}, {
+		{ 19, 20, 20 },	/* PIO3[0] */
+		{ 19, 21, 21 },	/* PIO3[1] */
+		{ 19, 22, 23 },	/* PIO3[2] */
+		{ 19, 24, 25 },	/* PIO3[3] */
+		{ 19, 26, 27 },	/* PIO3[4] */
+		{ 19, 28, 29 },	/* PIO3[5] */
+		{ 19, 30, 31 },	/* PIO3[6] */
+		{ 20,  0,  0 },	/* PIO3[7] */
+	}, {
+		{ 20,  1,  2 },	/* PIO4[0] */
+		{ 20,  3,  4 },	/* PIO4[1] */
+		{ 20,  5,  6 },	/* PIO4[2] */
+		{ 20,  7,  8 },	/* PIO4[3] */
+		{ 20,  9, 10 },	/* PIO4[4] */
+		{ 20, 11, 12 },	/* PIO4[5] */
+		{ 20, 13, 13 },	/* PIO4[6] */
+		{ 20, 14, 14 },	/* PIO4[7] */
+	}, {
+		{ 20, 15, 16 },	/* PIO5[0] */
+		{ 20, 17, 18 },	/* PIO5[1] */
+		{ 20, 19, 19 },	/* PIO5[2] */
+		{ 20, 20, 20 },	/* PIO5[3] */
+		{ 20, 21, 21 },	/* PIO5[4] */
+		{ 20, 22, 23 },	/* PIO5[5] */
+		{ 20, 24, 24 },	/* PIO5[6] */
+		{ 20, 25, 26 },	/* PIO5[7] */
+	}, {
+		{ 20, 27, 28 },	/* PIO6[0] */
+		{ 20, 29, 30 },	/* PIO6[1] */
+		{ 25,  0,  1 },	/* PIO6[2] */
+		{ 25,  2,  3 },	/* PIO6[3] */
+		{ 25,  4,  5 },	/* PIO6[4] */
+		{ 25,  6,  7 },	/* PIO6[5] */
+		{ 25,  8,  9 },	/* PIO6[6] */
+		{ 25, 10, 11 },	/* PIO6[7] */
+	}, {
+		{ 25, 12, 13 },	/* PIO7[0] */
+		{ 25, 14, 15 },	/* PIO7[1] */
+		{ 25, 16, 17 },	/* PIO7[2] */
+		{ 25, 18, 19 },	/* PIO7[3] */
+		{ 25, 20, 21 },	/* PIO7[4] */
+		{ 25, 22, 23 },	/* PIO7[5] */
+		{ 25, 24, 25 },	/* PIO7[6] */
+		{ 25, 26, 27 },	/* PIO7[7] */
+	}, {
+		{ 25, 28, 30 },	/* PIO8[0] */
+		{ 35,  0,  2 },	/* PIO8[1] */
+		{ 35,  3,  5 },	/* PIO8[2] */
+		{ 35,  6,  8 },	/* PIO8[3] */
+		{ 35,  9, 11 },	/* PIO8[4] */
+		{ 35, 12, 14 },	/* PIO8[5] */
+		{ 35, 15, 17 },	/* PIO8[6] */
+		{ 35, 18, 20 },	/* PIO8[7] */
+	}, {
+		{ 35, 21, 22 },	/* PIO9[0] */
+		{ 35, 23, 24 },	/* PIO9[1] */
+		{ 35, 25, 26 },	/* PIO9[2] */
+		{ 35, 27, 28 },	/* PIO9[3] */
+		{ 35, 29, 30 },	/* PIO9[4] */
+		{ 46,  0,  1 },	/* PIO9[5] */
+		{ 46,  2,  3 },	/* PIO9[6] */
+		{ 46,  4,  5 },	/* PIO9[7] */
+	}, {
+		{ 46,  6,  7 },	/* PIO10[0] */
+		{ 46,  8,  9 },	/* PIO10[1] */
+		{ 46, 10, 11 },	/* PIO10[2] */
+		{ 46, 12, 13 },	/* PIO10[3] */
+		{ 46, 14, 15 },	/* PIO10[4] */
+		{ 46, 16, 17 },	/* PIO10[5] */
+		{ 46, 18, 19 },	/* PIO10[6] */
+		{ 46, 20, 21 },	/* PIO10[7] */
+	}, {
+		{ 46, 22, 23 },	/* PIO11[0] */
+		{ 46, 24, 26 },	/* PIO11[1] */
+		{ 46, 27, 29 },	/* PIO11[2] */
+		{ 47,  0,  2 },	/* PIO11[3] */
+		{ 47,  3,  5 },	/* PIO11[4] */
+		{ 47,  6,  8 },	/* PIO11[5] */
+		{ 47,  9, 11 },	/* PIO11[6] */
+		{ 47, 12, 14 },	/* PIO11[7] */
+	}, {
+		{ 47, 15, 17 },	/* PIO12[0] */
+		{ 47, 18, 20 },	/* PIO12[1] */
+		{ 47, 21, 23 },	/* PIO12[2] */
+		{ 47, 24, 25 },	/* PIO12[3] */
+		{ 47, 26, 27 },	/* PIO12[4] */
+		{ 47, 28, 29 },	/* PIO12[5] */
+		{ 48,  0,  2 },	/* PIO12[6] */
+		{ 48,  3,  5 },	/* PIO12[7] */
+	}, {
+		{ 48,  6,  8 },	/* PIO13[0] */
+		{ 48,  9, 11 },	/* PIO13[1] */
+		{ 48, 12, 14 },	/* PIO13[2] */
+		{ 48, 15, 17 },	/* PIO13[3] */
+		{ 48, 18, 20 },	/* PIO13[4] */
+		{ 48, 21, 23 },	/* PIO13[5] */
+		{ 48, 24, 25 },	/* PIO13[6] */
+		{ 48, 26, 27 },	/* PIO13[7] */
+	}, {
+		{ 48, 28, 30 },	/* PIO14[0] */
+		{ 49,  0,  2 },	/* PIO14[1] */
+		{ 49,  3,  5 },	/* PIO14[2] */
+		{ 49,  6,  8 },	/* PIO14[3] */
+		{ 49,  9, 11 },	/* PIO14[4] */
+		{ 49, 12, 14 },	/* PIO14[5] */
+		{ 49, 15, 17 },	/* PIO14[6] */
+		{ 49, 18, 19 },	/* PIO14[7] */
+	}, {
+		{ 49, 20, 21 },	/* PIO15[0] */
+		{ 49, 22, 23 },	/* PIO15[1] */
+		{ 49, 24, 25 },	/* PIO15[2] */
+		{ 49, 26, 27 },	/* PIO15[3] */
+		{ 49, 28, 28 },	/* PIO15[4] */
+		{ 49, 29, 29 },	/* PIO15[5] */
+		{ 49, 30, 30 },	/* PIO15[6] */
+		{ 50,  0,  1 },	/* PIO15[7] */
+	}, {
+		{ 50,  2,  3 },	/* PIO16[0] */
+		{ 50,  4,  5 },	/* PIO16[1] */
+		{ 50,  6,  7 },	/* PIO16[2] */
+		{ 50,  8,  8 },	/* PIO16[3] */
+		{ 50,  9,  9 },	/* PIO16[4] */
+		{ 50, 10, 10 },	/* PIO16[5] */
+		{ 50, 11, 11 },	/* PIO16[6] */
+		{ 50, 12, 12 },	/* PIO16[7] */
+	}
+};
+
+static void stx7141_pio_sysconf(int bank, int pin, int alt, const char *name)
+{
+	struct sysconf_field *sc;
+
+	sc = sysconf_claim(SYS_CFG,
+			   pio_sysconf[bank][pin].syscfg,
+			   pio_sysconf[bank][pin].lsb,
+			   pio_sysconf[bank][pin].msb, name);
+	sysconf_write(sc, alt);
+}
+
+/* USB resources ----------------------------------------------------------- */
+
+#define AHB2STBUS_WRAPPER_GLUE_OFFSET	0x00000
+#define AHB2STBUS_OHCI_OFFSET		0xffc00
+#define AHB2STBUS_EHCI_OFFSET		0xffe00
+#define AHB2STBUS_PROTOCOL_OFFSET	0xfff00
+
+static struct plat_usb_data usb_wrapper[4] = {
+	/* USB2_0 */
+	USB_WRAPPER(0, 0xfe100000 + AHB2STBUS_WRAPPER_GLUE_OFFSET,
+		    0xfe100000 + AHB2STBUS_PROTOCOL_OFFSET,
+		    USB_FLAGS_STRAP_16BIT	|
+		    USB_FLAGS_STRAP_PLL		|
+		    USB_FLAGS_STBUS_CONFIG_THRESHOLD256),
+	/* USB2_1 */
+	USB_WRAPPER(1, 0xfea00000 + AHB2STBUS_WRAPPER_GLUE_OFFSET,
+		    0xfea00000 + AHB2STBUS_PROTOCOL_OFFSET,
+		    USB_FLAGS_STRAP_16BIT	|
+		    USB_FLAGS_STRAP_PLL		|
+		    USB_FLAGS_STBUS_CONFIG_THRESHOLD256),
+	/* USB1_0 */
+	USB_WRAPPER(2, 0xfeb00000 + AHB2STBUS_WRAPPER_GLUE_OFFSET,
+		    0xfeb00000 + AHB2STBUS_PROTOCOL_OFFSET,
+		    USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE),
+	/* USB1_1 */
+	USB_WRAPPER(3, 0xfec00000 + AHB2STBUS_WRAPPER_GLUE_OFFSET,
+		    0xfec00000 + AHB2STBUS_PROTOCOL_OFFSET,
+		    USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE),
+};
+
+static struct platform_device st40_ohci_devices[4] = {
+	/* USB2_0 */
+	USB_OHCI_DEVICE(0, 0xfe100000 + AHB2STBUS_OHCI_OFFSET,
+			ILC_IRQ(94), &usb_wrapper[0]),
+	/* USB2_1 */
+	USB_OHCI_DEVICE(1, 0xfea00000 + AHB2STBUS_OHCI_OFFSET,
+			ILC_IRQ(96), &usb_wrapper[1]),
+	/* USB1_0 */
+	USB_OHCI_DEVICE(2, 0xfeb00000 + AHB2STBUS_OHCI_OFFSET,
+			ILC_IRQ(97), &usb_wrapper[2]),
+	/* USB1_1 */
+	USB_OHCI_DEVICE(3, 0xfec00000 + AHB2STBUS_OHCI_OFFSET,
+			ILC_IRQ(98), &usb_wrapper[3]),
+};
+
+static struct platform_device st40_ehci_devices[2] = {
+	/* USB2_0 */
+	USB_EHCI_DEVICE(0, 0xfe100000 + AHB2STBUS_EHCI_OFFSET,
+			ILC_IRQ(93), &usb_wrapper[0]),
+	/* USB2_1 */
+	USB_EHCI_DEVICE(1, 0xfea00000 + AHB2STBUS_EHCI_OFFSET,
+			ILC_IRQ(95), &usb_wrapper[1]),
+};
+
+void __init stx7141_configure_usb(int port)
+{
+	static int first = 1;
+	struct sysconf_field *sc;
+	const struct {
+		struct {
+			unsigned char port, pin, alt;
+		} pwr, oc;
+	} usb_pins[4] = {
+		{ { 4, 7, 1 }, { 4, 6, 1 } },
+		{ { 5, 1, 1 }, { 5, 2, 1 } },
+		{ { 4, 3, 1 }, { 4, 2, 1 } },
+		{ { 4, 5, 1 }, { 4, 4, 1 } }
+	};
+
+	if (first) {
+		/* ENABLE_USB48_CLK: Enable 48 MHz clock */
+		sc = sysconf_claim(SYS_CFG, 4, 5, 5, "USB");
+		sysconf_write(sc, 1);
+
+		first = 0;
+	}
+
+	/* Power up USB */
+	sc = sysconf_claim(SYS_CFG, 32, 7+port, 7+port, "USB");
+	sysconf_write(sc, 0);
+	sc = sysconf_claim(SYS_STA, 15, 7+port, 7+port, "USB");
+	do {
+	} while (sysconf_read(sc));
+
+	stx7141_pio_sysconf(usb_pins[port].pwr.port,
+			    usb_pins[port].pwr.pin,
+			    usb_pins[port].pwr.alt, "USB");
+	stpio_request_pin(usb_pins[port].pwr.port,
+			  usb_pins[port].pwr.pin, "USB", STPIO_OUT);
+
+	stx7141_pio_sysconf(usb_pins[port].oc.port,
+			    usb_pins[port].oc.pin,
+			    usb_pins[port].oc.alt, "USB");
+	if (port > 1) {
+		/* Overcurrent detection is active high, so force
+		 * the pin low. */
+		stpio_request_set_pin(usb_pins[port].oc.port,
+				      usb_pins[port].oc.pin, "USB",
+				      STPIO_OUT, 0);
+	} else {
+		stpio_request_pin(usb_pins[port].oc.port,
+				  usb_pins[port].oc.pin, "USB", STPIO_IN);
+	}
+
+	platform_device_register(&st40_ohci_devices[port]);
+	if (port < 2)
+		platform_device_register(&st40_ehci_devices[port]);
+}
+
+/* FDMA resources ---------------------------------------------------------- */
+
+#ifdef CONFIG_STM_DMA
+
+#include <linux/stm/7200_cut1_fdma2_firmware.h>
+
+static struct fdma_regs stx7141_fdma_regs = {
+	.fdma_id = FDMA2_ID,
+	.fdma_ver = FDAM2_VER,
+	.fdma_en = FDMA2_ENABLE_REG,
+	.fdma_clk_gate = FDMA2_CLOCKGATE,
+	.fdma_rev_id = FDMA2_REV_ID,
+	.fdma_cmd_statn = STB7200_FDMA_CMD_STATn_REG,
+	.fdma_ptrn = STB7200_FDMA_PTR_REG,
+	.fdma_cntn = STB7200_FDMA_COUNT_REG,
+	.fdma_saddrn = STB7200_FDMA_SADDR_REG,
+	.fdma_daddrn = STB7200_FDMA_DADDR_REG,
+	.fdma_req_ctln = STB7200_FDMA_REQ_CTLn_REG,
+	.fdma_cmd_sta = FDMA2_CMD_MBOX_STAT_REG,
+	.fdma_cmd_set = FDMA2_CMD_MBOX_SET_REG,
+	.fdma_cmd_clr = FDMA2_CMD_MBOX_CLR_REG,
+	.fdma_cmd_mask = FDMA2_CMD_MBOX_MASK_REG,
+	.fdma_int_sta = FDMA2_INT_STAT_REG,
+	.fdma_int_set = FDMA2_INT_SET_REG,
+	.fdma_int_clr = FDMA2_INT_CLR_REG,
+	.fdma_int_mask = FDMA2_INT_MASK_REG,
+	.fdma_sync_reg = FDMA2_SYNCREG,
+	.fdma_dmem_region = STX7141_DMEM_OFFSET,
+	.fdma_imem_region = STX7141_IMEM_OFFSET,
+};
+
+static struct fdma_platform_device_data stx7141_fdma0_plat_data = {
+	.registers_ptr = &stx7141_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7200_v1.4.bin",
+	.fw.data_reg = (unsigned long *)&STB7200_DMEM_REGION,
+	.fw.imem_reg = (unsigned long *)&STB7200_IMEM_REGION,
+	.fw.imem_fw_sz = STB7200_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7200_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7200_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7200_IMEM_REGION_LENGTH
+};
+
+
+static struct fdma_platform_device_data stx7141_fdma1_plat_data = {
+	.registers_ptr = &stx7141_fdma_regs,
+	.min_ch_num = CONFIG_MIN_STM_DMA_CHANNEL_NR,
+	.max_ch_num = CONFIG_MAX_STM_DMA_CHANNEL_NR,
+	.fw_device_name = "stb7200_v1.4.bin",
+	.fw.data_reg = (unsigned long *)&STB7200_DMEM_REGION,
+	.fw.imem_reg = (unsigned long *)&STB7200_IMEM_REGION,
+	.fw.imem_fw_sz = STB7200_IMEM_FIRMWARE_SZ,
+	.fw.dmem_fw_sz = STB7200_DMEM_FIRMWARE_SZ,
+	.fw.dmem_len = STB7200_DMEM_REGION_LENGTH,
+	.fw.imem_len = STB7200_IMEM_REGION_LENGTH
+};
+
+#define stx7141_fdma0_plat_data_addr &stx7141_fdma0_plat_data
+#define stx7141_fdma1_plat_data_addr &stx7141_fdma1_plat_data
+#else
+#define stx7141_fdma0_plat_data_addr NULL
+#define stx7141_fdma1_plat_data_addr NULL
+#endif /* CONFIG_STM_DMA */
+
+static struct platform_device fdma0_device = {
+	.name		= "stmfdma",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource = (struct resource[2]) {
+		[0] = {
+			.start = STX7141_FDMA0_BASE,
+			.end   = STX7141_FDMA0_BASE + 0xffff,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = LINUX_FDMA0_STX7141_IRQ_VECT,
+			.end   = LINUX_FDMA0_STX7141_IRQ_VECT,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = stx7141_fdma0_plat_data_addr,
+	},
+};
+
+static struct platform_device fdma1_device = {
+	.name		= "stmfdma",
+	.id		= 1,
+	.resource = (struct resource[2]) {
+		[0] = {
+			.start = STX7141_FDMA1_BASE,
+			.end   = STX7141_FDMA1_BASE + 0xffff,
+			.flags = IORESOURCE_MEM,
+		},
+		[1] = {
+			.start = LINUX_FDMA1_STX7141_IRQ_VECT,
+			.end   = LINUX_FDMA1_STX7141_IRQ_VECT,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = stx7141_fdma1_plat_data_addr,
+	},
+};
+
+static struct platform_device fdma_xbar_device = {
+	.name		= "fdma-xbar",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[1]) {
+		{
+			.start	= STX7141_XBAR_BASE,
+			.end	= STX7141_XBAR_BASE+(4*1024)-1,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+/* SSC resources ----------------------------------------------------------- */
+
+static char i2c_st[] = "i2c_st";
+static char spi_st[] = "spi_st";
+
+static struct platform_device stssc_devices[] = {
+	STSSC_DEVICE(0xfd040000, ILC_IRQ(69), 2, 0, 1, 2),
+	STSSC_DEVICE(0xfd041000, ILC_IRQ(70), 2, 3, 4, 5),
+	STSSC_DEVICE(0xfd042000, ILC_IRQ(71), 2, 6, 7, 0xff),
+	STSSC_DEVICE(0xfd043000, ILC_IRQ(72), 3, 0, 1, 0xff),
+	STSSC_DEVICE(0xfd044000, ILC_IRQ(73), 3, 2, 3, 0xff),
+	STSSC_DEVICE(0xfd045000, ILC_IRQ(74), 3, 4, 5, 6),
+	STSSC_DEVICE(0xfd046000, ILC_IRQ(75), 4, 0, 1, 0xff),
+};
+
+void __init stx7141_configure_ssc(struct plat_ssc_data *data)
+{
+	int num_i2c = 0;
+	int num_spi = 0;
+	int i;
+	int capability = data->capability;
+	int pin;
+
+	for (i = 0; i < ARRAY_SIZE(stssc_devices); i++, capability >>= 2) {
+		struct ssc_pio_t *ssc_pio = stssc_devices[i].dev.platform_data;
+
+		if (capability & SSC_UNCONFIGURED)
+			continue;
+
+		for (pin = 0; pin < 3; pin++) {
+			int portno = ssc_pio->pio[pin].pio_port;
+			int pinno  = ssc_pio->pio[pin].pio_pin;
+
+			if ((pin == 2) && !(capability & SSC_SPI_CAPABILITY))
+				continue;
+
+#ifdef CONFIG_I2C_ST40_PIO
+			stx7141_pio_sysconf(portno, pinno, 0, "ssc");
+#else
+			stx7141_pio_sysconf(portno, pinno, 1, "ssc");
+#endif
+		}
+
+		if (capability & SSC_SPI_CAPABILITY) {
+			stssc_devices[i].name = spi_st;
+			stssc_devices[i].id = num_spi++;
+		} else {
+			stssc_devices[i].name = i2c_st;
+			stssc_devices[i].id = num_i2c++;
+		}
+
+		platform_device_register(&stssc_devices[i]);
+	}
+
+	/* I2C buses number reservation (to prevent any hot-plug device
+	 * from using it) */
+#ifdef CONFIG_I2C_BOARDINFO
+	i2c_register_board_info(num_i2c - 1, NULL, 0);
+#endif
+}
+
+/* SATA resources ---------------------------------------------------------- */
+
+static struct plat_sata_data sata_private_info = {
+	.phy_init = 0,
+	.pc_glue_logic_init = 0,
+	.only_32bit = 0,
+};
+
+static struct platform_device sata_device =
+	SATA_DEVICE(0, 0xfe209000, ILC_IRQ(89), ILC_IRQ(88),
+		    &sata_private_info);
+
+void __init stx7141_configure_sata(void)
+{
+	platform_device_register(&sata_device);
+}
+
+/* PATA resources ---------------------------------------------------------- */
+
+/*
+ * EMI A20 = CS1 (active low)
+ * EMI A21 = CS0 (active low)
+ * EMI A19 = DA2
+ * EMI A18 = DA1
+ * EMI A17 = DA0
+ */
+
+static struct resource pata_resources[] = {
+	[0] = {	/* I/O base: CS1=N, CS0=A */
+		.start	= (1<<20),
+		.end	= (1<<20) + (8<<17)-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {	/* CTL base: CS1=A, CS0=N, DA2=A, DA1=A, DA0=N */
+		.start	= (1<<21) + (6<<17),
+		.end	= (1<<21) + (6<<17) + 3,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {	/* IRQ */
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct pata_platform_info pata_info = {
+	.ioport_shift	= 17,
+};
+
+static struct platform_device pata_device = {
+	.name		= "pata_platform",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(pata_resources),
+	.resource	= pata_resources,
+	.dev = {
+		.platform_data = &pata_info,
+	}
+};
+
+void __init stx7141_configure_pata(int bank, int pc_mode, int irq)
+{
+	unsigned long bank_base;
+
+	bank_base = emi_bank_base(bank);
+	pata_resources[0].start += bank_base;
+	pata_resources[0].end   += bank_base;
+	pata_resources[1].start += bank_base;
+	pata_resources[1].end   += bank_base;
+	pata_resources[2].start = irq;
+	pata_resources[2].end   = irq;
+
+	emi_config_pata(bank, pc_mode);
+
+	platform_device_register(&pata_device);
+}
+
+/* Ethernet MAC resources -------------------------------------------------- */
+
+static void fix_mac_speed(void *priv, unsigned int speed)
+{
+	struct sysconf_field *sc = priv;
+
+	sysconf_write(sc, (speed == SPEED_100) ? 0 : 1);
+}
+
+static struct plat_stmmacenet_data stx7141eth_private_data[2] = {
+{
+	.bus_id = 0,
+	.pbl = 8,
+	.has_gmac = 1,
+	.fix_mac_speed = fix_mac_speed,
+	.bsp_priv = 0,
+}, {
+	.bus_id = 1,
+	.pbl = 8,
+	.has_gmac = 1,
+	.fix_mac_speed = fix_mac_speed,
+	.bsp_priv = 1,
+} };
+
+static struct platform_device stx7141eth_devices[2] = {
+{
+	.name		= "stmmaceth",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd110000,
+			.end	= 0xfd117fff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "macirq",
+			.start	= ILC_IRQ(40),
+			.end	= ILC_IRQ(40),
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &stx7141eth_private_data[0],
+	}
+}, {
+	.name		= "stmmaceth",
+	.id		= 1,
+	.num_resources	= 2,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd118000,
+			.end	= 0xfd11ffff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "macirq",
+			.start	= ILC_IRQ(47),
+			.end	= ILC_IRQ(47),
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &stx7141eth_private_data[1],
+	}
+} };
+
+void stx7141_configure_ethernet(int port, int reverse_mii, int mode,
+				int phy_bus)
+{
+	struct sysconf_field *sc;
+	int i;
+	struct {
+		struct {
+			unsigned char port, pin, alt;
+		} pio[2];
+		unsigned char dir;
+	} mii_pins[] = {
+		{ { {  8, 0, 1 }, { 11, 4, 1 } }, STPIO_IN  },	/* TXCLK */
+		{ { {  8, 1, 1 }, { 11, 5, 1 } }, STPIO_OUT },	/* TXEN */
+		{ { {  8, 2, 1 }, { 11, 6, 1 } }, STPIO_OUT },	/* TXER */
+		{ { {  8, 3, 1 }, { 11, 7, 1 } }, STPIO_OUT },	/* TXD[0] */
+		{ { {  8, 4, 1 }, { 12, 0, 1 } }, STPIO_OUT },	/* TXD[1] */
+		{ { {  8, 5, 1 }, { 12, 1, 1 } }, STPIO_OUT },	/* TXD[2] */
+		{ { {  8, 6, 1 }, { 12, 2, 1 } }, STPIO_OUT },	/* TXD[3] */
+		{ { {  8, 7, 1 }, { 12, 3, 1 } }, STPIO_OUT },	/* TXD[4] */
+		{ { {  9, 0, 1 }, { 12, 4, 1 } }, STPIO_OUT },	/* TXD[5] */
+		{ { {  9, 1, 1 }, { 12, 5, 1 } }, STPIO_OUT },	/* TXD[6] */
+		{ { {  9, 2, 1 }, { 12, 6, 1 } }, STPIO_OUT },	/* TXD[7] */
+		{ { {  9, 3, 1 }, { 12, 7, 1 } }, STPIO_IN  },	/* RXCLK */
+		{ { {  9, 4, 1 }, { 13, 0, 1 } }, STPIO_IN  },	/* RXDV */
+		{ { {  9, 5, 1 }, { 13, 1, 1 } }, STPIO_IN  },	/* RX_ER */
+		{ { {  9, 6, 1 }, { 13, 2, 1 } }, STPIO_IN  },	/* RXD[0] */
+		{ { {  9, 7, 1 }, { 13, 3, 1 } }, STPIO_IN  },	/* RXD[1] */
+		{ { { 10, 0, 1 }, { 13, 4, 1 } }, STPIO_IN  },	/* RXD[2] */
+		{ { { 10, 1, 1 }, { 13, 5, 1 } }, STPIO_IN  },	/* RXD[3] */
+		{ { { 10, 2, 1 }, { 13, 6, 1 } }, STPIO_IN  },	/* RXD[4] */
+		{ { { 10, 3, 1 }, { 13, 7, 1 } }, STPIO_IN  },	/* RXD[5] */
+		{ { { 10, 4, 1 }, { 14, 0, 1 } }, STPIO_IN  },	/* RXD[6] */
+		{ { { 10, 5, 1 }, { 14, 1, 1 } }, STPIO_IN  },	/* RXD[7] */
+		{ { { 10, 6, 1 }, { 14, 2, 1 } }, STPIO_IN  },	/* CRS */
+		{ { { 10, 7, 1 }, { 14, 3, 1 } }, STPIO_IN  },	/* COL */
+		{ { { 11, 0, 1 }, { 14, 4, 1 } }, STPIO_OUT },	/* MDC */
+		{ { { 11, 1, 1 }, { 14, 5, 1 } }, STPIO_BIDIR },/* MDIO */
+		{ { { 11, 2, 1 }, { 14, 6, 1 } }, STPIO_IN  },	/* MDINT */
+		{ { { 11, 3, 1 }, { 14, 7, 1 } }, STPIO_OUT },	/* PHYCLK */
+	};
+
+	stx7141eth_private_data[port].bus_id = phy_bus;
+
+	/* gmac_en: GMAC Enable */
+	sc = sysconf_claim(SYS_CFG, 7, 16+port, 16+port, "stmmac");
+	sysconf_write(sc, 1);
+
+	/* enmii: Interface type (rev MII/MII) */
+	sc = sysconf_claim(SYS_CFG, 7, port ? 31 : 27, port ? 31 : 27,
+			   "stmmac");
+	sysconf_write(sc, reverse_mii ? 0 : 1);
+
+	/* mac_speed */
+	stx7141eth_private_data[port].bsp_priv =
+		sysconf_claim(SYS_CFG, 7, 20+port, 20+port, "stmmac");
+
+	/* phy_intf_sel[2;0] : PHY Interface Selection */
+	/* Note the that MSB implicitly also set mii_mode */
+	sc = sysconf_claim(SYS_CFG, 7,
+			   port ? 28 : 24, port ? 30 : 26, "stmmac");
+	sysconf_write(sc, mode);
+
+	for (i = 0; i < ARRAY_SIZE(mii_pins); i++) {
+		stx7141_pio_sysconf(mii_pins[i].pio[port].port,
+				    mii_pins[i].pio[port].pin,
+				    mii_pins[i].pio[port].alt, "eth");
+		stpio_request_pin(mii_pins[i].pio[port].port,
+				  mii_pins[i].pio[port].pin,
+				  "eth",
+				  mii_pins[i].dir);
+	}
+
+	platform_device_register(&stx7141eth_devices[port]);
+}
+
+/* PWM resources ----------------------------------------------------------- */
+
+static struct resource stm_pwm_resource[] = {
+	[0] = {
+		.start	= 0xfd010000,
+		.end	= 0xfd010000 + 0x67,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start	= ILC_IRQ(85),
+		.end	= ILC_IRQ(85),
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct platform_device stm_pwm_device = {
+	.name		= "stm-pwm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
+	.resource	= stm_pwm_resource,
+};
+
+void stx7141_configure_pwm(struct plat_stm_pwm_data *data)
+{
+	int pwm;
+	const struct {
+		unsigned char port, pin, alt;
+	} pwm_pios[2] = {
+		{ 3, 4, 2 },	/* PWM0 */
+		{ 4, 2, 2 },	/* PWM1 */
+	};
+
+	stm_pwm_device.dev.platform_data = data;
+
+	for (pwm = 0; pwm < 2; pwm++) {
+		if (data->flags & (1<<pwm)) {
+			int port = pwm_pios[pwm].port;
+			int pin  = pwm_pios[pwm].pin;
+			int alt  = pwm_pios[pwm].alt;
+
+			stx7141_pio_sysconf(port, pin, alt, "pwm");
+			stpio_request_pin(port, pin, "pwm", STPIO_ALT_OUT);
+		}
+	}
+
+	platform_device_register(&stm_pwm_device);
+}
+
+/* Hardware RNG resources -------------------------------------------------- */
+
+static struct platform_device hwrandom_rng_device = {
+	.name	   = "stm_hwrandom",
+	.id	     = -1,
+	.num_resources  = 1,
+	.resource       = (struct resource[]){
+		{
+			.start  = 0xfe250000,
+			.end    = 0xfe250fff,
+			.flags  = IORESOURCE_MEM
+		},
+	}
+};
+
+static struct platform_device devrandom_rng_device = {
+	.name           = "stm_rng",
+	.id             = 0,
+	.num_resources  = 1,
+	.resource       = (struct resource[]){
+		{
+			.start  = 0xfe250000,
+			.end    = 0xfe250fff,
+			.flags  = IORESOURCE_MEM
+		},
+	}
+};
+
+/* ASC resources ----------------------------------------------------------- */
+
+static struct platform_device stm_stasc_devices[] = {
+	/* 7141: Checked except pacing */
+	STASC_DEVICE(0xfd030000, ILC_IRQ(76), 11, 15,
+		     -1, -1, -1, -1, -1),
+	STASC_DEVICE(0xfd031000, ILC_IRQ(77), 12, 16,
+		     -1, -1, -1, -1, -1),
+	STASC_DEVICE(0xfd032000, ILC_IRQ(78), 13, 17,
+		     -1, -1, -1, -1, -1),
+};
+
+/*
+ * Note these three variables are global, and shared with the stasc driver
+ * for console bring up prior to platform initialisation.
+ */
+
+/* the serial console device */
+int stasc_console_device __initdata;
+
+/* Platform devices to register */
+struct platform_device *stasc_configured_devices[ARRAY_SIZE(stm_stasc_devices)]
+	__initdata;
+unsigned int stasc_configured_devices_count __initdata = 0;
+
+/* Configure the ASC's for this board.
+ * This has to be called before console_init().
+ */
+#include <linux/delay.h>
+void __init stx7141_configure_asc(const int *ascs, int num_ascs, int console)
+{
+	int i;
+
+	for (i = 0; i < num_ascs; i++) {
+		int port;
+		unsigned char flags;
+		struct platform_device *pdev;
+		struct stasc_uart_data *uart_data;
+		struct sysconf_field *sc;
+		int pio_port = -1;
+
+		port = ascs[i] & 0xff;
+		flags = ascs[i] >> 8;
+		pdev = &stm_stasc_devices[port];
+		uart_data = pdev->dev.platform_data;
+
+		switch (port) {
+		case 0:
+			/* Mcard routing only */
+			BUG();	/* TODO */
+			break;
+		case 1:
+			sc = sysconf_claim(SYS_CFG, 36, 29, 29, "asc");
+			if (flags & ASC1_PIO10) {
+				pio_port = 10;
+				sysconf_write(sc, 0);
+			} else {
+				BUG();	/* TODO */
+			}
+			break;
+		case 2:
+			sc = sysconf_claim(SYS_CFG, 36, 30, 31, "asc");
+			if (flags & ASC2_PIO6) {
+				pio_port = 6;
+				sysconf_write(sc, 3);
+			} else {
+				pio_port = 1;
+				sysconf_write(sc, 0);
+			}
+			break;
+		default:
+			BUG();
+		}
+
+		uart_data->pio_port = pio_port;
+
+		if (pio_port) {
+			/* Tx */
+			stx7141_pio_sysconf(pio_port, 0, 3, "asc");
+			uart_data->pio_pin[0] = 0;
+			/* Rx */
+			stx7141_pio_sysconf(pio_port, 1, 3, "asc");
+			uart_data->pio_pin[1] = 1;
+		}
+
+		if (!(flags & STASC_FLAG_NORTSCTS)) {
+			/* CTS */
+			stx7141_pio_sysconf(pio_port, 2, 3, "asc");
+			uart_data->pio_pin[2] = 2;
+			/* RTS */
+			stx7141_pio_sysconf(pio_port, 2, 3, "asc");
+			uart_data->pio_pin[3] = 3;
+		}
+		pdev->id = i;
+		((struct stasc_uart_data *)(pdev->dev.platform_data))->flags =
+			flags;
+		stasc_configured_devices[stasc_configured_devices_count] = pdev;
+		stasc_configured_devices_count++;
+	}
+
+	stasc_console_device = console;
+}
+
+/* Add platform device as configured by board specific code */
+static int __init stx7141_add_asc(void)
+{
+	return platform_add_devices(stasc_configured_devices,
+				    stasc_configured_devices_count);
+}
+arch_initcall(stx7141_add_asc);
+
+#if 0
+/* LiRC resources ---------------------------------------------------------- */
+static struct lirc_pio lirc_pios[] = {
+	[0] = {
+		.bank  = 3,
+		.pin   = 3,
+		.dir   = STPIO_IN,
+		.pinof = 0x00 | LIRC_IR_RX | LIRC_PIO_ON
+	},
+	[1] = {
+		.bank  = 3,
+		.pin   = 4,
+		.dir   = STPIO_IN,
+		.pinof = 0x00 | LIRC_UHF_RX /* | LIRC_PIO_ON not available */
+		},
+	[2] = {
+		.bank  = 3,
+		.pin   = 5,
+		.dir   = STPIO_ALT_OUT,
+		.pinof = 0x00 | LIRC_IR_TX | LIRC_PIO_ON
+	},
+	[3] = {
+		.bank  = 3,
+		.pin   = 6,
+		.dir   = STPIO_ALT_OUT,
+		.pinof = 0x00 | LIRC_IR_TX | LIRC_PIO_ON
+	},
+};
+
+static struct plat_lirc_data lirc_private_info = {
+	/* For the 7141, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv	= 0, /* automatically calculate */
+	.irbperiodmult	= 0,
+	.irbperioddiv	= 0,
+	.irbontimemult	= 0,
+	.irbontimediv	= 0,
+	.irbrxmaxperiod = 0x5000,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1,
+	.pio_pin_arr  = lirc_pios,
+	.num_pio_pins = ARRAY_SIZE(lirc_pios)
+};
+
+static struct resource lirc_resource[] = {
+	[0] = {
+		.start = 0xfd018000,
+		.end   = 0xfd018000 + 0xa0,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = evt2irq(0x11a0),
+		.end   = evt2irq(0x11a0),
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct platform_device lirc_device = {
+	.name		= "lirc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(lirc_resource),
+	.resource	= lirc_resource,
+	.dev = {
+		   .platform_data = &lirc_private_info
+	}
+};
+
+void __init stx7141_configure_lirc(void)
+{
+	platform_device_register(&lirc_device);
+}
+#endif
+
+/* NAND Resources ---------------------------------------------------------- */
+
+static void nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+
+		if (ctrl & NAND_CLE)
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W |
+				 (unsigned int)(1 << 17));
+		else
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W &
+				 ~(unsigned int)(1 << 17));
+
+		if (ctrl & NAND_ALE)
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W |
+				 (unsigned int)(1 << 18));
+		else
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W &
+				 ~(unsigned int)(1 << 18));
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+static void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	/* write buf up to 4-byte boundary */
+	while ((unsigned int)buf & 0x3) {
+		writeb(*buf++, chip->IO_ADDR_W);
+		len--;
+	}
+
+	writesl(chip->IO_ADDR_W, buf, len/4);
+
+	/* mop up trailing bytes */
+	for (i = (len & ~0x3); i < len; i++)
+		writeb(buf[i], chip->IO_ADDR_W);
+}
+
+static void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	/* read buf up to 4-byte boundary */
+	while ((unsigned int)buf & 0x3) {
+		*buf++ = readb(chip->IO_ADDR_R);
+		len--;
+	}
+
+	readsl(chip->IO_ADDR_R, buf, len/4);
+
+	/* mop up trailing bytes */
+	for (i = (len & ~0x3); i < len; i++)
+		buf[i] = readb(chip->IO_ADDR_R);
+}
+
+static const char *nand_part_probes[] = { "cmdlinepart", NULL };
+
+static struct platform_device nand_flash[] = {
+	EMI_NAND_DEVICE(0),
+	EMI_NAND_DEVICE(1),
+	EMI_NAND_DEVICE(2),
+	EMI_NAND_DEVICE(3),
+	EMI_NAND_DEVICE(4),
+ };
+
+
+/*
+ * stx7141_configure_nand - Configures NAND support for the STx7141
+ *
+ * Requires generic platform NAND driver (CONFIG_MTD_NAND_PLATFORM).
+ * Uses 'gen_nand.x' as ID for specifying MTD partitions on the kernel
+ * command line.
+ */
+void __init stx7141_configure_nand(struct nand_config_data *data)
+{
+	unsigned int bank_base, bank_end;
+	unsigned int emi_bank = data->emi_bank;
+
+	struct platform_nand_data *nand_private_data =
+		nand_flash[emi_bank].dev.platform_data;
+
+	bank_base = emi_bank_base(emi_bank) + data->emi_withinbankoffset;
+	if (emi_bank == 4)
+		bank_end = 0x07ffffff;
+	else
+		bank_end = emi_bank_base(emi_bank+1) - 1;
+
+	printk(KERN_INFO "Configuring EMI Bank%d for NAND device\n", emi_bank);
+	emi_config_nand(data->emi_bank, data->emi_timing_data);
+
+	nand_flash[emi_bank].resource[0].start = bank_base;
+	nand_flash[emi_bank].resource[0].end = bank_end;
+
+	nand_private_data->chip.chip_delay = data->chip_delay;
+	nand_private_data->chip.partitions = data->mtd_parts;
+	nand_private_data->chip.nr_partitions = data->nr_parts;
+
+	platform_device_register(&nand_flash[emi_bank]);
+}
+
+/* Early resources (sysconf and PIO) --------------------------------------- */
+
+static struct platform_device sysconf_device = {
+	.name		= "sysconf",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfe001000,
+			.end	= 0xfe001000 + 0x1df,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+	.dev = {
+		.platform_data = &(struct plat_sysconf_data) {
+			.sys_device_offset = 0,
+			.sys_sta_offset = 8,
+			.sys_cfg_offset = 0x100,
+		}
+	}
+};
+
+static struct platform_device stpio_devices[] = {
+	STPIO_DEVICE(1, 0xfd020000, ILC_IRQ(49)),
+	STPIO_DEVICE(2, 0xfd021000, ILC_IRQ(50)),
+	STPIO_DEVICE(3, 0xfd022000, ILC_IRQ(51)),
+	STPIO_DEVICE(4, 0xfd023000, ILC_IRQ(52)),
+	STPIO_DEVICE(5, 0xfd024000, ILC_IRQ(53)),
+	STPIO_DEVICE(6, 0xfd025000, ILC_IRQ(54)),
+	STPIO_DEVICE(7, 0xfd026000, ILC_IRQ(55)),
+
+	STPIO_DEVICE(8, 0xfe010000, ILC_IRQ(59)),
+	STPIO_DEVICE(9, 0xfe011000, ILC_IRQ(60)),
+	STPIO_DEVICE(10, 0xfe012000, ILC_IRQ(61)),
+	STPIO_DEVICE(11, 0xfe013000, ILC_IRQ(62)),
+	STPIO_DEVICE(12, 0xfe014000, ILC_IRQ(63)),
+	STPIO_DEVICE(13, 0xfe015000, ILC_IRQ(64)),
+	STPIO_DEVICE(14, 0xfe016000, ILC_IRQ(65)),
+	STPIO_DEVICE(15, 0xfe017000, ILC_IRQ(66)),
+	STPIO_DEVICE(16, 0xfe018000, ILC_IRQ(67)),
+};
+
+/* Initialise devices which are required early in the boot process. */
+void __init stx7141_early_device_init(void)
+{
+	struct sysconf_field *sc;
+	unsigned long devid;
+	unsigned long chip_revision;
+
+	/* Initialise PIO and sysconf drivers */
+
+	sysconf_early_init(&sysconf_device);
+	stpio_early_init(stpio_devices, ARRAY_SIZE(stpio_devices),
+			 ILC_FIRST_IRQ+ILC_NR_IRQS);
+
+	sc = sysconf_claim(SYS_DEV, 0, 0, 31, "devid");
+	devid = sysconf_read(sc);
+	chip_revision = (devid >> 28) + 1;
+	boot_cpu_data.cut_major = chip_revision;
+
+	printk(KERN_INFO "STx7141 version %ld.x\n", chip_revision);
+
+	/* We haven't configured the LPC, so the sleep instruction may
+	 * do bad things. Thus we disable it here. */
+	disable_hlt();
+}
+
+static void __init pio_late_setup(void)
+{
+	int i;
+	struct platform_device *pdev = stpio_devices;
+
+	for (i = 0; i < ARRAY_SIZE(stpio_devices); i++, pdev++)
+		platform_device_register(pdev);
+}
+
+/* This is the eSTB ILC3 */
+static struct platform_device ilc3_device = {
+	.name		= "ilc3",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= (struct resource[]) {
+		{
+			.start	= 0xfd120000,
+			.end	= 0xfd120000 + 0x900,
+			.flags	= IORESOURCE_MEM
+		}
+	},
+};
+
+/* Pre-arch initialisation ------------------------------------------------- */
+
+static int __init stx7141_postcore_setup(void)
+{
+	emi_init(0, 0xfe700000);
+
+	return 0;
+}
+postcore_initcall(stx7141_postcore_setup);
+
+/* Late resources ---------------------------------------------------------- */
+
+static int __init stx7141_subsys_setup(void)
+{
+	/* we need to do PIO setup before module init, because some
+	 * drivers (eg gpio-keys) require that the interrupts
+	 * are available. */
+	pio_late_setup();
+
+	return 0;
+}
+subsys_initcall(stx7141_subsys_setup);
+
+static struct platform_device *stx7141_devices[] __initdata = {
+	&fdma0_device,
+	&fdma1_device,
+	&fdma_xbar_device,
+	&sysconf_device,
+	&ilc3_device,
+	&hwrandom_rng_device,
+	&devrandom_rng_device,
+};
+
+static int __init stx7141_devices_setup(void)
+{
+	return platform_add_devices(stx7141_devices,
+				    ARRAY_SIZE(stx7141_devices));
+}
+device_initcall(stx7141_devices_setup);
+
+/* Interrupt initialisation ------------------------------------------------ */
+
+enum {
+	UNUSED = 0,
+
+	/* interrupt sources */
+	IRL0, IRL1, IRL2, IRL3, /* only IRLM mode described here */
+	TMU0, TMU1, TMU2_TUNI, TMU2_TICPI,
+	WDT,
+	HUDI,
+
+	/* interrupt groups */
+	TMU2, RTC,
+};
+
+static struct intc_vect vectors[] = {
+	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
+	INTC_VECT(TMU2_TUNI, 0x440), INTC_VECT(TMU2_TICPI, 0x460),
+	INTC_VECT(WDT, 0x560),
+	INTC_VECT(HUDI, 0x600),
+};
+
+static struct intc_group groups[] = {
+	INTC_GROUP(TMU2, TMU2_TUNI, TMU2_TICPI),
+};
+
+static struct intc_prio priorities[] = {
+};
+
+static struct intc_prio_reg prio_registers[] = {
+					   /*   15-12, 11-8,  7-4,   3-0 */
+	{ 0xffd00004, 0, 16, 4, /* IPRA */     { TMU0, TMU1, TMU2,       } },
+	{ 0xffd00008, 0, 16, 4, /* IPRB */     {  WDT,    0,    0,     0 } },
+	{ 0xffd0000c, 0, 16, 4, /* IPRC */     {    0,    0,    0,  HUDI } },
+	{ 0xffd00010, 0, 16, 4, /* IPRD */     { IRL0, IRL1,  IRL2, IRL3 } },
+};
+
+static DECLARE_INTC_DESC(intc_desc, "stx7111", vectors, groups,
+			 priorities, NULL, prio_registers, NULL);
+
+void __init plat_irq_setup(void)
+{
+	unsigned long intc2_base = (unsigned long)ioremap(0xfe001000, 0x400);
+
+	register_intc_controller(&intc_desc);
+
+	ilc_early_init(&ilc3_device);
+
+	/*
+	 * Currently we route all ILC3 interrupts to the 0'th output,
+	 * which is connected to INTC2: group 0 interrupt 0.
+	 */
+
+	/* Enable the INTC2 */
+	writel(7, intc2_base + 0x300);	/* INTPRI00 */
+	writel(1, intc2_base + 0x360);	/* INTMSKCLR00 */
+
+	/* Set up the demux function */
+	set_irq_chip(evt2irq(0xa00), &dummy_irq_chip);
+	set_irq_chained_handler(evt2irq(0xa00), ilc_irq_demux);
+
+	ilc_demux_init();
+}
Index: linux-2.6.23-stm/arch/sh/kernel/setup.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/setup.c
+++ linux-2.6.23-stm/arch/sh/kernel/setup.c
@@ -326,7 +326,8 @@ static const char *cpu_name[] = {
 	[CPU_ST40RA]	= "ST40RA",	[CPU_ST40GX1]	= "ST40GX1",
 	[CPU_STB7100]	= "STb7100",	[CPU_STX7105]	= "STx7105",
 	[CPU_STB7109]	= "STb7109",
-	[CPU_STX7200]	= "STx7200",    [CPU_ST40_300]	= "ST40-300",
+	[CPU_STX7111]	= "STx7111",	[CPU_STX7141]	= "STx7141",
+	[CPU_STX7200]	= "STx7200",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
Index: linux-2.6.23-stm/arch/sh/mm/Kconfig
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/mm/Kconfig
+++ linux-2.6.23-stm/arch/sh/mm/Kconfig
@@ -190,6 +190,13 @@ config CPU_SUBTYPE_STX7111
 	help
 	  Select STX7111 if you have an STx7111 CPU.
 
+config CPU_SUBTYPE_STX7141
+	bool "Support STx7141 processors"
+	select CPU_SUBTYPE_ST40
+	select SUPPORTS_32BIT
+	help
+	  Select STX7141 if you have an STx7141 CPU.
+
 config CPU_SUBTYPE_STX7200
 	bool "Support STx7200 processor"
 	select CPU_SUBTYPE_ST40
Index: linux-2.6.23-stm/include/asm-sh/processor.h
===================================================================
--- linux-2.6.23-stm.orig/include/asm-sh/processor.h
+++ linux-2.6.23-stm/include/asm-sh/processor.h
@@ -51,7 +51,8 @@ enum cpu_type {
 	/* SH-4 types */
 	CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
 	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_STI5528, CPU_STM8000,
-	CPU_STB7100, CPU_STX7105, CPU_STB7109, CPU_STX7200, CPU_ST40_300,
+	CPU_STB7100, CPU_STX7105, CPU_STB7109, CPU_STX7111, CPU_STX7141,
+	CPU_STX7200,
 	CPU_SH4_202, CPU_SH4_501,
 
 	/* SH-4A types */
Index: linux-2.6.23-stm/sound/stm/stx7111.c
===================================================================
--- linux-2.6.23-stm.orig/sound/stm/stx7111.c
+++ linux-2.6.23-stm/sound/stm/stx7111.c
@@ -504,8 +504,7 @@ static int __init snd_stm_stx7111_init(v
 
 	snd_stm_printd(0, "snd_stm_stx7111_init()\n");
 
-	/* TODO: 7111 is identified now as ST40-300... */
-	if (cpu_data->type != CPU_ST40_300) {
+	if (cpu_data->type != CPU_STX7111) {
 		snd_stm_printe("Not supported (other than STx7111) SOC "
 				"detected!\n");
 		result = -EINVAL;
Index: linux-2.6.23-stm/arch/sh/boards/st/mb628/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/arch/sh/boards/st/mb628/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STx7141 Mboard (mb628) board
+#
+
+obj-y := setup.o
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/Makefile
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/Makefile
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/Makefile
@@ -20,5 +20,6 @@ archclock-y					:= clock-cpg.o
 archclock-$(CONFIG_CPU_SUBTYPE_STB7100)	:=
 archclock-$(CONFIG_CPU_SUBTYPE_STX7105)	:=
 archclock-$(CONFIG_CPU_SUBTYPE_STX7111)	:=
+archclock-$(CONFIG_CPU_SUBTYPE_STX7141)	:=
 archclock-$(CONFIG_CPU_SUBTYPE_STX7200)	:=
 obj-y	+= $(archclock-y)
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/irq/Makefile
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/irq/Makefile
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/irq/Makefile
@@ -8,4 +8,5 @@ obj-$(CONFIG_CPU_HAS_MASKREG_IRQ)	+= mas
 obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= st40_ilc_sti5528.o ilc3_common.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7105)	+= st40_ilc_stx7200.o ilc3_common.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7111)	+= st40_ilc_stx7200.o ilc3_common.o
+obj-$(CONFIG_CPU_SUBTYPE_STX7141)	+= st40_ilc_stx7200.o ilc3_common.o
 obj-$(CONFIG_CPU_SUBTYPE_STX7200)	+= st40_ilc_stx7200.o ilc3_common.o
Index: linux-2.6.23-stm/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c
===================================================================
--- linux-2.6.23-stm.orig/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c
+++ linux-2.6.23-stm/arch/sh/kernel/cpu/irq/st40_ilc_stx7200.c
@@ -79,7 +79,8 @@ static struct pr_mask priority_mask[16];
  */
 void ilc_irq_demux(unsigned int irq, struct irq_desc *desc)
 {
-#if	defined(CONFIG_CPU_SUBTYPE_STX7111)
+#if	defined(CONFIG_CPU_SUBTYPE_STX7111) || \
+	defined(CONFIG_CPU_SUBTYPE_STX7141)
 	const unsigned int priority = 7;
 #elif	defined(CONFIG_CPU_SUBTYPE_STX7105) || \
 	defined(CONFIG_CPU_SUBTYPE_STX7200)
@@ -142,6 +143,8 @@ static unsigned int startup_ilc_irq(unsi
 #elif	defined(CONFIG_CPU_SUBTYPE_STX7105) || \
 	defined(CONFIG_CPU_SUBTYPE_STX7200)
 	ILC_SET_PRI(irq_offset, priority);
+#elif	defined(CONFIG_CPU_SUBTYPE_STX7141)
+	ILC_SET_PRI(irq_offset, 0x0);
 #endif
 
 	ILC_SET_ENABLE(irq_offset);
Index: linux-2.6.23-stm/drivers/net/Kconfig
===================================================================
--- linux-2.6.23-stm.orig/drivers/net/Kconfig
+++ linux-2.6.23-stm/drivers/net/Kconfig
@@ -2499,7 +2499,7 @@ config STMMAC_ETH
 	tristate "STMicroelectronics 10/100/1000 Ethernet driver"
 	select MII
 	select PHYLIB
-	depends on NETDEVICES && (CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7105 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200)
+	depends on NETDEVICES && CPU_SUBTYPE_ST40
 	---help---
 	  This is the driver for the MAC 10/100/1000 on-chip Ethernet 
 	  controller (Synopsys Core).
Index: linux-2.6.23-stm/drivers/serial/stasc.c
===================================================================
--- linux-2.6.23-stm.orig/drivers/serial/stasc.c
+++ linux-2.6.23-stm/drivers/serial/stasc.c
@@ -477,10 +477,17 @@ static int asc_remap_port(struct asc_por
 	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
 	int i;
 	static int pio_dirs[4] = {
+#ifdef CONFIG_CPU_SUBTYPE_STX7141
+		STPIO_OUT,	/* Tx */
+		STPIO_IN,	/* Rx */
+		STPIO_IN,	/* CTS */
+		STPIO_OUT	/* RTS */
+#else
 		STPIO_ALT_OUT,	/* Tx */
 		STPIO_IN,	/* Rx */
 		STPIO_IN,	/* CTS */
 		STPIO_ALT_OUT	/* RTS */
+#endif
 	};
 
 	if (req && !request_mem_region(port->mapbase, size, pdev->name))
Index: linux-2.6.23-stm/include/asm-sh/irq-ilc.h
===================================================================
--- linux-2.6.23-stm.orig/include/asm-sh/irq-ilc.h
+++ linux-2.6.23-stm/include/asm-sh/irq-ilc.h
@@ -21,6 +21,11 @@
 #define ILC_INT_IRQ(x)	(ILC_FIRST_IRQ + (x))
 #define ILC_EXT_IRQ(x)	(ILC_FIRST_IRQ + 64 + (x))
 #define ILC_IRQ(x)	ILC_INT_IRQ(x)
+#elif	defined(CONFIG_CPU_SUBTYPE_STX7141)
+/* set this to 65 to allow 64 (INTEVT 0xa00) to demux */
+#define ILC_FIRST_IRQ	65
+#define ILC_NR_IRQS	180
+#define ILC_IRQ(x)	(ILC_FIRST_IRQ + (x))
 #elif defined(CONFIG_CPU_SUBTYPE_STX7200)
 #define ILC_FIRST_IRQ	44
 #define ILC_NR_IRQS	150
Index: linux-2.6.23-stm/include/asm-sh/irq.h
===================================================================
--- linux-2.6.23-stm.orig/include/asm-sh/irq.h
+++ linux-2.6.23-stm/include/asm-sh/irq.h
@@ -8,7 +8,7 @@
  * advised to cap this at the hard limit that they're interested in
  * through the machvec.
  */
-#define NR_IRQS 350
+#define NR_IRQS 400
 
 /*
  * Convert back and forth between INTEVT and IRQ values.
Index: linux-2.6.23-stm/include/linux/stm/soc.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/soc.h
+++ linux-2.6.23-stm/include/linux/stm/soc.h
@@ -218,6 +218,14 @@ extern int stasc_console_device;
 extern struct platform_device *stasc_configured_devices[];
 extern unsigned int stasc_configured_devices_count;
 
+#ifdef CONFIG_CPU_SUBTYPE_STX7141
+#define ASC1_MCARD		0
+#define ASC1_PIO10		2
+
+#define ASC2_PIO1		0
+#define ASC2_PIO6		4
+#endif
+
 struct plat_sysconf_data {
 	int sys_device_offset;
 	int sys_sta_offset;
@@ -275,6 +283,14 @@ void stx7111_configure_ethernet(int en_m
 void stx7111_configure_nand(struct nand_config_data *data);
 void stx7111_configure_lirc(lirc_scd_t *scd);
 
+void stx7141_early_device_init(void);
+void stx7141_configure_asc(const int *ascs, int num_ascs, int console);
+void stx7141_configure_pwm(struct plat_stm_pwm_data *data);
+void stx7141_configure_ssc(struct plat_ssc_data *data);
+void stx7141_configure_usb(int port);
+void stx7141_configure_ethernet(int port, int reverse_mii, int mode,
+				int phy_bus);
+
 void stx7200_early_device_init(void);
 void stx7200_configure_asc(const int *ascs, int num_ascs, int console);
 void stx7200_configure_pwm(struct plat_stm_pwm_data *data);
Index: linux-2.6.23-stm/drivers/leds/Makefile
===================================================================
--- linux-2.6.23-stm.orig/drivers/leds/Makefile
+++ linux-2.6.23-stm/drivers/leds/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_LEDS_COBALT)		+= leds-cobal
 obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
 obj-$(CONFIG_LEDS_MB374)		+= leds-mb374.o
 obj-$(CONFIG_SH_ST_MB411)		+= leds-mb411.o
+obj-$(CONFIG_SH_ST_MB628)		+= leds-mb628.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
Index: linux-2.6.23-stm/drivers/leds/leds-mb628.c
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/drivers/leds/leds-mb628.c
@@ -0,0 +1,56 @@
+/*
+ * linux/drivers/leds/leds-mb628.c
+ *
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <linux/io.h>
+#include <asm/mb628/epld.h>
+#include "../../arch/sh/boards/st/common/common.h"
+
+static void mb628_led_set(struct led_classdev *led_cdev,
+			  enum led_brightness brightness)
+{
+	u8 reg;
+
+	/* Locking required here */
+	reg = epld_read(EPLD_ENABLE);
+	if (brightness)
+		reg |= EPLD_ENABLE_HBEAT;
+	else
+		reg &= ~EPLD_ENABLE_HBEAT;
+	epld_write(reg, EPLD_ENABLE);
+}
+
+static struct led_classdev mb628_led = {
+	.name = "mb628-led",
+	.brightness_set = mb628_led_set,
+	.default_trigger = "heartbeat"
+};
+
+static int __init mb628_led_init(void)
+{
+	led_classdev_register(NULL, &mb628_led);
+}
+
+static void __exit mb628_led_exit(void)
+{
+	led_classdev_unregister(&mb628_led);
+}
+
+module_init(mb628_led_init);
+module_exit(mb628_led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LED support for STMicroelectronics mb628");
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
Index: linux-2.6.23-stm/drivers/mtd/chips/cfi_cmdset_0001.c
===================================================================
--- linux-2.6.23-stm.orig/drivers/mtd/chips/cfi_cmdset_0001.c
+++ linux-2.6.23-stm/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -102,8 +102,8 @@ static struct mtd_chip_driver cfi_intele
 	.module		= THIS_MODULE
 };
 
-/* #define DEBUG_LOCK_BITS */
-/* #define DEBUG_CFI_FEATURES */
+#undef DEBUG_LOCK_BITS
+#define DEBUG_CFI_FEATURES
 
 #ifdef DEBUG_CFI_FEATURES
 static void cfi_tell_features(struct cfi_pri_intelext *extp)
Index: linux-2.6.23-stm/include/asm-sh/mb628/epld.h
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/include/asm-sh/mb628/epld.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2008 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics STx7141 Validation board.
+ */
+
+#ifndef __ASM_SH_MB671_EPLD_H
+#define __ASM_SH_MB671_EPLD_H
+
+#define EPLD_IDENT		0x010000
+#define EPLD_TEST		0x020000
+#define EPLD_RESET		0x030000
+#define   EPLD_RESET_MII		(1<<5)
+#define EPLD_AUDIO		0x040000
+#define EPLD_FLASH		0x050000
+#define   EPLD_FLASH_NOTWP		(1<<0)
+#define   EPLD_FLASH_NOTRESET		(1<<1)
+#define EPLD_IEEE		0x060000
+#define EPLD_ENABLE		0x070000
+#define   EPLD_ENABLE_HBEAT		(1<<2)
+#define EPLD_CCARDCTRL		0x080000
+#define EPLD_CCARDCTRL2		0x090000
+#define EPLD_CCARDIMDIMODE	0x0A0000
+#define EPLD_CCARDTS3INMODE	0x0B0000
+#define EPLD_STATUS		0x0C0000
+
+#endif
Index: linux-2.6.23-stm/drivers/stm/Kconfig
===================================================================
--- linux-2.6.23-stm.orig/drivers/stm/Kconfig
+++ linux-2.6.23-stm/drivers/stm/Kconfig
@@ -20,7 +20,7 @@ config STM_PIO
 
 config STM_DMA
 	bool "STMicroelectronics DMA API"
-	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7105 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7105 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7141 || CPU_SUBTYPE_STX7200
 	select SH_DMA_API
 	default y
 	---help---
Index: linux-2.6.23-stm/include/linux/stm/fdma-plat.h
===================================================================
--- linux-2.6.23-stm.orig/include/linux/stm/fdma-plat.h
+++ linux-2.6.23-stm/include/linux/stm/fdma-plat.h
@@ -31,6 +31,13 @@
 #define STX7111_IMEM_OFFSET					STB7100_IMEM_OFFSET
 #define STX7111_DMEM_OFFSET					STB7100_DMEM_OFFSET
 
+#define STX7141_FDMA0_BASE					0xfe220000
+#define STX7141_FDMA1_BASE					0xfe410000
+#define STX7141_XBAR_BASE					0xfe420000
+
+#define STX7141_IMEM_OFFSET					STB7100_IMEM_OFFSET
+#define STX7141_DMEM_OFFSET					STB7100_DMEM_OFFSET
+
 #define STB7200_FDMA0_BASE					0xFD810000
 #define STB7200_FDMA1_BASE					0xFD820000
 #define STB7200_XBAR_BASE					0xFD830000
@@ -89,6 +96,8 @@
 #define LINUX_FDMA1_STX7105_IRQ_VECT			evt2irq(0x13a0)
 #define LINUX_FDMA0_STX7111_IRQ_VECT			evt2irq(0x1380)
 #define LINUX_FDMA1_STX7111_IRQ_VECT			evt2irq(0x13a0)
+#define LINUX_FDMA0_STX7141_IRQ_VECT			ILC_IRQ(44)
+#define LINUX_FDMA1_STX7141_IRQ_VECT			ILC_IRQ(45)
 #define LINUX_FDMA0_STB7200_IRQ_VECT			ILC_IRQ(13)
 #define LINUX_FDMA1_STB7200_IRQ_VECT			ILC_IRQ(15)
 
Index: linux-2.6.23-stm/arch/sh/configs/mb628_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.23-stm/arch/sh/configs/mb628_defconfig
@@ -0,0 +1,1210 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.23.17
+# Wed Jun 11 17:08:03 2008
+#
+CONFIG_SUPERH=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_NO_VIRT_TO_BUS=y
+CONFIG_ARCH_SUPPORTS_LTT_CLOCK=y
+CONFIG_ARCH_NEEDS_LTT_SYNTHETIC_TSC=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-mb618"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System type
+#
+CONFIG_CPU_SH4=y
+CONFIG_CPU_SUBTYPE_ST40=y
+# CONFIG_CPU_SUBTYPE_SH7619 is not set
+# CONFIG_CPU_SUBTYPE_SH7206 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7706 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7710 is not set
+# CONFIG_CPU_SUBTYPE_SH7712 is not set
+# CONFIG_CPU_SUBTYPE_SH7720 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STB7100 is not set
+# CONFIG_CPU_SUBTYPE_STX7105 is not set
+# CONFIG_CPU_SUBTYPE_STX7111 is not set
+CONFIG_CPU_SUBTYPE_STX7141=y
+# CONFIG_CPU_SUBTYPE_STX7200 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+# CONFIG_CPU_SUBTYPE_SH7785 is not set
+# CONFIG_CPU_SUBTYPE_SHX3 is not set
+# CONFIG_CPU_SUBTYPE_SH7343 is not set
+# CONFIG_CPU_SUBTYPE_SH7722 is not set
+
+#
+# Memory management options
+#
+CONFIG_QUICKLIST=y
+CONFIG_MMU=y
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x08000000
+CONFIG_SUPPORTS_32BIT=y
+# CONFIG_32BIT is not set
+# CONFIG_VSYSCALL is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_MAX_ACTIVE_REGIONS=1
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_NR_QUICK=2
+# CONFIG_BPA2 is not set
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+CONFIG_CACHE_WRITEBACK=y
+# CONFIG_CACHE_WRITETHROUGH is not set
+# CONFIG_CACHE_OFF is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SH_FPU=y
+# CONFIG_SH_STORE_QUEUES is not set
+CONFIG_CPU_HAS_INTEVT=y
+CONFIG_CPU_HAS_SR_RB=y
+CONFIG_CPU_HAS_FPU=y
+# CONFIG_SH_GRB is not set
+
+#
+# Board support
+#
+
+#
+# ST Main Boards
+#
+# CONFIG_SH_ST_HARP_IRQ is not set
+CONFIG_SH_ST_EPLD=y
+CONFIG_SH_ST_STEM=y
+# CONFIG_SH_ST_STPM_HD_V1 is not set
+# CONFIG_SH_ST_STPM_HD_V2 is not set
+CONFIG_SH_ST_MB628=y
+
+#
+# ST Peripheral Boards
+#
+# CONFIG_SH_ST_DB641 is not set
+# CONFIG_SH_ST_DB679 is not set
+# CONFIG_SH_ST_MB588 is not set
+
+#
+# Timer and clock configuration
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_TIMER_IRQ=16
+CONFIG_SH_PCLK_FREQ=66000000
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+# CONFIG_SH_FAST_HZ is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_SH4_CALIBRATE_DELAY is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+CONFIG_SH_DMA_API=y
+
+#
+# Companion Chips
+#
+
+#
+# Additional SuperH Device Drivers
+#
+# CONFIG_HEARTBEAT is not set
+# CONFIG_PUSH_SWITCH is not set
+
+#
+# Kernel features
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+CONFIG_GUSA=y
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_PM_SH3_FRQCR is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NF_CONNTRACK_ENABLED is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+# CONFIG_MTD_BLKDEVS is not set
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x0
+CONFIG_MTD_PHYSMAP_LEN=0
+CONFIG_MTD_PHYSMAP_BANKWIDTH=0
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+CONFIG_PHYLIB=y
+
+#
+# PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_STE10XP is not set
+CONFIG_NATIONAL_PHY=y
+# CONFIG_FIXED_PHY is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_SMSC911x is not set
+# CONFIG_SMC91X is not set
+CONFIG_NETDEV_1000=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_DA is not set
+# CONFIG_STMMAC_TIMER is not set
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_USBNET_MII=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+# CONFIG_SERIAL_ST_ASC_FDMA is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+# CONFIG_LIRC_SUPPORT is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_STM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_ST40_PIO is not set
+CONFIG_I2C_STM=y
+# CONFIG_I2C_STM_GLITCH_SUPPORT is not set
+# CONFIG_I2C_STM_HW_GLITCH is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_I2C_AT24C is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+CONFIG_HAVE_GPIO_LIB=y
+
+#
+# GPIO Support
+#
+CONFIG_DEBUG_GPIO=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_PCA9539 is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_STM_COMMON=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_GPIO is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+CONFIG_STM_PIO=y
+CONFIG_STM_DMA=y
+CONFIG_MIN_STM_DMA_CHANNEL_NR=0
+CONFIG_MAX_STM_DMA_CHANNEL_NR=15
+# CONFIG_STM_DMA_DEBUG is not set
+# CONFIG_STM_DMA_FW_USERSPACE is not set
+CONFIG_STM_DMA_FW_KERNEL=y
+CONFIG_STM_RNG=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Instrumentation Support
+#
+# CONFIG_KPROBES is not set
+# CONFIG_KPTRACE is not set
+# CONFIG_MARKERS is not set
+CONFIG_LTT_TIMESTAMP=y
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SLAB_LEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+# CONFIG_PROVE_LOCKING is not set
+CONFIG_LOCKDEP=y
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_LOCKDEP is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+CONFIG_DEBUG_LIST=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_FORCED_INLINING is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_WANT_EXTRA_DEBUG_INFORMATION is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_KGDB is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_BOOTMEM is not set
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_DEBUG_STACK_USAGE=y
+# CONFIG_4KSTACKS is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
