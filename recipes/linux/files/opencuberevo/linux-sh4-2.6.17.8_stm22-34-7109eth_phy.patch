Index: linux/arch/sh/boards/st/stb7100mboard/setup.c
===================================================================
--- linux.orig/arch/sh/boards/st/stb7100mboard/setup.c
+++ linux/arch/sh/boards/st/stb7100mboard/setup.c
@@ -25,7 +25,7 @@
 #define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
 #define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
 
-#ifdef CONFIG_STB7109_ETH
+#ifdef CONFIG_STMMAC_ETH
 #define MAC_SPEED_SEL	    0x00100000 /* MAC is running at 100 Mbps speed */
 #define PHY_CLK_EXT	    0x00080000 /* PHY clock is external (RMII mode)*/
 #define MII_MODE	    0x00040000 /* RMII interface activated */
@@ -41,20 +41,27 @@ void stb7109eth_hw_setup(void)
 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
 	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
 
-#ifdef CONFIG_STE101P_RMII
+#ifdef CONFIG_PHY_RMII
 	sysconf |= MII_MODE; /* RMII selected*/
 #else
 	sysconf &= ~MII_MODE; /* MII selected */
 #endif
+#ifdef CONFIG_STMMAC_EXT_CLK
+	sysconf |= PHY_CLK_EXT;
+#endif
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
-	/* STe101P: enable the external interrupts */
+	/* Enable the external PHY interrupts */
 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(10));
 	sysconf |= 0x0000000f;
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
 
-       /* Configure e/net PHY clock */
+	/* Configure e/net PHY clock */
+#ifndef CONFIG_STMMAC_EXT_CLK
 	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
+#else
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_IN);
+#endif
 
 	return;
 }
@@ -127,7 +134,7 @@ void __init platform_setup(void)
          */
 	disable_hlt();
 
-#ifdef CONFIG_STB7109_ETH
+#ifdef CONFIG_STMMAC_ETH
 	stb7109eth_hw_setup();
 #endif
 
@@ -249,19 +256,6 @@ static struct resource smc91x_resources[
 	},
 };
 
-static struct resource stb7109eth_resources[] = {
-        [0] = {
-                .start = 0x18110000,
-                .end   = 0x1811ffff,
-                .flags  = IORESOURCE_MEM,
-        },
-        [1] = {
-                .start  = 133,
-                .end    = 133,
-                .flags  = IORESOURCE_IRQ,
-        },
-};
-
 static struct resource st40_ohci_resources[] = {
 	/*this lot for the ohci block*/
 	[0] = {
@@ -353,29 +347,40 @@ static struct platform_device smc91x_dev
 	.resource	= smc91x_resources,
 };
 
-static struct platform_device stb7109eth_device = {
-        .name           = "stb7109eth",
-        .id             = 0,
-        .num_resources  = ARRAY_SIZE(stb7109eth_resources),
-        .resource       = stb7109eth_resources,
+static struct plat_stmmacenet_data eth7109_private_data = {
+	.bus_id = 0,
+	.phy_addr = 0,
+	.phy_ignorezero = 0,
+	.phy_name = "ste101p",
+	.pbl = 1,
 };
 
-static struct resource ste101p_resources[] = {
-        [0] = {
-                .flags  = IORESOURCE_DISABLED,
-        },
-        [1] = {
-                .start  = 7,
-                .end    = 7,
-                .flags  = IORESOURCE_IRQ,
-        },
-};
-
-static struct platform_device ste101p_device = {
-        .name           = "ste101p",
+static struct platform_device stb7109eth_device = {
+        .name           = "stmmaceth",
         .id             = 0,
-        .num_resources  = ARRAY_SIZE(ste101p_resources),
-        .resource       = ste101p_resources,
+        .num_resources  = 3,
+        .resource       = (struct resource[]) {
+        	{
+	                .start = 0x18110000,
+        	        .end   = 0x1811ffff,
+                	.flags  = IORESOURCE_MEM,
+        	},
+        	{
+			.name   = "macirq",
+                	.start  = 133,
+                	.end    = 133,
+                	.flags  = IORESOURCE_IRQ,
+        	},
+        	{
+			.name   = "phyirq",
+                	.start  = 7,
+                	.end    = 7,
+                	.flags  = IORESOURCE_IRQ,
+        	},
+	},
+	.dev = {
+		.platform_data = &eth7109_private_data,
+	}
 };
 
 static struct platform_device lirc_device = {
@@ -526,7 +531,6 @@ static struct platform_device stm_pwm_de
 static struct platform_device *stb7100mboard_devices[] __initdata = {
 	&smc91x_device,
 	&stb7109eth_device,
-	&ste101p_device,
 	&st40_ohci_devices,
 	&st40_ehci_devices,
 	&lirc_device,
@@ -564,6 +568,15 @@ static int __init device_init(void)
 		sata_private_info.pc_glue_logic_init = 0x100ff;
 	}
 
+	/* Configure the ethernet MAC PBL depending on the cut of the chip */
+	if (chip_7109){
+	       if (chip_revision == 1){
+			eth7109_private_data.pbl = 1;
+		} else {
+			eth7109_private_data.pbl = 32;
+		}
+        }
+
 	ret = platform_add_devices(stb7100mboard_devices, ARRAY_SIZE(stb7100mboard_devices));
 	return ret;
 }
Index: linux/arch/sh/boards/st/stb7100ref/mach.c
===================================================================
--- linux.orig/arch/sh/boards/st/stb7100ref/mach.c
+++ linux/arch/sh/boards/st/stb7100ref/mach.c
@@ -49,7 +49,11 @@ static void __init stb7100ref_init_irq(v
         ilc_route_external(ILC_EXT_IRQ0, 4, 0);
         ilc_route_external(ILC_EXT_IRQ1, 5, 0);
         ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+#ifdef CONFIG_STMMAC_ETH
+        ilc_route_external(70, 7, 0);
+#else
         ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+#endif
 
         make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
         make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
Index: linux/arch/sh/boards/st/stb7100ref/setup.c
===================================================================
--- linux.orig/arch/sh/boards/st/stb7100ref/setup.c
+++ linux/arch/sh/boards/st/stb7100ref/setup.c
@@ -25,6 +25,48 @@
 #define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
 #define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
 
+#ifdef CONFIG_STMMAC_ETH
+#define MAC_SPEED_SEL      0x00100000 /* MAC is running at 100 Mbps speed */
+#define PHY_CLK_EXT        0x00080000 /* PHY clock is external (RMII mode)*/
+#define MII_MODE           0x00040000 /* RMII interface activated */
+#define        ETH_IF_ON           0x00010000 /* ETH interface on */
+#define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
+#define STB7109ETH_RESOURCE_NAME       "stb7109eth"
+
+/* ETH MAC pad configuration */
+void stb7109eth_hw_setup(void)
+{
+       unsigned long sysconf;
+
+       sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+       sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
+#ifdef CONFIG_PHY_RMII
+       sysconf |= MII_MODE; /* RMII selected*/
+#else
+       sysconf &= ~MII_MODE; /* MII selected */
+#endif
+#ifdef CONFIG_STMMAC_EXT_CLK
+        sysconf |= PHY_CLK_EXT;
+#endif
+       ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+       /* Enable the external PHY interrupts */
+       sysconf = ctrl_inl(SYSCONF_SYS_CFG(10));
+       sysconf |= 0x0000000f;
+       ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
+
+       /* Configure e/net PHY clock */
+#ifndef CONFIG_STMMAC_EXT_CLK
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
+#else
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_IN);
+#endif
+
+       return;
+}
+#endif
+
+
 /*
  * Initialize the board
  */
@@ -75,6 +117,17 @@ void __init platform_setup(void)
 	 */
 	disable_hlt();
 
+#ifdef CONFIG_STMMAC_ETH
+	stb7109eth_hw_setup();
+	/* Reset the PHY */
+	ethreset = stpio_request_pin(2, 4, "STE100P_RST", STPIO_OUT);
+	stpio_set_pin(ethreset, 1);
+	udelay(1);
+	stpio_set_pin(ethreset, 0);
+	udelay(1000);
+	stpio_set_pin(ethreset, 1);
+#endif
+
 #ifdef CONFIG_STM_PWM
 	stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
 #endif
@@ -161,17 +214,17 @@ static struct lirc_pio lirc_pios[] = {
 };
 
 static struct plat_lirc_data lirc_private_info = {
-        /* For the 7100, the clock settings will be calculated by the driver
+	/* For the 7100, the clock settings will be calculated by the driver
 	 * from the system clock
 	 */
 	.irbclock	= 0, /* use current_cpu data */
-        .irbclkdiv      = 0, /* automatically calculate */
-        .irbperiodmult  = 0,
-        .irbperioddiv   = 0,
-        .irbontimemult  = 0,
-        .irbontimediv   = 0,
-        .irbrxmaxperiod = 0x5000,
-        .irbversion     = 2,
+	.irbclkdiv      = 0, /* automatically calculate */
+	.irbperiodmult  = 0,
+	.irbperioddiv   = 0,
+	.irbontimemult  = 0,
+	.irbontimediv   = 0,
+	.irbrxmaxperiod = 0x5000,
+	.irbversion     = 2,
 	.sysclkdiv	= 1,
 	.rxpolarity	= 1,
 	.pio_pin_arr  = lirc_pios,
@@ -236,18 +289,18 @@ struct platform_device wdt_device = {
 };
 
 static struct resource lirc_resource[]= {
-        /* This is the main LIRC register block, as defined by the spec */
+	/* This is the main LIRC register block, as defined by the spec */
        [0] = {
 		.start = 0x18018000,
 		.end   = 0x18018000 + 0xa0,
-                .flags = IORESOURCE_MEM
-        },
-        /* The LIRC block has one interrupt */
-        [1] = {
-                .start = 125,
+	        .flags = IORESOURCE_MEM
+	},
+	/* The LIRC block has one interrupt */
+	[1] = {
+	        .start = 125,
 		.end   = 125,
-                .flags = IORESOURCE_IRQ
-        },
+	        .flags = IORESOURCE_IRQ
+	},
 };
 
 static u64 st40_dma_mask = 0xfffffff;
@@ -281,14 +334,50 @@ static struct platform_device smc91x_dev
 	.resource	= smc91x_resources,
 };
 
+static struct plat_stmmacenet_data eth7109_private_data = {
+	.bus_id = 0,
+	.phy_addr = 14,
+	.phy_ignorezero = 1,
+	.phy_name = "ste100p",
+	.pbl = 1,
+};
+
+static struct platform_device stb7109eth_device = {
+	.name           = "stmmaceth",
+	.id             = 0,
+	.num_resources  = 3,
+	.resource       = (struct resource[]) {
+		{
+	                .start = 0x18110000,
+		        .end   = 0x1811ffff,
+	        	.flags  = IORESOURCE_MEM,
+		},
+		{
+			.name   = "macirq",
+	        	.start  = 133,
+	        	.end    = 133,
+	        	.flags  = IORESOURCE_IRQ,
+		},
+		{
+			.name   = "phyirq",
+	        	.start  = IRL3_IRQ,
+	        	.end    = IRL3_IRQ,
+	        	.flags  = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &eth7109_private_data,
+	}
+};
+
 static struct platform_device lirc_device = {
-        .name           = "lirc",
-        .id             = -1,
-        .num_resources  = ARRAY_SIZE(lirc_resource),
-        .resource       = lirc_resource,
-        .dev = {
-                   .platform_data = &lirc_private_info
-        }
+	.name           = "lirc",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(lirc_resource),
+	.resource       = lirc_resource,
+	.dev = {
+	           .platform_data = &lirc_private_info
+	}
 };
 
 static struct resource sata_resource[]= {
@@ -414,6 +503,7 @@ static struct platform_device physmap_fl
 
 static struct platform_device *stb7100ref_devices[] __initdata = {
 	&smc91x_device,
+	&stb7109eth_device,
 	&st40_ohci_devices,
 	&st40_ehci_devices,
 	&lirc_device,
@@ -451,6 +541,15 @@ static int __init device_init(void)
 		sata_private_info.pc_glue_logic_init = 0x100ff;
 	}
 
+	/* Configure the ethernet MAC PBL depending on the cut of the chip */
+	if (chip_7109){
+	       if (chip_revision == 1){
+			eth7109_private_data.pbl = 1;
+		} else {
+			eth7109_private_data.pbl = 32;
+		}
+	}
+
 	ret = platform_add_devices(stb7100ref_devices, ARRAY_SIZE(stb7100ref_devices));
 	return ret;
 }
Index: linux/drivers/net/Kconfig
===================================================================
--- linux.orig/drivers/net/Kconfig
+++ linux/drivers/net/Kconfig
@@ -1860,41 +1860,40 @@ config NE_H8300
 source "drivers/net/fec_8xx/Kconfig"
 source "drivers/net/fs_enet/Kconfig"
 
-config STB7109_ETH
-        tristate "STb7109 Ethernet driver"
+config STMMAC_ETH
+        tristate "STM MAC Ethernet driver"
         select MII
-        select STE101P
         select PHYLIB
-        depends on NET_ETHERNET && (SH_STB7100_MBOARD || SH_STB7109E_REF)
+        depends on NET_ETHERNET && (SH_STB7100_MBOARD || SH_STB7109E_REF || SH_STB7100_REF)
         ---help---
-          This is the driver for the STB7109 on-chip Ethernet controller.
+          This is the driver for the STMMAC on-chip Ethernet controller.
           The STb7109 ETH subsystem is composed of three main layers:
 	  a DMA layer, a Transaction Layer Interface (TLI), and a Media Access
 	  Controller layer (MAC).
 
 config DMA_RX_SIZE
         int "RX DMA list size"
-        default "8"
-	depends on STB7109_ETH
+        default "16"
+	depends on STMMAC_ETH
         help
           it's the max number of descriptors in the RX list.
 
 config DMA_TX_SIZE
         int "TX DMA list size"
-        default "8"
-	depends on STB7109_ETH
+        default "16"
+	depends on STMMAC_ETH
         help
           it's the max number of descriptors in the TX list.
 
-config 7109ETH_DEBUG
+config STMMAC_DEBUG
         boolean "Debug mode"
-	depends on STB7109_ETH
+	depends on STMMAC_ETH
         help
           it enables the debug mode for the IRQ handle.
 
-config 7109ETH_NAPI
+config STMMAC_NAPI
         bool "Enable NAPI support (EXPERIMENTAL)"
-        depends on STB7109_ETH && EXPERIMENTAL
+        depends on STMMAC_ETH && EXPERIMENTAL
         help
           NAPI is a new driver API designed to reduce CPU and interrupt load
           when the driver is receiving lots of packets from the card.
@@ -1903,6 +1902,35 @@ config 7109ETH_NAPI
           Please, for more information about the NAPI support see:
 		<file:Documentation/networking/NAPI_HOWTO.txt>
 
+choice
+	depends on STMMAC_ETH && PHYLIB
+        prompt "MDIO communication mode"
+	default PHY_RMII if SH_STB7100_REF
+	default PHY_MII if SH_STB7100_MBOARD
+	default PHY_RMII if LAN8700
+
+config  PHY_MII
+        bool "MII mode"
+	help
+	  Use the IEEE 802.3u Media Independent Interface (MII)
+	  between the MAC and PHY
+
+config  PHY_RMII
+        bool "RMII mode"
+        help
+	  Use the Reduced Media Independent Interface (RMII).
+	  The Reduced Media Independent Interface (RMII) provides a low cost
+	  alternative to the IEEE 802.3u MII interface.
+
+endchoice
+
+config STMMAC_EXT_CLK
+        boolean "External physical clock"
+        depends on STMMAC_ETH && PHY_RMII
+        help
+          Set this option if you want to use an external clock for physical layer
+	  (RMII mode).
+
 endmenu
 
 #
Index: linux/drivers/net/Makefile
===================================================================
--- linux.orig/drivers/net/Makefile
+++ linux/drivers/net/Makefile
@@ -196,7 +196,7 @@ obj-$(CONFIG_S2IO) += s2io.o
 obj-$(CONFIG_SMC91X) += smc91x.o
 obj-$(CONFIG_DM9000) += dm9000.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
-obj-$(CONFIG_STB7109_ETH) += stb7109eth.o
+obj-$(CONFIG_STMMAC_ETH) += stmmac.o
 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
Index: linux/drivers/net/phy/Kconfig
===================================================================
--- linux.orig/drivers/net/phy/Kconfig
+++ linux/drivers/net/phy/Kconfig
@@ -12,7 +12,7 @@ config PHYLIB
 	  devices.  This option provides infrastructure for
 	  managing PHY devices.
 
-comment "MII PHY device drivers"
+comment "PHY device drivers"
 	depends on PHYLIB
 
 config MARVELL_PHY
@@ -45,33 +45,23 @@ config CICADA_PHY
 	---help---
 	  Currently supports the cis8204
 
-config STE101P
-	depends on NET_ETHERNET && PHYLIB && EXPERIMENTAL
-        tristate "Drivers for STe101p (EXPERIMENTAL)"
+config STE10XP
+	depends on PHYLIB
+        tristate "Driver for STM STe10Xp PHY"
         ---help---
-          This is the driver for the STe101p SMII/RMII/MII interface.
+          This is the driver for the STe100p and STe101p PHYs.
+	  The STe101p PHY is found on the ST DB666 daughter card for the MB411.
+	  The STe100p PHY is found on the STb7109REF (CoCo) board.
           Say Y if you want it compiled into the kernel. To compile this
           driver as a module, choose M here.
-choice
-	depends on STE101P
-        prompt "Media Indipendent Interface mode"
-        default MII_INTERFACE
-
-config STE101P_MII
-        bool "MII interface"
-        depends on STE101P
-        help
-	  Support of MII protocol to interface the MAC with the MII-based PHY.
-
-config  STE101P_RMII
-        depends on STE101P
-        bool "RMII interface"
-        help
-	  Activated the Reduced Media Indipendent Interface (RMII).
-	  The Reduced Media Independent Interface (RMII) provides a low cost
-	  alternative to the IEEE 802.3u MII interface.
 
-endchoice
+config LAN8700
+	depends on PHYLIB
+        bool "Driver for SMSC Lan8700 PHY"
+        ---help---
+          This is the driver for the SMSC Lan8700 PHY.
+          Say Y if you want it compiled into the kernel. To compile this
+          driver as a module, choose M here.
 
 endmenu
 
Index: linux/drivers/net/phy/mdio_bus.c
===================================================================
--- linux.orig/drivers/net/phy/mdio_bus.c
+++ linux/drivers/net/phy/mdio_bus.c
@@ -42,9 +42,9 @@
  * description: Called by a bus driver to bring up all the PHYs
  *   on a given bus, and attach them to the bus
  */
-int mdiobus_register(struct mii_bus *bus)
+int mdiobus_register(struct mii_bus *bus, int ignorezero)
 {
-	int i;
+	int i = 0;
 	int err = 0;
 
 	spin_lock_init(&bus->mdio_lock);
@@ -57,7 +57,10 @@ int mdiobus_register(struct mii_bus *bus
 	if (bus->reset)
 		bus->reset(bus);
 
-	for (i = 0; i < PHY_MAX_ADDR; i++) {
+	if (ignorezero)
+		i++;
+
+	for (; i < PHY_MAX_ADDR; i++) {
 		struct phy_device *phydev;
 
 		if (bus->phy_mask & (1 << i)) {
@@ -79,6 +82,7 @@ int mdiobus_register(struct mii_bus *bus
 		 * 5) mii_bus
 		 * And, we need to register it */
 		if (phydev) {
+			printk(KERN_DEBUG "mdiobus_register: found PHY and assigning IRQ %d\n", bus->irq[i]);
 			phydev->irq = bus->irq[i];
 
 			phydev->dev.parent = bus->dev;
Index: linux/drivers/net/phy/phy_device.c
===================================================================
--- linux.orig/drivers/net/phy/phy_device.c
+++ linux/drivers/net/phy/phy_device.c
@@ -75,12 +75,13 @@ struct phy_device * get_phy_device(struc
 
 	phy_id |= (phy_reg & 0xffff);
 
-	/* If the phy_id is all Fs, there is no device there */
-	if (0xffffffff == phy_id)
+	/* If the phy_id is mostly Fs, there is no device there */
+	if ((phy_id & 0x1fffffff) == 0x1fffffff)
 		return NULL;
 
 	/* Otherwise, we allocate the device, and initialize the
 	 * default values */
+
 	dev = kcalloc(1, sizeof(*dev), GFP_KERNEL);
 
 	if (NULL == dev)
Index: linux/drivers/net/phy/smsc8700.c
===================================================================
--- /dev/null
+++ linux/drivers/net/phy/smsc8700.c
@@ -0,0 +1,182 @@
+/* ============================================================================
+ * This is a driver for the SMSC LAN8700 PHY controller
+ *
+ * Copyright (C) 2006 ST Microelectronics (R&D) Ltd.
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   Sep 2006
+ *	Converted PHY driver to new 2.6.17 PHY device
+ *	Carl Shaw <carl.shaw@st.com>
+ *	Added contributions by Steve Glendinning <Steve.Glendinning@smsc.com>
+ *   July 2006
+ *	Copied from the STe101p PHY driver (originally written by
+ *	Giuseppe Cavallaro <peppe.cavallaro@st.com>) by
+ *	Nigel Hathaway <nigel.hathaway@st.com>
+ * ===========================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/delay.h>
+
+#undef PHYDEBUG
+#define DEFAULT_PHY_ID  0
+#define RESOURCE_NAME	"lan8700"
+
+
+/* LAN8700 vendor-specific registers */
+#define MII_REV		0x10	/* Silicon revision register */
+#define MII_MCSR	0x11	/* Mode control/status register */
+#define MII_SMR		0x12	/* Special modes register */
+#define MII_SCSIR	0x1b	/* Special control/status indications register */
+#define MII_SITCR	0x1c	/* Special internal testability controls register */
+#define MII_ISR		0x1d	/* Interrupt source register */
+#define MII_IMR		0x1e	/* Interrupt mask register */
+#define MII_PSCSR	0x1f	/* PHY Special control/status register */
+
+#define MII_SCSIR_AMDIXCTRL	0x8000	/* Auto-MDIX control (1 to disable AMDIX) */
+#define MII_SCSIR_CH_SELECT	0x2000	/* MDIX control (1 for AMDIX) */
+
+/* LAN8700 Interrupt Source Register values */
+#define MII_ISR_ANPR	0x0002	/* Auto-Negotiation page received */
+#define MII_ISR_PDF	0x0004	/* Parallel detection fault */
+#define MII_ISR_ANLA	0x0008	/* Auto-Negotiation LP Acknowledge */
+#define MII_ISR_LINK	0x0010	/* Link down (status negated) */
+#define MII_ISR_RFLT	0x0020	/* Remote fault detected */
+#define MII_ISR_ANC	0x0040	/* Auto-Negotiation completed */
+#define MII_ISR_EOG	0x0080	/* ENERGYON generated */
+
+/* LAN8700 PHY Special control/status register values */
+#define MII_PSCSR_ANC		0x1000	/* Auto-Negotiation done */
+#define MII_PSCSR_SPD_MASK	0x001C	/* HCDSPEED value */
+#define MII_PSCSR_SPD_10	0x0004	/* 10Mbps */
+#define MII_PSCSR_SPD_100	0x0008	/* 100Mbps */
+#define MII_PSCSR_SPD_FDPLX	0x0010	/* Full Duplex */
+
+#define MII_IMR_INTSRC_ENERGYON             0x0080
+#define MII_IMR_INTSRC_AUTONEGCOM           0x0040
+#define MII_IMR_INTSRC_REMFLT               0x0020
+#define MII_IMR_INTSRC_LNKDN                0x0010
+#define MII_IMR_INTSRC_AUTONEGLP            0x0008
+#define MII_IMR_INTSRC_PARFLT               0x0004
+#define MII_IMR_INTSRC_AUTONEGPR            0x0002
+
+#define MII_IMR_DEFAULT_MASK (MII_IMR_INTSRC_AUTONEGCOM | MII_IMR_INTSRC_REMFLT | MII_IMR_INTSRC_LNKDN)
+
+
+/* LAN8700 phy identifier values */
+#define LAN8700_PHY_ID		0x0007c0c0
+#define LAN8700_PHY_LO_ID_REVA 	0xc0c1
+#define LAN8700_PHY_LO_ID_REVB 	0xc0c2
+#define LAN8700_PHY_LO_ID_REVC 	0xc0c3
+#define LAN8700_PHY_LO_ID_REVD 	0xc0c4
+#define LAN8700_PHY_LO_ID_REVE 	0xc0c5
+#define LAN8700_PHY_LO_ID_REVF 	0xc0c6
+#define LAN8700_PHY_LO_ID_REVG 	0xc0c7
+
+static int lan8700_config_init(struct phy_device *phydev)
+{
+	int value, err;
+	int timeout = 1000;
+
+	/* Enable the MODE pins to enable autoneg */
+	value = phy_read(phydev, MII_SMR);
+	if (value < 0)
+                return value;
+	value |= 0x0E0;
+	err = phy_write(phydev, MII_SMR, value);
+	if (err < 0)
+		return err;
+	/* Software Reset PHY */
+	value = phy_read(phydev, MII_BMCR);
+	if (value < 0)
+		return value;
+
+	value |= BMCR_RESET;
+	err = phy_write(phydev, MII_BMCR, value);
+	if (err < 0)
+		return err;
+
+	do{
+		mdelay(1);
+		value = phy_read(phydev, MII_BMCR);
+	} while ((value & BMCR_RESET) && (--timeout));
+
+	if (!timeout){
+		printk(KERN_ERR "LAN8700 PHY timed out during reset!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int lan8700_config_intr(struct phy_device *phydev)
+{
+        int err, value;
+
+        if(phydev->interrupts == PHY_INTERRUPT_ENABLED){
+		/* Enable interrupts */
+		err = phy_write(phydev, MII_IMR, MII_IMR_DEFAULT_MASK);
+		/* clear any pending interrupts */
+		if (err == 0){
+			value = phy_read(phydev, MII_ISR);
+			if (value <0){
+				err = value;
+			}
+		}
+	} else
+		err = phy_write(phydev, MII_IMR, 0);
+
+        return err;
+}
+
+static int lan8700_ack_interrupt(struct phy_device *phydev)
+{
+        int err = phy_read(phydev, MII_ISR);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+static struct phy_driver lan8700_pdriver = {
+        .phy_id         = LAN8700_PHY_ID,
+        .phy_id_mask    = 0xfffffff0,
+        .name           = "LAN8700",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = lan8700_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = lan8700_ack_interrupt,
+        .config_intr    = lan8700_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static int __init lan8700_init(void)
+{
+	int retval;
+
+	return phy_driver_register(&lan8700_pdriver);
+}
+
+static void __exit lan8700_exit(void)
+{
+	phy_driver_unregister(&lan8700_pdriver);
+}
+
+module_init(lan8700_init);
+module_exit(lan8700_exit);
+
+MODULE_DESCRIPTION("SMSC LAN8700 PHY driver");
+MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
+MODULE_LICENSE("GPL");
Index: linux/drivers/net/phy/ste101p.c
===================================================================
--- linux.orig/drivers/net/phy/ste101p.c
+++ /dev/null
@@ -1,552 +0,0 @@
-/* ============================================================================
- * This is a driver for the Ste101p PHY controller.
- *
- * Copyright (C) 2006 by  Giuseppe Cavallaro <peppe.cavallaro@st.com>
- *
- * ----------------------------------------------------------------------------
- * Kernel Command line arguments:
- *	- ste101p=device:<ethx>,addr:<phy_n>,flowctrl:<flowctrl>
- *		where:
- *		 - "device:<ethx>" is the ethernet device name (by default
- *				   the "eth0" will be used),
- *		 - "addr:<phy_n>" is STe101p PHY device address, by default the
- *				  driver is able to detect it automatically.
- *		 - "flowctrl:<flowctrl>: it enables/disables the flow-control.
- *		 NOTE: you must use the , as delimiter.
- *
- * ----------------------------------------------------------------------------
- * Changelog:
- *   May 2006
- *	- It's indipendend from the STb7109eth driver.
- *   April 2006 (first release of the driver):
- *	- Added the RMII interface support.
- * 	- The driver has been tested, on the MB411 platform with the DB666
- * 	  daughter board, using:
- *		- the clock through the STPIO3[7],
- *		- the clock through an external clock generator device.
- *	- Added the "fix_mac_speed" function: it is used for changing
- *	  the MAC speed field in the SYS_CFG7 register.
- *	  (required when we are using the RMII interface).
- *
- * ----------------------------------------------------------------------------
- * Known bugs:
- * 	The SMII mode is not supported yet.
- * ===========================================================================*/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/moduleparam.h>
-#include <linux/interrupt.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-
-#define DEFAULT_PHY_ID  0
-#define RESOURCE_NAME	"ste101p"
-
-#define MII_XCNTL   	0x10 /* 100BaseX Auxiliary Control Register */
-#define MII_XCIIS   	0x11 /* Configuration Info IRQ & Status Reg*/
-#define MII_XIE     	0x12 /* Interrupt Enable Register*/
-#define MII_XMC     	0x14 /* Mode Control Register*/
-#define MII_RSVRD   	0x15 /* Private test register*/
-#define MII_RSRVD   	0x16 /* Private test register*/
-#define MII_PTEST   	0x17 /* Private test register*/
-#define MII_AUXCS   	0x18 /* Auxiliary Control/Status Register*/
-#define MII_AUXSS   	0x19 /* AuxiliaryStatus Summary Register*/
-#define MII_INRPT   	0x1a /* Interrupt Register*/
-#define MII_AUXM2  	0x1b /* Auxiliary Mode 2 Register*/
-#define MII_TSTAT   	0x1c /* Auxiliary Error and General Status Reg */
-#define MII_AUXMD   	0x1d /* Auxiliary Mode Register*/
-#define MII_AMPHY   	0x1e /* Auxiliary PHY Register*/
-#define MII_BTEST   	0x1f /* Shadow register enable*/
-
-/* STE101P Configuration Information Interrupt & Status register */
-#define MII_XCIIS_FIFO_OVERRUN          0x0800
-#define MII_XCIIS_SPEED                 0x0200
-#define MII_XCIIS_DUPLEX                0x0100
-#define MII_XCIIS_PAUSE                 0x0080
-#define MII_XCIIS_ANE	 		0x0040
-#define MII_XCIIS_REMOTE_FAULT_INT      0x0020
-#define MII_XCIIS_LINK_DOWN 	        0x0010
-#define MII_XCIIS_AUTONEGO_ACK_INT      0x0008
-#define MII_XCIIS_PARALL_DETECT_INT     0x0004
-#define MII_XCIIS_AUTONEGO_PAGE_INT     0x0002
-#define MII_XCIIS_RX_ERROR_BUFFER_INT   0x0001
-#define MII_XIE_DEFAULT_MASK 0x0070 /* ANE complete, Remote Fault, Link Down */
-
-/* STE101P phy identifier values */
-#define STE101P_PHY_HI_ID	0x0006
-#define STE101P_PHY_LO_ID_REVA	0x1c51
-#define STE101P_PHY_LO_ID_REVB	0x1c52
-
-/* MII mode */
-#define MII_TSTAT_SMII	0x1000
-#define MII_TSTAT_RMII  0x0800
-#define MII_TSTAT_MII   0x0400
-#define MII_ADVERTISE_PAUSE 0x0400 /* supports the pause command */
-
-static char user_dev_name[IFNAMSIZ] __initdata = { 0, };
-
-struct phy_driver_local {
-	struct mii_if_info mii;
-	struct net_device *dev;
-	unsigned int phy_type;
-	unsigned int speed;
-	unsigned int irq;
-	u16 irq_status;
-	struct work_struct phy_queue;
-};
-
-/* Module Arguments */
-static int phy_n = -1;
-module_param(phy_n, int, S_IRUGO);
-MODULE_PARM_DESC(phy_n, "Physical Device Number");
-
-static int flowctrl=0;
-module_param(flowctrl, int, 0);
-MODULE_PARM_DESC(flowctrl, "flow control [0|1]");
-
-/* MII external functions */
-extern void stb7109eth_set_mac_mii_cap(struct mii_if_info mii, unsigned int speed,
-				       struct net_device *dev);
-extern int stb7109_mii_read (struct net_device *dev, int phyaddr, int phyreg);
-extern void stb7109_mii_write(struct net_device *dev, int phyaddr, int phyreg,
-                              int phydata);
-
-/* ----------------------------------------------------------------------------
-			STe101p functions
-   ---------------------------------------------------------------------------*/
-static int ste101p_restart_ane (struct phy_driver_local *phydev)
-{
-	u16 value;
-	int ret = 0, i = 100000;
-
-	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
-	/* NOTE: writing the PR00[12] has not effect when the ANE
-	 * has been disabled by HW control. */
-	value |= (BMCR_ANRESTART | AUTONEG_ENABLE);
-	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR, value);
-
-	/*  waiting for autonegotiation complete */
-        while( i-- > 0 ) {
-                value=stb7109_mii_read(phydev->dev,phydev->mii.phy_id,MII_BMSR);
-                /* STE101P: MII status reg bit n. 5 */
-                if ((value & BMSR_ANEGCOMPLETE) != 0) {
-			ret = 1;
-                        break;
-                }
-        }
-	return (ret);
-}
-
-static void dump_ste101p_registers (unsigned int n_column,
-		struct phy_driver_local *phydev)
-{
-	int i, /* phy device count */
-	    j  /* phy regs count */,
-	    pr_number = 32;
-
-	printk (KERN_DEBUG "\t STE101P registers \n");
-
-	for (i=0;i<pr_number;i++) {
-		j = 0;
-		printk (KERN_DEBUG "\tPHY device #%d\n", i);
-		while(j < 32) {
-			int k;
-			u16 tmp;
-			for (k=0;k<n_column;k++) {
-				if ( ((j+k) < 9) ||
-				     ( ((j+k) > 10)  && ((j+k) < 13) ) ||
-				     ( ((j+k) > 15)  && ((j+k) < 32) ) ) {
-				   tmp=stb7109_mii_read(phydev->dev, i, j+k);
-				   printk (KERN_DEBUG"\t PR%x: 0x%x", j+k, tmp);
-				}
-			}
-			printk(KERN_DEBUG "\n");
-			j += n_column;
-		}
-	}
-}
-
-static void ste101p_reset_phy(struct phy_driver_local *phydev)
-{
-	u16 value;
-
-	/* When the bit 15 of the register PR00 is set to 1 the STE101P'll
-         * reset entire circuits (a software reset should only take 1ms),
-	 * then clear the  bit 15 of the register PR00 and set the RIP
-	 * output pin 29 to logic 1.  */
-	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
-	value |= BMCR_RESET;
-	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR, value);
-
-	printk(KERN_DEBUG "STe101P: waiting the STE101P reset completition...");
-	do{
-		value=stb7109_mii_read(phydev->dev,phydev->mii.phy_id,MII_BMCR);
-	} while (value & BMCR_RESET);
-
-	printk(KERN_DEBUG " done!\n");
-
-	return;
-}
-
-/* Automatically gets and returns the PHY device */
-static unsigned int ste101p_get_phys_addr(struct phy_driver_local *phydev)
-{
-	int phyaddr;
-
-	for (phyaddr=0; phyaddr<32; phyaddr++) {
-		unsigned int id1, id2;
-		id1 = stb7109_mii_read(phydev->dev, phyaddr, MII_PHYSID1);
-		id2 = stb7109_mii_read(phydev->dev, phyaddr, MII_PHYSID2);
-
-                /* Make sure it is a valid identifier */
-                if ((id1==STE101P_PHY_HI_ID) &&
-			((id2 == STE101P_PHY_LO_ID_REVB) ||
-			 (id2 == STE101P_PHY_LO_ID_REVA))) {
-                        /* Save the PHY's address */
-                        phydev->phy_type = id1 << 16 | id2;
-                        return (phyaddr);
-		}
-	}
-	return (-1);
-}
-
-/* It should be used for setting an user PHY address */
-static void ste101p_set_phy_addr(struct phy_driver_local *phydev)
-{
-	u16 value;
-
-	/* Read the XMC register */
-        value=stb7109_mii_read(phydev->dev, DEFAULT_PHY_ID, MII_XMC);
-	/* Set the PHY address */
-	value |= (phydev->mii.phy_id << 3) & 0x00f8;
-	stb7109_mii_write(phydev->dev, DEFAULT_PHY_ID, MII_XMC, value);
-	return;
-}
-
-/* Power down the specified PHY: Power down can be exited by cleaning
- * bit PR00[11] or by HW/SW reset. */
-void ste101p_powerdown(struct phy_driver_local *phydev)
-{
-
-        u16 bmcr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
-	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR,
-			  (bmcr|BMCR_PDOWN));
-
-	return;
-}
-
-static void ste101p_change(void *data)
-{
-	struct phy_driver_local *phydev = (struct  phy_driver_local *) data;
-	u16 value = phydev->irq_status;
-
-	/* Check if auto negotiation caused interrupt */
-	if (value & MII_XCIIS_ANE) { /* ANE Interrupt completed */
-
-		if (!(value & MII_XCIIS_DUPLEX)) { /* Half Duplex */
-			phydev->mii.full_duplex = 0;
-		} else {  /* Full Duplex */
-			phydev->mii.full_duplex = 1;
-		}
-
-		if (!(value & MII_XCIIS_SPEED)) {
-			phydev->speed = SPEED_10;
-		} else {
-			phydev->speed = SPEED_100;
-		}
-
-		/* we need to set the new speed and duplex values in the MAC
-		   interface*/
-		stb7109eth_set_mac_mii_cap(phydev->mii, phydev->speed,
-					   phydev->dev);
-
-		printk(KERN_INFO "%s: %s duplex, Link speed: 10%s Mbit/s"
-			  "%s\n", phydev->dev->name,
-			  (phydev->mii.full_duplex) ? "Full" : "Half",
-			  (phydev->speed == SPEED_100)  ? "0" : "",
-			  ((value & MII_XCIIS_PAUSE) &&
-			  (value & MII_XCIIS_DUPLEX)) ? ", Flow-control" : "");
-	}
-
-	/* The remote fault indicates to a link partner that a fault condition
-	 * has occurred so we need to re-start the ANE process. */
-	if (value & MII_XCIIS_REMOTE_FAULT_INT){
-		value = ste101p_restart_ane(phydev);
-		printk(KERN_INFO  "%s: auto-negotation Completed: %s\n",
-				phydev->dev->name, value ? "yes": "no");
-	}
-
-	mii_check_link (&phydev->mii);
-
-	return;
-}
-
-/* Interrupt handler for the MII.
- * When a PHY interrupt occurs, the handler clear the
- * interrupt and schedules a work task. */
-static irqreturn_t ste101p_interrupt(int irq, void *phy_dat,
-				     struct pt_regs *regs)
-{
-	u16 bmcr, bmsr;
-	struct phy_driver_local *phydev = (struct  phy_driver_local *)phy_dat;
-
-	/* Read the R/O Auxiliary Status register (PR11)
-	 * and clear the relative "interrupt/pending" bits */
-	phydev->irq_status = stb7109_mii_read(phydev->dev,phydev->mii.phy_id,
-					      MII_XCIIS);
-
-	bmcr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
-	bmsr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMSR);
-
-	printk(KERN_DEBUG "ste101p IRQ handler: MII_XCIIS=0x%x, "
-	      "MII_BMCR=0x%x, MII_BMSR=0x%x\n", phydev->irq_status, bmcr, bmsr);
-
-        schedule_work(&phydev->phy_queue);
-
-        return IRQ_HANDLED;
-}
-
-static int ste101p_start_interrupt(struct phy_driver_local *phydev)
-{
-	int ret;
-
-	INIT_WORK(&phydev->phy_queue, ste101p_change, phydev);
-
-	/* Request the IRQ line*/
-        if ( (ret = request_irq(phydev->irq, &ste101p_interrupt,
-				SA_INTERRUPT, RESOURCE_NAME, phydev)) < 0 ) {
-		printk(KERN_ERR "%s: ERROR: allocating the ste101p IRQ %d "
-				"(return error: %d)\n", __FUNCTION__,
-				phydev->irq, ret);
-		return (ret);
-	}
-
-	/* Enable all STe101P interrupts (PR12) */
-	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_XIE,
-			  MII_XIE_DEFAULT_MASK);
-
-	/* clear any pending interrupts */
-	stb7109_mii_read(phydev->dev,phydev->mii.phy_id, MII_XCIIS);
-
-	return (ret);
-
-}
-
-static int ste101p_init_config(struct phy_driver_local *phydev)
-{
-	u16 value;
-	u16 advertised_caps;
-
-	unsigned int phy_valid;
-#ifdef CONFIG_STE101P_RMII
-        char *mii_mode = "RMII mode";
-#else
-        char *mii_mode = "MII mode";
-#endif
-	phy_valid = ste101p_get_phys_addr(phydev);
-	if (phy_valid < 0) {
-		/* If the auto detection process fails we can try to
-		use a default value. */
-		phy_valid = DEFAULT_PHY_ID;
-		printk(KERN_WARNING "STe101P: auto-detection failed!\n");
-	}
-	phydev->mii.phy_id = phy_valid;
-
-	/* Software Reset */
-	ste101p_reset_phy(phydev);
-
-	/* We must write the new phy address in the XCVR Mode Control Register
-	 * (bits [7-3]).
-	 * NOTE: we need a SW reset with the default value before setting the
-		 new address. */
-	if ((phy_n >=0) && (phy_n <= 31)) {
-		phydev->mii.phy_id = phy_n;
-		ste101p_set_phy_addr(phydev);
-	}
-
-	printk(KERN_INFO "STe101P Revision %s (%s) - device address: %d\n",
-	      (((stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_PHYSID2))
-	      & 0xffff) == STE101P_PHY_LO_ID_REVB) ? "B" : "A",
-	      mii_mode, phydev->mii.phy_id);
-
-#if 0
-	/* Extend the squelch levels for the detection of incoming
-	   data packets. */
-	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_AUXCS);
-	stb7109_mii_write(phydev->dev,phydev->mii.phy_id,
-			  MII_AUXCS, (value | 0xc0));
-#endif
-
-	/* Read the ANE Advertisement register */
-	advertised_caps = stb7109_mii_read(phydev->dev, phydev->mii.phy_id,
-					   MII_ADVERTISE);
-
-	/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
-	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMSR);
-
-	/* Set the advertised capabilities */
-	if (value & BMSR_100BASE4)
-                advertised_caps |= ADVERTISE_100BASE4;
-        if (value & BMSR_100FULL)
-                advertised_caps |= ADVERTISE_100FULL;
-        if (value & BMSR_100HALF)
-                advertised_caps |= ADVERTISE_100HALF;
-        if (value & BMSR_10FULL)
-                advertised_caps |= ADVERTISE_10FULL;
-        if (value & BMSR_10HALF)
-                advertised_caps |= ADVERTISE_10HALF;
-
-	/* If flow control enabled, we need to advertise it. */
-	if (flowctrl)
-                advertised_caps |= MII_ADVERTISE_PAUSE;
-	else
-		advertised_caps &= ~MII_ADVERTISE_PAUSE;
-
-	/* Update our Auto-Neg Advertisement Register */
-	phydev->mii.advertising = advertised_caps;
-	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_ADVERTISE,
-			  advertised_caps);
-
-	/* Request and start the interrupt */
-	ste101p_start_interrupt(phydev);
-
-	/* Restart auto-negotiation process in order to advertise my caps;
-	 * NOTE: in any case, in during the STe101p interrupt routine the ANE
-	 * Advertisement Register will be updated with the actual parameters*/
-	value = ste101p_restart_ane(phydev);
-	phydev->mii.force_media = 1; /* ANE */
-	printk(KERN_INFO "%s: auto-negotation Completed: %s\n",
-		phydev->dev->name, value ? "yes": "no");
-
-	/* verify the link status */
-        printk(KERN_INFO "%s: check link...", phydev->dev->name);
-        if (!mii_link_ok(&phydev->mii)) {
-                printk(KERN_INFO "failed!\n");
-                netif_carrier_off(phydev->dev);
-        } else {
-                printk(KERN_INFO "done!\n");
-                netif_carrier_on(phydev->dev);
-        }
-
-	dump_ste101p_registers(3, phydev);
-
-	return (0);
-}
-
-/* --------------------------------------------------------------------------
- * 		Parse the optional command line arguments
- * --------------------------------------------------------------------------*/
-static int __init ste101p_parse_option(char *str)
-{
-	char* opt;
-
-	if (!str || !*str)
-		return -EINVAL;
-
-	while ((opt=strsep(&str, ",")) != NULL) {
-                if (! strncmp(opt, "device:", 7)) {
-                        strlcpy(user_dev_name, opt+7, sizeof(user_dev_name));
-                }
-                else if (! strncmp(opt, "addr:", 5)) {
-                        phy_n = simple_strtoul(opt+5, NULL, 0);
-                }
-                else if (! strncmp(opt, "flowctrl:", 9)) {
-                         flowctrl = simple_strtoul(opt+9, NULL, 0);
-                }
-        }
-
-	printk(KERN_DEBUG "%s: device name %s, phy addr=%d, flowctrl=%s\n",
-                          RESOURCE_NAME, user_dev_name, phy_n,
-			  (flowctrl)?"enabled":"disabled");
-
-        return (0);
-}
-__setup("ste101p=", ste101p_parse_option);
-
-/* ----------------------------------------------------------------------------
-	           DEVICE registration and unloading
-   ---------------------------------------------------------------------------*/
-static int ste101p_drv_remove(struct device *dev)
-{
-	struct phy_driver_local *phydev=dev_get_drvdata(dev);
-
-	free_irq(phydev->irq, phydev);
-
-        kfree(phydev);
-        return (0);
-}
-
-static int ste101p_drv_probe(struct device *dev)
-{
-	struct net_device *ndev;
-	struct phy_driver_local *phydev;
-	struct platform_device *pdev = to_platform_device(dev);
-
-	phydev = kmalloc(sizeof(struct phy_driver_local), GFP_KERNEL);
-
-	/* Get the IRQ number */
-        if ((phydev->irq = platform_get_irq(pdev,0)) == 0){
-                printk(KERN_ERR "%s: ERROR: IRQ configuration "
-                                "information not found\n",__FUNCTION__);
-		return (-ENODEV);
-        }
-	printk(KERN_DEBUG " IRQ #%d\n", phydev->irq);
-
-	if (!strcmp(user_dev_name, "")) {
-		strcpy(user_dev_name, "eth0");
-		printk (KERN_DEBUG "STe101P: omitting the \"device\" "
-			"parameter in the cmdline... it will try with %s\n",
-			user_dev_name);
-	}
-
-	/* Get the ETH driver by name */
-	ndev = __dev_get_by_name(user_dev_name);
-        if (!ndev) {
-                printk(KERN_ERR "%s: ERROR: network %s device not found\n",
-				__FUNCTION__, user_dev_name);
-                return (-1);
-        }
-	printk(KERN_DEBUG "network device (%s) found at address 0x%x\n",
-				ndev->name, (unsigned int)ndev);
-	phydev->dev = ndev;
-	phydev->mii.dev = ndev;
-	phydev->mii.mdio_read = stb7109_mii_read;
-	phydev->mii.mdio_write = stb7109_mii_write;
-	dev_set_drvdata(dev, phydev);
-
-	/* Init the PHY device */
-	ste101p_init_config(phydev);
-
-	return (0);
-}
-
-static struct device_driver ste101p_driver = {
-        .name           = RESOURCE_NAME,
-	.bus            = &platform_bus_type,
-        .probe          = ste101p_drv_probe,
-	.remove		= ste101p_drv_remove,
-};
-
-static int __init ste101p_init(void)
-{
-        printk(KERN_DEBUG "%s: register the device driver...", __FUNCTION__);
-        return driver_register(&ste101p_driver);
-}
-
-static void __exit ste101p_exit(void)
-{
-        printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
-        driver_unregister(&ste101p_driver);
-}
-
-module_init(ste101p_init);
-module_exit(ste101p_exit);
-
-MODULE_DESCRIPTION("STe101p driver");
-MODULE_AUTHOR("Giuseppe Cavallaro");
-MODULE_LICENSE("GPL");
Index: linux/drivers/net/phy/ste10Xp.c
===================================================================
--- /dev/null
+++ linux/drivers/net/phy/ste10Xp.c
@@ -0,0 +1,156 @@
+/* ============================================================================
+ * This is a driver for the STe101p and STe100p PHY controllers.
+ *
+ * Copyright (C) 2006 by Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   Aug  2006
+ *	Converted PHY driver to new 2.6.17 PHY device
+ *	Added STe100p support
+ *	Carl Shaw <carl.shaw@st.com>
+ *   July 2006
+ *	- Minor fixes.
+ *   May 2006
+ *	- It's indipendend from the STb7109eth driver.
+ *   April 2006 (first release of the driver):
+ *	- Added the RMII interface support.
+ * 	- The driver has been tested, on the MB411 platform with the DB666
+ * 	  daughter board, using:
+ *		- the clock through the STPIO3[7],
+ *		- the clock through an external clock generator device.
+ *	- Added the "fix_mac_speed" function: it is used for changing
+ *	  the MAC speed field in the SYS_CFG7 register.
+ *	  (required when we are using the RMII interface).
+ *
+ * ----------------------------------------------------------------------------
+ * Known bugs:
+ * 	The SMII mode is not supported yet.
+ * ===========================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#undef PHYDEBUG
+#define DEFAULT_PHY_ID  0
+#define RESOURCE_NAME	"ste10Xp"
+
+#define MII_XCIIS   	0x11 /* Configuration Info IRQ & Status Reg*/
+#define MII_XIE     	0x12 /* Interrupt Enable Register*/
+#define MII_XIE_DEFAULT_MASK 0x0070 /* ANE complete, Remote Fault, Link Down */
+
+/* STE101P phy identifier values */
+#define STE101P_PHY_ID		0x00061c51
+
+/* STe100P phy identifier values */
+#define STE100P_PHY_ID       	0x1c040011
+
+static int ste10Xp_config_init(struct phy_device *phydev)
+{
+	int value, err;
+
+	/* Software Reset PHY */
+	value = phy_read(phydev, MII_BMCR);
+	if (value < 0)
+		return value;
+
+	value |= BMCR_RESET;
+	err = phy_write(phydev, MII_BMCR, value);
+	if (err < 0)
+		return err;
+
+	do{
+		value = phy_read(phydev, MII_BMCR);
+	} while (value & BMCR_RESET);
+
+	return 0;
+}
+
+static int ste10Xp_config_intr(struct phy_device *phydev)
+{
+        int err, value;
+
+        if(phydev->interrupts == PHY_INTERRUPT_ENABLED){
+		/* Enable all STe101P interrupts (PR12) */
+		err = phy_write(phydev, MII_XIE, MII_XIE_DEFAULT_MASK);
+		/* clear any pending interrupts */
+		if (err == 0){
+			value = phy_read(phydev, MII_XCIIS);
+			if (value <0){
+				err = value;
+			}
+		}
+	} else
+		err = phy_write(phydev, MII_XIE, 0);
+
+        return err;
+}
+
+static int ste10Xp_ack_interrupt(struct phy_device *phydev)
+{
+        int err = phy_read(phydev, MII_XCIIS);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+static struct phy_driver ste101p_pdriver = {
+        .phy_id         = STE101P_PHY_ID,
+        .phy_id_mask    = 0xfffffffc,
+        .name           = "STe101p",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = ste10Xp_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = ste10Xp_ack_interrupt,
+        .config_intr    = ste10Xp_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static struct phy_driver ste100p_pdriver = {
+        .phy_id         = STE100P_PHY_ID,
+        .phy_id_mask    = 0xffffffff,
+        .name           = "STe100p",
+        .features       = PHY_BASIC_FEATURES | SUPPORTED_Pause,
+        .flags          = PHY_HAS_INTERRUPT,
+	.config_init    = ste10Xp_config_init,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = ste10Xp_ack_interrupt,
+        .config_intr    = ste10Xp_config_intr,
+        .driver         = { .owner = THIS_MODULE,},
+};
+
+static int __init ste10Xp_init(void)
+{
+	int retval;
+
+	retval = phy_driver_register(&ste100p_pdriver);
+	if (retval < 0)
+		return retval;
+	return phy_driver_register(&ste101p_pdriver);
+}
+
+static void __exit ste10Xp_exit(void)
+{
+	phy_driver_unregister(&ste100p_pdriver);
+	phy_driver_unregister(&ste101p_pdriver);
+}
+
+module_init(ste10Xp_init);
+module_exit(ste10Xp_exit);
+
+MODULE_DESCRIPTION("STe10Xp PHY driver");
+MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
+MODULE_LICENSE("GPL");
Index: linux/drivers/net/stb7109eth.c
===================================================================
--- linux.orig/drivers/net/stb7109eth.c
+++ /dev/null
@@ -1,1935 +0,0 @@
-/* ============================================================================
- * This is a driver for the STB7109 on-chip Ethernet controller.
- *
- * Copyright (C) 2006 by  Giuseppe Cavallaro <peppe.cavallaro@st.com>
- *
- * ----------------------------------------------------------------------------
- * Driver internals:
- *	The driver is initialized through the platform_device mechanism.
- *	Structures which define the configuration needed by the board
- *	are defined in a internal structure (for example in the
- *	"arch/sh/boards/st/stb7100mboard/setup.c" file).
- *
- *	The STb7109 Ethernet Controller uses two ring of buffer
- * 	descriptors for handling the transmission and the reception processes.
- *
- *	Receive process:
- *  		When one or more packets are received, an interrupt
- *  		happens. Note that the interrupts are not queued so the driver
- *		must scan all the descriptors, from the last recorded to the
- *		first one owned by the DMA controller.
- *  		In NAPI, the interrupt handler will signal there is work to be
- *		done, and exit.  Without NAPI, the packet(s) will be handled
- *  		at once.
- *  		The incoming packets are stored, by the DMA, in a big chunk of
- *  		pre-allocated memory. Finally, a new skb is allocated and
- *		the frame is sent to the kernel.
- *
- *	Transmit process:
- *		When the kernel requests that a packet be transmitted, the
- *  		the xmit function is invoked by the kernel. The skb is
- *		copied in the socket buffer list. Then the relative descriptor
- *		fields in the DMA tx ring is set. Finally, the driver
- *  		informs the DMA engine that there are packets ready to
- *  		be transmitted.  Once the controller is finished transmitting
- *  		the packet, an interrupt is triggered so the driver will be
- *  		able to clean the descriptor used and releas the socket buffer
- *		allocated.
- *
- * ----------------------------------------------------------------------------
- * Kernel Command line arguments:
- *	- stb7109eth=<msg_level>,<watchdog>,<pause_time>
- *		where:
- *		 - <msg_level>: message level (0: no output, 16:  all).
- *		 - <watchdog>:  transmit timeout (in milliseconds).
- *		 - <pause_time>: flow-control pause time (0-65535).
- *		NOTE: you must use the , as delimiter.
- *
- * ----------------------------------------------------------------------------
- * Changelog:
- *   June 2006:
- *	- Reviewed and improved the transmit algorithm.
- *	- Added the NAPI support (as experimental code).
- * 	- Added a new debug option. Now during the kernel configuration phase
- * 	  you can enable the complete debug level for the driver
- *	  (including the debug messages for the critical functions i.e. the
- *	  interrupt handler).
- *   May 2006:
- * 	- Separated out the PHY code.
- *   April 2006:
- *	- Partially removed the STe101p MII interface code.
- *	- The DMA Rx/Tx functions has been re-written.
- *	- Removed the PnSEGADDR and PHYSADDR SH4 macros and added the
- *	  Dynamic DMA mapping support.
- *	- Removed the DMA buffer size parameter. It has been fixed to the
- *	  maximum value. Moreover, the driver will only use a single buffer
- *	  in the DMA because an ethernet frame can be stored in it.
- *	- Fixed some part in the ethtool support.
- *	- Added the 802.1q VLAN support.
- *   March 2006:
- * 	- First release of the driver.
- * ----------------------------------------------------------------------------
- * Known bugs:
- *	- The two-level VLAN tag is not supported yet.
- *	- The NETPOLL support is not fully tested.
- * ---
- *	https://bugzilla.stlinux.com
- * ===========================================================================*/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/skbuff.h>
-#include <linux/ethtool.h>
-#include <linux/if_ether.h>
-#include <linux/crc32.h>
-#include <linux/mii.h>
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-#include <linux/if_vlan.h>
-#endif
-#include <linux/dma-mapping.h>
-
-#include "stb7109eth.h"
-
-/* Generic defines */
-#define RESOURCE_NAME	"stb7109eth"
-#ifdef CONFIG_7109ETH_DEBUG
-#define ETHPRINTK(nlevel, klevel, fmt, args...) \
-		(void)(netif_msg_##nlevel(lp) && \
-		printk(KERN_##klevel fmt, ## args))
-#else
-#define ETHPRINTK(nlevel, klevel, fmt, args...)  do { } while(0)
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
-#define SYSCONF_BASE 		0xb9001000
-#define SYSCONF_DEVICEID        (SYSCONF_BASE + 0x000)
-#endif
-#define DEFAULT_PBL_VALUE	32
-
-/* This structure is common for both receive and transmit DMA descriptors.
- * A descriptor should not be used for storing more than one frame. */
-struct synopsys_dma_des_t {
-	unsigned int  des0; /* Status */
-	unsigned int  des1; /* Ctrl bits, Buffer 2 length, Buffer 1 length */
-	void *des2; /* Buffer 1 Address Pointer */
-	void *des3; /* Buffer 2 Address Pointer or the next Descriptor*/
-};
-
-typedef struct synopsys_dma_des_t synopsys_dma_des;
-
-#define DMA_BUFFER_SIZE	0x800
-
-struct eth_driver_local {
-        int speed;
-	unsigned int mac_enable;
-	unsigned int ip_header_len;
-        struct mii_if_info mii;
-	struct dev_mc_list *dmi;
-	struct net_device_stats stats;
-	u32 msg_enable;
-        spinlock_t lock;
-	synopsys_dma_des *dma_tx; /* virtual DMA TX addr */
-	synopsys_dma_des *cur_tx; /* next free descriptor in the DMA ring */
-	synopsys_dma_des *dirty_tx;/* Tx entry to be freed. */
-	unsigned int skb_curtx;	/* next skb free */
-	unsigned int skb_dirtytx; /* socket buffer to be freed at interrupt
-				     time*/
-	dma_addr_t dma_tx_phy;	   /* bus DMA TX addr */
-	struct sk_buff *tx_skb[CONFIG_DMA_TX_SIZE];
-  	synopsys_dma_des *dma_rx; /* virtual DMA RX addr */
-	dma_addr_t dma_rx_phy;	  /* bus DMA RX addr */
-	dma_addr_t rx_mem_phy;
-	int rx_pos; /* last position of the frame recorded the Rx dma ring*/
-	unsigned int rx_buff; /*it contains the last rx buf owned by the DMA*/
-	void *rx_mem;
-
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	struct vlan_group *vlgrp;
-#endif
-};
-
-/* Module Arguments */
-#define TX_TIMEO (5*HZ)
-static int watchdog = TX_TIMEO;
-module_param(watchdog, int, S_IRUGO);
-MODULE_PARM_DESC(watchdog, "Transmit Timeout (in milliseconds)");
-
-static int debug = -1; /* -1: use default, 0: no output, 16:  all */
-module_param(debug, int, S_IRUGO|S_IWUGO);
-MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
-
-#define MAX_PAUSE_TIME (MAC_FLOW_CONTROL_PT_MASK>>MAC_FLOW_CONTROL_PT_SHIFT)
-static int pause_time = MAX_PAUSE_TIME;
-module_param(pause_time, int, S_IRUGO|S_IWUGO);
-MODULE_PARM_DESC(flowctrl, "pause time");
-
-static const char version[] = "stb7109eth - (C) STM 2006\n";
-
-static const u32 default_msg_level = NETIF_MSG_DRV |NETIF_MSG_PROBE|
-				     NETIF_MSG_LINK |NETIF_MSG_IFUP|
-				     NETIF_MSG_IFDOWN|NETIF_MSG_TIMER;
-
-static irqreturn_t stb7109eth_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs);
-#ifndef CONFIG_7109ETH_NAPI
-static int stb7109eth_rx (struct net_device *dev);
-#else
-static int stb7109eth_poll(struct net_device *dev, int *budget);
-#endif
-
-static void stb7109eth_check_mod_params(struct net_device *dev)
-{
-	if (watchdog < 0) {
-		watchdog = TX_TIMEO;
-		printk (KERN_WARNING "\tWARNING: invalid tx timeout "
-				     "(default is %d)\n", watchdog);
-	}
-
-	if ((pause_time <= 0) || (pause_time >= MAX_PAUSE_TIME))
-		pause_time = MAX_PAUSE_TIME;
-
-	return;
-}
-
-static inline void print_mac_addr(u8 addr[6])
-{
-	int i;
-	for (i = 0; i < 5; i++)
-		printk("%2.2x:", addr[i]);
-	printk("%2.2x\n", addr[5]);
-	return;
-}
-
-#ifdef CONFIG_7109ETH_DEBUG
-static void print_pkt(unsigned char *buf, int len)
-{
-	int j;
-	printk("len = %d byte, buf addr: 0x%p", len, buf);
-	for (j=0; j<len; j++) {
-		if ((j%16) == 0)
-			printk("\n %03x:", j);
-		printk(" %02x", buf[j]);
-	}
-	printk("\n");
-	return;
-}
-#endif
-
-/* The PBL indicates the maximum number of DWORDs to be transferred in one DMA
- * transaction.
- * It seems that the Programmable Burst Length bit in the CSR0 must be set to 1
- * for the Stb7109 CUT 1.x and to 32 for the CUT 2.x. */
-static int fix_pbl_value(void)
-{
-	unsigned long sysconf;
-
-	sysconf = ctrl_inl(SYSCONF_DEVICEID);
-	if (((sysconf >> 28) & 0xF) == 0)
-		return (1);
-	else if (((sysconf >> 28) & 0xF) == 1)
-		return (DEFAULT_PBL_VALUE);
-}
-
-#define SYSCONF_SYS_CFG(n)      (SYSCONF_BASE + 0x100 + ((n) * 4))
-#define MAC_SPEED_SEL		0x00100000 /* MAC is running at 100 Mbps */
-void fix_mac_speed(unsigned int speed)
-{
-#ifdef CONFIG_STE101P_RMII
-        unsigned long sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
-
-        if (speed == SPEED_100)
-                sysconf |= MAC_SPEED_SEL;
-        else if (speed == SPEED_10)
-                sysconf &= ~MAC_SPEED_SEL;
-
-	printk (KERN_DEBUG  "fix_mac_speed: speed = %d, sysconf7 = 0x%x\n",
-				           speed, (unsigned int) sysconf);
-
-	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
-#endif
-        return;
-}
-
-/* ----------------------------------------------------------------------------
-				 MII Interface
-   ---------------------------------------------------------------------------*/
-/*  Read data from the MII register from within the specified phy device,
- *  arguments:
- *	phyaddr: MII addr reg bits 15-11
- *	phyreg: MII addr reg bits 10-6
- */
-int stb7109_mii_read (struct net_device *dev, int phyaddr, int phyreg)
-{
-	unsigned long ioaddr=dev->base_addr;
-	u16 regValue=(((phyaddr << 11)&(0x0000F800))|
-		      ((phyreg<<6)&(0x000007C0)));
-
-	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
-
-	writel(regValue, ioaddr+MAC_MII_ADDR);
-
-	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
-
-	/* Read the data from the MII data register */
-	return ((u16)(readl(ioaddr+MAC_MII_DATA) & 0xFFFF));
-}
-
-/* Writes the data intto the MII register from within the specified device */
-void stb7109_mii_write(struct net_device *dev, int phyaddr, int phyreg,
-		       int phydata)
-{
-	unsigned long ioaddr=dev->base_addr;
-	u16 value=(((phyaddr<<11)&(0x0000F800))|((phyreg<<6)&(0x000007C0)))|
-			MAC_MII_ADDR_WRITE;
-
-	/* Wait until any existing MII operation is complete */
-	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
-
-	/* Set the MII address register to write */
-	writel(phydata, ioaddr+MAC_MII_DATA);
-	writel(value, ioaddr+MAC_MII_ADDR);
-
-	/* Wait until any existing MII operation is complete */
-	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
-
-	/* NOTE: we need to perform this "extra" read in order to fix an error
-	 * during the write operation */
-	stb7109_mii_read(dev, phyaddr, phyreg);
-	return;
-}
-
-void stb7109eth_set_mac_mii_cap(struct mii_if_info mii, unsigned int speed,
-				struct net_device *dev)
-{
-	unsigned long ioaddr=dev->base_addr;
-	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned int flow=(unsigned int) readl(ioaddr+MAC_FLOW_CONTROL),
-		     ctrl=(unsigned int) readl(ioaddr+MAC_CONTROL);
-
-	printk (KERN_DEBUG "%s\n", __FUNCTION__);
-
-	lp->mii = mii;
-	lp->speed = speed;
-
-	if (!(mii.full_duplex)) { /* Half Duplex */
-		flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
-			  MAC_FLOW_CONTROL_PCF);
-		ctrl &= ~MAC_CONTROL_F;
-		ctrl |= MAC_CONTROL_DRO;
-
-	} else {  /* Full Duplex */
-		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
-			(pause_time << MAC_FLOW_CONTROL_PT_SHIFT);
-		ctrl |= MAC_CONTROL_F;
-		ctrl &= ~MAC_CONTROL_DRO;
-	}
-
-	writel(flow, ioaddr+MAC_FLOW_CONTROL);
-	writel(ctrl, ioaddr+MAC_CONTROL);
-
-	fix_mac_speed(lp->speed);
-
-	return;
-}
-
-EXPORT_SYMBOL(stb7109eth_set_mac_mii_cap);
-EXPORT_SYMBOL(stb7109_mii_read);
-EXPORT_SYMBOL(stb7109_mii_write);
-
-/* ----------------------------------------------------------------------------
-				 MAC CORE Interface
-   ---------------------------------------------------------------------------*/
-/* Print the MAC CSR registers */
-static inline void dump_synopsys_mac_csr(unsigned long ioaddr)
-{
-	printk ("\t----------------------------------------------\n"
-		"\t STb7109eth MAC CSR (base addr = 0x%8x)\n"
-		"\t----------------------------------------------\n",
-		(unsigned int)ioaddr);
-	printk ("\tcontrol reg (offset 0x%x): 0x%lx\n", MAC_CONTROL,
-			readl(ioaddr+MAC_CONTROL));
-	printk ("\taddr HI (offset 0x%x): 0x%lx\n ", MAC_ADDR_HIGH,
-			readl(ioaddr+MAC_ADDR_HIGH));
-	printk ("\taddr LO (offset 0x%x): 0x%lx\n", MAC_ADDR_LOW,
-			readl(ioaddr+MAC_ADDR_LOW));
-	printk ("\tmulticast hash HI (offset 0x%x): 0x%lx\n", MAC_HASH_HIGH,
-			readl(ioaddr+MAC_HASH_HIGH));
-	printk ("\tmulticast hash LO (offset 0x%x): 0x%lx\n", MAC_HASH_LOW,
-			readl(ioaddr+MAC_HASH_LOW));
-	printk ("\tflow control (offset 0x%x): 0x%lx\n", MAC_FLOW_CONTROL,
-			readl(ioaddr+MAC_FLOW_CONTROL));
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	printk ("\tVLAN1 tag (offset 0x%x): 0x%lx\n", MAC_VLAN1,
-			readl(ioaddr+MAC_VLAN1));
-	printk ("\tVLAN2 tag (offset 0x%x): 0x%lx\n", MAC_VLAN2,
-			readl(ioaddr+MAC_VLAN2));
-#endif
-	printk ("\tmac wakeup frame (offset 0x%x): 0x%lx\n", MAC_WAKEUP_FILTER,
-			readl(ioaddr+MAC_WAKEUP_FILTER));
-	printk ("\tmac wakeup crtl (offset 0x%x): 0x%lx\n",
-			MAC_WAKEUP_CONTROL_STATUS,
-			readl(ioaddr+MAC_WAKEUP_CONTROL_STATUS));
-
-	printk ("\n\tMAC management counter registers\n");
-	printk ("\t MMC crtl (offset 0x%x): 0x%lx\n",
-			MMC_CONTROL, readl(ioaddr+MMC_CONTROL));
-	printk ("\t MMC High Interrupt (offset 0x%x): 0x%lx\n",
-			MMC_HIGH_INTR, readl(ioaddr+MMC_HIGH_INTR));
-	printk ("\t MMC Low Interrupt (offset 0x%x): 0x%lx\n",
-			MMC_LOW_INTR, readl(ioaddr+MMC_LOW_INTR));
-	printk ("\t MMC High Interrupt Mask (offset 0x%x): 0x%lx\n",
-			MMC_HIGH_INTR_MASK, readl(ioaddr+MMC_HIGH_INTR_MASK));
-	printk ("\t MMC Low Interrupt Mask (offset 0x%x): 0x%lx\n",
-			MMC_LOW_INTR_MASK, readl(ioaddr+MMC_LOW_INTR_MASK));
-	return;
-}
-
-/* Set the hardware MAC address */
-static void set_synopsys_mac_addr(unsigned long ioaddr, u8 Addr[6])
-{
-	unsigned long data;
-
-	data = (Addr[5]<<8) | Addr[4];
-        writel(data, ioaddr+MAC_ADDR_HIGH );
-        data = (Addr[3]<<24) | (Addr[2]<<16) | (Addr[1]<<8) | Addr[0];
-        writel(data, ioaddr+MAC_ADDR_LOW);
-
-	return;
-}
-
-/* Get the hardware MAC address  */
-static void get_synopsys_mac_address(unsigned long ioaddr, unsigned char *addr)
-{
-	unsigned int hi_addr, lo_addr;
-
-	/* Read the MAC address from the hardware */
-	hi_addr = (unsigned int) readl(ioaddr+MAC_ADDR_HIGH);
-	lo_addr = (unsigned int) readl(ioaddr+MAC_ADDR_LOW);
-
-	/* Extract the MAC address from the high and low words */
-	addr[0] = lo_addr & 0xff;
-	addr[1] = (lo_addr >>  8) & 0xff;
-	addr[2] = (lo_addr >> 16) & 0xff;
-	addr[3] = (lo_addr >> 24) & 0xff;
-	addr[4] = hi_addr & 0xff;
-	addr[5] = (hi_addr >>  8) & 0xff;
-
-	return;
-}
-
-static void synopsys_mac_enable(struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-
-	ETHPRINTK(probe, DEBUG, "%s: MAC RX/TX enabled\n", RESOURCE_NAME);
-
-	/* set: TE (transmitter enable, bit 3), RE (receive enable, bit 2)
-	   and RA (receive all mode, bit 31) */
-	value |= (MAC_CONTROL_RA|MAC_CONTROL_TE|MAC_CONTROL_RE);
-	writel(value, ioaddr+MAC_CONTROL);
-	lp->mac_enable = 1;
-	return;
-}
-
-static void synopsys_mac_disable(struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-
-	ETHPRINTK(probe, DEBUG, "%s: MAC RX/TX disabled\n", RESOURCE_NAME);
-
-	value &= ~(MAC_CONTROL_RA|MAC_CONTROL_TE|MAC_CONTROL_RE);
-	writel(value, ioaddr+MAC_CONTROL);
-	lp->mac_enable = 0;
-	return;
-}
-
-/* This function provides the initial setup of the MAC controller */
-static void synopsys_mac_core_init(struct net_device *dev)
-{
-	unsigned int value = 0;
-	unsigned long ioaddr=dev->base_addr;
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	/* Set the MAC control register with our default value */
-        value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-        value |= MAC_CONTROL_HBD | MAC_CONTROL_PM;
-        writel(value, ioaddr+MAC_CONTROL);
-
-	/* Check the MAC address*/
-	printk(KERN_INFO "STb7109eth: MAC Core setup:\n"
-			      "\tHW MAC address: ");
-	get_synopsys_mac_address(ioaddr, dev->dev_addr);
-	print_mac_addr(dev->dev_addr);
-
-        if (!is_valid_ether_addr(dev->dev_addr)) {
-                printk (KERN_WARNING "\tno valid MAC address; "
-				    "please, set using ifconfig!\n");
-        }
-
-	/* Change the MAX_FRAME bits in the MMC control register. */
-	value = dev->mtu + lp->ip_header_len + 4 /*fsc*/;
-	writel(((value << MMC_CONTROL_MAX_FRM_SHIFT) &
-		MMC_CONTROL_MAX_FRM_MASK), dev->base_addr+MMC_CONTROL);
-
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	writel(ETH_P_8021Q, dev->base_addr+MAC_VLAN1);
-#endif
-	return;
-}
-
-/* ----------------------------------------------------------------------------
- *  			DESCRIPTORS functions
- * ---------------------------------------------------------------------------*/
-static void display_dma_desc_ring(synopsys_dma_des *p, int size)
-{
-	int i;
-	for (i=0; i<size; i++)
-		printk ("\t%d [0x%x]: "
-			"desc0=0x%x desc1=0x%x buffer1=0x%x\n", i,
-			(unsigned int) virt_to_phys(&p[i].des0), p[i].des0,
-			p[i].des1, (unsigned int)p[i].des2);
-}
-
-static void init_desc_owner (synopsys_dma_des *head, unsigned int size,
-			    unsigned int owner)
-{
-	int i;
-	synopsys_dma_des *p = head;
-
-	for (i=0; i<size; i++) {
-		p->des0 = owner;
-		p++;
-	}
-	return;
-}
-
-static void init_dma_ring(synopsys_dma_des *p, dma_addr_t phy,
-			  unsigned int ring_size, unsigned int own_bit)
-{
-	int i;
-	for (i=0; i<ring_size; i++) {
-		p->des0 = own_bit;
-		p->des1 = (!(own_bit) ? 0 :
-			  ((DMA_BUFFER_SIZE-1)<<DES1_RBS1_SIZE_SHIFT));
-		if (i == ring_size-1) {
-			p->des1 |= DES1_CONTROL_TER;
-		}
-		p->des2 = (!(own_bit)?0:((void *)(phy+(i*DMA_BUFFER_SIZE))));
-		p->des3 = NULL;
-		p++;
-	}
-	return;
-}
-
-/* Allocate and init the TX and RX descriptors rings.
- * The driver uses the 'implicit' scheme for implementing the TX/RX DMA
- * linked lists. */
-static void init_dma_desc_rings(struct net_device *dev)
-{
-	int i;
-	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned int rx_mem_size = (CONFIG_DMA_RX_SIZE*DMA_BUFFER_SIZE);
-
-	ETHPRINTK(probe, DEBUG,"%s: allocate and init the DMA RX/TX lists\n",
-			    RESOURCE_NAME);
-
-	/* Allocate memory for the DMA RX/TX buffer descriptors */
-	lp->dma_rx = (synopsys_dma_des *) dma_alloc_coherent(NULL,
-		 CONFIG_DMA_RX_SIZE*sizeof(struct synopsys_dma_des_t),
-		 &lp->dma_rx_phy, GFP_KERNEL);
-
-	lp->dma_tx = (synopsys_dma_des *) dma_alloc_coherent(NULL,
-		 CONFIG_DMA_TX_SIZE*sizeof(struct synopsys_dma_des_t),
-		 &lp->dma_tx_phy, GFP_KERNEL);
-
-	if ((lp->dma_rx == NULL)||(lp->dma_tx == NULL)) {
-		printk(KERN_ERR "%s:ERROR allocating the DMA Tx/Rx desc\n",
-			__FUNCTION__);
-		return;
-	}
-
-	ETHPRINTK(probe, DEBUG, "%s: DMA desc rings: virt addr (Rx 0x%08x, "
-		"Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
-		dev->name, (unsigned int)lp->dma_rx ,(unsigned int)lp->dma_tx,
-		(unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
-
-	/* The frames received will be put in 'lp->rx_mem'. In fact the
-	 * buffer in each descriptor will point to the relative position
-	 * in this chunk of memory. */
-	lp->rx_mem = (void *) dma_alloc_coherent(NULL,rx_mem_size,
-		 &lp->rx_mem_phy, GFP_KERNEL);
-
-	memset(lp->rx_mem, 0, rx_mem_size);
-
-	ETHPRINTK(probe, DEBUG, "%s: DMA RX mem: virt addr=0x%08x, "
-			        "phy addr=0x%08x, len=%d\n",
-				 __FUNCTION__, (unsigned int)lp->rx_mem,
-				 (unsigned int)lp->rx_mem_phy, rx_mem_size);
-
-	init_dma_ring(lp->dma_rx, lp->rx_mem_phy, CONFIG_DMA_RX_SIZE, OWN_BIT);
-	init_dma_ring(lp->dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
-
-	if (netif_msg_hw(lp)) {
-		printk (" - RX descriptor ring:\n");
-		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
-		printk (" - TX descriptor ring:\n");
-		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
-	}
-
-	/* Init the transmit socket buffers */
-	for (i=0;i < CONFIG_DMA_TX_SIZE;i++)
-		lp->tx_skb[i] = NULL;
-
-	/* Initialize some TX variables */
-        lp->dirty_tx = lp->cur_tx = lp->dma_tx;
-        lp->skb_curtx = lp->skb_dirtytx = 0;
-    return;
-}
-
-/* Release and free the descriptor resources. */
-static void free_dma_desc_resources(struct net_device *dev)
-{
-	unsigned int rx_mem_size = (CONFIG_DMA_RX_SIZE*DMA_BUFFER_SIZE);
-
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	dma_free_coherent(NULL,
-		CONFIG_DMA_TX_SIZE*sizeof(struct synopsys_dma_des_t),
-		lp->dma_tx, lp->dma_tx_phy);
-	dma_free_coherent(NULL,
-		CONFIG_DMA_RX_SIZE*sizeof(struct synopsys_dma_des_t),
-		lp->dma_rx, lp->dma_rx_phy);
-	dma_free_coherent(NULL, rx_mem_size, lp->rx_mem, lp->rx_mem_phy);
-
-	return;
-}
-
-/* ----------------------------------------------------------------------------
-				DMA FUNCTIONS
- * ---------------------------------------------------------------------------*/
-static inline void dump_dma_csr(unsigned long ioaddr)
-{
-	int i;
-	printk ("\t--------------------\n"
-		"\t STb7109eth DMA CSR \n"
-		"\t--------------------\n");
-	for (i = 0; i<9; i++) {
-		printk ("\t CSR%d (offset 0x%x): 0x%lx\n", i,
-			(DMA_BUS_MODE + i*4), readl(ioaddr+DMA_BUS_MODE + i*4));
-	}
-	printk ("\t CSR20 (offset 0x%x): 0x%lx\n",
-		DMA_CUR_TX_BUF_ADDR, readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
-	printk ("\t CSR21 (offset 0x%x): 0x%lx\n",
-		DMA_CUR_RX_BUF_ADDR, readl(ioaddr+DMA_CUR_RX_BUF_ADDR));
-	return;
-}
-
-/* DMA SW reset.
- *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
- *	   SW reset otherwise the MAC core won't exit the reset state.
- *  NOTE2: after a SW reset all interrupts are disabled */
-static void synopsys_dma_reset(unsigned long ioaddr)
-{
-	unsigned int value;
-
-	value=(unsigned int)readl(ioaddr+DMA_BUS_MODE);
-	value|= DMA_BUS_MODE_SFT_RESET;
-
-	writel(value, ioaddr+DMA_BUS_MODE);
-
-	while ((readl(ioaddr+DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {}
-
-	return;
-}
-
-/* START/STOP the DMA TX/RX processes */
-static void synopsys_dma_start_tx(unsigned long ioaddr)
-{
-	unsigned int value;
-
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |= DMA_CONTROL_ST ;
-	writel(value, ioaddr+DMA_CONTROL);
-
-	return;
-}
-
-static void synopsys_dma_stop_tx(unsigned long ioaddr)
-{
-	unsigned int value;
-
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |=  ~DMA_CONTROL_ST;
-	writel(value, ioaddr+DMA_CONTROL);
-
-	return;
-}
-
-static void stb7109eth_stop_tx(struct net_device *dev)
-{
-	int i;
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	netif_stop_queue(dev);
-	synopsys_dma_stop_tx(dev->base_addr);
-
-	for (i=0;i < CONFIG_DMA_TX_SIZE;i++)
-		if (lp->tx_skb[i] != NULL)
-			dev_kfree_skb_any(lp->tx_skb[i]);
-
-	init_desc_owner(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
-
-	return;
-}
-
-static void synopsys_dma_start_rx(unsigned long ioaddr)
-{
-	unsigned int value;
-
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |= DMA_CONTROL_SR ;
-	writel(value, ioaddr+DMA_CONTROL);
-
-	return;
-}
-
-static void synopsys_dma_stop_rx(unsigned long ioaddr)
-{
-	unsigned int value;
-
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |=  ~DMA_CONTROL_SR;
-	writel(value, ioaddr+DMA_CONTROL);
-
-	return;
-}
-
-/* The DMA init function performs:
- * - the DMA RX/TX SW descriptors initialization
- * - the DMA HW controller initialization
- * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
-static int synopsys_dma_init(struct net_device *dev)
-{
-	unsigned int value;
-	unsigned long ioaddr = dev->base_addr;
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	ETHPRINTK(probe, DEBUG, "STb7109eth: DMA Core setup\n");
-
-	/* DMA SW reset */
-	synopsys_dma_reset(ioaddr);
-
-	/* Enable Application Access by writing to DMA CSR0 */
-	value = fix_pbl_value();
-	writel(DMA_BUS_MODE_DEFAULT | (value << DMA_BUS_MODE_PBL_SHIFT) ,
-	       ioaddr+DMA_BUS_MODE);
-
-	/* Mask interrupts by writing to CSR7 */
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr+DMA_INTR_ENA);
-
-	/* The base address of the RX/TX descriptor lists must be written into
-	 * DMA CSR3 and CSR4, respectively. */
-	writel((unsigned long)lp->dma_tx_phy,ioaddr+DMA_TX_BASE_ADDR);
-	writel((unsigned long)lp->dma_rx_phy,ioaddr+DMA_RCV_BASE_ADDR);
-
-	if (netif_msg_hw(lp))
-		dump_dma_csr(ioaddr);
-
-	return (0);
-}
-
-#ifdef CONFIG_7109ETH_DEBUG
-/* Transmit Process State for CSR5[22:20] */
-static void show_tx_process_state(unsigned int status)
-{
-	unsigned int state;
-	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
-
-	printk(KERN_DEBUG" DMA tx status: \n");
-	switch (state) {
-	   case 0: printk(KERN_DEBUG " -TX (Stopped): Reset or Stop command\n");
-	   	   break;
-	   case 1: printk(KERN_DEBUG " -TX (Running):Fetching the Tx desc\n");
-	   	   break;
-	   case 2: printk(KERN_DEBUG " -TX (Running): Waiting for end of tx\n");
-	   	   break;
-	   case 3: printk(KERN_DEBUG " -TX (Running): Reading the data "
-				    "and queuing the data into the Tx buf\n");
-	   	   break;
-	   case 6: printk(KERN_DEBUG " -TX (Suspended): Tx Buff Underflow "
-				    "or an unavailable Transmit descriptor\n");
-	   	   break;
-	   case 7: printk(KERN_DEBUG " -TX (Running): Closing Tx descriptor\n");
-	   	   break;
-	   default:
-	   	   break;
-	   }
-	return;
-}
-
-/* Receive Process State for CSR5[19:17] */
-static void show_rx_process_state(unsigned int status)
-{
-	unsigned int state;
-	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
-
-	printk(KERN_DEBUG" DMA rx status: \n");
-	switch (state) {
-	   case 0: printk(KERN_DEBUG " -RX (Stopped): Reset or Stop command\n");
-	   	   break;
-	   case 1: printk(KERN_DEBUG " -RX (Running): Fetching the Rx desc\n");
-	   	   break;
-	   case 2: printk(KERN_DEBUG" -RX (Running):Checking for end of pkt\n");
-	   	   break;
-	   case 3: printk(KERN_DEBUG " -RX (Running): Waiting for Rx pkt\n");
-	   	   break;
-	   case 4: printk(KERN_DEBUG " -RX (Suspended): Unavailable Rx buf\n");
-	   	   break;
-	   case 5: printk(KERN_DEBUG " -RX (Running): Closing Rx descriptor\n");
-	   	   break;
-	   case 6: printk(KERN_DEBUG" - RX(Running): Flushing the current frame"
-				    " from the Rx buf\n");
-	   	   break;
-	   case 7: printk(KERN_DEBUG " -RX (Running): Queuing the Rx frame"
-				    " from the Rx buf into memory\n");
-	   	   break;
-	   default:
-	   	   break;
-	}
-	return;
-}
-#endif
-
-/* When the transmission is completed the frame status is written into
- * TDESC0 of the descriptor having the LS bit set.
- * This function returns zero if no error is happened during the transmission.*/
-static int check_tx_error_summary(struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-	synopsys_dma_des *p = lp->dirty_tx;
-
-	/* The TDES0 of the LS segment will contain the frame
-	   status */
-	while (!(p->des1 & TDES1_CONTROL_LS))
-		p++;
-
-	ETHPRINTK(intr, INFO,"[0x%x] TDES0: 0x%x\n", (unsigned int)p, p->des0);
-
-	if (p->des0 & TDES0_STATUS_DF) {
-		ETHPRINTK(tx_err, WARNING,"%s: DMA tx: deferred error\n",
-				RESOURCE_NAME);
-		goto out_error;
-	}
-	if (p->des0 & TDES0_STATUS_HRTBT_FAIL) {
-		ETHPRINTK(tx_err, WARNING, "%s: DMA tx: Heartbeat Fail\n",
-					RESOURCE_NAME);
-		lp->stats.tx_heartbeat_errors++;
-		goto out_error;
-	}
-
-	if (p->des0 & TDES0_STATUS_ES) {
-		ETHPRINTK(tx_err, ERR,  "%s: DMA tx ERROR: ", RESOURCE_NAME);
-
-		if (p->des0 & TDES0_STATUS_UF) {
-			ETHPRINTK(tx_err, ERR, "Underflow Error\n");
-			goto out_error;
-		}
-		if (p->des0 & TDES0_STATUS_EX_DEF){
-			ETHPRINTK(tx_err, ERR, "Ex Deferrals\n");
-			goto set_collision;
-		}
-		if (p->des0 & TDES0_STATUS_EX_COL) {
-			ETHPRINTK(tx_err, ERR, "Ex Collisions\n");
-			goto set_collision;
-		}
-		if (p->des0 & TDES0_STATUS_LATE_COL) {
-			ETHPRINTK(tx_err, ERR, "Late Collision\n");
-			goto set_collision;
-		}
-		if (p->des0 & TDES0_STATUS_NO_CARRIER){
-			ETHPRINTK(tx_err, ERR, "No Carrier\n");
-			goto out_error;
-		}
-		if (p->des0 & TDES0_STATUS_LOSS_CARRIER) {
-			ETHPRINTK(tx_err, ERR, "Loss of Carrier\n");
-			goto out_error;
-		}
-	}
-
-	return (0);
-
-set_collision:
-	lp->stats.collisions +=((p->des0 & TDES0_STATUS_COLCNT_MASK)>>
-		TDES0_STATUS_COLCNT_SHIFT);
-out_error:
-	lp->stats.tx_errors++;
-
-	return (-1);
-}
-
-/* When a frame is received the status is written into TDESC0 of the descriptor
- * having the LS bit set. */
-static int check_rx_error_summary(struct eth_driver_local *lp,
-			          unsigned int status)
-{
-	if (status & RDES0_STATUS_ES) {
-		ETHPRINTK(rx_err, ERR, "%s: DMA rx ERROR: ", RESOURCE_NAME);
-		if (status & RDES0_STATUS_DE)
-			ETHPRINTK(rx_err, ERR, "descriptor error\n");
-		if (status & RDES0_STATUS_PFE)
-			ETHPRINTK(rx_err, ERR, "partial frame error\n");
-		if (status & RDES0_STATUS_RUNT_FRM)
-			ETHPRINTK(rx_err, ERR, "runt Frame\n");
-		if (status & RDES0_STATUS_TL)
-			ETHPRINTK(rx_err, ERR, "frame too long\n");
-		if (status & RDES0_STATUS_COL_SEEN) {
-			ETHPRINTK(rx_err, ERR, "collision seen\n");
-			lp->stats.collisions++;
-		}
-		if (status & RDES0_STATUS_CE)
-			ETHPRINTK(rx_err, ERR, "CRC Error\n");
-
-		lp->stats.rx_errors++;
-
-		return (-EINVAL);
-	}
-	return (0);
-}
-
-/* Get the last frame position in the Rx DMA ring */
-static inline void get_rx_last_frame_pos(struct  eth_driver_local *lp)
-{
-	lp->rx_pos = ((lp->rx_buff-lp->rx_mem_phy)/(DMA_BUFFER_SIZE))-1;
-	return;
-}
-
-
-static void synopsys_dma_tx_irq(struct net_device *dev)
-{
-	struct  eth_driver_local *lp = netdev_priv(dev);
-
-#ifdef CONFIG_7109ETH_DEBUG
-        if (netif_msg_tx_done(lp)) {
-                printk(">> TX done: next tx desc=0x%x, desc used=0x%x "
-                  "(free the skb #%d, next skb free #%d)\n",
-                  (unsigned int)lp->cur_tx, (unsigned int)lp->dirty_tx,
-                  lp->skb_dirtytx, lp->skb_curtx);
-                printk ("    TX descriptor ring:\n");
-                display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
-        }
-#endif
-
-	/* If the lp->dirty_tx and the lp->cur_tx are the same, the Tx ring
-	 * could be either empty or full (only in the beginning).  */
-	if ((lp->dirty_tx == lp->cur_tx) && (netif_queue_stopped(dev) == 0))
-                        return;
-
-	check_tx_error_summary(dev);
-	lp->stats.tx_packets++;
-
-	/* Release the Tx resources */
-	(lp->dirty_tx)->des1 =
-                   ((lp->dirty_tx)->des1 & DES1_CONTROL_TER)?DES1_CONTROL_TER:0;
-	dma_unmap_single(NULL, (lp->dirty_tx)->des2,
-                         lp->tx_skb[lp->skb_dirtytx]->len, DMA_TO_DEVICE);
-	(lp->dirty_tx)->des2 = NULL;
-
-	/* Free the sk buffer associated with this descriptor */
-	if (lp->tx_skb[lp->skb_dirtytx] != NULL) {
-	        dev_kfree_skb_irq(lp->tx_skb[lp->skb_dirtytx]);
-	        lp->tx_skb[lp->skb_dirtytx] = NULL;
-	}
-
-        lp->skb_dirtytx = (lp->skb_dirtytx + 1) % CONFIG_DMA_TX_SIZE;
-	if ((lp->dirty_tx)->des1 & DES1_CONTROL_TER)
-		lp->dirty_tx = lp->dma_tx;
-	else
-		lp->dirty_tx++;
-
-	/* We freed a buffer, so now we can restart transmission */
-	if (netif_queue_stopped(dev))
-		netif_wake_queue(dev);
-
-	return;
-}
-
-/*
- *  --- Interrupt handler for the MAC110 DMA
- *
- * It determines if we have to call either the Rx or the Tx interrupt handler.
- * Numerous events can cause an interrupt: a new packet has arrived
- * or transmission is completed or an error occurred).
- * The CSR5 contains all the bits can cause an interrupt while the CSR7
- * contains an enable bit for each of them. There are two groups of interrupts:
- *  - normal
- *  - abnormal (as outlined in the CSR5)
- *  Note: we won't use the Early interrupts (disabled in the DMA_INTR_ENA). */
-static void synopsys_dma_interrupt(struct net_device *dev)
-{
-	unsigned int status;
-	struct  eth_driver_local *lp = netdev_priv(dev);
-
-	/* read the status register (CSR5) */
-	status = (unsigned int)readl(dev->base_addr+DMA_STATUS);
-	lp->rx_buff = (unsigned int)readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
-
-	ETHPRINTK(intr, INFO, "%s: (%s) [CSR5: 0x%08x]\n", RESOURCE_NAME,
-			      "DMA IRQ", status);
-
-#ifdef CONFIG_7109ETH_DEBUG
-	if (netif_msg_tx_done(lp))
-		show_tx_process_state(status);
-	if (netif_msg_rx_status(lp))
-		show_rx_process_state(status);
-#endif
-	/* Process the NORMAL interrupts */
-	if (status & DMA_STATUS_NIS) {
-		ETHPRINTK(intr, INFO, " CSR5[16]: DMA NORMAL IRQ: ");
-		if (status & DMA_STATUS_TI) {
-			ETHPRINTK(tx_done, INFO, "CSR5[0] Transmit interrupt"
-			" [next buf: %lx]\n",
-	          	readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR));
-			synopsys_dma_tx_irq(dev);
-		}
-		/*  CSR5[2] Transmit Buffer Unavailable the next desc in the TX
-		    list cannot be aquired by the DMA controller */
-		if (status & DMA_STATUS_TU) {
-			ETHPRINTK (intr, INFO, "Transmit Buffer Unavailable\n");
-		/*	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);*/
-		}
-		/* CSR5[6] Receive interrupt: it indicates the completition
-		   of the frame reception. */
-		if (status & DMA_STATUS_RI) {
-			lp->rx_buff = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
-			ETHPRINTK(intr,INFO,"Receive Interrupt [buf: 0x%08x\n]",
-					     lp->rx_buff);
-
-#ifndef CONFIG_7109ETH_NAPI
-			stb7109eth_rx(dev);
-#else
-			/* scheduling dev->poll */
-			synopsys_dma_stop_rx(dev->base_addr);
-			if (netif_rx_schedule_prep(dev)) {
-				get_rx_last_frame_pos(lp);
-	                	__netif_rx_schedule(dev);
-	        	} else {
-				ETHPRINTK (intr, DEBUG,"%s: bug!!! "
-				  "interrupt while in poll.\n", __FUNCTION__);
-        		}
-#endif
-		}
-		if (status & DMA_STATUS_ERI) {
-#if 0
-			ETHPRINTK(intr,INFO,"Early Receive Interrupt\n");
-			status |= DMA_STATUS_RI;
-			stb7109eth_rx(dev);
-#endif
-		}
-	}
-	/* Process the ABNORMAL interrupts */
-	if (status & DMA_STATUS_AIS) {
-		ETHPRINTK (intr, INFO,"CSR5[15] DMA ABNORMAL IRQ: ");
-		if (status & DMA_STATUS_TPS) {
-			ETHPRINTK (intr, INFO,"Transmit Process Stopped \n");
-			synopsys_dma_start_tx(dev->base_addr);
-		}
-		if (status & DMA_STATUS_TJT){
-			ETHPRINTK (intr, INFO,"Transmit Jabber Timeout\n");
-			synopsys_dma_start_tx(dev->base_addr);
-		}
-		if (status & DMA_STATUS_OVF) {
-			ETHPRINTK (intr, INFO,"Receive Overflow\n");
-		}
-		if (status & DMA_STATUS_UNF) {
-			ETHPRINTK (intr, INFO,"Transmit Underflow\n");
-			writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
-		}
-		if (status & DMA_STATUS_RU){
-			ETHPRINTK (intr, INFO,"Rx Buffer Unavailable\n");
-#if 0
-			init_desc_owner(lp->dma_rx, CONFIG_DMA_RX_SIZE,OWN_BIT);
-			writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
-#endif
-		}
-		if (status & DMA_STATUS_RPS){
-			ETHPRINTK (intr, INFO,"Receive Process Stopped\n");
-			synopsys_dma_start_rx(dev->base_addr);
-		}
-		if (status & DMA_STATUS_RWT){
-			ETHPRINTK (intr, INFO,"Rx Watchdog Timeout\n");
-		}
-		if (status & DMA_STATUS_ETI){
-			ETHPRINTK (intr, INFO,"Early Tx Interrupt\n");
-			/*status |= DMA_STATUS_TI;*/
-		}
-		if (status & DMA_STATUS_FBI){
-			ETHPRINTK (intr, INFO,"Fatal Bus Error Interrupt\n");
-		}
-	}
-	ETHPRINTK (intr, INFO,"\n\n");
-
-	/* Clear the interrupt by writing a logic 1 to the relative bits */
-	writel(status, dev->base_addr+DMA_STATUS);
-	return;
-}
-
-/* ----------------------------------------------------------------------------
-			      DEVICE METHODS
-   ---------------------------------------------------------------------------*/
-int stb7109eth_open(struct net_device *dev)
-{
-	struct  eth_driver_local *lp = netdev_priv(dev);
-	int ret;
-
-       /* Request the IRQ lines */
-        if ( (ret = request_irq(dev->irq, &stb7109eth_interrupt,
-				SA_SHIRQ, dev->name, dev)) < 0 ) {
-		printk(KERN_ERR "%s: ERROR: allocating the IRQ %d "
-				"(return error: %d)\n", __FUNCTION__,
-							dev->irq, ret);
-                return (ret);
-	}
-
-	/* Check that the MAC address is valid.  If its not, refuse
-         * to bring the device up. The user must specify an
-         * address using the following linux command:
-	 * 	ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
-        if (!is_valid_ether_addr(dev->dev_addr)) {
-                ETHPRINTK(probe, ERR, "%s: no valid eth hw addr\n",
-					__FUNCTION__);
-                return (-EINVAL);
-        }
-
-	/* Copy the MAC addr into the HW */
-	set_synopsys_mac_addr(dev->base_addr, dev->dev_addr);
-
-	/* Initialize the MAC110 Core */
-	synopsys_mac_core_init(dev);
-
-	/* Enable the MAC/DMA */
-	if (!lp->mac_enable)
-		synopsys_mac_enable(dev);
-
-	if (netif_msg_hw(lp))
-		dump_synopsys_mac_csr((unsigned int)dev->base_addr);
-
-	ETHPRINTK(probe, DEBUG, "%s: DMA RX/TX processes started...\n",
-				RESOURCE_NAME);
-
-	synopsys_dma_start_rx(dev->base_addr);
-	synopsys_dma_start_tx(dev->base_addr);
-
-	netif_start_queue(dev);
-	return (0);
-}
-
-int stb7109eth_release(struct net_device *dev)
-{
-	struct  eth_driver_local *lp = netdev_priv(dev);
-
-	printk (KERN_DEBUG "%s\n", __FUNCTION__);
-
-	/* Free the IRQ lines */
-	free_irq(dev->irq, dev);
-
-	/* Reset the TX/RX processes */
-	synopsys_dma_stop_rx(dev->base_addr);
-	stb7109eth_stop_tx(dev);
-
-	/* Disable the MAC core */
-	if (lp->mac_enable)
-		synopsys_mac_disable(dev);
-
-	/* Change the link status */
-        netif_carrier_off(dev);
-
-	return (0);
-}
-
-int stb7109eth_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-	/* Point at the first free tx descriptor */
-	synopsys_dma_des *p = lp->cur_tx;
-
-	if (skb->len< ETH_ZLEN) {
-		skb = skb_padto(skb, ETH_ZLEN);
-		skb->len = ETH_ZLEN;
-        }
-
-	/* Handle the DMA TX descriptors */
-	p->des1 =((TDES1_CONTROL_IC | TDES1_CONTROL_FS | TDES1_CONTROL_LS) |
-	  	 ((p->des1 & DES1_CONTROL_TER) ? DES1_CONTROL_TER : 0)|
-		 ((skb->len<<DES1_RBS1_SIZE_SHIFT) & DES1_RBS1_SIZE_MASK));
-	p->des0 = OWN_BIT;
-	p->des2 = (synopsys_dma_des *) dma_map_single(NULL,
-			skb->data, skb->len, DMA_TO_DEVICE);
-/*
-	if (lp->tx_skb[lp->skb_curtx] != NULL)
-	        dev_kfree_skb(lp->tx_skb[lp->skb_curtx]);
-*/
-	/* Save the skb pointer so we can free it later */
-	lp->tx_skb[lp->skb_curtx] = skb;
-
-	/* Update the current skb position */
-	lp->skb_curtx = (lp->skb_curtx + 1) % CONFIG_DMA_TX_SIZE;
-
-	if (p->des1 & DES1_CONTROL_TER)
-		p = lp->dma_tx;
-	else
-		p++;
-	/* We need to tell the kernel to stop the transmission. */
-	if (p == lp->dirty_tx) {
-                netif_stop_queue(dev);
-                lp->stats.tx_fifo_errors++;
-        }
-
-#ifdef CONFIG_7109ETH_DEBUG
-        if (netif_msg_pktdata(lp)) {
-                printk("%s: tx desc used=0x%x; skb used #%d\n", __FUNCTION__,
-                        (unsigned int)lp->cur_tx, lp->skb_curtx);
-                print_pkt(skb->data ,skb->len);
-                printk ("TX descriptor ring:\n");
-                display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
-        }
-#endif
-
-	/* Update the current tx pointer to the next one */
-	lp->cur_tx = p;
-
-	/* Update transmit stats */
-        lp->stats.tx_bytes += skb->len;
-
-	dev->trans_start = jiffies;
-
-	/* CSR1 enables the transmit DMA to check for new descriptor */
-	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
-
-	return (0);
-}
-
-/* If the NAPI support is enable the stb7109eth_poll method will be
- * scheduled at interrupt time.
- * Otherwise, the stb7109eth_rx(...) is the receive function processed
- * by the regular interrupt handle.  */
-#ifdef CONFIG_7109ETH_NAPI
-static int stb7109eth_poll(struct net_device *dev, int *budget)
-#else
-static int  stb7109eth_rx (struct net_device *dev)
-#endif
-{
-	struct sk_buff *skb;
-	int j=0, frame_len = 0, pos;
-	struct eth_driver_local *lp = netdev_priv(dev);
-	synopsys_dma_des *drx;
-#ifdef CONFIG_7109ETH_NAPI
-	int npackets = 0, quota = min(dev->quota, *budget);
-#else
-	/* we can do that here! */
-	get_rx_last_frame_pos(lp);
-#endif
-	pos = (lp->rx_pos < 0) ? (CONFIG_DMA_RX_SIZE-1) : lp->rx_pos;
-
-        while (j<CONFIG_DMA_RX_SIZE) {
-                int prec=((pos!=0)?(pos-1):(CONFIG_DMA_RX_SIZE-1));
-                if ((lp->dma_rx+prec)->des0 & OWN_BIT)
-                        break;
-                pos = prec;
-                j++;
-        }
-
-	drx = lp->dma_rx + pos;
-
-	ETHPRINTK (rx_status,DEBUG ,"%s: [dma current pos = %d, drx = 0x%x, "
-		  		    "pos=%d]\n", __FUNCTION__, lp->rx_pos,
-				    (unsigned int)drx, pos);
-
-	while (!(drx->des0 & OWN_BIT)) {
-		unsigned int status = drx->des0;
-#ifdef CONFIG_7109ETH_DEBUG
-		if (netif_msg_rx_status(lp)) {
-			printk ("RX descriptor ring:\n");
-			display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
-		}
-#endif
-#ifdef CONFIG_7109ETH_NAPI
-		if (npackets >= quota){
-			ETHPRINTK(rx_status,ERR,"%s: ERROR: out of Quota\n" ,
-				   __FUNCTION__);
-			break;
-		}
-#endif
-		/* Check if the frame was not successfully received */
-		if (check_rx_error_summary(lp, status) < 0) {
-			drx->des0=OWN_BIT;
-			continue;
-		}
-
-		/* update multicast stats */
-		if (status & RDES0_STATUS_MULTICST_FRM)
-			lp->stats.multicast++;
-
-		/* FL (frame length) indicates the length in byte including
-		 * the CRC */
-		frame_len=(status&RDES0_STATUS_FL_MASK)>>RDES0_STATUS_FL_SHIFT;
-
-		/* Allocate the socket buffer */
-		skb = dev_alloc_skb(frame_len + 2);
-		if (!skb) {
-			if (printk_ratelimit())
-				printk(KERN_NOTICE "%s: low memory, packet "
-					"dropped.\n", dev->name);
-			lp->stats.rx_dropped++;
-			drx->des0=OWN_BIT;
-			continue;
-		}
-
-		/* Align IP on 16 byte boundaries */
-		skb_reserve(skb, 2);
-
-		eth_copy_and_sum(skb, lp->rx_mem+(pos*DMA_BUFFER_SIZE),
-				 frame_len, 0);
-
-		/* release the descriptor */
-		drx->des0=OWN_BIT;
-
-		if (drx->des1 & DES1_CONTROL_TER)
-			pos = 0;
-		else
-			pos++;
-		drx = lp->dma_rx + pos;
-
-#ifdef CONFIG_7109ETH_DEBUG
-		if (netif_msg_pktdata(lp)){
-			printk ("%s: frame received ", __FUNCTION__);
-			print_pkt(skb->data, frame_len);
-		}
-#endif
-		/* write metadata, and pass to the receive level */
-		skb->dev = dev;
-		skb_put(skb, frame_len);
-		skb->protocol = eth_type_trans(skb, dev);
-		skb->ip_summed = CHECKSUM_NONE;
-		lp->stats.rx_packets++;
-		lp->stats.rx_bytes += frame_len;
-		dev->last_rx = jiffies;
-#ifdef CONFIG_7109ETH_NAPI
-		npackets++;
-		netif_receive_skb(skb);
-#else
-		netif_rx(skb);
-#endif
-	}
-#ifdef CONFIG_7109ETH_NAPI
-	 /* All the packets in the DMA have been processed so we can
-	  * reenable the RX interrupt. */
-	*budget -= npackets;
-        dev->quota -= npackets;
-        netif_rx_complete(dev);
-	synopsys_dma_start_rx(dev->base_addr);
-#else
-	writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
-#endif
-        return 0;
-}
-
-/* This function is called when a packet transmission fails to complete
- * within a reasonable period. The driver will mark the error in the
- * netdev structure and arrange for the device to be reset to a sane state
- * in order to transmit a new packet. */
-void stb7109eth_tx_timeout (struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	ETHPRINTK(timer, INFO, "%s: Tx timeout at %ld, latency %ld\n",
-		dev->name, jiffies, jiffies - dev->trans_start);
-
-        if (netif_msg_tx_queued(lp)) {
-		printk (KERN_INFO "%s: DMA TX (cur_tx = 0x%x):\n",
-				  __FUNCTION__, (unsigned int)lp->cur_tx);
-		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
-	}
-
-	netif_stop_queue(dev);
-	stb7109eth_stop_tx(dev);
-	init_dma_ring(lp->dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
-	synopsys_dma_start_tx(dev->base_addr);
-	lp->stats.tx_errors++;
-	netif_start_queue(dev);
-	dev->trans_start = jiffies;
-
-	return;
-}
-
-/* Return statistics to the caller application */
-struct net_device_stats *stb7109eth_stats(struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-	return &lp->stats;
-}
-
-/* Configuration changes (passed on by ifconfig) */
-int stb7109eth_config(struct net_device *dev, struct ifmap *map)
-{
-	if (dev->flags & IFF_UP) /* can't act on a running interface */
-                return -EBUSY;
-
-        /* Don't allow changing the I/O address */
-        if (map->base_addr != dev->base_addr) {
-                printk(KERN_WARNING "%s: can't change I/O address\n",dev->name);
-                return -EOPNOTSUPP;
-        }
-
-        /* Don't allow changing the IRQ */
-        if (map->irq != dev->irq) {
-                printk(KERN_WARNING "%s: can't change IRQ number %d\n",
-					 dev->name, dev->irq);
-                return -EOPNOTSUPP;
-        }
-
-        /* ignore other fields */
-        return (0);
-}
-
-/* ---------------------------------------------------------------------------
-			Address Filtering Method
-   ---------------------------------------------------------------------------*/
-static void stb7109eth_set_rx_mode(struct net_device *dev)
-{
-	unsigned long ioaddr=dev->base_addr;
-	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-	u32 mc_filter[2]; /* Multicast hash filter */
-
-	printk(KERN_DEBUG "%s: mc_list=0x%x, mc_count=0x%x\n", __FUNCTION__,
-			      (unsigned int)dev->mc_list, dev->mc_count);
-
-	if (dev->flags & IFF_PROMISC) {
-		printk(KERN_DEBUG"%s: promiscuous mode enabled.\n",dev->name);
-		/* Promiscuous mode: set th PR bit in order to indicate
-		 * that all incoming frame are valid regardless of the
-		 * destination address.  */
-		value |= MAC_CONTROL_PR;
-		value &= ~(MAC_CONTROL_IF|MAC_CONTROL_HO);
-	} else if (dev->flags & IFF_ALLMULTI) {
-		printk(KERN_DEBUG "%s: pass all multicast mode enabled.\n",
-				  dev->name);
-		value |= MAC_CONTROL_PM;
-		value &= ~(MAC_CONTROL_PR|MAC_CONTROL_IF|MAC_CONTROL_HO);
-	} else {
-		if (dev->mc_count == 0) {
-			printk(KERN_DEBUG "%s: perfect filtering mode.\n",
-					  dev->name);
-			value &= ~(MAC_CONTROL_PM|MAC_CONTROL_PR|MAC_CONTROL_IF|
-				   MAC_CONTROL_HO|MAC_CONTROL_HP);
-			writel(0x0, ioaddr+MAC_HASH_HIGH);
-			writel(0x0, ioaddr+MAC_HASH_LOW);
-		} else {
-			/* MAC Addr Perfect Filtering for physical addresses
-			 * and Hash Filtering for Multicast addresses;
-		         * Pass Multicast frames if enabled. */
-			int i;
-			printk(KERN_DEBUG "%s: set Hash table for multicast "
-					  "addresses\n", dev->name);
-			mc_filter[1] = mc_filter[0] = 0;
-			for (i = 0, lp->dmi = dev->mc_list;
-			     lp->dmi && i < dev->mc_count;
-			     i++, lp->dmi = lp->dmi->next) {
-				int bit_nr = ether_crc(ETH_ALEN,
-						lp->dmi->dmi_addr) >> 26;
-				mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
-			}
-			writel(mc_filter[0], ioaddr+MAC_HASH_HIGH);
-			writel(mc_filter[1], ioaddr+MAC_HASH_LOW);
-
-			value |= MAC_CONTROL_HP;
-			value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |
-				   MAC_CONTROL_IF| MAC_CONTROL_HO);
-		}
-	}
-
-	writel(value, ioaddr+MAC_CONTROL);
-
-	if (netif_msg_hw(lp))
-		dump_synopsys_mac_csr((unsigned int)dev->base_addr);
-	return;
-}
-
-/* The Maximum Transfer Unit (MTU) is used by the network layer to
- * drive packet transmission. Ethernet has an MTU of 1500 octets (ETH_DATA_LEN).
- * This value can be changed with ifconfig.  */
-static int stb7109eth_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if (netif_running(dev)) {
-                printk (KERN_ERR "%s: must be stopped to change its MTU\n",
-				 dev->name);
-                return -EBUSY;
-        }
-
-	if (new_mtu > ETH_DATA_LEN)
-                return -EINVAL;
-        dev->mtu = new_mtu;
-
-        return (0);
-}
-
-/* ---------------------------------------------------------------------------
-			REGULAR INTERRUPT FUNCTION
-   ---------------------------------------------------------------------------*/
-static irqreturn_t stb7109eth_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs)
-{
-	struct eth_driver_local *lp;
-	struct net_device *dev = (struct net_device *)dev_id;
-
-	if (!dev) {
-		printk (KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
-		return IRQ_NONE;
-	}
-        lp = netdev_priv(dev);
-
-	synopsys_dma_interrupt(dev);
-
-	return IRQ_HANDLED;
-}
-
-/* ---------------------------------------------------------------------------
-	          		NETPOLL SUPPORT
-   ---------------------------------------------------------------------------*/
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/* Polling receive - used by NETCONSOLE and other diagnostic tools
- * to allow network I/O with interrupts disabled. */
-static void stb7109eth_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-        stb7109eth_interrupt(dev->irq, dev, NULL);
-	enable_irq(dev->irq);
-}
-#endif
-
-/* ----------------------------------------------------------------------------
-	          		ETHTOOL SUPPORT
-   ---------------------------------------------------------------------------*/
-static void stb7109eth_ethtool_getdrvinfo(struct net_device *dev,
-				   struct ethtool_drvinfo*info)
-{
-        strcpy(info->driver, RESOURCE_NAME);
-        strncpy(info->version, version, sizeof(version));
-	strcpy(info->bus_info, "STBUS");
-	info->fw_version[0] = '\0';
-	return;
-}
-
-/* Restart autonegotiation */
-static int stb7109eth_ethtool_nwayreset(struct net_device *dev)
-{
-        int ret = -EINVAL;
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	spin_lock(&lp->lock);
-	ret = mii_nway_restart(&lp->mii);
-	spin_unlock(&lp->lock);
-        return ret;
-}
-
-static int stb7109eth_ethtool_getsettings(struct net_device *dev,
-					  struct ethtool_cmd *cmd)
-{
-        struct eth_driver_local *lp = netdev_priv(dev);
-
-	if (!netif_running(dev)) {
-                printk(KERN_ERR "%s: interface is disabled: we cannot track "
-				   "link speed / duplex setting\n", dev->name);
-        	return -EBUSY;
-        }
-
-	cmd->port = PORT_MII;
-
-	cmd->supported = (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
-		SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
-		SUPPORTED_Autoneg | SUPPORTED_MII);
-
-	if (lp->speed == SPEED_10)
-		cmd->speed = SPEED_10;
-	else if (lp->speed == SPEED_100)
-		cmd->speed = SPEED_100;
-
-	if (!lp->mii.force_media)
-		cmd->autoneg = AUTONEG_DISABLE;
-	else
-		cmd->autoneg = AUTONEG_ENABLE;
-
-	cmd->advertising = lp->mii.advertising;
-
-	cmd->transceiver = XCVR_INTERNAL;
-	cmd->duplex = lp->mii.full_duplex ? DUPLEX_FULL : DUPLEX_HALF;
-	cmd->phy_address = lp->mii.phy_id;
-
-        return (0);
-}
-
-static int stb7109eth_ethtool_setsettings(struct net_device *dev,
-					  struct ethtool_cmd *cmd)
-{
-        struct eth_driver_local *lp = dev->priv;
-
-	return (mii_ethtool_sset(&lp->mii, cmd));
-}
-
-static u32 stb7109eth_ethtool_getmsglevel(struct net_device *dev)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-        return lp->msg_enable;
-}
-
-static void stb7109eth_ethtool_setmsglevel(struct net_device *dev, u32 level)
-{
-	struct eth_driver_local *lp = netdev_priv(dev);
-        lp->msg_enable = level;
-
-}
-
-static int stb7109eth_check_if_running(struct net_device *dev)
-{
-        if (!netif_running(dev))
-                return -EBUSY;
-        return (0);
-}
-
-#define REGDUMP_LEN         (32 * 1024)
-int stb7109eth_ethtool_get_regs_len(struct net_device *dev)
-{
-        return (REGDUMP_LEN);
-}
-
-static void stb7109eth_ethtool_gregs(struct net_device *dev,
-                               	     struct ethtool_regs *regs, void *space)
-{
-        int i;
-        u32 reg;
-        u32 *reg_space = (u32 *) space;
-
-	memset(reg_space, 0x0, REGDUMP_LEN);
-
-	/* MAC registers */
-        for (i = 0; i < 11; i++) {
-		reg = readl(dev->base_addr + i*4);
-                memcpy((reg_space + i*4), &reg, sizeof(u32));
-        }
-
-	/* DMA registers */
-	for (i = 0; i<9; i++) {
-		reg = readl(dev->base_addr+(DMA_BUS_MODE+i*4));
-		memcpy((reg_space + (DMA_BUS_MODE+i*4)), &reg,
-			sizeof(u32));
-	}
-	reg = readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR);
-	memcpy((reg_space + DMA_CUR_TX_BUF_ADDR), &reg, sizeof(u32));
-	reg = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
-	memcpy((reg_space + DMA_CUR_RX_BUF_ADDR), &reg, sizeof(u32));
-
-	return;
-}
-
-static struct ethtool_ops stb7109eth_ethtool_ops = {
-	.begin 		= stb7109eth_check_if_running,
-	.get_drvinfo    = stb7109eth_ethtool_getdrvinfo,
-	.nway_reset     = stb7109eth_ethtool_nwayreset,
-	.get_settings   = stb7109eth_ethtool_getsettings,
-	.set_settings   = stb7109eth_ethtool_setsettings,
-	.get_msglevel   = stb7109eth_ethtool_getmsglevel,
-	.set_msglevel   = stb7109eth_ethtool_setmsglevel,
-	.get_regs 	= stb7109eth_ethtool_gregs,
-	.get_regs_len 	= stb7109eth_ethtool_get_regs_len,
-	.get_link       = ethtool_op_get_link,
-};
-
-/* ----------------------------------------------------------------------------
-	            		VLAN SUPPORT
-   ---------------------------------------------------------------------------*/
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-static void stb7109eth_vlan_rx_register(struct net_device *dev,
-				    struct vlan_group *grp)
-{
-        struct eth_driver_local *lp = netdev_priv(dev);
-
-        spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: setting vlgrp to %p\n", dev->name, grp);
-        lp->vlgrp = grp;
-        stb7109eth_set_rx_mode(dev);
-        spin_unlock(&lp->lock);
-}
-
-static void stb7109eth_vlan_rx_add_vid(struct net_device *dev,
-				       unsigned short vid)
-{
-        struct eth_driver_local *lp = netdev_priv(dev);
-
-        spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: adding VLAN ID %d to VLAN filter\n",
-			  dev->name, vid);
-        stb7109eth_set_rx_mode(dev);
-        spin_unlock(&lp->lock);
-}
-static void stb7109eth_vlan_rx_kill_vid(struct net_device *dev,
-					unsigned short vid)
-{
-        struct eth_driver_local *lp = netdev_priv(dev);
-
-        spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: removing VLAN ID %d from VLAN filter\n",
-			  dev->name, vid);
-        if (lp->vlgrp)
-                lp->vlgrp->vlan_devices[vid] = NULL;
-        stb7109eth_set_rx_mode(dev);
-        spin_unlock(&lp->lock);
-}
-#endif
-
-/* ----------------------------------------------------------------------------
-	           DEVICE REGISTRATION, INITIALIZATION AND UNLOADING
-   ---------------------------------------------------------------------------*/
-static int stb7109eth_probe(struct net_device *dev, unsigned long ioaddr)
-{
-	int ret = 0;
-	struct eth_driver_local *lp = netdev_priv(dev);
-
-	ether_setup(dev);
-
-	dev->open = stb7109eth_open;
-	dev->stop = stb7109eth_release;
-	dev->set_config	= stb7109eth_config;
-	dev->hard_start_xmit = stb7109eth_hard_start_xmit;
-	dev->get_stats = stb7109eth_stats;
-	dev->tx_timeout	= stb7109eth_tx_timeout;
-	dev->watchdog_timeo = msecs_to_jiffies(watchdog);;
-	dev->set_multicast_list	= stb7109eth_set_rx_mode,
-	dev->change_mtu	= stb7109eth_change_mtu;
-        dev->ethtool_ops = &stb7109eth_ethtool_ops;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-        dev->poll_controller = stb7109eth_poll_controller;
-#endif
-#ifdef CONFIG_7109ETH_NAPI
-	dev->poll = stb7109eth_poll;
-	dev->weight = CONFIG_DMA_RX_SIZE;
-#endif
-
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-        dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
-        dev->vlan_rx_register = stb7109eth_vlan_rx_register;
-        dev->vlan_rx_add_vid  = stb7109eth_vlan_rx_add_vid;
-        dev->vlan_rx_kill_vid = stb7109eth_vlan_rx_kill_vid;
-#endif
-	/* network local structure default */
-        lp->mii.dev = dev;
-	lp->mii.force_media = 1;
-        lp->mii.full_duplex = 0;
-        lp->mii.mdio_read = stb7109_mii_read;
-        lp->mii.mdio_write = stb7109_mii_write;
-	lp->mii.advertising = 0;
-	lp->mac_enable = 0;
-	lp->msg_enable = netif_msg_init(debug, default_msg_level);
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	lp->ip_header_len = VLAN_ETH_HLEN;
-#else
-	lp->ip_header_len = ETH_HLEN;
-#endif
-	/* Check the module arguments */
-	stb7109eth_check_mod_params(dev);
-
-	/* Set the I/O base addr */
-        dev->base_addr = ioaddr;
-	printk(KERN_INFO "\tI/O base addr: 0x%lx\n", dev->base_addr);
-
-	if ((ret = register_netdev(dev))) {
-		printk(KERN_ERR "%s: ERROR %i registering the device\n",
-				__FUNCTION__, ret);
-		return (-ENODEV);
-	}
-
-	/* Create and initialize the TX/RX descriptors rings */
-	init_dma_desc_rings(dev);
-
-	/* Intialize the DMA controller and send the SW reset */
-	if (synopsys_dma_init(dev) < 0 ) {
-		ETHPRINTK(probe, ERR, "%s: DMA initialization failed\n",
-				__FUNCTION__);
-		return (-1);
-	}
-
-        spin_lock_init(&lp->lock);
-
-	return (ret);
-}
-
-static int stb7109eth_dvr_probe(struct device *dev)
-{
-	int ret = 0;
-        struct resource *res;
-	unsigned int *addr = NULL;
-	struct net_device *ndev = NULL;
-        struct platform_device *pdev = to_platform_device(dev);
-
-	printk(KERN_INFO "%s:\n\tplatform registration... ", __FUNCTION__);
-        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-        if (!res) {
-                ret = -ENODEV;
-		goto out;
-        }
-	printk(KERN_INFO "done!\n");
-
-        if (!request_mem_region(res->start, (res->end - res->start),
-				RESOURCE_NAME)) {
-		printk(KERN_ERR "%s: ERROR: memory allocation failed"
-				"cannot get the I/O addr 0x%x\n",
-				__FUNCTION__, (unsigned int)res->start);
-                ret = -EBUSY;
-		goto out;
-        }
-
-	printk(KERN_INFO "\tmapping the I/O space (start=0x%x, size=0x%x)\n",
-			 (unsigned int)res->start,
-			 (unsigned int)(res->end - res->start));
-	addr = ioremap(res->start, (res->end - res->start));
-        if (!addr) {
-		printk(KERN_ERR "%s: ERROR: memory mapping failed \n",
-					__FUNCTION__);
-                ret = -ENOMEM;
-		goto out;
-        }
-
-	printk(KERN_INFO "\tnetwork device initialization... ");
-	ndev = alloc_etherdev(sizeof(struct eth_driver_local));
-	if (!ndev ) {
-		printk(KERN_ERR "%s: ERROR: allocating the device\n",
-					__FUNCTION__);
-		ret = -ENOMEM;
-		goto out;
-	}
-	printk(KERN_INFO "done!\n");
-
-	/* Get the IRQ number */
-	if ((ndev->irq = platform_get_irq(pdev,0)) == 0){
-		printk(KERN_ERR "%s: ERROR: IRQ configuration "
-				"information not found\n",__FUNCTION__);
-		ret = -ENODEV;
-		goto out;
-	}
-	printk(KERN_INFO "\tMAC IRQ number: %d\n", ndev->irq);
-	dev_set_drvdata(dev, ndev);
-
-	/* Network Device Registration */
-	ret = stb7109eth_probe(ndev, (unsigned long)addr);
-out:
-	if (ret < 0) {
-		dev_set_drvdata(dev, NULL);
-		release_mem_region(res->start, (res->end - res->start));
-		if (addr != NULL)
-			iounmap(addr);
-	}
-	return (ret);
-}
-
-static int stb7109eth_dvr_remove(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct eth_driver_local *lp = netdev_priv(ndev);
-	struct resource *res;
-
-	/* Reset the TX/RX processes */
-	synopsys_dma_stop_rx(ndev->base_addr);
-	stb7109eth_stop_tx(ndev);
-
-	/* Disable the MAC core */
-	if (lp->mac_enable)
-		synopsys_mac_disable(ndev);
-
-	/* Change the link status */
-        netif_carrier_off(ndev);
-
-	/* Free the DMA descriptor rings */
-	free_dma_desc_resources(ndev);
-
-	dev_set_drvdata(dev, NULL);
-	unregister_netdev(ndev);
-
-	iounmap((void *)ndev->base_addr);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, (res->end - res->start));
-
-	free_netdev(ndev);
-
-	return (0);
-}
-
-static struct device_driver stb7109eth_driver = {
-        .name           = RESOURCE_NAME,
-        .bus            = &platform_bus_type,
-        .probe          = stb7109eth_dvr_probe,
-        .remove         = stb7109eth_dvr_remove,
-};
-
-static int __init stb7109eth_init_module(void)
-{
-        printk(KERN_DEBUG "%s: register the device driver\n", __FUNCTION__);
-        return driver_register(&stb7109eth_driver);
-}
-
-static void __exit stb7109eth_cleanup_module(void)
-{
-        printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
-        driver_unregister(&stb7109eth_driver);
-}
-
-module_init(stb7109eth_init_module);
-module_exit(stb7109eth_cleanup_module);
-
-MODULE_DESCRIPTION("stb7109 Ethernet driver");
-MODULE_AUTHOR("Giuseppe Cavallaro");
-MODULE_LICENSE("GPL");
-
-/* --------------------------------------------------------------------------
- * 		Parse the optional command line arguments
- * --------------------------------------------------------------------------*/
-static int __init stb7109eth_parse_options(char *str)
-{
-	if (!str || !*str)
-		goto errout;
-
-	debug = simple_strtoul(str, &str, 10);
-	if (*str != ',')
-		goto out;
-
-	str++;
-	watchdog = simple_strtoul(str, &str, 10);
-	if (*str != ',')
-		goto out;
-
-        str++;
-        pause_time = simple_strtoul(str, &str, 10);
-        if (*str != ',')
-                goto out;
-
-out:
-	printk(KERN_DEBUG "%s: debug=%d, watchdog=%d, pause_time = %d\n",
-			  __FUNCTION__, debug, watchdog, pause_time);
-        return (0);
-
-errout:
-	return -EINVAL;
-}
-__setup("stb7109eth=", stb7109eth_parse_options);
Index: linux/drivers/net/stb7109eth.h
===================================================================
--- linux.orig/drivers/net/stb7109eth.h
+++ /dev/null
@@ -1,219 +0,0 @@
-
-/*----------------------------------------------------------------------------
- *	 			MAC BLOCK defines
- *---------------------------------------------------------------------------*/
-/* MAC CSR offset */
-#define MAC_CONTROL               0x00000000  /* MAC Control */
-#define MAC_ADDR_HIGH             0x00000004  /* MAC Address High */
-#define MAC_ADDR_LOW              0x00000008  /* MAC Address Low */
-#define MAC_HASH_HIGH             0x0000000c  /* Multicast Hash Table High */
-#define MAC_HASH_LOW              0x00000010  /* Multicast Hash Table Low */
-#define MAC_MII_ADDR              0x00000014  /* MII Address */
-#define MAC_MII_DATA              0x00000018  /* MII Data */
-#define MAC_FLOW_CONTROL          0x0000001c  /* Flow Control */
-#define MAC_VLAN1                 0x00000020  /* VLAN1 Tag */
-#define MAC_VLAN2                 0x00000024  /* VLAN2 Tag */
-#define MAC_WAKEUP_FILTER         0x00000028  /* Wake-up Frame Filter */
-#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c  /* Wake-up Control And Status */
-
-/* MAC CTRL defines */
-#define MAC_CONTROL_RA            0x80000000  /* Receive All Mode */
-#define MAC_CONTROL_BLE           0x40000000  /* Endian Mode */
-#define MAC_CONTROL_HBD           0x10000000  /* Heartbeat Disable */
-#define MAC_CONTROL_PS            0x08000000  /* Port Select */
-#define MAC_CONTROL_DRO           0x00800000  /* Disable Receive Own */
-#define MAC_CONTROL_EXT_LOOPBACK  0x00400000  /* Reserved (ext loopback?) */
-#define MAC_CONTROL_OM            0x00200000  /* Loopback Operating Mode */
-#define MAC_CONTROL_F             0x00100000  /* Full Duplex Mode */
-#define MAC_CONTROL_PM            0x00080000  /* Pass All Multicast */
-#define MAC_CONTROL_PR            0x00040000  /* Promiscuous Mode */
-#define MAC_CONTROL_IF            0x00020000  /* Inverse Filtering */
-#define MAC_CONTROL_PB            0x00010000  /* Pass Bad Frames */
-#define MAC_CONTROL_HO            0x00008000  /* Hash Only Filtering Mode */
-#define MAC_CONTROL_HP            0x00002000  /* Hash/Perfect Filtering Mode */
-#define MAC_CONTROL_LCC           0x00001000  /* Late Collision Control */
-#define MAC_CONTROL_DBF           0x00000800  /* Disable Broadcast Frames */
-#define MAC_CONTROL_DRTY          0x00000400  /* Disable Retry */
-#define MAC_CONTROL_ASTP          0x00000100  /* Automatic Pad Stripping */
-#define MAC_CONTROL_BOLMT_10      0x00000000  /* Back Off Limit 10 */
-#define MAC_CONTROL_BOLMT_8       0x00000040  /* Back Off Limit 8 */
-#define MAC_CONTROL_BOLMT_4       0x00000080  /* Back Off Limit 4 */
-#define MAC_CONTROL_BOLMT_1       0x000000c0  /* Back Off Limit 1 */
-#define MAC_CONTROL_DC            0x00000020  /* Deferral Check */
-#define MAC_CONTROL_TE            0x00000008  /* Transmitter Enable */
-#define MAC_CONTROL_RE            0x00000004  /* Receiver Enable */
-
-/* MAC FLOW CTRL defines */
-#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000  /* Pause Time Mask */
-#define MAC_FLOW_CONTROL_PT_SHIFT 16
-#define MAC_FLOW_CONTROL_PCF      0x00000004  /* Pass Control Frames */
-#define MAC_FLOW_CONTROL_FCE      0x00000002  /* Flow Control Enable */
-#define MAC_FLOW_CONTROL_PAUSE    0x00000001  /* Flow Control Busy ... */
-
-/* MII ADDR  defines */
-#define MAC_MII_ADDR_WRITE        0x00000002  /* MII Write */
-#define MAC_MII_ADDR_BUSY         0x00000001  /* MII Busy */
-
-/* MAC Management Counters register */
-#define MMC_CONTROL               0x00000100  /* MMC Control */
-#define MMC_HIGH_INTR             0x00000104  /* MMC High Interrupt */
-#define MMC_LOW_INTR              0x00000108  /* MMC Low Interrupt */
-#define MMC_HIGH_INTR_MASK        0x0000010c  /* MMC High Interrupt Mask */
-#define MMC_LOW_INTR_MASK         0x00000110  /* MMC Low Interrupt Mask */
-
-#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8   /* Maximum Frame Size */
-#define MMC_CONTROL_MAX_FRM_SHIFT 3
-#define MMC_CONTROL_MAX_FRAME 	  0x7FF
-
-/*----------------------------------------------------------------------------
- * 				DMA BLOCK defines
- *---------------------------------------------------------------------------*/
-/* DMA CRS Control and Status Register Mapping */
-#define DMA_BUS_MODE              0x00001000  /* Bus Mode */
-#define DMA_XMT_POLL_DEMAND       0x00001004  /* Transmit Poll Demand */
-#define DMA_RCV_POLL_DEMAND       0x00001008  /* Received Poll Demand */
-#define DMA_RCV_BASE_ADDR         0x0000100c  /* Receive List Base */
-#define DMA_TX_BASE_ADDR          0x00001010  /* Transmit List Base */
-#define DMA_STATUS                0x00001014  /* Status Register */
-#define DMA_CONTROL               0x00001018  /* Control (Operational Mode) */
-#define DMA_INTR_ENA              0x0000101c  /* Interrupt Enable */
-#define DMA_MISSED_FRAME_CTR      0x00001020  /* Missed Frame Counter */
-#define DMA_CUR_TX_BUF_ADDR       0x00001050  /* Current Host Transmit Buffer */
-#define DMA_CUR_RX_BUF_ADDR       0x00001054  /* Current Host Receive Buffer */
-
-/*  DMA Bus Mode register defines */
-#define DMA_BUS_MODE_DBO          0x00100000  /* Descriptor Byte Ordering */
-#define DMA_BUS_MODE_PBL_MASK     0x00003f00  /* Programmable Burst Length */
-#define DMA_BUS_MODE_PBL_SHIFT    8
-#define DMA_BUS_MODE_BLE          0x00000080  /* Big Endian/Little Endian */
-#define DMA_BUS_MODE_DSL_MASK     0x0000007c  /* Descriptor Skip Length */
-#define DMA_BUS_MODE_DSL_SHIFT    2           /*       (in DWORDS)      */
-#define DMA_BUS_MODE_BAR_BUS      0x00000002  /* Bar-Bus Arbitration */
-#define DMA_BUS_MODE_SFT_RESET    0x00000001  /* Software Reset */
-#define DMA_BUS_MODE_DEFAULT      0x00000000
-
-/* DMA Status register defines */
-#define DMA_STATUS_EB_MASK        0x00380000  /* Error Bits Mask */
-#define DMA_STATUS_EB_TX_ABORT    0x00080000  /* Error Bits - TX Abort */
-#define DMA_STATUS_EB_RX_ABORT    0x00100000  /* Error Bits - RX Abort */
-#define DMA_STATUS_TS_MASK        0x00700000  /* Transmit Process State */
-#define DMA_STATUS_TS_SHIFT       20
-#define DMA_STATUS_RS_MASK        0x000e0000  /* Receive Process State */
-#define DMA_STATUS_RS_SHIFT       17
-#define DMA_STATUS_NIS            0x00010000  /* Normal Interrupt Summary */
-#define DMA_STATUS_AIS            0x00008000  /* Abnormal Interrupt Summary */
-#define DMA_STATUS_ERI            0x00004000  /* Early Receive Interrupt */
-#define DMA_STATUS_FBI            0x00002000  /* Fatal Bus Error Interrupt */
-#define DMA_STATUS_ETI            0x00000400  /* Early Transmit Interrupt */
-#define DMA_STATUS_RWT            0x00000200  /* Receive Watchdog Timeout */
-#define DMA_STATUS_RPS            0x00000100  /* Receive Process Stopped */
-#define DMA_STATUS_RU             0x00000080  /* Receive Buffer Unavailable */
-#define DMA_STATUS_RI             0x00000040  /* Receive Interrupt */
-#define DMA_STATUS_UNF            0x00000020  /* Transmit Underflow */
-#define DMA_STATUS_OVF            0x00000010  /* Receive Overflow */
-#define DMA_STATUS_TJT            0x00000008  /* Transmit Jabber Timeout */
-#define DMA_STATUS_TU             0x00000004  /* Transmit Buffer Unavailable */
-#define DMA_STATUS_TPS            0x00000002  /* Transmit Process Stopped */
-#define DMA_STATUS_TI             0x00000001  /* Transmit Interrupt */
-
-/* DMA Control register defines */
-#define DMA_CONTROL_SF            0x00200000  /* Store And Forward */
-#define DMA_CONTROL_TTC_MASK      0x0001c000  /* Transmit Threshold Control */
-#define DMA_CONTROL_TTC_32        0x00000000  /* Threshold is 32 DWORDS */
-#define DMA_CONTROL_TTC_64        0x00004000  /* Threshold is 64 DWORDS */
-#define DMA_CONTROL_TTC_128       0x00008000  /* Threshold is 128 DWORDS */
-#define DMA_CONTROL_TTC_256       0x0000c000  /* Threshold is 256 DWORDS */
-#define DMA_CONTROL_TTC_18        0x00010000  /* Threshold is 18 DWORDS */
-#define DMA_CONTROL_TTC_24        0x00014000  /* Threshold is 24 DWORDS */
-#define DMA_CONTROL_TTC__32_      0x00018000  /* Threshold is 32 DWORDS */
-#define DMA_CONTROL_TTC_40        0x0001c000  /* Threshold is 40 DWORDS */
-#define DMA_CONTROL_ST            0x00002000  /* Start/Stop Transmission */
-#define DMA_CONTROL_SE            0x00000008  /* Stop On Empty */
-#define DMA_CONTROL_OSF           0x00000004  /* Operate On 2nd Frame */
-#define DMA_CONTROL_SR            0x00000002  /* Start/Stop Receive */
-
-/* DMA Interrupt Enable register defines */
-#define DMA_INTR_ENA_NIE          0x00010000  /* Normal Interrupt Summary */
-#define DMA_INTR_ENA_AIE          0x00008000  /* Abnormal Interrupt Summary */
-#define DMA_INTR_ENA_ERE          0x00004000  /* Early Receive */
-#define DMA_INTR_ENA_FBE          0x00002000  /* Fatal Bus Error */
-#define DMA_INTR_ENA_ETE          0x00000400  /* Early Transmit */
-#define DMA_INTR_ENA_RWE          0x00000200  /* Receive Watchdog */
-#define DMA_INTR_ENA_RSE          0x00000100  /* Receive Stopped */
-#define DMA_INTR_ENA_RUE          0x00000080  /* Receive Buffer Unavailable */
-#define DMA_INTR_ENA_RIE          0x00000040  /* Receive Interrupt */
-#define DMA_INTR_ENA_UNE          0x00000020  /* Underflow */
-#define DMA_INTR_ENA_OVE          0x00000010  /* Receive Overflow */
-#define DMA_INTR_ENA_TJE          0x00000008  /* Transmit Jabber */
-#define DMA_INTR_ENA_TUE          0x00000004  /* Transmit Buffer Unavailable */
-#define DMA_INTR_ENA_TSE          0x00000002  /* Transmit Stopped */
-#define DMA_INTR_ENA_TIE          0x00000001  /* Transmit Interrupt */
-/* DMA default interrupt mask */
-#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_AIE | \
-				DMA_INTR_ENA_FBE | DMA_INTR_ENA_RWE | \
-				DMA_INTR_ENA_RSE | DMA_INTR_ENA_RUE | \
-				DMA_INTR_ENA_RIE | DMA_INTR_ENA_UNE | \
-				DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
-				DMA_INTR_ENA_TUE | DMA_INTR_ENA_TSE | \
-				/*DMA_INTR_ENA_ERE | DMA_INTR_ENA_ETE | */ \
-				DMA_INTR_ENA_TIE)
-
-/* STMAC110 DMA Missed Frame Counter register defines */
-#define DMA_MISSED_FRAME_OVE      0x10000000  /* FIFO Overflow Overflow */
-#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000  /* Overflow Frame Counter */
-#define DMA_MISSED_FRAME_OVE_M    0x00010000  /* Missed Frame Overflow */
-#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff  /* Missed Frame Couinter */
-
-/*----------------------------------------------------------------------------
- * 		    	    Descriptor defines
- *---------------------------------------------------------------------------*/
-/* Common fields */
-#define OWN_BIT			0x80000000  /* Own Bit (owned by hardware) */
-#define DES1_CONTROL_CH		0x01000000  /* Second Address Chained */
-#define DES1_CONTROL_TER	0x02000000  /* End of Ring */
-#define DES1_RBS2_SIZE_MASK	0x003ff800  /* Buffer 2 Size Mask */
-#define DES1_RBS2_SIZE_SHIFT	11          /* Buffer 2 Size Shift */
-#define DES1_RBS1_SIZE_MASK	0x000007ff  /* Buffer 1 Size Mask */
-#define DES1_RBS1_SIZE_SHIFT	0           /* Buffer 1 Size Shift */
-
-/* Receive Descriptor */
-#define RDES0_STATUS_FILTER_FAIL  0x40000000  /* Filtering Fail */
-#define RDES0_STATUS_FL_MASK      0x3fff0000  /* Frame Length Mask */
-#define RDES0_STATUS_FL_SHIFT     16          /* Frame Length Shift */
-#define RDES0_STATUS_ES           0x00008000  /* Error Summary */
-#define RDES0_STATUS_DE           0x00004000  /* Descriptor Error */
-#define RDES0_STATUS_PFE          0x00002000  /* Partial Frame Error */
-#define RDES0_STATUS_LENGTH_ERROR 0x00001000  /* Length Error */
-#define RDES0_STATUS_RUNT_FRM     0x00000800  /* Runt Frame */
-#define RDES0_STATUS_MULTICST_FRM 0x00000400  /* Multicast Frame */
-#define RDES0_STATUS_FS           0x00000200  /* First Descriptor */
-#define RDES0_STATUS_LS           0x00000100  /* Last Descriptor */
-#define RDES0_STATUS_TL           0x00000080  /* Frame Too Long */
-#define RDES0_STATUS_COL_SEEN     0x00000040  /* Collision Seen */
-#define RDES0_STATUS_FRM_TYPE     0x00000020  /* Frame Type */
-#define RDES0_STATUS_RX_WATCHDOG  0x00000010  /* Receive Watchdog */
-#define RDES0_STATUS_MII_ERR      0x00000008  /* Report on MII Error */
-#define RDES0_STATUS_DRIBBLE      0x00000004  /* Dribbling Bit */
-#define RDES0_STATUS_CE           0x00000002  /* CRC Error */
-#define RDES0_STATUS_0            0x00000000  /* Always tied to zero */
-
-#define RDES1_CONTROL_DIOC        0x80000000  /* Disable Intr On Completion */
-
-/* Transmit Descriptor */
-#define TDES0_STATUS_ES		  0x00008000  /* Error Summary */
-#define TDES0_STATUS_LOSS_CARRIER 0x00000800  /* Loss of Carrier */
-#define TDES0_STATUS_NO_CARRIER   0x00000400  /* No Carrier */
-#define TDES0_STATUS_LATE_COL     0x00000200  /* Late Collision */
-#define TDES0_STATUS_EX_COL       0x00000100  /* Excessive Collisions */
-#define TDES0_STATUS_HRTBT_FAIL   0x00000080  /* Heartbeat Fail */
-#define TDES0_STATUS_COLCNT_MASK  0x00000078  /* Collision Count Mask */
-#define TDES0_STATUS_COLCNT_SHIFT 3           /* Collision Count Shift */
-#define TDES0_STATUS_EX_DEF       0x00000004  /* Excessive Deferrals */
-#define TDES0_STATUS_UF           0x00000002  /* Underflow Error */
-#define TDES0_STATUS_DF           0x00000001  /* Deferred */
-
-#define TDES1_CONTROL_IC          0x80000000  /* Interrupt on Completion */
-#define TDES1_CONTROL_LS          0x40000000  /* Last Segment */
-#define TDES1_CONTROL_FS          0x20000000  /* First Segment */
-#define TDES1_CONTROL_AC          0x04000000  /* Add CRC Disable */
-#define TDES1_CONTROL_DPD         0x00800000  /* Disable Padding */
Index: linux/drivers/net/stmmac.c
===================================================================
--- /dev/null
+++ linux/drivers/net/stmmac.c
@@ -0,0 +1,2351 @@
+/* ============================================================================
+ *  #####  ####### #     #
+ * #     #    #    ##   ##  This is a driver for the STM on-chip
+ * #          #    # # # #  Ethernet controller currently present on STb7109.
+ *  #####     #    #  #  #
+ *       #    #    #     #  Copyright (C) 2006 by STMicroelectronics
+ * #     #    #    #     #  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *  #####     #    #     #
+ * ----------------------------------------------------------------------------
+ * Driver internals:
+ *	The driver is initialized through the platform_device mechanism.
+ *	Structures which define the configuration needed by the board
+ *	are defined in a internal structure.
+ *
+ *	The STMMAC Ethernet Controller uses two ring of buffer
+ * 	descriptors for handling the transmission and the reception processes.
+ *
+ *	Receive process:
+ *  		When one or more packets are received, an interrupt happens.
+ *  		The interrupts are not queued so the driver must scan all the
+ *		descriptors in the ring before exiting to the interrupt handler.
+ *  		In NAPI, the interrupt handler will signal there is work to be
+ *		done, and exit. The poll method will be called at some future
+ *		point. Without NAPI, the packet(s) will be handled at once
+ *		(at interrupt time).
+ *  		The incoming packets are stored, by the DMA, in a list of
+ *  		pre-allocated socket buffers in order to avoid, for big packet,
+ *		the memcpy operation. The min_rx_pkt_size module parameter can
+ *		be used for tuning the size of the frame copied via memcpy.
+ *
+ *	Transmit process:
+ *		The xmit function is invoked when the kernel needs to transmit
+ *	        a packet.
+ *  		The transmit skb is copied in the socket buffer list.
+ *		Then the relative descriptor fields in the DMA tx ring is set.
+ *		Finally, the driver informs the DMA engine that there is
+ *		a packet ready to be transmitted.
+ *		Once the controller's finished transmitting the packet,
+ *		an interrupt is triggered. So the driver will be
+ *  		able to releases the socket buffers previously allocated.
+ *
+ *		Zero-Copy support and TSO:
+ *			When the driver sets the NETIF_F_SG bit in the features
+ *			field of the net_device structure it enables
+ *			the scatter/gather feature.
+ *			The kernel doesn't perform any scatter/gather I/O to
+ *			the driver if it doesn't provide some form of
+ *			checksumming as well. Unfortunately, our hardware
+ *			is not able to verify the csum.
+ *			The driver is able to verify the CS and handle the
+ *			scatter/gather by itself (zero-copy implementation).
+ *			NOTE: The scatter/gather can be enabled/disabled using:
+ *				ethtool -K <eth> sg on/off
+ *			The driver also supports the TSO technology.
+ *	 		TCP segmentation offload or TSO is a technology for
+ *			the acceleration of TCP/IP.
+ * 			The TSO frames are indicated to the driver by mss
+ *			being non-zero. Note that the tso_size is the size
+ *			the hardware should fragment the TCP data.
+ *			NOTE: the TSO can be enabled/disabled with:
+ *				ethtool -K ethX tso on/off
+ *
+ * ----------------------------------------------------------------------------
+ * Kernel Command line arguments:
+ *	stmmaceth=msglvl:<debug_msg_level>,phyaddr:<phy_address>,
+ *		  watchdog:<watchdog_value>,rxsize:<min_rx_pkt_size>
+ *	where:
+ *	  - <debug_msg_level>: message level (0: no output, 16:  all).
+ *	  - <phy_address>: physical Address number.
+ *	  - <watchdog>:  transmit timeout (in milliseconds).
+ *	  - <pause_time>: flow-control pause time (0-65535).
+ *	  - <min_rx_pkt_size>: copy only tiny-frames.
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   September 2006:
+ *	- Reviewed the transmit function.
+ *      - Added the TCP Segmentation Offload (TSO) support.
+ *      - Rewritten the command line parser function.
+ *   August 2006:
+ *   	- Converted to new platform_driver device
+ *   		Carl Shaw <carl.shaw@st.com>
+ *   July 2006:
+ *	- Reviewed the receive process (zero-copy).
+ *	- First implementation of the scatter/gather for the transmit function.
+ *	- Fixed the PBL field in the DMA CSR0 register in according to the
+ *	  SYSCFG7 register configuration.
+ *	- Downstream/Upstream checksum offloading.
+ *	- Added the Ethtool Rx/Tx csum, SG get/set support.
+ *   June 2006:
+ *	- Reviewed and improved the transmit algorithm.
+ *	- Added the NAPI support (as experimental code).
+ * 	- Added a new debug option. Now during the kernel configuration phase
+ * 	  you can enable the complete debug level for the driver
+ *	  (including the debug messages for the critical functions i.e. the
+ *	  interrupt handler).
+ *   May 2006:
+ * 	- Separated out the PHY code.
+ *   April 2006:
+ *	- Partially removed the STe101p MII interface code.
+ *	- The DMA Rx/Tx functions has been re-written.
+ *	- Removed the PnSEGADDR and PHYSADDR SH4 macros and added the
+ *	  Dynamic DMA mapping support.
+ *	- Removed the DMA buffer size parameter. It has been fixed to the
+ *	  maximum value. Moreover, the driver will only use a single buffer
+ *	  in the DMA because an ethernet frame can be stored in it.
+ *	- Fixed some part in the ethtool support.
+ *	- Added the 802.1q VLAN support.
+ *   March 2006:
+ * 	- First release of the driver.
+ * ----------------------------------------------------------------------------
+ * Known bugs and limits:
+ *	- The two-level VLAN tag is not supported yet.
+ *	- The NETPOLL support is not fully tested.
+ *	- Currently, the TSO support is not fully tested.
+ * ---
+ *	https://bugzilla.stlinux.com
+ * ===========================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/st_soc.h>
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+#include <linux/dma-mapping.h>
+
+#include "stmmac.h"
+
+/* Generic defines */
+#define RESOURCE_NAME	"stmmaceth"
+#ifdef CONFIG_STMMAC_DEBUG
+#define ETHPRINTK(nlevel, klevel, fmt, args...) \
+		(void)(netif_msg_##nlevel(lp) && \
+		printk(KERN_##klevel fmt, ## args))
+#else
+#define ETHPRINTK(nlevel, klevel, fmt, args...)  do { } while(0)
+#endif /*CONFIG_STMMAC_DEBUG */
+
+/* It only enables the debug information, in the transmit function,
+ * for the TSO support. */
+#undef STMMAC_TSO_DEBUG
+/*#define STMMAC_TSO_DEBUG 1*/
+#ifdef STMMAC_TSO_DEBUG
+#define TSOPRINTK(mss, klevel, fmt, args...) \
+		if (mss!=0)	\
+		printk(KERN_##klevel fmt, ## args)
+#else
+#define TSOPRINTK(mss, klevel, fmt, args...)  do { } while(0)
+#endif /* STMMAC_TSO_DEBUG */
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#define SYSCONF_BASE 		0xb9001000
+#define SYSCONF_DEVICEID        (SYSCONF_BASE + 0x000)
+#define SYSCONF_SYS_CFG(n)      (SYSCONF_BASE + 0x100 + ((n) * 4))
+#endif
+#define MAC_SPEED_SEL		0x00100000 /* MAC is running at 100 Mbps */
+
+#define DMA_BUFFER_SIZE	0x800
+#define TDES1_MAX_BUF1_SIZE ((0x7fff << DES1_RBS1_SIZE_SHIFT) & \
+				DES1_RBS1_SIZE_MASK);
+#define TDES1_MAX_BUF2_SIZE ((0x7fff << DES1_RBS2_SIZE_SHIFT) & \
+				DES1_RBS2_SIZE_MASK);
+
+#define TX_QUEUE_LEN  (CONFIG_DMA_TX_SIZE<4)?1:(CONFIG_DMA_TX_SIZE/2)
+#define MIN_MTU 46
+#define MAX_MTU 9000
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame. */
+struct dma_desc_t {
+	unsigned int des0; /* Status */
+	unsigned int des1; /* Ctrl bits, Buffer 2 length, Buffer 1 length */
+	unsigned int des2; /* Buffer 1 */
+	unsigned int des3; /* Buffer 2 */
+};
+
+typedef struct dma_desc_t dma_desc;
+
+struct eth_driver_local {
+	int bus_id;
+	int phy_addr;
+	int phy_irq;
+	int phy_ignorezero;
+	int oldlink;
+	int speed;
+	int oldduplex;
+	struct phy_device *phydev;
+	int pbl;
+	unsigned int ip_header_len;
+	struct mii_bus *mii;
+	struct dev_mc_list *dmi;
+	struct net_device_stats stats;
+	u32 msg_enable;
+	spinlock_t lock;
+
+	dma_desc *dma_tx; /* virtual DMA TX addr */
+	dma_addr_t dma_tx_phy;	   /* bus DMA TX addr */
+	unsigned int cur_tx, dirty_tx; /* Producer/consumer ring indices */
+	struct sk_buff *tx_skbuff[CONFIG_DMA_TX_SIZE];
+
+  	dma_desc *dma_rx; 	  /* virtual DMA RX addr */
+	dma_addr_t dma_rx_phy;	  /* bus DMA RX addr */
+	unsigned int rx_buf_sz;   /* Based on MTU+slack. */
+	unsigned int rx_buff; 	  /* it contains the last rx buf owned by
+				     the DMA */
+	int rx_csum;
+	unsigned int cur_rx, dirty_rx;  /* Producer/consumer ring indices */
+	/* The addresses of receive-in-place skbuffs. */
+	struct sk_buff *rx_skbuff[CONFIG_DMA_RX_SIZE];
+	dma_addr_t rx_skbuff_dma[CONFIG_DMA_RX_SIZE];
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	struct vlan_group *vlgrp;
+#endif
+	struct device *device;
+	struct tasklet_struct tx_task;
+};
+
+/* Module Arguments */
+#define TX_TIMEO (4*HZ)
+static int watchdog = TX_TIMEO;
+module_param(watchdog, int, S_IRUGO|S_IWUGO);
+MODULE_PARM_DESC(watchdog, "Transmit Timeout (in milliseconds)");
+
+static int debug = -1; /* -1: default, 0: no output, 16:  all */
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
+
+#define MAX_PAUSE_TIME (MAC_FLOW_CONTROL_PT_MASK>>MAC_FLOW_CONTROL_PT_SHIFT)
+static int pause_time = MAX_PAUSE_TIME;
+module_param(pause_time, int, S_IRUGO);
+MODULE_PARM_DESC(pause_time, "Pause Time");
+
+static int min_rx_pkt_size = 512;
+module_param(min_rx_pkt_size, int, S_IRUGO|S_IWUGO);
+MODULE_PARM_DESC(min_rx_pkt_size, "Copy only tiny-frames");
+
+static int phy_n = -1;
+module_param(phy_n, int, S_IRUGO);
+MODULE_PARM_DESC(phy_n, "Physical device address");
+
+static const char version[] = "stmmaceth - (C) STM 2006\n";
+
+static const u32 default_msg_level = (NETIF_MSG_DRV |NETIF_MSG_PROBE|
+				      NETIF_MSG_LINK |NETIF_MSG_IFUP|
+				      NETIF_MSG_IFDOWN|NETIF_MSG_TIMER);
+
+static irqreturn_t stmmaceth_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs);
+#ifndef CONFIG_STMMAC_NAPI
+static int stmmaceth_rx (struct net_device *dev);
+#else
+static int stmmaceth_poll(struct net_device *dev, int *budget);
+#endif
+
+static void stmmaceth_check_mod_params(struct net_device *dev)
+{
+	if (watchdog < 0) {
+		watchdog = TX_TIMEO;
+		printk (KERN_WARNING "\tWARNING: invalid tx timeout "
+				     "(default is %d)\n", watchdog);
+	}
+
+	if ((pause_time <= 0) || (pause_time >= MAX_PAUSE_TIME))
+		pause_time = MAX_PAUSE_TIME;
+
+	return;
+}
+
+static inline void print_mac_addr(u8 addr[6])
+{
+	int i;
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", addr[i]);
+	printk("%2.2x\n", addr[5]);
+	return;
+}
+
+#ifdef CONFIG_STMMAC_DEBUG
+static void print_pkt(unsigned char *buf, int len)
+{
+	int j;
+	printk("len = %d byte, buf addr: 0x%p", len, buf);
+	for (j=0; j<len; j++) {
+		if ((j%16) == 0)
+			printk("\n %03x:", j);
+		printk(" %02x", buf[j]);
+	}
+	printk("\n");
+	return;
+}
+#endif
+
+void fix_mac_speed(unsigned int speed)
+{
+#ifdef CONFIG_PHY_RMII
+	unsigned long sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+
+	if (speed == SPEED_100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == SPEED_10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	printk (KERN_DEBUG  "fix_mac_speed: speed = %d, sysconf7 = 0x%x\n",
+				           speed, (unsigned int) sysconf);
+
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+#endif
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+				PHY Support
+   ---------------------------------------------------------------------------*/
+static void stmmac_adjust_link(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phydev = lp->phydev;
+	unsigned long ioaddr=dev->base_addr;
+	unsigned long flags;
+	int new_state = 0;
+
+	ETHPRINTK(probe, DEBUG, "stmmac_adjust_link: called.  address %d link %d\n",
+			  phydev->addr, phydev->link);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	if (phydev->link) {
+		unsigned int flow=(unsigned int) readl(ioaddr+MAC_FLOW_CONTROL);
+		unsigned int ctrl=(unsigned int) readl(ioaddr+MAC_CONTROL);
+
+		/* Now we make sure that we can be in full duplex mode.
+		 * If not, we operate in half-duplex mode. */
+		if (phydev->duplex != lp->oldduplex) {
+			new_state = 1;
+			if (!(phydev->duplex)){
+				flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
+			  		MAC_FLOW_CONTROL_PCF);
+				ctrl &= ~MAC_CONTROL_F;
+				ctrl |= MAC_CONTROL_DRO;
+			} else {
+				flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
+					(pause_time << MAC_FLOW_CONTROL_PT_SHIFT);
+				ctrl |= MAC_CONTROL_F;
+				ctrl &= ~MAC_CONTROL_DRO;
+			}
+
+			lp->oldduplex = phydev->duplex;
+		}
+
+		if (phydev->speed != lp->speed) {
+			new_state = 1;
+			switch (phydev->speed) {
+			case 100:
+			case 10:
+				fix_mac_speed(phydev->speed);
+			        break;
+			default:
+			        if (netif_msg_link(lp))
+			                printk(KERN_WARNING
+			                       "%s: Ack!  Speed (%d) is not 10 or 100!\n",
+			                        dev->name, phydev->speed);
+			        break;
+			}
+
+			lp->speed = phydev->speed;
+	       }
+
+		writel(flow, ioaddr+MAC_FLOW_CONTROL);
+		writel(ctrl, ioaddr+MAC_CONTROL);
+
+	       if (!lp->oldlink) {
+			new_state = 1;
+			lp->oldlink = 1;
+			netif_schedule(dev);
+		}
+	} else if (lp->oldlink) {
+		new_state = 1;
+		lp->oldlink = 0;
+		lp->speed = 0;
+		lp->oldduplex = -1;
+	}
+
+	if (new_state && netif_msg_link(lp))
+		phy_print_status(phydev);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	ETHPRINTK(probe, DEBUG,"stmmac_adjust_link: exiting\n");
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int stmmac_init_phy(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phydev;
+	char phy_id[BUS_ID_SIZE];
+
+	lp->oldlink = 0;
+	lp->speed = 0;
+	lp->oldduplex = -1;
+
+	snprintf(phy_id, BUS_ID_SIZE, PHY_ID_FMT, lp->bus_id, lp->phy_addr);
+	ETHPRINTK(probe, DEBUG,"stmmac_init_phy:  trying to attach to %s\n", phy_id);
+
+	phydev = phy_connect(dev, phy_id, &stmmac_adjust_link, 0);
+
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);
+		return PTR_ERR(phydev);
+	}
+
+	ETHPRINTK(probe, DEBUG, "stmmac_init_phy:  %s: attached to PHY. Link = %d\n",
+		 dev->name, phydev->link);
+
+	lp->phydev = phydev;
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------------
+				MDIO Bus Support
+   ---------------------------------------------------------------------------*/
+
+/*  Read data from the MII register from within the specified phy device,
+ *  arguments:
+ *	phyaddr: MII addr reg bits 15-11
+ *	phyreg: MII addr reg bits 10-6
+ */
+int stmmac_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)
+{
+	unsigned long ioaddr=(unsigned long)bus->priv;
+	int data;
+	u16 regValue=(((phyaddr << 11)&(0x0000F800))|
+		      ((phyreg<<6)&(0x000007C0)));
+
+	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	writel(regValue, ioaddr+MAC_MII_ADDR);
+
+	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* Read the data from the MII data register */
+	data = (int)readl(ioaddr+MAC_MII_DATA);
+/*	printk(KERN_DEBUG "stmmac_mdio_read : phyaddr = %d  phyreg = %d data = %08x\n",
+			phyaddr, phyreg, data); */
+	return data;
+}
+
+/* Writes the data intto the MII register from within the specified device */
+int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg,
+		       u16 phydata)
+{
+	unsigned long ioaddr=(unsigned long)bus->priv;
+	u16 value=(((phyaddr<<11)&(0x0000F800))|((phyreg<<6)&(0x000007C0)))|
+			MAC_MII_ADDR_WRITE;
+
+/*	printk(KERN_DEBUG "stmmac_mdio_write : phyaddr = %d  phyreg = %d data = %04x\n",
+			phyaddr, phyreg, phydata); */
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* Set the MII address register to write */
+	writel(phydata, ioaddr+MAC_MII_DATA);
+	writel(value, ioaddr+MAC_MII_ADDR);
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* NOTE: we need to perform this "extra" read in order to fix an error
+	 * during the write operation */
+	stmmac_mdio_read (bus, phyaddr, phyreg);
+	return 0;
+}
+
+/* Resets the MII bus */
+int stmmac_mdio_reset(struct mii_bus *bus)
+{
+	return 0;
+}
+
+/* Register the MII bus */
+int stmmac_mdio_register(struct eth_driver_local *lp, struct net_device *ndev,
+			  unsigned long ioaddr)
+{
+	int err = 0;
+	struct mii_bus *new_bus = kzalloc(sizeof(struct mii_bus), GFP_KERNEL);
+	int *irqlist = kzalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
+
+        if (new_bus == NULL)
+                return -ENOMEM;
+
+	/* Assign IRQ to phy at address phy_addr */
+	irqlist[lp->phy_addr] = lp->phy_irq;
+
+        new_bus->name = "STMMAC MII Bus",
+        new_bus->read = &stmmac_mdio_read,
+        new_bus->write = &stmmac_mdio_write,
+        new_bus->reset = &stmmac_mdio_reset,
+        new_bus->id = (int)lp->bus_id;
+	new_bus->priv = (void *)ioaddr;
+	new_bus->irq = irqlist;
+
+	err = mdiobus_register(new_bus, lp->phy_ignorezero);
+
+        if (err != 0) {
+                printk (KERN_ERR "%s: Cannot register as MDIO bus\n",
+                                new_bus->name);
+                goto bus_register_fail;
+        }
+
+	lp->mii = new_bus;
+        return 0;
+
+bus_register_fail:
+        kfree(new_bus);
+        return err;
+}
+
+int stmmac_mdio_unregister(struct eth_driver_local *lp)
+{
+	mdiobus_unregister(lp->mii);
+	lp->mii->priv = NULL;
+        kfree(lp->mii);
+
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------------------
+				 MAC CORE Interface
+   ---------------------------------------------------------------------------*/
+/* Print the MAC CSR registers */
+static inline void dump_stm_mac_csr(unsigned long ioaddr)
+{
+	printk ("\t----------------------------------------------\n"
+		"\t  MAC CSR (base addr = 0x%8x)\n"
+		"\t----------------------------------------------\n",
+		(unsigned int)ioaddr);
+	printk ("\tcontrol reg (offset 0x%x): 0x%lx\n", MAC_CONTROL,
+			readl(ioaddr+MAC_CONTROL));
+	printk ("\taddr HI (offset 0x%x): 0x%lx\n ", MAC_ADDR_HIGH,
+			readl(ioaddr+MAC_ADDR_HIGH));
+	printk ("\taddr LO (offset 0x%x): 0x%lx\n", MAC_ADDR_LOW,
+			readl(ioaddr+MAC_ADDR_LOW));
+	printk ("\tmulticast hash HI (offset 0x%x): 0x%lx\n", MAC_HASH_HIGH,
+			readl(ioaddr+MAC_HASH_HIGH));
+	printk ("\tmulticast hash LO (offset 0x%x): 0x%lx\n", MAC_HASH_LOW,
+			readl(ioaddr+MAC_HASH_LOW));
+	printk ("\tflow control (offset 0x%x): 0x%lx\n", MAC_FLOW_CONTROL,
+			readl(ioaddr+MAC_FLOW_CONTROL));
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	printk ("\tVLAN1 tag (offset 0x%x): 0x%lx\n", MAC_VLAN1,
+			readl(ioaddr+MAC_VLAN1));
+	printk ("\tVLAN2 tag (offset 0x%x): 0x%lx\n", MAC_VLAN2,
+			readl(ioaddr+MAC_VLAN2));
+#endif
+	printk ("\tmac wakeup frame (offset 0x%x): 0x%lx\n", MAC_WAKEUP_FILTER,
+			readl(ioaddr+MAC_WAKEUP_FILTER));
+	printk ("\tmac wakeup crtl (offset 0x%x): 0x%lx\n",
+			MAC_WAKEUP_CONTROL_STATUS,
+			readl(ioaddr+MAC_WAKEUP_CONTROL_STATUS));
+
+	printk ("\n\tMAC management counter registers\n");
+	printk ("\t MMC crtl (offset 0x%x): 0x%lx\n",
+			MMC_CONTROL, readl(ioaddr+MMC_CONTROL));
+	printk ("\t MMC High Interrupt (offset 0x%x): 0x%lx\n",
+			MMC_HIGH_INTR, readl(ioaddr+MMC_HIGH_INTR));
+	printk ("\t MMC Low Interrupt (offset 0x%x): 0x%lx\n",
+			MMC_LOW_INTR, readl(ioaddr+MMC_LOW_INTR));
+	printk ("\t MMC High Interrupt Mask (offset 0x%x): 0x%lx\n",
+			MMC_HIGH_INTR_MASK, readl(ioaddr+MMC_HIGH_INTR_MASK));
+	printk ("\t MMC Low Interrupt Mask (offset 0x%x): 0x%lx\n",
+			MMC_LOW_INTR_MASK, readl(ioaddr+MMC_LOW_INTR_MASK));
+	return;
+}
+
+/* Set the hardware MAC address */
+static void set_mac_addr(unsigned long ioaddr, u8 Addr[6])
+{
+	unsigned long data;
+
+	data = (Addr[5]<<8) | Addr[4];
+	writel(data, ioaddr+MAC_ADDR_HIGH );
+	data = (Addr[3]<<24) | (Addr[2]<<16) | (Addr[1]<<8) | Addr[0];
+	writel(data, ioaddr+MAC_ADDR_LOW);
+
+	return;
+}
+
+/* Get the hardware MAC address  */
+static void get_mac_address(unsigned long ioaddr, unsigned char *addr)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = (unsigned int) readl(ioaddr+MAC_ADDR_HIGH);
+	lo_addr = (unsigned int) readl(ioaddr+MAC_ADDR_LOW);
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xff;
+	addr[1] = (lo_addr >>  8) & 0xff;
+	addr[2] = (lo_addr >> 16) & 0xff;
+	addr[3] = (lo_addr >> 24) & 0xff;
+	addr[4] = hi_addr & 0xff;
+	addr[5] = (hi_addr >>  8) & 0xff;
+
+	return;
+}
+
+/* Enable/Disable RX/TX MAC process*/
+static void stmmaceth_mac_enable_rx(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	/* set the RE (receive enable, bit 2) */
+	value |= (MAC_CONTROL_RE);
+	writel(value, ioaddr+MAC_CONTROL);
+	return;
+}
+
+static void stmmaceth_mac_enable_tx(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	/* set: TE (transmitter enable, bit 3) */
+	value |= (MAC_CONTROL_TE);
+	writel(value, ioaddr+MAC_CONTROL);
+	return;
+}
+
+static void stmmaceth_mac_disable_rx(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	value &= ~MAC_CONTROL_RE;
+	writel(value, ioaddr+MAC_CONTROL);
+	return;
+}
+
+static void stmmaceth_mac_disable_tx(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	value &= ~(MAC_CONTROL_TE);
+	writel(value, ioaddr+MAC_CONTROL);
+	return;
+}
+
+/* This function provides the initial setup of the MAC controller */
+static void stmmaceth_mac_core_init(struct net_device *dev)
+{
+	unsigned int value = 0;
+	unsigned long ioaddr=dev->base_addr;
+
+	/* Set the MAC control register with our default value */
+	value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	value |= MAC_CONTROL_HBD | MAC_CONTROL_PM | MAC_CONTROL_ASTP;
+	writel(value, ioaddr+MAC_CONTROL);
+
+	/* Change the MAX_FRAME bits in the MMC control register. */
+	value = 0x7ff;
+	/*value = dev->mtu + lp->ip_header_len + 4;*/
+	writel(((value << MMC_CONTROL_MAX_FRM_SHIFT) &
+		MMC_CONTROL_MAX_FRM_MASK), dev->base_addr+MMC_CONTROL);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	writel(ETH_P_8021Q, dev->base_addr+MAC_VLAN1);
+#endif
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+ *  			DESCRIPTORS functions
+ * ---------------------------------------------------------------------------*/
+static void display_dma_desc_ring(dma_desc *p, int size)
+{
+	int i;
+	for (i=0; i<size; i++) {
+		printk ("\t%d [0x%x]: "
+			"desc0=0x%x desc1=0x%x buffer1=0x%x", i,
+			(unsigned int) virt_to_bus(&p[i].des0), p[i].des0,
+			p[i].des1, (unsigned int)p[i].des2);
+		if (p[i].des3 != 0)
+			printk(" buffer2=0x%x", (unsigned int)p[i].des3);
+		printk("\n");
+	}
+}
+
+static void clear_dma_descs(dma_desc *p, unsigned int ring_size,
+		    	  unsigned int own_bit)
+{
+	int i;
+	for (i=0; i<ring_size; i++) {
+		p->des0 = own_bit;
+		if (!(own_bit))
+			p->des1 = 0;
+		else
+			p->des1 = ((DMA_BUFFER_SIZE-1)<<DES1_RBS1_SIZE_SHIFT);
+		if (i == ring_size-1) {
+			p->des1 |= DES1_CONTROL_TER;
+		}
+		/* The driver uses the 'implicit' scheme for implementing
+		 * the TX/RX DMA linked lists. */
+		p->des3 = 0;
+		p++;
+	}
+	return;
+}
+
+static void init_dma_desc_rings(struct net_device *dev)
+{
+	int i;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	lp->rx_buf_sz = DMA_BUFFER_SIZE;
+
+	ETHPRINTK(probe, DEBUG,"%s: allocate and init the DMA RX/TX lists\n",
+			    RESOURCE_NAME);
+
+	/* ---- DMA RX/TX descriptors initializaion */
+	lp->dma_rx = (dma_desc *) dma_alloc_coherent(lp->device,
+		 CONFIG_DMA_RX_SIZE*sizeof(struct dma_desc_t),
+		 &lp->dma_rx_phy, GFP_KERNEL);
+	lp->dma_tx = (dma_desc *) dma_alloc_coherent(lp->device,
+		 CONFIG_DMA_TX_SIZE*sizeof(struct dma_desc_t),
+		 &lp->dma_tx_phy, GFP_KERNEL);
+
+	if ((lp->dma_rx == NULL)||(lp->dma_tx == NULL)) {
+		printk(KERN_ERR "%s:ERROR allocating the DMA Tx/Rx desc\n",
+			__FUNCTION__);
+		return;
+	}
+	ETHPRINTK(probe, DEBUG, "%s: DMA desc rings: virt addr (Rx 0x%08x, "
+		"Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
+		dev->name, (unsigned int)lp->dma_rx ,(unsigned int)lp->dma_tx,
+		(unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
+
+	/* ---- RX INITIALIZATION */
+	ETHPRINTK(probe,DEBUG,"[RX skb data]   [DMA RX skb data] "
+			      "(buff size: %d)\n", lp->rx_buf_sz);
+	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
+		dma_desc *p = lp->dma_rx + i;
+		struct sk_buff *skb = dev_alloc_skb(lp->rx_buf_sz);
+		skb->dev = dev;
+		skb_reserve(skb, NET_IP_ALIGN);
+		lp->rx_skbuff[i] = skb;
+		if (skb == NULL)
+			break;
+		lp->rx_skbuff_dma[i] = dma_map_single(lp->device, skb->tail,
+					lp->rx_buf_sz, DMA_FROM_DEVICE);
+		p->des2 = lp->rx_skbuff_dma[i];
+		ETHPRINTK(probe, DEBUG, "[0x%08x]\t[0x%08x]\n",
+				(unsigned int)lp->rx_skbuff[i]->data,
+				(unsigned int)lp->rx_skbuff_dma[i]);
+	}
+	lp->cur_rx = 0;
+	lp->dirty_rx = (unsigned int)(i - CONFIG_DMA_RX_SIZE);
+
+	/* ---- TX INITIALIZATION */
+	for (i=0;i < CONFIG_DMA_TX_SIZE;i++) {
+		lp->tx_skbuff[i] = NULL;
+		lp->dma_tx[i].des2 = 0;
+		lp->dma_tx[i].des3 = 0;
+	}
+	lp->dirty_tx = lp->cur_tx = 0;
+
+	/* Clear the R/T descriptors 0/1 */
+	clear_dma_descs(lp->dma_rx, CONFIG_DMA_RX_SIZE, OWN_BIT);
+	clear_dma_descs(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
+
+	if (netif_msg_hw(lp)) {
+		printk ("RX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
+		printk ("TX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+	}
+    return;
+}
+
+/* Free all the skbuffs in the Rx queue. */
+static void dma_free_rx_bufs(struct net_device* dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
+		if (lp->rx_skbuff[i]) {
+			dma_unmap_single(lp->device, lp->rx_skbuff_dma[i],
+			      	         lp->rx_buf_sz, DMA_FROM_DEVICE);
+			dev_kfree_skb(lp->rx_skbuff[i]);
+		}
+		lp->rx_skbuff[i] = NULL;
+	}
+	return;
+}
+
+/* Free all the skbuffs in the Tx queue. */
+static void dma_free_tx_bufs(struct net_device* dev)
+{
+        struct eth_driver_local *lp = netdev_priv(dev);
+        int i;
+
+        for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
+		if (lp->tx_skbuff[i] != NULL) {
+                        if ((lp->dma_tx+i)->des2) {
+                                dma_unmap_single(lp->device, p->des2,
+                                   (p->des1 & DES1_RBS1_SIZE_MASK)>>
+				    DES1_RBS1_SIZE_SHIFT, DMA_TO_DEVICE);
+                        }
+                        if ((lp->dma_tx+i)->des3) {
+                                dma_unmap_single(lp->device, p->des3,
+                                   (p->des1 & DES1_RBS2_SIZE_MASK)>>
+				   DES1_RBS2_SIZE_SHIFT, DMA_TO_DEVICE);
+                        }
+                        dev_kfree_skb_any(lp->tx_skbuff[i]);
+                	lp->tx_skbuff[i] = NULL;
+                }
+        }
+	return;
+}
+
+/* Release and free the DMA descriptor resources. */
+static void free_dma_desc_resources(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Release the DMA TX/RX socket buffers */
+	dma_free_rx_bufs(dev);
+	dma_free_tx_bufs(dev);
+
+	/* Release the TX/RX rings */
+	dma_free_coherent(lp->device,
+		CONFIG_DMA_TX_SIZE*sizeof(struct dma_desc_t),
+		lp->dma_tx, lp->dma_tx_phy);
+	dma_free_coherent(lp->device,
+		CONFIG_DMA_RX_SIZE*sizeof(struct dma_desc_t),
+		lp->dma_rx, lp->dma_rx_phy);
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+				DMA FUNCTIONS
+ * ---------------------------------------------------------------------------*/
+static inline void dump_dma_csr(unsigned long ioaddr)
+{
+	int i;
+	printk ("\t--------------------\n"
+		"\t   STMMAC DMA CSR \n"
+		"\t--------------------\n");
+	for (i = 0; i<9; i++) {
+		printk ("\t CSR%d (offset 0x%x): 0x%lx\n", i,
+			(DMA_BUS_MODE + i*4), readl(ioaddr+DMA_BUS_MODE + i*4));
+	}
+	printk ("\t CSR20 (offset 0x%x): 0x%lx\n",
+		DMA_CUR_TX_BUF_ADDR, readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
+	printk ("\t CSR21 (offset 0x%x): 0x%lx\n",
+		DMA_CUR_RX_BUF_ADDR, readl(ioaddr+DMA_CUR_RX_BUF_ADDR));
+	return;
+}
+
+/* DMA SW reset.
+ *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
+ *	   SW reset otherwise the MAC core won't exit the reset state.
+ *  NOTE2: after a SW reset all interrupts are disabled */
+static void stmmaceth_dma_reset(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value=(unsigned int)readl(ioaddr+DMA_BUS_MODE);
+	value|= DMA_BUS_MODE_SFT_RESET;
+	writel(value, ioaddr+DMA_BUS_MODE);
+	while ((readl(ioaddr+DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {}
+	return;
+}
+
+/* START/STOP the DMA TX/RX processes */
+static void stmmaceth_dma_start_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |= DMA_CONTROL_ST ;
+	writel(value, ioaddr+DMA_CONTROL);
+	return;
+}
+
+static void stmmaceth_dma_stop_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value &=  ~DMA_CONTROL_ST;
+	writel(value, ioaddr+DMA_CONTROL);
+	return;
+}
+
+static void stmmaceth_dma_start_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |= DMA_CONTROL_SR ;
+	writel(value, ioaddr+DMA_CONTROL);
+
+#ifdef CONFIG_STMMAC_NAPI
+	/* Enable the RX irq */
+	value =(unsigned int)readl(ioaddr+DMA_INTR_ENA);
+	writel((value | DMA_INTR_ENA_RIE), ioaddr+DMA_INTR_ENA);
+#endif
+	return;
+}
+
+static void stmmaceth_dma_stop_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value &= ~DMA_CONTROL_SR;
+	writel(value, ioaddr+DMA_CONTROL);
+
+#ifdef CONFIG_STMMAC_NAPI
+	/* Disable the RX irq */
+	value =(unsigned int)readl(ioaddr+DMA_INTR_ENA);
+	writel((value & ~DMA_INTR_ENA_RIE), ioaddr+DMA_INTR_ENA);
+#endif
+	return;
+}
+
+/* The DMA init function performs:
+ * - the DMA RX/TX SW descriptors initialization
+ * - the DMA HW controller initialization
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
+static int stmmaceth_dma_init(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ETHPRINTK(probe, DEBUG, "STMMAC: DMA Core setup\n");
+
+	/* DMA SW reset */
+	stmmaceth_dma_reset(ioaddr);
+
+	/* Enable Application Access by writing to DMA CSR0 */
+	ETHPRINTK(probe, DEBUG, "\t(PBL: %d)\n", lp->pbl);
+	writel(DMA_BUS_MODE_DEFAULT | ((lp->pbl) << DMA_BUS_MODE_PBL_SHIFT) ,
+	       ioaddr+DMA_BUS_MODE);
+
+	/* Mask interrupts by writing to CSR7 */
+	writel(DMA_INTR_DEFAULT_MASK, ioaddr+DMA_INTR_ENA);
+
+	/* The base address of the RX/TX descriptor lists must be written into
+	 * DMA CSR3 and CSR4, respectively. */
+	writel((unsigned long)lp->dma_tx_phy,ioaddr+DMA_TX_BASE_ADDR);
+	writel((unsigned long)lp->dma_rx_phy,ioaddr+DMA_RCV_BASE_ADDR);
+
+	if (netif_msg_hw(lp))
+		dump_dma_csr(ioaddr);
+
+	return (0);
+}
+
+#ifdef CONFIG_STMMAC_DEBUG
+/* Transmit Process State for CSR5[22:20] */
+static void show_tx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
+
+	switch (state) {
+	   case 0: printk("- TX (Stopped): Reset or Stop command\n");
+	   	   break;
+	   case 1: printk("- TX (Running):Fetching the Tx desc\n");
+	   	   break;
+	   case 2: printk("- TX (Running): Waiting for end of tx\n");
+	   	   break;
+	   case 3: printk("- TX (Running): Reading the data "
+				    "and queuing the data into the Tx buf\n");
+	   	   break;
+	   case 6: printk("- TX (Suspended): Tx Buff Underflow "
+				    "or an unavailable Transmit descriptor\n");
+	   	   break;
+	   case 7: printk("- TX (Running): Closing Tx descriptor\n");
+	   	   break;
+	   default:
+	   	   break;
+	   }
+	return;
+}
+
+/* Receive Process State for CSR5[19:17] */
+static void show_rx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
+
+	switch (state) {
+	   case 0: printk("- RX (Stopped): Reset or Stop command\n");
+	   	   break;
+	   case 1: printk("- RX (Running): Fetching the Rx desc\n");
+	   	   break;
+	   case 2: printk("- RX (Running):Checking for end of pkt\n");
+	   	   break;
+	   case 3: printk("- RX (Running): Waiting for Rx pkt\n");
+	   	   break;
+	   case 4: printk("- RX (Suspended): Unavailable Rx buf\n");
+	   	   break;
+	   case 5: printk("- RX (Running): Closing Rx descriptor\n");
+	   	   break;
+	   case 6: printk("- RX(Running): Flushing the current frame"
+			  " from the Rx buf\n");
+	   	   break;
+	   case 7: printk("- RX (Running): Queuing the Rx frame"
+			  " from the Rx buf into memory\n");
+	   	   break;
+	   default:
+	   	   break;
+	}
+	return;
+}
+#endif
+
+/* When the transmission is completed the frame status is written into
+ * TDESC0 of the descriptor having the LS bit set.
+ * This function returns zero if no error is happened during the transmission.*/
+static int check_tx_error_summary(struct eth_driver_local *lp, int entry)
+{
+	dma_desc *p = lp->dma_tx + entry;
+	int status = p->des0;
+
+	ETHPRINTK(intr, INFO,"%s: [0x%x] - status %s\n", __FUNCTION__,
+			     (unsigned int)p, (!status)?"done":"with error");
+
+	if (status & TDES0_STATUS_DF) {
+		ETHPRINTK(tx_err, WARNING,"%s: DMA tx: deferred error\n",
+				RESOURCE_NAME);
+		goto out_error;
+	}
+	if (status & TDES0_STATUS_HRTBT_FAIL) {
+		ETHPRINTK(tx_err, WARNING, "%s: DMA tx: Heartbeat Fail\n",
+					RESOURCE_NAME);
+		lp->stats.tx_heartbeat_errors++;
+		goto out_error;
+	}
+
+	if (status & TDES0_STATUS_ES) {
+		ETHPRINTK(tx_err, ERR,  "%s: DMA tx ERROR: ", RESOURCE_NAME);
+
+		if (status & TDES0_STATUS_UF) {
+			ETHPRINTK(tx_err, ERR, "Underflow Error\n");
+			goto out_error;
+		}
+		if (status & TDES0_STATUS_EX_DEF){
+			ETHPRINTK(tx_err, ERR, "Ex Deferrals\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_EX_COL) {
+			ETHPRINTK(tx_err, ERR, "Ex Collisions\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_LATE_COL) {
+			ETHPRINTK(tx_err, ERR, "Late Collision\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_NO_CARRIER){
+			ETHPRINTK(tx_err, ERR, "No Carrier\n");
+			goto out_error;
+		}
+		if (status & TDES0_STATUS_LOSS_CARRIER) {
+			ETHPRINTK(tx_err, ERR, "Loss of Carrier\n");
+			goto out_error;
+		}
+	}
+
+	return (0);
+
+set_collision:
+	lp->stats.collisions +=((status & TDES0_STATUS_COLCNT_MASK)>>
+		TDES0_STATUS_COLCNT_SHIFT);
+out_error:
+	lp->stats.tx_errors++;
+
+	return (-1);
+}
+
+/* This is the tasklet or the bottom half of the IRQ handler.
+ * The tasklet is used for freeing the TX resources.  */
+static void stmmaceth_clean_tx_irq(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct  eth_driver_local *lp = netdev_priv(dev);
+	int entry = lp->dirty_tx % CONFIG_DMA_TX_SIZE;
+
+	while (lp->dirty_tx != lp->cur_tx) {
+		dma_desc *p = lp->dma_tx + entry;
+
+		if (!(p->des0 & OWN_BIT)) {
+			if (p->des1 & TDES1_CONTROL_LS)
+				if (!check_tx_error_summary(lp, entry))
+					lp->stats.tx_packets++;
+
+			ETHPRINTK(tx_done, INFO, "%s: (entry %d)\n",
+						__FUNCTION__, entry);
+                        if (p->des2) {
+				dma_unmap_single(lp->device, p->des2,
+				  (p->des1 & DES1_RBS1_SIZE_MASK)>>
+				   DES1_RBS1_SIZE_SHIFT, DMA_TO_DEVICE);
+				p->des2 = 0;
+			}
+
+                        if (p->des3) {
+                                dma_unmap_single(lp->device, p->des3,
+                                   (p->des1 & DES1_RBS2_SIZE_MASK)>>
+				   DES1_RBS2_SIZE_SHIFT, DMA_TO_DEVICE);
+				p->des3 = 0;
+                        }
+
+			if (lp->tx_skbuff[entry] != NULL) {
+				dev_kfree_skb_irq(lp->tx_skbuff[entry]);
+				lp->tx_skbuff[entry] = NULL;
+			}
+		}
+		entry = (++lp->dirty_tx) % CONFIG_DMA_TX_SIZE;
+	}
+	if (netif_queue_stopped(dev)) {
+		netif_wake_queue(dev);
+	}
+	return;
+}
+
+/*
+ *  --- Interrupt handler for the MAC110 DMA
+ *
+ * It determines if we have to call either the Rx or the Tx interrupt handler.
+ * Numerous events can cause an interrupt: a new packet has arrived
+ * or transmission is completed or an error occurred).  */
+static void stmmaceth_dma_interrupt(struct net_device *dev)
+{
+	unsigned int status;
+	unsigned int ioaddr = dev->base_addr;
+	struct  eth_driver_local *lp = netdev_priv(dev);
+	lp->rx_buff = readl(ioaddr+DMA_CUR_RX_BUF_ADDR);
+
+	/* read the status register (CSR5) */
+	status = (unsigned int)readl(ioaddr+DMA_STATUS);
+
+	ETHPRINTK(intr, INFO, "%s: (%s) [CSR5: 0x%08x]\n", RESOURCE_NAME,
+			      "DMA IRQ", status);
+#ifdef CONFIG_STMMAC_DEBUG
+	/* It displays the DMA transmit process state (CSR5 register) */
+	if (netif_msg_tx_done(lp))
+		show_tx_process_state(status);
+	if (netif_msg_rx_status(lp))
+		show_rx_process_state(status);
+#endif
+
+	/* Process the NORMAL interrupts */
+	if (status & DMA_STATUS_NIS) {
+		ETHPRINTK(intr, INFO, " CSR5[16]: DMA NORMAL IRQ: ");
+		if (status & DMA_STATUS_RI) {
+			ETHPRINTK (intr, INFO, "Receive irq [buf: 0x%08x]\n",
+						lp->rx_buff);
+#ifndef CONFIG_STMMAC_NAPI
+			stmmaceth_rx(dev);
+#else
+			stmmaceth_dma_stop_rx(ioaddr);
+			if (netif_rx_schedule_prep(dev)) {
+				__netif_rx_schedule(dev);
+			} else {
+				ETHPRINTK (intr, ERR,"%s: bug!!! "
+				  "interrupt while in poll.\n", __FUNCTION__);
+			}
+#endif
+		}
+		if (unlikely(status & DMA_STATUS_ERI)) {
+			ETHPRINTK(intr,INFO,"Early Receive Interrupt\n");
+		}
+		if (status & DMA_STATUS_TI) {
+			ETHPRINTK(intr, INFO," Transmit irq [buf: 0x%lx]\n",
+		  	 	 readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
+			tasklet_hi_schedule(&lp->tx_task);
+		}
+		if (unlikely(status & DMA_STATUS_TU)) {
+			ETHPRINTK (intr, INFO, "Transmit Buffer Unavailable\n");
+		}
+	}
+	/* ABNORMAL interrupts */
+	if (unlikely(status & DMA_STATUS_AIS)) {
+		ETHPRINTK (intr, INFO,"CSR5[15] DMA ABNORMAL IRQ: ");
+		if (status & DMA_STATUS_TPS) {
+			ETHPRINTK (intr, INFO,"Transmit Process Stopped \n");
+		}
+		if (status & DMA_STATUS_TJT){
+			ETHPRINTK (intr, INFO,"Transmit Jabber Timeout\n");
+		}
+		if (status & DMA_STATUS_OVF) {
+			ETHPRINTK (intr, INFO,"Receive Overflow\n");
+		}
+		if (status & DMA_STATUS_UNF) {
+			ETHPRINTK (intr, INFO,"Transmit Underflow\n");
+		}
+		if (status & DMA_STATUS_RU){
+			ETHPRINTK (intr, INFO,"Rx Buffer Unavailable\n");
+		}
+		if (status & DMA_STATUS_RPS){
+			ETHPRINTK (intr, INFO,"Receive Process Stopped\n");
+		}
+		if (status & DMA_STATUS_RWT){
+			ETHPRINTK (intr, INFO,"Rx Watchdog Timeout\n");
+		}
+		if (status & DMA_STATUS_ETI){
+			ETHPRINTK (intr, INFO,"Early Tx Interrupt\n");
+		}
+		if (status & DMA_STATUS_FBI){
+			ETHPRINTK (intr, INFO,"Fatal Bus Error Interrupt\n");
+		}
+	}
+	ETHPRINTK (intr, INFO,"\n\n");
+
+	/* Clear the interrupt by writing a logic 1 to the relative bits */
+	writel(status, ioaddr+DMA_STATUS);
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+			      DEVICE METHODS
+   ---------------------------------------------------------------------------*/
+int stmmaceth_open(struct net_device *dev)
+{
+	struct  eth_driver_local *lp = netdev_priv(dev);
+	int ret;
+
+       /* Request the IRQ lines */
+	if ( (ret = request_irq(dev->irq, &stmmaceth_interrupt,
+				SA_SHIRQ, dev->name, dev)) < 0 ) {
+		printk(KERN_ERR "%s: ERROR:allocating the IRQ %d (error: %d)\n",
+				__FUNCTION__, dev->irq, ret);
+		return (ret);
+	}
+
+	/* Check that the MAC address is valid.  If its not, refuse
+	 * to bring the device up. The user must specify an
+	 * address using the following linux command:
+	 * 	ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		ETHPRINTK(probe,ERR,"%s: no valid eth hw addr\n", __FUNCTION__);
+		return (-EINVAL);
+	}
+
+	/* Copy the MAC addr into the HW in case we have set it with nwhw */
+	set_mac_addr(dev->base_addr, dev->dev_addr);
+
+	/* Initialize the MAC110 Core */
+	stmmaceth_mac_core_init(dev);
+
+	/* Enable the MAC/DMA */
+	stmmaceth_mac_enable_rx(dev);
+	stmmaceth_mac_enable_tx(dev);
+
+	if (netif_msg_hw(lp))
+		dump_stm_mac_csr((unsigned int)dev->base_addr);
+
+	/* Attach the PHY */
+	ret = stmmac_init_phy(dev);
+	if (ret)
+	{
+		printk(KERN_ERR "%s: Cannot attach to PHY (error: %d)\n",
+				__FUNCTION__, ret);
+		return (-ENODEV);
+	}
+
+	phy_start(lp->phydev);
+
+	/* Start the ball rolling... */
+	ETHPRINTK(probe, DEBUG, "%s: DMA RX/TX processes started...\n",
+				RESOURCE_NAME);
+
+	stmmaceth_dma_start_rx(dev->base_addr);
+	stmmaceth_dma_start_tx(dev->base_addr);
+
+	netif_start_queue(dev);
+	return (0);
+}
+
+int stmmaceth_release(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Stop the PHY */
+	phy_stop(lp->phydev);
+	phy_disconnect(lp->phydev);
+	lp->phydev = NULL;
+
+	/* Free the IRQ lines */
+	free_irq(dev->irq, dev);
+
+	/* Reset the TX/RX processes */
+	tasklet_kill(&lp->tx_task);
+	stmmaceth_dma_stop_tx(dev->base_addr);
+	clear_dma_descs(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
+	dma_free_tx_bufs(dev);
+	stmmaceth_dma_stop_rx(dev->base_addr);
+
+	/* Disable the MAC core */
+	stmmaceth_mac_disable_tx(dev);
+	stmmaceth_mac_disable_rx(dev);
+
+	/* Change the link status */
+	netif_carrier_off(dev);
+
+	return (0);
+}
+
+/* It is used for filling the DMA tx ring with the frame to be transmitted.
+ * Note that the algorithm works both for the non-paged data and for the paged
+ * fragment (SG).
+ * It also supports the segmentation offloading for super-sized skb's
+ * (skb_shinfo(skb)->tso_size != 0). */
+static int stmmaceth_fill_tx_buffer(void *data, unsigned int size, unsigned int mss,
+				    struct eth_driver_local *lp, int first)
+{
+	int new_des = 0;
+	void *addr = data;
+	dma_desc *p = lp->dma_tx;
+	unsigned int entry;
+
+	TSOPRINTK(mss, INFO,"  %s (size=%d, addr=0x%x)\n", s,
+		size, (unsigned int) addr);
+	do {
+		if (new_des) {
+			lp->cur_tx++;
+			new_des = 0;
+		}
+		entry = lp->cur_tx % CONFIG_DMA_TX_SIZE;
+		/* Set the owner field */
+		p[entry].des0 = OWN_BIT;
+		/* Reset the descriptor number 1 */
+		p[entry].des1 = (p[entry].des1 & DES1_CONTROL_TER);
+		if (first)
+			p[entry].des1 |= TDES1_CONTROL_FS;
+		else
+			lp->tx_skbuff[entry] = NULL;
+
+		TSOPRINTK(mss, INFO, "\t[entry =%d] buf1 len=%d\n",
+				entry, min((int)size, DMA_BUFFER_SIZE));
+		/* If the data size is too big we need to use the buffer 2
+		 * (in the same descriptor) or, if necessary, another descriptor
+		 * in the ring. */
+		if (size < DMA_BUFFER_SIZE) {
+			p[entry].des1 |= ((size << DES1_RBS1_SIZE_SHIFT) &
+			  	DES1_RBS1_SIZE_MASK);
+			p[entry].des2 = dma_map_single(lp->device, addr,
+				size, DMA_TO_DEVICE);
+		} else {
+			int b2_size = (size - DMA_BUFFER_SIZE);
+
+			p[entry].des1 |= TDES1_MAX_BUF1_SIZE;
+			p[entry].des2 = dma_map_single(lp->device, addr,
+				DMA_BUFFER_SIZE, DMA_TO_DEVICE);
+
+			/* Check if we need to use the buffer 2 */
+			if (b2_size > 0) {
+				void *buffer2 = addr;
+
+				TSOPRINTK(mss,INFO,"\t[entry=%d] buf2 len=%d\n",
+					entry, min(b2_size, DMA_BUFFER_SIZE));
+
+				/* Check if we need another descriptor.*/
+				if (b2_size > DMA_BUFFER_SIZE) {
+					b2_size = DMA_BUFFER_SIZE;
+					size -= (2*DMA_BUFFER_SIZE);
+					addr += ((2*DMA_BUFFER_SIZE)+1);
+					new_des = 1;
+					TSOPRINTK(mss,INFO,"\tnew descriptor - "
+					       "%s (len = %d)\n",
+						(first)?"skb->data":"Frag",size);
+				}
+				p[entry].des3 = dma_map_single(lp->device,
+						 (buffer2+DMA_BUFFER_SIZE+1),
+						  b2_size,DMA_TO_DEVICE);
+				if (b2_size == DMA_BUFFER_SIZE) {
+					p[entry].des1 |= TDES1_MAX_BUF2_SIZE;
+				}else{
+					p[entry].des1 |=((b2_size<<DES1_RBS2_SIZE_SHIFT)
+					      & DES1_RBS2_SIZE_MASK);
+				}
+			}
+		}
+	} while(new_des);
+	return (entry);
+}
+
+int stmmaceth_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	dma_desc *p = lp->dma_tx;
+        unsigned int nfrags = skb_shinfo(skb)->nr_frags,
+	    entry = lp->cur_tx % CONFIG_DMA_TX_SIZE,
+	    i, mss = 0, nopaged_len;
+
+	if (skb->len < ETH_ZLEN) {
+		skb = skb_padto(skb, ETH_ZLEN);
+		skb->len = ETH_ZLEN;
+        }
+
+	/* Reporting an error if either the frame, to be transmitted, is too
+	 * long or we haven't enough space in the DMA ring. If the following
+	 * error is reported, probably, you ought to increase the ring size.*/
+	if (nfrags >= CONFIG_DMA_TX_SIZE){
+		printk (KERN_ERR "%s: ERROR too many fragments (%d)...\n",
+			__FUNCTION__, nfrags);
+		goto xmit_error;
+	}
+	if (dev->features & NETIF_F_TSO){
+		/*Maximum  Segment Size*/
+		mss = skb_shinfo(skb)->tso_size;
+
+		if ((skb->len > ((2*(DMA_BUFFER_SIZE))*CONFIG_DMA_TX_SIZE))
+		    && (mss != 0)){
+			printk (KERN_ERR"%s: (TSO) frame too long (%d)...\n",
+				__FUNCTION__, skb->len);
+			goto xmit_error;
+		}
+	}
+	/* Verify the csum via software... it' necessary, because the
+	 * hardware doesn't support a complete csum calculation. */
+	if (skb->ip_summed == CHECKSUM_HW){
+		if (skb_checksum_help(skb, 0))
+			goto xmit_error;
+	}
+	/* Get the amount of non-paged data (skb->data). */
+	nopaged_len = skb_headlen(skb);
+	lp->tx_skbuff[entry] = skb;
+	TSOPRINTK(mss, INFO,"\n%s:\n(skb->len=%d, nfrags=%d, "
+			"nopaged_len=%d, mss=%d)\n", __FUNCTION__, skb->len,
+						  nfrags, nopaged_len, mss);
+	/* Handle the non-paged data (skb->data) */
+	stmmaceth_fill_tx_buffer(skb->data, nopaged_len, mss, lp, 1);
+
+	/* Handle the paged fragments */
+	for (i=0; i < nfrags; i++) {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+		void *addr=((void *)page_address(frag->page)+frag->page_offset);
+		int len = frag->size;
+
+		lp->cur_tx++;
+		entry = stmmaceth_fill_tx_buffer(addr, len, mss, lp, 0);
+	}
+	p[entry].des1 |= TDES1_CONTROL_LS | TDES1_CONTROL_IC;
+	lp->cur_tx++;
+
+	if ((lp->cur_tx - lp->dirty_tx) >= TX_QUEUE_LEN + nfrags)
+		netif_stop_queue(dev);
+
+	lp->stats.tx_bytes += skb->len;
+        dev->trans_start = jiffies;
+
+#ifdef CONFIG_STMMAC_DEBUG
+	if (netif_msg_pktdata(lp)) {
+		printk(">>> (current=%d, dirty=%d; entry=%d)\n",
+			(lp->cur_tx % CONFIG_DMA_TX_SIZE),
+			(lp->dirty_tx % CONFIG_DMA_TX_SIZE), entry);
+		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+		printk (">>> frame to be transmitted: ");
+		print_pkt(skb->data, skb->len);
+	}
+#endif
+	/* CSR1 enables the transmit DMA to check for new descriptor */
+	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
+	return (0);
+
+xmit_error:
+	dev_kfree_skb(skb);
+	lp->stats.tx_dropped++;
+	return (0);
+}
+
+/* If the NAPI support is enable the stmmaceth_poll method will be
+ * scheduled at interrupt time.
+ * Otherwise, the stmmaceth_rx(...) is the receive function processed
+ * by the regular interrupt handle. */
+#ifdef CONFIG_STMMAC_NAPI
+static int stmmaceth_poll(struct net_device *dev, int *budget)
+#else
+static int  stmmaceth_rx (struct net_device *dev)
+#endif
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int frame_len = 0, entry = lp->cur_rx % CONFIG_DMA_RX_SIZE;
+	dma_desc *drx = lp->dma_rx + entry;
+#ifdef CONFIG_STMMAC_NAPI
+	int npackets = 0, quota = min(dev->quota, *budget);
+#endif
+
+#ifdef CONFIG_STMMAC_DEBUG
+	if (netif_msg_rx_status(lp)) {
+		printk ("%s: RX descriptor ring:\n", __FUNCTION__);
+		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
+	}
+#endif
+	while (!(drx->des0 & OWN_BIT)) {
+		struct sk_buff *skb;
+		unsigned int status = drx->des0;
+#ifdef CONFIG_STMMAC_NAPI
+		if (npackets > quota){
+			printk("%s: ERROR: out of quota (%d); npackets %d\n",
+					dev->name, quota, npackets);
+			drx->des0 = OWN_BIT;
+			break;
+		}
+#endif
+		/* Check if the frame was not successfully received */
+		if (status & RDES0_STATUS_ES) {
+			ETHPRINTK(rx_err, ERR, "%s: DMA rx ERROR: ",
+					RESOURCE_NAME);
+			if (status & RDES0_STATUS_DE)
+				ETHPRINTK(rx_err, ERR, "descriptor error\n");
+			if (status & RDES0_STATUS_PFE)
+				ETHPRINTK(rx_err, ERR, "partial frame error\n");
+			if (status & RDES0_STATUS_RUNT_FRM)
+				ETHPRINTK(rx_err, ERR, "runt Frame\n");
+			if (status & RDES0_STATUS_TL)
+				ETHPRINTK(rx_err, ERR, "frame too long\n");
+			if (status & RDES0_STATUS_COL_SEEN) {
+				ETHPRINTK(rx_err, ERR, "collision seen\n");
+				lp->stats.collisions++;
+			}
+			lp->stats.rx_errors++;
+			goto next_frame;
+		}
+		/* update multicast stats */
+		if (status & RDES0_STATUS_MULTICST_FRM)
+			lp->stats.multicast++;
+		/* FL (frame length) indicates the length in byte including
+		 * the CRC */
+		frame_len=(status&RDES0_STATUS_FL_MASK)>>RDES0_STATUS_FL_SHIFT;
+		ETHPRINTK(rx_status, INFO,">>> desc addr: 0x%0x [entry: %d]\n"
+			  "\tdesc0=0x%x desc1=0x%x buffer1=0x%x\n",
+			  (unsigned int )drx, entry, drx->des0, drx->des1,
+			  drx->des2);
+		/* Check if the packet is long enough to accept without
+		   copying to a minimally-sized skbuff. */
+		if (frame_len < min_rx_pkt_size) {
+			skb = dev_alloc_skb(frame_len + 2);
+			if (!skb) {
+				if (printk_ratelimit())
+					printk(KERN_NOTICE "%s: low memory, "
+						"packet dropped.\n", dev->name);
+				lp->stats.rx_dropped++;
+				goto next_frame;
+			}
+			skb->dev = dev;
+			skb_reserve(skb, NET_IP_ALIGN);
+			dma_sync_single_for_cpu(lp->device,
+						lp->rx_skbuff_dma[entry],
+			       			lp->rx_buf_sz, DMA_FROM_DEVICE);
+			eth_copy_and_sum(skb, lp->rx_skbuff[entry]->tail,
+					frame_len, 0);
+			skb_put(skb, frame_len);
+			dma_sync_single_for_device(lp->device,
+						   lp->rx_skbuff_dma[entry],
+			                           lp->rx_buf_sz,
+						   DMA_FROM_DEVICE);
+		} else { /* zero-copy */
+			skb = lp->rx_skbuff[entry];
+			dma_unmap_single(lp->device, lp->rx_skbuff_dma[entry],
+					lp->rx_buf_sz, DMA_FROM_DEVICE);
+			lp->rx_skbuff[entry] = NULL;
+			skb_put(skb, frame_len);
+		}
+#ifdef CONFIG_STMMAC_DEBUG
+		if (netif_msg_pktdata(lp)){
+			printk (">>> frame received: ");
+			print_pkt(skb->data, frame_len);
+		}
+#endif
+		skb->protocol = eth_type_trans(skb, dev);
+
+		if (lp->rx_csum) {
+			/* The device can "opaquely" calculate and verify any
+			 * csum in the incoming frames and report
+			 * success-or-failure to the driver.*/
+			if (status & RDES0_STATUS_CE) {
+				ETHPRINTK(rx_err, ERR, "CRC Error\n");
+				skb->ip_summed = CHECKSUM_NONE;
+			} else /* The network stack will calculate and
+				  verify the csum.*/
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+		} else
+			skb->ip_summed = CHECKSUM_NONE;
+
+#ifdef CONFIG_STMMAC_NAPI
+		npackets++;
+		netif_receive_skb(skb);
+#else
+		netif_rx(skb);
+#endif
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += frame_len;
+		dev->last_rx = jiffies;
+
+next_frame:
+		drx->des0 = OWN_BIT;
+		entry = (++lp->cur_rx) % CONFIG_DMA_RX_SIZE;
+		drx = lp->dma_rx + entry;
+	}
+
+       /* Refill the Rx ring buffers (zero-copy) */
+       for (; lp->cur_rx - lp->dirty_rx > 0; lp->dirty_rx++) {
+		struct sk_buff *skb;
+		entry = lp->dirty_rx % CONFIG_DMA_RX_SIZE;
+		if (lp->rx_skbuff[entry] == NULL) {
+			skb = dev_alloc_skb(lp->rx_buf_sz);
+			lp->rx_skbuff[entry] = skb;
+			if (skb == NULL)
+			        break;
+			skb->dev = dev;
+			lp->rx_skbuff_dma[entry] =
+			        dma_map_single(lp->device, skb->tail,
+			                       lp->rx_buf_sz,
+			                       DMA_FROM_DEVICE);
+			(lp->dma_rx+entry)->des2=lp->rx_skbuff_dma[entry];
+			ETHPRINTK(rx_status, INFO,">>> refill entry #%d\n",
+						  entry);
+		}
+	}
+
+#ifdef CONFIG_STMMAC_NAPI
+	 /* All the packets in the DMA have been processed so we can
+	  * reenable the RX interrupt. */
+	*budget -= npackets;
+	dev->quota -= npackets;
+	netif_rx_complete(dev);
+	stmmaceth_dma_start_rx(dev->base_addr);
+#else
+	writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
+#endif
+	return 0;
+}
+
+/* This function is called when a packet transmission fails to complete
+ * within a reasonable period. The driver will mark the error in the
+ * netdev structure and arrange for the device to be reset to a sane state
+ * in order to transmit a new packet. */
+void stmmaceth_tx_timeout (struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	printk("%s: Tx timeout at %ld, latency %ld\n",
+		dev->name, jiffies, (jiffies - dev->trans_start));
+
+#ifdef CONFIG_STMMAC_DEBUG
+	printk("(current=%d, dirty=%d)\n",(lp->cur_tx % CONFIG_DMA_TX_SIZE),
+		    (lp->dirty_tx % CONFIG_DMA_TX_SIZE));
+	printk ("DMA tx ring status: \n");
+	display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+#endif
+	netif_stop_queue(dev);
+	tasklet_disable(&lp->tx_task);
+	stmmaceth_dma_stop_tx(dev->base_addr);
+	clear_dma_descs(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
+	dma_free_tx_bufs(dev);
+	tasklet_enable(&lp->tx_task);
+	stmmaceth_dma_start_tx(dev->base_addr);
+	lp->stats.tx_errors++;
+	dev->trans_start = jiffies;
+	netif_start_queue(dev);
+
+	return;
+}
+
+/* Return statistics to the caller application */
+struct net_device_stats *stmmaceth_stats(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	return &lp->stats;
+}
+
+/* Configuration changes (passed on by ifconfig) */
+int stmmaceth_config(struct net_device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP) /* can't act on a running interface */
+		return -EBUSY;
+
+	/* Don't allow changing the I/O address */
+	if (map->base_addr != dev->base_addr) {
+		printk(KERN_WARNING "%s: can't change I/O address\n",dev->name);
+		return -EOPNOTSUPP;
+	}
+
+	/* Don't allow changing the IRQ */
+	if (map->irq != dev->irq) {
+		printk(KERN_WARNING "%s: can't change IRQ number %d\n",
+					 dev->name, dev->irq);
+		return -EOPNOTSUPP;
+	}
+
+	/* ignore other fields */
+	return (0);
+}
+
+/* ---------------------------------------------------------------------------
+			Address Filtering Method
+   ---------------------------------------------------------------------------*/
+static void stmmaceth_set_rx_mode(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	u32 mc_filter[2]; /* Multicast hash filter */
+
+	ETHPRINTK(probe, DEBUG,"%s: mc_list = 0x%x, mc_count = 0x%x\n",
+			      __FUNCTION__, (unsigned int)dev->mc_list,
+			      dev->mc_count);
+
+	if (dev->flags & IFF_PROMISC) {
+		ETHPRINTK(probe, DEBUG,"\tpromiscuous mode enabled.\n");
+		/* Promiscuous mode: set th PR bit in order to indicate
+		 * that all incoming frame are valid regardless of the
+		 * destination address.  */
+		value |= MAC_CONTROL_PR;
+		value &= ~(MAC_CONTROL_IF|MAC_CONTROL_HO);
+	} else if (dev->flags & IFF_ALLMULTI) {
+		ETHPRINTK(probe, DEBUG,"\tpass all multicast mode enabled.\n");
+		value |= MAC_CONTROL_PM;
+		value &= ~(MAC_CONTROL_PR|MAC_CONTROL_IF|MAC_CONTROL_HO);
+	} else {
+		if (dev->mc_count == 0) {
+			ETHPRINTK(probe, DEBUG,"\tperfect filtering mode.\n");
+			value &= ~(MAC_CONTROL_PM|MAC_CONTROL_PR|MAC_CONTROL_IF|
+				   MAC_CONTROL_HO|MAC_CONTROL_HP);
+			writel(0x0, ioaddr+MAC_HASH_HIGH);
+			writel(0x0, ioaddr+MAC_HASH_LOW);
+		} else {
+			/* MAC Addr Perfect Filtering for physical addresses
+			 * and Hash Filtering for Multicast addresses;
+			 * Pass Multicast frames if enabled. */
+			int i;
+			ETHPRINTK(probe, DEBUG,"\tset Hash table for multicast "
+					  "addresses\n");
+			mc_filter[1] = mc_filter[0] = 0;
+			for (i = 0, lp->dmi = dev->mc_list;
+			     lp->dmi && i < dev->mc_count;
+			     i++, lp->dmi = lp->dmi->next) {
+				int bit_nr = ether_crc(ETH_ALEN,
+						lp->dmi->dmi_addr) >> 26;
+				mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			}
+			writel(mc_filter[0], ioaddr+MAC_HASH_HIGH);
+			writel(mc_filter[1], ioaddr+MAC_HASH_LOW);
+
+			value |= MAC_CONTROL_HP;
+			value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |
+				   MAC_CONTROL_IF| MAC_CONTROL_HO);
+		}
+	}
+
+	writel(value, ioaddr+MAC_CONTROL);
+
+	if (netif_msg_hw(lp))
+		dump_stm_mac_csr((unsigned int)dev->base_addr);
+	return;
+}
+
+/* The Maximum Transfer Unit (MTU) is used by the network layer to
+ * drive packet transmission. Ethernet has an MTU of 1500 octets (ETH_DATA_LEN).
+ * This value can be changed with ifconfig.  */
+static int stmmaceth_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (netif_running(dev)) {
+		printk (KERN_ERR "%s: must be stopped to change its MTU\n",
+				 dev->name);
+		return -EBUSY;
+	}
+
+	if ((new_mtu < MIN_MTU) || (new_mtu > MAX_MTU))
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+
+	return (0);
+}
+
+/* ---------------------------------------------------------------------------
+			REGULAR INTERRUPT FUNCTION
+   ---------------------------------------------------------------------------*/
+static irqreturn_t stmmaceth_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs)
+{
+	struct eth_driver_local *lp;
+	struct net_device *dev = (struct net_device *)dev_id;
+
+	if (!dev) {
+		printk (KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
+		return IRQ_NONE;
+	}
+	lp = netdev_priv(dev);
+
+	stmmaceth_dma_interrupt(dev);
+
+	return IRQ_HANDLED;
+}
+
+/* ---------------------------------------------------------------------------
+		  		NETPOLL SUPPORT
+   ---------------------------------------------------------------------------*/
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling receive - used by NETCONSOLE and other diagnostic tools
+ * to allow network I/O with interrupts disabled. */
+static void stmmaceth_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	stmmaceth_interrupt(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
+
+/* ----------------------------------------------------------------------------
+		  		ETHTOOL SUPPORT
+   ---------------------------------------------------------------------------*/
+static void stmmaceth_ethtool_getdrvinfo(struct net_device *dev,
+				   struct ethtool_drvinfo*info)
+{
+	strcpy(info->driver, RESOURCE_NAME);
+	strncpy(info->version, version, sizeof(version));
+	strcpy(info->bus_info, "STBUS");
+	info->fw_version[0] = '\0';
+	return;
+}
+
+static int stmmaceth_ethtool_getsettings(struct net_device *dev,
+					  struct ethtool_cmd *cmd)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	struct phy_device *phy = lp->phydev;
+
+	if (phy == NULL)
+	{
+		printk(KERN_ERR "%s: ethtool_getsettings PHY is not registered\n", dev->name);
+		return -ENODEV;
+	}
+
+	if (!netif_running(dev)) {
+		printk(KERN_ERR "%s: interface is disabled: we cannot track "
+				   "link speed / duplex setting\n", dev->name);
+		return -EBUSY;
+	}
+
+	cmd->transceiver = XCVR_INTERNAL;
+	return phy_ethtool_gset(phy, cmd);
+}
+
+static int stmmaceth_ethtool_setsettings(struct net_device *dev,
+					  struct ethtool_cmd *cmd)
+{
+	struct eth_driver_local *lp = dev->priv;
+	struct phy_device *phy = lp->phydev;
+
+	return phy_ethtool_sset(phy, cmd);
+}
+
+static u32 stmmaceth_ethtool_getmsglevel(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	return lp->msg_enable;
+}
+
+static void stmmaceth_ethtool_setmsglevel(struct net_device *dev, u32 level)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	lp->msg_enable = level;
+
+}
+
+static int stmmaceth_check_if_running(struct net_device *dev)
+{
+	if (!netif_running(dev))
+		return -EBUSY;
+	return (0);
+}
+
+#define REGDUMP_LEN         (32 * 1024)
+int stmmaceth_ethtool_get_regs_len(struct net_device *dev)
+{
+	return (REGDUMP_LEN);
+}
+
+static void stmmaceth_ethtool_gregs(struct net_device *dev,
+			       	     struct ethtool_regs *regs, void *space)
+{
+	int i;
+	u32 reg;
+	u32 *reg_space = (u32 *) space;
+
+	memset(reg_space, 0x0, REGDUMP_LEN);
+
+	/* MAC registers */
+	for (i = 0; i < 11; i++) {
+		reg = readl(dev->base_addr + i*4);
+		memcpy((reg_space + i*4), &reg, sizeof(u32));
+	}
+
+	/* DMA registers */
+	for (i = 0; i<9; i++) {
+		reg = readl(dev->base_addr+(DMA_BUS_MODE+i*4));
+		memcpy((reg_space + (DMA_BUS_MODE+i*4)), &reg,
+			sizeof(u32));
+	}
+	reg = readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_TX_BUF_ADDR), &reg, sizeof(u32));
+	reg = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_RX_BUF_ADDR), &reg, sizeof(u32));
+
+	return;
+}
+
+
+int stmmaceth_ethtool_set_tx_csum(struct net_device *dev, u32 data)
+{
+	if (data)
+		dev->features |= NETIF_F_HW_CSUM;
+	else
+		dev->features &= ~NETIF_F_HW_CSUM;
+
+	return 0;
+}
+
+u32 stmmaceth_ethtool_get_rx_csum(struct net_device * dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	return (lp->rx_csum);
+}
+
+int stmmaceth_ethtool_set_rx_csum(struct net_device *dev, u32 data)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	if (data)
+		lp->rx_csum = 1;
+	else
+		lp->rx_csum = 0;
+
+	return 0;
+}
+
+static struct ethtool_ops stmmaceth_ethtool_ops = {
+	.begin 		= stmmaceth_check_if_running,
+	.get_drvinfo    = stmmaceth_ethtool_getdrvinfo,
+	.get_settings   = stmmaceth_ethtool_getsettings,
+	.set_settings   = stmmaceth_ethtool_setsettings,
+	.get_msglevel   = stmmaceth_ethtool_getmsglevel,
+	.set_msglevel   = stmmaceth_ethtool_setmsglevel,
+	.get_regs 	= stmmaceth_ethtool_gregs,
+	.get_regs_len 	= stmmaceth_ethtool_get_regs_len,
+	.get_link       = ethtool_op_get_link,
+	.get_rx_csum 	= stmmaceth_ethtool_get_rx_csum,
+	.set_rx_csum 	= stmmaceth_ethtool_set_rx_csum,
+	.get_tx_csum 	= ethtool_op_get_tx_csum,
+	.set_tx_csum 	= stmmaceth_ethtool_set_tx_csum,
+	.get_sg 	= ethtool_op_get_sg,
+	.set_sg 	= ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+        .get_tso        = ethtool_op_get_tso,
+        .set_tso        = ethtool_op_set_tso,
+#endif
+        .get_ufo 	= ethtool_op_get_ufo,
+        .set_ufo 	= ethtool_op_set_ufo,
+
+};
+
+
+/* ----------------------------------------------------------------------------
+		    		IOCTL SUPPORT
+   ---------------------------------------------------------------------------*/
+
+static int stmmaceth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+    struct eth_driver_local *lp = dev->priv;
+    int rc;
+    unsigned long flags;
+
+    /* SIOC[GS]MIIxxx ioctls */
+    spin_lock_irqsave(&lp->lock, flags);
+    rc = phy_mii_ioctl(lp->phydev, if_mii(rq), cmd);
+    spin_unlock_irqrestore(&lp->lock, flags);
+
+    return rc;
+}
+
+
+/* ----------------------------------------------------------------------------
+		    		VLAN SUPPORT
+   ---------------------------------------------------------------------------*/
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+static void stmmaceth_vlan_rx_register(struct net_device *dev,
+				    struct vlan_group *grp)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: setting vlgrp to %p\n", dev->name, grp);
+	lp->vlgrp = grp;
+	stmmaceth_set_rx_mode(dev);
+	spin_unlock(&lp->lock);
+}
+
+static void stmmaceth_vlan_rx_add_vid(struct net_device *dev,
+				       unsigned short vid)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: adding VLAN ID %d to VLAN filter\n",
+			  dev->name, vid);
+	stmmaceth_set_rx_mode(dev);
+	spin_unlock(&lp->lock);
+}
+
+static void stmmaceth_vlan_rx_kill_vid(struct net_device *dev,
+					unsigned short vid)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: removing VLAN ID %d from VLAN filter\n",
+			  dev->name, vid);
+	if (lp->vlgrp)
+		lp->vlgrp->vlan_devices[vid] = NULL;
+	stmmaceth_set_rx_mode(dev);
+	spin_unlock(&lp->lock);
+}
+#endif
+
+/* ----------------------------------------------------------------------------
+		   DEVICE REGISTRATION, INITIALIZATION AND UNLOADING
+   ---------------------------------------------------------------------------*/
+static int stmmaceth_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	int ret = 0;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ether_setup(dev);
+
+	dev->open = stmmaceth_open;
+	dev->stop = stmmaceth_release;
+	dev->set_config	= stmmaceth_config;
+
+	dev->hard_start_xmit = stmmaceth_xmit;
+	dev->features |= (NETIF_F_SG|NETIF_F_HW_CSUM|NETIF_F_HIGHDMA);
+
+	/*dev->features |= NETIF_F_TSO;*/
+
+	dev->get_stats = stmmaceth_stats;
+	dev->tx_timeout	= stmmaceth_tx_timeout;
+	dev->watchdog_timeo = msecs_to_jiffies(watchdog);;
+	dev->set_multicast_list	= stmmaceth_set_rx_mode,
+	dev->change_mtu	= stmmaceth_change_mtu;
+	dev->ethtool_ops = &stmmaceth_ethtool_ops;
+	dev->do_ioctl = &stmmaceth_ioctl;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = stmmaceth_poll_controller;
+#endif
+#ifdef CONFIG_STMMAC_NAPI
+	dev->poll = stmmaceth_poll;
+	dev->weight = CONFIG_DMA_RX_SIZE;
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
+	dev->vlan_rx_register = stmmaceth_vlan_rx_register;
+	dev->vlan_rx_add_vid  = stmmaceth_vlan_rx_add_vid;
+	dev->vlan_rx_kill_vid = stmmaceth_vlan_rx_kill_vid;
+#endif
+
+	lp->msg_enable = netif_msg_init(debug, default_msg_level);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	lp->ip_header_len = VLAN_ETH_HLEN;
+#else
+	lp->ip_header_len = ETH_HLEN;
+#endif
+	lp->rx_csum = 1;
+	tasklet_init(&lp->tx_task, stmmaceth_clean_tx_irq, (unsigned long)dev);
+	/* Check the module arguments */
+	stmmaceth_check_mod_params(dev);
+
+	/* Set the I/O base addr */
+	dev->base_addr = ioaddr;
+	printk(KERN_INFO "\tI/O base addr: 0x%lx\n", dev->base_addr);
+
+	/* Get the MAC address*/
+	printk(KERN_INFO "\tHW MAC address: ");
+	get_mac_address(ioaddr, dev->dev_addr);
+	print_mac_addr(dev->dev_addr);
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk (KERN_WARNING "\tno valid MAC address; "
+				    "please, set using ifconfig or nwhwconfig!\n");
+	}
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR "%s: ERROR %i registering the device\n",
+				__FUNCTION__, ret);
+		return (-ENODEV);
+	}
+
+	printk(KERN_DEBUG "Registered netdev %s ret = %d\n", dev->name, ret);
+	if (dev->reg_state == NETREG_REGISTERED){
+		printk(KERN_DEBUG "Netdev %s IS registered\n", dev->name);
+	}
+
+	/* Create and initialize the TX/RX descriptors rings */
+	init_dma_desc_rings(dev);
+
+	/* Intialize the DMA controller and send the SW reset */
+	if (stmmaceth_dma_init(dev) < 0 ) {
+		ETHPRINTK(probe, ERR, "%s: DMA initialization failed\n",
+				__FUNCTION__);
+		return (-1);
+	}
+
+	spin_lock_init(&lp->lock);
+
+	return (ret);
+}
+
+static int stmmaceth_dvr_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	unsigned int *addr = NULL;
+	struct net_device *ndev = NULL;
+	struct eth_driver_local *lp;
+	int phy_irq;
+	struct plat_stmmacenet_data *plat_dat;
+
+	printk(KERN_INFO "%s:\n\tplatform registration... ", __FUNCTION__);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto out;
+	}
+	printk(KERN_INFO "done!\n");
+
+	if (!request_mem_region(res->start, (res->end - res->start),
+				RESOURCE_NAME)) {
+		printk(KERN_ERR "%s: ERROR: memory allocation failed"
+				"cannot get the I/O addr 0x%x\n",
+				__FUNCTION__, (unsigned int)res->start);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	printk(KERN_INFO "\tmapping the I/O space (start=0x%x, size=0x%x)\n",
+			 (unsigned int)res->start,
+			 (unsigned int)(res->end - res->start));
+	addr = ioremap(res->start, (res->end - res->start));
+	if (!addr) {
+		printk(KERN_ERR "%s: ERROR: memory mapping failed \n",
+					__FUNCTION__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	printk(KERN_INFO "\tnetwork device initialization... ");
+	ndev = alloc_etherdev(sizeof(struct eth_driver_local));
+	if (!ndev ) {
+		printk(KERN_ERR "%s: ERROR: allocating the device\n",
+					__FUNCTION__);
+		ret = -ENOMEM;
+		goto out;
+	}
+	printk(KERN_INFO "done!\n");
+
+	/* Get the MAC information */
+	if ((ndev->irq = platform_get_irq_byname(pdev, "macirq")) == 0){
+		printk(KERN_ERR "%s: ERROR: MAC IRQ configuration "
+				"information not found\n",__FUNCTION__);
+		ret = -ENODEV;
+		goto out;
+	}
+	printk(KERN_INFO "\tMAC IRQ number: %d\n", ndev->irq);
+
+	lp = netdev_priv(ndev);
+	lp->device = &(pdev->dev);
+	plat_dat = (struct plat_stmmacenet_data *)((pdev->dev).platform_data);
+	lp->bus_id = plat_dat->bus_id;
+	lp->pbl = plat_dat->pbl;
+
+	platform_set_drvdata(pdev, ndev);
+
+	/* Network Device Registration */
+	ret = stmmaceth_probe(ndev, (unsigned long)addr);
+	if (ret < 0) {
+		goto out;
+	}
+	printk(KERN_INFO "\tnetwork device registration done (%d)\n", ret);
+
+	/* Get the PHY information */
+	if ((phy_irq = platform_get_irq_byname(pdev, "phyirq")) == 0){
+		printk(KERN_ERR "%s: ERROR: PHY IRQ configuration "
+				"information not found\n",__FUNCTION__);
+		ret = -ENODEV;
+		goto out;
+	}
+	printk(KERN_INFO "\tPHY IRQ number: %d\n", phy_irq);
+
+	lp->phy_irq = phy_irq;
+        if ((phy_n >=0) && (phy_n <= 31)) {
+		plat_dat->phy_addr = phy_n;
+        }
+	lp->phy_addr = plat_dat->phy_addr;
+	lp->phy_ignorezero = plat_dat->phy_ignorezero;
+
+	/* MDIO bus Registration */
+	printk(KERN_DEBUG "\tMDIO bus registration... ");
+	ret = stmmac_mdio_register(lp, ndev, (unsigned long)addr);
+	printk(KERN_DEBUG "done (returned %d)!\n", ret);
+
+	ndev = __dev_get_by_name("eth0");
+	printk(KERN_DEBUG "\tnetwork device name = %s\n", ndev->name);
+
+out:
+	if (ret < 0) {
+		platform_set_drvdata(pdev, NULL);
+		release_mem_region(res->start, (res->end - res->start));
+		if (addr != NULL)
+			iounmap(addr);
+	}
+
+	printk(KERN_DEBUG "\tplatform registration complete\n");
+	return (ret);
+}
+
+static int stmmaceth_dvr_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct eth_driver_local *lp = netdev_priv(ndev);
+	struct resource *res;
+
+	printk(KERN_INFO "%s:\n\tremoving driver", __FUNCTION__);
+
+	/* Reset the TX/RX processes */
+	stmmaceth_dma_stop_rx(ndev->base_addr);
+	stmmaceth_dma_stop_tx(ndev->base_addr);
+
+	/* Disable the MAC RX/TX */
+	stmmaceth_mac_disable_rx(ndev);
+	stmmaceth_mac_disable_tx(ndev);
+
+	/* Change the link status */
+	netif_carrier_off(ndev);
+
+	/* Free the DMA descriptor rings */
+	free_dma_desc_resources(ndev);
+
+	/* Unregister the MDIO bus */
+	stmmac_mdio_unregister(lp);
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(ndev);
+
+	iounmap((void *)ndev->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, (res->end - res->start));
+
+	free_netdev(ndev);
+
+	return (0);
+}
+
+static struct platform_driver stmmaceth_driver = {
+	.driver = {
+		.name           = RESOURCE_NAME,
+	},
+	.probe          = stmmaceth_dvr_probe,
+	.remove         = stmmaceth_dvr_remove,
+};
+
+static int __init stmmaceth_init_module(void)
+{
+	printk(KERN_DEBUG "%s: register the device driver\n", __FUNCTION__);
+	return platform_driver_register(&stmmaceth_driver);
+}
+
+static void __exit stmmaceth_cleanup_module(void)
+{
+	printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
+	platform_driver_unregister(&stmmaceth_driver);
+}
+
+/* --------------------------------------------------------------------------
+ * 		Parse the optional command line arguments
+ * --------------------------------------------------------------------------*/
+static int __init stmmaceth_cmdline_opt(char *str)
+{
+	char* opt;
+
+	printk(KERN_DEBUG "stmmaceth_cmdline_opt: \n");
+	if (!str || !*str)
+		return -EINVAL;
+
+	while ((opt=strsep(&str, ",")) != NULL) {
+		if (! strncmp(opt, "msglvl:", 7)) {
+			debug = simple_strtoul(opt+7, NULL, 0);
+		}
+		else if (! strncmp(opt, "phyaddr:", 8)) {
+			phy_n = simple_strtoul(opt+8, NULL, 0);
+		}
+		else if (! strncmp(opt, "watchdog:", 9)) {
+			 watchdog = simple_strtoul(opt+9, NULL, 0);
+		}
+		else if (! strncmp(opt, "pause:", 6)) {
+			 pause_time = simple_strtoul(opt+6, NULL, 0);
+		}
+		else if (! strncmp(opt, "rxsize:", 7)) {
+			 min_rx_pkt_size = simple_strtoul(opt+7, NULL, 0);
+		}
+	}
+	printk(KERN_DEBUG "\tdebug msg level = %d, phy_addr = %d\n"
+			  "\twatchdog = %d, pause_time = %d\n"
+			  "\trxsize = %d\n",
+			   debug, phy_n, watchdog, pause_time, min_rx_pkt_size);
+	return (0);
+}
+__setup("stmmaceth=", stmmaceth_cmdline_opt);
+
+module_init(stmmaceth_init_module);
+module_exit(stmmaceth_cleanup_module);
+
+MODULE_DESCRIPTION("STM MAC Ethernet driver");
+MODULE_AUTHOR("Giuseppe Cavallaro");
+MODULE_LICENSE("GPL");
Index: linux/drivers/net/stmmac.h
===================================================================
--- /dev/null
+++ linux/drivers/net/stmmac.h
@@ -0,0 +1,212 @@
+
+/*----------------------------------------------------------------------------
+ *	 			MAC BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* MAC CSR offset */
+#define MAC_CONTROL               0x00000000  /* MAC Control */
+#define MAC_ADDR_HIGH             0x00000004  /* MAC Address High */
+#define MAC_ADDR_LOW              0x00000008  /* MAC Address Low */
+#define MAC_HASH_HIGH             0x0000000c  /* Multicast Hash Table High */
+#define MAC_HASH_LOW              0x00000010  /* Multicast Hash Table Low */
+#define MAC_MII_ADDR              0x00000014  /* MII Address */
+#define MAC_MII_DATA              0x00000018  /* MII Data */
+#define MAC_FLOW_CONTROL          0x0000001c  /* Flow Control */
+#define MAC_VLAN1                 0x00000020  /* VLAN1 Tag */
+#define MAC_VLAN2                 0x00000024  /* VLAN2 Tag */
+#define MAC_WAKEUP_FILTER         0x00000028  /* Wake-up Frame Filter */
+#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c  /* Wake-up Control And Status */
+
+/* MAC CTRL defines */
+#define MAC_CONTROL_RA            0x80000000  /* Receive All Mode */
+#define MAC_CONTROL_BLE           0x40000000  /* Endian Mode */
+#define MAC_CONTROL_HBD           0x10000000  /* Heartbeat Disable */
+#define MAC_CONTROL_PS            0x08000000  /* Port Select */
+#define MAC_CONTROL_DRO           0x00800000  /* Disable Receive Own */
+#define MAC_CONTROL_EXT_LOOPBACK  0x00400000  /* Reserved (ext loopback?) */
+#define MAC_CONTROL_OM            0x00200000  /* Loopback Operating Mode */
+#define MAC_CONTROL_F             0x00100000  /* Full Duplex Mode */
+#define MAC_CONTROL_PM            0x00080000  /* Pass All Multicast */
+#define MAC_CONTROL_PR            0x00040000  /* Promiscuous Mode */
+#define MAC_CONTROL_IF            0x00020000  /* Inverse Filtering */
+#define MAC_CONTROL_PB            0x00010000  /* Pass Bad Frames */
+#define MAC_CONTROL_HO            0x00008000  /* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP            0x00002000  /* Hash/Perfect Filtering Mode */
+#define MAC_CONTROL_LCC           0x00001000  /* Late Collision Control */
+#define MAC_CONTROL_DBF           0x00000800  /* Disable Broadcast Frames */
+#define MAC_CONTROL_DRTY          0x00000400  /* Disable Retry */
+#define MAC_CONTROL_ASTP          0x00000100  /* Automatic Pad Stripping */
+#define MAC_CONTROL_BOLMT_10      0x00000000  /* Back Off Limit 10 */
+#define MAC_CONTROL_BOLMT_8       0x00000040  /* Back Off Limit 8 */
+#define MAC_CONTROL_BOLMT_4       0x00000080  /* Back Off Limit 4 */
+#define MAC_CONTROL_BOLMT_1       0x000000c0  /* Back Off Limit 1 */
+#define MAC_CONTROL_DC            0x00000020  /* Deferral Check */
+#define MAC_CONTROL_TE            0x00000008  /* Transmitter Enable */
+#define MAC_CONTROL_RE            0x00000004  /* Receiver Enable */
+
+/* MAC FLOW CTRL defines */
+#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000  /* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT 16
+#define MAC_FLOW_CONTROL_PCF      0x00000004  /* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE      0x00000002  /* Flow Control Enable */
+#define MAC_FLOW_CONTROL_PAUSE    0x00000001  /* Flow Control Busy ... */
+
+/* MII ADDR  defines */
+#define MAC_MII_ADDR_WRITE        0x00000002  /* MII Write */
+#define MAC_MII_ADDR_BUSY         0x00000001  /* MII Busy */
+
+/* MAC Management Counters register */
+#define MMC_CONTROL               0x00000100  /* MMC Control */
+#define MMC_HIGH_INTR             0x00000104  /* MMC High Interrupt */
+#define MMC_LOW_INTR              0x00000108  /* MMC Low Interrupt */
+#define MMC_HIGH_INTR_MASK        0x0000010c  /* MMC High Interrupt Mask */
+#define MMC_LOW_INTR_MASK         0x00000110  /* MMC Low Interrupt Mask */
+
+#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8   /* Maximum Frame Size */
+#define MMC_CONTROL_MAX_FRM_SHIFT 3
+#define MMC_CONTROL_MAX_FRAME 	  0x7FF
+
+/*----------------------------------------------------------------------------
+ * 				DMA BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* DMA CRS Control and Status Register Mapping */
+#define DMA_BUS_MODE              0x00001000  /* Bus Mode */
+#define DMA_XMT_POLL_DEMAND       0x00001004  /* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND       0x00001008  /* Received Poll Demand */
+#define DMA_RCV_BASE_ADDR         0x0000100c  /* Receive List Base */
+#define DMA_TX_BASE_ADDR          0x00001010  /* Transmit List Base */
+#define DMA_STATUS                0x00001014  /* Status Register */
+#define DMA_CONTROL               0x00001018  /* Control (Operational Mode) */
+#define DMA_INTR_ENA              0x0000101c  /* Interrupt Enable */
+#define DMA_MISSED_FRAME_CTR      0x00001020  /* Missed Frame Counter */
+#define DMA_CUR_TX_BUF_ADDR       0x00001050  /* Current Host Transmit Buffer */
+#define DMA_CUR_RX_BUF_ADDR       0x00001054  /* Current Host Receive Buffer */
+
+/*  DMA Bus Mode register defines */
+#define DMA_BUS_MODE_DBO          0x00100000  /* Descriptor Byte Ordering */
+#define DMA_BUS_MODE_PBL_MASK     0x00003f00  /* Programmable Burst Length */
+#define DMA_BUS_MODE_PBL_SHIFT    8
+#define DMA_BUS_MODE_BLE          0x00000080  /* Big Endian/Little Endian */
+#define DMA_BUS_MODE_DSL_MASK     0x0000007c  /* Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT    2           /*       (in DWORDS)      */
+#define DMA_BUS_MODE_BAR_BUS      0x00000002  /* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET    0x00000001  /* Software Reset */
+#define DMA_BUS_MODE_DEFAULT      0x00000000
+
+/* DMA Status register defines */
+#define DMA_STATUS_EB_MASK        0x00380000  /* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT    0x00080000  /* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT    0x00100000  /* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK        0x00700000  /* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT       20
+#define DMA_STATUS_RS_MASK        0x000e0000  /* Receive Process State */
+#define DMA_STATUS_RS_SHIFT       17
+#define DMA_STATUS_NIS            0x00010000  /* Normal Interrupt Summary */
+#define DMA_STATUS_AIS            0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI            0x00004000  /* Early Receive Interrupt */
+#define DMA_STATUS_FBI            0x00002000  /* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI            0x00000400  /* Early Transmit Interrupt */
+#define DMA_STATUS_RWT            0x00000200  /* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS            0x00000100  /* Receive Process Stopped */
+#define DMA_STATUS_RU             0x00000080  /* Receive Buffer Unavailable */
+#define DMA_STATUS_RI             0x00000040  /* Receive Interrupt */
+#define DMA_STATUS_UNF            0x00000020  /* Transmit Underflow */
+#define DMA_STATUS_OVF            0x00000010  /* Receive Overflow */
+#define DMA_STATUS_TJT            0x00000008  /* Transmit Jabber Timeout */
+#define DMA_STATUS_TU             0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS            0x00000002  /* Transmit Process Stopped */
+#define DMA_STATUS_TI             0x00000001  /* Transmit Interrupt */
+
+/* DMA Control register defines */
+#define DMA_CONTROL_SF            0x00200000  /* Store And Forward */
+#define DMA_CONTROL_TTC_MASK      0x0001c000  /* Transmit Threshold Control */
+#define DMA_CONTROL_TTC_32        0x00000000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_64        0x00004000  /* Threshold is 64 DWORDS */
+#define DMA_CONTROL_TTC_128       0x00008000  /* Threshold is 128 DWORDS */
+#define DMA_CONTROL_TTC_256       0x0000c000  /* Threshold is 256 DWORDS */
+#define DMA_CONTROL_TTC_18        0x00010000  /* Threshold is 18 DWORDS */
+#define DMA_CONTROL_TTC_24        0x00014000  /* Threshold is 24 DWORDS */
+#define DMA_CONTROL_TTC__32_      0x00018000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_40        0x0001c000  /* Threshold is 40 DWORDS */
+#define DMA_CONTROL_ST            0x00002000  /* Start/Stop Transmission */
+#define DMA_CONTROL_SE            0x00000008  /* Stop On Empty */
+#define DMA_CONTROL_OSF           0x00000004  /* Operate On 2nd Frame */
+#define DMA_CONTROL_SR            0x00000002  /* Start/Stop Receive */
+
+/* DMA Interrupt Enable register defines */
+#define DMA_INTR_ENA_NIE          0x00010000  /* Normal Interrupt Summary */
+#define DMA_INTR_ENA_AIE          0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_INTR_ENA_ERE          0x00004000  /* Early Receive */
+#define DMA_INTR_ENA_FBE          0x00002000  /* Fatal Bus Error */
+#define DMA_INTR_ENA_ETE          0x00000400  /* Early Transmit */
+#define DMA_INTR_ENA_RWE          0x00000200  /* Receive Watchdog */
+#define DMA_INTR_ENA_RSE          0x00000100  /* Receive Stopped */
+#define DMA_INTR_ENA_RUE          0x00000080  /* Receive Buffer Unavailable */
+#define DMA_INTR_ENA_RIE          0x00000040  /* Receive Interrupt */
+#define DMA_INTR_ENA_UNE          0x00000020  /* Underflow */
+#define DMA_INTR_ENA_OVE          0x00000010  /* Receive Overflow */
+#define DMA_INTR_ENA_TJE          0x00000008  /* Transmit Jabber */
+#define DMA_INTR_ENA_TUE          0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_INTR_ENA_TSE          0x00000002  /* Transmit Stopped */
+#define DMA_INTR_ENA_TIE          0x00000001  /* Transmit Interrupt */
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_RIE | \
+				DMA_INTR_ENA_TIE)
+/* STMAC110 DMA Missed Frame Counter register defines */
+#define DMA_MISSED_FRAME_OVE      0x10000000  /* FIFO Overflow Overflow */
+#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000  /* Overflow Frame Counter */
+#define DMA_MISSED_FRAME_OVE_M    0x00010000  /* Missed Frame Overflow */
+#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff  /* Missed Frame Couinter */
+
+/*----------------------------------------------------------------------------
+ * 		    	    Descriptor defines
+ *---------------------------------------------------------------------------*/
+/* Common fields */
+#define OWN_BIT			0x80000000  /* Own Bit (owned by hardware) */
+#define DES1_CONTROL_CH		0x01000000  /* Second Address Chained */
+#define DES1_CONTROL_TER	0x02000000  /* End of Ring */
+#define DES1_RBS2_SIZE_MASK	0x003ff800  /* Buffer 2 Size Mask */
+#define DES1_RBS2_SIZE_SHIFT	11          /* Buffer 2 Size Shift */
+#define DES1_RBS1_SIZE_MASK	0x000007ff  /* Buffer 1 Size Mask */
+#define DES1_RBS1_SIZE_SHIFT	0           /* Buffer 1 Size Shift */
+
+/* Receive Descriptor */
+#define RDES0_STATUS_FILTER_FAIL  0x40000000  /* Filtering Fail */
+#define RDES0_STATUS_FL_MASK      0x3fff0000  /* Frame Length Mask */
+#define RDES0_STATUS_FL_SHIFT     16          /* Frame Length Shift */
+#define RDES0_STATUS_ES           0x00008000  /* Error Summary */
+#define RDES0_STATUS_DE           0x00004000  /* Descriptor Error */
+#define RDES0_STATUS_PFE          0x00002000  /* Partial Frame Error */
+#define RDES0_STATUS_LENGTH_ERROR 0x00001000  /* Length Error */
+#define RDES0_STATUS_RUNT_FRM     0x00000800  /* Runt Frame */
+#define RDES0_STATUS_MULTICST_FRM 0x00000400  /* Multicast Frame */
+#define RDES0_STATUS_FS           0x00000200  /* First Descriptor */
+#define RDES0_STATUS_LS           0x00000100  /* Last Descriptor */
+#define RDES0_STATUS_TL           0x00000080  /* Frame Too Long */
+#define RDES0_STATUS_COL_SEEN     0x00000040  /* Collision Seen */
+#define RDES0_STATUS_FRM_TYPE     0x00000020  /* Frame Type */
+#define RDES0_STATUS_RX_WATCHDOG  0x00000010  /* Receive Watchdog */
+#define RDES0_STATUS_MII_ERR      0x00000008  /* Report on MII Error */
+#define RDES0_STATUS_DRIBBLE      0x00000004  /* Dribbling Bit */
+#define RDES0_STATUS_CE           0x00000002  /* CRC Error */
+#define RDES0_STATUS_0            0x00000000  /* Always tied to zero */
+
+#define RDES1_CONTROL_DIOC        0x80000000  /* Disable Intr On Completion */
+
+/* Transmit Descriptor */
+#define TDES0_STATUS_ES		  0x00008000  /* Error Summary */
+#define TDES0_STATUS_LOSS_CARRIER 0x00000800  /* Loss of Carrier */
+#define TDES0_STATUS_NO_CARRIER   0x00000400  /* No Carrier */
+#define TDES0_STATUS_LATE_COL     0x00000200  /* Late Collision */
+#define TDES0_STATUS_EX_COL       0x00000100  /* Excessive Collisions */
+#define TDES0_STATUS_HRTBT_FAIL   0x00000080  /* Heartbeat Fail */
+#define TDES0_STATUS_COLCNT_MASK  0x00000078  /* Collision Count Mask */
+#define TDES0_STATUS_COLCNT_SHIFT 3           /* Collision Count Shift */
+#define TDES0_STATUS_EX_DEF       0x00000004  /* Excessive Deferrals */
+#define TDES0_STATUS_UF           0x00000002  /* Underflow Error */
+#define TDES0_STATUS_DF           0x00000001  /* Deferred */
+
+#define TDES1_CONTROL_IC          0x80000000  /* Interrupt on Completion */
+#define TDES1_CONTROL_LS          0x40000000  /* Last Segment */
+#define TDES1_CONTROL_FS          0x20000000  /* First Segment */
+#define TDES1_CONTROL_AC          0x04000000  /* Add CRC Disable */
+#define TDES1_CONTROL_DPD         0x00800000  /* Disable Padding */
Index: linux/include/linux/phy.h
===================================================================
--- linux.orig/include/linux/phy.h
+++ linux/include/linux/phy.h
@@ -350,7 +350,7 @@ void phy_start(struct phy_device *phydev
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
 
-int mdiobus_register(struct mii_bus *bus);
+int mdiobus_register(struct mii_bus *bus, int ignorezero);
 void mdiobus_unregister(struct mii_bus *bus);
 void phy_sanitize_settings(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
Index: linux/include/linux/st_soc.h
===================================================================
--- linux.orig/include/linux/st_soc.h
+++ linux/include/linux/st_soc.h
@@ -97,6 +97,15 @@ struct plat_stm_pwm_data {
 #define PLAT_STM_PWM_OUT0	(1<<0)
 #define PLAT_STM_PWM_OUT1	(1<<1)
 
+/* Private data for the STM on-board ethernet driver */
+struct plat_stmmacenet_data {
+	int bus_id;
+	int phy_addr;
+	int phy_ignorezero;
+	char *phy_name;
+	int pbl;
+};
+
 #endif /* __LINUX_ST_SOC_H */
 
 
Index: linux/arch/sh/boards/st/stb7109eref/setup.c
===================================================================
--- linux.orig/arch/sh/boards/st/stb7109eref/setup.c
+++ linux/arch/sh/boards/st/stb7109eref/setup.c
@@ -25,7 +25,7 @@
 #define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
 #define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
 
-#ifdef CONFIG_STB7109_ETH
+#ifdef CONFIG_STMMAC_ETH
 #define MAC_SPEED_SEL	    0x00100000 /* MAC is running at 100 Mbps speed */
 #define PHY_CLK_EXT	    0x00080000 /* PHY clock is external (RMII mode)*/
 #define MII_MODE	    0x00040000 /* RMII interface activated */
@@ -41,11 +41,14 @@ static void stb7109eth_hw_setup(void)
 	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
 	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
 
-#ifdef CONFIG_STE101P_RMII
+#ifdef CONFIG_PHY_RMII
 	sysconf |= MII_MODE; /* RMII selected*/
 #else
 	sysconf &= ~MII_MODE; /* MII selected */
 #endif
+#ifdef CONFIG_STMMAC_EXT_CLK
+        sysconf |= PHY_CLK_EXT;
+#endif
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 
 	/* STe101P: enable the external interrupts */
@@ -54,7 +57,11 @@ static void stb7109eth_hw_setup(void)
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
 
        /* Configure e/net PHY clock */
+#ifndef CONFIG_STMMAC_EXT_CLK
 	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
+#else
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_IN);
+#endif
 
 	return;
 }
@@ -211,19 +218,6 @@ static struct resource smc91x_resources[
 	},
 };
 
-static struct resource stb7109eth_resources[] = {
-        [0] = {
-                .start = 0x18110000,
-                .end   = 0x1811ffff,
-                .flags  = IORESOURCE_MEM,
-        },
-        [1] = {
-                .start  = 133,
-                .end    = 133,
-                .flags  = IORESOURCE_IRQ,
-        },
-};
-
 static struct resource st40_ohci_resources[] = {
 	/*this lot for the ohci block*/
 	[0] = {
@@ -315,13 +309,43 @@ static struct platform_device smc91x_dev
 	.resource	= smc91x_resources,
 };
 
+static struct plat_stmmacenet_data eth7109_private_data = {
+	.bus_id = 0,
+	.phy_addr = 14,
+	.phy_ignorezero = 1,
+	.phy_name = "ste100p",
+	.pbl = 1,
+};
+
 static struct platform_device stb7109eth_device = {
-        .name           = "stb7109eth",
-        .id             = 0,
-        .num_resources  = ARRAY_SIZE(stb7109eth_resources),
-        .resource       = stb7109eth_resources,
+	.name           = "stmmaceth",
+	.id             = 0,
+	.num_resources  = 3,
+	.resource       = (struct resource[]) {
+		{
+	                .start = 0x18110000,
+		        .end   = 0x1811ffff,
+	        	.flags  = IORESOURCE_MEM,
+		},
+		{
+			.name   = "macirq",
+	        	.start  = 133,
+	        	.end    = 133,
+	        	.flags  = IORESOURCE_IRQ,
+		},
+		{
+			.name   = "phyirq",
+	        	.start  = IRL3_IRQ,
+	        	.end    = IRL3_IRQ,
+	        	.flags  = IORESOURCE_IRQ,
+		},
+	},
+	.dev = {
+		.platform_data = &eth7109_private_data,
+	}
 };
 
+
 static struct resource ste101p_resources[] = {
         [0] = {
                 .flags  = IORESOURCE_DISABLED,
Index: linux/arch/sh/boards/st/stb7100mboard/mach.c
===================================================================
--- linux.orig/arch/sh/boards/st/stb7100mboard/mach.c
+++ linux/arch/sh/boards/st/stb7100mboard/mach.c
@@ -57,7 +57,7 @@ static void __init stb7100mboard_init_ir
 	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
 
         /* Route e/net PHY interrupt to SH4 - only for STb7109 */
-#ifdef CONFIG_STB7109_ETH
+#ifdef CONFIG_STMMAC_ETH
         /* Note that we invert the signal - the ste101p is connected
            to the mb411 as active low. The sh4 INTC expects active high */
         ilc_route_external(70, 7, 1);
Index: linux/drivers/net/phy/Makefile
===================================================================
--- linux.orig/drivers/net/phy/Makefile
+++ linux/drivers/net/phy/Makefile
@@ -8,4 +8,5 @@ obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 obj-$(CONFIG_LXT_PHY)		+= lxt.o
 obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
-obj-$(CONFIG_STE101P)		+= ste101p.o
+obj-$(CONFIG_STE10XP)		+= ste10Xp.o
+obj-$(CONFIG_LAN8700)           += smsc8700.o
