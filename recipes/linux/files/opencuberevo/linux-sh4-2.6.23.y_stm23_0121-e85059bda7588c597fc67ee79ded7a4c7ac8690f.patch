From e85059bda7588c597fc67ee79ded7a4c7ac8690f Mon Sep 17 00:00:00 2001
From: Francesco VIRLINZI <francesco.virlinzi@st.com>
Date: Wed, 22 Jul 2009 08:45:09 +0200
Subject: [PATCH] stm: clk: LLA clock code for stx7141

This patch applies the LLA clock code from Validation Team.
Reference: clk_lla_17jul09
Moreover it:
 - removes all the OS21 code
 - applies the GPL2 license

Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
---
 arch/sh/kernel/cpu/sh4/clock-regs-stx7141.h |  217 +++
 arch/sh/kernel/cpu/sh4/clock-stx7141.c      | 2099 +++++++++++++++++++++++----
 arch/sh/kernel/cpu/sh4/clock-stx7141.h      |   87 ++
 3 files changed, 2096 insertions(+), 307 deletions(-)
 create mode 100644 arch/sh/kernel/cpu/sh4/clock-regs-stx7141.h
 mode change 100644 => 100755 arch/sh/kernel/cpu/sh4/clock-stx7141.c
 create mode 100644 arch/sh/kernel/cpu/sh4/clock-stx7141.h

diff --git a/arch/sh/kernel/cpu/sh4/clock-regs-stx7141.h b/arch/sh/kernel/cpu/sh4/clock-regs-stx7141.h
new file mode 100644
index 0000000..1c89b89
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh4/clock-regs-stx7141.h
@@ -0,0 +1,217 @@
+/******************************************************************************
+ *
+ * File name   : clock-regs-stx7141.h
+ * Description : Low Level API - Base addresses & register definitions.
+ *
+ * COPYRIGHT (C) 2009 STMicroelectronics - All Rights Reserved
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+******************************************************************************/
+
+
+#ifndef __CLOCK_LLA_7141REGS_H
+#define __CLOCK_LLA_7141REGS_H
+
+
+#define CKGA_BASE_ADDRESS	       0xfe213000
+#define CKGB_BASE_ADDRESS	       0xfe000000
+#define CKGC_BASE_ADDRESS	       0xfe210000
+#define SYSCFG_BASE_ADDRESS	     0xfe001000
+#define PIO5_BASE_ADDRESS	       0xfd025000
+
+#define PIO_BASE_ADDRESS(bank)	  0xfd025000
+
+
+#define DEVICE_ID	       0x000
+#define EXTRA_DEVICE_ID	 0x004
+#define SYSTEM_STATUS0	  0x008
+#define SYSTEM_STATUS(x)	(SYSTEM_STATUS0 + (x) * 4)
+
+#define SYSTEM_CONFIG0	  0x100
+#define SYSTEM_CONFIG(x)	(SYSTEM_CONFIG0 + (x) * 4)
+
+/*
+    INTPRI00 - Interrupt Priority Level (Read/Write)
+    ==============================================================
+    bit [J*4, (J*4)+3] = IP[J] with 0<=J<=7: Specifies the priority level for
+					interrupts beloiging
+					     to priority group J.
+					     (0 => Interrupt are masked,
+					      1..15 => Set priority level)
+
+    INTREQ00 - Interrupt Request Level (Read-only)
+    ============================================================
+    bit J = IR[J] with 0<=J<=31: Indicates the request level of the interrupt
+				associated with bit J.
+				 (1 => Interrupt is being asserted,
+				  0 => Interrupt is not being asserted)
+
+    INTMSK00 - Interrupt Mask (Read/Write)
+    ====================================================
+    bit J = IM[J] with 0<=J<=31: Specifies wether the interrupt associated with
+				bit J is masked.
+				 (1 => Interrupt is masked, 0 => Ignored)
+
+
+    INTMSKCLR00  - Interrupt Mask Clear (Write-only)
+    =============================================================
+    bit J = IMC[J] with 0<=J<=31: Specifies wether the interrupt mask
+				associated with bit J is cleared.
+				  (1 => Unmask the interrupt. I.e. clear the
+				corrispondending bit in INTMSK00,
+				   0 => Ignored)
+
+    INTC2MODE  - INTC2 Mode (Read/Write)
+    =============================================================
+    bit 0 = INTC2 MODE: Specifies wether the most significant bit of the INTEVT
+			code is masked out.
+			(1 = The INTEVT code are AND-ed with 0x7FF before being
+			passes to the CPU,
+			 0 = The INTEVT code is unmodified)
+    bit 31:1 = Reserved
+*/
+
+#define INTC2_PRIORITY00	0x300
+#define INTC2_PRIORITY04	0x304
+#define INTC2_PRIORITY08	0x308
+
+#define INTC2_REQUEST00	 0x320
+#define INTC2_REQUEST04	 0x324
+#define INTC2_REQUEST08	 0x328
+
+#define INTC2_MASK00	    0x340
+#define INTC2_MASK04	    0x344
+#define INTC2_MASK08	    0x348
+
+#define INTC2_MASK_CLEAR00      0x360
+#define INTC2_MASK_CLEAR04      0x364
+#define INTC2_MASK_CLEAR08      0x368
+
+#define INTC2_MODE	      0x380
+
+/* --- CKGA registers ( hardware specific ) --------------------------------- */
+#define CKGA_PLL0_CFG		 0x000
+#define CKGA_PLL1_CFG		 0x004
+#define CKGA_POWER_CFG		0x010
+#define CKGA_CLKOPSRC_SWITCH_CFG      0x014
+#define CKGA_OSC_ENABLE_FB	    0x018
+#define CKGA_PLL0_ENABLE_FB	   0x01c
+#define CKGA_PLL1_ENABLE_FB	   0x020
+#define CKGA_CLKOPSRC_SWITCH_CFG2     0x024
+
+#define CKGA_CLKOBS_MUX1_CFG	  0x030
+#define CKGA_CLKOBS_MASTER_MAXCOUNT   0x034
+#define CKGA_CLKOBS_CMD	       0x038
+#define CKGA_CLKOBS_STATUS	    0x03c
+#define CKGA_CLKOBS_SLAVE0_COUNT      0x040
+#define CKGA_OSCMUX_DEBUG	     0x044
+/*#define CKGA_CLKOBS_MUX2_CFG	  0x048*/
+#define CKGA_LOW_POWER_CTRL	   0x04C
+
+#define CKGA_OSC_DIV0_CFG	     0x800
+#define CKGA_OSC_DIV_CFG(x)		(CKGA_OSC_DIV0_CFG + (x) * 4)
+
+#define CKGA_PLL0HS_DIV0_CFG	  0x900
+#define CKGA_PLL0HS_DIV_CFG(x)		(CKGA_PLL0HS_DIV0_CFG + (x) * 4)
+
+#define CKGA_PLL0LS_DIV0_CFG	  0xA00
+#define CKGA_PLL0LS_DIV_CFG(x)		(CKGA_PLL0LS_DIV0_CFG + (x) * 4)
+
+#define CKGA_PLL1_DIV0_CFG	    0xB00
+#define CKGA_PLL1_DIV_CFG(x)		(CKGA_PLL1_DIV0_CFG + (x) * 4)
+
+/* Clockgen B registers */
+#define CKGB_LOCK	       0x010
+#define CKGB_FS0_CTRL	   0x014
+#define CKGB_FS0_MD1	    0x018
+#define CKGB_FS0_PE1	    0x01c
+#define CKGB_FS0_EN_PRG1	0x020
+#define CKGB_FS0_SDIV1	  0x024
+#define CKGB_FS0_MD2	    0x028
+#define CKGB_FS0_PE2	    0x02c
+#define CKGB_FS0_EN_PRG2	0x030
+#define CKGB_FS0_SDIV2	  0x034
+#define CKGB_FS0_MD3	    0x038
+#define CKGB_FS0_PE3	    0x03c
+#define CKGB_FS0_EN_PRG3	0x040
+#define CKGB_FS0_SDIV3	  0x044
+#define CKGB_FS0_MD4	    0x048
+#define CKGB_FS0_PE4	    0x04c
+#define CKGB_FS0_EN_PRG4	0x050
+#define CKGB_FS0_SDIV4	  0x054
+#define CKGB_FS0_CLKOUT_CTRL    0x058
+#define CKGB_FS1_CTRL	   0x05c
+#define CKGB_FS1_MD1	    0x060
+#define CKGB_FS1_PE1	    0x064
+#define CKGB_FS1_EN_PRG1	0x068
+#define CKGB_FS1_SDIV1	  0x06c
+#define CKGB_FS1_MD2	    0x070
+#define CKGB_FS1_PE2	    0x074
+#define CKGB_FS1_EN_PRG2	0x078
+#define CKGB_FS1_SDIV2	  0x07c
+#define CKGB_FS1_MD3	    0x080
+#define CKGB_FS1_PE3	    0x084
+#define CKGB_FS1_EN_PRG3	0x088
+#define CKGB_FS1_SDIV3	  0x08c
+#define CKGB_FS1_MD4	    0x090
+#define CKGB_FS1_PE4	    0x094
+#define CKGB_FS1_EN_PRG4	0x098
+#define CKGB_FS1_SDIV4	  0x09c
+#define CKGB_FS1_CLKOUT_CTRL    0x0a0
+#define CKGB_DISPLAY_CFG	0x0a4
+#define CKGB_FS_SELECT	  0x0a8
+#define CKGB_POWER_DOWN	 0x0ac
+#define CKGB_POWER_ENABLE       0x0b0
+#define CKGB_OUT_CTRL	   0x0b4
+#define CKGB_CRISTAL_SEL	0x0b8
+
+/* Clock recovery registers */
+#define CKGB_RECOV_REF_MAX      0x000
+#define CKGB_RECOV_CMD	  0x004
+#define CKGB_RECOV_CPT_PCM      0x008
+#define CKGB_RECOV_CPT_HD       0x00c
+
+
+
+#define CKGC_FS0_CFG	0x000
+
+#define CKGC_FS0_MD1	0x010
+#define CKGC_FS0_PE1	0x014
+#define CKGC_FS0_SDIV1      0x018
+#define CKGC_FS0_EN_PRG1    0x01c
+
+#define CKGC_FS0_MD2	0x020
+#define CKGC_FS0_PE2	0x024
+#define CKGC_FS0_SDIV2      0x028
+#define CKGC_FS0_EN_PRG2    0x02c
+
+#define CKGC_FS0_MD3	0x030
+#define CKGC_FS0_PE3	0x034
+#define CKGC_FS0_SDIV3      0x038
+#define CKGC_FS0_EN_PRG3    0x03c
+
+#define CKGC_FS0_MD4	0x040
+#define CKGC_FS0_PE4	0x044
+#define CKGC_FS0_SDIV4      0x048
+#define CKGC_FS0_EN_PRG4    0x04c
+
+#define DAC_CFG_ADD_SIG     0x100
+#define IOCTL_CFG_ADD       0x200
+
+#define HDMI_AUDIO_CFG 0x204
+
+
+
+/* --- PIO registers (  ) ------------------------------- */
+#define	 PIO_CLEAR_PnC0		0x28
+#define	 PIO_CLEAR_PnC1		0x38
+#define	 PIO_CLEAR_PnC2		0x48
+#define	 PIO_PnC0		      0x20
+#define	 PIO_PnC1		      0x30
+#define	 PIO_PnC2		      0x40
+#define	 PIO_SET_PnC0		  0x24
+#define	 PIO_SET_PnC1		  0x34
+#define	 PIO_SET_PnC2		  0x44
+
+#endif  /* End __CLOCK_LLA_7141REGS_H */
+
diff --git a/arch/sh/kernel/cpu/sh4/clock-stx7141.c b/arch/sh/kernel/cpu/sh4/clock-stx7141.c
old mode 100644
new mode 100755
index 92f98f0..eceb4e2
--- a/arch/sh/kernel/cpu/sh4/clock-stx7141.c
+++ b/arch/sh/kernel/cpu/sh4/clock-stx7141.c
@@ -1,424 +1,1909 @@
-/*
- * Copyright (C) 2008 STMicroelectronics Limited
+/*************************************************************************
+ * CLOCK driver
+ * Low Level API - 7141 specific implementation
+ *************************************************************************
+ *************************************************************************
+ *
+ * File name   :clock-stx7141.c
  *
+ * Description :low level api for 7141 specific implementation
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
- * Code to handle the clockgen hardware on the STx7141.
- */
+ ************************************************************************/
+
+/* ----- Modification history (most recent first)----
+ - 10 July 2009 - Review by Francesco Virlinzi
+   - applyed all the LLA rules
+   - Linux compliant
+
+ -  8 July 2009 - First Draft - ...
+ *****************/
 
-#include <linux/init.h>
-#include <linux/kernel.h>
 #include <linux/stm/sysconf.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
 #include <linux/io.h>
-#include <linux/pm.h>
 #include <asm/clock.h>
-#include <asm/freq.h>
-
-#include "./soc-stx7141.h"
-#include "./clock-common.h"
-
-/*#define _CLK_DEBUG*/
-#ifdef _CLK_DEBUG
-#include <linux/stm/pio.h>
-#define dgb_print(fmt, args...)			\
-			printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
-#else
-#define dgb_print(fmt, args...)
-#endif
-
-/* Definitions taken from targetpack sti7141_clockgena_regs.xml */
-#define CKGA_PLL0_CFG			0x000
-#define CKGA_PLL1_CFG			0x004
-#define CKGA_POWER_CFG			0x010
-/*#define CKGA_CLKOPSRC_SWITCH_CFG(x)	(0x014+((x)*0x10))*/
-#define CKGA_CLKOBS_MUX1_CFG		0x030
-#define CKGA_CLKOBS_MUX2_CFG		0x048
-/* All the following appear to be offsets into clkgen B, despite the name */
-/*#define CKGA_OSC_DIV_CFG(x)		(0x800+((x)*4))			*/
-/*#define CKGA_PLL0HS_DIV_CFG(x)		(0x900+((x)*4))		*/
-/*#define CKGA_PLL0LS_DIV_CFG(x)		(0xa10+(((x)-4)*4))	*/
-/*#define CKGA_PLL1_DIV_CFG(x)		(0xb00+((x)*4))			*/
-
-static unsigned long clkin[2] = {
-	SYSCLKIN,	/* clk_osc_a */
-	SYSCLKINALT,	/* clk_osc_b */
+#include "clock-regs-stx7141.h"
+#include "clock-stx7141.h"
+
+#include "clock-oslayer.h"
+#include "clock-common.h"
+
+static int clkgena_observe(clk_t *clk_p, unsigned long *div_p);
+static int clkgenb_observe(clk_t *clk_p, unsigned long *div_p);
+static int clkgena_set_parent(clk_t *clk_p, clk_t *src_p);
+static int clkgenb_set_parent(clk_t *clk_p, clk_t *src_p);
+static int clkgenc_set_parent(clk_t *clk_p, clk_t *src_p);
+static int clkgend_set_parent(clk_t *clk_p, clk_t *src_p);
+static int clkgene_set_parent(clk_t *clk_p, clk_t *src_p);
+static int clkgena_set_freq(clk_t *clk_p, U32 freq);
+static int clkgenb_set_freq(clk_t *clk_p, U32 freq);
+static int clkgena_set_div(clk_t *clk_p, U32 *div_p);
+static int clkgenb_set_div(clk_t *clk_p, U32 *div_p);
+static int clkgenb_set_fsclock(clk_t *clk_p, U32 freq);
+static int clkgena_recalc(clk_t *clk_p);
+static int clkgenb_recalc(clk_t *clk_p);
+static int clkgenc_recalc(clk_t *clk_p);
+static int clkgend_recalc(clk_t *clk_p);
+static int clkgene_recalc(clk_t *clk_p);	/* Added to get infos for USB */
+static int clkgena_enable(clk_t *clk_p);
+static int clkgenb_enable(clk_t *clk_p);
+static int clkgenc_enable(clk_t *clk_p);
+static int clkgena_disable(clk_t *clk_p);
+static int clkgenb_disable(clk_t *clk_p);
+static int clkgenc_disable(clk_t *clk_p);
+static unsigned long clkgena_get_measure(clk_t *clk_p);
+static int clktop_init(clk_t *clk_p);
+static int clkgena_init(clk_t *clk_p);
+static int clkgenb_init(clk_t *clk_p);
+static int clkgenc_init(clk_t *clk_p);
+static int clkgenc_set_rate(clk_t *clk_p, U32 freq);
+static int clkgend_init(clk_t *clk_p);
+static int clkgene_init(clk_t *clk_p);
+
+/* Per boards top input clocks. mb618 & mb636 currently identical */
+static U32 OSC_CLKOSC = 30;	/* USB/lp osc */
+
+/* Possible operations registration.
+   Operations are usually grouped by clockgens due to specific HW implementation
+
+   Name, Desc, init, set_parent, Setfreq, recalc, enable, disable, Observe, Meas
+
+   where
+     Name: MUST be the same one declared with REGISTER_CLK (ops field).
+     Desc: Clock group short description. Ex: "clockgen A", "USB", "LMI"
+     init: Clock init function (read HW to identify parent & compute rate).
+     set_parent: Parent/src setup function.
+     Setfreq: Clock frequency setup function.
+     enable: Clock enable function.
+     disable: Clock disable function.
+     Observe: Clock observation function.
+     recalc: Clock frequency recompute function. Called when parent clock change
+     Measure: Clock measure function (when HW available).
+
+   Note: If no capability, put NULL instead of function name.
+   Note: All functions should return 'clk_err_t'. */
+
+REGISTER_OPS(Top, "Top clocks",
+	clktop_init,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,	/* No measure function */
+	NULL
+);
+REGISTER_OPS(ClockGenA,
+	"clockgen A",
+	clkgena_init,
+	clkgena_set_parent,
+	clkgena_set_freq,
+	clkgena_recalc,
+	clkgena_enable,
+	clkgena_disable,
+	clkgena_observe,
+	clkgena_get_measure,
+	NULL
+);
+REGISTER_OPS(ClockGenB,
+	"clockgen B",
+	clkgenb_init,
+	clkgenb_set_parent,
+	clkgenb_set_freq,
+	clkgenb_recalc,
+	clkgenb_enable,
+	clkgenb_disable,
+	clkgenb_observe,
+	NULL,	/* No measure function */
+	NULL
+);
+REGISTER_OPS(ClockGenC,
+	"C/Audio",
+	clkgenc_init,
+	clkgenc_set_parent,
+	clkgenc_set_rate,
+	clkgenc_recalc,
+	clkgenc_enable,
+	clkgenc_disable,
+	NULL,
+	NULL,	/* No measure function */
+	NULL
+);
+REGISTER_OPS(ClockGenD,
+	"D/LMI",
+	clkgend_init,
+	clkgend_set_parent,
+	NULL,
+	clkgend_recalc,
+	NULL,
+	NULL,
+	NULL,
+	NULL,	/* No measure function */
+	NULL
+);
+REGISTER_OPS(ClockGenE,
+	"USB",
+	clkgene_init,
+	clkgene_set_parent,
+	NULL,
+	clkgene_recalc,
+	NULL,
+	NULL,
+	NULL,
+	NULL,	/* No measure function */
+	NULL
+);
+
+/* Physical clocks description */
+clk_t clk_clocks[] = {
+	/*	    ClkID	       Ops	 Nominalfreq   Flags */
+
+	/* Top level clocks */
+	REGISTER_CLK(CLK_SATA_OSC, &Top, 0,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLK_SYSALT, &Top, 0,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+
+	/* Clockgen A */
+	REGISTER_CLK(CLKA_REF, &ClockGenA, 0,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLKA_PLL0HS, &ClockGenA, 900000000, CLK_RATE_PROPAGATES),
+	REGISTER_CLK(CLKA_PLL0LS, &ClockGenA, 450000000, CLK_RATE_PROPAGATES),
+	REGISTER_CLK(CLKA_PLL1, &ClockGenA, 800000000, CLK_RATE_PROPAGATES),
+	REGISTER_CLK(CLKA_OSC, &ClockGenA, 30000000, CLK_RATE_PROPAGATES),
+
+	REGISTER_CLK(CLKA_IC_STNOC, &ClockGenA, 400000000, 0),
+	REGISTER_CLK(CLKA_FDMA0, &ClockGenA, 400000000, 0),
+	REGISTER_CLK(CLKA_FDMA1, &ClockGenA, 400000000, 0),
+	REGISTER_CLK(CLKA_FDMA2, &ClockGenA, 400000000, 0),
+	REGISTER_CLK(CLKA_SH4_ICK, &ClockGenA, 450000000, 0),
+	REGISTER_CLK(CLKA_SH4_ICK_498, &ClockGenA, 450000000, 0),
+	REGISTER_CLK(CLKA_LX_DMU_CPU, &ClockGenA, 450000000, 0),
+	REGISTER_CLK(CLKA_LX_AUD_CPU, &ClockGenA, 450000000, 0),
+	REGISTER_CLK(CLKA_IC_BDISP_200, &ClockGenA, 200000000, 0),
+	REGISTER_CLK(CLKA_IC_DISP_200, &ClockGenA, 200000000, 0),
+	REGISTER_CLK(CLKA_IC_IF_100, &ClockGenA, 100000000, 0),
+	REGISTER_CLK(CLKA_DISP_PIPE_200, &ClockGenA, 200000000, 0),
+	REGISTER_CLK(CLKA_BLIT_PROC, &ClockGenA, 266666666, 0),
+	REGISTER_CLK(CLKA_ETH_PHY, &ClockGenA, 25000000, 0),
+	REGISTER_CLK(CLKA_PCI, &ClockGenA, 66666666, 0),
+	REGISTER_CLK(CLKA_EMI_MASTER, &ClockGenA, 100000000, 0),
+	REGISTER_CLK(CLKA_IC_COMPO_200, &ClockGenA, 200000000, 0),
+	REGISTER_CLK(CLKA_IC_IF_200, &ClockGenA, 200000000, 0),
+
+	/* Clockgen B */
+	REGISTER_CLK(CLKB_REF, &ClockGenB, 0,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLKB_FS0_CH1, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_FS0_CH2, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_FS0_CH3, &ClockGenB, 0, 0),
+	/*   REGISTER_CLK( CLKB_FS0_CH4,       &ClockGenB, 0,	    0 ),*/
+	REGISTER_CLK(CLKB_FS1_CH1, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_FS1_CH2, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_FS1_CH3, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_FS1_CH4, &ClockGenB, 0, 0),
+
+	REGISTER_CLK(CLKB_TMDS_HDMI, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_PIX_HD, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_DISP_HD, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_656, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_GDP3, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_DISP_ID, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_PIX_SD, &ClockGenB, 0, 0),
+
+	REGISTER_CLK(CLKB_DSS, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_PP, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_150, &ClockGenB, 0, 0),
+	REGISTER_CLK(CLKB_LPC, &ClockGenB, 0, 0),
+
+	/* Clockgen C (CKGCIO) */
+	REGISTER_CLK(CLKC_REF, &ClockGenC, 0,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLKC_FS0_CH1, &ClockGenC, 0, 0),
+	REGISTER_CLK(CLKC_FS0_CH2, &ClockGenC, 0, 0),
+	REGISTER_CLK(CLKC_FS0_CH3, &ClockGenC, 0, 0),
+	REGISTER_CLK(CLKC_FS0_CH4, &ClockGenC, 0, 0),
+
+	/* Clockgen D (LMI) */
+	REGISTER_CLK(CLKD_REF, &ClockGenD, 30000000,
+		     CLK_RATE_PROPAGATES | CLK_ALWAYS_ENABLED),
+	REGISTER_CLK(CLKD_LMI2X, &ClockGenD, 800000000, 0),
+
+	/* Clockgen E (USB), not really a clockgen */
+	REGISTER_CLK(CLKE_REF, &ClockGenE, 30000000, CLK_ALWAYS_ENABLED),
+/*
+ * Not required in Linux
+	REGISTER_CLK(CLK_LAST, NULL, 0, 0)	* Always keep this last item
+ */
 };
 
-static struct sysconf_field *clkgena_clkosc_sel_sc;
+typedef struct fsyn_regs {
+	unsigned long md, pe, sdiv, prog;
+} fsyn_regs_t;
 
-static void __iomem *clkgena_base, *clkgenb_base;
+static U32 clkgena_offset_regs[] = {
+	CKGA_OSC_DIV0_CFG,
+	CKGA_PLL0HS_DIV0_CFG,
+	CKGA_PLL0LS_DIV0_CFG,
+	CKGA_PLL1_DIV0_CFG
+};
 
-static struct sysconf_field *clkgend_ddiv, *clkgend_rdiv;
-static struct sysconf_field *clkgend_clk_sel;
+static struct fsyn_regs clkgenb_regs[] = {
+	{CKGB_FS0_MD1, CKGB_FS0_PE1, CKGB_FS0_SDIV1, CKGB_FS0_EN_PRG1},
+	{CKGB_FS0_MD2, CKGB_FS0_PE2, CKGB_FS0_SDIV2, CKGB_FS0_EN_PRG2},
+	{CKGB_FS0_MD3, CKGB_FS0_PE3, CKGB_FS0_SDIV3, CKGB_FS0_EN_PRG3},
+	{CKGB_FS0_MD4, CKGB_FS0_PE4, CKGB_FS0_SDIV4, CKGB_FS0_EN_PRG4},
+	{CKGB_FS1_MD1, CKGB_FS1_PE1, CKGB_FS1_SDIV1, CKGB_FS1_EN_PRG1},
+	{CKGB_FS1_MD2, CKGB_FS1_PE2, CKGB_FS1_SDIV2, CKGB_FS1_EN_PRG2},
+	{CKGB_FS1_MD3, CKGB_FS1_PE3, CKGB_FS1_SDIV3, CKGB_FS1_EN_PRG3},
+	{CKGB_FS1_MD4, CKGB_FS1_PE4, CKGB_FS1_SDIV4, CKGB_FS1_EN_PRG4},
+};
 
-/* Clkgen A clk_osc -------------------------------------------------------- */
+static struct fsyn_regs clkgenc_regs[] = {
+	{CKGC_FS0_MD1, CKGC_FS0_PE1, CKGC_FS0_SDIV1, CKGC_FS0_EN_PRG1},
+	{CKGC_FS0_MD2, CKGC_FS0_PE2, CKGC_FS0_SDIV2, CKGC_FS0_EN_PRG2},
+	{CKGC_FS0_MD3, CKGC_FS0_PE3, CKGC_FS0_SDIV3, CKGC_FS0_EN_PRG3},
+	{CKGC_FS0_MD4, CKGC_FS0_PE4, CKGC_FS0_SDIV4, CKGC_FS0_EN_PRG4}
+};
 
-static void clkgena_clk_osc_init(struct clk *clk)
+GENERIC_LINUX_CLKS(clk_clocks[CLKA_SH4_ICK],	/* sh4_clk parent    */
+		   clk_clocks[CLKA_IC_IF_100],	/* module_clk parent */
+		   clk_clocks[CLKA_IC_IF_100]);	/* comms_clk parent  */
+
+/*
+ * The Linux clk_init function
+ */
+int __init clk_init(void)
 {
-	clk->rate = clkin[sysconf_read(clkgena_clkosc_sel_sc)];
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(clk_clocks); ++i)
+		if (!clk_register(&clk_clocks[i]))
+			clk_enable(&clk_clocks[i]);
+
+	REGISTER_GENERIC_LINUX_CLKS();
+
+	return 0;
 }
 
-static struct clk_ops clkgena_clk_osc_ops = {
-	.init		= clkgena_clk_osc_init,
-};
+/******************************************************************************
+Top level clocks group
+******************************************************************************/
 
-static struct clk clkgena_clk_osc = {
-	.name		= "clkgena_clk_osc",
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-	.ops		= &clkgena_clk_osc_ops,
-};
+/* ========================================================================
+   Name:	clkgena_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
 
-/* Clkgen A PLLs ----------------------------------------------------------- */
+static int clktop_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return (CLK_ERR_BAD_PARAMETER);
 
-static unsigned long pll800_freq(unsigned long input, unsigned long cfg)
+	/* Top recalc function */
+	switch (clk_p->id) {
+	case CLK_SATA_OSC:
+		clk_p->rate = OSC_CLKOSC * 1000000;
+		break;
+	case CLK_SYSALT:
+		clk_p->rate = OSC_CLKOSC * 1000000;
+		break;
+
+	default:
+		clk_p->rate = 0;
+		break;
+	}
+
+	return (CLK_ERR_NONE);
+}
+
+/******************************************************************************
+CLOCKGEN A (CPU+interco+comms) clocks group
+******************************************************************************/
+
+/* ========================================================================
+Name:	clkgena_get_index
+Description: Returns index of given clockgenA clock
+Returns:     idx==-1 if error, else >=0
+======================================================================== */
+
+static int clkgena_get_index(clk_id_t clkid, U32 *srcreg, int *shift)
 {
-	unsigned long freq, ndiv, pdiv, mdiv;
+	int idx;
+	/* Warning: This functions assumes clock IDs are perfectly
+	   following real implementation order. Each "hole" has therefore
+	   to be filled with "CLKx_NOT_USED" */
+	if (clkid < CLKA_IC_STNOC || clkid > CLKA_IC_IF_200)
+		return -1;
 
-	mdiv = (cfg >>  0) & 0xff;
-	ndiv = (cfg >>  8) & 0xff;
-	pdiv = (cfg >> 16) & 0x7;
-	freq = (((2 * (input / 1000) * ndiv) / mdiv) /
-		(1 << pdiv)) * 1000;
+	if (clkid >= CLKA_BLIT_PROC)
+		idx = clkid - CLKA_IC_STNOC - 1;
+	else
+		idx = clkid - CLKA_IC_STNOC;
+
+	if (idx <= 15) {
+		*srcreg = CKGA_CLKOPSRC_SWITCH_CFG;
+		*shift = idx * 2;
+	} else {
+		*srcreg = CKGA_CLKOPSRC_SWITCH_CFG2;
+		*shift = (idx - 16) * 2;
+	}
 
-	return freq;
+	return (idx);
 }
 
-static unsigned long pll1600_freq(unsigned long input, unsigned long cfg)
+/* ========================================================================
+   Name:	clkgena_set_parent
+   Description: Set clock source for clockgenA when possible
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgena_set_parent(clk_t *clk_p, clk_t *src_p)
 {
-	unsigned long freq, ndiv, mdiv;
+	U32 clk_src, val;
+	int idx;
+	U32 srcreg;
+	int shift;
+
+	if (!clk_p || !src_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	switch (src_p->id) {
+	case CLKA_OSC:
+		clk_src = 0;
+		break;
+	case CLKA_PLL0LS:
+	case CLKA_PLL0HS:
+		clk_src = 1;
+		break;
+	case CLKA_PLL1:
+		clk_src = 2;
+		break;
+	default:
+		return CLK_ERR_BAD_PARAMETER;
+	}
 
-	mdiv = (cfg >>  0) & 0x7;
-	ndiv = (cfg >>  8) & 0xff;
-	freq = (((input / 1000) * ndiv) / mdiv) * 1000;
+	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
+	if (idx == -1)
+		return (CLK_ERR_BAD_PARAMETER);
 
-	return freq;
+	val = CLK_READ(CKGA_BASE_ADDRESS + srcreg) & ~(0x3 << shift);
+	val = val | (clk_src << shift);
+	CLK_WRITE(CKGA_BASE_ADDRESS + srcreg, val);
+
+	clk_p->parent = &clk_clocks[src_p->id];
+	clkgena_recalc(clk_p);
+
+	return 0;
 }
 
-static unsigned long clkgena_pll_freq(unsigned long clk_osc, int pll_num)
+/* ========================================================================
+   Name:	clkgena_identify_parent
+   Description: Identify parent clock for clockgen A clocks.
+   Returns:     Pointer on parent 'clk_t' structure.
+   ======================================================================== */
+
+static int clkgena_identify_parent(clk_t *clk_p)
 {
-	unsigned long data;
+	int idx;
+	U32 src_sel;
+	U32 srcreg;
+	int shift;
+
+	if (!clk_p)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	clk_p->parent = NULL;
+
+	switch (clk_p->id) {
+	case CLKA_REF:
+		src_sel = SYSCONF_READ(SYS_STA, 1, 0, 0);
+		switch (src_sel) {
+		case 0:
+			clk_p->parent = &clk_clocks[CLK_SATA_OSC];
+			break;
+		case 1:
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
+			break;
+		default:
+			break;
+		}
+		return (0);
+
+	case CLKA_PLL0LS:/* PLLs of clockgen A all sourced from CLKA_REF */
+	case CLKA_PLL0HS:
+	case CLKA_PLL1:
+		clk_p->parent = &clk_clocks[CLKA_REF];
+		return (0);
+	}
 
-	switch (pll_num) {
+	/* Which divider to setup ? */
+	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
+	if (idx == -1)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	/* Identifying source */
+	src_sel = (CLK_READ(CKGA_BASE_ADDRESS + srcreg) >> shift) & 0x3;
+	switch (src_sel) {
 	case 0:
-		data = readl(clkgena_base + CKGA_PLL0_CFG);
-		return pll1600_freq(clk_osc, data);
+		clk_p->parent = &clk_clocks[CLKA_OSC];
+		break;
 	case 1:
-		data = readl(clkgena_base + CKGA_PLL1_CFG);
-		return pll800_freq(clk_osc, data);
+		if (idx <= 3)
+			clk_p->parent = &clk_clocks[CLKA_PLL0HS];
+		else
+			clk_p->parent = &clk_clocks[CLKA_PLL0LS];
+		break;
+	case 2:
+		clk_p->parent = &clk_clocks[CLKA_PLL1];
+		break;
+	case 3:
+		clk_p->parent = NULL;
+		clk_p->rate = 0;
+		break;
 	}
 
+	return (0);
+}
+
+/* ========================================================================
+   Name:	clkgena_enable
+   Description: enable/disable clock
+   Returns:     O=NO error
+   ======================================================================== */
+
+static int clkgena_enable(clk_t *clk_p)
+{
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+	if (!clk_p->parent)
+		return CLK_ERR_BAD_PARAMETER;
+
+	return clkgena_set_parent(clk_p, clk_p->parent);
+}
+
+/* ========================================================================
+   Name:	clkgena_disable
+   Description: disable clock
+   Returns:     'clk_err_t' error code
+   ======================================================================== */
+
+static int clkgena_disable(clk_t *clk_p)
+{
+	U32 clk_src, val;
+	int idx;
+	U32 srcreg;
+	int shift;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+	if (!clk_p->parent)
+		/* Unsupported. Need to use set_parent() first. */
+		return CLK_ERR_BAD_PARAMETER;
+
+	/* IC_IF_100, IC_IF_200, and CPU cannot be disabled */
+	if ((clk_p->id == CLKA_IC_IF_100) || (clk_p->id == CLKA_IC_IF_200)
+	    || (clk_p->id == CLKA_SH4_ICK))
+		return (0);
+
+	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
+	if (idx == -1)
+		return CLK_ERR_BAD_PARAMETER;
+
+	/* Disabling clock */
+	val = CLK_READ(CKGA_BASE_ADDRESS + srcreg) & ~(0x3 << shift);
+	val = val | (3 << shift);	/* 3 = STOP clock */
+	CLK_WRITE(CKGA_BASE_ADDRESS + srcreg, val);
+	clk_p->rate = 0;
+
+	return (0);
+}
+
+/* ========================================================================
+   Name:	clkgena_set_div
+   Description: Set divider ratio for clockgenA when possible
+   ======================================================================== */
+
+static int clkgena_set_div(clk_t *clk_p, U32 * div_p)
+{
+	int idx;
+	U32 div_cfg = 0;
+	U32 srcreg, offset;
+	int shift;
+
+	if (!clk_p || !clk_p->parent)
+		return CLK_ERR_BAD_PARAMETER;
+
+	/* Computing divider config */
+	if (*div_p == 1)
+		div_cfg = 0x00;
+	else {
+		float split;
+		div_cfg = (*div_p - 1) & 0x1F;
+		if ((*div_p % 2) == 0) {	/* even */
+			split = (*div_p / 2) - 1;
+		} else {	/* odd */
+
+			split = ((float)*div_p / 2) - (float)0.5;
+		}
+		div_cfg = div_cfg | ((U32) split << 8);
+	}
+
+	/* Which divider to setup ? */
+	idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
+	if (idx == -1)
+		return CLK_ERR_BAD_PARAMETER;
+
+	/* Now according to parent, let's write divider ratio */
+	offset = clkgena_offset_regs[clk_p->parent->id - CLKA_OSC];
+	CLK_WRITE(CKGA_BASE_ADDRESS + offset + (4 * idx), div_cfg);
+
+	return (0);
+}
+
+/* ========================================================================
+   Name:	clkgena_set_freq
+   Description: Set clock frequency
+   ======================================================================== */
+
+static int clkgena_set_freq(clk_t *clk_p, U32 freq)
+{
+	U32 div;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id < CLKA_IC_STNOC)
+		return 0;
+	if (clk_p->id <= CLKA_IC_IF_200)
+		if (!clk_p->parent)
+			return CLK_ERR_INTERNAL;
+	div = clk_p->parent->rate / freq;
+	clkgena_set_div(clk_p, &div);
+
 	return 0;
 }
 
-struct pllclk
+/* ========================================================================
+   Name:	clkgena_recalc
+   Description: Get CKGA programmed clocks frequencies
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgena_recalc(clk_t *clk_p)
 {
-	struct clk clk;
-	unsigned long pll_num;
-};
+	U32 data, ratio;
+	int idx;
+	U32 srcreg, offset;
+	int shift;
 
-static void pll_clk_recalc(struct clk *clk)
+	if (!clk_p || !clk_p->parent)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	/* Cleaning structure first */
+	clk_p->rate = 0;
+
+	/* Reading clock programmed value */
+	switch (clk_p->id) {
+	case CLKA_REF:		/* Clockgen A reference clock */
+		clk_p->rate = clk_p->parent->rate;
+		break;
+
+	case CLKA_PLL0HS:
+	case CLKA_PLL0LS:
+		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL0_CFG);
+		clk_p->rate = clk_pll1600_freq(clk_p->parent->rate, data);
+		if (clk_p->id == CLKA_PLL0LS)
+			clk_p->rate = clk_p->rate / 2;
+		break;
+
+	case CLKA_PLL1:
+		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_PLL1_CFG);
+		clk_p->rate = clk_pll800_freq(clk_p->parent->rate, data);
+		break;
+
+	default:
+		if (!clk_p->parent) {
+			clk_p->rate = 0;
+			return (0);
+		}
+
+		idx = clkgena_get_index(clk_p->id, &srcreg, &shift);
+		if (idx == -1)
+			return (CLK_ERR_BAD_PARAMETER);
+
+		/* Now according to source, let's get divider ratio */
+		offset = clkgena_offset_regs[clk_p->parent->id - CLKA_OSC];
+		data = CLK_READ(CKGA_BASE_ADDRESS + offset + (4 * idx));
+
+		if ((data & 0x1F) == 0)	/* Div by 1 ? */
+			ratio = 1;
+		else
+			ratio = (data & 0x1F) + 1;
+
+		clk_p->rate = clk_p->parent->rate / ratio;
+		break;
+	}
+
+	return (0);
+}
+
+/* ========================================================================
+   Name:	clkgena_observe
+   Description: allows to observe a clock on a SYSACLK_OUT
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgena_observe(clk_t *clk_p, unsigned long *div_p)
 {
-	struct pllclk *pllclk = container_of(clk, struct pllclk, clk);
+	U32 src = 0;
+	U32 divcfg;
+	static U32 obs_table[] = { 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
+		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
+	};
+	if (!clk_p || !div_p)
+		return (CLK_ERR_BAD_PARAMETER);
 
-	clk->rate = clkgena_pll_freq(clk->parent->rate, pllclk->pll_num);
+	if (clk_p->id < CLKA_IC_STNOC || clk_p->id > CLKA_IC_IF_200)
+		return CLK_ERR_FEATURE_NOT_SUPPORTED;
+
+	src = obs_table[clk_p->id - CLKA_IC_STNOC];
+
+	switch (*div_p) {
+	case 2:
+		divcfg = 0;
+		break;
+	case 4:
+		divcfg = 1;
+		break;
+	default:
+		divcfg = 2;
+		*div_p = 1;
+		break;
+	}
+	CLK_WRITE((CKGA_BASE_ADDRESS + CKGA_CLKOBS_MUX1_CFG),
+		  (divcfg << 6) | src);
+
+	return 0;
 }
 
-static struct clk_ops pll_clk_ops = {
-	.recalc		= pll_clk_recalc,
-};
+/* ========================================================================
+   Name:	clkgena_get_measure
+   Description: Use internal HW feature (when avail.) to measure clock
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
+
+static unsigned long clkgena_get_measure(clk_t *clk_p)
+{
+	U32 src, data;
+	U32 measure;
+	static U32 measure_table[] = {
+		8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12,
+		0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
+	};
+	if (!clk_p)
+		return (0);
+	if (clk_p->id < CLKA_IC_STNOC || clk_p->id > CLKA_IC_IF_200)
+		return 0;
+
+	src = measure_table[clk_p->id - CLKA_IC_STNOC];
+	measure = 0;
+
+	/* Loading the MAX Count 1000 in 30MHz Oscillator Counter */
+	/* poke #FE213034 #3E8     */
+	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_MASTER_MAXCOUNT, 0x3E8);
+	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_CMD, 3);
+
+	/* Selecting clock to observe */
+	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_MUX1_CFG, (1 << 7) | src);
 
-static struct pllclk pllclks[2] = {
-	{
-		.clk = {
-			.name	= "clkgena_pll0_clk",
-			.parent	= &clkgena_clk_osc,
-			.flags	= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-			.ops	= &pll_clk_ops,
-		},
-		.pll_num = 0
-	}, {
-		.clk = {
-			.name	= "clkgena_pll1_clk",
-			.parent	= &clkgena_clk_osc,
-			.flags	= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-			.ops	= &pll_clk_ops,
-		},
-		.pll_num = 1
+	/* Start counting */
+	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_CMD, 0);
+
+	while (1) {
+		task_delay(time_ticks_per_sec() / 100);	/* Every 10ms */
+
+		data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_CLKOBS_STATUS);
+		if (data & 1)
+			break;	/* IT */
 	}
-};
 
-/* Clkgen A clocks --------------------------------------------------------- */
-enum clockgenA_ID {
-	IC_STNOC_ID     = 0,
-	FDMA0_ID,
-	FDMA1_ID,
-	SH4_CLK_ID,
-	SH4_498_CLK_ID,
-	LX_DMU_ID,
-	LD_AUD_ID,
-	IC_BDISP_200_ID,
-	IC_DISP_200_ID,
-	IC_IF_100_ID,
-	DISP_PIPE_200_ID,
-	BLIT_PROC_ID,
-	ETH_PHY_ID,
-	PCI_ID,
-	EMI_ID,
-	IC_COMPO_200_ID,
-	IC_IF_200_ID
-};
+	/* Reading value */
+	data = CLK_READ(CKGA_BASE_ADDRESS + CKGA_CLKOBS_SLAVE0_COUNT);
+	measure = 30 * data * 1000;
+
+	/* poke #FE213038 #3 */
+	CLK_WRITE(CKGA_BASE_ADDRESS + CKGA_CLKOBS_CMD, 3);
+
+	return measure;
+}
+
+/* ========================================================================
+   Name:	clkgena_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
+
+static int clkgena_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	clkgena_identify_parent(clk_p);
+	clkgena_recalc(clk_p);
 
-struct clkgenaclk
+	return 0;
+}
+
+/******************************************************************************
+CLOCKGEN B
+******************************************************************************/
+
+void clkgenb_unlock(void)
+{
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_LOCK, 0xc0de);
+}
+
+void clkgenb_lock(void)
 {
-	unsigned long num;
+	CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_LOCK, 0xc1a0);
+}
+
+/* ========================================================================
+   Name:	clkgenb_enable
+   Description: enable/disable clock
+   Returns:     0=NO error
+   ======================================================================== */
+struct gen_utility {
+	U32 clk_id;
+	U32 info;
 };
 
-static void clkgena_clk_init(struct clk *clk)
+static int clkgenb_xxable(clk_t *clk_p, U32 en)
 {
-	struct clkgenaclk *clkgenaclk =
-		(struct clkgenaclk *)clk->private_data;
-	unsigned long num = clkgenaclk->num;
-	unsigned long data;
-	unsigned long src_sel;
+	U32 bit, power;
+	U32 i;
+	struct gen_utility enable_clock[] = {
+		{CLKB_DSS, 1},
+		{CLKB_PIX_HD, 3},
+		{CLKB_DISP_HD, 4},
+		{CLKB_TMDS_HDMI, 5},
+		{CLKB_656, 6},
+		{CLKB_GDP3, 7},
+		{CLKB_DISP_ID, 8},
+		{CLKB_PIX_SD, 9},
+		{CLKB_150, 11},
+		{CLKB_PP, 12},
+		{CLKB_LPC, 13}
+	};
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+	for (i = 0; i < 11; ++i)
+		if (enable_clock[i].clk_id == clk_p->id)
+			break;
+	if (i == 11)
+		return CLK_ERR_BAD_PARAMETER;
+	power = CLK_READ(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE);
+	bit = enable_clock[i].info;
+	clkgenb_unlock();
+	if (en) {
+		CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE,
+			  power | (1 << bit));
+	} else {
+		CLK_WRITE(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE,
+			  power & ~(1 << bit));
+	}
+	clkgenb_lock();
 
-	data = readl(clkgena_base + CKGA_CLKOPSRC_SWITCH_CFG(num >> 4));
-	src_sel = (data >> ((num & 0xf) * 2)) & 3;
+	return 0;
+}
 
-	switch (src_sel) {
-	case 0:
-		clk->parent = &clkgena_clk_osc;
-		break;
-	case 1:
-		clk->parent = &pllclks[0].clk;
+static int clkgenb_enable(clk_t *clk_p)
+{
+	return clkgenb_xxable(clk_p, 1);
+}
+
+/* ========================================================================
+   Name:	clkgenb_disable
+   Description: disable clock
+   Returns:     O=NO error
+   ======================================================================== */
+
+static int clkgenb_disable(clk_t *clk_p)
+{
+	return clkgenb_xxable(clk_p, 0);
+}
+
+/* ========================================================================
+   Name:	clkgenb_set_parent
+   Description: Set clock source for clockgenB when possible
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgenb_set_parent(clk_t *clk_p, clk_t *parent_p)
+{
+	U32 set = 0;		/* Each bit set to 1 will be SETTED */
+	U32 reset = 0;		/* Each bit set to 1 will be RESETTED */
+	U32 reg;		/* Register address */
+	U32 val;
+
+	if (!clk_p || !parent_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	switch (clk_p->id) {
+	case CLKB_REF:
+		switch (parent_p->id) {
+		case CLK_SATA_OSC:
+			reset = 1;
+			break;
+		case CLK_SYSALT:
+			set = 1;
+			break;
+		}
+		reg = CKGB_BASE_ADDRESS + CKGB_CRISTAL_SEL;
 		break;
-	case 2:
-		clk->parent = &pllclks[1].clk;
+
+		/*  case CLKB_PIX_HD:
+		   if ( parent_p->id == CLKB_FS0_CH1 )
+		   reset = 1 << 14;
+		   else
+		   set = 1 << 14;
+		   reg = CKGB_BASE_ADDRESS+CKGB_DISPLAY_CFG;
+		   break; */
+	case CLKB_GDP3:
+		if ((parent_p->id == CLKB_DISP_HD)
+		    || (parent_p->id == CLKB_FS0_CH1))
+			reset = 1 << 0;
+		else
+			set = 1 << 0;
+		reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 		break;
-	case 3:
-		/* clock is stopped */
-		clk->parent = NULL;
+
+	case CLKB_PIX_SD:
+		if (parent_p->id == CLKB_FS0_CH1)
+			reset = 1 << 1;
+		else
+			set = 1 << 1;
+		reg = CKGB_BASE_ADDRESS + CKGB_FS_SELECT;
 		break;
+
+	case CLKB_PIP:
+		/* In fact NOT a clockgen B clock but closely linked to it */
+		if (parent_p->id == CLKB_DISP_ID)
+			val = 0;
+		else if (parent_p->id == CLKB_DISP_HD)
+			val = 1;
+		else
+			return CLK_ERR_BAD_PARAMETER;
+		SYSCONF_WRITE(SYS_CFG, 6, 0, 0, val);
+		clk_p->parent = parent_p;
+		/* Special case since config done thru sys_conf register */
+		return 0;
+
+	default:
+		return CLK_ERR_BAD_PARAMETER;
 	}
+
+	clkgenb_unlock();
+	val = CLK_READ(reg);
+	val = val & ~reset;
+	val = val | set;
+	CLK_WRITE(reg, val);
+	clkgenb_lock();
+	clk_p->parent = parent_p;
+
+	return 0;
 }
 
-static void clkgena_clk_recalc(struct clk *clk)
+/* ========================================================================
+   Name:	clkgenb_set_freq
+   Description: Set clock frequency
+   ======================================================================== */
+
+static int clkgenb_set_freq(clk_t *clk_p, U32 freq)
 {
-	struct clkgenaclk *clkgenaclk =
-		(struct clkgenaclk *)clk->private_data;
-	unsigned long num = clkgenaclk->num;
-	unsigned long data;
-	unsigned long src_sel;
-	unsigned long div_cfg = 0;
-	unsigned long ratio;
+	U32 div;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	switch (clk_p->id) {
+	case CLKB_FS0_CH1:
+	case CLKB_FS0_CH2:
+	case CLKB_FS0_CH3:
+/*	case CLKB_FS0_CH4:*/
+	case CLKB_FS1_CH1:
+	case CLKB_FS1_CH2:
+	case CLKB_FS1_CH3:
+	case CLKB_FS1_CH4:
+		return clkgenb_set_fsclock(clk_p, freq);
+	default:
+		if (!clk_p->parent)
+			/* A parent is expected to these clocks */
+			return CLK_ERR_INTERNAL;
+		div = clk_p->parent->rate / freq;
+		return clkgenb_set_div(clk_p, &div);
+	}
 
-	data = readl(clkgena_base + CKGA_CLKOPSRC_SWITCH_CFG(num >> 4));
-	src_sel = (data >> ((num & 0xf) * 2)) & 3;
+	return 0;
+}
 
-	switch (src_sel) {
-	case 0:
-		div_cfg = readl(clkgena_base + CKGA_OSC_DIV_CFG(num));
+/* ========================================================================
+   Name:	clkgenb_set_fsclock
+   Description: Set FS clock
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgenb_set_fsclock(clk_t *clk_p, U32 freq)
+{
+	int md, pe, sdiv;
+	struct fsyn_regs *regs;
+	if (!clk_p || !clk_p->parent)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	/* Computing FSyn params. Should be common function with FSyn type */
+	if ((clk_fsyn_get_params
+	     ((clk_p->parent->rate / 1000000), freq, &md, &pe, &sdiv)) != 0)
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id < CLKB_FS0_CH1 || clk_p->id > CLKB_FS1_CH4)
+		return CLK_ERR_BAD_PARAMETER;
+
+	regs = &clkgenb_regs[clk_p->id - CLKB_FS1_CH4];
+
+	clkgenb_unlock();
+	CLK_WRITE(CKGB_BASE_ADDRESS + regs->md, md);
+	CLK_WRITE(CKGB_BASE_ADDRESS + regs->pe, pe);
+	CLK_WRITE(CKGB_BASE_ADDRESS + regs->sdiv, sdiv);
+	CLK_WRITE(CKGB_BASE_ADDRESS + regs->prog, 0x1);
+	clkgenb_lock();
+	clk_p->rate = freq;
+	return 0;
+}
+
+/* ========================================================================
+   Name:	clkgenb_set_div
+   Description: Set divider ratio for clockgenB when possible
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgenb_set_div(clk_t *clk_p, U32 * div_p)
+{
+	U32 set = 0;		/* Each bit set to 1 will be SETTED */
+	U32 reset = 0;		/* Each bit set to 1 will be RESETTED */
+	U32 reg;
+	U32 val;
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	reg = CKGB_DISPLAY_CFG;
+	switch (clk_p->id) {
+	case CLKB_TMDS_HDMI:
+		switch (*div_p) {
+		case 1:
+			reset = 0x1;
+			set = 0x3;
+			break;
+		case 2:
+			reset = 0x3;
+			set = 0x3;
+			break;
+		case 4:
+			reset = 1 << 1;
+			set = 1 << 0;
+			break;
+		case 1024:
+			reg = CKGB_POWER_DOWN;
+			set = 1 << 1;
+			break;
+		}
 		break;
-	case 1:
-		div_cfg = readl(clkgena_base +
-				((num <= 3) ? CKGA_PLL0HS_DIV_CFG(num) :
-				 CKGA_PLL0LS_DIV_CFG(num)));
+	case CLKB_DISP_HD:
+		switch (*div_p) {
+		case 1:
+			reset = 0x3 << 4;
+			set = 0x3 << 4;
+			break;
+		case 2:
+			reset = 0x3 << 4;
+			set = 0x0;
+			break;
+		case 4:
+			reset = 1 << 5;
+			set = 1 << 4;
+			break;
+		case 8:
+			set = 1 << 5;
+			reset = 1 << 4;
+			break;
+		case 1024:
+			reg = CKGB_POWER_DOWN;
+			set = 1 << 4;
+			break;
+		}
 		break;
-	case 2:
-		div_cfg = readl(clkgena_base + CKGA_PLL1_DIV_CFG(num));
+	case CLKB_656:
+		switch (*div_p) {
+		case 2:
+			reset = 0x3 << 6;
+			set = 0x3 << 6;
+			break;
+		case 4:
+			reset = 1 << 7;
+			set = 1 << 6;
+			break;
+		case 1024:
+			reg = CKGB_POWER_DOWN;
+			set = 1 << 5;
+			break;
+		}
 		break;
-	case 3:
-		clk->rate = 0;
-		return;
+	case CLKB_DISP_ID:
+		switch (*div_p) {
+		case 2:
+			reset = 0x3 << 8;
+			set = 0x3 << 8;
+			break;
+		case 4:
+			reset = 0x1 << 9;
+			set = 0x1 << 8;
+			break;
+		case 8:
+			reset = 0x3 << 8;
+			set = 0x2 << 8;
+			break;
+		case 1024:
+			reg = CKGB_POWER_DOWN;
+			set = 1 << 6;
+			break;
+		}
+		break;
+	case CLKB_PIX_SD:
+
+		if (clk_p->parent->id == CLKB_FS0_CH1) {
+			switch (*div_p) {/* clk_pix_sd sourced from Fsyn0 */
+			case 2:
+				reset = 0x3 << 10;
+				set = 0;
+				break;
+			case 4:
+				reset = 1 << 11;
+				set = 1 << 10;
+				break;
+			case 1024:
+				reg = CKGB_POWER_DOWN;
+				set = 1 << 7;
+				break;
+			}
+
+		} else {
+			switch (*div_p) {/* clk_pix_sd sourced from Fsyn1 */
+			case 1:
+				reset = 0x1 << 13;
+				set = 0x3 << 12;
+				break;
+			case 2:
+				reset = 0x3 < 12;
+				set = 0;
+				break;
+			case 4:
+				reset = 1 << 13;
+				set = 1 << 12;
+				break;
+			case 1024:
+				reg = CKGB_POWER_DOWN;
+				set = 1 << 7;
+				break;
+			}
+		}
+		break;
+	default:
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
-	if (div_cfg & 0x10000)
-		ratio = 1;
-	else
-		ratio = (div_cfg & 0x1F) + 1;
+	val = CLK_READ(CKGB_BASE_ADDRESS + reg);
+	val = val & ~reset;
+	val = val | set;
+	clkgenb_unlock();
+	CLK_WRITE(CKGB_BASE_ADDRESS + reg, val);
+	clkgenb_lock();
 
-	clk->rate = clk->parent->rate / ratio;
+	return 0;
 }
 
-static const struct xratio ratios [] = {{1,  0x0 },
-					{2,  0x1 },
-					{4,  0x3 },
-					{8,  0x7 },
-					{12, 0xb },
-					{16, 0xf },
-					{24, 0x17 },
-					{32, 0x1f },
-					{NO_MORE_RATIO, }
-};
+/* ========================================================================
+   Name:	clkgenb_observe
+   Description: Allows to observe a clock on a PIO5_2
+   Returns:     0=NO error
+   ======================================================================== */
 
-static int clkgena_clk_setrate(struct clk *clk, unsigned long value)
+static int clkgenb_observe(clk_t *clk_p, unsigned long *div_p)
 {
-	struct clkgenaclk *clkgenaclk =
-		(struct clkgenaclk *)clk->private_data;
-	unsigned long num = clkgenaclk->num;
-	unsigned long id = clk->id;
-	unsigned long data;
-	unsigned long src_sel;
-	int idx;
+	static U32 observe_table[] = {
+		1,		/* CLKB_TMDS_HDMI    */
+		3,		/* CLKB_PIX_HD       */
+		4,		/* CLKB_DISP_HD      */
+		5,		/* CLKB_656	  */
+		6,		/* CLKB_GDP3	 */
+		7,		/* CLKB_DISP_ID      */
+		8,		/* CLKB_PIX_SD       */
+		12,		/* CLKB_PP	   */
+		-1,		/* CLKB_150	  */
+		13,		/* CLKB_LPC	  */
+		9,		/* CLKB_DSS	  */
+		-1 /* CLKB_PIP	  */
+	};
+
+	U32 out0, out1 = 0;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id == CLKB_PIP || clk_p->id == CLKB_150)
+		return CLK_ERR_BAD_PARAMETER;
+
+	out0 = observe_table[clk_p->id - CLKB_TMDS_HDMI];
+	if (clk_p->id == CLKB_PP)
+		out1 = 11;
+
+	clkgenb_unlock();
+	CLK_WRITE((CKGB_BASE_ADDRESS + CKGB_OUT_CTRL), (out1 << 4) | out0);
+	clkgenb_lock();
+
+	/* Set PIO5_2 for observation (alternate function output mode) */
+	PIO_SET_MODE(5, 2, STPIO_ALT_OUT);
+
+	/* No possible predivider on clockgen B */
+	*div_p = 1;
+
+	return 0;
+}
+
+/* ========================================================================
+   Name:	clkgenb_recalc
+   Description: Get CKGB clocks frequencies function
+   Returns:     0=NO error
+   ======================================================================== */
+
+/* Check clock enable value for clockgen B.
+   Returns: 1=RUNNING, 0=DISABLED */
+static int clkgenb_is_running(U32 power, int bit)
+{
+	if (power & (1 << bit))
+		return 1;
+
+	return 0;
+}
+
+static int clkgenb_recalc(clk_t *clk_p)
+{
+
+	U32 displaycfg, powerdown, fs_sel, power;
+	U32 ref;		/* Ref clock in Mhz */
+	U32 pe, md, sdiv;
+	struct fsyn_regs *regs;
+
+	if (!clk_p || !clk_p->parent)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	/* Cleaning structure first */
+	clk_p->rate = 0;
+
+	/* Required clocks */
+	ref = clk_p->parent->rate / 1000000;
+
+	/* Read mux */
+	displaycfg = CLK_READ(CKGB_BASE_ADDRESS + CKGB_DISPLAY_CFG);
+	powerdown = CLK_READ(CKGB_BASE_ADDRESS + CKGB_POWER_DOWN);
+	fs_sel = CLK_READ(CKGB_BASE_ADDRESS + CKGB_FS_SELECT);
+	power = CLK_READ(CKGB_BASE_ADDRESS + CKGB_POWER_ENABLE);
+
+	switch (clk_p->id) {
+	case CLKB_REF:		/* What is clockgen B ref clock ? */
+		clk_p->rate = clk_p->parent->rate;
+		break;
+
+	case CLKB_FS0_CH1...CLKB_FS1_CH4:
+		regs = &clkgenb_regs[clk_p->id - CLKB_FS0_CH1];
+		md = CLK_READ(CKGB_BASE_ADDRESS + regs->md);
+		pe = CLK_READ(CKGB_BASE_ADDRESS + regs->pe);
+		sdiv = CLK_READ(CKGB_BASE_ADDRESS + regs->sdiv);
+		clk_p->rate =
+		    clk_fsyn_get_rate(clk_p->parent->rate, pe, md, sdiv);
+		break;
+
+	case CLKB_TMDS_HDMI:	/* tmds_hdmi_clk */
+		if (powerdown & (1 << 1)) {
+			clk_p->rate = clk_p->parent->rate / 1024;
+		} else {
+			switch (displaycfg & 0x3) {
+			case 0:
+			case 3:
+				clk_p->rate = clk_p->parent->rate / 2;
+				break;
+			case 1:
+				clk_p->rate = clk_p->parent->rate / 4;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!clkgenb_is_running(power, 5))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_PIX_HD:	/* pix_hd */
+		if (displaycfg & (1 << 14)) {	/* pix_hd source = FSYN1 */
+			clk_p->rate = clk_p->parent->rate;
+		} else {	/* pix_hd source = FSYN0 */
+			clk_p->rate = clk_p->parent->rate;
+		}
+		if (powerdown & (1 << 3))
+			clk_p->rate = clk_p->rate / 1024;
+		if (!clkgenb_is_running(power, 3))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_DISP_HD:	/* disp_hd */
+		if (powerdown & (1 << 4))
+			clk_p->rate = clk_p->parent->rate / 1024;
+		else {
+			switch ((displaycfg >> 4) & 0x3) {
+			case 0:
+			case 3:
+				clk_p->rate = clk_p->parent->rate / 2;
+				break;
+			case 1:
+				clk_p->rate = clk_p->parent->rate / 4;
+				break;
+			case 2:
+				clk_p->rate = clk_p->parent->rate / 8;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!clkgenb_is_running(power, 4))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_656:		/* ccir656_clk */
+		if (powerdown & (1 << 5))
+			clk_p->rate = clk_p->parent->rate / 1024;
+		else {
+			switch ((displaycfg >> 6) & 0x3) {
+			case 0:
+			case 3:
+				clk_p->rate = clk_p->parent->rate / 2;
+				break;
+			case 1:
+				clk_p->rate = clk_p->parent->rate / 4;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!clkgenb_is_running(power, 6))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_DISP_ID:	/* disp_id */
+		if (powerdown & (1 << 6))
+			clk_p->rate = clk_p->parent->rate / 1024;
+		else {
+			switch ((displaycfg >> 8) & 0x3) {
+			case 0:
+			case 3:
+				clk_p->rate = clk_p->parent->rate / 2;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!clkgenb_is_running(power, 8))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_PIX_SD:	/* pix_sd */
+		/* source is FS0 */
+		if (powerdown & (1 << 7))
+			clk_p->rate = clk_p->parent->rate / 1024;
+		else {
+			switch ((displaycfg >> 10) & 0x3) {
+			case 1:
+				clk_p->rate = clk_p->parent->rate / 4;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!clkgenb_is_running(power, 9))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_GDP3:	/* gdp3_clk */
+		if (fs_sel & 0x1) {
+			/* source is FS1 */
+			clk_p->rate = clk_p->parent->rate;
+		} else {
+			/* source is FS0 */
+			clk_p->rate = clk_p->parent->rate;
+		}
+		if (!clkgenb_is_running(power, 7))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_DSS:
+		clk_p->rate = clk_p->parent->rate;
+		if (!clkgenb_is_running(power, 0))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_PP:
+		clk_p->rate = clk_p->parent->rate;
+		if (!clkgenb_is_running(power, 12))
+			clk_p->rate = 0;
+		break;
+
+	case CLKB_LPC:
+		clk_p->rate = clk_p->parent->rate / 1024;
+		if (!clkgenb_is_running(power, 13))
+			clk_p->rate = 0;
+		break;
 
-	switch (id) {
-	case SH4_CLK_ID: return -1;/* the cpu clock managed via cpufreq-API */
+	default:
+		return CLK_ERR_BAD_PARAMETER;
 	}
 
-	idx = get_xratio_field(value, clk->parent->rate, ratios);
-	if (idx == NO_MORE_RATIO)
-		return -1;
+	return (0);
+}
 
-	data = readl(clkgena_base + CKGA_CLKOPSRC_SWITCH_CFG(num >> 4));
-	src_sel = (data >> ((num & 0xf) * 2)) & 3;
-	switch (src_sel) {
-	case 0: writel(ratios[idx].field, clkgena_base +
-			CKGA_OSC_DIV_CFG(num));
+/* ========================================================================
+   Name:	clkgenb_get_parent
+   Description: Identify parent clock
+   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   ======================================================================== */
+
+static clk_t *clkgenb_get_parent(clk_t *clk_p)
+{
+	U32 sel, fs_sel;
+	U32 displaycfg;
+
+	if (!clk_p)
+		return NULL;
+
+	fs_sel = CLK_READ(CKGB_BASE_ADDRESS + CKGB_FS_SELECT);
+
+	switch (clk_p->id) {
+	case CLKB_REF:		/* What is clockgen B ref clock ? */
+		sel = CLK_READ(CKGB_BASE_ADDRESS + CKGB_CRISTAL_SEL);
+		switch (sel & 0x1) {
+		case 0:
+			clk_p->parent = &clk_clocks[CLK_SATA_OSC];
+			break;
+		case 1:
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
+			break;
+		default:
+			clk_p->parent = NULL;
+			break;
+		}
 		break;
-	case 1: writel(ratios[idx].field, clkgena_base +
-			((num <= 3) ? CKGA_PLL0HS_DIV_CFG(num) :
-			CKGA_PLL0LS_DIV_CFG(num)));
+
+	case CLKB_FS0_CH1:	/* FS0 clock 1 */
+	case CLKB_FS0_CH2:	/* FS0 clock 2 */
+	case CLKB_FS0_CH3:	/* FS0 clock 3 */
+	case CLKB_FS0_CH4:	/* FS0 clock 4 */
+	case CLKB_FS1_CH1:	/* FS1 clock 1 */
+	case CLKB_FS1_CH2:	/* FS1 clock 2 */
+	case CLKB_FS1_CH3:	/* FS1 clock 3 */
+	case CLKB_FS1_CH4:	/* FS1 clock 4 */
+		clk_p->parent = &clk_clocks[CLKB_REF];
+		break;
+
+	case CLKB_TMDS_HDMI:	/* tmds_hdmi_clk */
+	case CLKB_DISP_HD:	/* disp_hd */
+	case CLKB_656:		/* ccir656_clk */
+		clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
 		break;
-	case 2: writel(ratios[idx].field, clkgena_base +
-			CKGA_PLL1_DIV_CFG(num));
+
+	case CLKB_PIX_HD:	/* pix_hd */
+		displaycfg = CLK_READ(CKGB_BASE_ADDRESS + CKGB_DISPLAY_CFG);
+		if (displaycfg & (1 << 14)) {	/* pix_hd source = FSYN1 */
+			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
+		} else {	/* pix_hd source = FSYN0 */
+			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
+		}
+		break;
+
+	case CLKB_DISP_ID:	/* disp_id */
+		clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
 		break;
-	case 3: clk->rate = 0;
+
+	case CLKB_PIX_SD:	/* pix_sd */
+		if (fs_sel & 0x2)
+			/* source is FS1 */
+			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
+		else
+			/* source is FS0 */
+			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
+		break;
+
+	case CLKB_GDP3:	/* gdp3_clk */
+		if (fs_sel & 0x1)
+			/* source is FS1 */
+			clk_p->parent = &clk_clocks[CLKB_FS1_CH1];
+		else
+			/* source is FS0 */
+			clk_p->parent = &clk_clocks[CLKB_FS0_CH1];
+		break;
+
+	case CLKB_DSS:
+		clk_p->parent = &clk_clocks[CLKB_FS0_CH2];
+		break;
+
+	case CLKB_PP:
+		clk_p->parent = &clk_clocks[CLKB_FS1_CH3];
+		break;
+
+	case CLKB_LPC:
+		clk_p->parent = &clk_clocks[CLKB_FS1_CH4];
+		break;
+
+	default:
+		return NULL;
+	}
+
+	return clk_p->parent;
+}
+
+/* ========================================================================
+   Name:	clkgenb_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
+
+static int clkgenb_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	clk_p->parent = clkgenb_get_parent(clk_p);
+	clkgenb_recalc(clk_p);
+
+	return 0;
+}
+
+/******************************************************************************
+CLOCKGEN C (audio)
+******************************************************************************/
+
+/* ========================================================================
+   Name:	clkgenc_recalc
+   Description: Get CKGC clocks frequencies function
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgenc_recalc(clk_t *clk_p)
+{
+	int pe, md, sdiv;
+	struct fsyn_regs *regs;
+	/* Cleaning structure first */
+	clk_p->rate = 0;
+
+	/* What is clockgen C ref clock ? */
+	/* refclockC = Clk->parent->rate / 1000000; */
+
+	if (clk_p->id == CLKC_REF) {
+		clk_p->rate = clk_p->parent->rate;
 		return 0;
 	}
-	clk->rate = clk->parent->rate / ratios[idx].ratio ;
+
+	regs = &clkgenc_regs[clk_p->id - CLKC_FS0_CH1];
+
+	pe = CLK_READ(CKGC_BASE_ADDRESS + regs->pe);
+	md = CLK_READ(CKGC_BASE_ADDRESS + regs->md);
+	sdiv = CLK_READ(CKGC_BASE_ADDRESS + regs->sdiv);
+	clk_p->rate = clk_fsyn_get_rate(clk_p->parent->rate, pe, md, sdiv);
+	return (0);
+}
+
+/* ========================================================================
+   Name:	clkgenc_identify_parent
+   Description: Identify parent clock
+   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   ======================================================================== */
+
+static clk_t *clkgenc_identify_parent(clk_t *clk_p)
+{
+	U32 sel;
+
+	if (!clk_p)
+		return (NULL);
+
+	switch (clk_p->id) {
+	case CLKC_REF:
+		sel = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG) >> 23;
+		switch (sel & 0x1) {
+		case 0:
+			clk_p->parent = &clk_clocks[CLK_SATA_OSC];
+			break;
+		case 1:
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
+			break;
+		default:
+			clk_p->parent = NULL;
+			break;
+		}
+		break;
+
+	case CLKC_FS0_CH1:
+	case CLKC_FS0_CH2:
+	case CLKC_FS0_CH3:
+	case CLKC_FS0_CH4:
+		clk_p->parent = &clk_clocks[CLKC_REF];
+		break;
+
+	default:
+		clk_p->parent = NULL;
+		break;
+	}
+
+	return (clk_p->parent);
+}
+
+/* ========================================================================
+   Name:	clkgenc_set_parent
+   Description: Set parent clock
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
+
+static int clkgenc_set_parent(clk_t *clk_p, clk_t *parent_p)
+{
+	U32 sel, data;
+
+	if (!clk_p || !parent_p)
+		return (CLK_ERR_BAD_PARAMETER);
+
+	if (clk_p->id == CLKC_REF) {
+		switch (parent_p->id) {
+		case CLK_SATA_OSC:
+			sel = 0;
+			break;
+		case CLK_SYSALT:
+			sel = 1;
+			break;
+		default:
+			return CLK_ERR_BAD_PARAMETER;
+		}
+		data =
+		    CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG) & ~(0x3 << 23);
+		CLK_WRITE(CKGC_BASE_ADDRESS + CKGC_FS0_CFG, data | (sel << 23));
+		clk_p->parent = parent_p;
+	} else
+		clk_p->parent = &clk_clocks[CLKC_REF];
+
+	return CLK_ERR_BAD_PARAMETER;
+}
+
+/* ========================================================================
+   Name:	clkgenc_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
+
+static int clkgenc_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	clk_p->parent = clkgenc_identify_parent(clk_p);
+	clkgenc_recalc(clk_p);
+
 	return 0;
 }
 
-static struct clk_ops clkgena_clk_ops = {
-	.init		= clkgena_clk_init,
-	.recalc		= clkgena_clk_recalc,
-	.set_rate	= clkgena_clk_setrate,
-};
+/******************************************************************************
+CLOCKGEN D (LMI)
+******************************************************************************/
 
-#define CLKGENA_CLK(_id, _num, _name)					\
-{									\
-	.name	= _name,						\
-	.flags	= CLK_ALWAYS_ENABLED | 					\
-			CLK_RATE_PROPAGATES,				\
-	.ops	= &clkgena_clk_ops,					\
-	.id	= _id,							\
-	.private_data = (void *)&(struct clkgenaclk)			\
-		{							\
-		.num = (_num),						\
-		},							\
- }
-
-struct clk clkgenaclks[] = {
-	CLKGENA_CLK(IC_STNOC_ID, 0, "ic_STNOC"),
-	CLKGENA_CLK(FDMA0_ID, 1, "fdma0"),
-	CLKGENA_CLK(FDMA1_ID, 2, "fdma1"),
-	CLKGENA_CLK(SH4_CLK_ID,4, "sh4_clk"),			/* ls[0] */
-	CLKGENA_CLK(SH4_498_CLK_ID, 5, "sh4_clk_498"),		/* ls[1] */
-	CLKGENA_CLK(LX_DMU_ID, 6, "lx_dmu_cpu"),		/* ls[2] */
-	CLKGENA_CLK(LD_AUD_ID, 7, "lx_aud_cpu"),		/* ls[3] */
-	CLKGENA_CLK(IC_BDISP_200_ID, 8, "ic_bdisp_200"),	/* ls[4] */
-	CLKGENA_CLK(IC_DISP_200_ID, 9, "ic_disp_200"),		/* ls[5] */
-	CLKGENA_CLK(IC_IF_100_ID, 10, "ic_if_100"),		/* ls[6] */
-	CLKGENA_CLK(DISP_PIPE_200_ID, 11, "disp_pipe_200"),	/* ls[7] */
-	CLKGENA_CLK(BLIT_PROC_ID, 12, "blit_proc"),		/* ls[8] */
-	CLKGENA_CLK(ETH_PHY_ID, 13, "ethernet_phy"),		/* ls[9] */
-	CLKGENA_CLK(PCI_ID, 14, "pci"),				/* ls[10] */
-	CLKGENA_CLK(EMI_ID, 15, "emi_master"),			/* ls[11] */
-	CLKGENA_CLK(IC_COMPO_200_ID, 16, "ic_compo_200"),	/* ls[12] */
-	CLKGENA_CLK(IC_IF_200_ID, 17, "ic_if_200"),		/* ls[13] */
-};
+/* ========================================================================
+   Name:	clkgend_recalc
+   Description: Get CKGD (LMI) clocks frequencies (in Hz)
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgend_recalc(clk_t *clk_p)
+{
+	U32 data, rdiv, ddiv;
+
+	/* Cleaning structure first */
+	clk_p->rate = 0;
+
+	if (clk_p->id == CLKD_REF) {
+		clk_p->rate = clk_p->parent->rate;
+	} else if (clk_p->id == CLKD_LMI2X) {
+		rdiv = SYSCONF_READ(SYS_CFG, 11, 9, 11);
+		ddiv = SYSCONF_READ(SYS_CFG, 11, 1, 8);
+		clk_p->rate =
+		    (((clk_p->parent->rate / 1000000) * ddiv) / rdiv) * 1000000;
+	} else
+		return CLK_ERR_BAD_PARAMETER;	/* Unknown clock */
+
+	return 0;
+}
+
+/* ========================================================================
+   Name:	clkgend_get_parent
+   Description: Identify parent clock
+   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   ======================================================================== */
+
+static clk_t *clkgend_get_parent(clk_t *clk_p)
+{
+	U32 sel;
+
+	if (!clk_p)
+		return (NULL);
+
+	if (clk_p->id == CLKD_REF) {
+		sel = SYSCONF_READ(SYS_CFG, 40, 0, 0);
+		if (sel)
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
+		else
+			clk_p->parent = &clk_clocks[CLK_SATA_OSC];
+	} else
+		clk_p->parent = &clk_clocks[CLKD_REF];
 
-/* SH4 generic clocks ------------------------------------------------------ */
+	return clk_p->parent;
+}
+
+/* ========================================================================
+   Name:	clkgend_set_parent
+   Description: Set parent clock
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
 
-static void generic_clk_recalc(struct clk *clk)
+static int clkgend_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	clk->rate = clk->parent->rate;
+	U32 sel, data;
+
+	if (!clk_p || !parent_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id == CLKD_REF) {
+		switch (parent_p->id) {
+		case CLK_SATA_OSC:
+			sel = 0;
+			break;
+		case CLK_SYSALT:
+			sel = 1;
+			break;
+		default:
+			return CLK_ERR_BAD_PARAMETER;
+		}
+
+		SYSCONF_WRITE(SYS_CFG, 40, 0, 0, sel);
+		clk_p->parent = parent_p;
+	} else
+		clk_p->parent = &clk_clocks[CLKD_REF];
+
+	return 0;
 }
 
-static struct clk_ops generic_clk_ops = {
-	.recalc		= generic_clk_recalc,
-};
+/* ========================================================================
+   Name:	clkgend_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
 
-static struct clk generic_module_clk = {
-	.name		= "module_clk",
-	.parent		= &clkgenaclks[IC_IF_100_ID], /* ic_if_100 */
-	.flags		= CLK_ALWAYS_ENABLED,
-	.ops		= &generic_clk_ops,
-};
+static int clkgend_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
 
-static struct clk generic_comms_clk = {
-	.name		= "comms_clk",
-	.parent		= &clkgenaclks[IC_IF_100_ID], /* ic_if_100 */
-	.flags		= CLK_ALWAYS_ENABLED,
-	.ops		= &generic_clk_ops,
-};
+	clk_p->parent = clkgend_get_parent(clk_p);
+	clkgend_recalc(clk_p);
 
-/* Clockgen D clocks ------------------------------------------------------- */
+	return 0;
+}
+
+/******************************************************************************
+CLOCKGEN E (USB)
+******************************************************************************/
 
-static void clkgend_clk_init(struct clk *clk)
+/* ========================================================================
+   Name:	clkgene_recalc
+   Description: Get CKGE (USB) clocks frequencies (in Hz)
+   Returns:     0=NO error
+   ======================================================================== */
+
+static int clkgene_recalc(clk_t *clk_p)
 {
-	int clk_sel = sysconf_read(clkgend_clk_sel);
-	int ddiv = sysconf_read(clkgend_ddiv);
-	int rdiv = sysconf_read(clkgend_rdiv);
+	/* Cleaning structure first */
+	clk_p->rate = 0;
 
-	if (rdiv == 0)
-		clk->rate = 0;
+	if (clk_p->id == CLKE_REF)
+		clk_p->rate = clk_p->parent->rate;
 	else
-		clk->rate = (clkin[clk_sel] * ddiv) / rdiv;
+		return CLK_ERR_BAD_PARAMETER;	/* Unknown clock */
+
+	return 0;
 }
 
-static struct clk_ops clkgend_clk_ops = {
-	.init		= clkgend_clk_init,
-};
+/* ========================================================================
+   Name:	clkgene_get_parent
+   Description: Identify parent clock
+   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   ======================================================================== */
 
-static struct clk clkgend_clk = {
-	.name		= "lmi2x",
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-	.ops		= &clkgend_clk_ops,
-};
+static clk_t *clkgene_get_parent(clk_t *clk_p)
+{
+	U32 sel;
 
-/* ------------------------------------------------------------------------- */
+	if (!clk_p)
+		return (NULL);
 
-int __init clk_init(void)
+	if (clk_p->id == CLKE_REF) {
+		sel = SYSCONF_READ(SYS_CFG, 40, 2, 2);
+		if (sel)
+			clk_p->parent = &clk_clocks[CLK_SYSALT];
+		else
+			clk_p->parent = &clk_clocks[CLK_SATA_OSC];
+	} else
+		clk_p->parent = &clk_clocks[CLKE_REF];
+
+	return (clk_p->parent);
+}
+
+/* ========================================================================
+   Name:	clkgene_set_parent
+   Description: Change parent clock
+   Returns:     Pointer on parent 'clk_t' structure, or NULL (none or error)
+   ======================================================================== */
+
+static int clkgene_set_parent(clk_t *clk_p, clk_t *parent_p)
 {
-	int i, ret;
+	U32 data, sel;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	if (clk_p->id == CLKE_REF) {
+		switch (parent_p->id) {
+		case CLK_SATA_OSC:
+			sel = 0;
+			break;
+		case CLK_SYSALT:
+			sel = 1;
+			break;
+		default:
+			return CLK_ERR_BAD_PARAMETER;
+		}
+
+		SYSCONF_WRITE(SYS_CFG, 40, 2, 2, sel);
+		clk_p->parent = parent_p;
+	} else
+		return CLK_ERR_BAD_PARAMETER;
+
+	return (0);
+}
 
-	/* Clockgen A */
+/* ========================================================================
+   Name:	clkgene_init
+   Description: Read HW status to initialize 'clk_t' structure.
+   Returns:     'clk_err_t' error code.
+   ======================================================================== */
 
-	clkgena_clkosc_sel_sc = sysconf_claim(SYS_STA, 1, 0, 0, "clkgena");
-	clkgena_base = ioremap(CLOCKGENA_BASE_ADDR, 0x50);
-	clkgenb_base = ioremap(CLOCKGENB_BASE_ADDR, 0xc00);
+static int clkgene_init(clk_t *clk_p)
+{
+	if (!clk_p)
+		return (CLK_ERR_BAD_PARAMETER);
 
-	ret = clk_register(&clkgena_clk_osc);
-	clk_enable(&clkgena_clk_osc);
+	clk_p->parent = clkgene_get_parent(clk_p);
+	clkgene_recalc(clk_p);
 
-	for (i = 0; i < 2; i++) {
-		ret |= clk_register(&pllclks[i].clk);
-		clk_enable(&pllclks[i].clk);
-	}
+	return (0);
+}
 
-	for (i = 0; i < ARRAY_SIZE(clkgenaclks); i++) {
-		ret |= clk_register(&clkgenaclks[i]);
-		clk_enable(&clkgenaclks[i]);
-	}
+static int clkgenc_set_rate(clk_t *clk_p, U32 freq)
+{
+	int md, pe, sdiv;
+	U32 ref;
+	struct fsyn_regs *regs;
+	U32 reg_value = 0;
+	static U32 set_rate_table[] = { 0x06, 0x0A, 0x012, 0x022 };
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	ref = clk_p->parent->rate / 1000000;
 
-	ret = clk_register(&generic_module_clk);
-	clk_enable(&generic_module_clk);
-	ret = clk_register(&generic_comms_clk);
-	clk_enable(&generic_comms_clk);
+	/* Computing FSyn params. Should be common function with FSyn type */
+	if ((clk_fsyn_get_params(ref, freq, &md, &pe, &sdiv)) != 0)
+		return CLK_ERR_BAD_PARAMETER;
 
-	/* Propagate the clk osc value down */
-	clk_set_rate(&clkgena_clk_osc, clk_get_rate(&clkgena_clk_osc));
-	clk_put(&clkgena_clk_osc);
+	reg_value = CLK_READ(CKGC_BASE_ADDRESS + CKGC_FS0_CFG);
 
-	/* Clockgen D */
+	regs = &clkgenc_regs[clk_p->id - CLKC_FS0_CH1];
 
-	clkgend_clk_sel = sysconf_claim(SYS_CFG, 40, 0, 0, "clkgend");
-	clkgend_ddiv = sysconf_claim(SYS_CFG, 11, 1, 8, "clkgend");
-	clkgend_rdiv = sysconf_claim(SYS_CFG, 11, 9, 11, "clkgend");
+	reg_value |= set_rate_table[clk_p->id - CLKC_FS0_CH1];
 
-	ret = clk_register(&clkgend_clk);
-	clk_enable(&clkgend_clk);
+	/* Select FS clock only for the clock specified */
+	CLK_WRITE(CKGC_BASE_ADDRESS + CKGC_FS0_CFG, reg_value);
+
+	CLK_WRITE(CKGC_BASE_ADDRESS + regs->pe, pe);
+	CLK_WRITE(CKGC_BASE_ADDRESS + regs->md, md);
+	CLK_WRITE(CKGC_BASE_ADDRESS + regs->sdiv, sdiv);
+	CLK_WRITE(CKGC_BASE_ADDRESS + regs->prog, 0x01);
+	CLK_WRITE(CKGC_BASE_ADDRESS + regs->prog, 0x00);
+
+	clk_p->rate = freq;
+	return 0;
+
+}
+
+static U32 clkgenc_enable_mask[] = { 0x440, 0x880, 0x1100, 0x2200 };
+
+static int clkgenc_enable(clk_t *clk_p)
+{
+	U32 reg_value = 0;
+
+	if (!clk_p)
+		return CLK_ERR_BAD_PARAMETER;
+
+	reg_value = CLK_READ(CKGC_BASE_ADDRESS);
+
+	reg_value |= clkgenc_enable_mask[clk_p->id - CLKC_FS0_CH1];
+
+	CLK_WRITE(CKGC_BASE_ADDRESS, reg_value);
+	if ((reg_value & 0x1DC0) && !(reg_value & 0x4000)) {
+		reg_value = reg_value | 0x4000;
+		CLK_WRITE(CKGC_BASE_ADDRESS, reg_value);
+	}
+	return 0;
+
+}
+
+static int clkgenc_disable(clk_t *clk_p)
+{
+	U32 reg_value = 0;
+
+	reg_value = CLK_READ(CKGC_BASE_ADDRESS);
+	reg_value &= ~clkgenc_enable_mask[clk_p->id - CLKC_FS0_CH1];
+
+	CLK_WRITE(CKGC_BASE_ADDRESS, reg_value);
+	if (!(reg_value & 0x1DC0)) {
+		reg_value = reg_value & 0xFFFFBFFF;
+		CLK_WRITE(CKGC_BASE_ADDRESS, reg_value);
+	}
+	return 0;
 
-	return ret;
 }
diff --git a/arch/sh/kernel/cpu/sh4/clock-stx7141.h b/arch/sh/kernel/cpu/sh4/clock-stx7141.h
new file mode 100644
index 0000000..1f7ede2
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh4/clock-stx7141.h
@@ -0,0 +1,87 @@
+/************************************************************************
+ * CLOCK driver
+ * Low Level API - 7141 specific implementation
+ * (C) F. Charpentier, 2008-09
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+************************************************************************/
+
+/* Clocks identifier list */
+typedef enum
+{
+    /* Top level clocks */
+    CLK_SATA_OSC,	    /* SATA OSC */
+    CLK_SYSALT,	      /* SYSCLKINALT Optional alternate input clock */
+
+    /* Clockgen A */
+    CLKA_REF,	   /* Clockgen A reference clock */
+    CLKA_OSC,
+    CLKA_PLL0HS,	/* PLL0 HS output */
+    CLKA_PLL0LS,	/* PLL0 LS output */
+    CLKA_PLL1,
+
+    CLKA_IC_STNOC,
+    CLKA_FDMA0,
+    CLKA_FDMA1,
+    CLKA_FDMA2,
+    CLKA_SH4_ICK,
+    CLKA_SH4_ICK_498,
+    CLKA_LX_DMU_CPU,
+    CLKA_LX_AUD_CPU,
+    CLKA_IC_BDISP_200,
+    CLKA_IC_DISP_200,
+    CLKA_IC_IF_100,
+    CLKA_DISP_PIPE_200,
+    CLKA_BLIT_PROC,
+    CLKA_ETH_PHY,
+    CLKA_PCI,
+    CLKA_EMI_MASTER,
+    CLKA_IC_COMPO_200,
+    CLKA_IC_IF_200,
+
+    /* Clockgen B */
+    CLKB_REF,	   /* Clockgen B reference clock */
+    CLKB_FS0_CH1,
+    CLKB_FS0_CH2,
+    CLKB_FS0_CH3,
+    CLKB_FS0_CH4,
+    CLKB_FS1_CH1,
+    CLKB_FS1_CH2,
+    CLKB_FS1_CH3,
+    CLKB_FS1_CH4,
+
+    CLKB_TMDS_HDMI,
+
+    CLKB_PIX_HD,
+    CLKB_DISP_HD,
+    CLKB_656,
+    CLKB_GDP3,
+    CLKB_DISP_ID,
+    CLKB_PIX_SD,
+
+    CLKB_PP,
+    CLKB_150,
+    CLKB_LPC,
+    CLKB_DSS,
+    CLKB_PIP,	   /* NOT in clockgenB.
+		    * Sourced from clk_disp_sd or clk_disp_hd
+		    */
+
+    /* Clockgen C (Audio) */
+    CLKC_REF,
+    CLKC_FS0_CH1,
+    CLKC_FS0_CH2,
+    CLKC_FS0_CH3,
+    CLKC_FS0_CH4,
+
+    /* Clockgen D */
+    CLKD_REF,	   /* Clockgen D reference clock */
+    CLKD_LMI2X,
+
+    /* Clockgen E = USB PHY */
+    CLKE_REF,	   /* Clockgen E reference clock */
+/*
+ * Not used in Linux
+ *   CLK_LAST	    * Keep this as last clock ID. Used to get number of clocks
+ */
+} clk_id_t;
-- 
1.6.0.6

