From 5b614b5b8952c5187087ceecadb431460c457ef3 Mon Sep 17 00:00:00 2001
From: Angelo CASTELLO <angelo.castello@st.com>
Date: Tue, 30 Sep 2008 10:38:06 +0200
Subject: [PATCH] lirc: LiRC 0.8.3 drivers and core integration.

Integrated latest stable LiRC drivers and core interface
in our tree. Reference project at www.lirc.org.
Minimal changes has been done on all drivers trying to
keep it as it is.

Signed-off-by: Angelo Castello <angelo.castello@st.com>
Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
---
 drivers/char/lirc/Makefile           |    2 +-
 drivers/char/lirc/commandir.c        | 1520 ++++++++++++++++++++++++++++++++++
 drivers/char/lirc/commandir.h        |   41 +
 drivers/char/lirc/kcompat.h          |  103 ++-
 drivers/char/lirc/lirc_atiusb.c      |  600 ++++++++------
 drivers/char/lirc/lirc_bt829.c       |  102 ++--
 drivers/char/lirc/lirc_cmdir.c       |  633 +++++++-------
 drivers/char/lirc/lirc_cmdir.h       |   11 +-
 drivers/char/lirc/lirc_dev.c         |  447 ++++++-----
 drivers/char/lirc/lirc_dev.h         |   83 +-
 drivers/char/lirc/lirc_gpio.c        |  343 +++++----
 drivers/char/lirc/lirc_i2c.c         |  354 +++++----
 drivers/char/lirc/lirc_igorplugusb.c |  351 +++++----
 drivers/char/lirc/lirc_imon.c        | 1155 ++++++++++++++------------
 drivers/char/lirc/lirc_it87.c        |  538 ++++++-------
 drivers/char/lirc/lirc_mceusb.c      |  679 ++++++++--------
 drivers/char/lirc/lirc_mceusb2.c     |  682 +++++++++-------
 drivers/char/lirc/lirc_parallel.c    |  696 ++++++++--------
 drivers/char/lirc/lirc_sasem.c       |  811 ++++++++++---------
 drivers/char/lirc/lirc_serial.c      |  898 ++++++++++----------
 drivers/char/lirc/lirc_sir.c         |  577 ++++++-------
 drivers/char/lirc/lirc_streamzap.c   |  574 ++++++-------
 drivers/char/lirc/lirc_ttusbir.c     |  206 +++--
 include/linux/lirc.h                 |    1 +
 24 files changed, 6668 insertions(+), 4739 deletions(-)
 create mode 100644 drivers/char/lirc/commandir.c
 create mode 100644 drivers/char/lirc/commandir.h

diff --git a/drivers/char/lirc/Makefile b/drivers/char/lirc/Makefile
index 9abd9dd..f58a73e 100644
--- a/drivers/char/lirc/Makefile
+++ b/drivers/char/lirc/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_LIRC_SUPPORT) += lirc_dev.o
 obj-$(CONFIG_LIRC_ATIUSB) += lirc_atiusb.o
 obj-$(CONFIG_LIRC_BT829) += lirc_bt829.o
-obj-$(CONFIG_LIRC_CMDIR) += lirc_cmdir.o
+obj-$(CONFIG_LIRC_CMDIR) += lirc_cmdir.o commandir.o
 obj-$(CONFIG_LIRC_GPIO) += lirc_gpio.o
 obj-$(CONFIG_LIRC_I2C) += lirc_i2c.o
 obj-$(CONFIG_LIRC_IGORPLUGUSB) += lirc_igorplugusb.o
diff --git a/drivers/char/lirc/commandir.c b/drivers/char/lirc/commandir.c
new file mode 100644
index 0000000..905e4d5
--- /dev/null
+++ b/drivers/char/lirc/commandir.c
@@ -0,0 +1,1520 @@
+
+/*
+ *
+ *	Hardware Driver for COMMANDIR USB Transceiver
+ *	2005-2007 InnovationOne - Matt Bodkin, Evelyn Yeung
+ *
+ *	Version 1.4.2
+ *	For 2.4.* or 2.6.* kernel versions
+ *	Based on the USB Skeleton driver, versions 0.7 and 2.0
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/smp_lock.h>
+#include "commandir.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/poll.h>
+#include <linux/fcntl.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/devfs_fs_kernel.h>
+#else
+#include <linux/kref.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+#include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
+#endif
+
+#define DRIVER_VERSION "v1.1.2"
+#define DRIVER_AUTHOR "Evelyn Yeung, InnovationOne"
+#define DRIVER_DESC "CommandIR USB Transceiver Driver"
+
+#define USB_CMDIR_VENDOR_ID	0x10c4
+#define USB_CMDIR_PRODUCT_ID	0x0003
+#define USB_CMDIR_MINOR_BASE	192
+
+/* table of devices that work with this driver */
+static struct usb_device_id cmdir_table [] =
+{
+	{ USB_DEVICE(USB_CMDIR_VENDOR_ID, USB_CMDIR_PRODUCT_ID) },
+	{ }			/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, cmdir_table);
+
+static int cmdir_open(struct inode *inode, struct file *file);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static void *cmdir_probe(struct usb_device *dev, unsigned int ifnum,
+			  const struct usb_device_id *id);
+static int cmdir_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg);
+static void cmdir_disconnect(struct usb_device *dev, void *ptr);
+#else
+static int cmdir_probe(struct usb_interface *interface,
+		       const struct usb_device_id *id);
+static void cmdir_disconnect(struct usb_interface *interface);
+#endif
+static int cmdir_release(struct inode *inode, struct file *file);
+static int cmdir_check(int device_num);
+static void init_cmdir_var(int device_num);
+static void reset_cmdir(int device_num);
+static void update_cmdir_string(int device_num);
+static void print_cmdir(int device_num);
+static ssize_t cmdir_file_read(struct file *file, char *buffer,
+			       size_t count, loff_t *ppos);
+ssize_t cmdir_read(unsigned char *buffer, size_t count);
+static ssize_t cmdir_file_write(struct file *file, const char *buffer,
+				size_t count, loff_t *ppos);
+int cmdir_write(unsigned char *buffer, int count, void *callback_fct, int u);
+int write_core(unsigned char *buffer, int count,
+	       void *callback_fct, int device_num);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static void cmdir_write_bulk_callback(struct urb *urb);
+#else
+static void cmdir_write_bulk_callback(struct urb *urb, struct pt_regs *regs);
+#endif
+int set_tx_channels(unsigned int next_tx);
+
+int add_cmdir_queue(unsigned char *buffer, int count,
+		    void *callback_vct, int usecdelay);
+int cmdir_write_queue(unsigned char *buffer, int count, void *callback_vct);
+int send_queue(void);
+int wait_to_tx(int usecs);
+
+/* circular packet queue */
+unsigned char ourbuffers[QUEUELENGTH][64];
+int waitusecs[QUEUELENGTH];
+int ourbufferlengths[QUEUELENGTH];
+int nexttosend;
+int nexttofill;
+int send_status = SEND_IDLE;
+int last_tx_sec;
+int last_tx_usec;
+
+static int curTXFill;
+struct timeval tp;
+
+int debug_commandir;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+
+/* Structure to hold all of our device specific stuff */
+struct usb_skel {
+	struct usb_device *udev; /* save off the usb device pointer */
+	struct usb_interface *interface; /* the interface for this device */
+	devfs_handle_t devfs; /* devfs device node */
+	unsigned char minor; /* the starting minor number */
+	unsigned char num_ports; /* the number of ports this device has */
+	char num_interrupt_in; /* number of interrupt in endpoints */
+	char num_bulk_in; /* number of bulk in endpoints */
+	char num_bulk_out; /* number of bulk out endpoints */
+
+	unsigned char *bulk_in_buffer; /* the buffer to receive data */
+	int bulk_in_size; /* the size of the receive buffer */
+	__u8 bulk_in_endpointAddr; /* the address of the bulk in endpoint */
+
+	unsigned char *bulk_out_buffer; /* the buffer to send data */
+	int bulk_out_size; /* the size of the send buffer */
+	struct urb *write_urb; /* the urb used to send data */
+	__u8 bulk_out_endpointAddr; /* the address of the bulk out endpoint */
+
+	struct tq_struct tqueue; /* task queue for line discipline waking up */
+	int open_count; /* number of times this port has been opened */
+	struct semaphore sem; /* locks this structure */
+};
+
+extern devfs_handle_t usb_devfs_handle; /* the global usb devfs handle */
+
+/* array of pointers to our devices that are currently connected */
+static struct usb_skel *minor_table[MAX_DEVICES];
+/* lock to protect the minor_table structure */
+static DECLARE_MUTEX(minor_table_mutex);
+
+static struct file_operations cmdir_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+	.owner		= THIS_MODULE,
+#endif /* kernel < 2.6.16 */
+#endif /* kernel >= 2.6.0 */
+	.read		= cmdir_file_read,
+	.write		= cmdir_file_write,
+	.ioctl		= cmdir_ioctl,
+	.open		= cmdir_open,
+	.release	= cmdir_release,
+};
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver cmdir_driver = {
+	.name		= "commandir",
+	.probe		= cmdir_probe,
+	.disconnect	= cmdir_disconnect,
+	.fops		= &cmdir_fops,
+	.minor		= USB_CMDIR_MINOR_BASE,
+	.id_table	= cmdir_table,
+};
+
+#else /* kernel >= 2.6 */
+
+/* Structure to hold all of our device specific stuff */
+struct usb_skel {
+	struct usb_device *udev; /* the usb device for this device */
+	struct usb_interface *interface; /* the interface for this device */
+	unsigned char *bulk_in_buffer; /* the buffer to receive data */
+	size_t bulk_in_size; /* the size of the receive buffer */
+	__u8 bulk_in_endpointAddr; /* the address of the bulk in endpoint */
+	__u8 bulk_out_endpointAddr; /* the address of the bulk out endpoint */
+	struct kref kref;
+};
+#define to_skel_dev(d) container_of(d, struct usb_skel, kref)
+
+static struct file_operations cmdir_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+	.owner =	THIS_MODULE,
+#endif /* kernel < 2.6.16 */
+#endif /* kernel >= 2.6.0 */
+	.read =		cmdir_file_read,
+	.write =	cmdir_file_write,
+	.open =		cmdir_open,
+	.release =	cmdir_release,
+};
+
+/* usb class driver info in order to get a minor number from the usb core,
+ * and to have the device registered with devfs and the driver core */
+static struct usb_class_driver cmdir_class = {
+	.name =		"usb/commandir%d",
+	.fops =		&cmdir_fops,
+	/* .mode =	S_IFCHR | S_IRUSR | S_IWUSR |
+	 *		S_IRGRP | S_IWGRP | S_IROTH, */
+	.minor_base =	USB_CMDIR_MINOR_BASE,
+};
+
+static struct usb_driver cmdir_driver = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+	.owner =	THIS_MODULE,
+#endif /* kernel < 2.6.16 */
+#endif /* kernel >= 2.6.0 */
+	.name =		"commandir",
+	.probe =	cmdir_probe,
+	.disconnect =	cmdir_disconnect,
+	.id_table =	cmdir_table,
+};
+
+#endif /* kernel < 2.6.0 */
+
+static int lcd_device;
+static int rx_device;
+static int def_device;
+
+#define DEFAULT_TRANSMITTERS 0x0F
+static unsigned int transmitters = DEFAULT_TRANSMITTERS;
+static unsigned int next_transmitters = DEFAULT_TRANSMITTERS;
+
+#define CMDIR_VAR_LEN 68
+static char cmdir_var[] =
+"COMMANDIRx:\n TX Enabled: 1, 2, 3, 4\n RX: commandirx\n LCD: commandirx";
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static inline void cmdir_delete(struct usb_skel *dev)
+{
+	minor_table[dev->minor] = NULL;
+	if (dev->bulk_in_buffer != NULL)
+		kfree(dev->bulk_in_buffer);
+	if (dev->bulk_out_buffer != NULL)
+		kfree(dev->bulk_out_buffer);
+	if (dev->write_urb != NULL)
+		usb_free_urb(dev->write_urb);
+	kfree(dev);
+}
+#else
+static void cmdir_delete(struct kref *kref)
+{
+	struct usb_skel *dev = to_skel_dev(kref);
+
+	usb_put_dev(dev->udev);
+	kfree(dev->bulk_in_buffer);
+	kfree(dev);
+}
+#endif
+
+static int __init usb_cmdir_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&cmdir_driver);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	if (result < 0) {
+		err("usb_register failed for the "__FILE__
+		    " driver. Error number %d", result);
+		return -1;
+	}
+
+	info(DRIVER_DESC " " DRIVER_VERSION);
+
+	return 0;
+#else
+	if (result)
+		err("usb_register failed. Error number %d", result);
+
+	return result;
+#endif
+}
+
+static int cmdir_open(struct inode *inode, struct file *file)
+{
+	struct usb_skel *dev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 0)
+	struct usb_interface *interface;
+#endif
+	int subminor;
+	int retval = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	subminor = MINOR(inode->i_rdev) - USB_CMDIR_MINOR_BASE;
+	if ((subminor < 0) || (subminor >= MAX_DEVICES))
+		return -ENODEV;
+	MOD_INC_USE_COUNT;
+
+	/* lock our minor table and get our local data for this minor */
+	down(&minor_table_mutex);
+	dev = minor_table[subminor];
+	if (dev == NULL) {
+		up(&minor_table_mutex);
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+
+	down(&dev->sem);	/* lock this device */
+	up(&minor_table_mutex);	/* unlock the minor table */
+	++dev->open_count;	/* increment our usage count for the driver */
+	file->private_data = dev; /* save object in file's private structure */
+	up(&dev->sem);		/* unlock this device */
+
+	return retval;
+#else
+	subminor = iminor(inode);
+	interface = usb_find_interface(&cmdir_driver, subminor);
+	if (!interface) {
+		err("%s - error, can't find device for minor %d",
+		     __FUNCTION__, subminor);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	dev = usb_get_intfdata(interface);
+	if (!dev) {
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	kref_get(&dev->kref);	/* increment our usage count for the device */
+	file->private_data = dev; /* save object in file's private structure */
+
+exit:
+	return retval;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static void *cmdir_probe(struct usb_device *udev, unsigned int ifnum,
+			 const struct usb_device_id *id)
+{
+	struct usb_skel *dev = NULL;
+	struct usb_interface *interface;
+	struct usb_interface_descriptor *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	int minor;
+	int buffer_size;
+	int i;
+	char name[10];
+
+	/* See if the device offered us matches what we can accept */
+	if ((udev->descriptor.idVendor != USB_CMDIR_VENDOR_ID) ||
+	    (udev->descriptor.idProduct != USB_CMDIR_PRODUCT_ID))
+		return NULL;
+
+	/* select a "subminor" number (part of a minor number) */
+	down(&minor_table_mutex);
+	for (minor = 0; minor < MAX_DEVICES; ++minor) {
+		if (minor_table[minor] == NULL)
+			break;
+	}
+	if (minor >= MAX_DEVICES) {
+		info("Too many devices plugged in, cannot handle this device.");
+		goto exit;
+	}
+
+	/* allocate memory for our device state and intialize it */
+	dev = kmalloc(sizeof(struct usb_skel), GFP_KERNEL);
+	if (dev == NULL) {
+		err("Out of memory");
+		goto exit;
+	}
+	memset(dev, 0x00, sizeof(*dev));
+	minor_table[minor] = dev;
+
+	interface = &udev->actconfig->interface[ifnum];
+
+	init_MUTEX(&dev->sem);
+	dev->udev = udev;
+	dev->interface = interface;
+	dev->minor = minor;
+
+	/* set up and check the endpoint information */
+	iface_desc = &interface->altsetting[0];
+	for (i = 0; i < iface_desc->bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i];
+
+		if ((endpoint->bEndpointAddress & 0x80) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_in_size = buffer_size;
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!dev->bulk_in_buffer) {
+				err("Couldn't allocate bulk_in_buffer");
+				goto error;
+			}
+		}
+
+		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			dev->write_urb = usb_alloc_urb(0);
+			if (!dev->write_urb) {
+				err("No free urbs available");
+				goto error;
+			}
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_out_size = buffer_size;
+			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!dev->bulk_out_buffer) {
+				err("Couldn't allocate bulk_out_buffer");
+				goto error;
+			}
+			FILL_BULK_URB(dev->write_urb, udev,
+				      usb_sndbulkpipe(udev,
+					endpoint->bEndpointAddress),
+				      dev->bulk_out_buffer, buffer_size,
+				      cmdir_write_bulk_callback, dev);
+		}
+	}
+
+	/* initialize the devfs node for this device and register it */
+	sprintf(name, "commandir%d", dev->minor);
+
+	dev->devfs = devfs_register(usb_devfs_handle, name,
+				     DEVFS_FL_DEFAULT, USB_MAJOR,
+				     USB_CMDIR_MINOR_BASE + dev->minor,
+				     S_IFCHR | S_IRUSR | S_IWUSR |
+				     S_IRGRP | S_IWGRP | S_IROTH,
+				     &cmdir_fops, NULL);
+
+	/* let the user know what node this device is now attached to */
+	info("CommandIR USB device now attached to commandir%d", dev->minor);
+
+	/* should reset just the one that was plugged in */
+	reset_cmdir(minor);
+
+	goto exit;
+
+error:
+	cmdir_delete(dev);
+	dev = NULL;
+
+exit:
+	up(&minor_table_mutex);
+	return dev;
+}
+#else
+static int cmdir_probe(struct usb_interface *interface,
+		       const struct usb_device_id *id)
+{
+	struct usb_skel *dev = NULL;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	size_t buffer_size;
+
+	int i;
+	int retval = -ENOMEM;
+	int minor;
+
+	/* allocate memory for our device state and initialize it */
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL) {
+		err("Out of memory");
+		goto error;
+	}
+	memset(dev, 0x00, sizeof(*dev));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
+	kref_init(&dev->kref, cmdir_delete);
+#else
+	kref_init(&dev->kref);
+#endif
+	dev->udev = usb_get_dev(interface_to_usbdev(interface));
+	dev->interface = interface;
+
+	/* set up the endpoint information */
+	/* use only the first bulk-in and bulk-out endpoints */
+	iface_desc = interface->cur_altsetting;
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		if (!dev->bulk_in_endpointAddr &&
+		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+					== USB_ENDPOINT_XFER_BULK)) {
+			/* we found a bulk in endpoint */
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_in_size = buffer_size;
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!dev->bulk_in_buffer) {
+				err("Could not allocate bulk_in_buffer");
+				goto error;
+			}
+		}
+
+		if (!dev->bulk_out_endpointAddr &&
+		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+					== USB_ENDPOINT_XFER_BULK)) {
+			/* we found a bulk out endpoint */
+			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+		}
+	}
+	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
+		err("Could not find both bulk-in and bulk-out endpoints");
+		goto error;
+	}
+
+	/* save our data pointer in this interface device */
+	usb_set_intfdata(interface, dev);
+
+	/* we can register the device now, as it is ready */
+	retval = usb_register_dev(interface, &cmdir_class);
+	if (retval) {
+		/* something prevented us from registering this driver */
+		err("Not able to get a minor for this device.");
+		usb_set_intfdata(interface, NULL);
+		goto error;
+	}
+
+	/* check whether minor already includes base */
+	minor = interface->minor;
+	if (minor >= USB_CMDIR_MINOR_BASE)
+		minor = minor-USB_CMDIR_MINOR_BASE;
+
+	/* let the user know what node this device is now attached to */
+	info("CommandIR USB device now attached to commandir%d", minor);
+
+	reset_cmdir(minor);
+
+	return 0;
+
+error:
+	if (dev)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
+		kref_put(&dev->kref);
+#else
+		kref_put(&dev->kref, cmdir_delete);
+#endif
+	return retval;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static int cmdir_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct usb_skel *dev;
+
+	dev = (struct usb_skel *)file->private_data;
+
+	/* lock this object */
+	down(&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (dev->udev == NULL) {
+		up(&dev->sem);
+		return -ENODEV;
+	}
+
+	/* unlock the device */
+	up(&dev->sem);
+
+	/* return that we did not understand this ioctl call */
+	return -ENOTTY;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static void cmdir_disconnect(struct usb_device *udev, void *ptr)
+{
+	struct usb_skel *dev;
+	int minor;
+
+	dev = (struct usb_skel *)ptr;
+
+	down(&minor_table_mutex);
+	down(&dev->sem);
+
+	minor = dev->minor;
+
+	/* remove our devfs node */
+	devfs_unregister(dev->devfs);
+
+	/* if the device is not opened, then we clean up right now */
+	if (!dev->open_count) {
+		up(&dev->sem);
+		cmdir_delete(dev);
+	} else {
+		dev->udev = NULL;
+		up(&dev->sem);
+	}
+
+	info("CommandIR #%d now disconnected", minor);
+	up(&minor_table_mutex);
+
+	/* check if default RX device still exists */
+	if (minor == rx_device) {
+		/* decrement until find next valid device */
+		while (rx_device > 0) {
+			rx_device--;
+			if (cmdir_check(rx_device) == 0) break;
+		}
+		if (minor > 0)
+			info("Active Receiver is on CommandIR #%d", rx_device);
+	}
+
+}
+#else
+static void cmdir_disconnect(struct usb_interface *interface)
+{
+	struct usb_skel *dev;
+	int minor = interface->minor;
+
+	/* prevent cmdir_open() from racing cmdir_disconnect() */
+	lock_kernel();
+
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+
+	/* give back our minor */
+	usb_deregister_dev(interface, &cmdir_class);
+
+	unlock_kernel();
+
+	/* decrement our usage count */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
+		kref_put(&dev->kref);
+#else
+		kref_put(&dev->kref, cmdir_delete);
+#endif
+
+	/* check whether minor already includes base */
+	if (minor >= USB_CMDIR_MINOR_BASE)
+		minor = minor-USB_CMDIR_MINOR_BASE;
+
+	info("CommandIR #%d now disconnected", minor);
+
+	/* check if default RX device still exists */
+	if (minor == rx_device) {
+		/* decrement until find next valid device */
+		while (rx_device > 0) {
+			rx_device--;
+			if (cmdir_check(rx_device) == 0)
+				break;
+		}
+		if (minor > 0)
+			info("Active Receiver is on CommandIR #%d", rx_device);
+	}
+}
+#endif
+
+static int cmdir_release(struct inode *inode, struct file *file)
+{
+	struct usb_skel *dev;
+	int retval = 0;
+
+	dev = (struct usb_skel *)file->private_data;
+	if (dev == NULL)
+		/*dbg(" - object is NULL");*/
+		return -ENODEV;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+
+	/* lock our minor table */
+	down(&minor_table_mutex);
+
+	/* lock our device */
+	down(&dev->sem);
+
+	if (dev->open_count <= 0) {
+		/*dbg(" - device not opened");*/
+		retval = -ENODEV;
+		goto exit_not_opened;
+	}
+
+	if (dev->udev == NULL) {
+		/* the device was unplugged before the file was released */
+		/*dbg(" - device unplugged before file released");*/
+		up(&dev->sem);
+		cmdir_delete(dev);
+		up(&minor_table_mutex);
+		MOD_DEC_USE_COUNT;
+		return 0;
+	}
+
+	/* decrement our usage count for the device */
+	--dev->open_count;
+	if (dev->open_count <= 0) {
+		/* shutdown any bulk writes that might be going on */
+		usb_unlink_urb(dev->write_urb);
+		dev->open_count = 0;
+	}
+
+	/* decrement our usage count for the module */
+	MOD_DEC_USE_COUNT;
+
+exit_not_opened:
+	up(&dev->sem);
+	up(&minor_table_mutex);
+
+	return retval;
+
+#else
+	/* decrement the count on our device */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
+		kref_put(&dev->kref);
+#else
+		kref_put(&dev->kref, cmdir_delete);
+#endif
+	return retval;
+#endif
+}
+
+static void __exit usb_cmdir_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&cmdir_driver);
+
+}
+
+static int cmdir_check(int device_num)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	if (minor_table[device_num] == NULL)
+		return -ENODEV;
+	return 0;
+#else
+	struct usb_interface *interface;
+
+	interface = usb_find_interface(&cmdir_driver,
+				       USB_CMDIR_MINOR_BASE+device_num);
+	if (!interface) {
+		/* also check without adding base, for devfs */
+		interface = usb_find_interface(&cmdir_driver, rx_device);
+		if (!interface)
+			return -ENODEV;
+	}
+	return 0;
+#endif
+}
+
+static void init_cmdir_var(int device_num)
+{
+	int i;
+	unsigned int multiplier = 1;
+
+	for (i = 0; i < device_num; i++)
+		multiplier = multiplier*0x10;
+	transmitters |= multiplier * 0x0F;
+	next_transmitters = transmitters;
+	info("commandir%d reset", device_num);
+	return;
+}
+
+static void reset_cmdir(int device_num)
+{
+	unsigned char ctrl_buffer[MCU_CTRL_SIZE];
+	int retval;
+	int i;
+
+	ctrl_buffer[0] = RESET_HEADER;
+	for (i = 1; i < MCU_CTRL_SIZE; i++)
+		ctrl_buffer[i] = 'j';
+	retval = write_core(ctrl_buffer, MCU_CTRL_SIZE, NULL, device_num);
+
+	init_cmdir_var(device_num);
+	print_cmdir(device_num);
+
+	return;
+}
+
+static void update_cmdir_string(int device_num)
+{
+	int next_comma = 0;
+	int next_pos = 25;
+	unsigned int multiplier;
+	int i;
+
+	/* cmdir_var[] = "COMMANDIRx:\n"
+	 * 		 " TX Enabled: 1, 2, 3, 4\n"
+	 * 		 " RX: commandirx\n"
+	 * 		 " LCD: commandirx\n" */
+
+	cmdir_var[9] = ASCII0+device_num;
+	cmdir_var[50] = ASCII0+rx_device;
+	cmdir_var[67] = ASCII0+lcd_device;
+
+	for (i = 25; i < 35; i++)
+		cmdir_var[i] = ' ';
+
+	multiplier = 1;
+	for (i = 0; i < device_num; i++)
+		multiplier = multiplier*0x10;
+
+	if (transmitters & (multiplier*0x01)) {
+		cmdir_var[next_pos] = '1';
+		next_pos += 3;
+		next_comma++;
+	}
+	if (transmitters & (multiplier*0x02)) {
+		cmdir_var[next_pos] = '2';
+		if (next_comma > 0)
+			cmdir_var[next_pos-2] = ',';
+		next_pos += 3;
+		next_comma++;
+	}
+	if (transmitters & (multiplier*0x04)) {
+		cmdir_var[next_pos] = '3';
+		if (next_comma > 0)
+			cmdir_var[next_pos-2] = ',';
+		next_pos += 3;
+		next_comma++;
+	}
+	if (transmitters & (multiplier*0x08)) {
+		cmdir_var[next_pos] = '4';
+		if (next_comma > 0)
+			cmdir_var[next_pos-2] = ',';
+		next_pos += 3;
+		next_comma++;
+	}
+	return;
+}
+
+static void print_cmdir(int device_num)
+{
+	update_cmdir_string(device_num);
+	info("%s", cmdir_var);
+	return;
+}
+
+static ssize_t cmdir_file_read(struct file *file, char *buffer,
+			       size_t count, loff_t *ppos)
+{
+	int retval = 0;
+	int minor = 0;
+	struct usb_skel *dev;
+
+	dev = (struct usb_skel *)file->private_data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	minor = dev->minor;
+#else
+	minor = dev->interface->minor;
+	if (minor >= USB_CMDIR_MINOR_BASE)
+		minor = minor - USB_CMDIR_MINOR_BASE;
+#endif
+
+	if (((int)*ppos) == 0) {
+		update_cmdir_string(minor);
+		if (copy_to_user(buffer, cmdir_var, CMDIR_VAR_LEN))
+			retval = -EFAULT;
+		else
+			retval = CMDIR_VAR_LEN;
+		return retval;
+	} else
+		return 0;
+}
+
+/*  Read data from CommandIR  */
+ssize_t cmdir_read(unsigned char *buffer, size_t count)
+{
+	struct usb_skel *dev;
+	int retval = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	if (minor_table[rx_device] == NULL)
+		return -ENODEV;
+	dev = minor_table[rx_device];
+
+	/* lock this object */
+	down(&dev->sem);
+	retval = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev,
+						dev->bulk_in_endpointAddr),
+		 dev->bulk_in_buffer, dev->bulk_in_size, &count, HZ*100);
+#else
+	struct usb_interface *interface;
+	interface = usb_find_interface(&cmdir_driver,
+			USB_CMDIR_MINOR_BASE+rx_device);
+	if (!interface) {
+		/* also check without adding base, for devfs */
+		interface = usb_find_interface(&cmdir_driver, rx_device);
+		if (!interface)
+			return -ENODEV;
+	}
+	dev = usb_get_intfdata(interface);
+	if (!dev)
+		return -ENODEV;
+	retval = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev,
+						dev->bulk_in_endpointAddr),
+		 dev->bulk_in_buffer, min(dev->bulk_in_size, count),
+		 &count, HZ*10);
+#endif
+	if (!retval) {
+		if (!memcpy(buffer, dev->bulk_in_buffer, count))
+			retval = -EFAULT;
+		else {
+			/* current status of the TX buffer */
+			curTXFill = buffer[2];
+			retval = count;
+		}
+	}
+	/* suppress errors */
+	/*
+	else {
+		err("Read from device failed, error %d",retval);
+	}
+	*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	/* unlock the device */
+	up(&dev->sem);
+#endif
+	/* printk(KERN_INFO "CommandIR Reporting TX buffer at %d bytes. \n",
+	 * 	  curTXFill); */
+	return retval;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+EXPORT_SYMBOL_NOVERS(cmdir_read);
+#else
+EXPORT_SYMBOL(cmdir_read);
+#endif
+
+static ssize_t cmdir_file_write(struct file *file, const char *buffer,
+				size_t count, loff_t *ppos)
+{
+	int retval;
+	int i;
+	int equalsign = 0;
+	int changeType = 0;
+	unsigned char ctrl_buffer[MCU_CTRL_SIZE];
+	char *local_buffer;
+	int minor;
+
+	/* set as default - if non-specific error,
+	 * won't keep calling this function */
+	retval = count;
+	local_buffer = kmalloc(count, GFP_KERNEL);
+
+	/* verify that we actually have some data to write */
+	if (count == 0) {
+		err("Write request of 0 bytes");
+		goto exit;
+	}
+	if (count > 64) {
+		err("Input too long");
+		goto exit;
+	}
+
+	/* copy the data from userspace into our local buffer */
+	if (copy_from_user(local_buffer, buffer, count)) {
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	/* parse code */
+	changeType = cNothing;
+	equalsign = 0;
+	for (i = 0; i < MCU_CTRL_SIZE; i++)
+		ctrl_buffer[i] = 'j';
+
+	for (i = 0; i < count; i++) {
+		switch (local_buffer[i]) {
+		case 'X':
+		case 'x':
+			if ((i > 0) && ((local_buffer[i - 1] == 'R')
+			    || (local_buffer[i - 1] == 'r')))
+				changeType = cRX;
+			break;
+		case 'S':
+		case 's':
+			if ((i > 1) && ((local_buffer[i - 1] == 'E')
+			    || (local_buffer[i - 1] == 'e'))) {
+				if ((local_buffer[i-2] == 'R')
+				    || (local_buffer[i-2] == 'r'))
+					changeType = cRESET;
+			}
+			break;
+		case 'L':
+		case 'l':
+			if ((i > 0) && ((local_buffer[i - 1] == 'F')
+			    || (local_buffer[i - 1] == 'f')))
+				changeType = cFLASH;
+			break;
+		case 'C':
+		case 'c':
+			if ((i > 0) && ((local_buffer[i - 1] == 'L')
+			    || (local_buffer[i - 1] == 'l')))
+				changeType = cLCD;
+			break;
+		case '=':
+			if (changeType != cNothing)
+				equalsign = i;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+			if (equalsign > 0) {
+				minor = local_buffer[i] - ASCII0;
+				switch (changeType) {
+				case cRESET:
+					ctrl_buffer[0] = RESET_HEADER;
+					retval = write_core(ctrl_buffer,
+						MCU_CTRL_SIZE,
+						cmdir_write_bulk_callback,
+						minor);
+					if (retval != MCU_CTRL_SIZE) {
+						if (retval == -ENODEV)
+							err("Device %d "
+							    "unplugged", minor);
+						else
+							err("Error on write to "
+							    "%d", minor);
+						goto exit;
+					} else
+						retval = count;
+					init_cmdir_var(minor);
+					break;
+				case cFLASH:
+					ctrl_buffer[0] = FLASH_HEADER;
+					info("Flashing indicators on device %d",
+					     minor);
+					retval = write_core(ctrl_buffer,
+						MCU_CTRL_SIZE,
+						cmdir_write_bulk_callback,
+						minor);
+					if (retval != MCU_CTRL_SIZE) {
+						if (retval == -ENODEV)
+							err("Device %d "
+							    "unplugged", minor);
+						else
+							err("Error on write to "
+							    "%d", minor);
+						goto exit;
+					} else
+						retval = count;
+					break;
+				case cRX:
+					rx_device = minor;
+					info("Default receiver set to %d",
+					     minor);
+					break;
+				case cLCD:
+					lcd_device = minor;
+					info("commandir: Default LCD set to %d",
+					     minor);
+					break;
+				default:
+					break;
+				}
+			}
+			break;
+		case ',':
+			equalsign = 0;
+			changeType = cNothing;
+			break;
+		default:
+			if ((equalsign > 0) && (local_buffer[i] > 32)) {
+				err("Non-numerical argument");
+				goto exit;
+			}
+			break;
+		}
+	}
+
+	if ((changeType != cNothing) && (equalsign == 0))
+		err("No device specified");
+	if (changeType == cNothing)
+		err("Unknown command");
+
+exit:
+	kfree(local_buffer);
+	return retval;
+}
+
+int cmdir_write(unsigned char *buffer, int count,
+		void *callback_fct, int usecdelay)
+{
+	/* Always add to queue, then send queue number
+	 * no locks
+	 * mbodkin, Sept 8, 2005 */
+	int ret = 0;
+	if (debug_commandir == 1) {
+		do_gettimeofday(&tp);
+		printk(KERN_INFO "cmdir_write at %d\n", (int)tp.tv_usec);
+	}
+	ret = add_cmdir_queue(buffer, count, callback_fct, usecdelay);
+
+	if (ret == -1)  {
+		printk(KERN_INFO "cmdir_write returning 0\n");
+		return 0;
+	}
+	return count;
+
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+EXPORT_SYMBOL_NOVERS(cmdir_write);
+#else
+EXPORT_SYMBOL(cmdir_write);
+#endif
+
+int add_cmdir_queue(unsigned char *buffer, int count,
+		    void *callback_vct, int usecdelay)
+{
+	int ret = 0;
+	if ((nexttofill + 1) % (QUEUELENGTH - 1) == nexttosend) {
+
+		/* our buffer is full */
+		printk(KERN_INFO "Too many packets backlogged "
+		       "in CommandIR Queue.\n");
+		return -1;
+	}
+	/* go ahead and use this one: */
+	memcpy(ourbuffers[nexttofill], buffer, count);
+	ourbufferlengths[nexttofill] = count;
+	waitusecs[nexttofill] = (usecdelay == 0) ? 10000 : usecdelay;
+	/* printk(KERN_INFO "Adding %d to queue at position %d.\n",
+	 *        count, nexttofill); */
+	nexttofill = (nexttofill + 1) % (QUEUELENGTH - 1);
+	ret = nexttofill;
+	/* if (timer_running == 0) */
+	send_queue(); /* fake it if the timer's not running */
+	return ret;	/* we accepted the full packet */
+
+}
+
+int send_queue()
+{
+	int last_sent = 0;
+	int ret = 0;
+	if (debug_commandir == 1) {
+		do_gettimeofday(&tp);
+		printk(KERN_INFO "Send_queue() at %d\n", (int)tp.tv_usec);
+	}
+	/* initiate the send/callback routine if not already running. */
+	if (send_status == SEND_IDLE) {
+		if (!(nexttofill == nexttosend)) {
+			/* start it up: */
+
+			last_sent = nexttosend - 1;
+			if (last_sent < 0)
+				last_sent = QUEUELENGTH - 1;
+			/* Final check - is it TIME to send this packet yet? */
+			/* if (wait_to_tx(waitusecs[last_sent]) == 0) { */
+			/* always send if there's room,
+			 * otherwise wait until room */
+			if (curTXFill < 190) {
+				if (debug_commandir == 1) {
+					do_gettimeofday(&tp);
+					printk(KERN_INFO "Sending packet data "
+					       "at %d\n", (int)tp.tv_usec);
+				}
+				ret = cmdir_write_queue(ourbuffers[nexttosend],
+				      ourbufferlengths[nexttosend], NULL);
+				if (ret <= 0) {
+					/* send failed - the device is either
+					 * unplugged or full
+					 * nexttosend =
+					 * 	(nexttosend + 1)
+					 * 	% (QUEUELENGTH - 1); */
+					send_status = SEND_IDLE;
+					return 0; /*send_queue(); */
+				} else
+					nexttosend = (nexttosend + 1)
+						     % (QUEUELENGTH - 1);
+				return 1;
+			} else {
+				if (debug_commandir == 1) {
+					do_gettimeofday(&tp);
+					printk(KERN_INFO "Not time to send yet "
+					       "- starting timer at %d.\n",
+					       (int)tp.tv_usec);
+					printk(KERN_INFO "Enabling timer.\n");
+				}
+				return 0; /* doesn't matter anymore */
+			}
+		} else {
+			if (debug_commandir == 1) {
+				do_gettimeofday(&tp);
+				printk(KERN_INFO "No more data to send %d!\n",
+				       (int)tp.tv_usec);
+			}
+			last_tx_sec = 0; /* reset our TX counters */
+			last_tx_usec = 0;
+			return 1; /* nothing more to send! */
+		}
+	} else {
+		if (debug_commandir == 1)
+			/* will try again on the callback */
+			printk(KERN_INFO "Already sending\n");
+		return 1;  /* then the timer shouldn't be running... */
+	}
+	return 0; /* should never get here... */
+}
+
+
+int wait_to_tx(int usecs)
+{
+	/* don't return until last_time + usecs has been reached
+	 * for non-zero last_tx's. */
+	int wait_until_sec = 0, wait_until_usec = 0;
+	int now_sec = 0, now_usec = 0;
+	if (debug_commandir == 1)
+		printk(KERN_INFO "waittotx(%d)\n", usecs);
+	if (usecs == 0)
+		return 0;
+
+	if (!(last_tx_sec == 0 && last_tx_usec == 0)) {
+		/* calculate wait time: */
+		wait_until_sec = last_tx_sec + (usecs / 1000000);
+		wait_until_usec = last_tx_usec + usecs;
+
+		do_gettimeofday(&tp);
+		now_sec = tp.tv_sec;
+		now_usec = tp.tv_usec;
+
+		if (wait_until_usec > 1000000) {
+			/* we've spilled over to the next second. */
+			wait_until_sec++;
+			wait_until_usec -= 1000000;
+			/* printk(KERN_INFO "usec rollover\n"); */
+		}
+		if (debug_commandir == 1)
+			printk(KERN_INFO "Testing for the right second, now = "
+			       "%d %d, wait = %d %d\n",
+			       now_sec, now_usec,
+			       wait_until_sec, wait_until_usec);
+		/* now we are always on the same second. */
+		if (now_sec > wait_until_sec) {
+			if (debug_commandir == 1)
+				printk(KERN_INFO "Setting last_tx_sec to %d.\n",
+				       wait_until_sec);
+			last_tx_sec = wait_until_sec;
+			last_tx_usec = wait_until_usec;
+			return 0;
+		}
+
+		if ((now_sec == wait_until_sec)
+		    && (now_usec > wait_until_usec)) {
+			if (debug_commandir == 1)
+				printk(KERN_INFO "Setting last_tx_sec to %d.\n",
+				       wait_until_sec);
+			last_tx_sec = wait_until_sec;
+			last_tx_usec = wait_until_usec;
+			return 0;
+		}
+		return -1; /* didn't send */
+	}
+
+	do_gettimeofday(&tp);
+	last_tx_usec = tp.tv_usec;
+	last_tx_sec = tp.tv_sec;
+	return 0; /* if there's no last even, go ahead and send */
+}
+
+
+int cmdir_write_queue(unsigned char *buffer, int count, void *callback_fct)
+{
+	int retval = count;
+	static char prev_signal_num;
+	unsigned char next_mask;
+	unsigned int multiplier;
+	int i;
+
+	send_status = SEND_ACTIVE;
+
+	if (count < 2) {
+		err("Not enough bytes (write request of %d bytes)", count);
+		return count;
+	}
+
+	/* check data; decide which device to send to */
+	switch (buffer[0]) {
+	case TX_HEADER:
+	case TX_HEADER_NEW:
+		/* this is LIRC transmit data */
+		if (curTXFill >= 190) {
+			printk(KERN_INFO
+			       "TX buffer too full to send more TX data\n");
+			return 0;
+		}
+		if (next_transmitters != transmitters) {
+			if (buffer[1] != prev_signal_num)
+				/* this is new signal; change transmitter mask*/
+				transmitters = next_transmitters;
+		}
+		prev_signal_num = buffer[1];
+
+		multiplier = 1;
+		for (i = 0; i < MAX_DEVICES; i++) {
+			next_mask = 0;
+			if (transmitters & (0x01*multiplier))
+				next_mask |= TX1_ENABLE;
+			if (transmitters & (0x02*multiplier))
+				next_mask |= TX2_ENABLE;
+			if (transmitters & (0x04*multiplier))
+				next_mask |= TX3_ENABLE;
+			if (transmitters & (0x08*multiplier))
+				next_mask |= TX4_ENABLE;
+
+			if (next_mask > 0) {
+				buffer[1] = next_mask;
+				retval = write_core(buffer, count,
+					 callback_fct, i);
+				if (retval != count) {
+					if (retval == -ENODEV)
+						err("Device %d not plugged in",
+						    i);
+					else
+						err("Write error to device %d",
+						    i);
+					return retval;
+				}
+			}
+			multiplier = multiplier*0x10;
+		}
+		return retval;
+		break;
+	case LCD_HEADER:
+		return write_core(buffer, count, callback_fct, lcd_device);
+		break;
+	default:
+		return write_core(buffer, count, callback_fct, def_device);
+		break;
+	}
+	/* should never get here */
+	return retval;
+
+}
+
+int write_core(unsigned char *buffer, int count,
+	       void *callback_fct, int device_num)
+{
+	struct usb_skel *dev;
+	int retval = count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	ssize_t bytes_written = 0;
+	if (minor_table[device_num] == NULL)
+		/* device is unplugged */
+		return -ENODEV;
+	dev = minor_table[device_num];
+
+	/* lock this object */
+	down(&dev->sem);
+
+	/* see if we are already in the middle of a write */
+	if (dev->write_urb->status == -EINPROGRESS) {
+		/*suppress errors - should just try sending again*/
+		/*dbg(" - already writing");*/
+		retval = -EINPROGRESS;
+		goto exit;
+	}
+
+	/* we can only write as much as 1 urb will hold */
+	bytes_written = (count > dev->bulk_out_size) ?
+				dev->bulk_out_size : count;
+
+	/* copy the data into our urb */
+	if (!(memcpy(dev->write_urb->transfer_buffer, buffer, bytes_written))) {
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	/* set up our urb */
+	if (callback_fct == NULL) {
+		/*FILL_BULK_URB(dev->write_urb, dev->udev,
+			usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+			dev->write_urb->transfer_buffer, bytes_written,
+			cmdir_write_bulk_callback, dev); */
+		usb_fill_bulk_urb(dev->write_urb, dev->udev,
+			usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+			dev->write_urb->transfer_buffer, bytes_written,
+			cmdir_write_bulk_callback, dev);
+	} else {
+		FILL_BULK_URB(dev->write_urb, dev->udev,
+			usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+			dev->write_urb->transfer_buffer, bytes_written,
+			callback_fct, dev);
+	}
+
+	/* send the data out the bulk port */
+	retval = usb_submit_urb(dev->write_urb);
+	if (!(retval))
+		retval = bytes_written;
+	/* suppress errors */
+	/* else {
+		err("Failed submitting write urb, error %d", retval);
+	} */
+exit:
+	/* unlock the device */
+	up(&dev->sem);
+	return retval;  /* this should be return error I think */
+
+#else
+	struct usb_interface *interface;
+	struct urb *urb = NULL;
+	char *buf = NULL;
+	interface = usb_find_interface(&cmdir_driver,
+			USB_CMDIR_MINOR_BASE + device_num);
+	if (!interface) {
+		/* also check without adding base, for devfs */
+		interface = usb_find_interface(&cmdir_driver, device_num);
+		if (!interface)
+			return -ENODEV;
+	}
+	dev = usb_get_intfdata(interface);
+	if (!dev)
+		return -ENODEV;
+	/* create a urb, and a buffer for it, and copy the data to the urb */
+	urb = usb_alloc_urb(0, GFP_ATOMIC);	/* Now -=Atomic=- */
+	if (!urb) {
+		retval = -ENOMEM;
+		goto error;
+	}
+	buf = usb_buffer_alloc(dev->udev, count,
+		GFP_KERNEL, &urb->transfer_dma);
+	if (!buf) {
+		retval = -ENOMEM;
+		goto error;
+	}
+	if (!memcpy(buf, buffer, count)) {
+		retval = -EFAULT;
+		goto error;
+	}
+	/* initialize the urb properly */
+	if (callback_fct == NULL) {
+		usb_fill_bulk_urb(urb, dev->udev,
+			  usb_sndbulkpipe(dev->udev,
+				dev->bulk_out_endpointAddr),
+			  buf, count, (void *) cmdir_write_bulk_callback, dev);
+	} else {
+		usb_fill_bulk_urb(urb, dev->udev,
+			  usb_sndbulkpipe(dev->udev,
+				dev->bulk_out_endpointAddr),
+			  buf, count, callback_fct, dev);
+	}
+	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;  /* double check this */
+
+	/* send the data out the bulk port */
+	retval = usb_submit_urb(urb, GFP_KERNEL);
+	if (retval) {
+		err("%s - failed submitting write urb, error %d",
+		    __FUNCTION__, retval);
+		goto error;
+	}
+
+	/* release our reference to this urb, the USB
+	 * core will eventually free it entirely */
+	usb_free_urb(urb);
+	return count;
+
+error:
+	usb_buffer_free(dev->udev, count, buf, urb->transfer_dma);
+	usb_free_urb(urb);
+	return retval;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static void cmdir_write_bulk_callback(struct urb *urb)
+{
+	if (debug_commandir == 1) {
+		do_gettimeofday(&tp);
+		printk(KERN_INFO "cmdir_write_bulk_callback at %d\n",
+		       (int)tp.tv_usec);
+	}
+	/*if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET))
+		return;
+	else {
+		dbg(" - urb status: %d", urb->status);
+		return;
+	}*/
+
+	send_status = SEND_IDLE;
+	/* printk(KERN_INFO "cmdir_write_bulk_callback - set idle\n"); */
+	send_queue(); /* send the next packet */
+	return;
+}
+#else
+static void cmdir_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_skel *dev;
+	dev = (struct usb_skel *)urb->context;
+	send_status = SEND_IDLE;
+	if (debug_commandir == 1)
+		printk(KERN_INFO "callback()\n");
+	/* free up our allocated buffer */
+
+	usb_buffer_free(urb->dev, urb->transfer_buffer_length,
+			urb->transfer_buffer, urb->transfer_dma);
+	send_queue(); /* send the next packet */
+
+}
+#endif
+
+int set_tx_channels(unsigned int next_tx)
+{
+	next_transmitters = next_tx;
+	return 0;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+EXPORT_SYMBOL_NOVERS(set_tx_channels);
+#else
+EXPORT_SYMBOL(set_tx_channels);
+#endif
+
+module_init(usb_cmdir_init);
+module_exit(usb_cmdir_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/lirc/commandir.h b/drivers/char/lirc/commandir.h
new file mode 100644
index 0000000..90a297f
--- /dev/null
+++ b/drivers/char/lirc/commandir.h
@@ -0,0 +1,41 @@
+/*
+ *  commandir.h
+ */
+
+#define ASCII0      48
+
+/* transmitter channel control */
+#define MAX_DEVICES      8
+#define MAX_CHANNELS     32
+#define TX1_ENABLE       0x80
+#define TX2_ENABLE       0x40
+#define TX3_ENABLE       0x20
+#define TX4_ENABLE       0x10
+
+/* command types */
+#define cNothing        0
+#define cRESET          1
+#define cFLASH          2
+#define cLCD            3
+#define cRX             4
+
+/* CommandIR control codes */
+#define MCU_CTRL_SIZE   3
+#define FREQ_HEADER     2
+#define RESET_HEADER    3
+#define FLASH_HEADER    4
+#define LCD_HEADER      5
+#define TX_HEADER       7
+#define TX_HEADER_NEW   8
+
+/* Queue buffering constants */
+#define SEND_IDLE	0
+#define SEND_ACTIVE	1
+
+#define QUEUELENGTH	256
+
+extern int cmdir_write(unsigned char *buffer, int count,
+		       void *callback_fct, int u);
+extern ssize_t cmdir_read(unsigned char *buffer, size_t count);
+extern int set_tx_channels(unsigned int next_tx);
+
diff --git a/drivers/char/lirc/kcompat.h b/drivers/char/lirc/kcompat.h
index 2f8a63a..05f481f 100644
--- a/drivers/char/lirc/kcompat.h
+++ b/drivers/char/lirc/kcompat.h
@@ -1,28 +1,28 @@
-/*      $Id: kcompat.h,v 5.30 2007/01/02 21:45:08 lirc Exp $      */
+/*      $Id: kcompat.h,v 5.34 2008/01/13 10:26:28 lirc Exp $      */
 
 #ifndef _KCOMPAT_H
 #define _KCOMPAT_H
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
 #define LIRC_THIS_MODULE(x) x,
 #else /* >= 2.6.16 */
 #define LIRC_THIS_MODULE(x)
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 
 #include <linux/device.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #define LIRC_HAVE_DEVFS
 #define LIRC_HAVE_DEVFS_26
 #endif
 
 #define LIRC_HAVE_SYSFS
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 13)
 
 typedef struct class_simple lirc_class_t;
 
@@ -46,7 +46,7 @@ static inline void class_device_destroy(lirc_class_t *cls, dev_t devt)
 
 #else /* >= 2.6.13 */
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 
 #define lirc_class_device_create(cs, parent, dev, device, fmt, args...) \
 	class_device_create(cs, dev, device, fmt, ## args)
@@ -62,7 +62,7 @@ typedef struct class lirc_class_t;
 
 #endif
 
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
 #define LIRC_HAVE_DEVFS
 #define LIRC_HAVE_DEVFS_24
 #endif
@@ -74,7 +74,7 @@ typedef struct class lirc_class_t;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
 #include <linux/timer.h>
 #include <linux/interrupt.h>
-static inline void del_timer_sync(struct timer_list * timerlist)
+static inline void del_timer_sync(struct timer_list *timerlist)
 {
 	start_bh_atomic();
 	del_timer(timerlist);
@@ -86,30 +86,30 @@ static inline void del_timer_sync(struct timer_list * timerlist)
 #ifdef daemonize
 #undef daemonize
 #endif
-#define daemonize(name) do {                                           \
-                                                                       \
-	lock_kernel();                                                 \
-	                                                               \
-	exit_mm(current);                                              \
-	exit_files(current);                                           \
-	exit_fs(current);                                              \
-	current->session = 1;                                          \
-	current->pgrp = 1;                                             \
-	current->euid = 0;                                             \
-	current->tty = NULL;                                           \
-	sigfillset(&current->blocked);                                 \
-	                                                               \
-	strcpy(current->comm, name);                                   \
-	                                                               \
-	unlock_kernel();                                               \
-                                                                       \
+#define daemonize(name) do {		\
+					\
+	lock_kernel();			\
+					\
+	exit_mm(current);		\
+	exit_files(current);		\
+	exit_fs(current);		\
+	current->session = 1;		\
+	current->pgrp = 1;		\
+	current->euid = 0;		\
+	current->tty = NULL;		\
+	sigfillset(&current->blocked);	\
+					\
+	strcpy(current->comm, name);	\
+					\
+	unlock_kernel();		\
+					\
 } while (0)
 
 /* Not sure when this was introduced, sometime during 2.5.X */
 #define MODULE_PARM_int(x) MODULE_PARM(x, "i")
 #define MODULE_PARM_bool(x) MODULE_PARM(x, "i")
 #define MODULE_PARM_long(x) MODULE_PARM(x, "l")
-#define module_param(x,y,z) MODULE_PARM_##y(x)
+#define module_param(x, y, z) MODULE_PARM_##y(x)
 #else
 #include <linux/moduleparam.h>
 #endif /* Linux < 2.6.0 */
@@ -131,27 +131,27 @@ static inline void del_timer_sync(struct timer_list * timerlist)
 #endif /* DEVFS 2.4 */
 
 #ifndef LIRC_HAVE_SYSFS
-#define class_destroy(x) do { } while(0)
-#define class_create(x,y) NULL
-#define class_device_destroy(x,y) do { } while(0)
+#define class_destroy(x) do { } while (0)
+#define class_create(x, y) NULL
+#define class_device_destroy(x, y) do { } while (0)
 #define lirc_class_device_create(x, y, z, xx, yy, zz) 0
 #define IS_ERR(x) 0
-typedef struct class_simple 
+typedef struct class_simple
 {
 	int notused;
-} lirc_class_t;	
+} lirc_class_t;
 #endif /* No SYSFS */
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #define KERNEL_2_5
 
 /*
- * We still are using MOD_INC_USE_COUNT/MOD_DEC_USE_COUNT in the set_use_inc 
+ * We still are using MOD_INC_USE_COUNT/MOD_DEC_USE_COUNT in the set_use_inc
  * function of all modules for 2.4 kernel compatibility.
- * 
- * For 2.6 kernels reference counting is done in lirc_dev by 
+ *
+ * For 2.6 kernels reference counting is done in lirc_dev by
  * try_module_get()/module_put() because the old approach is racy.
- * 
+ *
  */
 #ifdef MOD_INC_USE_COUNT
 #undef MOD_INC_USE_COUNT
@@ -186,7 +186,7 @@ static inline void module_put(struct module *module)
 #endif
 
 #ifndef MODULE_PARM_DESC
-#define MODULE_PARM_DESC(x,y)
+#define MODULE_PARM_DESC(x, y)
 #endif
 
 #ifndef MODULE_ALIAS_CHARDEV_MAJOR
@@ -194,7 +194,7 @@ static inline void module_put(struct module *module)
 #endif
 
 #ifndef MODULE_DEVICE_TABLE
-#define MODULE_DEVICE_TABLE(x,y)
+#define MODULE_DEVICE_TABLE(x, y)
 #endif
 
 #include <linux/interrupt.h>
@@ -215,20 +215,24 @@ typedef void irqreturn_t;
 #endif
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #if !defined(local_irq_save)
-#define local_irq_save(flags) do{ save_flags(flags);cli(); } while(0)
+#define local_irq_save(flags) do { save_flags(flags); cli(); } while (0)
 #endif
 #if !defined(local_irq_restore)
-#define local_irq_restore(flags) do{ restore_flags(flags); } while(0)
+#define local_irq_restore(flags) do { restore_flags(flags); } while (0)
+#endif
 #endif
 
-#if KERNEL_VERSION(2, 4, 0) <= LINUX_VERSION_CODE && LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 22)
+#if KERNEL_VERSION(2, 4, 0) <= LINUX_VERSION_CODE
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 22)
 #include <linux/pci.h>
 static inline char *pci_name(struct pci_dev *pdev)
 {
 	return pdev->slot_name;
 }
-#endif // 2.4.0 <= kernel < 2.4.22
+#endif /* kernel < 2.4.22 */
+#endif /* kernel >= 2.4.0 */
 
 /*************************** I2C specific *****************************/
 #include <linux/i2c.h>
@@ -277,7 +281,7 @@ static inline int usb_kill_urb(struct urb *urb)
 
 /* removed in 2.6.14 */
 #ifndef URB_ASYNC_UNLINK
-#define URB_ASYNC_UNLINK 0  
+#define URB_ASYNC_UNLINK 0
 #endif
 #endif
 
@@ -322,11 +326,24 @@ static inline int usb_kill_urb(struct urb *urb)
 /******************************* pm.h *********************************/
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
 typedef u32 pm_message_t;
+#endif /* kernel < 2.6.11 */
+#endif /* kernel >= 2.6.0 */
+
+/*************************** interrupt.h ******************************/
+/* added in 2.6.18, old defines removed in 2.6.24 */
+#ifndef IRQF_DISABLED
+#define IRQF_DISABLED SA_INTERRUPT
+#endif
+#ifndef IRQF_SHARED
+#define IRQF_SHARED SA_SHIRQ
 #endif
 
+/*************************** spinlock.h *******************************/
+/* added in 2.6.11 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+#define DEFINE_SPINLOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
 #endif
 
 #endif /* _KCOMPAT_H */
diff --git a/drivers/char/lirc/lirc_atiusb.c b/drivers/char/lirc/lirc_atiusb.c
index def2718..abadc93 100644
--- a/drivers/char/lirc/lirc_atiusb.c
+++ b/drivers/char/lirc/lirc_atiusb.c
@@ -16,7 +16,7 @@
  *   Vassilis Virvilis <vasvir@iit.demokritos.gr> 2006
  *      reworked the patch for lirc submission
  *
- * $Id: lirc_atiusb.c,v 1.61 2007/04/29 14:23:04 lirc Exp $
+ * $Id: lirc_atiusb.c,v 1.69 2008/04/28 06:47:29 lirc Exp $
  */
 
 /*
@@ -53,7 +53,11 @@
 #include <linux/kmod.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
 #include <linux/usb.h>
 #include <linux/poll.h>
 #include <linux/wait.h>
@@ -63,7 +67,7 @@
 #include "kcompat.h"
 #include "lirc_dev.h"
 
-#define DRIVER_VERSION		"$Revision: 1.61 $"
+#define DRIVER_VERSION		"$Revision: 1.69 $"
 #define DRIVER_AUTHOR		"Paul Miller <pmiller9@users.sourceforge.net>"
 #define DRIVER_DESC		"USB remote driver for LIRC"
 #define DRIVER_NAME		"lirc_atiusb"
@@ -84,31 +88,32 @@
 
 /* module parameters */
 #ifdef CONFIG_USB_DEBUG
-	static int debug = 1;
+static int debug = 1;
 #else
-	static int debug = 0;
+static int debug;
 #endif
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
-// ATI, ATI2, XBOX
+/* ATI, ATI2, XBOX */
 static const int code_length[] = {5, 3, 6};
 static const int code_min_length[] = {3, 3, 6};
 static const int decode_length[] = {5, 3, 1};
-// USB_BUFF_LEN must be the maximum value of the code_length array.
-// It is used for static arrays.
+/* USB_BUFF_LEN must be the maximum value of the code_length array.
+ * It is used for static arrays. */
 #define USB_BUFF_LEN 6
 
-static int mask = 0xFFFF;	// channel acceptance bit mask
-static int unique = 0;		// enable channel-specific codes
-static int repeat = 10;		// repeat time in 1/100 sec
-static int emit_updown = 0;	// send seperate press/release codes (rw2)
-static int emit_modekeys = 0;	// send keycodes for aux1-aux4, pc, and mouse (rw2)
-static unsigned long repeat_jiffies; // repeat timeout
-static int mdeadzone = 0;	// mouse sensitivity >= 0
-static int mgradient = 375;	// 1000*gradient from cardinal direction
+static int mask = 0xFFFF;	/* channel acceptance bit mask */
+static int unique;		/* enable channel-specific codes */
+static int repeat = 10;		/* repeat time in 1/100 sec */
+static int emit_updown;		/* send seperate press/release codes (rw2) */
+static int emit_modekeys; /* send keycodes for aux1-4, pc, and mouse (rw2) */
+static unsigned long repeat_jiffies; /* repeat timeout */
+static int mdeadzone;		/* mouse sensitivity >= 0 */
+static int mgradient = 375;	/* 1000*gradient from cardinal direction */
 
 /* get hi and low bytes of a 16-bits int */
 #define HI(a)			((unsigned char)((a) >> 8))
@@ -134,29 +139,53 @@ static int mgradient = 375;	// 1000*gradient from cardinal direction
 #define VENDOR_ATI2		0x0471
 #define VENDOR_MS1		0x040b
 #define VENDOR_MS2		0x045e
+#define VENDOR_MS3		0xFFFF
 
 static struct usb_device_id usb_remote_table [] = {
-	{ USB_DEVICE(VENDOR_ATI1, 0x0002) },	/* X10 USB Firecracker Interface */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0003) },	/* X10 VGA Video Sender */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0004) },	/* ATI Wireless Remote Receiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0005) },	/* NVIDIA Wireless Remote Receiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0006) },	/* ATI Wireless Remote Receiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0007) },	/* X10 USB Wireless Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0008) },	/* X10 USB Wireless Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x0009) },	/* X10 USB Wireless Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000A) },	/* X10 USB Wireless Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000B) },	/* X10 USB Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000C) },	/* X10 USB Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000D) },	/* X10 USB Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000E) },	/* X10 USB Transceiver */
-	{ USB_DEVICE(VENDOR_ATI1, 0x000F) },	/* X10 USB Transceiver */
-
-	{ USB_DEVICE(VENDOR_ATI2, 0x0602) },	/* ATI Remote Wonder 2: Input Device */
-	{ USB_DEVICE(VENDOR_ATI2, 0x0603) },	/* ATI Remote Wonder 2: Controller (???) */
-
-	{ USB_DEVICE(VENDOR_MS1, 0x6521) }, /* Gamester Xbox DVD Movie Playback Kit IR */
-	{ USB_DEVICE(VENDOR_MS2, 0x0284) }, /* Microsoft Xbox DVD Movie Playback Kit IR */
-	{ }					/* Terminating entry */
+	/* X10 USB Firecracker Interface */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0002) },
+
+	/* X10 VGA Video Sender */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0003) },
+
+	/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0004) },
+
+	/* NVIDIA Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0005) },
+
+	/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0006) },
+
+	/* X10 USB Wireless Transceivers */
+	{ USB_DEVICE(VENDOR_ATI1, 0x0007) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x0008) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x0009) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000A) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000B) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000C) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000D) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000E) },
+	{ USB_DEVICE(VENDOR_ATI1, 0x000F) },
+
+	/* ATI Remote Wonder 2: Input Device */
+	{ USB_DEVICE(VENDOR_ATI2, 0x0602) },
+
+	/* ATI Remote Wonder 2: Controller (???) */
+	{ USB_DEVICE(VENDOR_ATI2, 0x0603) },
+
+	/* Gamester Xbox DVD Movie Playback Kit IR */
+	{ USB_DEVICE(VENDOR_MS1, 0x6521) },
+
+	/* Microsoft Xbox DVD Movie Playback Kit IR */
+	{ USB_DEVICE(VENDOR_MS2, 0x0284) },
+
+	/* Some chinese manufacterer -- conflicts with the joystick from the
+	 * same manufacterer */
+	{ USB_DEVICE(VENDOR_MS3, 0xFFFF) },
+
+	/* Terminating entry */
+	{ }
 };
 
 
@@ -166,8 +195,6 @@ static struct usb_device_id usb_remote_table [] = {
 static char init1[] = {0x01, 0x00, 0x20, 0x14};
 static char init2[] = {0x01, 0x00, 0x20, 0x14, 0x20, 0x20, 0x20};
 
-
-
 struct in_endpt {
 	/* inner link in list of endpoints for the remote specified by ir */
 	struct list_head iep_list_link;
@@ -242,8 +269,10 @@ static struct list_head remote_list;
 
 /* Convenience macros to retrieve a pointer to the surrounding struct from
  * the given list_head reference within, pointed at by link. */
-#define get_iep_from_link(link)  list_entry((link), struct in_endpt, iep_list_link);
-#define get_irctl_from_link(link)  list_entry((link), struct irctl, remote_list_link);
+#define get_iep_from_link(link) \
+		list_entry((link), struct in_endpt, iep_list_link);
+#define get_irctl_from_link(link) \
+		list_entry((link), struct irctl, remote_list_link);
 
 /* send packet - used to initialize remote */
 static void send_packet(struct out_endpt *oep, u16 cmd, unsigned char *data)
@@ -280,7 +309,7 @@ static void send_packet(struct out_endpt *oep, u16 cmd, unsigned char *data)
 	IRUNLOCK;
 
 	while (timeout && (oep->urb->status == -EINPROGRESS)
-		&& !(oep->send_flags & SEND_FLAG_COMPLETE)) {
+	       && !(oep->send_flags & SEND_FLAG_COMPLETE)) {
 		timeout = schedule_timeout(timeout);
 		rmb();
 	}
@@ -338,14 +367,17 @@ static int set_use_inc(void *data)
 			/* extract the current in_endpt */
 			iep = get_iep_from_link(pos);
 			iep->urb->dev = ir->usbdev;
-			dprintk(DRIVER_NAME "[%d]: linking iep 0x%02x (%p)\n", ir->devnum, iep->ep->bEndpointAddress, iep);
+			dprintk(DRIVER_NAME "[%d]: linking iep 0x%02x (%p)\n",
+				ir->devnum, iep->ep->bEndpointAddress, iep);
 #ifdef KERNEL_2_5
-			if ((rtn = usb_submit_urb(iep->urb, GFP_ATOMIC)) < 0) {
+			rtn = usb_submit_urb(iep->urb, GFP_ATOMIC);
 #else
-			if ((rtn = usb_submit_urb(iep->urb)) < 0) {
+			rtn = usb_submit_urb(iep->urb);
 #endif
-				printk(DRIVER_NAME "[%d]: open result = %d error "
-					"submitting urb\n", ir->devnum, rtn);
+			if (rtn) {
+				printk(DRIVER_NAME "[%d]: open result = %d "
+				       "error submitting urb\n",
+				       ir->devnum, rtn);
 				IRUNLOCK;
 				MOD_DEC_USE_COUNT;
 				return -EIO;
@@ -375,7 +407,8 @@ static void set_use_dec(void *data)
 		/* Free inbound usb urbs */
 		list_for_each_safe(pos, n, &ir->iep_listhead) {
 			iep = get_iep_from_link(pos);
-			dprintk(DRIVER_NAME "[%d]: unlinking iep 0x%02x (%p)\n", ir->devnum, iep->ep->bEndpointAddress, iep);
+			dprintk(DRIVER_NAME "[%d]: unlinking iep 0x%02x (%p)\n",
+				ir->devnum, iep->ep->bEndpointAddress, iep);
 			usb_kill_urb(iep->urb);
 		}
 		ir->connected = 0;
@@ -393,9 +426,8 @@ static void print_data(struct in_endpt *iep, char *buf, int len)
 	if (len <= 0)
 		return;
 
-	for (i = 0; i < len && i < clen; i++) {
+	for (i = 0; i < len && i < clen; i++)
 		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
-	}
 	printk(DRIVER_NAME "[%d]: data received %s (ep=0x%x length=%d)\n",
 		iep->ir->devnum, codes, iep->ep->bEndpointAddress, len);
 }
@@ -410,7 +442,7 @@ static int code_check_ati1(struct in_endpt *iep, int len)
 	if (len < CODE_MIN_LENGTH || len > CODE_LENGTH)
 		return -1;
 
-	// *** channel not tested with 4/5-byte Dutch remotes ***
+	/* *** channel not tested with 4/5-byte Dutch remotes *** */
 	chan = ((iep->buf[len-1]>>4) & 0x0F);
 
 	/* strip channel code */
@@ -419,8 +451,9 @@ static int code_check_ati1(struct in_endpt *iep, int len)
 		iep->buf[len-3] -= (chan<<4);
 	}
 
-	if ( !((1U<<chan) & mask) ) {
-		dprintk(DRIVER_NAME "[%d]: ignore channel %d\n", ir->devnum, chan+1);
+	if (!((1U<<chan) & mask)) {
+		dprintk(DRIVER_NAME "[%d]: ignore channel %d\n",
+			ir->devnum, chan+1);
 		return -1;
 	}
 	dprintk(DRIVER_NAME "[%d]: accept channel %d\n", ir->devnum, chan+1);
@@ -429,12 +462,10 @@ static int code_check_ati1(struct in_endpt *iep, int len)
 		for (i = len; i < CODE_LENGTH; i++) iep->buf[i] = 0;
 		/* check for repeats */
 		if (memcmp(iep->old, iep->buf, len) == 0) {
-			if (iep->old_jiffies + repeat_jiffies > jiffies) {
+			if (iep->old_jiffies + repeat_jiffies > jiffies)
 				return -1;
-			}
-		} else {
+		} else
 			memcpy(iep->old, iep->buf, CODE_LENGTH);
-		}
 		iep->old_jiffies = jiffies;
 	}
 
@@ -464,10 +495,10 @@ static int code_check_ati1(struct in_endpt *iep, int len)
  *    handle this we need a seperate parameter, like rw2modes, with the
  *    following values and meanings:
  *
- *    	0: Don't squash any channel info
- *    	1: Only squash channel data for non-mode setting keys
- *    	2: Ignore aux keypresses, but don't squash channel
- *    	3: Ignore aux keypresses and squash channel data
+ *	0: Don't squash any channel info
+ *	1: Only squash channel data for non-mode setting keys
+ *	2: Ignore aux keypresses, but don't squash channel
+ *	3: Ignore aux keypresses and squash channel data
  *
  *    Option 1 may seem useless since the mouse sends the same code, but one
  *    need only ignore in userspace any press of a mode-setting code that only
@@ -500,8 +531,8 @@ static int code_check_ati1(struct in_endpt *iep, int len)
  *    and the third, the y-axis.  Treated as signed integers, these axes range
  *    approximately as follows:
  *
- *    	x: (left) -46 ... 46 (right) (0xd2..0x2e)
- *    	y: (up)   -46 ... 46 (down)  (0xd2..0x2e)
+ *	x: (left) -46 ... 46 (right) (0xd2..0x2e)
+ *	y: (up)   -46 ... 46 (down)  (0xd2..0x2e)
  *
  *    NB these values do not correspond to the pressure with which the mouse
  *    norb is pushed in a given direction, but rather seems to indicate the
@@ -513,13 +544,14 @@ static int code_check_ati1(struct in_endpt *iep, int len)
  *
  * d. The interrupt rate of the mouse vs. the normal keys is different.
  *
- * 	mouse: ~27Hz (37ms between interrupts)
- * 	keys:  ~10Hz (100ms between interrupts)
+ *	mouse: ~27Hz (37ms between interrupts)
+ *	keys:  ~10Hz (100ms between interrupts)
  *
  *    This means that the normal gap mechanism for lircd won't work as
  *    expected; is emit_updown>0 if you can get away with it.
  */
-static int code_check_ati2(struct in_endpt *iep, int len) {
+static int code_check_ati2(struct in_endpt *iep, int len)
+{
 	struct irctl *ir = iep->ir;
 	int mode, i;
 	char *buf = iep->buf;
@@ -535,14 +567,17 @@ static int code_check_ati2(struct in_endpt *iep, int len) {
 	mode = buf[0];
 
 	/* Squash the mode indicator if unique wasn't set non-zero */
-	if (!unique) buf[0] = 0;
+	if (!unique)
+		buf[0] = 0;
 
 	if (iep->ep->bEndpointAddress == EP_KEYS_ADDR) {
-		/* ignore mouse navigation indicator key and mode-set (aux) keys */
+		/* ignore mouse navigation indicator key and
+		 * mode-set (aux) keys */
 		if (buf[2] == RW2_MODENAV_KEYCODE) {
-			if (emit_modekeys >= 2) { /* emit raw */
+			if (emit_modekeys >= 2) /* emit raw */
 				buf[0] = mode;
-			} else if (emit_modekeys == 1) { /* translate */
+			else if (emit_modekeys == 1) {
+				/* translate */
 				buf[0] = mode;
 				if (ir->mode != mode) {
 					buf[1] = 0x03;
@@ -550,8 +585,10 @@ static int code_check_ati2(struct in_endpt *iep, int len) {
 					return SUCCESS;
 				}
 			} else {
-				dprintk(DRIVER_NAME "[%d]: ignore dummy code 0x%x (ep=0x%x)\n",
-					ir->devnum, buf[2], iep->ep->bEndpointAddress);
+				dprintk(DRIVER_NAME
+					"[%d]: ignore dummy code 0x%x "
+					"(ep=0x%x)\n", ir->devnum,
+					buf[2], iep->ep->bEndpointAddress);
 				return -1;
 			}
 		}
@@ -560,8 +597,8 @@ static int code_check_ati2(struct in_endpt *iep, int len) {
 			/* handle press/release codes */
 			if (emit_updown == 0) /* ignore */
 				return -1;
-			else if(emit_updown == 1) /* normalize keycode */
-				buf[2] = RW2_PRESSRELEASE_KEYCODE;
+			else if (emit_updown == 1) /* normalize keycode */
+				 buf[2] = RW2_PRESSRELEASE_KEYCODE;
 			/* else emit raw */
 		}
 
@@ -594,11 +631,11 @@ static int code_check_ati2(struct in_endpt *iep, int len) {
 		dir_ns = (y > 0) ? MOUSE_S : MOUSE_N;
 
 		/* convert coordintes(angle) into compass direction */
-		if (x == 0) {
+		if (x == 0)
 			code = dir_ns;
-		} else if (y == 0) {
+		else if (y == 0)
 			code = dir_ew;
-		} else {
+		else {
 			if (abs(1000*y/x) > mgradient)
 				code = dir_ns;
 			if (abs(1000*x/y) > mgradient)
@@ -621,24 +658,19 @@ static int code_check_xbox(struct in_endpt *iep, int len)
 	struct irctl *ir = iep->ir;
 	const int clen = CODE_LENGTH;
 
-	if (len != clen)
-	{
-		dprintk(DRIVER_NAME ": We got %d instead of %d bytes from xbox ir.. ?\n", len, clen);
+	if (len != clen) {
+		dprintk(DRIVER_NAME ": We got %d instead of %d bytes from xbox "
+			"ir.. ?\n", len, clen);
 		return -1;
 	}
 
 	/* check for repeats */
-	if (memcmp(iep->old, iep->buf, len) == 0) 
-	{
-		if (iep->old_jiffies + repeat_jiffies > jiffies) 
-		{
+	if (memcmp(iep->old, iep->buf, len) == 0) {
+		if (iep->old_jiffies + repeat_jiffies > jiffies)
 			return -1;
-		}
-	} 
-	else 
-	{
-		// the third byte of xbox ir packet seems to contain key info
-		// the last two bytes are.. some kind of clock?
+	} else {
+		/* the third byte of xbox ir packet seems to contain key info
+		 * the last two bytes are.. some kind of clock? */
 		iep->buf[0] = iep->buf[2];
 		memset(iep->buf + 1, 0, len - 1);
 		memcpy(iep->old, iep->buf, len);
@@ -659,7 +691,8 @@ static void usb_remote_recv(struct urb *urb)
 
 	if (!urb)
 		return;
-	if (!(iep = urb->context)) {
+	iep = urb->context;
+	if (!iep) {
 #ifdef KERNEL_2_5
 		urb->transfer_flags |= URB_ASYNC_UNLINK;
 #endif
@@ -671,13 +704,12 @@ static void usb_remote_recv(struct urb *urb)
 
 	len = urb->actual_length;
 	if (debug)
-		print_data(iep,urb->transfer_buffer,len);
+		print_data(iep, urb->transfer_buffer, len);
 
 	switch (urb->status) {
 
 	/* success */
 	case SUCCESS:
-
 		switch (iep->ir->remote_type) {
 		case XBOX_COMPATIBLE:
 			result = code_check_xbox(iep, len);
@@ -689,7 +721,8 @@ static void usb_remote_recv(struct urb *urb)
 		default:
 			result = code_check_ati1(iep, len);
 		}
-		if (result < 0) break;
+		if (result < 0)
+			break;
 		lirc_buffer_write_1(iep->ir->p->rbuf, iep->buf);
 		wake_up(&iep->ir->p->rbuf->wait_poll);
 		break;
@@ -725,7 +758,8 @@ static void usb_remote_send(struct urb *urb)
 
 	if (!urb)
 		return;
-	if (!(oep = urb->context)) {
+	oep = urb->context;
+	if (!oep) {
 #ifdef KERNEL_2_5
 		urb->transfer_flags |= URB_ASYNC_UNLINK;
 #endif
@@ -759,7 +793,8 @@ static void free_in_endpt(struct in_endpt *iep, int mem_failure)
 {
 	struct irctl *ir;
 	dprintk(DRIVER_NAME ": free_in_endpt(%p, %d)\n", iep, mem_failure);
-	if (!iep) return;
+	if (!iep)
+		return;
 
 	ir = iep->ir;
 	if (!ir) {
@@ -771,7 +806,8 @@ static void free_in_endpt(struct in_endpt *iep, int mem_failure)
 	case FREE_ALL:
 	case 5:
 		list_del(&iep->iep_list_link);
-		dprintk(DRIVER_NAME "[%d]: free_in_endpt removing ep=0x%0x from list\n", ir->devnum, iep->ep->bEndpointAddress);
+		dprintk(DRIVER_NAME "[%d]: free_in_endpt removing ep=0x%0x "
+			"from list\n", ir->devnum, iep->ep->bEndpointAddress);
 	case 4:
 		if (iep->urb) {
 #ifdef KERNEL_2_5
@@ -780,9 +816,9 @@ static void free_in_endpt(struct in_endpt *iep, int mem_failure)
 			usb_unlink_urb(iep->urb);
 			usb_free_urb(iep->urb);
 			iep->urb = 0;
-		} else {
-			dprintk(DRIVER_NAME "[%d]: free_in_endpt null urb!\n", ir->devnum);
-		}
+		} else
+			dprintk(DRIVER_NAME "[%d]: free_in_endpt null urb!\n",
+				ir->devnum);
 	case 3:
 #ifdef KERNEL_2_5
 		usb_buffer_free(iep->ir->usbdev, iep->len, iep->buf, iep->dma);
@@ -800,7 +836,8 @@ static void free_in_endpt(struct in_endpt *iep, int mem_failure)
  * Construct a new inbound endpoint for this remote, and add it to the list of
  * in_epts in ir.
  */
-static struct in_endpt *new_in_endpt(struct irctl *ir, struct usb_endpoint_descriptor *ep)
+static struct in_endpt *new_in_endpt(struct irctl *ir,
+				     struct usb_endpoint_descriptor *ep)
 {
 	struct usb_device *dev = ir->usbdev;
 	struct in_endpt *iep;
@@ -811,42 +848,53 @@ static struct in_endpt *new_in_endpt(struct irctl *ir, struct usb_endpoint_descr
 	pipe = usb_rcvintpipe(dev, addr);
 	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
 
-//	len = (maxp > USB_BUFLEN) ? USB_BUFLEN : maxp;
-//	len -= (len % CODE_LENGTH);
+/*	len = (maxp > USB_BUFLEN) ? USB_BUFLEN : maxp;
+ *	len -= (len % CODE_LENGTH); */
 	len = CODE_LENGTH;
 
-	dprintk(DRIVER_NAME "[%d]: acceptable inbound endpoint (0x%x) found (maxp=%d len=%d)\n", ir->devnum, addr, maxp, len);
+	dprintk(DRIVER_NAME "[%d]: acceptable inbound endpoint (0x%x) found "
+		"(maxp=%d len=%d)\n", ir->devnum, addr, maxp, len);
 
 	mem_failure = 0;
-	if ( !(iep = kmalloc(sizeof(*iep), GFP_KERNEL)) ) {
+	iep = kmalloc(sizeof(*iep), GFP_KERNEL);
+	if (!iep) {
 		mem_failure = 1;
-	} else {
-		memset(iep, 0, sizeof(*iep));
-		iep->ir = ir;
-		iep->ep = ep;
-		iep->len = len;
+		goto new_in_endpt_failure_check;
+	}
+	memset(iep, 0, sizeof(*iep));
+	iep->ir = ir;
+	iep->ep = ep;
+	iep->len = len;
 
 #ifdef KERNEL_2_5
-		if ( !(iep->buf = usb_buffer_alloc(dev, len, GFP_ATOMIC, &iep->dma)) ) {
-			mem_failure = 2;
-		} else if ( !(iep->urb = usb_alloc_urb(0, GFP_KERNEL)) ) {
-			mem_failure = 3;
-		}
+	iep->buf = usb_buffer_alloc(dev, len, GFP_ATOMIC, &iep->dma);
 #else
-		if ( !(iep->buf = kmalloc(len, GFP_KERNEL)) ) {
-			mem_failure = 2;
-		} else if ( !(iep->urb = usb_alloc_urb(0)) ) {
-			mem_failure = 3;
-		}
+	iep->buf = kmalloc(len, GFP_KERNEL);
 #endif
+	if (!iep->buf) {
+		mem_failure = 2;
+		goto new_in_endpt_failure_check;
 	}
+
+#ifdef KERNEL_2_5
+	iep->urb = usb_alloc_urb(0, GFP_KERNEL);
+#else
+	iep->urb = usb_alloc_urb(0);
+#endif
+	if (!iep->urb)
+		mem_failure = 3;
+
+new_in_endpt_failure_check:
+
 	if (mem_failure) {
 		free_in_endpt(iep, mem_failure);
-		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n", ir->devnum, addr, mem_failure);
+		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n",
+		       ir->devnum, addr, mem_failure);
 		return NULL;
 	}
 	list_add_tail(&iep->iep_list_link, &ir->iep_listhead);
-	dprintk(DRIVER_NAME "[%d]: adding ep=0x%0x to list\n", ir->devnum, iep->ep->bEndpointAddress);
+	dprintk(DRIVER_NAME "[%d]: adding ep=0x%0x to list\n",
+		ir->devnum, iep->ep->bEndpointAddress);
 	return iep;
 }
 
@@ -854,7 +902,8 @@ static void free_out_endpt(struct out_endpt *oep, int mem_failure)
 {
 	struct irctl *ir;
 	dprintk(DRIVER_NAME ": free_out_endpt(%p, %d)\n", oep, mem_failure);
-	if (!oep) return;
+	if (!oep)
+		return;
 
 	wake_up_all(&oep->wait);
 
@@ -875,11 +924,13 @@ static void free_out_endpt(struct out_endpt *oep, int mem_failure)
 			usb_free_urb(oep->urb);
 			oep->urb = 0;
 		} else {
-			dprintk(DRIVER_NAME "[%d]: free_out_endpt: null urb!\n", ir->devnum);
+			dprintk(DRIVER_NAME "[%d]: free_out_endpt: null urb!\n",
+				ir->devnum);
 		}
 	case 3:
 #ifdef KERNEL_2_5
-		usb_buffer_free(oep->ir->usbdev, USB_OUTLEN, oep->buf, oep->dma);
+		usb_buffer_free(oep->ir->usbdev, USB_OUTLEN,
+				oep->buf, oep->dma);
 #else
 		kfree(oep->buf);
 #endif
@@ -890,7 +941,8 @@ static void free_out_endpt(struct out_endpt *oep, int mem_failure)
 	IRUNLOCK;
 }
 
-static struct out_endpt *new_out_endpt(struct irctl *ir, struct usb_endpoint_descriptor *ep)
+static struct out_endpt *new_out_endpt(struct irctl *ir,
+				       struct usb_endpoint_descriptor *ep)
 {
 #ifdef KERNEL_2_5
 	struct usb_device *dev = ir->usbdev;
@@ -898,34 +950,41 @@ static struct out_endpt *new_out_endpt(struct irctl *ir, struct usb_endpoint_des
 	struct out_endpt *oep;
 	int mem_failure;
 
-	dprintk(DRIVER_NAME "[%d]: acceptable outbound endpoint (0x%x) found\n", ir->devnum, ep->bEndpointAddress);
+	dprintk(DRIVER_NAME "[%d]: acceptable outbound endpoint (0x%x) found\n",
+		ir->devnum, ep->bEndpointAddress);
 
 	mem_failure = 0;
-	if ( !(oep = kmalloc(sizeof(*oep), GFP_KERNEL)) ) {
+	oep = kmalloc(sizeof(*oep), GFP_KERNEL);
+	if (!oep)
 		mem_failure = 1;
-	} else {
+	else {
 		memset(oep, 0, sizeof(*oep));
 		oep->ir = ir;
 		oep->ep = ep;
 		init_waitqueue_head(&oep->wait);
 
 #ifdef KERNEL_2_5
-		if ( !(oep->buf = usb_buffer_alloc(dev, USB_OUTLEN, GFP_ATOMIC, &oep->dma)) ) {
-			mem_failure = 2;
-		} else if ( !(oep->urb = usb_alloc_urb(0, GFP_KERNEL)) ) {
-			mem_failure = 3;
-		}
+		oep->buf = usb_buffer_alloc(dev, USB_OUTLEN,
+					    GFP_ATOMIC, &oep->dma);
 #else
-		if ( !(oep->buf = kmalloc(USB_OUTLEN, GFP_KERNEL)) ) {
+		oep->buf = kmalloc(USB_OUTLEN, GFP_KERNEL);
+#endif
+		if (!oep->buf)
 			mem_failure = 2;
-		} else if ( !(oep->urb = usb_alloc_urb(0)) ) {
-			mem_failure = 3;
-		}
+		else {
+#ifdef KERNEL_2_5
+			oep->urb = usb_alloc_urb(0, GFP_KERNEL);
+#else
+			oep->urb = usb_alloc_urb(0);
 #endif
+			if (!oep->urb)
+				mem_failure = 3;
+		}
 	}
 	if (mem_failure) {
 		free_out_endpt(oep, mem_failure);
-		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n", ir->devnum, ep->bEndpointAddress, mem_failure);
+		printk(DRIVER_NAME "[%d]: ep=0x%x out of memory (code=%d)\n",
+		       ir->devnum, ep->bEndpointAddress, mem_failure);
 		return NULL;
 	}
 	return oep;
@@ -937,7 +996,8 @@ static void free_irctl(struct irctl *ir, int mem_failure)
 	struct in_endpt *in;
 	dprintk(DRIVER_NAME ": free_irctl(%p, %d)\n", ir, mem_failure);
 
-	if (!ir) return;
+	if (!ir)
+		return;
 
 	list_for_each_safe(pos, n, &ir->iep_listhead) {
 		in = get_iep_from_link(pos);
@@ -952,13 +1012,14 @@ static void free_irctl(struct irctl *ir, int mem_failure)
 	switch (mem_failure) {
 	case FREE_ALL:
 	case 6:
-	    	if (!--ir->dev_refcount) {
+		if (!--ir->dev_refcount) {
 			list_del(&ir->remote_list_link);
-			dprintk(DRIVER_NAME "[%d]: free_irctl: removing remote from list\n",
-				ir->devnum);
+			dprintk(DRIVER_NAME "[%d]: free_irctl: removing "
+				"remote from list\n", ir->devnum);
 		} else {
 			dprintk(DRIVER_NAME "[%d]: free_irctl: refcount at %d,"
-				"aborting free_irctl\n", ir->devnum, ir->dev_refcount);
+				"aborting free_irctl\n",
+				ir->devnum, ir->dev_refcount);
 			IRUNLOCK;
 			return;
 		}
@@ -967,13 +1028,16 @@ static void free_irctl(struct irctl *ir, int mem_failure)
 	case 3:
 		if (ir->p) {
 			switch (mem_failure) {
-			case 5: lirc_buffer_free(ir->p->rbuf);
-			case 4: kfree(ir->p->rbuf);
-			case 3: kfree(ir->p);
+			case 5:
+				lirc_buffer_free(ir->p->rbuf);
+			case 4:
+				kfree(ir->p->rbuf);
+			case 3:
+				kfree(ir->p);
 			}
-		} else {
-			printk(DRIVER_NAME "[%d]: ir->p is a null pointer!\n", ir->devnum);
-		}
+		} else
+			printk(DRIVER_NAME "[%d]: ir->p is a null pointer!\n",
+			       ir->devnum);
 	case 2:
 		IRUNLOCK;
 		kfree(ir);
@@ -986,9 +1050,9 @@ static struct irctl *new_irctl(struct usb_device *dev)
 {
 	struct irctl *ir;
 	struct lirc_plugin *plugin;
-	struct lirc_buffer *rbuf;
 	int type, devnum;
 	int mem_failure;
+	int dclen;
 
 	devnum = dev->devnum;
 
@@ -1002,6 +1066,7 @@ static struct irctl *new_irctl(struct usb_device *dev)
 		break;
 	case VENDOR_MS1:
 	case VENDOR_MS2:
+	case VENDOR_MS3:
 		type = XBOX_COMPATIBLE;
 		break;
 	default:
@@ -1012,51 +1077,66 @@ static struct irctl *new_irctl(struct usb_device *dev)
 
 	/* allocate kernel memory */
 	mem_failure = 0;
-	if ( !(ir = kmalloc(sizeof(*ir), GFP_KERNEL)) ) {
+	ir = kmalloc(sizeof(*ir), GFP_KERNEL);
+	if (!ir) {
 		mem_failure = 1;
-	} else {
-	        // at this stage we cannot use the macro [DE]CODE_LENGTH: ir is not yet setup
-	        const int dclen = decode_length[type];
-		memset(ir, 0, sizeof(*ir));
-		/* add this infrared remote struct to remote_list, keeping track of
-		 * the number of drivers registered. */
-		dprintk(DRIVER_NAME "[%d]: adding remote to list\n", devnum);
-		list_add_tail(&ir->remote_list_link, &remote_list);
-		ir->dev_refcount=1;
-
-		if (!(plugin = kmalloc(sizeof(*plugin), GFP_KERNEL))) {
-			mem_failure = 2;
-		} else if (!(rbuf = kmalloc(sizeof(*rbuf), GFP_KERNEL))) {
-			mem_failure = 3;
-		} else if (lirc_buffer_init(rbuf, dclen, 1)) {
-			mem_failure = 4;
-		} else {
-			memset(plugin, 0, sizeof(*plugin));
-			strcpy(plugin->name, DRIVER_NAME " ");
-			plugin->minor = -1;
-			plugin->code_length = dclen * 8;
-			plugin->features = LIRC_CAN_REC_LIRCCODE;
-			plugin->data = ir;
-			plugin->rbuf = rbuf;
-			plugin->set_use_inc = &set_use_inc;
-			plugin->set_use_dec = &set_use_dec;
+		goto new_irctl_failure_check;
+	}
+
+	/* at this stage we cannot use the macro [DE]CODE_LENGTH: ir
+	 * is not yet setup */
+	dclen = decode_length[type];
+	memset(ir, 0, sizeof(*ir));
+	/* add this infrared remote struct to remote_list, keeping track
+	 * of the number of drivers registered. */
+	dprintk(DRIVER_NAME "[%d]: adding remote to list\n", devnum);
+	list_add_tail(&ir->remote_list_link, &remote_list);
+	ir->dev_refcount = 1;
+
+	plugin = kmalloc(sizeof(*plugin), GFP_KERNEL);
+	if (!plugin) {
+		mem_failure = 2;
+		goto new_irctl_failure_check;
+	}
+
+	memset(plugin, 0, sizeof(*plugin));
+	ir->p = plugin;
+	plugin->rbuf = kmalloc(sizeof(*(plugin->rbuf)), GFP_KERNEL);
+	if (!plugin->rbuf) {
+		mem_failure = 3;
+		goto new_irctl_failure_check;
+	}
+
+	if (lirc_buffer_init(plugin->rbuf, dclen, 1)) {
+		mem_failure = 4;
+		goto new_irctl_failure_check;
+	}
+
+	strcpy(plugin->name, DRIVER_NAME " ");
+	plugin->minor = -1;
+	plugin->code_length = dclen * 8;
+	plugin->features = LIRC_CAN_REC_LIRCCODE;
+	plugin->data = ir;
+	plugin->set_use_inc = &set_use_inc;
+	plugin->set_use_dec = &set_use_dec;
 #ifdef LIRC_HAVE_SYSFS
-			plugin->dev = &dev->dev;
+	plugin->dev = &dev->dev;
 #endif
-			plugin->owner = THIS_MODULE;
-			ir->usbdev = dev;
-			ir->p = plugin;
-			ir->remote_type = type;
-			ir->devnum = devnum;
-			ir->mode = RW2_NULL_MODE;
-
-			init_MUTEX(&ir->lock);
-			INIT_LIST_HEAD(&ir->iep_listhead);
-		}
-	}
+	plugin->owner = THIS_MODULE;
+	ir->usbdev = dev;
+	ir->remote_type = type;
+	ir->devnum = devnum;
+	ir->mode = RW2_NULL_MODE;
+
+	init_MUTEX(&ir->lock);
+	INIT_LIST_HEAD(&ir->iep_listhead);
+
+new_irctl_failure_check:
+
 	if (mem_failure) {
 		free_irctl(ir, mem_failure);
-		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n", devnum, mem_failure);
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+		       devnum, mem_failure);
 		return NULL;
 	}
 	return ir;
@@ -1068,7 +1148,8 @@ static struct irctl *new_irctl(struct usb_device *dev)
  * If it is, the corresponding irctl is returned, with its dev_refcount
  * incremented.  Otherwise, returns null.
  */
-static struct irctl *get_prior_reg_ir(struct usb_device *dev) {
+static struct irctl *get_prior_reg_ir(struct usb_device *dev)
+{
 	struct list_head *pos;
 	struct irctl *ir = NULL;
 
@@ -1076,12 +1157,14 @@ static struct irctl *get_prior_reg_ir(struct usb_device *dev) {
 	list_for_each(pos, &remote_list) {
 		ir = get_irctl_from_link(pos);
 		if (ir->usbdev != dev) {
-		    dprintk(DRIVER_NAME "[%d]: device %d isn't it...", dev->devnum, ir->devnum);
+			dprintk(DRIVER_NAME "[%d]: device %d isn't it...",
+				dev->devnum, ir->devnum);
 		    ir = NULL;
 		} else {
-		    dprintk(DRIVER_NAME "[%d]: prior instance found.\n", dev->devnum);
-		    ir->dev_refcount++;
-		    break;
+			dprintk(DRIVER_NAME "[%d]: prior instance found.\n",
+				dev->devnum);
+			ir->dev_refcount++;
+			break;
 		}
 	}
 	return ir;
@@ -1089,13 +1172,16 @@ static struct irctl *get_prior_reg_ir(struct usb_device *dev) {
 
 /* If the USB interface has an out endpoint for control (eg, the first Remote
  * Wonder) send the appropriate initialization packets. */
-static void send_outbound_init(struct irctl *ir) {
+static void send_outbound_init(struct irctl *ir)
+{
 	if (ir->out_init) {
 		struct out_endpt *oep = ir->out_init;
-		dprintk(DRIVER_NAME "[%d]: usb_remote_probe: initializing outbound ep\n", ir->devnum);
+		dprintk(DRIVER_NAME "[%d]: usb_remote_probe: initializing "
+			"outbound ep\n", ir->devnum);
 		usb_fill_int_urb(oep->urb, ir->usbdev,
-			usb_sndintpipe(ir->usbdev, oep->ep->bEndpointAddress), oep->buf,
-			USB_OUTLEN, usb_remote_send, oep, oep->ep->bInterval);
+			usb_sndintpipe(ir->usbdev, oep->ep->bEndpointAddress),
+			oep->buf, USB_OUTLEN, usb_remote_send,
+			oep, oep->ep->bInterval);
 
 		send_packet(oep, 0x8004, init1);
 		send_packet(oep, 0x8007, init2);
@@ -1103,13 +1189,14 @@ static void send_outbound_init(struct irctl *ir) {
 }
 
 /* Log driver and usb info */
-static void log_usb_dev_info(struct usb_device *dev) {
-	char buf[63], name[128]="";
+static void log_usb_dev_info(struct usb_device *dev)
+{
+	char buf[63], name[128] = "";
 	if (dev->descriptor.iManufacturer
-		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+	    && usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
 		strncpy(name, buf, 128);
 	if (dev->descriptor.iProduct
-		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+	    && usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
 		snprintf(name, 128, "%s %s", name, buf);
 	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", dev->devnum, name,
 	       dev->bus->busnum, dev->devnum);
@@ -1137,26 +1224,28 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	dprintk(DRIVER_NAME "[%d]: usb_remote_probe: dev:%p, intf:%p, id:%p)\n",
 		dev->devnum, dev, intf, id);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
-	idesc = intf->cur_altsetting;
-#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
 	idesc = &intf->altsetting[intf->act_altsetting];
+#else
+	idesc = intf->cur_altsetting;
 #endif
 
 	/* Check if a usb remote has already been registered for this device */
 	ir = get_prior_reg_ir(dev);
 
-	if ( !ir && !(ir = new_irctl(dev)) ) {
+	if (!ir) {
+		ir = new_irctl(dev);
+		if (!ir)
 #ifdef KERNEL_2_5
-		return -ENOMEM;
+			return -ENOMEM;
 #else
-		return NULL;
+			return NULL;
 #endif
 	}
 	type = ir->remote_type;
 
-	// step through the endpoints to find first in and first out endpoint
-	// of type interrupt transfer
+	/* step through the endpoints to find first in and first out endpoint
+	 * of type interrupt transfer */
 #ifdef KERNEL_2_5
 	for (i = 0; i < idesc->desc.bNumEndpoints; ++i) {
 		ep = &idesc->endpoint[i].desc;
@@ -1164,26 +1253,32 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	for (i = 0; i < idesc->bNumEndpoints; ++i) {
 		ep = &idesc->endpoint[i];
 #endif
-		dprintk(DRIVER_NAME "[%d]: processing endpoint %d\n", dev->devnum, i);
-		if ( ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
-			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)) {
-
-			if ((iep = new_in_endpt(ir,ep))) {
+		dprintk(DRIVER_NAME "[%d]: processing endpoint %d\n",
+			dev->devnum, i);
+		if (((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
+		     USB_DIR_IN) &&
+		     ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		      USB_ENDPOINT_XFER_INT)) {
+
+			iep = new_in_endpt(ir, ep);
+			if (iep)
 				usb_fill_int_urb(iep->urb, dev,
-					usb_rcvintpipe(dev,iep->ep->bEndpointAddress), iep->buf,
-					iep->len, usb_remote_recv, iep, iep->ep->bInterval);
-			}
+					usb_rcvintpipe(dev,
+						iep->ep->bEndpointAddress),
+					iep->buf, iep->len, usb_remote_recv,
+					iep, iep->ep->bInterval);
 		}
 
-		if ( ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
-			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)
-			&& (ir->out_init == NULL)) {
-
-			ir->out_init = new_out_endpt(ir,ep);
-		}
+		if (((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
+		     USB_DIR_OUT) &&
+		     ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		      USB_ENDPOINT_XFER_INT) &&
+		      (ir->out_init == NULL))
+			ir->out_init = new_out_endpt(ir, ep);
 	}
 	if (list_empty(&ir->iep_listhead)) {
-		printk(DRIVER_NAME "[%d]: inbound endpoint not found\n", ir->devnum);
+		printk(DRIVER_NAME "[%d]: inbound endpoint not found\n",
+		       ir->devnum);
 		free_irctl(ir, FREE_ALL);
 #ifdef KERNEL_2_5
 		return -ENODEV;
@@ -1192,7 +1287,8 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 #endif
 	}
 	if (ir->dev_refcount == 1) {
-		if ((ir->p->minor = lirc_register_plugin(ir->p)) < 0) {
+		ir->p->minor = lirc_register_plugin(ir->p);
+		if (ir->p->minor < 0) {
 			free_irctl(ir, FREE_ALL);
 #ifdef KERNEL_2_5
 			return -ENODEV;
@@ -1219,7 +1315,7 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 #ifdef KERNEL_2_5
 static void usb_remote_disconnect(struct usb_interface *intf)
 {
-//	struct usb_device *dev = interface_to_usbdev(intf);
+/*	struct usb_device *dev = interface_to_usbdev(intf); */
 	struct irctl *ir = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 #else
@@ -1228,7 +1324,8 @@ static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
 	struct irctl *ir = ptr;
 #endif
 
-	dprintk(DRIVER_NAME ": disconnecting remote %d:\n", (ir? ir->devnum: -1));
+	dprintk(DRIVER_NAME ": disconnecting remote %d:\n",
+		(ir? ir->devnum: -1));
 	if (!ir || !ir->p)
 		return;
 
@@ -1244,10 +1341,10 @@ static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
 
 static struct usb_driver usb_remote_driver = {
 	LIRC_THIS_MODULE(.owner = THIS_MODULE)
-	.name =		DRIVER_NAME,
-	.probe =	usb_remote_probe,
-	.disconnect =	usb_remote_disconnect,
-	.id_table =	usb_remote_table
+	.name		= DRIVER_NAME,
+	.probe		= usb_remote_probe,
+	.disconnect	= usb_remote_disconnect,
+	.id_table	= usb_remote_table
 };
 
 static int __init usb_remote_init(void)
@@ -1256,15 +1353,18 @@ static int __init usb_remote_init(void)
 
 	INIT_LIST_HEAD(&remote_list);
 
-	printk("\n" DRIVER_NAME ": " DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(KERN_INFO "\n" DRIVER_NAME ": " DRIVER_DESC " "
+	       DRIVER_VERSION "\n");
 	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
-	dprintk(DRIVER_NAME ": debug mode enabled: $Id: lirc_atiusb.c,v 1.61 2007/04/29 14:23:04 lirc Exp $\n");
+	dprintk(DRIVER_NAME ": debug mode enabled: "
+		"$Id: lirc_atiusb.c,v 1.69 2008/04/28 06:47:29 lirc Exp $\n");
 
 	request_module("lirc_dev");
 
 	repeat_jiffies = repeat*HZ/100;
 
-	if ((i = usb_register(&usb_remote_driver)) < 0) {
+	i = usb_register(&usb_remote_driver);
+	if (i) {
 		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
 		return -ENODEV;
 	}
@@ -1304,9 +1404,9 @@ MODULE_PARM_DESC(mdeadzone, "rw2 mouse sensitivity threshold (default: 0)");
  * Enabling this will cause the built-in Remote Wonder II repeate coding to
  * not be squashed.  The second byte of the keys output will then be:
  *
- * 	1 initial press (button down)
- * 	2 holding (button remains pressed)
- * 	0 release (button up)
+ *	1 initial press (button down)
+ *	2 holding (button remains pressed)
+ *	0 release (button up)
  *
  * By default, the driver emits 2 for both 1 and 2, and emits nothing for 0.
  * This is good for people having trouble getting their rw2 to send a good
@@ -1316,18 +1416,22 @@ MODULE_PARM_DESC(mdeadzone, "rw2 mouse sensitivity threshold (default: 0)");
  * at random points while you're still holding a button, then you can enable
  * this parameter to get finer grain repeat control out of your remote:
  *
- * 	1 Emit a single (per-channel) virtual code for all up/down events
- * 	2 Emit the actual rw2 output
+ *	1 Emit a single (per-channel) virtual code for all up/down events
+ *	2 Emit the actual rw2 output
  *
  * 1 is easier to write lircd configs for; 2 allows full control.
  */
 module_param(emit_updown, int, 0644);
-MODULE_PARM_DESC(emit_updown, "emit press/release codes (rw2): 0:don't (default), 1:emit 2 codes only, 2:code for each button");
+MODULE_PARM_DESC(emit_updown, "emit press/release codes (rw2): 0:don't "
+		 "(default), 1:emit 2 codes only, 2:code for each button");
 
 module_param(emit_modekeys, int, 0644);
-MODULE_PARM_DESC(emit_modekeys, "emit keycodes for aux1-aux4, pc, and mouse (rw2): 0:don't (default), 1:emit translated codes: one for mode switch, one for same mode, 2:raw codes");
+MODULE_PARM_DESC(emit_modekeys, "emit keycodes for aux1-aux4, pc, and mouse "
+		 "(rw2): 0:don't (default), 1:emit translated codes: one for "
+		 "mode switch, one for same mode, 2:raw codes");
 
 module_param(mgradient, int, 0644);
-MODULE_PARM_DESC(mgradient, "rw2 mouse: 1000*gradient from E to NE (default: 500 => .5 => ~27 degrees)");
+MODULE_PARM_DESC(mgradient, "rw2 mouse: 1000*gradient from E to NE (default: "
+		 "500 => .5 => ~27 degrees)");
 
 EXPORT_NO_SYMBOLS;
diff --git a/drivers/char/lirc/lirc_bt829.c b/drivers/char/lirc/lirc_bt829.c
index 50d1bd7..6efac1b 100644
--- a/drivers/char/lirc/lirc_bt829.c
+++ b/drivers/char/lirc/lirc_bt829.c
@@ -38,7 +38,7 @@
 static int poll_main(void);
 static int atir_init_start(void);
 
-static void write_index(unsigned char index,unsigned int value);
+static void write_index(unsigned char index, unsigned int value);
 static unsigned int read_index(unsigned char index);
 
 static void do_i2c_start(void);
@@ -48,7 +48,7 @@ static void seems_wr_byte(unsigned char al);
 static unsigned char seems_rd_byte(void);
 
 static unsigned int read_index(unsigned char al);
-static void write_index(unsigned char ah,unsigned int edx);
+static void write_index(unsigned char ah, unsigned int edx);
 
 static void cycle_delay(int cycle);
 
@@ -58,11 +58,12 @@ static unsigned char do_get_bits(void);
 #define DATA_PCI_OFF 0x7FFC00
 #define WAIT_CYCLE   20
 
-static int debug = 0;
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
+static int debug;
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
 static int atir_minor;
 static unsigned long pci_addr_phys;
@@ -75,20 +76,21 @@ static struct pci_dev *do_pci_probe(void)
 	struct pci_dev *my_dev;
 #ifndef KERNEL_2_5
 	/* unnecessary with recent kernels */
-	if ( !pci_present() ) {
+	if (!pci_present())
 		printk(KERN_ERR "ATIR: no pci in this kernel\n");
-	}
 #endif
-	my_dev = (struct pci_dev *)pci_find_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_264VT,NULL);
-	if ( my_dev ) {
+	my_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+				PCI_DEVICE_ID_ATI_264VT, NULL);
+	if (my_dev) {
 		printk(KERN_ERR "ATIR: Using device: %s\n",
 		       pci_name(my_dev));
 		pci_addr_phys = 0;
-		if ( my_dev->resource[0].flags & IORESOURCE_MEM ) {
+		if (my_dev->resource[0].flags & IORESOURCE_MEM) {
 			pci_addr_phys = my_dev->resource[0].start;
-			printk(KERN_INFO "ATIR memory at 0x%08X \n",(unsigned int)pci_addr_phys);
+			printk(KERN_INFO "ATIR memory at 0x%08X \n",
+			       (unsigned int)pci_addr_phys);
 		}
-		if ( pci_addr_phys == 0 ) {
+		if (pci_addr_phys == 0) {
 			printk(KERN_ERR "ATIR no memory resource ?\n");
 			return NULL;
 		}
@@ -99,29 +101,28 @@ static struct pci_dev *do_pci_probe(void)
 	return my_dev;
 }
 
-static int atir_add_to_buf (void* data, struct lirc_buffer* buf)
+static int atir_add_to_buf(void *data, struct lirc_buffer *buf)
 {
 	unsigned char key;
 	int status;
 	status = poll_main();
 	key = (status >> 8) & 0xFF;
-	if( status & 0xFF )
-	{
-	//    printk(KERN_INFO "ATIR reading key %02X\n",*key);
-		lirc_buffer_write_1( buf, &key );
+	if (status & 0xFF) {
+		dprintk("ATIR reading key %02X\n", key);
+		lirc_buffer_write_1(buf, &key);
 		return 0;
 	}
 	return -ENODATA;
 }
 
-static int atir_set_use_inc(void* data)
+static int atir_set_use_inc(void *data)
 {
 	MOD_INC_USE_COUNT;
 	dprintk("ATIR driver is opened\n");
 	return 0;
 }
 
-static void atir_set_use_dec(void* data)
+static void atir_set_use_dec(void *data)
 {
 	MOD_DEC_USE_COUNT;
 	dprintk("ATIR driver is closed\n");
@@ -132,15 +133,13 @@ int init_module(void)
 	struct pci_dev *pdev;
 
 	pdev = do_pci_probe();
-	if ( pdev == NULL ) {
+	if (pdev == NULL)
 		return 1;
-	}
 
-	if ( !atir_init_start() ) {
+	if (!atir_init_start())
 		return 1;
-	}
 
-	strcpy(atir_plugin.name,"ATIR");
+	strcpy(atir_plugin.name, "ATIR");
 	atir_plugin.minor       = -1;
 	atir_plugin.code_length = 8;
 	atir_plugin.sample_rate = 10;
@@ -154,7 +153,7 @@ int init_module(void)
 	atir_plugin.owner       = THIS_MODULE;
 
 	atir_minor = lirc_register_plugin(&atir_plugin);
-	dprintk("ATIR driver is registered on minor %d\n",atir_minor);
+	dprintk("ATIR driver is registered on minor %d\n", atir_minor);
 
 	return 0;
 }
@@ -168,8 +167,8 @@ void cleanup_module(void)
 
 static int atir_init_start(void)
 {
-	pci_addr_lin = ioremap(pci_addr_phys + DATA_PCI_OFF,0x400);
-	if ( pci_addr_lin == 0 ) {
+	pci_addr_lin = ioremap(pci_addr_phys + DATA_PCI_OFF, 0x400);
+	if (pci_addr_lin == 0) {
 		printk(KERN_INFO "atir: pci mem must be mapped\n");
 		return 0;
 	}
@@ -185,7 +184,7 @@ static void cycle_delay(int cycle)
 static int poll_main()
 {
 	unsigned char status_high, status_low;
-	
+
 	do_i2c_start();
 
 	seems_wr_byte(0xAA);
@@ -237,14 +236,14 @@ static void seems_wr_byte(unsigned char value)
 {
 	int i;
 	unsigned char reg;
-    
+
 	reg = do_get_bits();
-	for(i = 0;i < 8;i++) {
-		if ( value & 0x80 ) {
+	for (i = 0; i < 8; i++) {
+		if (value & 0x80)
 			reg |= 0x02;
-		} else {
+		else
 			reg &= 0xFD;
-		}
+
 		do_set_bits(reg);
 		cycle_delay(1);
 
@@ -283,7 +282,7 @@ static unsigned char seems_rd_byte(void)
 	do_set_bits(bits_1);
 
 	rd_byte = 0;
-	for(i = 0;i < 8;i++) {
+	for (i = 0; i < 8; i++) {
 		bits_1 &= 0xFE;
 		do_set_bits(bits_1);
 		cycle_delay(2);
@@ -292,16 +291,17 @@ static unsigned char seems_rd_byte(void)
 		do_set_bits(bits_1);
 		cycle_delay(1);
 
-		if ( (bits_2 = do_get_bits()) & 2 ) {
+		bits_2 = do_get_bits();
+		if (bits_2 & 2)
 			rd_byte |= 1;
-		}
+
 		rd_byte <<= 1;
 	}
 
 	bits_1 = 0;
-	if ( bits_2 == 0 ) {
+	if (bits_2 == 0)
 		bits_1 |= 2;
-	}
+
 	do_set_bits(bits_1);
 	cycle_delay(2);
 
@@ -322,7 +322,7 @@ static void do_set_bits(unsigned char new_bits)
 {
 	int reg_val;
 	reg_val = read_index(0x34);
-	if ( new_bits & 2 ) {
+	if (new_bits & 2) {
 		reg_val &= 0xFFFFFFDF;
 		reg_val |= 1;
 	} else {
@@ -330,16 +330,16 @@ static void do_set_bits(unsigned char new_bits)
 		reg_val |= 0x20;
 	}
 	reg_val |= 0x10;
-	write_index(0x34,reg_val);
+	write_index(0x34, reg_val);
 
 	reg_val = read_index(0x31);
-	if ( new_bits & 1 ) {
+	if (new_bits & 1) {
 		reg_val |= 0x1000000;
 	} else {
 		reg_val &= 0xFEFFFFFF;
 	}
 	reg_val |= 0x8000000;
-	write_index(0x31,reg_val);
+	write_index(0x31, reg_val);
 }
 
 static unsigned char do_get_bits(void)
@@ -350,18 +350,18 @@ static unsigned char do_get_bits(void)
 	reg_val = read_index(0x34);
 	reg_val |= 0x10;
 	reg_val &= 0xFFFFFFDF;
-	write_index(0x34,reg_val);
+	write_index(0x34, reg_val);
 
 	reg_val = read_index(0x34);
 	bits = 0;
-	if ( reg_val & 8 ) {
+	if (reg_val & 8) {
 		bits |= 2;
 	} else {
 		bits &= 0xFD;
 	}
 	reg_val = read_index(0x31);
-	if ( reg_val & 0x1000000 ) {
-		bits |= 1;	
+	if (reg_val & 0x1000000) {
+		bits |= 1;
 	} else {
 		bits &= 0xFE;
 	}
@@ -372,17 +372,17 @@ static unsigned int read_index(unsigned char index)
 {
 	unsigned char *addr;
 	unsigned int value;
-	//  addr = pci_addr_lin + DATA_PCI_OFF + ((index & 0xFF) << 2);
+	/*  addr = pci_addr_lin + DATA_PCI_OFF + ((index & 0xFF) << 2); */
 	addr = pci_addr_lin + ((index & 0xFF) << 2);
 	value = readl(addr);
 	return value;
 }
 
-static void write_index(unsigned char index,unsigned int reg_val)
+static void write_index(unsigned char index, unsigned int reg_val)
 {
 	unsigned char *addr;
 	addr = pci_addr_lin + ((index & 0xFF) << 2);
-	writel(reg_val,addr);
+	writel(reg_val, addr);
 }
 
 MODULE_AUTHOR("Froenchenko Leonid");
diff --git a/drivers/char/lirc/lirc_cmdir.c b/drivers/char/lirc/lirc_cmdir.c
index 7d395f8..329d6eb 100644
--- a/drivers/char/lirc/lirc_cmdir.c
+++ b/drivers/char/lirc/lirc_cmdir.c
@@ -1,4 +1,4 @@
-/*      $Id: lirc_cmdir.c,v 1.6 2007/02/13 06:45:15 lirc Exp $      */
+/*      $Id: lirc_cmdir.c,v 1.9 2008/01/13 11:13:49 lirc Exp $      */
 
 /*
  * lirc_cmdir.c - Driver for InnovationOne's COMMANDIR USB Transceiver
@@ -27,7 +27,7 @@
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
- 
+
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
 #error "**********************************************************"
@@ -50,13 +50,18 @@
 #include "kcompat.h"
 #include "lirc_cmdir.h"
 
-struct lirc_cmdir
-{
+static int debug;
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
+
+struct lirc_cmdir {
 	int features;
 };
 
-struct lirc_cmdir hardware=
-{
+struct lirc_cmdir hardware = {
 	(
 	/* LIRC_CAN_SET_SEND_DUTY_CYCLE|   */
 	LIRC_CAN_SET_SEND_CARRIER|
@@ -75,10 +80,10 @@ static struct lirc_buffer rbuf;
 static lirc_t wbuf[WBUF_LEN];
 static unsigned char cmdir_char[4*WBUF_LEN];
 static unsigned char write_control[MCU_CTRL_SIZE];
-static unsigned int last_mc_time = 0;
-static int usb_status=ON;
-static unsigned char signal_num=0;
-char timerval=0;
+static unsigned int last_mc_time;
+static int usb_status = ON;
+static unsigned char signal_num;
+char timerval;
 
 unsigned int freq = 38000;
 /* unsigned int duty_cycle = 50; */
@@ -92,54 +97,47 @@ unsigned int freq = 38000;
 
 static inline void safe_udelay(unsigned long usecs)
 {
-	while(usecs>MAX_UDELAY_US)
-	{
+	while (usecs > MAX_UDELAY_US) {
 		udelay(MAX_UDELAY_US);
-		usecs-=MAX_UDELAY_US;
+		usecs -= MAX_UDELAY_US;
 	}
 	udelay(usecs);
 }
 
-static unsigned int get_time_value(unsigned int firstint, unsigned int secondint, unsigned char overflow) 
+static unsigned int get_time_value(unsigned int firstint,
+			unsigned int secondint, unsigned char overflow)
 {	/* get difference between two timestamps from MCU */
 	unsigned int t_answer = 0;
-	
-	if (secondint > firstint) 
-	{
+
+	if (secondint > firstint) {
 		t_answer = secondint - firstint + overflow*65536;
-	} 
-	else 
-	{
-		if (overflow > 0) 
-		{
-			t_answer = (65536 - firstint) + secondint + (overflow - 1)*65536;
-		} 
-		else 
-		{
+	} else {
+		if (overflow > 0)
+			t_answer = (65536 - firstint) + secondint +
+						(overflow - 1) * 65536;
+		else
 			t_answer = (65536 - firstint) + secondint;
-		}
 	}
 
 	/* clamp to long signal  */
-	if (t_answer > 16000000) t_answer = PULSE_MASK;
-	
+	if (t_answer > 16000000)
+		t_answer = PULSE_MASK;
+
 	return t_answer;
 }
 
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	/* Init read buffer. */
 	if (lirc_buffer_init(&rbuf, sizeof(lirc_t), RBUF_LEN) < 0)
-	{
 		return -ENOMEM;
-	}
-	
+
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 	lirc_buffer_free(&rbuf);
 	MOD_DEC_USE_COUNT;
@@ -148,35 +146,29 @@ static void set_use_dec(void* data)
 
 static void usb_error_handle(int retval)
 {
-	switch (retval)
-	{
-		case -ENODEV:
-			/* device has been unplugged */
-			if (usb_status == ON)
-			{
-				usb_status = OFF;
-				printk(LIRC_DRIVER_NAME ": device is unplugged\n");
-			}
-			break;
-		default:
-			printk(LIRC_DRIVER_NAME ": usb error = %d\n", retval);
-			break;
+	switch (retval) {
+	case -ENODEV:
+		/* device has been unplugged */
+		if (usb_status == ON) {
+			usb_status = OFF;
+			printk(LIRC_DRIVER_NAME ": device is unplugged\n");
+		}
+		break;
+	default:
+		printk(LIRC_DRIVER_NAME ": usb error = %d\n", retval);
+		break;
 	}
 }
 
 static int write_to_usb(unsigned char *buffer, int count, int time_elapsed)
 {
 	int write_return;
-	
+
 	write_return = cmdir_write(buffer, count, NULL, time_elapsed);
-	if (write_return != count)
-	{
+	if (write_return != count) {
 		usb_error_handle(write_return);
-	}
-	else
-	{
-		if (usb_status == OFF) 
-		{
+	} else {
+		if (usb_status == OFF) {
 			printk(LIRC_DRIVER_NAME ": device is now plugged in\n");
 			usb_status = ON;
 		}
@@ -186,17 +178,22 @@ static int write_to_usb(unsigned char *buffer, int count, int time_elapsed)
 
 static void set_freq(void)
 {
-	/* float tempfreq=0.0; */
+	/* float tempfreq = 0.0; */
 	int write_return;
-	
-	/* can't use floating point in 2.6 kernel! May be some loss of precision */
+
+	/*
+	 * Can't use floating point in 2.6 kernel!
+	 * May be some loss of precision
+	 */
 	timerval = (1000000 / freq) / 2;
-	write_control[0]=FREQ_HEADER;
-	write_control[1]=timerval;
-	write_control[2]=0;
+	write_control[0] = FREQ_HEADER;
+	write_control[1] = timerval;
+	write_control[2] = 0;
 	write_return = write_to_usb(write_control, MCU_CTRL_SIZE, 0);
-	if (write_return == MCU_CTRL_SIZE) printk(LIRC_DRIVER_NAME ": freq set to %dHz\n", freq);
-	else printk(LIRC_DRIVER_NAME ": freq unchanged\n");
+	if (write_return == MCU_CTRL_SIZE)
+		printk(LIRC_DRIVER_NAME ": freq set to %dHz\n", freq);
+	else
+		printk(LIRC_DRIVER_NAME ": freq unchanged\n");
 
 }
 
@@ -204,72 +201,85 @@ static int cmdir_convert_RX(unsigned char *orig_rxbuffer)
 {
 	unsigned char tmp_char_buffer[80];
 	unsigned int tmp_int_buffer[20];
-	unsigned int final_data_buffer[20];	
+	unsigned int final_data_buffer[20];
 	unsigned int num_data_values = 0;
 	unsigned char num_data_bytes = 0;
 	unsigned int orig_index = 0;
 	int i;
-	
-	for (i=0; i<80; i++) tmp_char_buffer[i]=0;
-	for (i=0; i<20; i++) tmp_int_buffer[i]=0;
 
-	/* get number of data bytes that follow the control bytes (NOT including them)	 */
+	for (i = 0; i < 80; i++)
+		tmp_char_buffer[i] = 0;
+	for (i = 0; i < 20; i++)
+		tmp_int_buffer[i] = 0;
+
+	/*
+	 * get number of data bytes that follow the control bytes
+	 * (NOT including them)
+	 */
 	num_data_bytes = orig_rxbuffer[1];
-	
-	/* check if num_bytes is multiple of 3; if not, error  */
-	if (num_data_bytes%3 > 0) return -1;
-	if (num_data_bytes > 60) return -3; 
-	if (num_data_bytes < 3) return -2;
-	
-	/* get number of ints to be returned; num_data_bytes does NOT include control bytes */
+
+	/* check if num_bytes is multiple of 3; if not, error */
+	if (num_data_bytes % 3 > 0)
+		return -1;
+	if (num_data_bytes > 60)
+		return -3;
+	if (num_data_bytes < 3)
+		return -2;
+
+	/*
+	 * get number of ints to be returned; num_data_bytes does
+	 * NOT include control bytes
+	 */
 	num_data_values = num_data_bytes/3;
-	
-	for (i=0; i<num_data_values; i++) 
-	{
+
+	for (i = 0; i < num_data_values; i++) {
 		tmp_char_buffer[i*4] = orig_rxbuffer[(i+1)*3];
 		tmp_char_buffer[i*4+1] = orig_rxbuffer[(i+1)*3+1];
 		tmp_char_buffer[i*4+2] = 0;
 		tmp_char_buffer[i*4+3] = 0;
 	}
-		
+
 	/* convert to int array */
-	memcpy((unsigned char*)tmp_int_buffer, tmp_char_buffer, (num_data_values*4));
-
-	if (orig_rxbuffer[5] < 255) // space
-	{
-		final_data_buffer[0] = get_time_value(last_mc_time, tmp_int_buffer[0],
-			 orig_rxbuffer[5]);
-	} 
-	else 
-	{
-		/* is pulse */
-		final_data_buffer[0] = get_time_value(last_mc_time, tmp_int_buffer[0], 0);
+	memcpy((unsigned char *)tmp_int_buffer, tmp_char_buffer,
+						(num_data_values*4));
+
+	if (orig_rxbuffer[5] < 255) {
+		/* space */
+		final_data_buffer[0] = get_time_value(last_mc_time,
+						tmp_int_buffer[0],
+						orig_rxbuffer[5]);
+	} else { /* is pulse */
+		final_data_buffer[0] = get_time_value(last_mc_time,
+						tmp_int_buffer[0],
+						0);
 		final_data_buffer[0] |= PULSE_BIT;
 	}
-	for (i=1; i<num_data_values; i++) 
-	{
-		/* index of orig_rxbuffer that corresponds to overflow/pulse/space  */
-		orig_index = (i+1)*3 + 2;
-		if (orig_rxbuffer[orig_index] < 255) 
-		{
-			final_data_buffer[i] = get_time_value(tmp_int_buffer[i-1],
-				 tmp_int_buffer[i], orig_rxbuffer[orig_index]);
-		} 
-		else 
-		{
-			final_data_buffer[i] = get_time_value(tmp_int_buffer[i-1],
-				 tmp_int_buffer[i], 0);
+	for (i = 1; i < num_data_values; i++) {
+		/*
+		 * index of orig_rxbuffer that corresponds to
+		 * overflow/pulse/space
+		 */
+		orig_index = (i + 1)*3 + 2;
+		if (orig_rxbuffer[orig_index] < 255) {
+			final_data_buffer[i] =
+				get_time_value(tmp_int_buffer[i - 1],
+					       tmp_int_buffer[i],
+					       orig_rxbuffer[orig_index]);
+		} else {
+			final_data_buffer[i] =
+				get_time_value(tmp_int_buffer[i - 1],
+					       tmp_int_buffer[i],
+					       0);
 			final_data_buffer[i] |= PULSE_BIT;
 		}
 	}
-	last_mc_time = tmp_int_buffer[num_data_values-1];
-		
-	if(lirc_buffer_full(&rbuf))   
-	{
+	last_mc_time = tmp_int_buffer[num_data_values - 1];
+
+	if (lirc_buffer_full(&rbuf)) {
 		printk(KERN_ERR  LIRC_DRIVER_NAME ": lirc_buffer is full\n");
 		return -EOVERFLOW;
-	}	
-	lirc_buffer_write_n(&rbuf, (char*)final_data_buffer, num_data_values);
+	}
+	lirc_buffer_write_n(&rbuf, (char *)final_data_buffer, num_data_values);
 
 	return 0;
 }
@@ -280,310 +290,301 @@ static int usb_read_once(void)
 	int read_retval = 0;
 	int conv_retval = 0;
 	unsigned char read_buffer[MAX_PACKET];
-	int i=0;
-	int tooFull = 5;  // read up to 5 packets 
-	
-	for (i=0; i<MAX_PACKET; i++) read_buffer[i] = 0;
-	
-	while(tooFull--){
-		read_retval = cmdir_read(read_buffer, MAX_PACKET); 
-		if(read_buffer[1] < 60) tooFull = 0;  // loop until we unload the data build-up
-		if (!(read_retval == MAX_PACKET)) 
-		{
-			if (read_retval == -ENODEV) 
-			{
-				if (usb_status==ON) 
-				{
-					printk(KERN_ALERT LIRC_DRIVER_NAME ": device is unplugged\n");
+	int i = 0;
+	int tooFull = 5;  /* read up to 5 packets */
+
+	for (i = 0; i < MAX_PACKET; i++)
+		read_buffer[i] = 0;
+
+	while (tooFull--) {
+		read_retval = cmdir_read(read_buffer, MAX_PACKET);
+		/* Loop until we unload the data build-up */
+		if (read_buffer[1] < 60)
+			tooFull = 0;
+		if (!(read_retval == MAX_PACKET)) {
+			if (read_retval == -ENODEV) {
+				if (usb_status == ON) {
+					printk(KERN_ALERT LIRC_DRIVER_NAME
+						": device is unplugged\n");
 					usb_status = OFF;
 				}
-			}
-			else
-			{
+			} else {
 				/* supress errors */
-				printk(KERN_ALERT LIRC_DRIVER_NAME ": usb error on read = %d\n",
-						read_retval);  
+				printk(KERN_ALERT LIRC_DRIVER_NAME
+					": usb error on read = %d\n",
+					read_retval);
 				return -ENODATA;
 			}
-			// printk("Error 3\n");
+			dprintk("Error 3\n");
 			return -ENODATA;
-		}
-		else
-		{
-			if (usb_status==OFF) 
-			{
+		} else {
+			if (usb_status == OFF) {
 				usb_status = ON;
-				printk(LIRC_DRIVER_NAME ": device is now plugged in\n");
+				printk(LIRC_DRIVER_NAME
+					": device is now plugged in\n");
 			}
 		}
-	
-		if (read_buffer[0] & 0x08) 
-		{
+
+		if (read_buffer[0] & 0x08) {
 			conv_retval = cmdir_convert_RX(read_buffer);
-			if (conv_retval == 0) 
-			{
-				if(!tooFull) {
-					return 0; // else printk("Looping for more data...\n");
-				}
-			}
-			else
-			{
-				// printk("Error 2: %d\n", (int)conv_retval);
+			if (conv_retval == 0) {
+				if (!tooFull)
+					return 0;
+				else
+					dprintk("Looping for more data...\n");
+			} else {
+				dprintk("Error 2: %d\n", (int)conv_retval);
 				return -ENODATA;
 			}
-		} 
-		else 
-		{
-			// printk("Empty RX Buffer!\n");
-			return -ENODATA;  // There really is no data in their buffer
+		} else {
+			/* There really is no data in their buffer */
+			dprintk("Empty RX Buffer!\n");
+			return -ENODATA;
 		}
 	}
 	return -1;
 }
 
-int add_to_buf (void* data, struct lirc_buffer* buf)
+int add_to_buf(void *data, struct lirc_buffer *buf)
 {
 	return usb_read_once();
 }
 
 
 static ssize_t lirc_write(struct file *file, const char *buf,
-			 size_t n, loff_t * ppos)
+			 size_t n, loff_t *ppos)
 {
-	int i,count;
-	int num_bytes_to_send;
-	unsigned int mod_signal_length=0;
-	unsigned int cur_freq=0;
-	unsigned int time_elapse=0;
-	unsigned int total_time_elapsed=0;
-	/* double wbuf_mod=0.0;			//no floating point in 2.6 kernel  */
-	unsigned int num_bytes_already_sent=0;
-	unsigned int hibyte=0;
-	unsigned int lobyte=0;
-	int cmdir_cnt =0;
+	int i, count;
+	unsigned int mod_signal_length = 0;
+	unsigned int time_elapse = 0;
+	unsigned int total_time_elapsed = 0;
+	unsigned int num_bytes_already_sent = 0;
+	unsigned int hibyte = 0;
+	unsigned int lobyte = 0;
+	int cmdir_cnt = 0;
 	unsigned int wait_this = 0;
-	struct timeval start_time; 
-	struct timeval end_time; 
-	unsigned int real_time_elapsed = 0; 
-	// int first_signal = 0;
-	
-	// save the time we started the write:
+	struct timeval start_time;
+	struct timeval end_time;
+	unsigned int real_time_elapsed = 0;
+
+	/* save the time we started the write: */
 	do_gettimeofday(&start_time);
-		
-	if(n%sizeof(lirc_t)) return(-EINVAL);
 
-	count=n/sizeof(lirc_t);
-	if(count>WBUF_LEN || count%2==0) return(-EINVAL);	
-	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+	if (n % sizeof(lirc_t))
+		return -EINVAL;
 
-	// the first time we have to flag that this is the start of a new signal
-	// otherwise COMMANDIR may receive 2 back-to-back pulses & invert the signal
+	count = n/sizeof(lirc_t);
+	if (count > WBUF_LEN || count % 2 == 0)
+		return -EINVAL;
+	if (copy_from_user(wbuf, buf, n))
+		return -EFAULT;
+
+	/*
+	 * the first time we have to flag that this is the start of a new
+	 * signal otherwise COMMANDIR may receive 2 back-to-back pulses &
+	 * invert the signal
+	 */
 	cmdir_char[0] = TX_HEADER_NEW;
 	signal_num++;
 	cmdir_char[1] = signal_num;
 	cmdir_cnt = 2;
-	for(i=0;i<count;i++)
-	{
-		// prev_length_waited += wbuf[i];
-	
+	for (i = 0; i < count; i++) {
 		/* conversion to number of modulation frequency pulse edges */
 		mod_signal_length = wbuf[i] >> 3;
-
-		//if (mod_signal_length%2 == 1) mod_signal_length++;  //want even number
-		/* if (i%2==0) mod_signal_length-=5;
-		else mod_signal_length+=5;	
-		*/
-		// account for minor rounding errors - calculate length from this:
+		/*
+		 * account for minor rounding errors -
+		 * calculate length from this:
+		 */
 		time_elapse += mod_signal_length * timerval;
 
-		hibyte = mod_signal_length/256;
-		lobyte = mod_signal_length%256;
+		hibyte = mod_signal_length / 256;
+		lobyte = mod_signal_length % 256;
 		cmdir_char[cmdir_cnt+1] = lobyte;
 		cmdir_char[cmdir_cnt] = hibyte;
-		// (unsigned short)(cmdir_char[cmdir_cnt]) = mod_signal_length;
 		cmdir_cnt += 2;
-		
+
 		/* write data to usb if full packet is collected */
-		if (cmdir_cnt%MAX_PACKET == 0)
-		{
+		if (cmdir_cnt % MAX_PACKET == 0) {
 			write_to_usb(cmdir_char, MAX_PACKET,  time_elapse);
-			
+
 			total_time_elapsed += time_elapse;
-			
-			num_bytes_already_sent+= MAX_PACKET;
+
+			num_bytes_already_sent += MAX_PACKET;
 			time_elapse = 0;
-			
-			if ((i+1)<count) // still more to send:
-			{
-				cmdir_char[0] =	TX_HEADER;  // Next Packet
+
+			if ((i + 1) < count) {
+				/* still more to send: */
+				cmdir_char[0] =	TX_HEADER;  /* Next Packet */
 				cmdir_char[1] = signal_num;
-				cmdir_cnt = 2; // reset the count
+				cmdir_cnt = 2; /* reset the count */
 			}
 		}
 	}
-	
+
 	/* send last chunk of data */
-	if (cmdir_cnt > 0)
-	{
-		// time_elapse
-		total_time_elapsed += time_elapse; //time_elapse;
+	if (cmdir_cnt > 0) {
+		total_time_elapsed += time_elapse;
 		write_to_usb(cmdir_char, cmdir_cnt, time_elapse);
 	}
-	// ---------------------------------------------------------------------------
-	//  we need to _manually delay ourselves_ to remain backwards compatible with
-	// LIRC and prevent our queue buffer from overflowing.  Queuing in this driver
-	// is about instant, and send_start for example will fill it up quickly and 
-	// prevent send_stop from taking immediate effect.  
-	// ---------------------------------------------------------------------------
-	// printk("Total elapsed time is: %d. \n", total_time_elapsed);
+	/* XXX ERS remove all this? */
+	/*
+	 * we need to _manually delay ourselves_ to remain backwards
+	 * compatible with LIRC and prevent our queue buffer from overflowing.
+	 * Queuing in this driver is about instant, and send_start for example
+	 * will fill it up quickly and prevent send_stop from taking immediate
+	 * effect.
+	 */
+	dprintk("Total elapsed time is: %d. \n", total_time_elapsed);
 	do_gettimeofday(&end_time);
-	// udelay for the difference between endtime and start+total_time_elapsed
-	if(start_time.tv_usec < end_time.tv_usec){
+	/*
+	 * udelay for the difference between endtime and
+	 * start + total_time_elapsed
+	 */
+	if (start_time.tv_usec < end_time.tv_usec)
 		real_time_elapsed = (end_time.tv_usec - start_time.tv_usec);
-	} else {
-		real_time_elapsed = ((end_time.tv_usec +  1000000) - start_time.tv_usec);
-	}
-	// printk("Real time elapsed was %u.\n", real_time_elapsed);
-	if(real_time_elapsed < (total_time_elapsed-1000)){
+	else
+		real_time_elapsed = ((end_time.tv_usec +  1000000) -
+							start_time.tv_usec);
+	dprintk("Real time elapsed was %u.\n", real_time_elapsed);
+	if (real_time_elapsed < (total_time_elapsed - 1000))
 		wait_this = total_time_elapsed - real_time_elapsed - 1000;
-	}
-	//  safe_udelay(wait_this); // enable this for backwards compatibility
-	
+
+#if 0 /* enable this for backwards compatibility */
+	safe_udelay(wait_this);
+#endif
+
 	return(n);
 }
 
 
-static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+static int lirc_ioctl(struct inode *node, struct file *filep, unsigned int cmd,
 		      unsigned long arg)
 {
-        int result;
+	int result;
 	unsigned long value;
 	unsigned int ivalue;
-	unsigned int multiplier=1;
-	unsigned int mask=0;
+	unsigned int multiplier = 1;
+	unsigned int mask = 0;
 	int i;
-	switch(cmd)
-	{
+
+	switch (cmd) {
 	case LIRC_SET_TRANSMITTER_MASK:
 		if (!(hardware.features&LIRC_CAN_SET_TRANSMITTER_MASK))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		for(i=0;i<MAX_CHANNELS;i++) 
-		{
-			multiplier=multiplier*0x10;
-			mask|=multiplier;
+			return -ENOIOCTLCMD;
+		result = get_user(ivalue, (unsigned int *) arg);
+		if (result)
+			return result;
+		for (i = 0; i < MAX_CHANNELS; i++) {
+			multiplier = multiplier * 0x10;
+			mask |= multiplier;
 		}
-		if(ivalue >= mask) return (MAX_CHANNELS);
+		if (ivalue >= mask)
+			return MAX_CHANNELS;
 		set_tx_channels(ivalue);
-		return (0);
+		return 0;
 		break;
-				
+
 	case LIRC_GET_SEND_MODE:
-		if(!(hardware.features&LIRC_CAN_SEND_MASK))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=put_user(LIRC_SEND2MODE
-				(hardware.features&LIRC_CAN_SEND_MASK),
+		if (!(hardware.features & LIRC_CAN_SEND_MASK))
+			return -ENOIOCTLCMD;
+
+		result = put_user(LIRC_SEND2MODE
+				(hardware.features & LIRC_CAN_SEND_MASK),
 				(unsigned long *) arg);
-		if(result) return(result); 
+		if (result)
+			return result;
 		break;
-	
+
 	case LIRC_SET_SEND_MODE:
-		if(!(hardware.features&LIRC_CAN_SEND_MASK))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=get_user(value,(unsigned long *) arg);
-		if(result) return(result);
+		if (!(hardware.features&LIRC_CAN_SEND_MASK))
+			return -ENOIOCTLCMD;
+
+		result = get_user(value, (unsigned long *)arg);
+		if (result)
+			return result;
 		break;
-		
+
 	case LIRC_GET_LENGTH:
-		return(-ENOSYS);
+		return -ENOSYS;
 		break;
-		
+
 	case LIRC_SET_SEND_DUTY_CYCLE:
-#               ifdef DEBUG
-		printk(KERN_WARNING LIRC_DRIVER_NAME ": SET_SEND_DUTY_CYCLE\n");
-#               endif
+		dprintk(KERN_WARNING LIRC_DRIVER_NAME
+					": SET_SEND_DUTY_CYCLE\n");
+
+		if (!(hardware.features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
+			return -ENOIOCTLCMD;
+
+		result = get_user(ivalue, (unsigned int *)arg);
+		if (result)
+			return result;
+		if (ivalue <= 0 || ivalue > 100)
+			return -EINVAL;
 
-		if(!(hardware.features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
-		{
-			return(-ENOIOCTLCMD);
-		}
-				
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		if(ivalue<=0 || ivalue>100) return(-EINVAL);
-		
 		/* TODO: */
-		/* printk(LIRC_DRIVER_NAME ": set_send_duty_cycle not yet supported\n"); */
-	
+		dprintk(LIRC_DRIVER_NAME
+			": set_send_duty_cycle not yet supported\n");
+
 		return 0;
 		break;
-		
+
 	case LIRC_SET_SEND_CARRIER:
-#               ifdef DEBUG
-		printk(KERN_WARNING LIRC_DRIVER_NAME ": SET_SEND_CARRIER\n");
-#               endif
-		
-		if(!(hardware.features&LIRC_CAN_SET_SEND_CARRIER))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		if(ivalue>500000 || ivalue<24000) return(-EINVAL);
-		if (ivalue != freq) 
-		{
-			freq=ivalue;
+		dprintk(KERN_WARNING LIRC_DRIVER_NAME ": SET_SEND_CARRIER\n");
+
+		if (!(hardware.features & LIRC_CAN_SET_SEND_CARRIER))
+			return -ENOIOCTLCMD;
+
+		result = get_user(ivalue, (unsigned int *)arg);
+		if (result)
+			return result;
+		if (ivalue > 500000 || ivalue < 24000)
+			return -EINVAL;
+		if (ivalue != freq) {
+			freq = ivalue;
 			set_freq();
 		}
 		return 0;
 		break;
-		
+
 	default:
-		return(-ENOIOCTLCMD);
+		return -ENOIOCTLCMD;
 	}
-	return(0);
+	return 0;
 }
 
-static struct file_operations lirc_fops =
-{
-	write:   lirc_write,
+static struct file_operations lirc_fops = {
+	.write		= lirc_write,
 };
 
 static struct lirc_plugin plugin = {
-	name:		LIRC_DRIVER_NAME,
-	minor:		-1,
-	code_length:	1,
-	sample_rate:	20,
-	data:		NULL,
-	add_to_buf:	add_to_buf,
-	get_queue:	NULL,
-	rbuf:		&rbuf,
-	set_use_inc:	set_use_inc,
-	set_use_dec:	set_use_dec,
-	ioctl:		lirc_ioctl,
-	fops:		&lirc_fops,
-	dev:		NULL,
-	owner:		THIS_MODULE,
+	.name		= LIRC_DRIVER_NAME,
+	.minor		= -1,
+	.code_length	= 1,
+	.sample_rate	= 20,
+	.data		= NULL,
+	.add_to_buf	= add_to_buf,
+	.get_queue	= NULL,
+	.rbuf		= &rbuf,
+	.set_use_inc	= set_use_inc,
+	.set_use_dec	= set_use_dec,
+	.ioctl		= lirc_ioctl,
+	.fops		= &lirc_fops,
+	.dev		= NULL,
+	.owner		= THIS_MODULE,
 };
 
 #ifdef MODULE
 
 MODULE_AUTHOR("Evelyn Yeung, Matt Bodkin");
-MODULE_DESCRIPTION("InnovationOne driver for CommandIR USB infrared transceiver");
+MODULE_DESCRIPTION("InnovationOne driver for "
+		   "CommandIR USB infrared transceiver");
 #ifdef MODULE_LICENSE
 MODULE_LICENSE("GPL");
 #endif
 
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
 #ifndef KERNEL_2_5
 EXPORT_NO_SYMBOLS;
 #endif
@@ -591,9 +592,9 @@ EXPORT_NO_SYMBOLS;
 int init_module(void)
 {
 	plugin.features = hardware.features;
-	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) 
-	{
-		printk(KERN_ERR  LIRC_DRIVER_NAME  
+	plugin.minor = lirc_register_plugin(&plugin);
+	if (plugin.minor < 0) {
+		printk(KERN_ERR  LIRC_DRIVER_NAME
 		       ": register_chrdev failed!\n");
 		return -EIO;
 	}
diff --git a/drivers/char/lirc/lirc_cmdir.h b/drivers/char/lirc/lirc_cmdir.h
index 9a214e3..2de23da 100644
--- a/drivers/char/lirc/lirc_cmdir.h
+++ b/drivers/char/lirc/lirc_cmdir.h
@@ -1,4 +1,4 @@
-/*      $Id: lirc_cmdir.h,v 1.2 2005/09/25 12:03:39 lirc Exp $      */
+/*      $Id: lirc_cmdir.h,v 1.3 2007/09/27 19:47:20 lirc Exp $      */
 
 /*
  *   lirc_cmdir.h
@@ -17,10 +17,11 @@
 #define MCU_CTRL_SIZE   3
 #define FREQ_HEADER     2
 #define TX_HEADER       7
-#define TX_HEADER_NEW		8 
+#define TX_HEADER_NEW	8
 
-extern int cmdir_write (unsigned char *buffer, int count, void *callback_fct, int u);
-extern ssize_t cmdir_read (unsigned char *buffer, size_t count);
-extern int set_tx_channels (unsigned int next_tx);
+extern int cmdir_write(unsigned char *buffer, int count,
+		       void *callback_fct, int u);
+extern ssize_t cmdir_read(unsigned char *buffer, size_t count);
+extern int set_tx_channels(unsigned int next_tx);
 
 #endif
diff --git a/drivers/char/lirc/lirc_dev.c b/drivers/char/lirc/lirc_dev.c
index c8ba150..573985c 100644
--- a/drivers/char/lirc/lirc_dev.c
+++ b/drivers/char/lirc/lirc_dev.c
@@ -1,6 +1,6 @@
 /*
  * LIRC base driver
- * 
+ *
  * (L) by Artur Lipowski <alipowski@interia.pl>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -17,14 +17,14 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * $Id: lirc_dev.c,v 1.51 2007/02/13 06:45:15 lirc Exp $
+ * $Id: lirc_dev.c,v 1.56 2008/01/13 10:45:02 lirc Exp $
  *
  */
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
- 
+
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
 #error "**********************************************************"
@@ -41,14 +41,25 @@
 #include <linux/fs.h>
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
+#include <linux/completion.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
-#include <asm/semaphore.h>
 #include <asm/errno.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#else
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#endif
+#include <asm/semaphore.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
 #include <linux/wrapper.h>
 #endif
 #define __KERNEL_SYSCALLS__
 #include <linux/unistd.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+#include <linux/kthread.h>
+#endif
+
+#include "kcompat.h"
 
 /* SysFS header */
 #if defined(LIRC_HAVE_SYSFS)
@@ -56,25 +67,22 @@
 #endif
 
 #include <linux/lirc.h>
-#include "kcompat.h"
 #include "lirc_dev.h"
 
-static int debug = 0;
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
-
+static int debug;
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
 #define IRCTL_DEV_NAME	  "lirc"
 #define IRCTL_DEV_MAJOR   61
-
 #define SUCCESS           0
 #define NOPLUG            -1
 #define LOGHEAD           "lirc_dev (%s[%d]): "
 
-struct irctl
-{
+struct irctl {
 	struct lirc_plugin p;
 	int attached;
 	int open;
@@ -82,10 +90,14 @@ struct irctl
 	struct semaphore buffer_sem;
 	struct lirc_buffer *buf;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 	int tpid;
-	struct semaphore *t_notify;
-	struct semaphore *t_notify2;
+	struct completion *t_notify;
+	struct completion *t_notify2;
 	int shutdown;
+#else
+	struct task_struct *task;
+#endif
 	long jiffies_to_wait;
 
 #ifdef LIRC_HAVE_DEVFS_24
@@ -110,10 +122,14 @@ static inline void init_irctl(struct irctl *ir)
 	sema_init(&ir->buffer_sem, 1);
 	ir->p.minor = NOPLUG;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 	ir->tpid = -1;
 	ir->t_notify = NULL;
 	ir->t_notify2 = NULL;
 	ir->shutdown = 0;
+#else
+	ir->task = NULL;
+#endif
 	ir->jiffies_to_wait = 0;
 
 	ir->open = 0;
@@ -130,14 +146,14 @@ static void cleanup(struct irctl *ir)
 #ifdef LIRC_HAVE_DEVFS_26
 	devfs_remove(DEV_LIRC "/%u", ir->p.minor);
 #endif
-	class_device_destroy(lirc_class,MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+	class_device_destroy(lirc_class, MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
 
-	if (ir->buf != ir->p.rbuf){
+	if (ir->buf != ir->p.rbuf) {
 		lirc_buffer_free(ir->buf);
 		kfree(ir->buf);
 	}
 	ir->buf = NULL;
-	
+
 	init_irctl(ir);
 }
 
@@ -154,29 +170,31 @@ static inline int add_to_buf(struct irctl *ir)
 		return -EOVERFLOW;
 	}
 
-	if(ir->p.add_to_buf) {
+	if (ir->p.add_to_buf) {
 		int res = -ENODATA;
 		int got_data = 0;
-		
+
 		/* service the device as long as it is returning
 		 * data and we have space
 		 */
-		while( !lirc_buffer_full(ir->buf) )
-		{
-			res = ir->p.add_to_buf( ir->p.data, ir->buf );
-			if( res == SUCCESS )
+		while (!lirc_buffer_full(ir->buf)) {
+			res = ir->p.add_to_buf(ir->p.data, ir->buf);
+			if (res == SUCCESS)
 				got_data++;
 			else
 				break;
 		}
-		
-		if( res == -ENODEV )
-		{
+
+		if (res == -ENODEV)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 			ir->shutdown = 1;
-		}
+#else
+			kthread_stop(ir->task);
+#endif
+
 		return (got_data ? SUCCESS : res);
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -185,56 +203,59 @@ static inline int add_to_buf(struct irctl *ir)
 static int lirc_thread(void *irctl)
 {
 	struct irctl *ir = irctl;
-	
+
 	/* This thread doesn't need any user-level access,
 	 * so get rid of all our resources
 	 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 	daemonize("lirc_dev");
-	
-	if (ir->t_notify != NULL) {
-		up(ir->t_notify);
-	}
-	
+
+	if (ir->t_notify != NULL)
+		complete(ir->t_notify);
+#endif
+
 	dprintk(LOGHEAD "poll thread started\n", ir->p.name, ir->p.minor);
-	
+
 	do {
 		if (ir->open) {
 			if (ir->jiffies_to_wait) {
 				set_current_state(TASK_INTERRUPTIBLE);
 				schedule_timeout(ir->jiffies_to_wait);
 			} else {
-				interruptible_sleep_on(ir->p.get_queue(ir->p.data));
+				interruptible_sleep_on(
+					ir->p.get_queue(ir->p.data));
 			}
-			if (ir->shutdown) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+			if (ir->shutdown)
+#else
+			if (kthread_should_stop())
+#endif
 				break;
-			}
-			if (!add_to_buf(ir)) {
+			if (!add_to_buf(ir))
 				wake_up_interruptible(&ir->buf->wait_poll);
-			}
 		} else {
 			/* if device not opened so we can sleep half a second */
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ/2);
 		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 	} while (!ir->shutdown);
-	
-	if (ir->t_notify2 != NULL) {
-		down(ir->t_notify2);
-	}
+
+	if (ir->t_notify2 != NULL)
+		wait_for_completion(ir->t_notify2);
 
 	ir->tpid = -1;
-	if (ir->t_notify != NULL) {
-		up(ir->t_notify);
-	}
-	
+	if (ir->t_notify != NULL)
+		complete(ir->t_notify);
+#else
+	} while (!kthread_should_stop());
+#endif
+
 	dprintk(LOGHEAD "poll thread ended\n", ir->p.name, ir->p.minor);
-	
+
 	return 0;
 }
 
-/*
- *
- */
 int lirc_register_plugin(struct lirc_plugin *p)
 {
 	struct irctl *ir;
@@ -244,43 +265,43 @@ int lirc_register_plugin(struct lirc_plugin *p)
 #ifdef LIRC_HAVE_DEVFS_24
 	char name[16];
 #endif
-	DECLARE_MUTEX_LOCKED(tn);
+	DECLARE_COMPLETION(tn);
 
 	if (!p) {
-		printk("lirc_dev: lirc_register_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 		       "plugin pointer must be not NULL!\n");
 		err = -EBADRQC;
 		goto out;
 	}
 
 	if (MAX_IRCTL_DEVICES <= p->minor) {
-		printk("lirc_dev: lirc_register_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 		       "\"minor\" must be between 0 and %d (%d)!\n",
 		       MAX_IRCTL_DEVICES-1, p->minor);
 		err = -EBADRQC;
 		goto out;
 	}
 
-	if (1 > p->code_length || (BUFLEN*8) < p->code_length) {
-		printk("lirc_dev: lirc_register_plugin: "
+	if (1 > p->code_length || (BUFLEN * 8) < p->code_length) {
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 		       "code length in bits for minor (%d) "
 		       "must be less than %d!\n",
-		       p->minor, BUFLEN*8);
+		       p->minor, BUFLEN * 8);
 		err = -EBADRQC;
 		goto out;
 	}
 
-	printk("lirc_dev: lirc_register_plugin: "
-	       "sample_rate: %d\n",p->sample_rate);
+	printk(KERN_INFO "lirc_dev: lirc_register_plugin: sample_rate: %d\n",
+		p->sample_rate);
 	if (p->sample_rate) {
 		if (2 > p->sample_rate || HZ < p->sample_rate) {
-			printk("lirc_dev: lirc_register_plugin: "
+			printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 			       "sample_rate must be between 2 and %d!\n", HZ);
 			err = -EBADRQC;
 			goto out;
 		}
 		if (!p->add_to_buf) {
-			printk("lirc_dev: lirc_register_plugin: "
+			printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 			       "add_to_buf cannot be NULL when "
 			       "sample_rate is set\n");
 			err = -EBADRQC;
@@ -288,24 +309,23 @@ int lirc_register_plugin(struct lirc_plugin *p)
 		}
 	} else if (!(p->fops && p->fops->read)
 		   && !p->get_queue && !p->rbuf) {
-		printk("lirc_dev: lirc_register_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 		       "fops->read, get_queue and rbuf "
 		       "cannot all be NULL!\n");
 		err = -EBADRQC;
 		goto out;
 	} else if (!p->get_queue && !p->rbuf) {
-		if (!(p->fops && p->fops->read && p->fops->poll) 
+		if (!(p->fops && p->fops->read && p->fops->poll)
 		    || (!p->fops->ioctl && !p->ioctl)) {
-			printk("lirc_dev: lirc_register_plugin: "
+			printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 			       "neither read, poll nor ioctl can be NULL!\n");
 			err = -EBADRQC;
 			goto out;
 		}
 	}
-
 #ifdef MODULE
 	if (p->owner == NULL) {
-		printk(KERN_WARNING "lirc_dev: lirc_register_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 				    "no module owner registered\n");
 		err = -EBADRQC;
 		goto out;
@@ -317,17 +337,17 @@ int lirc_register_plugin(struct lirc_plugin *p)
 
 	if (0 > minor) {
 		/* find first free slot for plugin */
-		for (minor=0; minor<MAX_IRCTL_DEVICES; minor++)
+		for (minor = 0; minor < MAX_IRCTL_DEVICES; minor++)
 			if (irctls[minor].p.minor == NOPLUG)
 				break;
 		if (MAX_IRCTL_DEVICES == minor) {
-			printk("lirc_dev: lirc_register_plugin: "
+			printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 			       "no free slots for plugins!\n");
 			err = -ENOMEM;
 			goto out_lock;
 		}
 	} else if (irctls[minor].p.minor != NOPLUG) {
-		printk("lirc_dev: lirc_register_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 		       "minor (%d) just registered!\n", minor);
 		err = -EBUSY;
 		goto out_lock;
@@ -338,32 +358,32 @@ int lirc_register_plugin(struct lirc_plugin *p)
 	if (p->sample_rate) {
 		ir->jiffies_to_wait = HZ / p->sample_rate;
 	} else {
-                /* it means - wait for externeal event in task queue */
+		/* it means - wait for external event in task queue */
 		ir->jiffies_to_wait = 0;
-	} 
+	}
 
 	/* some safety check 8-) */
 	p->name[sizeof(p->name)-1] = '\0';
 
 	bytes_in_key = p->code_length/8 + (p->code_length%8 ? 1 : 0);
-	
+
 	if (p->rbuf) {
 		ir->buf = p->rbuf;
 	} else {
 		ir->buf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
-		if(!ir->buf) {
+		if (!ir->buf) {
 			err = -ENOMEM;
 			goto out_lock;
 		}
-		if(lirc_buffer_init
-		   (ir->buf, bytes_in_key, BUFLEN/bytes_in_key) != 0) {
+		if (lirc_buffer_init(ir->buf, bytes_in_key,
+				     BUFLEN/bytes_in_key) != 0) {
 			kfree(ir->buf);
 			err = -ENOMEM;
 			goto out_lock;
 		}
 	}
 
-	if (p->features==0)
+	if (p->features == 0)
 		p->features = (p->code_length > 8) ?
 			LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_CODE;
 
@@ -371,7 +391,7 @@ int lirc_register_plugin(struct lirc_plugin *p)
 	ir->p.minor = minor;
 
 #if defined(LIRC_HAVE_DEVFS_24)
-	sprintf (name, DEV_LIRC "/%d", ir->p.minor);
+	sprintf(name, DEV_LIRC "/%d", ir->p.minor);
 	ir->devfs_handle = devfs_register(NULL, name, DEVFS_FL_DEFAULT,
 					  IRCTL_DEV_MAJOR, ir->p.minor,
 					  S_IFCHR | S_IRUSR | S_IWUSR,
@@ -381,23 +401,30 @@ int lirc_register_plugin(struct lirc_plugin *p)
 			S_IFCHR|S_IRUSR|S_IWUSR,
 			DEV_LIRC "/%u", ir->p.minor);
 #endif
-	(void) lirc_class_device_create(lirc_class, NULL, 
+	(void) lirc_class_device_create(lirc_class, NULL,
 					MKDEV(IRCTL_DEV_MAJOR, ir->p.minor),
 					ir->p.dev, "lirc%u", ir->p.minor);
 
-	if(p->sample_rate || p->get_queue) {
+	if (p->sample_rate || p->get_queue) {
 		/* try to fire up polling thread */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 		ir->t_notify = &tn;
-		ir->tpid = kernel_thread(lirc_thread, (void*)ir, 0);
+		ir->tpid = kernel_thread(lirc_thread, (void *)ir, 0);
 		if (ir->tpid < 0) {
-			printk("lirc_dev: lirc_register_plugin: "
+#else
+		ir->task = kthread_run(lirc_thread, (void *)ir, "lirc_dev");
+		if (IS_ERR(ir->task)) {
+#endif
+			printk(KERN_ERR "lirc_dev: lirc_register_plugin: "
 			       "cannot run poll thread for minor = %d\n",
 			       p->minor);
 			err = -ECHILD;
 			goto out_sysfs;
 		}
-		down(&tn);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+		wait_for_completion(&tn);
 		ir->t_notify = NULL;
+#endif
 	}
 	ir->attached = 1;
 	up(&plugin_lock);
@@ -409,14 +436,13 @@ int lirc_register_plugin(struct lirc_plugin *p)
 #ifndef KERNEL_2_5
 	MOD_INC_USE_COUNT;
 #endif
-	printk("lirc_dev: plugin %s registered at minor number = %d\n",
+	dprintk("lirc_dev: plugin %s registered at minor number = %d\n",
 		ir->p.name, ir->p.minor);
-	printk("lirc_dev: device interface at /dev/lirc%u\n", ir->p.minor);
 	p->minor = minor;
 	return minor;
-	
+
 out_sysfs:
-	class_device_destroy(lirc_class,MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+	class_device_destroy(lirc_class, MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
 #ifdef LIRC_HAVE_DEVFS_24
 	devfs_unregister(ir->devfs_handle);
 #endif
@@ -428,18 +454,16 @@ out_lock:
 out:
 	return err;
 }
+EXPORT_SYMBOL(lirc_register_plugin);
 
-/*
- *
- */
 int lirc_unregister_plugin(int minor)
 {
 	struct irctl *ir;
-	DECLARE_MUTEX_LOCKED(tn);
-	DECLARE_MUTEX_LOCKED(tn2);
+	DECLARE_COMPLETION(tn);
+	DECLARE_COMPLETION(tn2);
 
 	if (minor < 0 || minor >= MAX_IRCTL_DEVICES) {
-		printk("lirc_dev: lirc_unregister_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_unregister_plugin: "
 		       "\"minor\" must be between 0 and %d!\n",
 		       MAX_IRCTL_DEVICES-1);
 		return -EBADRQC;
@@ -450,21 +474,22 @@ int lirc_unregister_plugin(int minor)
 	down(&plugin_lock);
 
 	if (ir->p.minor != minor) {
-		printk("lirc_dev: lirc_unregister_plugin: "
+		printk(KERN_ERR "lirc_dev: lirc_unregister_plugin: "
 		       "minor (%d) device not registered!", minor);
 		up(&plugin_lock);
 		return -ENOENT;
 	}
 
 	/* end up polling thread */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
 	if (ir->tpid >= 0) {
 		ir->t_notify = &tn;
 		ir->t_notify2 = &tn2;
 		ir->shutdown = 1;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
 		{
 			struct task_struct *p;
-			
+
 			p = find_task_by_pid(ir->tpid);
 			wake_up_process(p);
 		}
@@ -472,11 +497,17 @@ int lirc_unregister_plugin(int minor)
 		/* 2.2.x does not export wake_up_process() */
 		wake_up_interruptible(ir->p.get_queue(ir->p.data));
 #endif
-		up(&tn2);
-		down(&tn);
+		complete(&tn2);
+		wait_for_completion(&tn);
 		ir->t_notify = NULL;
 		ir->t_notify2 = NULL;
 	}
+#else /* kernel >= 2.6.23 */
+	if (ir->task) {
+		wake_up_process(ir->task);
+		kthread_stop(ir->task);
+	}
+#endif
 
 	dprintk("lirc_dev: plugin %s unregistered from minor number = %d\n",
 		ir->p.name, ir->p.minor);
@@ -490,11 +521,8 @@ int lirc_unregister_plugin(int minor)
 		ir->p.set_use_dec(ir->p.data);
 		module_put(ir->p.owner);
 		up(&ir->buffer_sem);
-	}
-	else
-	{
+	} else
 		cleanup(ir);
-	}
 	up(&plugin_lock);
 
 /*
@@ -507,6 +535,7 @@ int lirc_unregister_plugin(int minor)
 
 	return SUCCESS;
 }
+EXPORT_SYMBOL(lirc_unregister_plugin);
 
 /*
  *
@@ -515,7 +544,7 @@ static int irctl_open(struct inode *inode, struct file *file)
 {
 	struct irctl *ir;
 	int retval;
-	
+
 	if (MINOR(inode->i_rdev) >= MAX_IRCTL_DEVICES) {
 		dprintk("lirc_dev [%d]: open result = -ENODEV\n",
 			MINOR(inode->i_rdev));
@@ -527,13 +556,11 @@ static int irctl_open(struct inode *inode, struct file *file)
 	dprintk(LOGHEAD "open called\n", ir->p.name, ir->p.minor);
 
 	/* if the plugin has an open function use it instead */
-	if(ir->p.fops && ir->p.fops->open)
+	if (ir->p.fops && ir->p.fops->open)
 		return ir->p.fops->open(inode, file);
 
 	if (down_interruptible(&plugin_lock))
-	{
 		return -ERESTARTSYS;
-	}
 
 	if (ir->p.minor == NOPLUG) {
 		up(&plugin_lock);
@@ -549,37 +576,33 @@ static int irctl_open(struct inode *inode, struct file *file)
 		return -EBUSY;
 	}
 
-	/* there is no need for locking here because ir->open is 0 
-         * and lirc_thread isn't using buffer
+	/* there is no need for locking here because ir->open is 0
+	 * and lirc_thread isn't using buffer
 	 * plugins which use irq's should allocate them on set_use_inc,
 	 * so there should be no problem with those either.
-         */
+	 */
 	ir->buf->head = ir->buf->tail;
 	ir->buf->fill = 0;
 
 #ifdef MODULE
-	if(ir->p.owner!=NULL && try_module_get(ir->p.owner))
-	{
+	if (ir->p.owner != NULL && try_module_get(ir->p.owner)) {
 #endif
 		++ir->open;
 		retval = ir->p.set_use_inc(ir->p.data);
-		
+
 		if (retval != SUCCESS) {
 			module_put(ir->p.owner);
 			--ir->open;
 		}
 #ifdef MODULE
-	}
-	else
-	{
-		if(ir->p.owner==NULL)
-		{
-			dprintk(LOGHEAD "no module owner!!!\n", ir->p.name, ir->p.minor);
-		}
+	} else {
+		if (ir->p.owner == NULL)
+			dprintk(LOGHEAD "no module owner!!!\n",
+				ir->p.name, ir->p.minor);
+
 		retval = -ENODEV;
 	}
 #endif
-
 	dprintk(LOGHEAD "open result = %d\n", ir->p.name, ir->p.minor, retval);
 	up(&plugin_lock);
 
@@ -594,24 +617,19 @@ static int irctl_close(struct inode *inode, struct file *file)
 	struct irctl *ir = &irctls[MINOR(inode->i_rdev)];
 
 	dprintk(LOGHEAD "close called\n", ir->p.name, ir->p.minor);
- 
+
 	/* if the plugin has a close function use it instead */
-	if(ir->p.fops && ir->p.fops->release)
+	if (ir->p.fops && ir->p.fops->release)
 		return ir->p.fops->release(inode, file);
 
 	if (down_interruptible(&plugin_lock))
-	{
 		return -ERESTARTSYS;
-	}
 
 	--ir->open;
-	if(ir->attached)
-	{
+	if (ir->attached) {
 		ir->p.set_use_dec(ir->p.data);
 		module_put(ir->p.owner);
-	}
-	else
-	{
+	} else {
 		cleanup(ir);
 	}
 
@@ -631,12 +649,11 @@ static unsigned int irctl_poll(struct file *file, poll_table *wait)
 	dprintk(LOGHEAD "poll called\n", ir->p.name, ir->p.minor);
 
 	/* if the plugin has a poll function use it instead */
-	if(ir->p.fops && ir->p.fops->poll)
+	if (ir->p.fops && ir->p.fops->poll)
 		return ir->p.fops->poll(file, wait);
 
 	down(&ir->buffer_sem);
-	if(!ir->attached)
-	{
+	if (!ir->attached) {
 		up(&ir->buffer_sem);
 		return POLLERR;
 	}
@@ -644,11 +661,11 @@ static unsigned int irctl_poll(struct file *file, poll_table *wait)
 	poll_wait(file, &ir->buf->wait_poll, wait);
 
 	dprintk(LOGHEAD "poll result = %s\n",
-		ir->p.name, ir->p.minor, 
+		ir->p.name, ir->p.minor,
 		lirc_buffer_empty(ir->buf) ? "0" : "POLLIN|POLLRDNORM");
 
 	ret = lirc_buffer_empty(ir->buf) ? 0 : (POLLIN|POLLRDNORM);
-	
+
 	up(&ir->buffer_sem);
 	return ret;
 }
@@ -657,7 +674,7 @@ static unsigned int irctl_poll(struct file *file, poll_table *wait)
  *
  */
 static int irctl_ioctl(struct inode *inode, struct file *file,
-                       unsigned int cmd, unsigned long arg)
+		       unsigned int cmd, unsigned long arg)
 {
 	unsigned long mode;
 	int result;
@@ -667,7 +684,7 @@ static int irctl_ioctl(struct inode *inode, struct file *file,
 		ir->p.name, ir->p.minor, cmd);
 
 	/* if the plugin has a ioctl function use it instead */
-	if(ir->p.fops && ir->p.fops->ioctl)
+	if (ir->p.fops && ir->p.fops->ioctl)
 		return ir->p.fops->ioctl(inode, file, cmd, arg);
 
 	if (ir->p.minor == NOPLUG || !ir->attached) {
@@ -677,7 +694,7 @@ static int irctl_ioctl(struct inode *inode, struct file *file,
 	}
 
 	/* Give the plugin a chance to handle the ioctl */
-	if(ir->p.ioctl){
+	if (ir->p.ioctl) {
 		result = ir->p.ioctl(inode, file, cmd, arg);
 		if (result != -ENOIOCTLCMD)
 			return result;
@@ -685,33 +702,32 @@ static int irctl_ioctl(struct inode *inode, struct file *file,
 	/* The plugin can't handle cmd */
 	result = SUCCESS;
 
-	switch(cmd)
-	{
+	switch (cmd) {
 	case LIRC_GET_FEATURES:
-		result = put_user(ir->p.features, (unsigned long*)arg);
+		result = put_user(ir->p.features, (unsigned long *)arg);
 		break;
 	case LIRC_GET_REC_MODE:
-		if(!(ir->p.features&LIRC_CAN_REC_MASK))
-			return(-ENOSYS);
-		
+		if (!(ir->p.features&LIRC_CAN_REC_MASK))
+			return -ENOSYS;
+
 		result = put_user(LIRC_REC2MODE
 				  (ir->p.features&LIRC_CAN_REC_MASK),
-				  (unsigned long*)arg);
+				  (unsigned long *)arg);
 		break;
 	case LIRC_SET_REC_MODE:
-		if(!(ir->p.features&LIRC_CAN_REC_MASK))
-			return(-ENOSYS);
+		if (!(ir->p.features&LIRC_CAN_REC_MASK))
+			return -ENOSYS;
 
-		result = get_user(mode, (unsigned long*)arg);
-		if(!result && !(LIRC_MODE2REC(mode) & ir->p.features)) {
+		result = get_user(mode, (unsigned long *)arg);
+		if (!result && !(LIRC_MODE2REC(mode) & ir->p.features))
 			result = -EINVAL;
-		}
-		/* FIXME: We should actually set the mode somehow 
-		 * but for now, lirc_serial doesn't support mode changin
-		 * eighter */
+		/*
+		 * FIXME: We should actually set the mode somehow but
+		 * for now, lirc_serial doesn't support mode changing either
+		 */
 		break;
 	case LIRC_GET_LENGTH:
-		result = put_user((unsigned long)ir->p.code_length, 
+		result = put_user((unsigned long)ir->p.code_length,
 				  (unsigned long *)arg);
 		break;
 	default:
@@ -728,27 +744,24 @@ static int irctl_ioctl(struct inode *inode, struct file *file,
  *
  */
 static ssize_t irctl_read(struct file *file,
-			  char *buffer,   
-			  size_t length, 
-			  loff_t *ppos)     
+			  char *buffer,
+			  size_t length,
+			  loff_t *ppos)
 {
 	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
 	unsigned char buf[ir->buf->chunk_size];
-	int ret=0, written=0;
+	int ret = 0, written = 0;
 	DECLARE_WAITQUEUE(wait, current);
 
 	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
 
 	/* if the plugin has a specific read function use it instead */
-	if(ir->p.fops && ir->p.fops->read)
+	if (ir->p.fops && ir->p.fops->read)
 		return ir->p.fops->read(file, buffer, length, ppos);
 
-	if(down_interruptible(&ir->buffer_sem))
-	{
+	if (down_interruptible(&ir->buffer_sem))
 		return -ERESTARTSYS;
-	}
-	if(!ir->attached)
-	{
+	if (!ir->attached) {
 		up(&ir->buffer_sem);
 		return -ENODEV;
 	}
@@ -760,23 +773,26 @@ static ssize_t irctl_read(struct file *file,
 		return -EINVAL;
 	}
 
-	/* we add ourselves to the task queue before buffer check 
-         * to avoid losing scan code (in case when queue is awaken somewhere 
+	/*
+	 * we add ourselves to the task queue before buffer check
+	 * to avoid losing scan code (in case when queue is awaken somewhere
 	 * beetwen while condition checking and scheduling)
 	 */
 	add_wait_queue(&ir->buf->wait_poll, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
 
-	/* while we did't provide 'length' bytes, device is opened in blocking
+	/*
+	 * while we did't provide 'length' bytes, device is opened in blocking
 	 * mode and 'copy_to_user' is happy, wait for data.
 	 */
-	while (written < length && ret == 0) { 
+	while (written < length && ret == 0) {
 		if (lirc_buffer_empty(ir->buf)) {
 			/* According to the read(2) man page, 'written' can be
 			 * returned as less than 'length', instead of blocking
 			 * again, returning -EWOULDBLOCK, or returning
 			 * -ERESTARTSYS */
-			if (written) break;
+			if (written)
+				break;
 			if (file->f_flags & O_NONBLOCK) {
 				ret = -EWOULDBLOCK;
 				break;
@@ -787,8 +803,7 @@ static ssize_t irctl_read(struct file *file,
 			}
 			schedule();
 			set_current_state(TASK_INTERRUPTIBLE);
-			if(!ir->attached)
-			{
+			if (!ir->attached) {
 				ret = -ENODEV;
 				break;
 			}
@@ -803,7 +818,7 @@ static ssize_t irctl_read(struct file *file,
 	remove_wait_queue(&ir->buf->wait_poll, &wait);
 	set_current_state(TASK_RUNNING);
 	up(&ir->buffer_sem);
-	
+
 	dprintk(LOGHEAD "read result = %s (%d)\n",
 		ir->p.name, ir->p.minor, ret ? "-EFAULT" : "OK", ret);
 
@@ -813,95 +828,103 @@ static ssize_t irctl_read(struct file *file,
 
 void *lirc_get_pdata(struct file *file)
 {
-	void *data=NULL;
+	void *data = NULL;
 
 	if (file && file->f_dentry && file->f_dentry->d_inode &&
-	    file->f_dentry->d_inode->i_rdev )
-	{
-		struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
-		data=ir->p.data;
+	    file->f_dentry->d_inode->i_rdev) {
+		struct irctl *ir;
+		ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+		data = ir->p.data;
 	}
 
 	return data;
 }
+EXPORT_SYMBOL(lirc_get_pdata);
 
 
 static ssize_t irctl_write(struct file *file, const char *buffer,
-			   size_t length, loff_t * ppos)
+			   size_t length, loff_t *ppos)
 {
 	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
 
 	dprintk(LOGHEAD "write called\n", ir->p.name, ir->p.minor);
 
 	/* if the plugin has a specific read function use it instead */
-	if(ir->p.fops && ir->p.fops->write)
+	if (ir->p.fops && ir->p.fops->write)
 		return ir->p.fops->write(file, buffer, length, ppos);
 
-	if(!ir->attached)
-	{
+	if (!ir->attached)
 		return -ENODEV;
-	}
 
 	return -EINVAL;
 }
 
 
 static struct file_operations fops = {
-	read:    irctl_read, 
-	write:   irctl_write,
-	poll:    irctl_poll,
-	ioctl:   irctl_ioctl,
-	open:    irctl_open,
-	release: irctl_close
+	.read		= irctl_read,
+	.write		= irctl_write,
+	.poll		= irctl_poll,
+	.ioctl		= irctl_ioctl,
+	.open		= irctl_open,
+	.release	= irctl_close
 };
 
 
-EXPORT_SYMBOL(lirc_get_pdata);
-EXPORT_SYMBOL(lirc_register_plugin);
-EXPORT_SYMBOL(lirc_unregister_plugin);
-
-/*
- *
- */
-static int __init lirc_dev_init(void)
-{  	
+static int lirc_dev_init(void)
+{
 	int i;
 
-	for (i=0; i < MAX_IRCTL_DEVICES; ++i) {
-		init_irctl(&irctls[i]);	
-	}
+	for (i = 0; i < MAX_IRCTL_DEVICES; ++i)
+		init_irctl(&irctls[i]);
 
-	if(register_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME, &fops)) {
+	if (register_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME, &fops)) {
 		printk(KERN_ERR "lirc_dev: register_chrdev failed\n");
 		goto out;
 	}
 
-	lirc_class = class_create(THIS_MODULE, IRCTL_DEV_NAME);
-	if(IS_ERR(lirc_class)) {
+	lirc_class = class_create(THIS_MODULE, "lirc");
+	if (IS_ERR(lirc_class)) {
 		printk(KERN_ERR "lirc_dev: class_create failed\n");
 		goto out_unregister;
 	}
 
-	printk("lirc_dev: IR Remote Control driver registered, at major %d \n", 
-	       IRCTL_DEV_MAJOR);
+	printk(KERN_INFO "lirc_dev: IR Remote Control driver registered, "
+	       "major %d \n", IRCTL_DEV_MAJOR);
 
 	return SUCCESS;
 
 out_unregister:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	if (unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME))
+		printk(KERN_ERR "lirc_dev: unregister_chrdev failed!\n");
+#else
+	/* unregister_chrdev returns void now */
 	unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+#endif
 out:
 	return -1;
 }
 
 /* ---------------------------------------------------------------------- */
-/*
- *
- */
-void __exit lirc_dev_exit(void)
+void lirc_dev_exit(void)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	int ret;
+
+	ret = unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+	class_destroy(lirc_class);
+
+	if (ret)
+		printk(KERN_ERR "lirc_dev: error in "
+		       "module_unregister_chrdev: %d\n", ret);
+	else
+		dprintk("lirc_dev: module successfully unloaded\n");
+#else
+	/* unregister_chrdev returns void now */
 	unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
 	class_destroy(lirc_class);
-        dprintk("lirc_dev: module successfully unloaded\n");
+	dprintk("lirc_dev: module unloaded\n");
+#endif
 }
 
 MODULE_DESCRIPTION("LIRC base driver module");
diff --git a/drivers/char/lirc/lirc_dev.h b/drivers/char/lirc/lirc_dev.h
index ec55bcd..f9246a1 100644
--- a/drivers/char/lirc/lirc_dev.h
+++ b/drivers/char/lirc/lirc_dev.h
@@ -1,10 +1,10 @@
 /*
  * LIRC base driver
- * 
+ *
  * (L) by Artur Lipowski <alipowski@interia.pl>
  *        This code is licensed under GNU GPL
  *
- * $Id: lirc_dev.h,v 1.20 2007/04/22 10:21:37 lirc Exp $
+ * $Id: lirc_dev.h,v 1.22 2008/01/13 10:45:02 lirc Exp $
  *
  */
 
@@ -14,18 +14,17 @@
 #define MAX_IRCTL_DEVICES 4
 #define BUFLEN            16
 
-//#define LIRC_BUFF_POWER_OF_2
+/* #define LIRC_BUFF_POWER_OF_2 */
 #ifdef LIRC_BUFF_POWER_OF_2
-#define mod(n, div) ((n) & ((div) -1))
+#define mod(n, div) ((n) & ((div) - 1))
 #else
 #define mod(n, div) ((n) % (div))
 #endif
 #include <linux/slab.h>
 #include <linux/fs.h>
 
-struct lirc_buffer
-{
-        wait_queue_head_t wait_poll;
+struct lirc_buffer {
+	wait_queue_head_t wait_poll;
 	spinlock_t lock;
 
 	unsigned char *data;
@@ -33,12 +32,14 @@ struct lirc_buffer
 	unsigned int size; /* in chunks */
 	unsigned int fill; /* in chunks */
 	int head, tail;    /* in chunks */
-	/* Using chunks instead of bytes pretends to simplify boundary checking 
+	/* Using chunks instead of bytes pretends to simplify boundary checking
 	 * And should allow for some performance fine tunning later */
 };
 static inline void _lirc_buffer_clear(struct lirc_buffer *buf)
 {
-	buf->head = buf->tail = buf->fill = 0;
+	buf->head = 0;
+	buf->tail = 0;
+	buf->fill = 0;
 }
 static inline int lirc_buffer_init(struct lirc_buffer *buf,
 				    unsigned int chunk_size,
@@ -61,7 +62,9 @@ static inline void lirc_buffer_free(struct lirc_buffer *buf)
 {
 	kfree(buf->data);
 	buf->data = NULL;
-	buf->head = buf->tail = buf->fill = 0;
+	buf->head = 0;
+	buf->tail = 0;
+	buf->fill = 0;
 	buf->chunk_size = 0;
 	buf->size = 0;
 }
@@ -77,11 +80,13 @@ static inline int  lirc_buffer_available(struct lirc_buffer *buf)
 {
     return (buf->size - buf->fill);
 }
-static inline void lirc_buffer_lock(struct lirc_buffer *buf, unsigned long *flags)
+static inline void lirc_buffer_lock(struct lirc_buffer *buf,
+				    unsigned long *flags)
 {
 	spin_lock_irqsave(&buf->lock, *flags);
 }
-static inline void lirc_buffer_unlock(struct lirc_buffer *buf, unsigned long *flags)
+static inline void lirc_buffer_unlock(struct lirc_buffer *buf,
+				      unsigned long *flags)
 {
 	spin_unlock_irqrestore(&buf->lock, *flags);
 }
@@ -135,49 +140,48 @@ static inline void lirc_buffer_write_1(struct lirc_buffer *buf,
 	lirc_buffer_unlock(buf, &flags);
 }
 static inline void _lirc_buffer_write_n(struct lirc_buffer *buf,
-					unsigned char* orig, int count)
+					unsigned char *orig, int count)
 {
-	memcpy(&buf->data[buf->tail*buf->chunk_size], orig,
-	       count*buf->chunk_size);
-	buf->tail = mod(buf->tail+count, buf->size);
+	memcpy(&buf->data[buf->tail * buf->chunk_size], orig,
+	       count * buf->chunk_size);
+	buf->tail = mod(buf->tail + count, buf->size);
 	buf->fill += count;
 }
 static inline void lirc_buffer_write_n(struct lirc_buffer *buf,
-				       unsigned char* orig, int count)
+				       unsigned char *orig, int count)
 {
 	unsigned long flags;
 	int space1;
-	lirc_buffer_lock(buf,&flags);
-	if( buf->head > buf->tail ) space1 = buf->head - buf->tail;
-	else space1 = buf->size - buf->tail;
-	
-	if( count > space1 )
-	{
+
+	lirc_buffer_lock(buf, &flags);
+	if (buf->head > buf->tail)
+		space1 = buf->head - buf->tail;
+	else
+		space1 = buf->size - buf->tail;
+
+	if (count > space1) {
 		_lirc_buffer_write_n(buf, orig, space1);
 		_lirc_buffer_write_n(buf, orig+(space1*buf->chunk_size),
 				     count-space1);
-	}
-	else
-	{
+	} else {
 		_lirc_buffer_write_n(buf, orig, count);
 	}
 	lirc_buffer_unlock(buf, &flags);
 }
 
-struct lirc_plugin
-{
+struct lirc_plugin {
 	char name[40];
 	int minor;
 	int code_length;
 	int sample_rate;
 	unsigned long features;
-	void* data;
-	int (*add_to_buf) (void* data, struct lirc_buffer* buf);
-	wait_queue_head_t* (*get_queue) (void* data);
+	void *data;
+	int (*add_to_buf) (void *data, struct lirc_buffer *buf);
+	wait_queue_head_t* (*get_queue) (void *data);
 	struct lirc_buffer *rbuf;
-	int (*set_use_inc) (void* data);
-	void (*set_use_dec) (void* data);
-	int (*ioctl) (struct inode *,struct file *,unsigned int,
+	int (*set_use_inc) (void *data);
+	void (*set_use_dec) (void *data);
+	int (*ioctl) (struct inode *, struct file *, unsigned int,
 		      unsigned long);
 	struct file_operations *fops;
 	struct device *dev;
@@ -188,7 +192,7 @@ struct lirc_plugin
  *
  * minor:
  * indicates minor device (/dev/lirc) number for registered plugin
- * if caller fills it with negative value, then the first free minor 
+ * if caller fills it with negative value, then the first free minor
  * number will be used (if available)
  *
  * code_length:
@@ -233,7 +237,7 @@ struct lirc_plugin
  *
  * fops:
  * file_operations for drivers which don't fit the current plugin model.
- * 
+ *
  * owner:
  * the module owning this struct
  *
@@ -242,7 +246,7 @@ struct lirc_plugin
 
 /* following functions can be called ONLY from user context
  *
- * returns negative value on error or minor number 
+ * returns negative value on error or minor number
  * of the registered device if success
  * contens of the structure pointed by p is copied
  */
@@ -257,9 +261,4 @@ extern int lirc_unregister_plugin(int minor);
  */
 void *lirc_get_pdata(struct file *file);
 
-#if defined(CONFIG_ST_LIRC) || defined(MODULE)
-/* Returns the platform lirc private data */
-void* lirc_get_config(void);
-#endif
-
 #endif
diff --git a/drivers/char/lirc/lirc_gpio.c b/drivers/char/lirc/lirc_gpio.c
index cf5e003..a033380 100644
--- a/drivers/char/lirc/lirc_gpio.c
+++ b/drivers/char/lirc/lirc_gpio.c
@@ -1,10 +1,10 @@
 /*
  * Remote control driver for the TV-card
  * key codes are obtained from GPIO port
- * 
+ *
  * (L) by Artur Lipowski <alipowski@interia.pl>
  *     patch for the AverMedia by Santiago Garcia Mantinan <manty@i.am>
- *                            and Christoph Bartelmus <lirc@bartelmus.de>
+ *			    and Christoph Bartelmus <lirc@bartelmus.de>
  *     patch for the BestBuy by Miguel Angel Alvarez <maacruz@navegalia.com>
  *     patch for the Winfast TV2000 by Juan Toledo
  *     <toledo@users.sourceforge.net>
@@ -25,7 +25,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * $Id: lirc_gpio.c,v 1.49 2007/02/13 06:45:15 lirc Exp $
+ * $Id: lirc_gpio.c,v 1.50 2007/09/27 19:47:20 lirc Exp $
  *
  */
 
@@ -40,27 +40,27 @@
 #include <linux/module.h>
 #include <linux/kmod.h>
 #include <linux/sched.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
 #include <linux/wrapper.h>
 #endif
 #include <linux/errno.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-#include "../../char/bttv.h"
-#include "../../char/bttvp.h"
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
-#include "../../media/video/bttv.h"
-#include "../../media/video/bttvp.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#include "../drivers/char/bttv.h"
+#include "../drivers/char/bttvp.h"
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#include "../drivers/media/video/bttv.h"
+#include "../drivers/media/video/bttvp.h"
 #else
-#include "../../media/video/bt8xx/bttv.h"
-#include "../../media/video/bt8xx/bttvp.h"
+#include "../drivers/media/video/bt8xx/bttv.h"
+#include "../drivers/media/video/bt8xx/bttvp.h"
 #endif
 
-#if BTTV_VERSION_CODE < KERNEL_VERSION(0,7,45)
+#if BTTV_VERSION_CODE < KERNEL_VERSION(0, 7, 45)
 #error "*******************************************************"
 #error " Sorry, this driver needs bttv version 0.7.45 or       "
 #error " higher. If you are using the bttv package, copy it to "
-#error " the kernel                                            "
+#error " the kernel					    "
 #error "*******************************************************"
 #endif
 
@@ -68,21 +68,22 @@
 #include "lirc_dev.h"
 
 /* insmod parameters */
-static int debug = 0;
-static int card = 0;
+static int debug;
+static int card;
 static int minor = -1;
 static int bttv_id = BTTV_BOARD_UNKNOWN;
-static unsigned long gpio_mask = 0;
-static unsigned long gpio_enable = 0;
-static unsigned long gpio_lock_mask = 0;
-static unsigned long gpio_xor_mask = 0;
-static int soft_gap = 0;
+static unsigned long gpio_mask;
+static unsigned long gpio_enable;
+static unsigned long gpio_lock_mask;
+static unsigned long gpio_xor_mask;
+static int soft_gap;
 static int sample_rate = 10;
 
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
 struct rcv_info {
 	int bttv_id;
@@ -97,68 +98,108 @@ struct rcv_info {
 };
 
 static struct rcv_info rcv_infos[] = {
-	{BTTV_BOARD_UNKNOWN,                0,          0,          0,         0,          0,   0,  1,  0},
-	{BTTV_BOARD_PXELVWPLTVPAK,          0, 0x00003e00,          0, 0x0010000,          0,   0, 15, 32},
-	{BTTV_BOARD_PXELVWPLTVPRO,          0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
-	{BTTV_BOARD_PV_BT878P_9B,           0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
-	{BTTV_BOARD_PV_BT878P_PLUS,         0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_BOARD_UNKNOWN,
+		0, 0, 0, 0, 0, 0, 1, 0},
+	{BTTV_BOARD_PXELVWPLTVPAK,
+		0, 0x00003e00, 0, 0x0010000, 0, 0, 15, 32},
+	{BTTV_BOARD_PXELVWPLTVPRO,
+		0, 0x00001f00, 0, 0x0008000, 0, 500, 12, 32},
+	{BTTV_BOARD_PV_BT878P_9B,
+		0, 0x00001f00, 0, 0x0008000, 0, 500, 12, 32},
+	{BTTV_BOARD_PV_BT878P_PLUS,
+		0, 0x00001f00, 0, 0x0008000, 0, 500, 12, 32},
 #ifdef BTTV_BOARD_PV_M4900
-	{BTTV_BOARD_PV_M4900,               0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_BOARD_PV_M4900,
+		0, 0x00001f00, 0, 0x0008000, 0, 500, 12, 32},
 #endif
-	{BTTV_BOARD_AVERMEDIA,              0, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32},
-	{BTTV_BOARD_AVPHONE98,     0x00011461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
-	{BTTV_BOARD_AVERMEDIA98,   0x00021461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
-	{BTTV_BOARD_AVPHONE98,     0x00031461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	{BTTV_BOARD_AVERMEDIA,
+		0, 0x00f88000, 0, 0x0010000, 0x00010000, 0, 10, 32},
+
+	/* mapped to Capture98 */
+	{BTTV_BOARD_AVPHONE98,
+		0x00011461, 0x003b8000, 0x00004000,
+		0x0800000, 0x00800000, 0, 10, 0},
+	{BTTV_BOARD_AVERMEDIA98,
+		0x00021461, 0x003b8000, 0x00004000,
+		0x0800000, 0x00800000, 0, 10, 0},
+
+	/* mapped to Phone98 */
+	{BTTV_BOARD_AVPHONE98,
+		0x00031461, 0x00f88000, 0, 0x0010000, 0x00010000, 0, 10, 32},
 	/* is this one correct? */
-	{BTTV_BOARD_AVERMEDIA98,   0x00041461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	{BTTV_BOARD_AVERMEDIA98,
+		0x00041461, 0x00f88000, 0, 0x0010000, 0x00010000, 0, 10, 32},
 	/* work-around for VDOMATE */
-	{BTTV_BOARD_AVERMEDIA98,   0x03001461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	{BTTV_BOARD_AVERMEDIA98,
+		0x03001461, 0x00f88000, 0, 0x0010000, 0x00010000, 0, 10, 32},
 	/* reported by Danijel Korzinek, AVerTV GOw/FM */
-	{BTTV_BOARD_AVERMEDIA98,   0x00000000, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
-	{BTTV_BOARD_CHRONOS_VS2,            0, 0x000000f8,          0, 0x0000100,          0,   0, 20,  0},
+	{BTTV_BOARD_AVERMEDIA98,
+		0x00000000, 0x00f88000, 0, 0x0010000, 0x00010000, 0, 10, 32},
+
+	{BTTV_BOARD_CHRONOS_VS2,
+		0, 0x000000f8,	0, 0x0000100, 0, 0, 20, 0},
 	/* CPH031 and CPH033 cards (?) */
 	/* MIRO was just a work-around */
-	{BTTV_BOARD_MIRO,                   0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
-	{BTTV_BOARD_DYNALINK,               0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+	{BTTV_BOARD_MIRO,
+		0, 0x00001f00, 0, 0x0004000, 0, 0, 10, 32},
+	{BTTV_BOARD_DYNALINK,
+		0, 0x00001f00, 0, 0x0004000, 0, 0, 10, 32},
 #ifdef BTTV_BOARD_ASKEY_CPH03X
-	{BTTV_BOARD_ASKEY_CPH03X,           0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+	{BTTV_BOARD_ASKEY_CPH03X,
+		0, 0x00001f00, 0, 0x0004000, 0, 0, 10, 32},
 #endif
-	{BTTV_BOARD_WINVIEW_601,            0, 0x00001f00,          0, 0x0004000,          0,   0,  0, 32},
+	{BTTV_BOARD_WINVIEW_601,
+		0, 0x00001f00, 0, 0x0004000, 0, 0, 0, 32},
 #ifdef BTTV_BOARD_KWORLD
-	{BTTV_BOARD_KWORLD,                 0, 0x00007f00,          0, 0x0004000,          0,   0, 12, 32},
+	{BTTV_BOARD_KWORLD,
+		0, 0x00007f00, 0, 0x0004000, 0, 0, 12, 32},
 #endif
 	/* just a guess */
-	{BTTV_BOARD_MAGICTVIEW061,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
- 	{BTTV_BOARD_MAGICTVIEW063,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
- 	{BTTV_BOARD_PHOEBE_TVMAS,           0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+	{BTTV_BOARD_MAGICTVIEW061,
+		0, 0x0028e000, 0, 0x0020000, 0, 0, 20, 32},
+	{BTTV_BOARD_MAGICTVIEW063,
+		0, 0x0028e000, 0, 0x0020000, 0, 0, 20, 32},
+	{BTTV_BOARD_PHOEBE_TVMAS,
+		0, 0x0028e000, 0, 0x0020000, 0, 0, 20, 32},
 #ifdef BTTV_BOARD_BESTBUY_EASYTV2
-        {BTTV_BOARD_BESTBUY_EASYTV,         0, 0x00007F00,          0, 0x0004000,          0,   0, 10,  8},
-        {BTTV_BOARD_BESTBUY_EASYTV2,        0, 0x00007F00,          0, 0x0008000,          0,   0, 10,  8},
+	{BTTV_BOARD_BESTBUY_EASYTV,
+		0, 0x00007F00, 0, 0x0004000, 0, 0, 10, 8},
+	{BTTV_BOARD_BESTBUY_EASYTV2,
+		0, 0x00007F00, 0, 0x0008000, 0, 0, 10, 8},
 #endif
-	/* lock_mask probably also 0x100, or maybe it is 0x0 for all others !?! */
-	{BTTV_BOARD_FLYVIDEO,               0, 0x000000f8,          0,         0,          0,   0,  0, 42},
- 	{BTTV_BOARD_FLYVIDEO_98,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
- 	{BTTV_BOARD_TYPHOON_TVIEW,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+	/* lock_mask probably also 0x100, or maybe it is 0x0 for all others? */
+	{BTTV_BOARD_FLYVIDEO,
+		0, 0x000000f8, 0, 0, 0, 0, 0, 42},
+	{BTTV_BOARD_FLYVIDEO_98,
+		0, 0x000000f8,	0, 0x0000100, 0, 0, 0, 42},
+	{BTTV_BOARD_TYPHOON_TVIEW,
+		0, 0x000000f8, 0, 0x0000100, 0, 0, 0, 42},
 #ifdef BTTV_BOARD_FLYVIDEO_98FM
 	/* smorar@alfonzo.smuts.uct.ac.za */
-	{BTTV_BOARD_FLYVIDEO_98FM,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+	{BTTV_BOARD_FLYVIDEO_98FM,
+		0, 0x000000f8, 0, 0x0000100, 0, 0, 0, 42},
 #endif
 	/* The Leadtek WinFast TV 2000 XP card (id 0x6606107d) uses an
 	 * extra gpio bit compared to the original TV 2000 card (id
 	 * 0x217d6606); as the bttv-0.7.100 driver does not
 	 * distinguish between the two cards, we enable the extra bit
 	 * based on the card id: */
-	{BTTV_BOARD_WINFAST2000,   0x6606107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
-	{BTTV_BOARD_WINFAST2000,   0x6609107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
-	{BTTV_BOARD_WINFAST2000,   0xff06107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
+	{BTTV_BOARD_WINFAST2000,
+		0x6606107d, 0x000008f8, 0, 0x0000100, 0, 0, 0, 32},
+	{BTTV_BOARD_WINFAST2000,
+		0x6609107d, 0x000008f8, 0, 0x0000100, 0, 0, 0, 32},
+	{BTTV_BOARD_WINFAST2000,
+		0xff06107d, 0x000008f8, 0, 0x0000100, 0, 0, 0, 32},
 	/* default: */
-	{BTTV_BOARD_WINFAST2000,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 32},
+	{BTTV_BOARD_WINFAST2000,
+		0, 0x000000f8,	0, 0x0000100, 0, 0, 0, 32},
 #ifdef BTTV_BOARD_GVBCTV5PCI
-	{BTTV_BOARD_GVBCTV5PCI,             0, 0x00f0b000,          0,         0,          0,   0, 20,  8},
+	{BTTV_BOARD_GVBCTV5PCI,
+		0, 0x00f0b000, 0, 0, 0, 0, 20, 8},
 #endif
 };
 
-static unsigned char code_length = 0;
+static unsigned char code_length;
 static unsigned char code_bytes = 1;
 
 #define MAX_BYTES 8
@@ -169,17 +210,15 @@ static unsigned char code_bytes = 1;
 /* how many bits GPIO value can be shifted right before processing
  * it is computed from the value of gpio_mask_parameter
  */
-static unsigned char gpio_pre_shift = 0;
-
+static unsigned char gpio_pre_shift;
 
 static inline int reverse(int data, int bits)
 {
 	int i;
 	int c;
-	
-	for (c=0,i=0; i<bits; i++) {
+
+	for (c = 0, i = 0; i < bits; i++)
 		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
-	}
 
 	return c;
 }
@@ -189,16 +228,14 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 	unsigned long mask = gpio_mask;
 	unsigned char shift = 0;
 
-	dprintk(LOGHEAD "gpio_val is %lx\n",card,(unsigned long) gpio_val);
-	
+	dprintk(LOGHEAD "gpio_val is %lx\n", card, (unsigned long) gpio_val);
+
 	gpio_val ^= gpio_xor_mask;
-	
-	if (gpio_lock_mask && (gpio_val & gpio_lock_mask)) {
+
+	if (gpio_lock_mask && (gpio_val & gpio_lock_mask))
 		return -EBUSY;
-	}
-	
-	switch (bttv_id)
-	{
+
+	switch (bttv_id) {
 	case BTTV_BOARD_AVERMEDIA98:
 		if (bttv_write_gpio(card, gpio_enable, gpio_enable)) {
 			dprintk(LOGHEAD "cannot write to GPIO\n", card);
@@ -216,21 +253,19 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 	default:
 		break;
 	}
-	
+
 	/* extract bits from "raw" GPIO value using gpio_mask */
 	codes[0] = 0;
 	gpio_val >>= gpio_pre_shift;
 	while (mask) {
-		if (mask & 1u) {
+		if (mask & 1u)
 			codes[0] |= (gpio_val & 1u) << shift++;
-		}
 		mask >>= 1;
 		gpio_val >>= 1;
 	}
-	
-	dprintk(LOGHEAD "code is %lx\n",card,(unsigned long) codes[0]);
-	switch (bttv_id)
-	{
+
+	dprintk(LOGHEAD "code is %lx\n", card, (unsigned long) codes[0]);
+	switch (bttv_id) {
 	case BTTV_BOARD_AVERMEDIA:
 		codes[2] = (codes[0]<<2)&0xff;
 		codes[3] = (~codes[2])&0xff;
@@ -256,22 +291,22 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 #ifdef BTTV_BOARD_FLYVIDEO_98FM
 	case BTTV_BOARD_FLYVIDEO_98FM:
 #endif
-		codes[4]=codes[0]<<3;
-		codes[5]=((~codes[4])&0xff);
-		
-		codes[0]=0x00;
-		codes[1]=0x1A;
-		codes[2]=0x1F;
-		codes[3]=0x2F;
+		codes[4] = codes[0]<<3;
+		codes[5] = ((~codes[4])&0xff);
+
+		codes[0] = 0x00;
+		codes[1] = 0x1A;
+		codes[2] = 0x1F;
+		codes[3] = 0x2F;
 		break;
-        case BTTV_BOARD_MAGICTVIEW061:
-        case BTTV_BOARD_MAGICTVIEW063:
+	case BTTV_BOARD_MAGICTVIEW061:
+	case BTTV_BOARD_MAGICTVIEW063:
 	case BTTV_BOARD_PHOEBE_TVMAS:
 		codes[0] = (codes[0]&0x01)
-			|((codes[0]&0x02)<<1)
-			|((codes[0]&0x04)<<2)
-			|((codes[0]&0x08)>>2)
-			|((codes[0]&0x10)>>1);
+			| ((codes[0]&0x02)<<1)
+			| ((codes[0]&0x04)<<2)
+			| ((codes[0]&0x08)>>2)
+			| ((codes[0]&0x10)>>1);
 		/* FALLTHROUGH */
 	case BTTV_BOARD_MIRO:
 	case BTTV_BOARD_DYNALINK:
@@ -288,7 +323,7 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 #ifdef BTTV_BOARD_KWORLD
 	case BTTV_BOARD_KWORLD:
 #endif
-		codes[2] = reverse(codes[0],8);
+		codes[2] = reverse(codes[0], 8);
 		codes[3] = (~codes[2])&0xff;
 		codes[0] = 0x61;
 		codes[1] = 0xD6;
@@ -297,22 +332,22 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 		/* derived from e-tech config file */
 		/* 26 + 16 bits */
 		/* won't apply it until it's confirmed with a fly98 */
- 	case BTTV_BOARD_FLYVIDEO_98:
+	case BTTV_BOARD_FLYVIDEO_98:
 	case BTTV_BOARD_FLYVIDEO_98FM:
-		codes[4]=codes[0]<<3;
-		codes[5]=(~codes[4])&0xff;
-		
-		codes[0]=0x00;
-		codes[1]=0x1A;
-		codes[2]=0x1F;
-		codes[3]=0x2F;
+		codes[4] = codes[0]<<3;
+		codes[5] = (~codes[4])&0xff;
+
+		codes[0] = 0x00;
+		codes[1] = 0x1A;
+		codes[2] = 0x1F;
+		codes[3] = 0x2F;
 		break;
 #endif
 	case BTTV_BOARD_WINFAST2000:
 		/* shift extra bit */
 		codes[0] = (codes[0]&0x1f) | ((codes[0]&0x20) << 1);
 	case BTTV_BOARD_WINVIEW_601:
-		codes[2] = reverse(codes[0],8);
+		codes[2] = reverse(codes[0], 8);
 		codes[3] = (~codes[2])&0xff;
 		codes[0] = 0xC0;
 		codes[1] = 0x3F;
@@ -325,48 +360,47 @@ static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
 }
 
 /* add_to_buf - copy a code to the buffer */
-static int add_to_buf(void* data, struct lirc_buffer* buf)
+static int add_to_buf(void *data, struct lirc_buffer *buf)
 {
-	static unsigned long next_time = 0;
+	static unsigned long next_time;
 	static unsigned char prev_codes[MAX_BYTES];
 	unsigned long code = 0;
 	unsigned char cur_codes[MAX_BYTES];
-    
+
 	if (bttv_read_gpio(card, &code)) {
 		dprintk(LOGHEAD "cannot read GPIO\n", card);
 		return -EIO;
 	}
-	
-	if (build_key(code, cur_codes)) {
+
+	if (build_key(code, cur_codes))
 		return -EFAULT;
-	}
-	
+
 	if (soft_gap) {
 		if (!memcmp(prev_codes, cur_codes, code_bytes) &&
-			jiffies < next_time) {
+			jiffies < next_time)
 			return -EAGAIN;
-		}
+
 		next_time = jiffies + soft_gap;
 	}
-	memcpy( prev_codes, cur_codes, code_bytes );
-		
-	lirc_buffer_write_1( buf, cur_codes );
-		
+	memcpy(prev_codes, cur_codes, code_bytes);
+
+	lirc_buffer_write_1(buf, cur_codes);
+
 	return SUCCESS;
 }
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 	MOD_DEC_USE_COUNT;
 }
 
-static wait_queue_head_t* get_queue(void* data)
+static wait_queue_head_t *get_queue(void *data)
 {
 	return bttv_get_gpio_queue(card);
 }
@@ -378,14 +412,14 @@ static struct lirc_plugin plugin = {
 	.set_use_inc	= set_use_inc,
 	.set_use_dec	= set_use_dec,
 	.dev		= NULL,
-	.owner          = THIS_MODULE,
+	.owner		= THIS_MODULE,
 };
 
 /*
  *
  */
 static int gpio_remote_init(void)
-{  	
+{
 	int ret;
 	unsigned int mask;
 
@@ -397,29 +431,28 @@ static int gpio_remote_init(void)
 		gpio_mask >>= 1;
 	}
 
-	if (code_length) {
+	if (code_length)
 		plugin.code_length = code_length;
-	} else {
+	else {
 		/* calculate scan code length in bits if needed */
 		plugin.code_length = 1;
 		mask = gpio_mask >> 1;
 		while (mask) {
-			if (mask & 1u) {
+			if (mask & 1u)
 				plugin.code_length++;
-			}
 			mask >>= 1;
 		}
 	}
 
-	code_bytes = (plugin.code_length/8) + (plugin.code_length%8 ? 1 : 0);
+	code_bytes = (plugin.code_length/8) + (plugin.code_length % 8 ? 1 : 0);
 	if (MAX_BYTES < code_bytes) {
-		printk (LOGHEAD "scan code too long (%d bytes)\n",
+		printk(LOGHEAD "scan code too long (%d bytes)\n",
 			minor, code_bytes);
 		return -EBADRQC;
 	}
 
 	if (gpio_enable) {
-		if(bttv_gpio_enable(card, gpio_enable, gpio_enable)) {
+		if (bttv_gpio_enable(card, gpio_enable, gpio_enable)) {
 			printk(LOGHEAD "gpio_enable failure\n", minor);
 			return -EIO;
 		}
@@ -433,13 +466,13 @@ static int gpio_remote_init(void)
 	plugin.sample_rate = sample_rate;
 
 	ret = lirc_register_plugin(&plugin);
-	
+
 	if (0 > ret) {
-		printk (LOGHEAD "device registration failed with %d\n",
+		printk(LOGHEAD "device registration failed with %d\n",
 			minor, ret);
 		return ret;
 	}
-	
+
 	minor = ret;
 	printk(LOGHEAD "driver registered\n", minor);
 
@@ -452,28 +485,29 @@ static int gpio_remote_init(void)
  */
 int init_module(void)
 {
-	int type,cardid,card_type;
+	int type, cardid, card_type;
 
 	if (MAX_IRCTL_DEVICES < minor) {
-		printk("lirc_gpio: parameter minor (%d) must be less than %d!\n",
-		       minor, MAX_IRCTL_DEVICES-1);
+		printk(KERN_INFO "lirc_gpio: parameter minor (%d) "
+		       "must be less than %d!\n",
+		       minor, MAX_IRCTL_DEVICES - 1);
 		return -EBADRQC;
 	}
-	
+
 	request_module("bttv");
 
-	/* if gpio_mask not zero then use module parameters 
+	/* if gpio_mask not zero then use module parameters
 	 * instead of autodetecting TV card
 	 */
 	if (gpio_mask) {
-		if (sample_rate!=0 &&
+		if (sample_rate != 0 &&
 		    (2 > sample_rate || HZ < sample_rate)) {
 			printk(LOGHEAD "parameter sample_rate "
 			       "must be between 2 and %d!\n", minor, HZ);
 			return -EBADRQC;
 		}
 
-		if (sample_rate!=0 && soft_gap && 
+		if (sample_rate != 0 && soft_gap &&
 		    ((2000/sample_rate) > soft_gap || 1000 < soft_gap)) {
 			printk(LOGHEAD "parameter soft_gap "
 			       "must be between %d and 1000!\n",
@@ -481,12 +515,12 @@ int init_module(void)
 			return -EBADRQC;
 		}
 	} else {
-		if(bttv_get_cardinfo(card,&type,&cardid)==-1) {
+		if (bttv_get_cardinfo(card, &type, &cardid) == -1) {
 			printk(LOGHEAD "could not get card type\n", minor);
 			return -EBADRQC;
 		}
-		printk(LOGHEAD "card type 0x%x, id 0x%x\n",minor,
-		       type,cardid);
+		printk(LOGHEAD "card type 0x%x, id 0x%x\n", minor,
+		       type, cardid);
 
 		if (type == BTTV_BOARD_UNKNOWN) {
 			printk(LOGHEAD "cannot detect TV card nr %d!\n",
@@ -494,7 +528,7 @@ int init_module(void)
 			return -EBADRQC;
 		}
 		for (card_type = 1;
-		     card_type < sizeof(rcv_infos)/sizeof(struct rcv_info); 
+		     card_type < sizeof(rcv_infos)/sizeof(struct rcv_info);
 		     card_type++) {
 			if (rcv_infos[card_type].bttv_id == type &&
 			    (rcv_infos[card_type].card_id == 0 ||
@@ -502,26 +536,28 @@ int init_module(void)
 				bttv_id = rcv_infos[card_type].bttv_id;
 				gpio_mask = rcv_infos[card_type].gpio_mask;
 				gpio_enable = rcv_infos[card_type].gpio_enable;
-				gpio_lock_mask = rcv_infos[card_type].gpio_lock_mask;
-				gpio_xor_mask = rcv_infos[card_type].gpio_xor_mask;
+				gpio_lock_mask =
+					rcv_infos[card_type].gpio_lock_mask;
+				gpio_xor_mask =
+					rcv_infos[card_type].gpio_xor_mask;
 				soft_gap = rcv_infos[card_type].soft_gap;
 				sample_rate = rcv_infos[card_type].sample_rate;
 				code_length = rcv_infos[card_type].code_length;
 				break;
 			}
 		}
-		if (type==BTTV_BOARD_AVPHONE98 && cardid==0x00011461)	{
+		if (type == BTTV_BOARD_AVPHONE98 && cardid == 0x00011461)
 			bttv_id = BTTV_BOARD_AVERMEDIA98;
-		}
-		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x00041461) {
+
+		if (type == BTTV_BOARD_AVERMEDIA98 && cardid == 0x00041461)
 			bttv_id = BTTV_BOARD_AVPHONE98;
-		}
-		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x03001461) {
+
+		if (type == BTTV_BOARD_AVERMEDIA98 && cardid == 0x03001461)
 			bttv_id = BTTV_BOARD_AVPHONE98;
-		}
-		if (type==BTTV_BOARD_AVERMEDIA98 && cardid==0x00000000) {
+
+		if (type == BTTV_BOARD_AVERMEDIA98 && cardid == 0x00000000)
 			bttv_id = BTTV_BOARD_AVPHONE98;
-		}
+
 		if (card_type == sizeof(rcv_infos)/sizeof(struct rcv_info)) {
 			printk(LOGHEAD "TV card type 0x%x not supported!\n",
 			       minor, type);
@@ -545,7 +581,8 @@ void cleanup_module(void)
 }
 
 /* Dont try to use it as a static version !  */
-MODULE_DESCRIPTION("Driver module for remote control (data from bt848 GPIO port)");
+MODULE_DESCRIPTION("Driver module for remote control (data "
+		   "from bt848 GPIO port)");
 MODULE_AUTHOR("Artur Lipowski");
 MODULE_LICENSE("GPL");
 
diff --git a/drivers/char/lirc/lirc_i2c.c b/drivers/char/lirc/lirc_i2c.c
index a336b0c..24f84e9 100644
--- a/drivers/char/lirc/lirc_i2c.c
+++ b/drivers/char/lirc/lirc_i2c.c
@@ -1,4 +1,4 @@
-/*      $Id: lirc_i2c.c,v 1.39 2007/02/13 06:45:15 lirc Exp $      */
+/*      $Id: lirc_i2c.c,v 1.46 2008/05/04 13:49:53 lirc Exp $      */
 
 /*
  * i2c IR lirc plugin for Hauppauge and Pixelview cards - new 2.3.x i2c stack
@@ -15,6 +15,8 @@
  *      Jerome Brock <jbrock@users.sourceforge.net>
  * modified for Leadtek Winfast PVR2000 by
  *      Thomas Reitmayr (treitmayr@yahoo.com)
+ * modified for Hauppauge HVR-1300 by
+ *      Jan Frey (jfrey@gmx.de)
  *
  * parts are cut&pasted from the old lirc_haup.c driver
  *
@@ -71,16 +73,17 @@ struct IR {
 #define DEVICE_NAME "lirc_i2c"
 
 /* ----------------------------------------------------------------------- */
-/* insmod parameters                                                       */
+/* insmod parameters						       */
 
-static int debug   = 0;    /* debug output */
-static int minor   = -1;   /* minor number */
+static int debug;	/* debug output */
+static int minor = -1;	/* minor number */
 
-#define dprintk(fmt, args...)                                           \
-	do{                                                             \
-		if(debug) printk(KERN_DEBUG DEVICE_NAME ": " fmt,       \
-				 ## args);                              \
-	}while(0)
+#define dprintk(fmt, args...)						\
+	do {								\
+		if (debug)						\
+			printk(KERN_DEBUG DEVICE_NAME ": " fmt,		\
+			       ## args);				\
+	} while (0)
 
 /* ----------------------------------------------------------------------- */
 
@@ -88,44 +91,42 @@ static inline int reverse(int data, int bits)
 {
 	int i;
 	int c;
-	
-	for (c=0,i=0; i<bits; i++) {
+
+	for (c = 0, i = 0; i < bits; i++)
 		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
-	}
 
 	return c;
 }
 
-static int add_to_buf_adap(void* data, struct lirc_buffer* buf)
+static int add_to_buf_adap(void *data, struct lirc_buffer *buf)
 {
 	struct IR *ir = data;
 	unsigned char keybuf[4];
-	
+
 	keybuf[0] = 0x00;
-	i2c_master_send(&ir->c,keybuf,1);
+	i2c_master_send(&ir->c, keybuf, 1);
 	/* poll IR chip */
-	if(i2c_master_recv(&ir->c,keybuf,sizeof(keybuf)) != sizeof(keybuf))
-	{
+	if (i2c_master_recv(&ir->c, keybuf, sizeof(keybuf)) != sizeof(keybuf)) {
 		dprintk("read error\n");
 		return -EIO;
 	}
-	
+
 	dprintk("key (0x%02x%02x%02x%02x)\n",
 		keybuf[0], keybuf[1], keybuf[2], keybuf[3]);
-	
+
 	/* key pressed ? */
 	if (keybuf[2] == 0xff)
 		return -ENODATA;
-	
+
 	/* remove repeat bit */
 	keybuf[2] &= 0x7f;
 	keybuf[3] |= 0x80;
-	
+
 	lirc_buffer_write_1(buf, keybuf);
 	return 0;
 }
 
-static int add_to_buf_pcf8574(void* data, struct lirc_buffer* buf)
+static int add_to_buf_pcf8574(void *data, struct lirc_buffer *buf)
 {
 	struct IR *ir = data;
 	int rc;
@@ -150,9 +151,9 @@ static int add_to_buf_pcf8574(void* data, struct lirc_buffer* buf)
 	}
 
 	/* drop duplicate polls */
-	if (ir->b[0] == (rc & all)) {
+	if (ir->b[0] == (rc & all))
 		return -ENODATA;
-	}
+
 	ir->b[0] = rc & all;
 
 	dprintk("%s key 0x%02X %s\n", ir->c.name, rc & ir->bits,
@@ -165,20 +166,20 @@ static int add_to_buf_pcf8574(void* data, struct lirc_buffer* buf)
 
 	/* set valid key code */
 	key  = rc & ir->bits;
-	lirc_buffer_write_1( buf, &key );
+	lirc_buffer_write_1(buf, &key);
 	return 0;
 }
 
 /* common for Hauppauge IR receivers */
-static int add_to_buf_haup_common(void* data, struct lirc_buffer* buf,
-		unsigned char* keybuf, int size, int offset)
+static int add_to_buf_haup_common(void *data, struct lirc_buffer *buf,
+		unsigned char *keybuf, int size, int offset)
 {
 	struct IR *ir = data;
 	__u16 code;
 	unsigned char codes[2];
 
 	/* poll IR chip */
-	if (size == i2c_master_recv(&ir->c,keybuf,size)) {
+	if (size == i2c_master_recv(&ir->c, keybuf, size)) {
 		ir->b[0] = keybuf[offset];
 		ir->b[1] = keybuf[offset+1];
 		ir->b[2] = keybuf[offset+2];
@@ -191,20 +192,20 @@ static int add_to_buf_haup_common(void* data, struct lirc_buffer* buf,
 	/* key pressed ? */
 	if ((ir->b[0] & 0x80) == 0)
 		return -ENODATA;
-	
+
 	/* look what we have */
 	code = (((__u16)ir->b[0]&0x7f)<<6) | (ir->b[1]>>2);
-	
+
 	codes[0] = (code >> 8) & 0xff;
 	codes[1] = code & 0xff;
 
 	/* return it */
-	lirc_buffer_write_1( buf, codes );
+	lirc_buffer_write_1(buf, codes);
 	return 0;
 }
 
 /* specific for the Hauppauge PVR150 IR receiver */
-static int add_to_buf_haup_pvr150(void* data, struct lirc_buffer* buf)
+static int add_to_buf_haup_pvr150(void *data, struct lirc_buffer *buf)
 {
 	unsigned char keybuf[6];
 	/* fetch 6 bytes, first relevant is at offset 3 */
@@ -212,7 +213,7 @@ static int add_to_buf_haup_pvr150(void* data, struct lirc_buffer* buf)
 }
 
 /* used for all Hauppauge IR receivers but the PVR150 */
-static int add_to_buf_haup(void* data, struct lirc_buffer* buf)
+static int add_to_buf_haup(void *data, struct lirc_buffer *buf)
 {
 	unsigned char keybuf[3];
 	/* fetch 3 bytes, first relevant is at offset 0 */
@@ -220,7 +221,7 @@ static int add_to_buf_haup(void* data, struct lirc_buffer* buf)
 }
 
 
-static int add_to_buf_pvr2000(void* data, struct lirc_buffer* buf)
+static int add_to_buf_pvr2000(void *data, struct lirc_buffer *buf)
 {
 	struct IR *ir = data;
 	unsigned char key;
@@ -228,7 +229,8 @@ static int add_to_buf_pvr2000(void* data, struct lirc_buffer* buf)
 	s32 code;
 
 	/* poll IR chip */
-	if (-1 == (flags = i2c_smbus_read_byte_data(&ir->c,0x10))) {
+	flags = i2c_smbus_read_byte_data(&ir->c, 0x10);
+	if (-1 == flags) {
 		dprintk("read error\n");
 		return -ENODATA;
 	}
@@ -237,7 +239,8 @@ static int add_to_buf_pvr2000(void* data, struct lirc_buffer* buf)
 		return -ENODATA;
 
 	/* read actual key code */
-	if (-1 == (code = i2c_smbus_read_byte_data(&ir->c,0x00))) {
+	code = i2c_smbus_read_byte_data(&ir->c, 0x00);
+	if (-1 == code) {
 		dprintk("read error\n");
 		return -ENODATA;
 	}
@@ -247,96 +250,102 @@ static int add_to_buf_pvr2000(void* data, struct lirc_buffer* buf)
 	dprintk("IR Key/Flags: (0x%02x/0x%02x)\n", key, flags & 0xFF);
 
 	/* return it */
-	lirc_buffer_write_1( buf, &key );
+	lirc_buffer_write_1(buf, &key);
 	return 0;
 }
 
-static int add_to_buf_pixelview(void* data, struct lirc_buffer* buf)
+static int add_to_buf_pixelview(void *data, struct lirc_buffer *buf)
 {
 	struct IR *ir = data;
 	unsigned char key;
-	
+
 	/* poll IR chip */
-	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+	if (1 != i2c_master_recv(&ir->c, &key, 1)) {
 		dprintk("read error\n");
 		return -1;
 	}
 	dprintk("key %02x\n", key);
 
 	/* return it */
-	lirc_buffer_write_1( buf, &key );
+	lirc_buffer_write_1(buf, &key);
 	return 0;
 }
 
-static int add_to_buf_pv951(void* data, struct lirc_buffer* buf)
+static int add_to_buf_pv951(void *data, struct lirc_buffer *buf)
 {
 	struct IR *ir = data;
 	unsigned char key;
 	unsigned char codes[4];
 
 	/* poll IR chip */
-	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+	if (1 != i2c_master_recv(&ir->c, &key, 1)) {
 		dprintk("read error\n");
 		return -ENODATA;
 	}
 	/* ignore 0xaa */
-	if (key==0xaa)
+	if (key == 0xaa)
 		return -ENODATA;
 	dprintk("key %02x\n", key);
 
 	codes[0] = 0x61;
 	codes[1] = 0xD6;
-	codes[2] = reverse(key,8);
+	codes[2] = reverse(key, 8);
 	codes[3] = (~codes[2])&0xff;
-	
-	lirc_buffer_write_1( buf, codes );
+
+	lirc_buffer_write_1(buf, codes);
 	return 0;
 }
 
-static int add_to_buf_knc1(void *data, struct lirc_buffer* buf)
+static int add_to_buf_knc1(void *data, struct lirc_buffer *buf)
 {
 	static unsigned char last_key = 0xFF;
 	struct IR *ir = data;
 	unsigned char key;
-	
+
 	/* poll IR chip */
-	if (1 != i2c_master_recv(&ir->c,&key,1)) {
+	if (1 != i2c_master_recv(&ir->c, &key, 1)) {
 		dprintk("read error\n");
 		return -ENODATA;
 	}
-	
+
 	/* it seems that 0xFE indicates that a button is still hold
 	   down, while 0xFF indicates that no button is hold
 	   down. 0xFE sequences are sometimes interrupted by 0xFF */
-	
+
 	dprintk("key %02x\n", key);
-	
-	if( key == 0xFF )
+
+	if (key == 0xFF)
 		return -ENODATA;
-	
-	if ( key == 0xFE )
+
+	if (key == 0xFE)
 		key = last_key;
 
 	last_key = key;
-	lirc_buffer_write_1( buf, &key );
+	lirc_buffer_write_1(buf, &key);
 
 	return 0;
 }
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	struct IR *ir = data;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	i2c_use_client(&ir->c);
+#else
 	int ret;
 
 	/* lock bttv in memory while /dev/lirc is in use  */
 	ret = i2c_use_client(&ir->c);
-	if(ret != 0) return ret;
+	if (ret != 0)
+		return ret;
+#endif
 
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 	struct IR *ir = data;
 
@@ -345,11 +354,11 @@ static void set_use_dec(void* data)
 }
 
 static struct lirc_plugin lirc_template = {
-	name:        "lirc_i2c",
-	set_use_inc: set_use_inc,
-	set_use_dec: set_use_dec,
-	dev:         NULL,
-	owner:       THIS_MODULE
+	.name		= "lirc_i2c",
+	.set_use_inc	= set_use_inc,
+	.set_use_dec	= set_use_dec,
+	.dev		= NULL,
+	.owner		= THIS_MODULE,
 };
 
 /* ----------------------------------------------------------------------- */
@@ -362,39 +371,40 @@ static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg);
 
 static struct i2c_driver driver = {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
-        name:           "i2c ir driver",
-        flags:          I2C_DF_NOTIFY,
+	.name		= "i2c ir driver",
+	.flags		= I2C_DF_NOTIFY,
 #else
 	.driver = {
-		owner:  THIS_MODULE,
-		name:   "i2c ir driver",
+		.owner	= THIS_MODULE,
+		.name	= "i2c ir driver",
 	},
 #endif
-        id:             I2C_DRIVERID_EXP3, /* FIXME */
-        attach_adapter: ir_probe,
-        detach_client:  ir_detach,
-        command:        ir_command,
+	.id		= I2C_DRIVERID_EXP3, /* FIXME */
+	.attach_adapter	= ir_probe,
+	.detach_client	= ir_detach,
+	.command	= ir_command,
 };
 
-static struct i2c_client client_template = 
-{
-        name:   "unset",
-        driver: &driver
+static struct i2c_client client_template = {
+	.name		= "unset",
+	.driver		= &driver
 };
 
 static int ir_attach(struct i2c_adapter *adap, int addr,
 		     unsigned short flags, int kind)
 {
-        struct IR *ir;
-	
-        client_template.adapter = adap;
-        client_template.addr = addr;
-	
-        if (NULL == (ir = kmalloc(sizeof(struct IR),GFP_KERNEL)))
-                return -ENOMEM;
-        memcpy(&ir->l,&lirc_template,sizeof(struct lirc_plugin));
-        memcpy(&ir->c,&client_template,sizeof(struct i2c_client));
-	
+	struct IR *ir;
+	int err;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	ir = kmalloc(sizeof(struct IR), GFP_KERNEL);
+	if (!ir)
+		return -ENOMEM;
+	memcpy(&ir->l, &lirc_template, sizeof(struct lirc_plugin));
+	memcpy(&ir->c, &client_template, sizeof(struct i2c_client));
+
 	ir->c.adapter = adap;
 	ir->c.addr    = addr;
 	i2c_set_clientdata(&ir->c, ir);
@@ -403,85 +413,92 @@ static int ir_attach(struct i2c_adapter *adap, int addr,
 	ir->l.sample_rate = 10;
 	ir->nextkey   = -1;
 
-	switch(addr)
-	{
+	switch (addr) {
 	case 0x64:
-		strcpy(ir->c.name,"Pixelview IR");
+		strlcpy(ir->c.name, "Pixelview IR", I2C_NAME_SIZE);
 		ir->l.code_length = 8;
-		ir->l.add_to_buf=add_to_buf_pixelview;
+		ir->l.add_to_buf = add_to_buf_pixelview;
 		break;
 	case 0x4b:
-		strcpy(ir->c.name,"PV951 IR");
+		strlcpy(ir->c.name, "PV951 IR", I2C_NAME_SIZE);
 		ir->l.code_length = 32;
-		ir->l.add_to_buf=add_to_buf_pv951;
+		ir->l.add_to_buf = add_to_buf_pv951;
 		break;
 	case 0x71:
-		/* The PVR150 IR receiver uses the same protocol as other 
-		   Hauppauge cards, but the data flow is different, so we need
-		   to deal with it by its own.
-		 */
-		strcpy(ir->c.name,"Hauppauge IR (PVR150)");
+#ifdef I2C_HW_B_CX2341X
+		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848) ||
+		    adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2341X)) {
+#else
+		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848)) {
+#endif
+			/* The PVR150 IR receiver uses the same protocol as
+			 * other Hauppauge cards, but the data flow is
+			 * different, so we need to deal with it by its own. */
+			strlcpy(ir->c.name, "Hauppauge PVR150", I2C_NAME_SIZE);
+		} else /* I2C_HW_B_CX2388x */
+			strlcpy(ir->c.name, "Hauppauge HVR1300", I2C_NAME_SIZE);
 		ir->l.code_length = 13;
-		ir->l.add_to_buf=add_to_buf_haup_pvr150;
+		ir->l.add_to_buf = add_to_buf_haup_pvr150;
 		break;
 	case 0x6b:
-		strcpy(ir->c.name,"Adaptec IR");
+		strlcpy(ir->c.name, "Adaptec IR", I2C_NAME_SIZE);
 		ir->l.code_length = 32;
-		ir->l.add_to_buf=add_to_buf_adap;
+		ir->l.add_to_buf = add_to_buf_adap;
 		break;
 	case 0x18:
 	case 0x1a:
 #ifdef I2C_HW_B_CX2341X
 		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848) ||
-		    adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2341X))
+		    adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2341X)) {
 #else
-		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848))
+		if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848)) {
 #endif
-		{
-			strcpy(ir->c.name,"Hauppauge IR");
+			strlcpy(ir->c.name, "Hauppauge IR", I2C_NAME_SIZE);
 			ir->l.code_length = 13;
-			ir->l.add_to_buf=add_to_buf_haup;
-		}
-		else /* I2C_HW_B_CX2388x */
-		{
-			strcpy(ir->c.name,"Leadtek IR");
+			ir->l.add_to_buf = add_to_buf_haup;
+		} else { /* I2C_HW_B_CX2388x */
+			strlcpy(ir->c.name, "Leadtek IR", I2C_NAME_SIZE);
 			ir->l.code_length = 8;
-			ir->l.add_to_buf=add_to_buf_pvr2000;
+			ir->l.add_to_buf = add_to_buf_pvr2000;
 		}
 		break;
 	case 0x30:
-		strcpy(ir->c.name,"KNC ONE IR");
+		strlcpy(ir->c.name, "KNC ONE IR", I2C_NAME_SIZE);
 		ir->l.code_length = 8;
-		ir->l.add_to_buf=add_to_buf_knc1;
+		ir->l.add_to_buf = add_to_buf_knc1;
 		break;
 	case 0x21:
 	case 0x23:
-		strcpy(ir->c.name,"TV-Box IR");
+		strlcpy(ir->c.name, "TV-Box IR", I2C_NAME_SIZE);
 		ir->l.code_length = 8;
-		ir->l.add_to_buf=add_to_buf_pcf8574;
+		ir->l.add_to_buf = add_to_buf_pcf8574;
 		ir->bits = flags & 0xff;
 		ir->flag = (flags >> 8) & 0xff;
 		break;
-		
 	default:
 		/* shouldn't happen */
-		printk("lirc_i2c: Huh? unknown i2c address (0x%02x)?\n",addr);
+		printk("lirc_i2c: Huh? unknown i2c address (0x%02x)?\n", addr);
 		kfree(ir);
 		return -1;
 	}
-	printk("lirc_i2c: chip found @ 0x%02x (%s)\n",addr,ir->c.name);
-	
+	printk(KERN_INFO "lirc_i2c: chip 0x%x found @ 0x%02x (%s)\n",
+	       adap->id, addr, ir->c.name);
+
 	/* register device */
-	i2c_attach_client(&ir->c);
+	err = i2c_attach_client(&ir->c);
+	if (err) {
+		kfree(ir);
+		return err;
+	}
 	ir->l.minor = lirc_register_plugin(&ir->l);
-	
+
 	return 0;
 }
 
 static int ir_detach(struct i2c_client *client)
 {
 	struct IR *ir = i2c_get_clientdata(client);
-	
+
 	/* unregister device */
 	lirc_unregister_plugin(ir->l.minor);
 	i2c_detach_client(&ir->c);
@@ -491,20 +508,19 @@ static int ir_detach(struct i2c_client *client)
 	return 0;
 }
 
-static int ir_probe(struct i2c_adapter *adap) {
-	
+static int ir_probe(struct i2c_adapter *adap)
+{
 	/* The external IR receiver is at i2c address 0x34 (0x35 for
-	   reads).  Future Hauppauge cards will have an internal
-	   receiver at 0x30 (0x31 for reads).  In theory, both can be
-	   fitted, and Hauppauge suggest an external overrides an
-	   internal. 
-	   
-	   That's why we probe 0x1a (~0x34) first. CB 
-
-	   The i2c address for the Hauppauge PVR-150 card is 0xe2,
-	   so we need to probe 0x71 as well.
-	*/
-	
+	 * reads).  Future Hauppauge cards will have an internal
+	 * receiver at 0x30 (0x31 for reads).  In theory, both can be
+	 * fitted, and Hauppauge suggest an external overrides an
+	 * internal.
+	 *
+	 * That's why we probe 0x1a (~0x34) first. CB
+	 *
+	 * The i2c address for the Hauppauge PVR-150 card is 0xe2,
+	 * so we need to probe 0x71 as well. */
+
 	static const int probe[] = {
 		0x1a, /* Hauppauge IR external */
 		0x18, /* Hauppauge IR internal */
@@ -514,7 +530,17 @@ static int ir_probe(struct i2c_adapter *adap) {
 		0x30, /* KNC ONE IR */
 		0x6b, /* Adaptec IR */
 		-1};
-	struct i2c_client c; char buf; int i,rc;
+
+#ifdef I2C_HW_B_CX2388x
+	static const int probe_cx88[] = {
+		0x18, /* Leadtek Winfast PVR2000 */
+		0x71, /* Hauppauge HVR-IR */
+		-1};
+#endif
+
+	struct i2c_client c;
+	char buf;
+	int i, rc;
 
 #ifdef I2C_HW_B_CX2341X
 	if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848) ||
@@ -523,33 +549,32 @@ static int ir_probe(struct i2c_adapter *adap) {
 	if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_BT848))
 #endif
 	{
-		memset(&c,0,sizeof(c));
+		memset(&c, 0, sizeof(c));
 		c.adapter = adap;
 		for (i = 0; -1 != probe[i]; i++) {
 			c.addr = probe[i];
-			rc = i2c_master_recv(&c,&buf,1);
+			rc = i2c_master_recv(&c, &buf, 1);
 			dprintk("probe 0x%02x @ %s: %s\n",
-				probe[i], adap->name, 
+				probe[i], adap->name,
 				(1 == rc) ? "yes" : "no");
 			if (1 == rc)
-			{
-				ir_attach(adap,probe[i],0,0);
-			}
+				ir_attach(adap, probe[i], 0, 0);
 		}
 	}
 
 #ifdef I2C_HW_B_CX2388x
-	/* Leadtek Winfast PVR2000 */
+	/* Leadtek Winfast PVR2000 or Hauppauge HVR-1300 */
 	else if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_CX2388x)) {
-		memset(&c,0,sizeof(c));
+		memset(&c, 0, sizeof(c));
 		c.adapter = adap;
-		c.addr    = 0x18;
-		rc = i2c_master_recv(&c,&buf,1);
-		dprintk("probe 0x%02x @ %s: %s\n",
-			c.addr, adap->name, 
-			(1 == rc) ? "yes" : "no");
-		if (1 == rc) {
-			ir_attach(adap,c.addr,0,0);
+		for (i = 0; -1 != probe_cx88[i]; i++) {
+			c.addr = probe_cx88[i];
+			rc = i2c_master_recv(&c, &buf, 1);
+			dprintk("probe 0x%02x @ %s: %s\n",
+				c.addr, adap->name,
+				(1 == rc) ? "yes" : "no");
+			if (1 == rc)
+				ir_attach(adap, c.addr, 0, 0);
 		}
 	}
 #endif
@@ -557,8 +582,8 @@ static int ir_probe(struct i2c_adapter *adap) {
 	/* Asus TV-Box and Creative/VisionTek BreakOut-Box (PCF8574) */
 	else if (adap->id == (I2C_ALGO_BIT | I2C_HW_B_RIVA)) {
 		/* addresses to probe;
-		   leave 0x24 and 0x25 because SAA7113H possibly uses it 
-		   0x21 and 0x22 possibly used by SAA7108E 
+		   leave 0x24 and 0x25 because SAA7113H possibly uses it
+		   0x21 and 0x22 possibly used by SAA7108E
 		   Asus:      0x21 is a correct address (channel 1 of PCF8574)
 		   Creative:  0x23 is a correct address (channel 3 of PCF8574)
 		   VisionTek: 0x23 is a correct address (channel 3 of PCF8574)
@@ -568,7 +593,7 @@ static int ir_probe(struct i2c_adapter *adap) {
 		int ret1, ret2, ret3, ret4;
 		unsigned char bits = 0, flag = 0;
 
-		memset(&c,0,sizeof(c));
+		memset(&c, 0, sizeof(c));
 		c.adapter = adap;
 		for (i = 0; -1 != pcf_probe[i]; i++) {
 			c.addr = pcf_probe[i];
@@ -579,17 +604,17 @@ static int ir_probe(struct i2c_adapter *adap) {
 
 			/* ensure that the writable bitmask works correctly */
 			rc = 0;
-			if (ret1 != -1 && ret2 != -1 && 
+			if (ret1 != -1 && ret2 != -1 &&
 			    ret3 != -1 && ret4 != -1) {
 				/* in the Asus TV-Box: bit 1-0 */
-				if (((ret2 & 0x03) == 0x03) && 
+				if (((ret2 & 0x03) == 0x03) &&
 				    ((ret4 & 0x03) == 0x00)) {
 					bits = (unsigned char) ~0x07;
 					flag = 0x04;
 					rc = 1;
 				}
-				/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
-				if (((ret2 & 0xc0) == 0xc0) && 
+			/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
+				if (((ret2 & 0xc0) == 0xc0) &&
 				    ((ret4 & 0xc0) == 0x00)) {
 					bits = (unsigned char) ~0xe0;
 					flag = 0x20;
@@ -599,14 +624,15 @@ static int ir_probe(struct i2c_adapter *adap) {
 			dprintk("probe 0x%02x @ %s: %s\n",
 				c.addr, adap->name, rc ? "yes" : "no");
 			if (rc)
-				ir_attach(adap,pcf_probe[i],bits|(flag<<8),0);
+				ir_attach(adap, pcf_probe[i],
+					  bits|(flag<<8), 0);
 		}
 	}
-		
+
 	return 0;
 }
 
-static int ir_command(struct i2c_client *client,unsigned int cmd, void *arg)
+static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
 	/* nothing */
 	return 0;
@@ -630,8 +656,10 @@ void cleanup_module(void)
 	i2c_del_driver(&driver);
 }
 
-MODULE_DESCRIPTION("Infrared receiver driver for Hauppauge and Pixelview cards (i2c stack)");
-MODULE_AUTHOR("Gerd Knorr, Michal Kochanowicz, Christoph Bartelmus, Ulrich Mueller, Stefan Jahn, Jerome Brock");
+MODULE_DESCRIPTION("Infrared receiver driver for Hauppauge and "
+		   "Pixelview cards (i2c stack)");
+MODULE_AUTHOR("Gerd Knorr, Michal Kochanowicz, Christoph Bartelmus, "
+	      "Ulrich Mueller, Stefan Jahn, Jerome Brock");
 MODULE_LICENSE("GPL");
 
 module_param(minor, int, 0444);
diff --git a/drivers/char/lirc/lirc_igorplugusb.c b/drivers/char/lirc/lirc_igorplugusb.c
index 2e06ab6..fed57f4 100644
--- a/drivers/char/lirc/lirc_igorplugusb.c
+++ b/drivers/char/lirc/lirc_igorplugusb.c
@@ -1,15 +1,16 @@
 /* lirc_igorplugusb - USB remote support for LIRC
  *
  * Supports the standard homebrew IgorPlugUSB receiver with Igor's firmware.
- * See http://www.cesko.host.sk/IgorPlugUSB/IgorPlug-USB%20(AVR)_eng.htm 
- * 
+ * See http://www.cesko.host.sk/IgorPlugUSB/IgorPlug-USB%20(AVR)_eng.htm
+ *
  * The device can only record bursts of up to 36 pulses/spaces.
  * Works fine with RC5. Longer commands lead to device buffer overrun.
  * (Maybe a better firmware or a microcontroller with more ram can help?)
  *
  * Version 0.1  [beta status]
  *
- * Copyright (C) 2004 Jan M. Hochstein <hochstein@algo.informatik.tu-darmstadt.de>
+ * Copyright (C) 2004 Jan M. Hochstein
+ *	<hochstein@algo.informatik.tu-darmstadt.de>
  *
  * This driver was derived from:
  *   Paul Miller <pmiller9@users.sourceforge.net>
@@ -59,12 +60,13 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/time.h>
-#include <linux/lirc.h>
+
 #include "kcompat.h"
+#include <linux/lirc.h>
 #include "lirc_dev.h"
 
 #if !defined(KERNEL_2_5)
-#        define USB_CTRL_GET_TIMEOUT    5
+#define USB_CTRL_GET_TIMEOUT    5
 #endif
 
 /* lock irctl structure */
@@ -74,57 +76,59 @@
 /* module identification */
 #define DRIVER_VERSION		"0.1"
 #define DRIVER_AUTHOR		\
-        "Jan M. Hochstein <hochstein@algo.informatik.tu-darmstadt.de>"
+	"Jan M. Hochstein <hochstein@algo.informatik.tu-darmstadt.de>"
 #define DRIVER_DESC		"USB remote driver for LIRC"
 #define DRIVER_NAME		"lirc_igorplugusb"
 
 /* debugging support */
 #ifdef CONFIG_USB_DEBUG
-        static int debug = 1;
+static int debug = 1;
 #else
-        static int debug = 0;
+static int debug;
 #endif
 
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
 /* general constants */
-#define SUCCESS                 0
+#define SUCCESS		 0
 
 /* One mode2 pulse/space has 4 bytes. */
-#define CODE_LENGTH             sizeof(lirc_t)
+#define CODE_LENGTH	     sizeof(lirc_t)
 
 /* Igor's firmware cannot record bursts longer than 36. */
-#define DEVICE_BUFLEN           36
+#define DEVICE_BUFLEN	   36
 
 /** Header at the beginning of the device's buffer:
-        unsigned char data_length
-        unsigned char data_start    (!=0 means ring-buffer overrun)
-        unsigned char counter       (incremented by each burst)
+	unsigned char data_length
+	unsigned char data_start    (!=0 means ring-buffer overrun)
+	unsigned char counter       (incremented by each burst)
 **/
-#define DEVICE_HEADERLEN        3
+#define DEVICE_HEADERLEN	3
 
 /* This is for the gap */
 #define ADDITIONAL_LIRC_BYTES   2
 
 /* times to poll per second */
-#define SAMPLE_RATE             10
+#define SAMPLE_RATE	     100
 
+static int sample_rate = SAMPLE_RATE;
 
 /**** Igor's USB Request Codes */
 
 #define SET_INFRABUFFER_EMPTY   1
-/** 
+/**
  * Params: none
  * Answer: empty
  *
 **/
 
-#define GET_INFRACODE           2
-/** 
- * Params: 
+#define GET_INFRACODE	   2
+/**
+ * Params:
  *   wValue: offset to begin reading infra buffer
  *
  * Answer: infra data
@@ -132,8 +136,8 @@
 **/
 
 #define SET_DATAPORT_DIRECTION  3
-/** 
- * Params: 
+/**
+ * Params:
  *   wValue: (byte) 1 bit for each data port pin (0=in, 1=out)
  *
  * Answer: empty
@@ -141,50 +145,50 @@
 **/
 
 #define GET_DATAPORT_DIRECTION  4
-/** 
+/**
  * Params: none
  *
  * Answer: (byte) 1 bit for each data port pin (0=in, 1=out)
  *
 **/
 
-#define SET_OUT_DATAPORT        5
-/** 
- * Params: 
+#define SET_OUT_DATAPORT	5
+/**
+ * Params:
  *   wValue: byte to write to output data port
  *
  * Answer: empty
  *
 **/
 
-#define GET_OUT_DATAPORT        6
-/** 
+#define GET_OUT_DATAPORT	6
+/**
  * Params: none
  *
  * Answer: least significant 3 bits read from output data port
  *
 **/
 
-#define GET_IN_DATAPORT         7
-/** 
+#define GET_IN_DATAPORT	 7
+/**
  * Params: none
  *
  * Answer: least significant 3 bits read from input data port
  *
 **/
 
-#define READ_EEPROM             8
-/** 
- * Params: 
+#define READ_EEPROM	     8
+/**
+ * Params:
  *   wValue: offset to begin reading EEPROM
  *
  * Answer: EEPROM bytes
  *
 **/
 
-#define WRITE_EEPROM            9
-/** 
- * Params: 
+#define WRITE_EEPROM	    9
+/**
+ * Params:
  *   wValue: offset to EEPROM byte
  *   wIndex: byte to write
  *
@@ -192,34 +196,34 @@
  *
 **/
 
-#define SEND_RS232              10
-/** 
- * Params: 
+#define SEND_RS232	      10
+/**
+ * Params:
  *   wValue: byte to send
  *
  * Answer: empty
  *
 **/
 
-#define RECV_RS232              11
-/** 
+#define RECV_RS232	      11
+/**
  * Params: none
  *
  * Answer: byte received
  *
 **/
 
-#define SET_RS232_BAUD          12
-/** 
- * Params: 
+#define SET_RS232_BAUD	  12
+/**
+ * Params:
  *   wValue: byte to write to UART bit rate register (UBRR)
  *
  * Answer: empty
  *
 **/
 
-#define GET_RS232_BAUD          13
-/** 
+#define GET_RS232_BAUD	  13
+/**
  * Params: none
  *
  * Answer: byte read from UART bit rate register (UBRR)
@@ -237,7 +241,7 @@ struct irctl {
 
 	unsigned char *buf_in;
 	unsigned int len_in;
-        int in_space;
+	int in_space;
 	struct timeval last_time;
 
 #if defined(KERNEL_2_5)
@@ -259,9 +263,9 @@ static int unregister_from_lirc(struct irctl *ir)
 	struct lirc_plugin *p = ir->p;
 	int devnum;
 
-	if(!ir->p)
-        	return -EINVAL;
-        
+	if (!ir->p)
+		return -EINVAL;
+
 	devnum = ir->devnum;
 	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
 
@@ -273,7 +277,7 @@ static int unregister_from_lirc(struct irctl *ir)
 	kfree(p->rbuf);
 	kfree(p);
 	kfree(ir);
-        ir->p = NULL;
+	ir->p = NULL;
 	return SUCCESS;
 }
 
@@ -290,9 +294,7 @@ static int set_use_inc(void *data)
 	MOD_INC_USE_COUNT;
 
 	if (!ir->usbdev)
-	{
 		return -ENODEV;
-	}
 
 	return SUCCESS;
 }
@@ -311,49 +313,50 @@ static void set_use_dec(void *data)
 }
 
 
-/** 
+/**
  * Called in user context.
  * return 0 if data was added to the buffer and
  * -ENODATA if none was available. This should add some number of bits
  * evenly divisible by code_length to the buffer
 **/
-static int usb_remote_poll(void* data, struct lirc_buffer* buf)
+static int usb_remote_poll(void *data, struct lirc_buffer *buf)
 {
 	int ret;
 	struct irctl *ir = (struct irctl *)data;
 
-	if(!ir->usbdev)  /* Has the device been removed? */
+	if (!ir->usbdev)  /* Has the device been removed? */
 		return -ENODEV;
 
 	memset(ir->buf_in, 0, ir->len_in);
-  
-	if((ret = usb_control_msg(
-        	ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
-		GET_INFRACODE, USB_TYPE_VENDOR|USB_DIR_IN,
-		0/* offset */, /*unused*/0, 
-		ir->buf_in, ir->len_in, 
-		/*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) > 0)
-	{
+
+	ret = usb_control_msg(
+	      ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0),
+	      GET_INFRACODE, USB_TYPE_VENDOR|USB_DIR_IN,
+	      0/* offset */, /*unused*/0,
+	      ir->buf_in, ir->len_in,
+	      /*timeout*/HZ * USB_CTRL_GET_TIMEOUT);
+	if (ret > 0) {
 		int i = DEVICE_HEADERLEN;
-		lirc_t code,timediff;
-                struct timeval now;
+		lirc_t code, timediff;
+		struct timeval now;
 
-		if(ret <= 1)  /* ACK packet has 1 byte --> ignore */
+		if (ret <= 1)  /* ACK packet has 1 byte --> ignore */
 			return -ENODATA;
 
-		dprintk(DRIVER_NAME ": Got %d bytes. Header: %02x %02x %02x\n", 
-                	ret, ir->buf_in[0], ir->buf_in[1], ir->buf_in[2]);
-      
-		if(ir->buf_in[2] != 0) {
-			printk(DRIVER_NAME "[%d]: Device buffer overrun.\n", 
-                        	ir->devnum);
-			i = DEVICE_HEADERLEN + ir->buf_in[2];  /* start at earliest byte */
+		dprintk(DRIVER_NAME ": Got %d bytes. Header: %02x %02x %02x\n",
+			ret, ir->buf_in[0], ir->buf_in[1], ir->buf_in[2]);
+
+		if (ir->buf_in[2] != 0) {
+			printk(DRIVER_NAME "[%d]: Device buffer overrun.\n",
+				ir->devnum);
+			/* start at earliest byte */
+			i = DEVICE_HEADERLEN + ir->buf_in[2];
 			/* where are we now? space, gap or pulse? */
 		}
-      
+
 		do_gettimeofday(&now);
 		timediff = now.tv_sec - ir->last_time.tv_sec;
-		if(timediff+1 > PULSE_MASK/1000000)
+		if (timediff + 1 > PULSE_MASK / 1000000)
 			timediff = PULSE_MASK;
 		else {
 			timediff *= 1000000;
@@ -364,39 +367,37 @@ static int usb_remote_poll(void* data, struct lirc_buffer* buf)
 
 		/* create leading gap  */
 		code = timediff;
-  		lirc_buffer_write_n(buf, (unsigned char*)&code, 1);
+		lirc_buffer_write_n(buf, (unsigned char *)&code, 1);
 		ir->in_space = 1;   /* next comes a pulse */
 
 		/* MODE2: pulse/space (PULSE_BIT) in 1us units */
 
-		while(i < ret) {
+		while (i < ret) {
 			/* 1 Igor-tick = 85.333333 us */
-			code = (unsigned int)ir->buf_in[i] * 85 
-				+ (unsigned int)ir->buf_in[i]/3;
-			if(ir->in_space)
+			code = (unsigned int)ir->buf_in[i] * 85
+				+ (unsigned int)ir->buf_in[i] / 3;
+			ir->last_time.tv_usec += code;
+			if (ir->in_space)
 				code |= PULSE_BIT;
-			lirc_buffer_write_n(buf, (unsigned char*)&code, 1);  
+			lirc_buffer_write_n(buf, (unsigned char *)&code, 1);
 			/* 1 chunk = CODE_LENGTH bytes */
 			ir->in_space ^= 1;
-			++ i;
+			++i;
 		}
 
-		if((ret = usb_control_msg(
-                	ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
-			SET_INFRABUFFER_EMPTY, USB_TYPE_VENDOR|USB_DIR_IN,
-			/*unused*/0, /*unused*/0, 
-			/*dummy*/ir->buf_in, /*dummy*/ir->len_in, 
-                        /*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) < 0)
-		{
-			printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: error %d\n", 
-				ir->devnum, ret);
-		}
+		ret = usb_control_msg(
+		      ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0),
+		      SET_INFRABUFFER_EMPTY, USB_TYPE_VENDOR|USB_DIR_IN,
+		      /*unused*/0, /*unused*/0,
+		      /*dummy*/ir->buf_in, /*dummy*/ir->len_in,
+		      /*timeout*/HZ * USB_CTRL_GET_TIMEOUT);
+		if (ret < 0)
+			printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: "
+			       "error %d\n", ir->devnum, ret);
 		return SUCCESS;
-	}
-	else {
-		printk(DRIVER_NAME "[%d]: GET_INFRACODE: error %d\n", 
-                	ir->devnum, ret);
-	}
+	} else
+		printk(DRIVER_NAME "[%d]: GET_INFRACODE: error %d\n",
+			ir->devnum, ret);
 
 	return -ENODATA;
 }
@@ -423,7 +424,7 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	struct lirc_buffer *rbuf = NULL;
 	int devnum, pipe, maxp, bytes_in_key;
 	int minor = 0;
-	char buf[63], name[128]="";
+	char buf[63], name[128] = "";
 	int mem_failure = 0;
 	int ret;
 
@@ -441,9 +442,10 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	if (idesc->desc.bNumEndpoints != 1)
 		return -ENODEV;
 	ep_ctl2 = idesc->endpoint;
-	if (((ep_ctl2->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
-		|| (ep_ctl2->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
-		!= USB_ENDPOINT_XFER_CONTROL)
+	if (((ep_ctl2->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+	    != USB_DIR_IN)
+	    || (ep_ctl2->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	    != USB_ENDPOINT_XFER_CONTROL)
 		return -ENODEV;
 	pipe = usb_rcvctrlpipe(dev, ep_ctl2->desc.bEndpointAddress);
 #else
@@ -452,9 +454,10 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	if (idesc->bNumEndpoints != 1)
 		return NULL;
 	ep_ctl2 = idesc->endpoint;
-	if (((ep_ctl2->bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
-		|| (ep_ctl2->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
-		!= USB_ENDPOINT_XFER_CONTROL)
+	if (((ep_ctl2->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+	    != USB_DIR_IN)
+	    || (ep_ctl2->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	    != USB_ENDPOINT_XFER_CONTROL)
 		return NULL;
 	pipe = usb_rcvctrlpipe(dev, ep_ctl2->bEndpointAddress);
 #endif
@@ -469,62 +472,77 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 
 	/* allocate kernel memory */
 	mem_failure = 0;
-	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+	ir = kmalloc(sizeof(struct irctl), GFP_KERNEL);
+	if (!ir) {
 		mem_failure = 1;
-	} else {
-		memset(ir, 0, sizeof(struct irctl));
-
-		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
-			mem_failure = 2;
-		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
-			mem_failure = 3;
-		} else if (lirc_buffer_init(rbuf, bytes_in_key, 
-                		DEVICE_BUFLEN+ADDITIONAL_LIRC_BYTES)) {
-			mem_failure = 4;
+		goto mem_failure_switch;
+	}
+
+	memset(ir, 0, sizeof(struct irctl));
+
+	plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL);
+	if (!plugin) {
+		mem_failure = 2;
+		goto mem_failure_switch;
+	}
+
+	rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+	if (!rbuf) {
+		mem_failure = 3;
+		goto mem_failure_switch;
+	}
+
+	if (lirc_buffer_init(rbuf, bytes_in_key,
+			DEVICE_BUFLEN+ADDITIONAL_LIRC_BYTES)) {
+		mem_failure = 4;
+		goto mem_failure_switch;
+	}
+
 #if defined(KERNEL_2_5)
-		} else if (!(ir->buf_in = usb_buffer_alloc(dev, 
-				DEVICE_BUFLEN+DEVICE_HEADERLEN, 
-                                GFP_ATOMIC, &ir->dma_in))) {
-			mem_failure = 5;
+	ir->buf_in = usb_buffer_alloc(dev,
+			      DEVICE_BUFLEN+DEVICE_HEADERLEN,
+			      GFP_ATOMIC, &ir->dma_in);
 #else
-		} else if (!(ir->buf_in = kmalloc(
-				DEVICE_BUFLEN+DEVICE_HEADERLEN, GFP_KERNEL))) {
-			mem_failure = 5;
+	ir->buf_in = kmalloc(DEVICE_BUFLEN+DEVICE_HEADERLEN,
+			     GFP_KERNEL);
 #endif
-		} else {
-
-			memset(plugin, 0, sizeof(struct lirc_plugin));
-
-			strcpy(plugin->name, DRIVER_NAME " ");
-			plugin->minor = -1;
-			plugin->code_length = bytes_in_key*8; /* in bits */
-			plugin->features = LIRC_CAN_REC_MODE2;
-			plugin->data = ir;
-			plugin->rbuf = rbuf;
-			plugin->set_use_inc = &set_use_inc;
-			plugin->set_use_dec = &set_use_dec;
-			plugin->sample_rate = SAMPLE_RATE;    /* per second */
-			plugin->add_to_buf = &usb_remote_poll;
+	if (!ir->buf_in) {
+		mem_failure = 5;
+		goto mem_failure_switch;
+	}
+
+	memset(plugin, 0, sizeof(struct lirc_plugin));
+
+	strcpy(plugin->name, DRIVER_NAME " ");
+	plugin->minor = -1;
+	plugin->code_length = bytes_in_key*8; /* in bits */
+	plugin->features = LIRC_CAN_REC_MODE2;
+	plugin->data = ir;
+	plugin->rbuf = rbuf;
+	plugin->set_use_inc = &set_use_inc;
+	plugin->set_use_dec = &set_use_dec;
+	plugin->sample_rate = sample_rate;    /* per second */
+	plugin->add_to_buf = &usb_remote_poll;
 #ifdef LIRC_HAVE_SYSFS
-			plugin->dev = &dev->dev;
+	plugin->dev = &dev->dev;
 #endif
-			plugin->owner = THIS_MODULE;
+	plugin->owner = THIS_MODULE;
 
-			init_MUTEX(&ir->lock);
-			init_waitqueue_head(&ir->wait_out);
+	init_MUTEX(&ir->lock);
+	init_waitqueue_head(&ir->wait_out);
 
-			if ((minor = lirc_register_plugin(plugin)) < 0) {
-				mem_failure = 9;
-			}
-		}
-	}
+	minor = lirc_register_plugin(plugin);
+	if (minor < 0)
+		mem_failure = 9;
+
+mem_failure_switch:
 
 	/* free allocated memory in case of failure */
 	switch (mem_failure) {
 	case 9:
 #if defined(KERNEL_2_5)
-		usb_buffer_free(dev, DEVICE_BUFLEN+DEVICE_HEADERLEN, 
-                	ir->buf_in, ir->dma_in);
+		usb_buffer_free(dev, DEVICE_BUFLEN+DEVICE_HEADERLEN,
+			ir->buf_in, ir->dma_in);
 #else
 		kfree(ir->buf_in);
 #endif
@@ -564,15 +582,14 @@ static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
 	       dev->bus->busnum, devnum);
 
 	/* clear device buffer */
-	if ((ret = usb_control_msg(ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0), 
+	ret = usb_control_msg(ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0),
 		SET_INFRABUFFER_EMPTY, USB_TYPE_VENDOR|USB_DIR_IN,
-		/*unused*/0, /*unused*/0, 
-		/*dummy*/ir->buf_in, /*dummy*/ir->len_in, 
-		/*timeout*/HZ * USB_CTRL_GET_TIMEOUT)) < 0)
-	{
-		printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: error %d\n", 
+		/*unused*/0, /*unused*/0,
+		/*dummy*/ir->buf_in, /*dummy*/ir->len_in,
+		/*timeout*/HZ * USB_CTRL_GET_TIMEOUT);
+	if (ret < 0)
+		printk(DRIVER_NAME "[%d]: SET_INFRABUFFER_EMPTY: error %d\n",
 			devnum, ret);
-	}
 
 #if defined(KERNEL_2_5)
 	usb_set_intfdata(intf, ir);
@@ -613,8 +630,11 @@ static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
 }
 
 static struct usb_device_id usb_remote_id_table [] = {
-	{ USB_DEVICE(0x03eb, 0x0002) },	/* Igor Plug USB (Atmel's Manufact. ID) */
-	{ }				/* Terminating entry */
+	/* Igor Plug USB (Atmel's Manufact. ID) */
+	{ USB_DEVICE(0x03eb, 0x0002) },
+
+	/* Terminating entry */
+	{ }
 };
 
 static struct usb_driver usb_remote_driver = {
@@ -629,13 +649,15 @@ static int __init usb_remote_init(void)
 {
 	int i;
 
-	printk("\n" DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
+	printk(KERN_INFO "\n"
+	       DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
 	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
 	dprintk(DRIVER_NAME ": debug mode enabled\n");
 
 	request_module("lirc_dev");
 
-	if ((i = usb_register(&usb_remote_driver)) < 0) {
+	i = usb_register(&usb_remote_driver);
+	if (i < 0) {
 		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
 		return -ENODEV;
 	}
@@ -661,6 +683,9 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(usb, usb_remote_id_table);
 
+module_param(sample_rate, int, 0644);
+MODULE_PARM_DESC(sample_rate, "Sampling rate in Hz (default: 100)");
+
 EXPORT_NO_SYMBOLS;
 
 /*
diff --git a/drivers/char/lirc/lirc_imon.c b/drivers/char/lirc/lirc_imon.c
index 81b6806..5e278e5 100644
--- a/drivers/char/lirc/lirc_imon.c
+++ b/drivers/char/lirc/lirc_imon.c
@@ -1,37 +1,37 @@
 /*
  *   lirc_imon.c:  LIRC plugin/VFD driver for Ahanix/Soundgraph IMON IR/VFD
  *
- *   $Id: lirc_imon.c,v 1.19 2007/04/29 14:23:04 lirc Exp $
+ *   $Id: lirc_imon.c,v 1.23 2008/01/19 10:06:46 lirc Exp $
  *
- *   Version 0.3 
- *   		Supports newer iMON models that send decoded IR signals.
- *   			This includes the iMON PAD model.
- *   		Removed module option for vfd_proto_6p. This driver supports
- *   			multiple iMON devices so it is meaningless to have
- *   			a global option to set protocol variants.
+ *   Version 0.3
+ *		Supports newer iMON models that send decoded IR signals.
+ *			This includes the iMON PAD model.
+ *		Removed module option for vfd_proto_6p. This driver supports
+ *			multiple iMON devices so it is meaningless to have
+ *			a global option to set protocol variants.
  *
  *   Version 0.2 beta 2 [January 31, 2005]
  *		USB disconnect/reconnect no longer causes problems for lircd
- *   
+ *
  *   Version 0.2 beta 1 [January 29, 2005]
- *		Added support for original iMON receiver (ext USB)
- *   
+ *		Added support for original iMON receiver(ext USB)
+ *
  *   Version 0.2 alpha 2 [January 24, 2005]
- *   		Added support for VFDs with 6-packet protocol
+ *		Added support for VFDs with 6-packet protocol
  *
  *   Version 0.2 alpha 1 [January 23, 2005]
- *   		Added support for 2.6 kernels
- *   		Reworked disconnect handling
- *   		Incorporated Changwoo Ryu's algorithm
+ *		Added support for 2.6 kernels
+ *		Reworked disconnect handling
+ *		Incorporated Changwoo Ryu's algorithm
+ *
+ *   Version 0.1 alpha 1[July 5, 2004]
  *
- *   Version 0.1 alpha 1 [July 5, 2004]
+ *   Copyright(C) 2004  Venky Raju(dev@venky.ws)
  *
- *   Copyright (C) 2004  Venky Raju (dev@venky.ws)
- *   
  *   lirc_imon is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
+ *  (at your option) any later version.
  *
  *   This program is distributed in the hope that it will be useful,
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -45,7 +45,11 @@
  */
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 22)
 #error "*** Sorry, this driver requires kernel version 2.4.22 or higher"
 #endif
 
@@ -56,27 +60,32 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
 #include <linux/usb.h>
 
-#include <linux/lirc.h>
 #include "kcompat.h"
+#include <linux/lirc.h>
 #include "lirc_dev.h"
 
 
 #define MOD_AUTHOR	"Venky Raju <dev@venky.ws>"
-#define MOD_DESC	"Driver for Soundgraph iMON MultiMedian IR/VFD"
+#define MOD_DESC	"Driver for Soundgraph iMON MultiMedia IR/VFD"
 #define MOD_NAME	"lirc_imon"
 #define MOD_VERSION	"0.3"
 
 #define VFD_MINOR_BASE	144	/* Same as LCD */
-#define DEVFS_MODE	S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
+#define DEVFS_MODE	(S_IFCHR | S_IRUSR | S_IWUSR | \
+			 S_IRGRP | S_IWGRP | S_IROTH)
 #define DEVFS_NAME	LIRC_DEVFS_PREFIX "lcd%d"
 
 #define BUF_CHUNK_SIZE	4
 #define BUF_SIZE	128
 
-#define BIT_DURATION	250 	/* each bit received is 250us */
+#define BIT_DURATION	250	/* each bit received is 250us */
 
 #define SUCCESS		0
 #define	TRUE		1
@@ -84,96 +93,97 @@
 
 
 /* ------------------------------------------------------------
- *                     P R O T O T Y P E S
+ *		     P R O T O T Y P E S
  * ------------------------------------------------------------
  */
 
 /* USB Callback prototypes */
 #ifdef KERNEL_2_5
-static int imon_probe (struct usb_interface *interface,
-			const struct usb_device_id *id);
-static void imon_disconnect (struct usb_interface *interface);
+static int imon_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id);
+static void imon_disconnect(struct usb_interface *interface);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_rx_callback (struct urb *urb, struct pt_regs *regs);
-static void usb_tx_callback (struct urb *urb, struct pt_regs *regs);
+static void usb_rx_callback(struct urb *urb, struct pt_regs *regs);
+static void usb_tx_callback(struct urb *urb, struct pt_regs *regs);
 #else
-static void usb_rx_callback (struct urb *urb);
-static void usb_tx_callback (struct urb *urb);
+static void usb_rx_callback(struct urb *urb);
+static void usb_tx_callback(struct urb *urb);
 #endif
 #else
-static void * imon_probe (struct usb_device * dev, unsigned int intf,
+static void *imon_probe(struct usb_device *dev, unsigned int intf,
 				const struct usb_device_id *id);
-static void imon_disconnect (struct usb_device *dev, void *data);
-static void usb_rx_callback (struct urb *urb);
-static void usb_tx_callback (struct urb *urb);
+static void imon_disconnect(struct usb_device *dev, void *data);
+static void usb_rx_callback(struct urb *urb);
+static void usb_tx_callback(struct urb *urb);
 #endif
 
 /* VFD file_operations function prototypes */
-static int vfd_open (struct inode *inode, struct file *file);
-static int vfd_close (struct inode *inode, struct file *file);
-static ssize_t vfd_write (struct file *file, const char *buf,
+static int vfd_open(struct inode *inode, struct file *file);
+static int vfd_close(struct inode *inode, struct file *file);
+static ssize_t vfd_write(struct file *file, const char *buf,
+				size_t n_bytes, loff_t *pos);
+
+/* LCD file_operations override function prototypes */
+static ssize_t lcd_write(struct file *file, const char *buf,
 				size_t n_bytes, loff_t *pos);
 
 /* LIRC plugin function prototypes */
-static int ir_open (void *data);
-static void ir_close (void *data);
+static int ir_open(void *data);
+static void ir_close(void *data);
 
 /* Driver init/exit prototypes */
-static int __init imon_init (void);
-static void __exit imon_exit (void);
+static int __init imon_init(void);
+static void __exit imon_exit(void);
 
 /* ------------------------------------------------------------
- *                     G L O B A L S
+ *		     G L O B A L S
  * ------------------------------------------------------------
  */
 
 struct imon_context {
-
 	struct usb_device *dev;
-	int vfd_supported;		/* not all controllers do         */
-	int vfd_isopen;			/* VFD port has been opened       */
-#if !defined (KERNEL_2_5)
-	int subminor;			/* index into minor_table         */
+	int vfd_supported;		/* not all controllers do */
+	int vfd_isopen;			/* VFD port has been opened */
+#if !defined(KERNEL_2_5)
+	int subminor;			/* index into minor_table */
 	devfs_handle_t devfs;
 #endif
-	int ir_isopen;			/* IR port has been opened        */
-	int ir_isassociating;		/* IR port has been opened for association */
-	int dev_present;		/* USB device presence            */
-	struct semaphore sem;		/* to lock this object            */
+	int ir_isopen;			/* IR port open	*/
+	int ir_isassociating;		/* IR port open for association */
+	int dev_present;		/* USB device presence */
+	struct semaphore sem;		/* to lock this object */
 	wait_queue_head_t remove_ok;	/* For unexpected USB disconnects */
 
-	int vfd_proto_6p;		/* VFD requires 6th packet        */
-	int ir_onboard_decode;		/* IR signals decoded onboard     */
+	int vfd_proto_6p;		/* VFD requires 6th packet */
+	int ir_onboard_decode;		/* IR signals decoded onboard */
 
 	struct lirc_plugin *plugin;
 	struct usb_endpoint_descriptor *rx_endpoint;
 	struct usb_endpoint_descriptor *tx_endpoint;
 	struct urb *rx_urb;
 	struct urb *tx_urb;
-	unsigned char usb_rx_buf [8];
-	unsigned char usb_tx_buf [8];
+	unsigned char usb_rx_buf[8];
+	unsigned char usb_tx_buf[8];
 
 	struct rx_data {
-		int count;		/* length of 0 or 1 sequence      */
-		int prev_bit;		/* logic level of sequence        */
-		int initial_space;	/* initial space flag             */
-
+		int count;		/* length of 0 or 1 sequence */
+		int prev_bit;		/* logic level of sequence */
+		int initial_space;	/* initial space flag */
 	} rx;
 
 	struct tx_t {
-		unsigned char data_buf [35]; /* user data buffer          */
-		struct completion finished;  /* wait for write to finish  */
-		atomic_t busy;		     /* write in progress         */
-		int status;		     /* status of tx completion   */
+		unsigned char data_buf[35];	/* user data buffer */
+		struct completion finished;	/* wait for write to finish */
+		atomic_t busy;			/* write in progress */
+		int status;			/* status of tx completion */
 	} tx;
 };
 
-#define LOCK_CONTEXT	down (&context ->sem)
-#define UNLOCK_CONTEXT	up (&context ->sem)
+#define LOCK_CONTEXT	down(&context->sem)
+#define UNLOCK_CONTEXT	up(&context->sem)
 
 /* VFD file operations */
 static struct file_operations vfd_fops = {
-
 	.owner		= THIS_MODULE,
 	.open		= &vfd_open,
 	.write		= &vfd_write,
@@ -181,7 +191,7 @@ static struct file_operations vfd_fops = {
 };
 
 /* USB Device ID for IMON USB Control Board */
-static struct usb_device_id imon_usb_id_table [] = {
+static struct usb_device_id imon_usb_id_table[] = {
 	{ USB_DEVICE(0x0aa8, 0xffda) },		/* IR & VFD    */
 	{ USB_DEVICE(0x0aa8, 0x8001) },		/* IR only     */
 	{ USB_DEVICE(0x15c2, 0xffda) },		/* IR & VFD    */
@@ -191,15 +201,15 @@ static struct usb_device_id imon_usb_id_table [] = {
 };
 
 /* Some iMON VFD models requires a 6th packet */
-static unsigned short vfd_proto_6p_vendor_list [] = {
+static unsigned short vfd_proto_6p_vendor_list[] = {
 			/* terminate this list with a 0 */
 			0x15c2,
 			0 };
-static unsigned char vfd_packet6 [] = {
+static unsigned char vfd_packet6[] = {
 		0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };
 
 /* Newer iMON models decode the signal onboard */
-static unsigned short ir_onboard_decode_product_list [] = {
+static unsigned short ir_onboard_decode_product_list[] = {
 			/* terminate this list with a 0 */
 			0xffdc,
 			0 };
@@ -207,10 +217,10 @@ static unsigned short ir_onboard_decode_product_list [] = {
 /* USB Device data */
 static struct usb_driver imon_driver = {
 	LIRC_THIS_MODULE(.owner = THIS_MODULE)
-	.name 		= MOD_NAME,
-	.probe 		= imon_probe,
-	.disconnect 	= imon_disconnect,
-	.id_table 	= imon_usb_id_table,
+	.name		= MOD_NAME,
+	.probe		= imon_probe,
+	.disconnect	= imon_disconnect,
+	.id_table	= imon_usb_id_table,
 #if !defined(KERNEL_2_5)
 	.fops		= &vfd_fops,
 	.minor		= VFD_MINOR_BASE,
@@ -219,7 +229,7 @@ static struct usb_driver imon_driver = {
 
 #ifdef KERNEL_2_5
 static struct usb_class_driver imon_class = {
-	.name 		= DEVFS_NAME,
+	.name		= DEVFS_NAME,
 	.fops		= &vfd_fops,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 	.mode		= DEVFS_MODE,
@@ -229,19 +239,24 @@ static struct usb_class_driver imon_class = {
 #endif
 
 /* to prevent races between open() and disconnect() */
-static DECLARE_MUTEX (disconnect_sem);
+static DECLARE_MUTEX(disconnect_sem);
 
-static int debug = 0;
+static int debug;
+#ifdef LIRC_IMON_LCD
+static int is_lcd = 1;
+#else
+static int is_lcd; /* If LIRC_IMON_LCD not defined, default to non-LCD */
+#endif
 
 #if !defined(KERNEL_2_5)
 
 #define MAX_DEVICES	4	/* In case there's more than one iMON device */
-static struct imon_context * minor_table [MAX_DEVICES];
+static struct imon_context *minor_table[MAX_DEVICES];
 
 /*
-static DECLARE_MUTEX (minor_table_sem);
-#define LOCK_MINOR_TABLE	down (&minor_table_sem)
-#define UNLOCK_MINOR_TABLE	up (&minor_table_sem)
+static DECLARE_MUTEX(minor_table_sem);
+#define LOCK_MINOR_TABLE	down(&minor_table_sem)
+#define UNLOCK_MINOR_TABLE	up(&minor_table_sem)
 */
 
 /* the global usb devfs handle */
@@ -250,50 +265,61 @@ extern devfs_handle_t usb_devfs_handle;
 #endif
 
 /* ------------------------------------------------------------
- *                     M O D U L E   C O D E
+ *		     M O D U L E   C O D E
  * ------------------------------------------------------------
  */
 
-MODULE_AUTHOR (MOD_AUTHOR);
-MODULE_DESCRIPTION (MOD_DESC);
-MODULE_LICENSE ("GPL");
-MODULE_DEVICE_TABLE (usb, imon_usb_id_table);
-module_param (debug, int, 0);
-MODULE_PARM_DESC (debug, "Debug messages: 0=no, 1=yes (default: no)");
+MODULE_AUTHOR(MOD_AUTHOR);
+MODULE_DESCRIPTION(MOD_DESC);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, imon_usb_id_table);
 
-static inline void delete_context (struct imon_context *context) {
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug messages: 0=no, 1=yes(default: no)");
 
-	if (context ->vfd_supported)
-		usb_free_urb (context ->tx_urb);
-	usb_free_urb (context ->rx_urb);
-	lirc_buffer_free (context ->plugin ->rbuf);
-	kfree (context ->plugin ->rbuf);
-	kfree (context ->plugin);
-	kfree (context);
+#ifdef LIRC_IMON_LCD
+module_param(is_lcd, int, 1);
+MODULE_PARM_DESC(is_lcd, "The device is an LCD: 0=no (it's a VFD), "
+		 "1=yes (default:yes)");
+#else
+module_param(is_lcd, int, 0);
+MODULE_PARM_DESC(is_lcd, "The device is an LCD: 0=no (it's a VFD), "
+		 "1=yes (default:no)");
+#endif
 
-	if (debug) info ("%s: context deleted", __FUNCTION__);
+static inline void delete_context(struct imon_context *context)
+{
+	if (context->vfd_supported)
+		usb_free_urb(context->tx_urb);
+	usb_free_urb(context->rx_urb);
+	lirc_buffer_free(context->plugin->rbuf);
+	kfree(context->plugin->rbuf);
+	kfree(context->plugin);
+	kfree(context);
+
+	if (debug)
+		info("%s: context deleted", __FUNCTION__);
 }
 
-static inline void deregister_from_lirc (struct imon_context *context) {
-
+static inline void deregister_from_lirc(struct imon_context *context)
+{
 	int retval;
-	int minor = context ->plugin ->minor;
-
-	if ((retval = lirc_unregister_plugin (minor))) {
+	int minor = context->plugin->minor;
 
-		err ("%s: unable to deregister from lirc (%d)", 
+	retval = lirc_unregister_plugin(minor);
+	if (retval)
+		err("%s: unable to deregister from lirc(%d)",
 			__FUNCTION__, retval);
-	}
 	else
-		info ("Deregistered iMON plugin (minor:%d)", minor);
+		info("Deregistered iMON plugin(minor:%d)", minor);
 
 }
 
 /**
- * Called when the VFD device (e.g. /dev/usb/lcd)
+ * Called when the VFD device(e.g. /dev/usb/lcd)
  * is opened by the application.
  */
-static int vfd_open (struct inode *inode, struct file *file)
+static int vfd_open(struct inode *inode, struct file *file)
 {
 #ifdef KERNEL_2_5
 	struct usb_interface *interface;
@@ -303,29 +329,30 @@ static int vfd_open (struct inode *inode, struct file *file)
 	int retval = SUCCESS;
 
 	/* prevent races with disconnect */
-	down (&disconnect_sem);
-	
+	down(&disconnect_sem);
+
 #ifdef KERNEL_2_5
-	subminor = iminor (inode);
-	interface = usb_find_interface (&imon_driver, subminor);
+	subminor = iminor(inode);
+	interface = usb_find_interface(&imon_driver, subminor);
 	if (!interface) {
-		err ("%s: could not find interface for minor %d", __FUNCTION__, subminor);
+		err("%s: could not find interface for minor %d",
+		    __FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
 	}
-	context = usb_get_intfdata (interface);
+	context = usb_get_intfdata(interface);
 #else
-	subminor = MINOR (inode ->i_rdev) - VFD_MINOR_BASE;
+	subminor = MINOR(inode->i_rdev) - VFD_MINOR_BASE;
 	if (subminor < 0 || subminor >= MAX_DEVICES) {
-		err ("%s: no record of minor %d", __FUNCTION__, subminor);
+		err("%s: no record of minor %d", __FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
 	}
-	context = minor_table [subminor];
+	context = minor_table[subminor];
 #endif
 
 	if (!context) {
-		err ("%s: no context found for minor %d", 
+		err("%s: no context found for minor %d",
 					__FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
@@ -333,65 +360,60 @@ static int vfd_open (struct inode *inode, struct file *file)
 
 	LOCK_CONTEXT;
 
-	if (!context ->vfd_supported) {
-		err ("%s: VFD not supported by device", __FUNCTION__);
+	if (!context->vfd_supported) {
+		err("%s: VFD not supported by device", __FUNCTION__);
 		retval = -ENODEV;
-	}
-	else if (context ->vfd_isopen) {
-		
-		err ("%s: VFD port is already open", __FUNCTION__);
+	} else if (context->vfd_isopen) {
+		err("%s: VFD port is already open", __FUNCTION__);
 		retval = -EBUSY;
-	}
-	else {
+	} else {
 		MOD_INC_USE_COUNT;
-		context ->vfd_isopen = TRUE;
-		file ->private_data = context;
-		info ("VFD port opened");
+		context->vfd_isopen = TRUE;
+		file->private_data = context;
+		info("VFD port opened");
 	}
 
 	UNLOCK_CONTEXT;
 
 exit:
-	up (&disconnect_sem);
+	up(&disconnect_sem);
 	return retval;
 }
 
 /**
- * Called when the VFD device (e.g. /dev/usb/lcd)
+ * Called when the VFD device(e.g. /dev/usb/lcd)
  * is closed by the application.
  */
-static int vfd_close (struct inode *inode, struct file *file)
+static int vfd_close(struct inode *inode, struct file *file)
 {
 	struct imon_context *context = NULL;
 	int retval = SUCCESS;
 
-	context = (struct imon_context *) file ->private_data;
+	context = (struct imon_context *) file->private_data;
 
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
-	if (!context ->vfd_supported) {
-		err ("%s: VFD not supported by device", __FUNCTION__);
+	if (!context->vfd_supported) {
+		err("%s: VFD not supported by device", __FUNCTION__);
 		retval = -ENODEV;
-	}
-	else if (!context ->vfd_isopen) {
-		err ("%s: VFD is not open", __FUNCTION__);
+	} else if (!context->vfd_isopen) {
+		err("%s: VFD is not open", __FUNCTION__);
 		retval = -EIO;
-	}
-	else {
-		context ->vfd_isopen = FALSE;
+	} else {
+		context->vfd_isopen = FALSE;
 		MOD_DEC_USE_COUNT;
-		info ("VFD port closed");
-		if (!context ->dev_present && !context ->ir_isopen) {
-
-			/* Device disconnected before close and IR port is not open.  */
-			/* If IR port is open, context will be deleted by ir_close.   */
+		info("VFD port closed");
+		if (!context->dev_present && !context->ir_isopen) {
+			/* Device disconnected before close and IR port is not
+			 * open. If IR port is open, context will be deleted by
+			 * ir_close. */
 			UNLOCK_CONTEXT;
-			delete_context (context);
+			delete_context(context);
 			return retval;
 		}
 	}
@@ -403,45 +425,44 @@ static int vfd_close (struct inode *inode, struct file *file)
 /**
  * Sends a packet to the VFD.
  */
-static inline int send_packet (struct imon_context *context)
+static inline int send_packet(struct imon_context *context)
 {
 	unsigned int pipe;
 	int interval = 0;
 	int retval = SUCCESS;
 
-	pipe = usb_sndintpipe (context ->dev,
-			context-> tx_endpoint ->bEndpointAddress);
+	pipe = usb_sndintpipe(context->dev,
+			context->tx_endpoint->bEndpointAddress);
 #ifdef KERNEL_2_5
-	interval = context ->tx_endpoint ->bInterval;
+	interval = context->tx_endpoint->bInterval;
 #endif	/* Use 0 for 2.4 kernels */
 
-	usb_fill_int_urb (context ->tx_urb, context ->dev, pipe,
-		context ->usb_tx_buf, sizeof (context ->usb_tx_buf),
+	usb_fill_int_urb(context->tx_urb, context->dev, pipe,
+		context->usb_tx_buf, sizeof(context->usb_tx_buf),
 		usb_tx_callback, context, interval);
 
-	context ->tx_urb ->actual_length = 0;
+	context->tx_urb->actual_length = 0;
 
-	init_completion (&context ->tx.finished);
-	atomic_set (&(context ->tx.busy), 1);
+	init_completion(&context->tx.finished);
+	atomic_set(&(context->tx.busy), 1);
 
 #ifdef KERNEL_2_5
-	retval =  usb_submit_urb (context ->tx_urb, GFP_KERNEL);
+	retval =  usb_submit_urb(context->tx_urb, GFP_KERNEL);
 #else
-	retval =  usb_submit_urb (context ->tx_urb);
+	retval =  usb_submit_urb(context->tx_urb);
 #endif
 	if (retval != SUCCESS) {
-		atomic_set (&(context ->tx.busy), 0);
-		err ("%s: error submitting urb (%d)", __FUNCTION__, retval);
-	}
-	else {
-		/* Wait for tranmission to complete (or abort) */
+		atomic_set(&(context->tx.busy), 0);
+		err("%s: error submitting urb(%d)", __FUNCTION__, retval);
+	} else {
+		/* Wait for tranmission to complete(or abort) */
 		UNLOCK_CONTEXT;
-		wait_for_completion (&context ->tx.finished);
+		wait_for_completion(&context->tx.finished);
 		LOCK_CONTEXT;
 
-		retval = context ->tx.status;
+		retval = context->tx.status;
 		if (retval != SUCCESS)
-			err ("%s: packet tx failed (%d)", __FUNCTION__, retval);
+			err("%s: packet tx failed(%d)", __FUNCTION__, retval);
 	}
 
 	return retval;
@@ -453,30 +474,30 @@ static inline int send_packet (struct imon_context *context)
  * This might not be such a good idea, since it has an id
  * collition with some versions of the "IR & VFD" combo.
  * The only way to determine if it is a RF version is to look
- * at the product description string. (Which we currently do
+ * at the product description string.(Which we currently do
  * not fetch).
  */
-static inline int send_associate_24g (struct imon_context *context)
+static inline int send_associate_24g(struct imon_context *context)
 {
 	int retval;
 	const unsigned char packet[8] = { 0x01, 0x00, 0x00, 0x00,
 					  0x00, 0x00, 0x00, 0x20 };
 
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
-	if (!context ->dev_present) {
-		err ("%s: no iMON device present", __FUNCTION__);
+	if (!context->dev_present) {
+		err("%s: no iMON device present", __FUNCTION__);
 		retval = -ENODEV;
 		goto exit;
 	}
 
-	memcpy (context ->usb_tx_buf, packet, sizeof(packet));
-	retval = send_packet (context);
+	memcpy(context->usb_tx_buf, packet, sizeof(packet));
+	retval = send_packet(context);
 
 exit:
 	UNLOCK_CONTEXT;
@@ -491,49 +512,53 @@ exit:
  *
  */
 
-static ssize_t show_associate_remote (struct device *d, struct device_attribute *attr,
-			       char *buf)
+static ssize_t show_associate_remote(struct device *d,
+				     struct device_attribute *attr,
+				     char *buf)
 {
-	struct imon_context *context = dev_get_drvdata (d);
+	struct imon_context *context = dev_get_drvdata(d);
 
 	if (!context)
 		return -ENODEV;
 
-	if (context ->ir_isassociating) {
-		strcpy(buf, "The device it associating press some button on the remote.\n");
-	}
-	else if (context ->ir_isopen) {
+	if (context->ir_isassociating) {
+		strcpy(buf, "The device it associating press some button "
+			    "on the remote.\n");
+	} else if (context->ir_isopen) {
 		strcpy(buf, "Device is open and ready to associate.\n"
-		            "Echo something into this file to start the process.\n");
+			    "Echo something into this file to start "
+			    "the process.\n");
+	} else {
+		strcpy(buf, "Device is closed, you need to open it to "
+			    "associate the remote(you can use irw).\n");
 	}
-	else {
-		strcpy(buf, "Device is closed, you need to open it to associate the remote (you can use irw).\n");
-	}
-	return strlen (buf);
+	return strlen(buf);
 }
 
-static ssize_t store_associate_remote (struct device *d, struct device_attribute *attr,
-				const char *buf, size_t count)
+static ssize_t store_associate_remote(struct device *d,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
 {
 	struct imon_context *context;
-	
-	context = dev_get_drvdata (d);
+
+	context = dev_get_drvdata(d);
 
 	if (!context)
 		return -ENODEV;
 
-	if (! context ->ir_isopen)
+	if (!context->ir_isopen)
 		return -EINVAL;
 
-	if (context ->ir_isopen) {
-		context ->ir_isassociating = TRUE;
-		send_associate_24g (context);
+	if (context->ir_isopen) {
+		context->ir_isassociating = TRUE;
+		send_associate_24g(context);
 	}
 
 	return count;
 }
 
-static DEVICE_ATTR(associate_remote, S_IWUSR | S_IRUGO, show_associate_remote, store_associate_remote);
+static DEVICE_ATTR(associate_remote, S_IWUSR | S_IRUGO, show_associate_remote,
+		   store_associate_remote);
 
 static struct attribute *imon_sysfs_entries[] = {
 	&dev_attr_associate_remote.attr,
@@ -554,82 +579,138 @@ static struct attribute_group imon_attribute_group = {
  * each packet but the last carrying 7 bytes.
  *
  * I don't know if the VFD board supports features such as
- * scrolling, clearing rows, blanking, etc. so at 
+ * scrolling, clearing rows, blanking, etc. so at
  * the caller must provide a full screen of data.  If fewer
  * than 32 bytes are provided spaces will be appended to
  * generate a full screen.
  */
-static ssize_t vfd_write (struct file *file, const char *buf,
-				size_t n_bytes, loff_t *pos)
+static ssize_t vfd_write(struct file *file, const char *buf,
+			 size_t n_bytes, loff_t *pos)
 {
-
 	int i;
 	int offset;
 	int seq;
 	int retval = SUCCESS;
 	struct imon_context *context;
 
-	context = (struct imon_context *) file ->private_data;
+	context = (struct imon_context *) file->private_data;
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
-	if (!context ->dev_present) {
-		err ("%s: no iMON device present", __FUNCTION__);
+	if (!context->dev_present) {
+		err("%s: no iMON device present", __FUNCTION__);
 		retval = -ENODEV;
 		goto exit;
 	}
 
 	if (n_bytes <= 0 || n_bytes > 32) {
-		err ("%s: invalid payload size", __FUNCTION__);
+		err("%s: invalid payload size", __FUNCTION__);
 		retval = -EINVAL;
 		goto exit;
 	}
 
-	copy_from_user (context ->tx.data_buf, buf, n_bytes);
+	if (copy_from_user(context->tx.data_buf, buf, n_bytes))
+		return -EFAULT;
 
 	/* Pad with spaces */
-	for (i=n_bytes; i < 32; ++i)
-		context ->tx.data_buf [i] = ' ';
-	
-	for (i=32; i < 35; ++i)
-		context ->tx.data_buf [i] = 0xFF;
+	for (i = n_bytes; i < 32; ++i)
+		context->tx.data_buf[i] = ' ';
 
-	offset = seq = 0;
+	for (i = 32; i < 35; ++i)
+		context->tx.data_buf[i] = 0xFF;
 
-	do {
-		memcpy (context ->usb_tx_buf, context ->tx.data_buf + offset, 7);
-		context ->usb_tx_buf [7] = (unsigned char) seq;
+	offset = 0;
+	seq = 0;
 
-		if ((retval = send_packet (context)) != SUCCESS) {
+	do {
+		memcpy(context->usb_tx_buf, context->tx.data_buf + offset, 7);
+		context->usb_tx_buf[7] = (unsigned char) seq;
 
-			err ("%s: send packet failed for packet #%d", 
+		retval = send_packet(context);
+		if (retval != SUCCESS) {
+			err("%s: send packet failed for packet #%d",
 					__FUNCTION__, seq/2);
 			goto exit;
-		}
-		else {
+		} else {
 			seq += 2;
 			offset += 7;
 		}
 
 	} while (offset < 35);
 
-	if (context ->vfd_proto_6p) {
-
+	if (context->vfd_proto_6p) {
 		/* Send packet #6 */
-		memcpy (context ->usb_tx_buf, vfd_packet6, 7);
-		context ->usb_tx_buf [7] = (unsigned char) seq;
-		if ((retval = send_packet (context)) != SUCCESS)
-			err ("%s: send packet failed for packet #%d",
+		memcpy(context->usb_tx_buf, vfd_packet6, 7);
+		context->usb_tx_buf[7] = (unsigned char) seq;
+		retval = send_packet(context);
+		if (retval != SUCCESS)
+			err("%s: send packet failed for packet #%d",
 					__FUNCTION__, seq/2);
 	}
 
 exit:
 	UNLOCK_CONTEXT;
 
+	return(retval == SUCCESS) ? n_bytes : retval;
+}
+
+/**
+ * Writes data to the LCD.  The iMON OEM LCD screen excepts 8-byte
+ * packets. We accept data as 16 hexadecimal digits, followed by a
+ * newline (to make it easy to drive the device from a command-line
+ * -- even though the actual binary data is a bit complicated).
+ *
+ * The device itself is not a "traditional" text-mode display. It's
+ * actually a 16x96 pixel bitmap display. That means if you want to
+ * display text, you've got to have your own "font" and translate the
+ * text into bitmaps for display. This is really flexible (you can
+ * display whatever diacritics you need, and so on), but it's also
+ * a lot more complicated than most LCDs...
+ */
+static ssize_t lcd_write(struct file *file, const char *buf,
+			 size_t n_bytes, loff_t *pos)
+{
+	int retval = SUCCESS;
+	struct imon_context *context;
+
+	context = (struct imon_context *) file->private_data;
+	if (!context) {
+		err("%s: no context for device", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	LOCK_CONTEXT;
+
+	if (!context->dev_present) {
+		err("%s: no iMON device present", __FUNCTION__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	if (n_bytes != 8) {
+		err("%s: invalid payload size: %d (expecting 8)",
+		  __FUNCTION__, (int) n_bytes);
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (copy_from_user(context->usb_tx_buf, buf, 8))
+		return -EFAULT;
+
+	retval = send_packet(context);
+	if (retval != SUCCESS) {
+		err("%s: send packet failed!",
+		  __FUNCTION__);
+		goto exit;
+	} else if (debug) {
+		info("%s: write %d bytes to LCD", __FUNCTION__, (int) n_bytes);
+	}
+exit:
+	UNLOCK_CONTEXT;
 	return (retval == SUCCESS) ? n_bytes : retval;
 }
 
@@ -637,21 +718,24 @@ exit:
  * Callback function for USB core API: transmit data
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_tx_callback (struct urb *urb, struct pt_regs *regs)
+static void usb_tx_callback(struct urb *urb, struct pt_regs *regs)
 #else
-static void usb_tx_callback (struct urb *urb)
+static void usb_tx_callback(struct urb *urb)
 #endif
 {
 	struct imon_context *context;
 
-	if (!urb || !(context = (struct imon_context *) urb->context))
+	if (!urb)
+		return;
+	context = (struct imon_context *) urb->context;
+	if (!context)
 		return;
 
-	context ->tx.status = urb ->status;
+	context->tx.status = urb->status;
 
 	/* notify waiters that write has finished */
-	atomic_set (&context ->tx.busy, 0);
-	complete (&context ->tx.finished);
+	atomic_set(&context->tx.busy, 0);
+	complete(&context->tx.finished);
 
 	return;
 }
@@ -659,91 +743,87 @@ static void usb_tx_callback (struct urb *urb)
 /**
  * Called by lirc_dev when the application opens /dev/lirc
  */
-static int ir_open (void *data)
+static int ir_open(void *data)
 {
 	int retval = SUCCESS;
 	struct imon_context *context;
 
 	/* prevent races with disconnect */
-	down (&disconnect_sem);
+	down(&disconnect_sem);
 
 	context = (struct imon_context *) data;
 
 	LOCK_CONTEXT;
 
-	if (context ->ir_isopen) {
-		err ("%s: IR port is already open", __FUNCTION__);
+	if (context->ir_isopen) {
+		err("%s: IR port is already open", __FUNCTION__);
 		retval = -EBUSY;
 		goto exit;
 	}
 
 	/* initial IR protocol decode variables */
-	context ->rx.count = 0;
-	context ->rx.initial_space = 1;
-	context ->rx.prev_bit = 0;
+	context->rx.count = 0;
+	context->rx.initial_space = 1;
+	context->rx.prev_bit = 0;
 
-	usb_fill_int_urb (context ->rx_urb, context ->dev,
-		usb_rcvintpipe (context ->dev,
-				context ->rx_endpoint-> bEndpointAddress),
-		context ->usb_rx_buf, sizeof (context ->usb_rx_buf),
-		usb_rx_callback, context, context ->rx_endpoint ->bInterval);
+	usb_fill_int_urb(context->rx_urb, context->dev,
+		usb_rcvintpipe(context->dev,
+				context->rx_endpoint->bEndpointAddress),
+		context->usb_rx_buf, sizeof(context->usb_rx_buf),
+		usb_rx_callback, context, context->rx_endpoint->bInterval);
 
 #ifdef KERNEL_2_5
-	retval = usb_submit_urb (context ->rx_urb, GFP_KERNEL);
+	retval = usb_submit_urb(context->rx_urb, GFP_KERNEL);
 #else
-	retval = usb_submit_urb (context ->rx_urb);
+	retval = usb_submit_urb(context->rx_urb);
 #endif
 
-	if (retval) {
-		err ("%s: usb_submit_urb failed for ir_open (%d)", __FUNCTION__, retval);
-	}
+	if (retval)
+		err("%s: usb_submit_urb failed for ir_open(%d)",
+		    __FUNCTION__, retval);
 	else {
 		MOD_INC_USE_COUNT;
-		context ->ir_isopen = TRUE;
-		info ("IR port opened");
+		context->ir_isopen = TRUE;
+		info("IR port opened");
 	}
 
 exit:
 	UNLOCK_CONTEXT;
 
-	up (&disconnect_sem);
+	up(&disconnect_sem);
 	return SUCCESS;
 }
 
 /**
  * Called by lirc_dev when the application closes /dev/lirc
  */
-static void ir_close (void *data)
+static void ir_close(void *data)
 {
 	struct imon_context *context;
 
 	context = (struct imon_context *)data;
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return;
 	}
 
 	LOCK_CONTEXT;
 
 	usb_kill_urb(context->rx_urb);
-	context ->ir_isopen = FALSE;
-	context ->ir_isassociating = FALSE;
+	context->ir_isopen = FALSE;
+	context->ir_isassociating = FALSE;
 	MOD_DEC_USE_COUNT;
-	info ("IR port closed");
+	info("IR port closed");
 
-	if (!context ->dev_present) {
-
-		/* 
-		 * Device disconnected while IR port was 
-		 * still open. Plugin was not deregistered 
-		 * at disconnect time, so do it now.
-		 */
-		deregister_from_lirc (context);
-
-		if (!context ->vfd_isopen) {
+	if (!context->dev_present) {
+		/* Device disconnected while IR port was
+		 * still open. Plugin was not deregistered
+		 * at disconnect time, so do it now. */
+		deregister_from_lirc(context);
 
+		if (!context->vfd_isopen) {
 			UNLOCK_CONTEXT;
-			delete_context (context);
+			delete_context(context);
 			return;
 		}
 		/* If VFD port is open, context will be deleted by vfd_close */
@@ -754,95 +834,93 @@ static void ir_close (void *data)
 }
 
 /**
- * Convert bit count to time duration (in us) and submit
+ * Convert bit count to time duration(in us) and submit
  * the value to lirc_dev.
  */
-static inline void submit_data (struct imon_context *context)
+static inline void submit_data(struct imon_context *context)
 {
-	unsigned char buf [4];
-	int value = context ->rx.count;
+	unsigned char buf[4];
+	int value = context->rx.count;
 	int i;
 
-	if (debug) info ("submitting data to LIRC");
-	
+	if (debug)
+		info("submitting data to LIRC\n");
+
 	value *= BIT_DURATION;
 	value &= PULSE_MASK;
-	if (context ->rx.prev_bit)
+	if (context->rx.prev_bit)
 		value |= PULSE_BIT;
 
-	for (i=0; i < 4; ++i)
-		buf [i] = value >> (i*8);
+	for (i = 0; i < 4; ++i)
+		buf[i] = value>>(i*8);
 
-	lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
-	wake_up (&context ->plugin ->rbuf ->wait_poll);
+	lirc_buffer_write_1(context->plugin->rbuf, buf);
+	wake_up(&context->plugin->rbuf->wait_poll);
 	return;
 }
 
 /**
  * Process the incoming packet
  */
-static inline void incoming_packet (struct imon_context *context, struct urb *urb)
+static inline void incoming_packet(struct imon_context *context,
+				   struct urb *urb)
 {
-	int len = urb ->actual_length;
-	unsigned char *buf = urb ->transfer_buffer;
+	int len = urb->actual_length;
+	unsigned char *buf = urb->transfer_buffer;
 	int octet, bit;
 	unsigned char mask;
 	int chunk_num;
-
+#ifdef DEBUG
+	int i;
+#endif
 
 	if (len != 8) {
-		warn ("%s: invalid incoming packet size (%d)", __FUNCTION__, len);
+		warn("%s: invalid incoming packet size(%d)",
+		     __FUNCTION__, len);
 		return;
 	}
 
 	/* iMON 2.4G associate frame */
-	if (buf [0] == 0x00 &&
-	    /* REFID */
-	    buf [2] == 0xFF &&
-	    buf [3] == 0xFF &&
-	    buf [4] == 0xFF &&
-	    buf [5] == 0xFF &&                       /* iMON 2.4G */
-	    ((buf [6] == 0x4E && buf [7] == 0xDF) || /* LT */
-	     (buf [6] == 0x5E && buf [7] == 0xDF) )) { /* DT */
-		warn ("%s: remote associated refid=%02X", __FUNCTION__, buf [1]);
-		context ->ir_isassociating = FALSE;
+	if (buf[0] == 0x00 &&
+	    buf[2] == 0xFF &&				/* REFID */
+	    buf[3] == 0xFF &&
+	    buf[4] == 0xFF &&
+	    buf[5] == 0xFF &&				/* iMON 2.4G */
+	   ((buf[6] == 0x4E && buf[7] == 0xDF) ||	/* LT */
+	    (buf[6] == 0x5E && buf[7] == 0xDF))) {	/* DT */
+		warn("%s: remote associated refid=%02X", __FUNCTION__, buf[1]);
+		context->ir_isassociating = FALSE;
 	}
 
-	chunk_num = buf [7];
-	
+	chunk_num = buf[7];
+
 	if (chunk_num == 0xFF)
 		return;		/* filler frame, no data here */
 
-	if (buf [0] == 0xFF &&
-	    buf [1] == 0xFF &&
-	    buf [2] == 0xFF &&
-	    buf [3] == 0xFF &&
-	    buf [4] == 0xFF &&
-	    buf [5] == 0xFF &&                     /* iMON 2.4G */
-	    ((buf [6] == 0x4E && buf [7] == 0xAF) || /* LT */
-	     (buf [6] == 0x5E && buf [7] == 0xAF) )) /* DT */
-	        return;		/* filler frame, no data here */
-
-#ifdef DEBUG	
-	{
-		int i;
-		for (i=0; i < 8; ++i)
-			printk ("%02x ", buf [i]);
-		printk ("\n");
-	}
-#endif
+	if (buf[0] == 0xFF &&
+	    buf[1] == 0xFF &&
+	    buf[2] == 0xFF &&
+	    buf[3] == 0xFF &&
+	    buf[4] == 0xFF &&
+	    buf[5] == 0xFF &&				/* iMON 2.4G */
+	    ((buf[6] == 0x4E && buf[7] == 0xAF) ||	/* LT */
+	     (buf[6] == 0x5E && buf[7] == 0xAF)))	/* DT */
+		return;		/* filler frame, no data here */
 
-	if (context ->ir_onboard_decode) {
+#ifdef DEBUG
+	for (i = 0; i < 8; ++i)
+		printk(KERN_INFO "%02x ", buf[i]);
+	printk(KERN_INFO "\n");
+#endif
 
+	if (context->ir_onboard_decode) {
 		/* The signals have been decoded onboard the iMON controller */
-
-		lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
-		wake_up (&context ->plugin ->rbuf ->wait_poll);
+		lirc_buffer_write_1(context->plugin->rbuf, buf);
+		wake_up(&context->plugin->rbuf->wait_poll);
 		return;
 	}
-	
-	/*
-	 * Translate received data to pulse and space lengths.
+
+	/* Translate received data to pulse and space lengths.
 	 * Received data is active low, i.e. pulses are 0 and
 	 * spaces are 1.
 	 *
@@ -852,45 +930,38 @@ static inline void incoming_packet (struct imon_context *context, struct urb *ur
 	 * initial space to LIRC at the start of a new sequence
 	 * if the previous bit was a pulse.
 	 *
-	 * I've decided to adopt his algorithm.
-	 */
-
-	if (chunk_num == 1 && context ->rx.initial_space) {
+	 * I've decided to adopt his algorithm. */
 
+	if (chunk_num == 1 && context->rx.initial_space) {
 		/* LIRC requires a leading space */
-		context ->rx.prev_bit = 0;
-		context ->rx.count = 4;
-		submit_data (context);
-		context ->rx.count = 0;
+		context->rx.prev_bit = 0;
+		context->rx.count = 4;
+		submit_data(context);
+		context->rx.count = 0;
 	}
 
-	for (octet=0; octet < 5; ++octet) {
-
+	for (octet = 0; octet < 5; ++octet) {
 		mask = 0x80;
-		for (bit=0; bit < 8; ++bit) {
-
-			int curr_bit = !(buf [octet] & mask);
-			if (curr_bit != context ->rx.prev_bit) {
-
-				if (context ->rx.count) {
-
-					submit_data (context);
-					context ->rx.count = 0;
+		for (bit = 0; bit < 8; ++bit) {
+			int curr_bit = !(buf[octet] & mask);
+			if (curr_bit != context->rx.prev_bit) {
+				if (context->rx.count) {
+					submit_data(context);
+					context->rx.count = 0;
 				}
-				context ->rx.prev_bit = curr_bit;
+				context->rx.prev_bit = curr_bit;
 			}
-			++context ->rx.count; 
+			++context->rx.count;
 			mask >>= 1;
 		}
 	}
 
 	if (chunk_num == 10) {
-
-		if (context ->rx.count) {
-			submit_data (context);
-			context ->rx.count = 0;
+		if (context->rx.count) {
+			submit_data(context);
+			context->rx.count = 0;
 		}
-		context ->rx.initial_space = context ->rx.prev_bit;
+		context->rx.initial_space = context->rx.prev_bit;
 	}
 }
 
@@ -898,34 +969,33 @@ static inline void incoming_packet (struct imon_context *context, struct urb *ur
  * Callback function for USB core API: receive data
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_rx_callback (struct urb *urb, struct pt_regs *regs)
+static void usb_rx_callback(struct urb *urb, struct pt_regs *regs)
 #else
-static void usb_rx_callback (struct urb *urb)
+static void usb_rx_callback(struct urb *urb)
 #endif
 {
 	struct imon_context *context;
 
-	if (!urb || !(context = (struct imon_context *) urb->context))
+	if (!urb)
+		return;
+	context = (struct imon_context *) urb->context;
+	if (!context)
 		return;
 
-	switch (urb ->status) {
-
-		case -ENOENT: 		/* usbcore unlink successful! */ 
-			return;
-
-		case SUCCESS:
-			if (context ->ir_isopen)
-				incoming_packet (context, urb);
-		       	break;
-
-		default	:
-			warn ("%s: status (%d): ignored",
-				 __FUNCTION__, urb ->status);
-			break;
+	switch (urb->status) {
+	case -ENOENT:		/* usbcore unlink successful! */
+		return;
+	case SUCCESS:
+		if (context->ir_isopen)
+			incoming_packet(context, urb);
+		break;
+	default	:
+		warn("%s: status(%d): ignored", __FUNCTION__, urb->status);
+		break;
 	}
 
 #ifdef KERNEL_2_5
-	usb_submit_urb (context ->rx_urb, GFP_ATOMIC);
+	usb_submit_urb(context->rx_urb, GFP_ATOMIC);
 #endif
 	return;
 }
@@ -936,10 +1006,10 @@ static void usb_rx_callback (struct urb *urb)
  * Callback function for USB core API: Probe
  */
 #ifdef KERNEL_2_5
-static int imon_probe (struct usb_interface *interface,
-			const struct usb_device_id *id)
+static int imon_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id)
 #else
-static void * imon_probe (struct usb_device * dev, unsigned int intf,
+static void *imon_probe(struct usb_device *dev, unsigned int intf,
 			const struct usb_device_id *id)
 #endif
 {
@@ -949,7 +1019,7 @@ static void * imon_probe (struct usb_device * dev, unsigned int intf,
 #else
 	struct usb_interface *interface = NULL;
 	struct usb_interface_descriptor *iface_desc = NULL;
-	char name [10];
+	char name[10];
 	int subminor = 0;
 #endif
 	struct usb_endpoint_descriptor *rx_endpoint = NULL;
@@ -969,91 +1039,89 @@ static void * imon_probe (struct usb_device * dev, unsigned int intf,
 	struct imon_context *context = NULL;
 	int i;
 
-	info ("%s: found IMON device", __FUNCTION__);
+	info("%s: found IMON device", __FUNCTION__);
+
+	/*
+	 * If it's the LCD, as opposed to the VFD, we just need to replace
+	 * the "write" file op.
+	 */
+	if (is_lcd)
+		vfd_fops.write = &lcd_write;
 
 #if !defined(KERNEL_2_5)
 	for (subminor = 0; subminor < MAX_DEVICES; ++subminor) {
-		if (minor_table [subminor] == NULL)
+		if (minor_table[subminor] == NULL)
 			break;
 	}
 	if (subminor == MAX_DEVICES) {
-	
-		err ("%s: allowed number of devices already present", __FUNCTION__);
+		err("%s: allowed max number of devices already present",
+		    __FUNCTION__);
 		retval = -ENOMEM;
 		goto exit;
 	}
 #endif
 
 #ifdef KERNEL_2_5
-	dev = usb_get_dev (interface_to_usbdev (interface));
-	iface_desc = interface ->cur_altsetting;
-	num_endpoints = iface_desc ->desc.bNumEndpoints;
+	dev = usb_get_dev(interface_to_usbdev(interface));
+	iface_desc = interface->cur_altsetting;
+	num_endpoints = iface_desc->desc.bNumEndpoints;
 #else
-	interface = &dev ->actconfig ->interface [intf];
-	iface_desc = &interface ->altsetting [interface ->act_altsetting];
-	num_endpoints = iface_desc ->bNumEndpoints;
+	interface = &dev->actconfig->interface[intf];
+	iface_desc = &interface->altsetting[interface->act_altsetting];
+	num_endpoints = iface_desc->bNumEndpoints;
 #endif
 
 	/*
 	 * Scan the endpoint list and set:
-	 * 	first input endpoint = IR endpoint
-	 * 	first output endpoint = VFD endpoint
+	 *	first input endpoint = IR endpoint
+	 *	first output endpoint = VFD endpoint
 	 */
 
-	ir_ep_found = vfd_ep_found = FALSE;
-
-	for (i=0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
+	ir_ep_found = FALSE;
+	vfd_ep_found = FALSE;
 
+	for (i = 0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
 		struct usb_endpoint_descriptor *ep;
 		int ep_dir;
 		int ep_type;
 #ifdef KERNEL_2_5
-		ep = &iface_desc ->endpoint [i].desc;
+		ep = &iface_desc->endpoint[i].desc;
 #else
-		ep = &iface_desc ->endpoint [i];
+		ep = &iface_desc->endpoint[i];
 #endif
-		ep_dir = ep ->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
-		ep_type = ep ->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+		ep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
+		ep_type = ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
-		if (!ir_ep_found && 
-			ep_dir == USB_DIR_IN && 
+		if (!ir_ep_found &&
+			ep_dir == USB_DIR_IN &&
 			ep_type == USB_ENDPOINT_XFER_INT) {
 
 			rx_endpoint = ep;
 			ir_ep_found = TRUE;
-			if (debug) 
-				info ("%s: found IR endpoint", __FUNCTION__);
-
-		}
-		else if (!vfd_ep_found &&
-			ep_dir == USB_DIR_OUT && 
-			ep_type == USB_ENDPOINT_XFER_INT) {
+			if (debug)
+				info("%s: found IR endpoint", __FUNCTION__);
 
+		} else if (!vfd_ep_found &&
+			   ep_dir == USB_DIR_OUT &&
+			   ep_type == USB_ENDPOINT_XFER_INT) {
 			tx_endpoint = ep;
 			vfd_ep_found = TRUE;
-			if (debug) 
-				info ("%s: found VFD endpoint", __FUNCTION__);
+			if (debug)
+				info("%s: found VFD endpoint", __FUNCTION__);
 		}
-		else
-			;
-
 	}
 
 	/* Input endpoint is mandatory */
 	if (!ir_ep_found) {
-
-		err ("%s: no valid input (IR) endpoint found.", __FUNCTION__);
+		err("%s: no valid input(IR) endpoint found.", __FUNCTION__);
 		retval = -ENODEV;
 		goto exit;
-	}
-	else {
-
+	} else {
 		/* Determine if the IR signals are decoded onboard */
-
 		unsigned short product_id;
 		unsigned short *id_list_item;
 
-		product_id = cpu_to_le16(dev ->descriptor.idProduct);
+		product_id = cpu_to_le16(dev->descriptor.idProduct);
 		id_list_item = ir_onboard_decode_product_list;
 		while (*id_list_item) {
 			if (*id_list_item++ == product_id) {
@@ -1062,16 +1130,16 @@ static void * imon_probe (struct usb_device * dev, unsigned int intf,
 			}
 		}
 
-		if (debug) info ("ir_onboard_decode: %d", ir_onboard_decode);
+		if (debug)
+			info("ir_onboard_decode: %d", ir_onboard_decode);
 	}
 
 	/* Determine if VFD requires 6 packets */
 	if (vfd_ep_found) {
-
 		unsigned short vendor_id;
 		unsigned short *id_list_item;
 
-		vendor_id = cpu_to_le16(dev ->descriptor.idVendor);
+		vendor_id = cpu_to_le16(dev->descriptor.idVendor);
 		id_list_item = vfd_proto_6p_vendor_list;
 		while (*id_list_item) {
 			if (*id_list_item++ == vendor_id) {
@@ -1080,7 +1148,8 @@ static void * imon_probe (struct usb_device * dev, unsigned int intf,
 			}
 		}
 
-		if (debug) info ("vfd_proto_6p: %d", vfd_proto_6p);
+		if (debug)
+			info("vfd_proto_6p: %d", vfd_proto_6p);
 	}
 
 
@@ -1088,149 +1157,169 @@ static void * imon_probe (struct usb_device * dev, unsigned int intf,
 
 	alloc_status = SUCCESS;
 
-	if (!(context = kmalloc (sizeof(struct imon_context), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for context", __FUNCTION__);
+	context = kmalloc(sizeof(struct imon_context), GFP_KERNEL);
+	if (!context) {
+		err("%s: kmalloc failed for context", __FUNCTION__);
 		alloc_status = 1;
+		goto alloc_status_switch;
 	}
-	else if (!(plugin = kmalloc (sizeof(struct lirc_plugin), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
+	plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL);
+	if (!plugin) {
+		err("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
 		alloc_status = 2;
+		goto alloc_status_switch;
 	}
-	else if (!(rbuf = kmalloc (sizeof(struct lirc_buffer), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
+	rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+	if (!rbuf) {
+		err("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
 		alloc_status = 3;
+		goto alloc_status_switch;
 	}
-	else if (lirc_buffer_init (rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
-		err ("%s: lirc_buffer_init failed", __FUNCTION__);
+	if (lirc_buffer_init(rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
+		err("%s: lirc_buffer_init failed", __FUNCTION__);
 		alloc_status = 4;
+		goto alloc_status_switch;
 	}
 #ifdef KERNEL_2_5
-	else if (!(rx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+	rx_urb = usb_alloc_urb(0, GFP_KERNEL);
 #else
-	else if (!(rx_urb = usb_alloc_urb (0))) {
+	rx_urb = usb_alloc_urb(0);
 #endif
-		err ("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
+	if (!rx_urb) {
+		err("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
 		alloc_status = 5;
+		goto alloc_status_switch;
 	}
+	if (vfd_ep_found) {
 #ifdef KERNEL_2_5
-	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+		tx_urb = usb_alloc_urb(0, GFP_KERNEL);
 #else
-	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0))) {
+		tx_urb = usb_alloc_urb(0);
 #endif
-		err ("%s: usb_alloc_urb failed for VFD urb", __FUNCTION__);
-		alloc_status = 6;
+		if (!tx_urb) {
+			err("%s: usb_alloc_urb failed for VFD urb",
+			    __FUNCTION__);
+			alloc_status = 6;
+			goto alloc_status_switch;
+		}
 	}
-	else {
 
-		/* clear all members of imon_context and lirc_plugin */
-		memset (context, 0, sizeof (struct imon_context));
-		init_MUTEX (&context ->sem);
-		context ->vfd_proto_6p = vfd_proto_6p;
-		context ->ir_onboard_decode = ir_onboard_decode;
-
-		memset (plugin, 0, sizeof (struct lirc_plugin));
-
-		strcpy (plugin ->name, MOD_NAME);
-		plugin ->minor = -1;
-		plugin ->code_length = (ir_onboard_decode) ?
-			32 : sizeof (lirc_t) * 8;
-		plugin ->sample_rate = 0;
-		plugin ->features = (ir_onboard_decode) ?
-			LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_MODE2;
-		plugin ->data = context;
-		plugin ->rbuf = rbuf;
-		plugin ->set_use_inc = ir_open;
-		plugin ->set_use_dec = ir_close;
+	/* clear all members of imon_context and lirc_plugin */
+	memset(context, 0, sizeof(struct imon_context));
+	init_MUTEX(&context->sem);
+	context->vfd_proto_6p = vfd_proto_6p;
+	context->ir_onboard_decode = ir_onboard_decode;
+
+	memset(plugin, 0, sizeof(struct lirc_plugin));
+
+	strcpy(plugin->name, MOD_NAME);
+	plugin->minor = -1;
+	plugin->code_length = (ir_onboard_decode) ?
+		32 : sizeof(lirc_t) * 8;
+	plugin->sample_rate = 0;
+	plugin->features = (ir_onboard_decode) ?
+		LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_MODE2;
+	plugin->data = context;
+	plugin->rbuf = rbuf;
+	plugin->set_use_inc = ir_open;
+	plugin->set_use_dec = ir_close;
 #ifdef LIRC_HAVE_SYSFS
-		plugin->dev = &dev->dev;
+	plugin->dev = &dev->dev;
 #endif
-		plugin->owner = THIS_MODULE;
+	plugin->owner = THIS_MODULE;
 
-		LOCK_CONTEXT;
+	LOCK_CONTEXT;
 
-		if ((lirc_minor = lirc_register_plugin (plugin)) < 0) {
-			err ("%s: lirc_register_plugin failed", __FUNCTION__);
-			alloc_status = 7;
-			UNLOCK_CONTEXT;
-		}
-		else
-			info ("%s: Registered iMON plugin (minor:%d)", 
-				__FUNCTION__, lirc_minor);
-	}
+	lirc_minor = lirc_register_plugin(plugin);
+	if (lirc_minor < 0) {
+		err("%s: lirc_register_plugin failed", __FUNCTION__);
+		alloc_status = 7;
+		UNLOCK_CONTEXT;
+		goto alloc_status_switch;
+	} else
+		info("%s: Registered iMON plugin(minor:%d)",
+		     __FUNCTION__, lirc_minor);
 
-	switch (alloc_status) {
+alloc_status_switch:
 
-		case 7:		if (vfd_ep_found)
-					usb_free_urb (tx_urb);
-		case 6:		usb_free_urb (rx_urb);
-		case 5:		lirc_buffer_free (rbuf);
-		case 4:		kfree (rbuf);
-		case 3:		kfree (plugin);
-		case 2:		kfree (context);
-				context = NULL;
-		case 1:		retval = -ENOMEM;
-				goto exit;
+	switch (alloc_status) {
+	case 7:
+		if (vfd_ep_found)
+			usb_free_urb(tx_urb);
+	case 6:
+		usb_free_urb(rx_urb);
+	case 5:
+		lirc_buffer_free(rbuf);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(context);
+		context = NULL;
+	case 1:
+		retval = -ENOMEM;
 	}
 
-	// Needed while unregistering!
-	plugin ->minor = lirc_minor;
+	/* Needed while unregistering! */
+	plugin->minor = lirc_minor;
 
-	context ->dev = dev;
-	context ->dev_present = TRUE;
-	context ->rx_endpoint = rx_endpoint;
-	context ->rx_urb = rx_urb;
+	context->dev = dev;
+	context->dev_present = TRUE;
+	context->rx_endpoint = rx_endpoint;
+	context->rx_urb = rx_urb;
 	if (vfd_ep_found) {
-		
-		context ->vfd_supported = TRUE;
-		context ->tx_endpoint = tx_endpoint;
-		context ->tx_urb = tx_urb;
+		context->vfd_supported = TRUE;
+		context->tx_endpoint = tx_endpoint;
+		context->tx_urb = tx_urb;
 	}
-	context ->plugin = plugin;
+	context->plugin = plugin;
 
 #ifdef KERNEL_2_5
-	usb_set_intfdata (interface, context);
+	usb_set_intfdata(interface, context);
 
-	if (cpu_to_le16(dev ->descriptor.idProduct) == 0xffdc) {
+	if (cpu_to_le16(dev->descriptor.idProduct) == 0xffdc) {
 		int err;
 
-		err = sysfs_create_group(&interface ->dev.kobj, &imon_attribute_group);
+		err = sysfs_create_group(&interface->dev.kobj,
+					 &imon_attribute_group);
 		if (err)
-			err ("%s: Could not create sysfs entries (%d)", __FUNCTION__, err);
+			err("%s: Could not create sysfs entries(%d)",
+			    __FUNCTION__, err);
 	}
 #else
-	minor_table [subminor] = context;
-	context ->subminor = subminor;
+	minor_table[subminor] = context;
+	context->subminor = subminor;
 #endif
 
 	if (vfd_ep_found) {
-
-		if (debug) info ("Registering VFD with devfs");
+		if (debug)
+			info("Registering VFD with devfs");
 #ifdef KERNEL_2_5
-		if (usb_register_dev (interface, &imon_class)) {
-
-			// Not a fatal error, so ignore
-			info ("%s: could not get a minor number for VFD", 
+		if (usb_register_dev(interface, &imon_class)) {
+			/* Not a fatal error, so ignore */
+			info("%s: could not get a minor number for VFD",
 				__FUNCTION__);
 		}
 #else
-		sprintf (name, DEVFS_NAME, subminor);
-		if (!(context ->devfs = devfs_register (usb_devfs_handle, name, 
+		sprintf(name, DEVFS_NAME, subminor);
+		if (!(context->devfs = devfs_register(usb_devfs_handle, name,
 					DEVFS_FL_DEFAULT,
 					USB_MAJOR, VFD_MINOR_BASE + subminor,
 					DEVFS_MODE, &vfd_fops, NULL))) {
-
-			// not a fatal error so ignore
-			info ("%s: devfs register failed for VFD",
+			/* not a fatal error so ignore */
+			info("%s: devfs register failed for VFD",
 					__FUNCTION__);
 		}
 #endif
 	}
 
-	info ("%s: iMON device on usb<%d:%d> initialized",
-			__FUNCTION__, dev ->bus ->busnum, dev ->devnum);
+	info("%s: iMON device on usb<%d:%d> initialized",
+			__FUNCTION__, dev->bus->busnum, dev->devnum);
 
 	UNLOCK_CONTEXT;
-exit:
+
+ exit:
 #ifdef KERNEL_2_5
 	return retval;
 #else
@@ -1242,89 +1331,89 @@ exit:
  * Callback function for USB core API: disonnect
  */
 #ifdef KERNEL_2_5
-static void imon_disconnect (struct usb_interface *interface)
+static void imon_disconnect(struct usb_interface *interface)
 #else
-static void imon_disconnect (struct usb_device *dev, void *data)
+static void imon_disconnect(struct usb_device *dev, void *data)
 #endif
 {
 	struct imon_context *context;
 
 	/* prevent races with ir_open()/vfd_open() */
-	down (&disconnect_sem);
+	down(&disconnect_sem);
 
 #ifdef KERNEL_2_5
-	context = usb_get_intfdata (interface);
+	context = usb_get_intfdata(interface);
 #else
 	context = (struct imon_context *)data;
 #endif
 	LOCK_CONTEXT;
 
-	info ("%s: iMON device disconnected", __FUNCTION__);
+	info("%s: iMON device disconnected", __FUNCTION__);
 
 #ifdef KERNEL_2_5
-	/* sysfs_remove_group is safe to call even if sysfs_create_group hasn't been called */
+	/* sysfs_remove_group is safe to call even if sysfs_create_group
+	 * hasn't been called */
 	sysfs_remove_group(&interface->dev.kobj,
 			   &imon_attribute_group);
-	usb_set_intfdata (interface, NULL);
+	usb_set_intfdata(interface, NULL);
 #else
-	minor_table [context ->subminor] = NULL;
+	minor_table[context->subminor] = NULL;
 #endif
-	context ->dev_present = FALSE;
+	context->dev_present = FALSE;
 
 	/* Stop reception */
 	usb_kill_urb(context->rx_urb);
 
 	/* Abort ongoing write */
-	if (atomic_read (&context ->tx.busy)) {
-
+	if (atomic_read(&context->tx.busy)) {
 		usb_kill_urb(context->tx_urb);
-		wait_for_completion (&context ->tx.finished);
+		wait_for_completion(&context->tx.finished);
 	}
 
 	/* De-register from lirc_dev if IR port is not open */
-	if (!context ->ir_isopen)
-		deregister_from_lirc (context);
+	if (!context->ir_isopen)
+		deregister_from_lirc(context);
 
-	if (context ->vfd_supported) {
+	if (context->vfd_supported)
 #ifdef KERNEL_2_5
-		usb_deregister_dev (interface, &imon_class);
+		usb_deregister_dev(interface, &imon_class);
 #else
-		if (context ->devfs)
-			devfs_unregister (context ->devfs);
+		if (context->devfs)
+			devfs_unregister(context->devfs);
 #endif
-	}
 
 	UNLOCK_CONTEXT;
 
-	if (!context ->ir_isopen && !context ->vfd_isopen)
-		delete_context (context);
-	
-	up (&disconnect_sem);
+	if (!context->ir_isopen && !context->vfd_isopen)
+		delete_context(context);
+
+	up(&disconnect_sem);
 }
 
-static int __init imon_init (void)
+static int __init imon_init(void)
 {
 	int rc;
 
-	info (MOD_DESC ", v" MOD_VERSION);
-	info (MOD_AUTHOR);
+	info(MOD_DESC ", v" MOD_VERSION);
+	info(MOD_AUTHOR);
 
-	if ((rc = usb_register (&imon_driver)) < 0) {
-		err ("%s: usb register failed (%d)", __FUNCTION__, rc);
+	rc = usb_register(&imon_driver);
+	if (rc) {
+		err("%s: usb register failed(%d)", __FUNCTION__, rc);
 		return -ENODEV;
 	}
 	return SUCCESS;
 }
 
-static void __exit imon_exit (void)
+static void __exit imon_exit(void)
 {
-	usb_deregister (&imon_driver);
-	info ("module removed. Goodbye!");
+	usb_deregister(&imon_driver);
+	info("module removed. Goodbye!");
 }
 
 
-module_init (imon_init);
-module_exit (imon_exit);
+module_init(imon_init);
+module_exit(imon_exit);
 
 #if !defined(KERNEL_2_5)
 EXPORT_NO_SYMBOLS;
diff --git a/drivers/char/lirc/lirc_it87.c b/drivers/char/lirc/lirc_it87.c
index f220daf..beba988 100644
--- a/drivers/char/lirc/lirc_it87.c
+++ b/drivers/char/lirc/lirc_it87.c
@@ -21,12 +21,12 @@
  * ITE IT8705 and IT8712(not tested) CIR-port support for lirc based
  * via cut and paste from lirc_sir.c (C) 2000 Milan Pikula
  *
- * Attention: Sendmode only tested with debugging logs 
+ * Attention: Sendmode only tested with debugging logs
  *
  * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
  *   reimplemented read function
  * 2005/06/05 Andrew Calkin implemented support for Asus Digimatrix,
- *   based on work of the following member of the Outertrack Digimatrix 
+ *   based on work of the following member of the Outertrack Digimatrix
  *   Forum: Art103 <r_tay@hotmail.com>
  */
 
@@ -35,9 +35,9 @@
 #include <linux/module.h>
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+#include <config.h>
 #endif
- 
+
 #include <linux/autoconf.h>
 
 
@@ -58,10 +58,17 @@
 #include <linux/delay.h>
 #include <linux/poll.h>
 #include <asm/system.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/fcntl.h>
+#else
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/fcntl.h>
+#endif
 
 #include <linux/timer.h>
 
@@ -76,13 +83,13 @@ static int digimatrix = 1;
 static int it87_freq = 36; /* kHz */
 static int irq = 9;
 #else
-static int digimatrix = 0;
+static int digimatrix;
 static int it87_freq = 38; /* kHz */
 static int irq = IT87_CIR_DEFAULT_IRQ;
 #endif
 
-static unsigned long it87_bits_in_byte_out = 0;
-static unsigned long it87_send_counter = 0;
+static unsigned long it87_bits_in_byte_out;
+static unsigned long it87_send_counter;
 static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
 
 #define RBUF_LEN 1024
@@ -95,67 +102,59 @@ static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
 #define IT87_TIMEOUT	(HZ*5/100)
 
 /* insmod parameters */
-static int debug = 0;
-#define dprintk(fmt, args...)                                     \
-	do{                                                       \
-		if(debug) printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
-                                 fmt, ## args);                   \
-	}while(0)
+static int debug;
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG LIRC_DRIVER_NAME ": "	\
+			       fmt, ## args);			\
+	} while (0)
 
 static int io = IT87_CIR_DEFAULT_IOBASE;
 /* receiver demodulator default: off */
-static int it87_enable_demodulator = 0;
+static int it87_enable_demodulator;
 
-static int timer_enabled = 0;
-static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static int timer_enabled;
+static DEFINE_SPINLOCK(timer_lock);
 static struct timer_list timerlist;
 /* time of last signal change detected */
 static struct timeval last_tv = {0, 0};
 /* time of last UART data ready interrupt */
 static struct timeval last_intr_tv = {0, 0};
-static int last_value = 0;
+static int last_value;
 
 static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
 
-static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(hardware_lock);
+static DEFINE_SPINLOCK(dev_lock);
 
-static lirc_t rx_buf[RBUF_LEN]; unsigned int rx_tail = 0, rx_head = 0;
+static lirc_t rx_buf[RBUF_LEN];
+unsigned int rx_tail, rx_head;
 static lirc_t tx_buf[WBUF_LEN];
 
 /* SECTION: Prototypes */
 
 /* Communication with user-space */
-static int lirc_open(struct inode * inode,
-		     struct file * file);
-static int lirc_close(struct inode * inode,
-		      struct file *file);
-static unsigned int lirc_poll(struct file * file,
-			      poll_table * wait);
-static ssize_t lirc_read(struct file * file,
-			 char * buf,
-			 size_t count,
-			 loff_t * ppos);
-static ssize_t lirc_write(struct file * file,
-			  const char * buf,
-			  size_t n,
-			  loff_t * pos);
-static int lirc_ioctl(struct inode *node,
-		      struct file *filep,
-		      unsigned int cmd,
-		      unsigned long arg);
-static void add_read_queue(int flag,
-			   unsigned long val);
+static int lirc_open(struct inode *inode, struct file *file);
+static int lirc_close(struct inode *inode, struct file *file);
+static unsigned int lirc_poll(struct file *file, poll_table *wait);
+static ssize_t lirc_read(struct file *file, char *buf,
+			 size_t count, loff_t *ppos);
+static ssize_t lirc_write(struct file *file, const char *buf,
+			  size_t n, loff_t *pos);
+static int lirc_ioctl(struct inode *node, struct file *filep,
+		      unsigned int cmd, unsigned long arg);
+static void add_read_queue(int flag, unsigned long val);
 #ifdef MODULE
 static int init_chrdev(void);
 static void drop_chrdev(void);
 #endif
 	/* Hardware */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static irqreturn_t it87_interrupt(int irq, void * dev_id,
-				 struct pt_regs * regs);
+static irqreturn_t it87_interrupt(int irq, void *dev_id,
+				  struct pt_regs *regs);
 #else
-static irqreturn_t it87_interrupt(int irq, void * dev_id);
+static irqreturn_t it87_interrupt(int irq, void *dev_id);
 #endif
 static void send_space(unsigned long len);
 static void send_pulse(unsigned long len);
@@ -172,8 +171,7 @@ void cleanup_module(void);
 
 /* SECTION: Communication with user-space */
 
-static int lirc_open(struct inode * inode,
-		     struct file * file)
+static int lirc_open(struct inode *inode, struct file *file)
 {
 	spin_lock(&dev_lock);
 	if (MOD_IN_USE) {
@@ -186,16 +184,14 @@ static int lirc_open(struct inode * inode,
 }
 
 
-static int lirc_close(struct inode * inode,
-		      struct file *file)
+static int lirc_close(struct inode *inode, struct file *file)
 {
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
 
-static unsigned int lirc_poll(struct file * file,
-			      poll_table * wait)
+static unsigned int lirc_poll(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &lirc_read_queue, wait);
 	if (rx_head != rx_tail)
@@ -204,58 +200,46 @@ static unsigned int lirc_poll(struct file * file,
 }
 
 
-static ssize_t lirc_read(struct file * file,
-			 char * buf,
-			 size_t count,
-			 loff_t * ppos)
+static ssize_t lirc_read(struct file *file, char *buf,
+			 size_t count, loff_t *ppos)
 {
-	int n=0;
-	int retval=0;
-	
-	while(n<count)
-	{
-		if(file->f_flags & O_NONBLOCK &&
-		   rx_head==rx_tail)
-		{
+	int n = 0;
+	int retval = 0;
+
+	while (n < count) {
+		if (file->f_flags & O_NONBLOCK && rx_head == rx_tail) {
 			retval = -EAGAIN;
 			break;
 		}
-		retval=wait_event_interruptible(lirc_read_queue,
-						rx_head!=rx_tail);
-		if(retval)
-		{
+		retval = wait_event_interruptible(lirc_read_queue,
+						  rx_head != rx_tail);
+		if (retval)
 			break;
-		}
-		
-		if(copy_to_user((void *) buf+n,(void *) (rx_buf+rx_head),
-				sizeof(lirc_t)))
-		{
+
+		if (copy_to_user((void *) buf + n, (void *) (rx_buf + rx_head),
+				 sizeof(lirc_t))) {
 			retval = -EFAULT;
 			break;
 		}
-		rx_head=(rx_head+1)&(RBUF_LEN-1);
-		n+=sizeof(lirc_t);
+		rx_head = (rx_head + 1) & (RBUF_LEN - 1);
+		n += sizeof(lirc_t);
 	}
-	if(n)
-	{
+	if (n)
 		return n;
-	}
 	return retval;
 }
 
 
-static ssize_t lirc_write(struct file * file,
-			  const char * buf,
-			  size_t n,
-			  loff_t * pos)
+static ssize_t lirc_write(struct file *file, const char *buf,
+			  size_t n, loff_t *pos)
 {
-	int i;
+	int i = 0;
 
-        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
-		return(-EINVAL);
-	if(copy_from_user(tx_buf, buf, n)) return -EFAULT;
-	i = 0;
-	n/=sizeof(lirc_t);
+	if (n % sizeof(lirc_t) || (n / sizeof(lirc_t)) > WBUF_LEN)
+		return -EINVAL;
+	if (copy_from_user(tx_buf, buf, n))
+		return -EFAULT;
+	n /= sizeof(lirc_t);
 	init_send();
 	while (1) {
 		if (i >= n)
@@ -269,19 +253,18 @@ static ssize_t lirc_write(struct file * file,
 			send_space(tx_buf[i]);
 		i++;
 	}
-	terminate_send(tx_buf[i-1]);
+	terminate_send(tx_buf[i - 1]);
 	return n;
 }
 
 
-static int lirc_ioctl(struct inode *node,
-		      struct file *filep,
-		      unsigned int cmd,
-		      unsigned long arg)
+static int lirc_ioctl(struct inode *node, struct file *filep,
+		      unsigned int cmd, unsigned long arg)
 {
 	int retval = 0;
 	unsigned long value = 0;
 	unsigned int ivalue;
+	unsigned long hw_flags;
 
 	if (cmd == LIRC_GET_FEATURES)
 		value = LIRC_CAN_SEND_PULSE |
@@ -291,7 +274,7 @@ static int lirc_ioctl(struct inode *node,
 		value = LIRC_MODE_PULSE;
 	else if (cmd == LIRC_GET_REC_MODE)
 		value = LIRC_MODE_MODE2;
-	
+
 	switch (cmd) {
 	case LIRC_GET_FEATURES:
 	case LIRC_GET_SEND_MODE:
@@ -305,34 +288,32 @@ static int lirc_ioctl(struct inode *node,
 		break;
 
 	case LIRC_SET_SEND_CARRIER:
-		retval=get_user(ivalue,(unsigned int *) arg);
-		if(retval) return(retval);
+		retval = get_user(ivalue, (unsigned int *) arg);
+		if (retval)
+			return retval;
 		ivalue /= 1000;
 		if (ivalue > IT87_CIR_FREQ_MAX ||
-		    ivalue < IT87_CIR_FREQ_MIN) return(-EINVAL);
+		    ivalue < IT87_CIR_FREQ_MIN)
+			return -EINVAL;
 
 		it87_freq = ivalue;
-		{
-			unsigned long hw_flags;
 
-			spin_lock_irqsave(&hardware_lock, hw_flags);
-			outb(((inb(io + IT87_CIR_TCR2) & IT87_CIR_TCR2_TXMPW) |
-			      (it87_freq - IT87_CIR_FREQ_MIN) << 3),
-			     io + IT87_CIR_TCR2);
-			spin_unlock_irqrestore(&hardware_lock, hw_flags);
-			dprintk("demodulation frequency: %d kHz\n",
-				it87_freq);
-		}
+		spin_lock_irqsave(&hardware_lock, hw_flags);
+		outb(((inb(io + IT87_CIR_TCR2) & IT87_CIR_TCR2_TXMPW) |
+		      (it87_freq - IT87_CIR_FREQ_MIN) << 3),
+		      io + IT87_CIR_TCR2);
+		spin_unlock_irqrestore(&hardware_lock, hw_flags);
+		dprintk("demodulation frequency: %d kHz\n", it87_freq);
 
 		break;
 
 	default:
 		retval = -ENOIOCTLCMD;
 	}
-	
+
 	if (retval)
 		return retval;
-	
+
 	if (cmd == LIRC_SET_REC_MODE) {
 		if (value != LIRC_MODE_MODE2)
 			retval = -ENOSYS;
@@ -348,24 +329,21 @@ static void add_read_queue(int flag, unsigned long val)
 	unsigned int new_rx_tail;
 	lirc_t newval;
 
-	dprintk("add flag %d with val %lu\n", flag,val);
-	
+	dprintk("add flag %d with val %lu\n", flag, val);
+
 	newval = val & PULSE_MASK;
 
 	/* statistically pulses are ~TIME_CONST/2 too long: we could
 	   maybe make this more exactly but this is good enough */
-	if(flag) /* pulse */ {
-		if(newval>TIME_CONST/2) {
-			newval-=TIME_CONST/2;
-		}
-		else /* should not ever happen */ {
-			newval=1;
-		}
-		newval|=PULSE_BIT;
-	}
-	else {
-		newval+=TIME_CONST/2;
-	}
+	if (flag) {
+		/* pulse */
+		if (newval > TIME_CONST / 2)
+			newval -= TIME_CONST / 2;
+		else /* should not ever happen */
+			newval = 1;
+		newval |= PULSE_BIT;
+	} else
+		newval += TIME_CONST / 2;
 	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
 	if (new_rx_tail == rx_head) {
 		dprintk("Buffer overrun.\n");
@@ -378,15 +356,15 @@ static void add_read_queue(int flag, unsigned long val)
 
 
 static struct file_operations lirc_fops = {
-	read:    lirc_read,
-	write:   lirc_write,
-	poll:    lirc_poll,
-	ioctl:   lirc_ioctl,
-	open:    lirc_open,
-	release: lirc_close,
+	.read		= lirc_read,
+	.write		= lirc_write,
+	.poll		= lirc_poll,
+	.ioctl		= lirc_ioctl,
+	.open		= lirc_open,
+	.release	= lirc_close,
 };
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_INC_USE_COUNT;
@@ -394,25 +372,25 @@ static int set_use_inc(void* data)
        return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_DEC_USE_COUNT;
 #endif
 }
 static struct lirc_plugin plugin = {
-       name:           LIRC_DRIVER_NAME,
-       minor:          -1,
-       code_length:    1,
-       sample_rate:    0,
-       data:           NULL,
-       add_to_buf:     NULL,
-       get_queue:      NULL,
-       set_use_inc:    set_use_inc,
-       set_use_dec:    set_use_dec,
-       fops:           &lirc_fops,
-       dev:            NULL,
-       owner:	       THIS_MODULE,
+       .name		= LIRC_DRIVER_NAME,
+       .minor		= -1,
+       .code_length	= 1,
+       .sample_rate	= 0,
+       .data		= NULL,
+       .add_to_buf	= NULL,
+       .get_queue	= NULL,
+       .set_use_inc	= set_use_inc,
+       .set_use_dec	= set_use_dec,
+       .fops		= &lirc_fops,
+       .dev		= NULL,
+       .owner		= THIS_MODULE,
 };
 
 
@@ -420,7 +398,7 @@ static struct lirc_plugin plugin = {
 static int init_chrdev(void)
 {
 	plugin.minor = lirc_register_plugin(&plugin);
-	
+
 	if (plugin.minor < 0) {
 		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
 		return -EIO;
@@ -437,39 +415,35 @@ static void drop_chrdev(void)
 
 
 /* SECTION: Hardware */
-static long delta(struct timeval * tv1,
-		  struct timeval * tv2)
+static long delta(struct timeval *tv1, struct timeval *tv2)
 {
 	unsigned long deltv;
-	
+
 	deltv = tv2->tv_sec - tv1->tv_sec;
 	if (deltv > 15)
 		deltv = 0xFFFFFF;
 	else
-		deltv = deltv*1000000 +
-			tv2->tv_usec -
-			tv1->tv_usec;
+		deltv = deltv*1000000 + tv2->tv_usec - tv1->tv_usec;
 	return deltv;
 }
 
-static void it87_timeout(unsigned long data) 
+static void it87_timeout(unsigned long data)
 {
 	unsigned long flags;
-	
+
 	/* avoid interference with interrupt */
- 	spin_lock_irqsave(&timer_lock, flags);
-	
- 	if (digimatrix) {
+	spin_lock_irqsave(&timer_lock, flags);
+
+	if (digimatrix) {
 		/* We have timed out.
 		   Disable the RX mechanism.
 		*/
-		
+
 		outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
 		     IT87_CIR_RCR_RXACT, io + IT87_CIR_RCR);
-		if (it87_RXEN_mask) {
+		if (it87_RXEN_mask)
 			outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
 			     io + IT87_CIR_RCR);
-		}
 		dprintk(" TIMEOUT\n");
 		timer_enabled = 0;
 
@@ -477,36 +451,32 @@ static void it87_timeout(unsigned long data)
 		outb(inb(io + IT87_CIR_TCR1) | IT87_CIR_TCR1_FIFOCLR,
 		     io+IT87_CIR_TCR1);
 
-	}
-	else {
+	} else {
 		/* if last received signal was a pulse, but receiving
 		   stopped within the 9 bit frame, we need to finish
 		   this pulse and simulate a signal change to from
 		   pulse to space. Otherwise upper layers will receive
 		   two sequences next time. */
-	
+
 		if (last_value) {
 			unsigned long pulse_end;
-			
+
 			/* determine 'virtual' pulse end: */
-	 		pulse_end = delta(&last_tv, &last_intr_tv);
-			dprintk("timeout add %d for %lu usec\n", 
+			pulse_end = delta(&last_tv, &last_intr_tv);
+			dprintk("timeout add %d for %lu usec\n",
 				last_value, pulse_end);
 			add_read_queue(last_value, pulse_end);
 			last_value = 0;
-			last_tv=last_intr_tv;
+			last_tv = last_intr_tv;
 		}
 	}
-	spin_unlock_irqrestore(&timer_lock, flags);		
+	spin_unlock_irqrestore(&timer_lock, flags);
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static irqreturn_t it87_interrupt(int irq,
-				 void * dev_id,
-				 struct pt_regs * regs)
+static irqreturn_t it87_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 #else
-static irqreturn_t it87_interrupt(int irq,
-				  void * dev_id)
+static irqreturn_t it87_interrupt(int irq, void *dev_id)
 #endif
 {
 	unsigned char data;
@@ -516,11 +486,11 @@ static irqreturn_t it87_interrupt(int irq,
 	unsigned long flags, hw_flags;
 	int iir, lsr;
 	int fifo = 0;
-	static char lastbit = 0;
+	static char lastbit;
 	char bit;
 
 	/* Bit duration in microseconds */
-	const unsigned long bit_duration = 1000000ul / 
+	const unsigned long bit_duration = 1000000ul /
 		(115200 / IT87_CIR_BAUDRATE_DIVISOR);
 
 
@@ -533,45 +503,44 @@ static irqreturn_t it87_interrupt(int irq,
 						IT87_CIR_RSR_RXFBC);
 		fifo = lsr & IT87_CIR_RSR_RXFBC;
 		dprintk("iir: 0x%x fifo: 0x%x\n", iir, lsr);
-	
+
 		/* avoid interference with timer */
 		spin_lock_irqsave(&timer_lock, flags);
 		spin_lock_irqsave(&hardware_lock, hw_flags);
-		if (digimatrix) { 
-			static unsigned long acc_pulse = 0;
-			static unsigned long acc_space = 0;
-			
+		if (digimatrix) {
+			static unsigned long acc_pulse;
+			static unsigned long acc_space;
+
 			do {
 				data = inb(io + IT87_CIR_DR);
-				data =~ data;
+				data = ~data;
 				fifo--;
 				if (data != 0x00) {
-					if (timer_enabled) {
+					if (timer_enabled)
 						del_timer(&timerlist);
-					}
-					/* start timer for end of sequence detection */
-					timerlist.expires = jiffies + IT87_TIMEOUT;
+					/* start timer for end of
+					 * sequence detection */
+					timerlist.expires = jiffies +
+							    IT87_TIMEOUT;
 					add_timer(&timerlist);
 					timer_enabled = 1;
 				}
 				/* Loop through */
-				for(bit = 0; bit < 8; ++bit)
-				{
-					if((data >> bit) & 1)
-					{
+				for (bit = 0; bit < 8; ++bit) {
+					if ((data >> bit) & 1) {
 						++acc_pulse;
-						if(lastbit == 0)
-						{
-							add_read_queue(0, acc_space * bit_duration);
+						if (lastbit == 0) {
+							add_read_queue(0,
+								acc_space *
+								 bit_duration);
 							acc_space = 0;
 						}
-        				}
-					else
-					{
+					} else {
 						++acc_space;
-						if(lastbit == 1)
-						{
-							add_read_queue(1, acc_pulse * bit_duration);
+						if (lastbit == 1) {
+							add_read_queue(1,
+								acc_pulse *
+								 bit_duration);
 							acc_pulse = 0;
 						}
 					}
@@ -579,8 +548,7 @@ static irqreturn_t it87_interrupt(int irq,
 				}
 
 			} while (fifo != 0);
-	 	}
-		else {/* Normal Operation */
+		} else { /* Normal Operation */
 			do {
 				del_timer(&timerlist);
 				data = inb(io + IT87_CIR_DR);
@@ -590,8 +558,9 @@ static irqreturn_t it87_interrupt(int irq,
 				deltv = delta(&last_tv, &curr_tv);
 				deltintrtv = delta(&last_intr_tv, &curr_tv);
 
-				dprintk("t %lu , d %d\n", deltintrtv, (int)data);
-			
+				dprintk("t %lu , d %d\n",
+					deltintrtv, (int)data);
+
 				/* if nothing came in last 2 cycles,
 				   it was gap */
 				if (deltintrtv > TIME_CONST * 2) {
@@ -600,11 +569,13 @@ static irqreturn_t it87_interrupt(int irq,
 
 						/* simulate signal change */
 						add_read_queue(last_value,
-							       deltv-
+							       deltv -
 							       deltintrtv);
 						last_value = 0;
-						last_tv.tv_sec = last_intr_tv.tv_sec;
-						last_tv.tv_usec = last_intr_tv.tv_usec;
+						last_tv.tv_sec =
+							last_intr_tv.tv_sec;
+						last_tv.tv_usec =
+							last_intr_tv.tv_usec;
 						deltv = deltintrtv;
 					}
 				}
@@ -617,35 +588,36 @@ static irqreturn_t it87_interrupt(int irq,
 						       deltv-TIME_CONST);
 					last_value = data;
 					last_tv = curr_tv;
-					if(last_tv.tv_usec>=TIME_CONST) {
-						last_tv.tv_usec-=TIME_CONST;
-					}
+					if (last_tv.tv_usec >= TIME_CONST)
+						last_tv.tv_usec -= TIME_CONST;
 					else {
 						last_tv.tv_sec--;
-						last_tv.tv_usec+=1000000-
+						last_tv.tv_usec += 1000000 -
 							TIME_CONST;
 					}
 				}
 				last_intr_tv = curr_tv;
 				if (data) {
-					/* start timer for end of sequence detection */
-					timerlist.expires = jiffies + IT87_TIMEOUT;
+					/* start timer for end of
+					 * sequence detection */
+					timerlist.expires =
+						jiffies + IT87_TIMEOUT;
 					add_timer(&timerlist);
 				}
-				outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+				outb((inb(io + IT87_CIR_RCR) &
+				     ~IT87_CIR_RCR_RXEN) |
 				     IT87_CIR_RCR_RXACT,
 				     io + IT87_CIR_RCR);
-				if (it87_RXEN_mask) {
-					outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN, 
+				if (it87_RXEN_mask)
+					outb(inb(io + IT87_CIR_RCR) |
+					     IT87_CIR_RCR_RXEN,
 					     io + IT87_CIR_RCR);
-				}
 				fifo--;
-			}
-			while (fifo != 0);
+			} while (fifo != 0);
 		}
 		spin_unlock_irqrestore(&hardware_lock, hw_flags);
 		spin_unlock_irqrestore(&timer_lock, flags);
-		
+
 		return IRQ_RETVAL(IRQ_HANDLED);
 
 	default:
@@ -656,22 +628,21 @@ static irqreturn_t it87_interrupt(int irq,
 }
 
 
-static void send_it87(unsigned long len,
-		      unsigned long stime,
-		      unsigned char send_byte,
-		      unsigned int count_bits)
+static void send_it87(unsigned long len, unsigned long stime,
+		      unsigned char send_byte, unsigned int count_bits)
 {
-        long count = len / stime;
+	long count = len / stime;
 	long time_left = 0;
-	static unsigned char byte_out = 0;
+	static unsigned char byte_out;
+	unsigned long hw_flags;
 
 	dprintk("%s: len=%ld, sb=%d\n", __FUNCTION__, len, send_byte);
 
 	time_left = (long)len - (long)count * (long)stime;
 	count += ((2 * time_left) / stime);
 	while (count) {
-		long i=0;
-		for (i=0; i<count_bits; i++) {
+		long i = 0;
+		for (i = 0; i < count_bits; i++) {
 			byte_out = (byte_out << 1) | (send_byte & 1);
 			it87_bits_in_byte_out++;
 		}
@@ -682,14 +653,13 @@ static void send_it87(unsigned long len,
 				IT87_CIR_TSR_TXFBC);
 
 			while ((inb(io + IT87_CIR_TSR) &
-				IT87_CIR_TSR_TXFBC) >= IT87_CIR_FIFO_SIZE);
-			{
-				unsigned long hw_flags;
-
-				spin_lock_irqsave(&hardware_lock, hw_flags);
-				outb(byte_out, io + IT87_CIR_DR);
-				spin_unlock_irqrestore(&hardware_lock, hw_flags);
-			}
+				IT87_CIR_TSR_TXFBC) >= IT87_CIR_FIFO_SIZE)
+				;
+
+			spin_lock_irqsave(&hardware_lock, hw_flags);
+			outb(byte_out, io + IT87_CIR_DR);
+			spin_unlock_irqrestore(&hardware_lock, hw_flags);
+
 			it87_bits_in_byte_out = 0;
 			it87_send_counter++;
 			byte_out = 0;
@@ -707,18 +677,12 @@ it8705 only modulates 0-bits
 
 static void send_space(unsigned long len)
 {
-	send_it87(len,
-		  TIME_CONST,
-		  IT87_CIR_SPACE,
-		  IT87_CIR_BAUDRATE_DIVISOR);
+	send_it87(len, TIME_CONST, IT87_CIR_SPACE, IT87_CIR_BAUDRATE_DIVISOR);
 }
 
 static void send_pulse(unsigned long len)
 {
-	send_it87(len,
-		  TIME_CONST,
-		  IT87_CIR_PULSE,
-		  IT87_CIR_BAUDRATE_DIVISOR);
+	send_it87(len, TIME_CONST, IT87_CIR_PULSE, IT87_CIR_BAUDRATE_DIVISOR);
 }
 
 
@@ -761,7 +725,7 @@ static int init_hardware(void)
 {
 	unsigned long flags;
 	unsigned char it87_rcr = 0;
-	
+
 	spin_lock_irqsave(&hardware_lock, flags);
 	/* init cir-port */
 	/* enable r/w-access to Baudrate-Register */
@@ -772,8 +736,7 @@ static int init_hardware(void)
 	if (digimatrix) {
 		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RFOIE, io + IT87_CIR_IER);
 		/* RX: HCFS=0, RXDCR = 001b (33,75..38,25 kHz), RXEN=1 */
-	}
-	else {
+	} else {
 		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
 		/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
 	}
@@ -786,12 +749,11 @@ static int init_hardware(void)
 		outb(inb(io + IT87_CIR_TCR1) |  0x00,
 		     io + IT87_CIR_TCR1);
 
-		/* TX: it87_freq (36kHz), 
+		/* TX: it87_freq (36kHz),
 		   'reserved' sensitivity setting (0x00) */
 		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x00,
 		     io + IT87_CIR_TCR2);
-	}
-	else {
+	} else {
 		/* TX: 38kHz, 13,3us (pulse-width */
 		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
 		     io + IT87_CIR_TCR2);
@@ -804,7 +766,7 @@ static int init_hardware(void)
 static void drop_hardware(void)
 {
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&hardware_lock, flags);
 	disable_irq(irq);
 	/* receiver disable */
@@ -813,9 +775,9 @@ static void drop_hardware(void)
 	/* turn off irqs */
 	outb(0, io + IT87_CIR_IER);
 	/* fifo clear */
-        outb(IT87_CIR_TCR1_FIFOCLR, io+IT87_CIR_TCR1);
-        /* reset */
-        outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
+	outb(IT87_CIR_TCR1_FIFOCLR, io+IT87_CIR_TCR1);
+	/* reset */
+	outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
 	enable_irq(irq);
 	spin_unlock_irqrestore(&hardware_lock, flags);
 }
@@ -828,8 +790,7 @@ static unsigned char it87_read(unsigned char port)
 }
 
 
-static void it87_write(unsigned char port,
-		       unsigned char data)
+static void it87_write(unsigned char port, unsigned char data)
 {
 	outb(port, IT87_ADRPORT);
 	outb(data, IT87_DATAPORT);
@@ -842,19 +803,19 @@ static int init_port(void)
 {
 	unsigned long hw_flags;
 	int retval = 0;
-	
+
 	unsigned char init_bytes[4] = {IT87_INIT};
 	unsigned char it87_chipid = 0;
 	unsigned char ldn = 0;
 	unsigned int  it87_io = 0;
 	unsigned int  it87_irq = 0;
-	
+
 	/* Enter MB PnP Mode */
 	outb(init_bytes[0], IT87_ADRPORT);
 	outb(init_bytes[1], IT87_ADRPORT);
 	outb(init_bytes[2], IT87_ADRPORT);
 	outb(init_bytes[3], IT87_ADRPORT);
-	
+
 	/* 8712 or 8705 ? */
 	it87_chipid = it87_read(IT87_CHIP_ID1);
 	if (it87_chipid != 0x87) {
@@ -878,9 +839,9 @@ static int init_port(void)
 	else
 		ldn = IT8705_CIR_LDN;
 	it87_write(IT87_LDN, ldn);
-	
+
 	it87_io = it87_read(IT87_CIR_BASE_MSB) * 256 +
-		it87_read(IT87_CIR_BASE_LSB);
+		  it87_read(IT87_CIR_BASE_LSB);
 	if (it87_io == 0) {
 		if (io == 0)
 			io = IT87_CIR_DEFAULT_IOBASE;
@@ -889,10 +850,9 @@ static int init_port(void)
 		       io);
 		it87_write(IT87_CIR_BASE_MSB, io / 0x100);
 		it87_write(IT87_CIR_BASE_LSB, io % 0x100);
-	}
-	else
+	} else
 		io = it87_io;
-	
+
 	it87_irq = it87_read(IT87_CIR_IRQ);
 	if (digimatrix || it87_irq == 0) {
 		if (irq == 0)
@@ -901,11 +861,8 @@ static int init_port(void)
 		       ": set default irq 0x%x\n",
 		       irq);
 		it87_write(IT87_CIR_IRQ, irq);
-	}
-	else
-	{
+	} else
 		irq = it87_irq;
-	}
 
 	spin_lock_irqsave(&hardware_lock, hw_flags);
 	/* reset */
@@ -916,13 +873,11 @@ static int init_port(void)
 	     IT87_CIR_TCR1_TXRLE |
 	     IT87_CIR_TCR1_TXENDF, io+IT87_CIR_TCR1);
 	spin_unlock_irqrestore(&hardware_lock, hw_flags);
-	
+
 	/* get I/O port access and IRQ line */
-	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL)
-	{
+	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {
 		printk(KERN_ERR LIRC_DRIVER_NAME
-		       ": i/o port 0x%.4x already in use.\n",
-		       io);
+		       ": i/o port 0x%.4x already in use.\n", io);
 		/* Leaving MB PnP Mode */
 		it87_write(IT87_CFGCTRL, 0x2);
 		return -EBUSY;
@@ -934,7 +889,7 @@ static int init_port(void)
 	/* Leaving MB PnP Mode */
 	it87_write(IT87_CFGCTRL, 0x2);
 
-	retval = request_irq(irq, it87_interrupt, 0 /*SA_INTERRUPT*/,
+	retval = request_irq(irq, it87_interrupt, 0 /*IRQF_DISABLED*/,
 			     LIRC_DRIVER_NAME, NULL);
 	if (retval < 0) {
 		printk(KERN_ERR LIRC_DRIVER_NAME
@@ -945,14 +900,12 @@ static int init_port(void)
 	}
 
 	printk(KERN_INFO LIRC_DRIVER_NAME
-	       ": I/O port 0x%.4x, IRQ %d.\n",
-	       io,
-	       irq);
+	       ": I/O port 0x%.4x, IRQ %d.\n", io, irq);
 
 	init_timer(&timerlist);
 	timerlist.function = it87_timeout;
 	timerlist.data = 0xabadcafe;
-	
+
 	return 0;
 }
 
@@ -960,19 +913,19 @@ static int init_port(void)
 static void drop_port(void)
 {
 /*
-        unsigned char init_bytes[4] = {IT87_INIT};
- 
-        / * Enter MB PnP Mode * /
-        outb(init_bytes[0], IT87_ADRPORT);
-        outb(init_bytes[1], IT87_ADRPORT);
-        outb(init_bytes[2], IT87_ADRPORT);
-        outb(init_bytes[3], IT87_ADRPORT);
-
-        / * deactivate CIR-Device * /
-        it87_write(IT87_CIR_ACT, 0x0);
-
-        / * Leaving MB PnP Mode * /
-        it87_write(IT87_CFGCTRL, 0x2);
+	unsigned char init_bytes[4] = {IT87_INIT};
+
+	/ * Enter MB PnP Mode * /
+	outb(init_bytes[0], IT87_ADRPORT);
+	outb(init_bytes[1], IT87_ADRPORT);
+	outb(init_bytes[2], IT87_ADRPORT);
+	outb(init_bytes[3], IT87_ADRPORT);
+
+	/ * deactivate CIR-Device * /
+	it87_write(IT87_CIR_ACT, 0x0);
+
+	/ * Leaving MB PnP Mode * /
+	it87_write(IT87_CFGCTRL, 0x2);
 */
 
 	del_timer_sync(&timerlist);
@@ -984,14 +937,13 @@ static void drop_port(void)
 static int init_lirc_it87(void)
 {
 	int retval;
-	
+
 	init_waitqueue_head(&lirc_read_queue);
 	retval = init_port();
 	if (retval < 0)
 		return retval;
 	init_hardware();
-	printk(KERN_INFO LIRC_DRIVER_NAME
-	       ": Installed.\n");
+	printk(KERN_INFO LIRC_DRIVER_NAME ": Installed.\n");
 	return 0;
 }
 
@@ -1001,9 +953,9 @@ static int init_lirc_it87(void)
 int init_module(void)
 {
 	int retval;
-	
-	retval=init_chrdev();
-	if(retval < 0)
+
+	retval = init_chrdev();
+	if (retval < 0)
 		return retval;
 	retval = init_lirc_it87();
 	if (retval) {
@@ -1037,7 +989,7 @@ MODULE_PARM_DESC(irq, "Interrupt (1,3-12) (default: 7)");
 #endif
 
 module_param(it87_enable_demodulator, bool, 0444);
-MODULE_PARM_DESC(it87_enable_demodulator, 
+MODULE_PARM_DESC(it87_enable_demodulator,
 		 "Receiver demodulator enable/disable (1/0), default: 0");
 
 module_param(debug, bool, 0644);
@@ -1045,10 +997,10 @@ MODULE_PARM_DESC(debug, "Enable debugging messages");
 
 module_param(digimatrix, bool, 0644);
 #ifdef LIRC_IT87_DIGIMATRIX
-MODULE_PARM_DESC(digimatrix, 
+MODULE_PARM_DESC(digimatrix,
 	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 1");
 #else
-MODULE_PARM_DESC(digimatrix, 
+MODULE_PARM_DESC(digimatrix,
 	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 0");
 #endif
 
diff --git a/drivers/char/lirc/lirc_mceusb.c b/drivers/char/lirc/lirc_mceusb.c
index 396fb84..60f3b3c 100644
--- a/drivers/char/lirc/lirc_mceusb.c
+++ b/drivers/char/lirc/lirc_mceusb.c
@@ -23,25 +23,25 @@
  * portions of that code have been removed as the driver has evolved.
  *
  * 2003_11_11 - Restructured to minimalize code interpretation in the
- *              driver. The normal use case will be with lirc.
+ *	      driver. The normal use case will be with lirc.
  *
  * 2004_01_01 - Removed all code interpretation. Generate mode2 data
- *              for passing off to lirc. Cleanup
+ *	      for passing off to lirc. Cleanup
  *
  * 2004_01_04 - Removed devfs handle. Put in a temporary workaround
- *              for a known issue where repeats generate two
- *              sequential spaces (last_was_repeat_gap)
+ *	      for a known issue where repeats generate two
+ *	      sequential spaces (last_was_repeat_gap)
  *
  * 2004_02_17 - Changed top level api to no longer use fops, and
- *              instead use new interface for polling via
- *              lirc_thread. Restructure data read/mode2 generation to
- *              a single pass, reducing number of buffers. Rev to .2
+ *	      instead use new interface for polling via
+ *	      lirc_thread. Restructure data read/mode2 generation to
+ *	      a single pass, reducing number of buffers. Rev to .2
  *
  * 2004_02_27 - Last of fixups to plugin->add_to_buf API. Properly
- *              handle broken fragments from the receiver. Up the
- *              sample rate and remove any pacing from
- *              fetch_more_data. Fixes all known issues.
- * 
+ *	      handle broken fragments from the receiver. Up the
+ *	      sample rate and remove any pacing from
+ *	      fetch_more_data. Fixes all known issues.
+ *
  * TODO
  *   - Fix up minor number, registration of major/minor with usb subsystem
  *
@@ -98,8 +98,12 @@
 #include <linux/usb.h>
 #ifdef KERNEL_2_5
 #include <linux/completion.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 #include <asm/uaccess.h>
 #else
+#include <linux/uaccess.h>
+#endif
+#else
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/fcntl.h>
@@ -109,21 +113,22 @@
 #endif
 
 #ifdef CONFIG_USB_DEBUG
-	static int debug = 1;
+static int debug = 1;
 #else
-	static int debug = 0;
+static int debug;
 #endif
 
-#include <linux/lirc.h>
 #include "kcompat.h"
+#include <linux/lirc.h>
 #include "lirc_dev.h"
 
 /* Use our own dbg macro */
-#define dprintk(fmt, args...)                             \
-	do{                                               \
-		if(debug) printk(KERN_DEBUG __FILE__ ": " \
-				 fmt "\n", ## args);      \
-	}while(0)
+#define dprintk(fmt, args...)				\
+	do {						\
+		if (debug)				\
+			printk(KERN_DEBUG __FILE__ ": "	\
+			       fmt "\n", ## args);	\
+	} while (0)
 
 /* Version Information */
 #define DRIVER_VERSION "v0.2"
@@ -136,9 +141,9 @@
 #define USB_MCEUSB_PRODUCT_ID	0x006d
 
 /* table of devices that work with this driver */
-static struct usb_device_id mceusb_table [] = {
+static struct usb_device_id mceusb_table[] = {
 	{ USB_DEVICE(USB_MCEUSB_VENDOR_ID, USB_MCEUSB_PRODUCT_ID) },
-	{ }					/* Terminating entry */
+	{ }	/* Terminating entry */
 };
 
 /* we can have up to this number of device plugged in at once */
@@ -146,46 +151,45 @@ static struct usb_device_id mceusb_table [] = {
 
 /* Structure to hold all of our device specific stuff */
 struct usb_skel {
-	struct usb_device *	    udev;		/* save off the usb device pointer */
-	struct usb_interface *	interface;		/* the interface for this device */
-	unsigned char   minor;				/* the starting minor number for this device */
-	unsigned char   num_ports;			/* the number of ports this device has */
-	char            num_interrupt_in;		/* number of interrupt in endpoints we have */
-	char            num_bulk_in;			/* number of bulk in endpoints we have */
-	char            num_bulk_out;			/* number of bulk out endpoints we have */
-
-	unsigned char *    bulk_in_buffer;		/* the buffer to receive data */
-	int                bulk_in_size;		/* the size of the receive buffer */
-	__u8               bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
-
-	unsigned char *    bulk_out_buffer;		/* the buffer to send data */
-	int	               bulk_out_size;		/* the size of the send buffer */
-	struct urb *       write_urb;			/* the urb used to send data */
-	__u8               bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
-
-	atomic_t		write_busy;		/* true iff write urb is busy */
-	struct completion	write_finished;		/* wait for the write to finish */
-	
-	wait_queue_head_t  wait_q;			/* for timeouts */
-	int                open_count;			/* number of times this port has been opened */
-	struct semaphore   sem;				/* locks this structure */
-	
-	int			present;		/* if the device is not disconnected */		
-
-	struct lirc_plugin* plugin;
-	
-	lirc_t lircdata[256];          			/* place to store values until lirc processes them */
-	int    lircidx;                			/* current index */
-	int    lirccnt;                			/* remaining values */
-	
-	int    usb_valid_bytes_in_bulk_buffer;		/* leftover data from a previous read */
-	int    mce_bytes_left_in_packet;		/* for packets split across multiple reads */
-	
+	struct usb_device *udev; /* save off the usb device pointer */
+	struct usb_interface *interface; /* the interface for this device */
+	unsigned char minor;	 /* the starting minor number for this device */
+	unsigned char num_ports; /* the number of ports this device has */
+	char num_interrupt_in;	 /* number of interrupt in endpoints */
+	char num_bulk_in;	 /* number of bulk in endpoints */
+	char num_bulk_out;	 /* number of bulk out endpoints */
+
+	unsigned char *bulk_in_buffer;	/* the buffer to receive data */
+	int bulk_in_size;		/* the size of the receive buffer */
+	__u8 bulk_in_endpointAddr;	/* the address of bulk in endpoint */
+
+	unsigned char *bulk_out_buffer;	/* the buffer to send data */
+	int bulk_out_size;		/* the size of the send buffer */
+	struct urb *write_urb;		/* the urb used to send data */
+	__u8 bulk_out_endpointAddr;	/* the address of bulk out endpoint */
+
+	atomic_t write_busy;		/* true iff write urb is busy */
+	struct completion write_finished; /* wait for the write to finish */
+
+	wait_queue_head_t wait_q; /* for timeouts */
+	int open_count;		/* number of times this port has been opened */
+	struct semaphore sem;	/* locks this structure */
+
+	int present;		/* if the device is not disconnected */
+
+	struct lirc_plugin *plugin;
+
+	lirc_t lircdata[256]; /* place to store data until lirc processes it */
+	int lircidx;		/* current index */
+	int lirccnt;		/* remaining values */
+
+	int usb_valid_bytes_in_bulk_buffer; /* leftover data from prior read */
+	int mce_bytes_left_in_packet;	/* for packets split across reads */
+
 	/* Value to hold the last received space; 0 if last value
-	 * received was a pulse
-	 */
-	int    last_space;
-	
+	 * received was a pulse */
+	int last_space;
+
 #ifdef KERNEL_2_5
 	dma_addr_t dma_in;
 	dma_addr_t dma_out;
@@ -196,117 +200,120 @@ struct usb_skel {
 
 /* driver api */
 #ifdef KERNEL_2_5
-static int mceusb_probe		(struct usb_interface *interface, const struct usb_device_id *id);
-static void mceusb_disconnect	(struct usb_interface *interface);
+static int mceusb_probe(struct usb_interface *interface,
+			const struct usb_device_id *id);
+static void mceusb_disconnect(struct usb_interface *interface);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void mceusb_write_bulk_callback	(struct urb *urb, struct pt_regs *regs);
+static void mceusb_write_bulk_callback(struct urb *urb, struct pt_regs *regs);
 #else
-static void mceusb_write_bulk_callback	(struct urb *urb);
+static void mceusb_write_bulk_callback(struct urb *urb);
 #endif
 #else
-static void * mceusb_probe	(struct usb_device *dev, unsigned int ifnum, const struct usb_device_id *id);
-static void mceusb_disconnect	(struct usb_device *dev, void *ptr);
-static void mceusb_write_bulk_callback	(struct urb *urb);
+static void *mceusb_probe(struct usb_device *dev, unsigned int ifnum,
+			  const struct usb_device_id *id);
+static void mceusb_disconnect(struct usb_device *dev, void *ptr);
+static void mceusb_write_bulk_callback(struct urb *urb);
 #endif
 
 /* read data from the usb bus; convert to mode2 */
-static int msir_fetch_more_data( struct usb_skel* dev, int dont_block );
+static int msir_fetch_more_data(struct usb_skel *dev, int dont_block);
 
 /* helper functions */
-static void msir_cleanup( struct usb_skel* dev );
-static void set_use_dec( void* data );
-static int set_use_inc( void* data );
-    
+static void msir_cleanup(struct usb_skel *dev);
+static void set_use_dec(void *data);
+static int set_use_inc(void *data);
+
 /* array of pointers to our devices that are currently connected */
-static struct usb_skel		*minor_table[MAX_DEVICES];
+static struct usb_skel *minor_table[MAX_DEVICES];
 
 /* lock to protect the minor_table structure */
-static DECLARE_MUTEX (minor_table_mutex);
-static void mceusb_setup( struct usb_device *udev );
+static DECLARE_MUTEX(minor_table_mutex);
+static void mceusb_setup(struct usb_device *udev);
 
 /* usb specific object needed to register this driver with the usb subsystem */
 static struct usb_driver mceusb_driver = {
 	LIRC_THIS_MODULE(.owner = THIS_MODULE)
-	.name =		DRIVER_NAME,
-	.probe =	mceusb_probe,
-	.disconnect =	mceusb_disconnect,
-	.id_table =	mceusb_table,
+	.name		= DRIVER_NAME,
+	.probe		= mceusb_probe,
+	.disconnect	= mceusb_disconnect,
+	.id_table	= mceusb_table,
 };
 
 
 /**
  *	usb_mceusb_debug_data
  */
-static inline void usb_mceusb_debug_data (const char *function, int size,
+static inline void usb_mceusb_debug_data(const char *function, int size,
 					  const unsigned char *data)
 {
 	int i;
 	if (!debug)
 		return;
-	
-	printk(KERN_DEBUG __FILE__": %s - length = %d, data = ", 
+
+	printk(KERN_DEBUG __FILE__": %s - length = %d, data = ",
 	       function, size);
-	for (i = 0; i < size; ++i) {
+	for (i = 0; i < size; ++i)
 		printk(KERN_DEBUG "%.2x ", data[i]);
-	}
 	printk(KERN_DEBUG "\n");
 }
 
 /**
  *mceusb_delete
  */
-static inline void mceusb_delete (struct usb_skel *dev)
+static inline void mceusb_delete(struct usb_skel *dev)
 {
 	dprintk("%s", __func__);
 	minor_table[dev->minor] = NULL;
 #ifdef KERNEL_2_5
-	usb_buffer_free(dev->udev, dev->bulk_in_size, dev->bulk_in_buffer, dev->dma_in);
-	usb_buffer_free(dev->udev, dev->bulk_out_size, dev->bulk_out_buffer, dev->dma_out);
+	usb_buffer_free(dev->udev, dev->bulk_in_size,
+			dev->bulk_in_buffer, dev->dma_in);
+	usb_buffer_free(dev->udev, dev->bulk_out_size,
+			dev->bulk_out_buffer, dev->dma_out);
 #else
 	if (dev->bulk_in_buffer != NULL)
-		kfree (dev->bulk_in_buffer);
+		kfree(dev->bulk_in_buffer);
 	if (dev->bulk_out_buffer != NULL)
-		kfree (dev->bulk_out_buffer);
+		kfree(dev->bulk_out_buffer);
 #endif
 	if (dev->write_urb != NULL)
-		usb_free_urb (dev->write_urb);
-	kfree (dev);
+		usb_free_urb(dev->write_urb);
+	kfree(dev);
 }
 
-static void mceusb_setup( struct usb_device *udev )
+static void mceusb_setup(struct usb_device *udev)
 {
 	char data[8];
 	int res;
-	
-	memset( data, 0, 8 );
+
+	memset(data, 0, 8);
 
 	/* Get Status */
 	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			      USB_REQ_GET_STATUS, USB_DIR_IN,
 			      0, 0, data, 2, HZ * 3);
-    
+
 	/*    res = usb_get_status( udev, 0, 0, data ); */
 	dprintk("%s - res = %d status = 0x%x 0x%x", __func__,
 		res, data[0], data[1]);
-    
+
 	/* This is a strange one. They issue a set address to the device
 	 * on the receive control pipe and expect a certain value pair back
 	 */
-	memset( data, 0, 8 );
+	memset(data, 0, 8);
 
-	res = usb_control_msg( udev, usb_rcvctrlpipe(udev, 0),
-			       5, USB_TYPE_VENDOR, 0, 0,
-			       data, 2, HZ * 3 );
+	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+			      5, USB_TYPE_VENDOR, 0, 0,
+			      data, 2, HZ * 3);
 	dprintk("%s - res = %d, devnum = %d", __func__, res, udev->devnum);
 	dprintk("%s - data[0] = %d, data[1] = %d", __func__,
-		data[0], data[1] );
+		data[0], data[1]);
+
 
-    
 	/* set feature */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			       0xc04e, 0x0000, NULL, 0, HZ * 3 );
-    
+	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+			      USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+			      0xc04e, 0x0000, NULL, 0, HZ * 3);
+
 	dprintk("%s - res = %d", __func__, res);
 
 	/* These two are sent by the windows driver, but stall for
@@ -316,42 +323,42 @@ static void mceusb_setup( struct usb_device *udev )
 	 */
 #if 0
 	/* this is some custom control message they send */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       0x04, USB_TYPE_VENDOR,
-			       0x0808, 0x0000, NULL, 0, HZ * 3 );
-    
+	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+			      0x04, USB_TYPE_VENDOR,
+			      0x0808, 0x0000, NULL, 0, HZ * 3);
+
 	dprintk("%s - res = %d", __func__, res);
-    
+
 	/* this is another custom control message they send */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       0x02, USB_TYPE_VENDOR,
-			       0x0000, 0x0100, NULL, 0, HZ * 3 );
-    
+	res = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+			      0x02, USB_TYPE_VENDOR,
+			      0x0000, 0x0100, NULL, 0, HZ * 3);
+
 	dprintk("%s - res = %d", __func__, res);
 #endif
 }
 
-static void msir_cleanup( struct usb_skel* dev )
+static void msir_cleanup(struct usb_skel *dev)
 {
-	memset( dev->bulk_in_buffer, 0, dev->bulk_in_size );
+	memset(dev->bulk_in_buffer, 0, dev->bulk_in_size);
 
 	dev->usb_valid_bytes_in_bulk_buffer = 0;
 
 	dev->last_space = PULSE_MASK;
-    
+
 	dev->mce_bytes_left_in_packet = 0;
 	dev->lircidx = 0;
 	dev->lirccnt = 0;
-	memset( dev->lircdata, 0, sizeof(dev->lircdata) );
+	memset(dev->lircdata, 0, sizeof(dev->lircdata));
 }
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 	MOD_DEC_USE_COUNT;
 }
@@ -372,108 +379,87 @@ static void set_use_dec(void* data)
  * This routine always returns the number of words available
  *
  */
-static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
+static int msir_fetch_more_data(struct usb_skel *dev, int dont_block)
 {
 	int retries = 0;
-	int words_to_read = 
+	int words_to_read =
 		(sizeof(dev->lircdata)/sizeof(lirc_t)) - dev->lirccnt;
 	int partial, this_read = 0;
 	int bulkidx = 0;
 	int bytes_left_in_packet = 0;
-	signed char* signedp = (signed char*)dev->bulk_in_buffer;
-	
-	if( words_to_read == 0 )
+	signed char *signedp = (signed char*)dev->bulk_in_buffer;
+
+	if (words_to_read == 0)
 		return dev->lirccnt;
 
 	/* this forces all existing data to be read by lirc before we
 	 * issue another usb command. this is the only form of
 	 * throttling we have
 	 */
-	if( dev->lirccnt )
-	{
+	if (dev->lirccnt)
 		return dev->lirccnt;
-	}
 
 	/* reserve room for our leading space */
-	if( dev->last_space )
+	if (dev->last_space)
 		words_to_read--;
-		
-	while( words_to_read )
-	{
+
+	while (words_to_read) {
 		/* handle signals and USB disconnects */
-		if( signal_pending(current) )
-		{
+		if (signal_pending(current))
 			return dev->lirccnt ? dev->lirccnt : -EINTR;
-		}
-		if( !dev->udev )
-		{
+		if (!dev->udev)
 			return -ENODEV;
-		}
 
 		bulkidx = 0;
 
 		/*
 		 * perform data read (phys or from previous buffer)
 		 */
-        
+
 		/* use leftovers if present, otherwise perform a read */
-		if( dev->usb_valid_bytes_in_bulk_buffer )
-		{
-			this_read = partial = 
-				dev->usb_valid_bytes_in_bulk_buffer;
+		if (dev->usb_valid_bytes_in_bulk_buffer) {
+			this_read = dev->usb_valid_bytes_in_bulk_buffer;
+			partial = this_read;
 			dev->usb_valid_bytes_in_bulk_buffer = 0;
-		}
-		else
-		{
+		} else {
 			int retval;
-            
+
 			this_read = dev->bulk_in_size;
 			partial = 0;
-			retval = usb_bulk_msg
-				(dev->udev,
-				 usb_rcvbulkpipe
-				 (dev->udev, dev->bulk_in_endpointAddr),
-				 (unsigned char*)dev->bulk_in_buffer,
-				 this_read, &partial, HZ*10);
-			
+			retval = usb_bulk_msg(dev->udev,
+					usb_rcvbulkpipe(dev->udev,
+						dev->bulk_in_endpointAddr),
+					(unsigned char *)dev->bulk_in_buffer,
+					this_read, &partial, HZ*10);
+
 			/* retry a few times on overruns; map all
 			   other errors to -EIO */
-			if( retval )
-			{
-				if( retval == -EOVERFLOW && 
-				    retries < 5 )
-				{
+			if (retval) {
+				if (retval == -EOVERFLOW && retries < 5) {
 					retries++;
-					interruptible_sleep_on_timeout
-						( &dev->wait_q, HZ );
+					interruptible_sleep_on_timeout(
+						&dev->wait_q, HZ);
 					continue;
-				}
-				else
-				{
+				} else
 					return -EIO;
-				}
 			}
-            
+
 			retries = 0;
-			if( partial )
+			if (partial)
 				this_read = partial;
 
 			/* skip the header */
 			bulkidx += 2;
-            
+
 			/* check for empty reads (header only) */
-			if( this_read == 2 )
-			{
+			if (this_read == 2) {
 				/* assume no data */
-				if( dont_block )
-				{
+				if (dont_block)
 					break;
-				}
 
 				/* sleep for a bit before performing
 				   another read */
-				interruptible_sleep_on_timeout
-					( &dev->wait_q, 1 );
+				interruptible_sleep_on_timeout(&dev->wait_q, 1);
 				continue;
 			}
 		}
@@ -481,19 +467,16 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
 		/*
 		 * process data
 		 */
-        
+
 		/* at this point this_read is > 0 */
-		while( bulkidx < this_read &&
-		       (words_to_read > (dev->last_space ? 1 : 0)) )
-			//while( bulkidx < this_read && words_to_read )
-		{
+		while (bulkidx < this_read &&
+		       (words_to_read > (dev->last_space ? 1 : 0))) {
+			/* while( bulkidx < this_read && words_to_read) */
 			int keycode;
 			int pulse = 0;
-            
+
 			/* read packet length if needed */
-			if( !bytes_left_in_packet )
-			{
-				
+			if (!bytes_left_in_packet) {
 				/* we assume we are on a packet length
 				 * value. it is possible, in some
 				 * cases, to get a packet that does
@@ -502,7 +485,7 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
 				 * but occaisonally we do not receive
 				 * the second half of a fragment
 				 */
-				bytes_left_in_packet = 
+				bytes_left_in_packet =
 					128 + signedp[bulkidx++];
 
 				/* unfortunately rather than keep all
@@ -517,11 +500,10 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
 				 * up, and 2) the bytes_left value for
 				 * this packet is obviously wrong
 				 */
-				if( bytes_left_in_packet > 4  )
-				{
-					if( dev->mce_bytes_left_in_packet )
-					{
-						bytes_left_in_packet = dev->mce_bytes_left_in_packet;
+				if (bytes_left_in_packet > 4) {
+					if (dev->mce_bytes_left_in_packet) {
+						bytes_left_in_packet =
+						  dev->mce_bytes_left_in_packet;
 						bulkidx--;
 					}
 					bytes_left_in_packet = 0;
@@ -531,31 +513,28 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
 				/* always clear this if we have a
 				   valid packet */
 				dev->mce_bytes_left_in_packet = 0;
-                    
+
 				/* continue here to verify we haven't
 				   hit the end of the bulk_in */
 				continue;
-				
+
 			}
 
 			/*
 			 * generate mode2
 			 */
-            
+
 			keycode = signedp[bulkidx++];
-			if( keycode < 0 )
-			{
+			if (keycode < 0) {
 				pulse = 1;
 				keycode += 128;
 			}
 			keycode *= MCE_TIME_UNIT;
 
 			bytes_left_in_packet--;
-            
-			if( pulse )
-			{
-				if( dev->last_space )
-				{
+
+			if (pulse) {
+				if (dev->last_space) {
 					dev->lircdata[dev->lirccnt++] =
 						dev->last_space;
 					dev->last_space = 0;
@@ -566,34 +545,28 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
 				}
 				dev->lircdata[dev->lirccnt] += keycode;
 				dev->lircdata[dev->lirccnt] |= PULSE_BIT;
-			}
-			else
-			{
+			} else {
 				/* on pulse->space transition, add one
 				   for the existing pulse */
-				if( dev->lircdata[dev->lirccnt] &&
-				    !dev->last_space )
-				{
+				if (dev->lircdata[dev->lirccnt] &&
+				    !dev->last_space) {
 					dev->lirccnt++;
 					words_to_read--;
 				}
-                
+
 				dev->last_space += keycode;
 			}
 		}
 	}
-	
+
 	/* save off some info if we are exiting mid-packet, or with
 	   leftovers */
-	if( bytes_left_in_packet )
-	{
+	if (bytes_left_in_packet)
 		dev->mce_bytes_left_in_packet = bytes_left_in_packet;
-	}
-	if( bulkidx < this_read )
-	{
+	if (bulkidx < this_read) {
 		dev->usb_valid_bytes_in_bulk_buffer = (this_read - bulkidx);
-		memcpy( dev->bulk_in_buffer, &(dev->bulk_in_buffer[bulkidx]),
-			dev->usb_valid_bytes_in_bulk_buffer );
+		memcpy(dev->bulk_in_buffer, &(dev->bulk_in_buffer[bulkidx]),
+		       dev->usb_valid_bytes_in_bulk_buffer);
 	}
 	return dev->lirccnt;
 }
@@ -604,54 +577,51 @@ static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
  * check for new data returns 0 on success, or -ENODATA if nothing is
  * available
  */
-static int mceusb_add_to_buf(void* data, struct lirc_buffer* buf )
+static int mceusb_add_to_buf(void *data, struct lirc_buffer *buf)
 {
-	struct usb_skel* dev = (struct usb_skel*) data;
+	struct usb_skel *dev = (struct usb_skel *) data;
 
-	down( &dev->sem );
+	down(&dev->sem);
 
 	/* verify device still present */
-	if( dev->udev == NULL )
-	{
-		up( &dev->sem );
+	if (dev->udev == NULL) {
+		up(&dev->sem);
 		return -ENODEV;
 	}
 
-	if( !dev->lirccnt )
-	{
+	if (!dev->lirccnt) {
 		int res;
 		dev->lircidx = 0;
-        
-		res = msir_fetch_more_data( dev, 1 );
-		
-		if( res == 0 )
+
+		res = msir_fetch_more_data(dev, 1);
+
+		if (res == 0)
 			res = -ENODATA;
-		if( res < 0 ) {
-			up( &dev->sem );
+		if (res < 0) {
+			up(&dev->sem);
 			return res;
 		}
 	}
 
-	if( dev->lirccnt )
-	{
+	if (dev->lirccnt) {
 		int keys_to_copy;
 
 		/* determine available buffer space and available data */
-		keys_to_copy = lirc_buffer_available( buf );
-		if( keys_to_copy > dev->lirccnt )
-		{
+		keys_to_copy = lirc_buffer_available(buf);
+		if (keys_to_copy > dev->lirccnt)
 			keys_to_copy = dev->lirccnt;
-		}
-        
-		lirc_buffer_write_n( buf, (unsigned char*) &(dev->lircdata[dev->lircidx]), keys_to_copy );
+
+		lirc_buffer_write_n(buf,
+			(unsigned char *) &(dev->lircdata[dev->lircidx]),
+			keys_to_copy);
 		dev->lircidx += keys_to_copy;
 		dev->lirccnt -= keys_to_copy;
-        
-		up( &dev->sem );
+
+		up(&dev->sem);
 		return 0;
 	}
 
-	up( &dev->sem );
+	up(&dev->sem);
 	return -ENODATA;
 }
 
@@ -659,16 +629,16 @@ static int mceusb_add_to_buf(void* data, struct lirc_buffer* buf )
  *	mceusb_write_bulk_callback
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void mceusb_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+static void mceusb_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 #else
-static void mceusb_write_bulk_callback (struct urb *urb)
+static void mceusb_write_bulk_callback(struct urb *urb)
 #endif
 {
 	struct usb_skel *dev = (struct usb_skel *)urb->context;
 
 	dprintk("%s - minor %d", __func__, dev->minor);
 
-	if ((urb->status != -ENOENT) && 
+	if ((urb->status != -ENOENT) &&
 	    (urb->status != -ECONNRESET)) {
 		dprintk("%s - nonzero write buld status received: %d",
 			__func__, urb->status);
@@ -681,36 +651,39 @@ static void mceusb_write_bulk_callback (struct urb *urb)
 /**
  *	mceusb_probe
  *
- *	Called by the usb core when a new device is connected that it 
+ *	Called by the usb core when a new device is connected that it
  *	thinks this driver might be interested in.
  */
-#ifdef KERNEL_2_5 
-static int mceusb_probe(struct usb_interface *interface, const struct usb_device_id *id)
+#ifdef KERNEL_2_5
+static int mceusb_probe(struct usb_interface *interface,
+			const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(interface);
 	struct usb_host_interface *iface_desc;
 #else
-static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
-			   const struct usb_device_id *id)
+static void *mceusb_probe(struct usb_device *udev, unsigned int ifnum,
+			  const struct usb_device_id *id)
 {
 	struct usb_interface *interface = &udev->actconfig->interface[ifnum];
-	struct usb_interface_descriptor *iface_desc;	
+	struct usb_interface_descriptor *iface_desc;
 #endif
 	struct usb_skel *dev = NULL;
 	struct usb_endpoint_descriptor *endpoint;
-	
-	struct lirc_plugin* plugin;
-	struct lirc_buffer* rbuf;
+
+	struct lirc_plugin *plugin;
+	struct lirc_buffer *rbuf;
 
 	int minor;
 	size_t buffer_size;
 	int i;
 	int retval = -ENOMEM;
-	
+	char junk[64];
+	int partial = 0;
+
 	/* See if the device offered us matches what we can accept */
-	if ((cpu_to_le16(udev->descriptor.idVendor) != USB_MCEUSB_VENDOR_ID) ||
-	    (cpu_to_le16(udev->descriptor.idProduct) != USB_MCEUSB_PRODUCT_ID)) {
-	    	dprintk("Wrong Vendor/Product IDs");
+	if (cpu_to_le16(udev->descriptor.idVendor) != USB_MCEUSB_VENDOR_ID ||
+	    cpu_to_le16(udev->descriptor.idProduct) != USB_MCEUSB_PRODUCT_ID) {
+		dprintk("Wrong Vendor/Product IDs");
 #ifdef KERNEL_2_5
 		return -ENODEV;
 #else
@@ -719,30 +692,30 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 	}
 
 	/* select a "subminor" number (part of a minor number) */
-	down (&minor_table_mutex);
+	down(&minor_table_mutex);
 	for (minor = 0; minor < MAX_DEVICES; ++minor) {
 		if (minor_table[minor] == NULL)
 			break;
 	}
 	if (minor >= MAX_DEVICES) {
-		info ("Too many devices plugged in, "
-		      "can not handle this device.");
+		info("Too many devices plugged in, "
+		     "can not handle this device.");
 		goto error;
 	}
 
 	/* allocate memory for our device state and initialize it */
-	dev = kmalloc (sizeof(struct usb_skel), GFP_KERNEL);
+	dev = kmalloc(sizeof(struct usb_skel), GFP_KERNEL);
 	if (dev == NULL) {
-		err ("Out of memory");
+		err("Out of memory");
 #ifdef KERNEL_2_5
 		retval = -ENOMEM;
 #endif
 		goto error;
 	}
 	minor_table[minor] = dev;
-	
-	memset (dev, 0x00, sizeof (*dev));
-	init_MUTEX (&dev->sem);
+
+	memset(dev, 0x00, sizeof(*dev));
+	init_MUTEX(&dev->sem);
 	dev->udev = udev;
 	dev->interface = interface;
 	dev->minor = minor;
@@ -750,10 +723,10 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 	/* set up the endpoint information */
 	/* check out the endpoints */
 	/* use only the first bulk-in and bulk-out endpoints */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
-	iface_desc = interface->cur_altsetting;
-#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
 	iface_desc = &interface->altsetting[0];
+#else
+	iface_desc = interface->cur_altsetting;
 #endif
 
 #ifdef KERNEL_2_5
@@ -771,8 +744,9 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 			dev->bulk_in_size = buffer_size;
 			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
 #ifdef KERNEL_2_5
-			dev->bulk_in_buffer = usb_buffer_alloc
-				(udev, buffer_size, GFP_ATOMIC, &dev->dma_in);
+			dev->bulk_in_buffer =
+				usb_buffer_alloc(udev, buffer_size,
+						 GFP_ATOMIC, &dev->dma_in);
 #else
 			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
 #endif
@@ -781,10 +755,11 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 				goto error;
 			}
 		}
-		
-		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == 0x00) &&
-		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		     USB_ENDPOINT_XFER_BULK)) {
+
+		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+		    == 0x00)
+		    && ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		    USB_ENDPOINT_XFER_BULK)) {
 			dprintk("we found a bulk out endpoint");
 #ifdef KERNEL_2_5
 			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
@@ -799,27 +774,29 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 			dev->bulk_out_size = buffer_size;
 			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
 #ifdef KERNEL_2_5
-			dev->bulk_out_buffer = usb_buffer_alloc(udev, buffer_size, GFP_ATOMIC, &dev->dma_out);
+			dev->bulk_out_buffer =
+				usb_buffer_alloc(udev, buffer_size,
+						 GFP_ATOMIC, &dev->dma_out);
 #else
-			dev->bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
+			dev->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
 #endif
 			if (!dev->bulk_out_buffer) {
 				err("Couldn't allocate bulk_out_buffer");
 				goto error;
 			}
 #ifdef KERNEL_2_5
-			usb_fill_bulk_urb(dev->write_urb, udev, 
+			usb_fill_bulk_urb(dev->write_urb, udev,
 				      usb_sndbulkpipe
 				      (udev, endpoint->bEndpointAddress),
 				      dev->bulk_out_buffer, buffer_size,
 				      mceusb_write_bulk_callback, dev);
 #else
 			FILL_BULK_URB(dev->write_urb, udev,
-				      usb_sndbulkpipe
-				      (udev, endpoint->bEndpointAddress),
+				      usb_sndbulkpipe(udev,
+						endpoint->bEndpointAddress),
 				      dev->bulk_out_buffer, buffer_size,
 				      mceusb_write_bulk_callback, dev);
-#endif 
+#endif
 		}
 	}
 
@@ -829,92 +806,87 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
 	}
 
 	/* init the waitq */
-	init_waitqueue_head( &dev->wait_q );
+	init_waitqueue_head(&dev->wait_q);
 
 
 	/* Set up our lirc plugin */
-	if(!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+	plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL);
+	if (!plugin) {
 		err("out of memory");
 		goto error;
 	}
-	memset( plugin, 0, sizeof(struct lirc_plugin) );
+	memset(plugin, 0, sizeof(struct lirc_plugin));
 
-	if(!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+	rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+	if (!rbuf) {
 		err("out of memory");
-		kfree( plugin );
+		kfree(plugin);
 		goto error;
 	}
-    
+
 	/* the lirc_atiusb module doesn't memset rbuf here ... ? */
-	if( lirc_buffer_init( rbuf, sizeof(lirc_t), 128)) {
+	if (lirc_buffer_init(rbuf, sizeof(lirc_t), 128)) {
 		err("out of memory");
-		kfree( plugin );
-		kfree( rbuf );
+		kfree(plugin);
+		kfree(rbuf);
 		goto error;
 	}
 
 	strcpy(plugin->name, DRIVER_NAME " ");
-	plugin->minor       = minor;
+	plugin->minor = minor;
 	plugin->code_length = sizeof(lirc_t) * 8;
-	plugin->features    = LIRC_CAN_REC_MODE2; // | LIRC_CAN_SEND_MODE2;
-	plugin->data        = dev;
-	plugin->rbuf        = rbuf;
-	plugin->ioctl       = NULL;
+	plugin->features = LIRC_CAN_REC_MODE2; /* | LIRC_CAN_SEND_MODE2; */
+	plugin->data = dev;
+	plugin->rbuf = rbuf;
+	plugin->ioctl = NULL;
 	plugin->set_use_inc = &set_use_inc;
 	plugin->set_use_dec = &set_use_dec;
-	plugin->sample_rate = 80;   // sample at 100hz (10ms)
-	plugin->add_to_buf  = &mceusb_add_to_buf;
-	//    plugin->fops        = &mceusb_fops;
+	plugin->sample_rate = 80;   /* sample at 100hz (10ms) */
+	plugin->add_to_buf = &mceusb_add_to_buf;
+	/* plugin->fops = &mceusb_fops; */
 #ifdef LIRC_HAVE_SYSFS
-	plugin->dev         = &udev->dev;
+	plugin->dev = &udev->dev;
 #endif
-	plugin->owner       = THIS_MODULE;
-	if( lirc_register_plugin(plugin) < 0 )
-	{
-		kfree( plugin );
-		lirc_buffer_free( rbuf );
-		kfree( rbuf );
+	plugin->owner = THIS_MODULE;
+	if (lirc_register_plugin(plugin) < 0) {
+		kfree(plugin);
+		lirc_buffer_free(rbuf);
+		kfree(rbuf);
 		goto error;
 	}
 	dev->plugin = plugin;
-	
+
 	/* clear off the first few messages. these look like
 	 * calibration or test data, i can't really tell
 	 * this also flushes in case we have random ir data queued up
 	 */
-	{
-		char junk[64];
-		int partial = 0, retval, i;
-		for( i = 0; i < 40; i++ )
-		{
-			retval = usb_bulk_msg
-				(udev, usb_rcvbulkpipe
-				 (udev, dev->bulk_in_endpointAddr),
-				 junk, 64,
-				 &partial, HZ*10);
-		}
-	}
-    
-	msir_cleanup( dev );
-	mceusb_setup( udev );
-	
+	for (i = 0; i < 40; i++)
+		(void) usb_bulk_msg(udev,
+				    usb_rcvbulkpipe(udev,
+						    dev->bulk_in_endpointAddr),
+				    junk, 64, &partial, HZ*10);
+
+	msir_cleanup(dev);
+	mceusb_setup(udev);
+
 #ifdef KERNEL_2_5
 	/* we can register the device now, as it is ready */
-	usb_set_intfdata (interface, dev);
-#endif	
+	usb_set_intfdata(interface, dev);
+#endif
 	/* let the user know what node this device is now attached to */
-	//info ("USB Microsoft IR Transceiver device now attached to msir%d", dev->minor);
-	up (&minor_table_mutex);
+	/* info("USB Microsoft IR Transceiver device now attached to msir%d",
+		dev->minor); */
+	up(&minor_table_mutex);
 #ifdef KERNEL_2_5
 	return 0;
 #else
 	return dev;
 #endif
- error:
-	mceusb_delete (dev);
+error:
+	mceusb_delete(dev);
 	dev = NULL;
 	dprintk("%s: retval = %x", __func__, retval);
-	up (&minor_table_mutex);
+	up(&minor_table_mutex);
 #ifdef KERNEL_2_5
 	return retval;
 #else
@@ -933,7 +905,7 @@ static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
  *	not provide any way to do this.  But at least we can cancel an active
  *	write.
  */
-#ifdef KERNEL_2_5 
+#ifdef KERNEL_2_5
 static void mceusb_disconnect(struct usb_interface *interface)
 #else
 static void mceusb_disconnect(struct usb_device *udev, void *ptr)
@@ -942,37 +914,37 @@ static void mceusb_disconnect(struct usb_device *udev, void *ptr)
 	struct usb_skel *dev;
 	int minor;
 #ifdef KERNEL_2_5
-	dev = usb_get_intfdata (interface);
-	usb_set_intfdata (interface, NULL);
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
 #else
 	dev = (struct usb_skel *)ptr;
 #endif
-	
-	down (&minor_table_mutex);
-	down (&dev->sem);
+
+	down(&minor_table_mutex);
+	down(&dev->sem);
 	minor = dev->minor;
 
 	/* unhook lirc things */
-	lirc_unregister_plugin( minor );
-	lirc_buffer_free( dev->plugin->rbuf );
-	kfree( dev->plugin->rbuf );
-	kfree( dev->plugin );
+	lirc_unregister_plugin(minor);
+	lirc_buffer_free(dev->plugin->rbuf);
+	kfree(dev->plugin->rbuf);
+	kfree(dev->plugin);
 #ifdef KERNEL_2_5
 	/* terminate an ongoing write */
-	if (atomic_read (&dev->write_busy)) {
-		usb_kill_urb (dev->write_urb);
-		wait_for_completion (&dev->write_finished);
+	if (atomic_read(&dev->write_busy)) {
+		usb_kill_urb(dev->write_urb);
+		wait_for_completion(&dev->write_finished);
 	}
 
 	/* prevent device read, write and ioctl */
 	dev->present = 0;
 #endif
-	
-	mceusb_delete (dev);
-	
+
+	mceusb_delete(dev);
+
 	info("Microsoft IR Transceiver #%d now disconnected", minor);
-	up (&dev->sem);
-	up (&minor_table_mutex);
+	up(&dev->sem);
+	up(&minor_table_mutex);
 }
 
 
@@ -986,12 +958,13 @@ static int __init usb_mceusb_init(void)
 
 	/* register this driver with the USB subsystem */
 	result = usb_register(&mceusb_driver);
-#ifdef KERNEL_2_5	
-	if ( result ) {
+#ifdef KERNEL_2_5
+	if (result) {
 #else
-	if ( result < 0 ) {
+	if (result < 0) {
 #endif
-		err("usb_register failed for the " DRIVER_NAME " driver. error number %d",result);
+		err("usb_register failed for the " DRIVER_NAME
+		    " driver. error number %d", result);
 #ifdef KERNEL_2_5
 		return result;
 #else
@@ -1013,13 +986,13 @@ static void __exit usb_mceusb_exit(void)
 	usb_deregister(&mceusb_driver);
 }
 
- module_init (usb_mceusb_init);
-module_exit (usb_mceusb_exit);
+module_init(usb_mceusb_init);
+module_exit(usb_mceusb_exit);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE (usb, mceusb_table);
+MODULE_DEVICE_TABLE(usb, mceusb_table);
 
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Debug enabled or not");
diff --git a/drivers/char/lirc/lirc_mceusb2.c b/drivers/char/lirc/lirc_mceusb2.c
index 7872533..fa4839d 100644
--- a/drivers/char/lirc/lirc_mceusb2.c
+++ b/drivers/char/lirc/lirc_mceusb2.c
@@ -1,7 +1,7 @@
 /*
- * LIRC driver for Philips eHome USB Infrared Transciever
+ * LIRC driver for Philips eHome USB Infrared Transceiver
  * and the Microsoft MCE 2005 Remote Control
- * 
+ *
  * (C) by Martin A. Blatter <martin_a_blatter@yahoo.com>
  *
  * Transmitter support and reception code cleanup.
@@ -50,7 +50,11 @@
 #include <linux/kmod.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
 #include <linux/usb.h>
 #include <linux/poll.h>
 #include <linux/wait.h>
@@ -60,44 +64,47 @@
 #include "kcompat.h"
 #include "lirc_dev.h"
 
-#define DRIVER_VERSION          "$Revision: 1.29 $"
-#define DRIVER_AUTHOR           "Daniel Melander <lirc@rajidae.se>, Martin Blatter <martin_a_blatter@yahoo.com>"
-#define DRIVER_DESC             "Philips eHome USB IR Transciever and Microsoft MCE 2005 Remote Control driver for LIRC"
-#define DRIVER_NAME		"lirc_mceusb2"
+#define DRIVER_VERSION	"$Revision: 1.44 $"
+#define DRIVER_AUTHOR	"Daniel Melander <lirc@rajidae.se>, " \
+			"Martin Blatter <martin_a_blatter@yahoo.com>"
+#define DRIVER_DESC	"Philips eHome USB IR Transceiver and Microsoft " \
+			"MCE 2005 Remote Control driver for LIRC"
+#define DRIVER_NAME	"lirc_mceusb2"
 
-#define USB_BUFLEN              16             /* USB reception buffer length */
-#define LIRCBUF_SIZE            256            /* LIRC work buffer length */
+#define USB_BUFLEN	16	/* USB reception buffer length */
+#define LIRCBUF_SIZE	256	/* LIRC work buffer length */
 
 /* MCE constants */
-#define MCE_CMDBUF_SIZE         384            /* MCE Command buffer length */
-#define MCE_TIME_UNIT           50             /* Approx 50us resolution */
-#define MCE_CODE_LENGTH         5              /* Normal length of one mce packet (header included) */
-#define MCE_PACKET_SIZE         4              /* Normal length of one mce packet (header not included) */
-#define MCE_PACKET_HEADER       0x84           /* Actual header format is 0x80 + num_bytes */
-#define MCE_CONTROL_HEADER      0x9F           /* MCE status header */
-#define MCE_TX_HEADER_LENGTH    3              /* Number of bytes in the initializing tx header */
-#define MCE_MAX_CHANNELS        2              /* Two transmitters, hardware dependent? */
-#define MCE_DEFAULT_TX_MASK     0x03           /* Supported values are TX1=0x01, TX2=0x02, ALL=0x03 */
-#define MCE_PULSE_BIT           0x80           /* Pulse bit, MSB set == PULSE else SPACE */
-#define MCE_PULSE_MASK          0x7F           /* Pulse mask */
-#define MCE_MAX_PULSE_LENGTH    0x7F           /* Longest transmittable pulse symbol */
+#define MCE_CMDBUF_SIZE	384 /* MCE Command buffer length */
+#define MCE_TIME_UNIT	50 /* Approx 50us resolution */
+#define MCE_CODE_LENGTH	5 /* Normal length of packet (with header) */
+#define MCE_PACKET_SIZE	4 /* Normal length of packet (without header) */
+#define MCE_PACKET_HEADER 0x84 /* Actual header format is 0x80 + num_bytes */
+#define MCE_CONTROL_HEADER 0x9F /* MCE status header */
+#define MCE_TX_HEADER_LENGTH 3 /* # of bytes in the initializing tx header */
+#define MCE_MAX_CHANNELS 2 /* Two transmitters, hardware dependent? */
+#define MCE_DEFAULT_TX_MASK 0x03 /* Val opts: TX1=0x01, TX2=0x02, ALL=0x03 */
+#define MCE_PULSE_BIT	0x80 /* Pulse bit, MSB set == PULSE else SPACE */
+#define MCE_PULSE_MASK	0x7F /* Pulse mask */
+#define MCE_MAX_PULSE_LENGTH 0x7F /* Longest transmittable pulse symbol */
 
 
 /* module parameters */
 #ifdef CONFIG_USB_DEBUG
-	static int debug = 1;
+static int debug = 1;
 #else
-	static int debug = 0;
+static int debug;
 #endif
-#define dprintk(fmt, args...)                                 \
-	do{                                                   \
-		if(debug) printk(KERN_DEBUG fmt, ## args);    \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG fmt, ## args);	\
+	} while (0)
 
 /* lock irctl structure */
-//#define IRLOCK			down_interruptible(&ir->lock)
-#define IRLOCK			down(&ir->lock)
-#define IRUNLOCK		up(&ir->lock)
+/*#define IRLOCK	down_interruptible(&ir->lock) */
+#define IRLOCK		down(&ir->lock)
+#define IRUNLOCK	up(&ir->lock)
 
 /* general constants */
 #define SUCCESS			0
@@ -110,34 +117,72 @@
 #define PHILUSB_OUTBOUND	2
 
 #define VENDOR_PHILIPS		0x0471
-#define VENDOR_SMK              0x0609
+#define VENDOR_SMK		0x0609
 #define VENDOR_TATUNG		0x1460
 #define VENDOR_GATEWAY		0x107b
 #define VENDOR_SHUTTLE		0x1308
-#define VENDOR_MITSUMI          0x03ee
-#define VENDOR_TOPSEED          0x1784 
-#define VENDOR_RICAVISION       0x179d
-#define VENDOR_ITRON            0x195d
-#define VENDOR_FIC              0x1509
-#define VENDOR_LG               0x043e
+#define VENDOR_SHUTTLE2		0x051c
+#define VENDOR_MITSUMI		0x03ee
+#define VENDOR_TOPSEED		0x1784
+#define VENDOR_RICAVISION	0x179d
+#define VENDOR_ITRON		0x195d
+#define VENDOR_FIC		0x1509
+#define VENDOR_LG		0x043e
 #define VENDOR_MICROSOFT	0x045e
+#define VENDOR_FORMOSA		0x147a
+#define VENDOR_FINTEK		0x1934
 
 static struct usb_device_id usb_remote_table [] = {
-	{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },	/* Philips eHome Infrared Transciever */
-	{ USB_DEVICE(VENDOR_PHILIPS, 0x060c) },	/* Philips Infrared Transciever - HP branded */
-	{ USB_DEVICE(VENDOR_SMK, 0x031d) },	/* SMK/Toshiba G83C0004D410 */
-	{ USB_DEVICE(VENDOR_SMK, 0x0322) },	/* SMK eHome Infrared Transceiver (Sony VAIO) */
-	{ USB_DEVICE(VENDOR_TATUNG, 0x9150) },  /* Tatung eHome Infrared Transceiver */
-	{ USB_DEVICE(VENDOR_SHUTTLE, 0xc001) },  /* Shuttle eHome Infrared Transceiver */
-        { USB_DEVICE(VENDOR_GATEWAY, 0x3009) },  /* Gateway eHome Infrared Transceiver */
-        { USB_DEVICE(VENDOR_MITSUMI, 0x2501) },  /* Mitsumi */
-	{ USB_DEVICE(VENDOR_TOPSEED, 0x0001) },  /* Topseed eHome Infrared Transceiver */ 
-	{ USB_DEVICE(VENDOR_RICAVISION, 0x0010) }, /* Ricavision internal Infrared Transceiver */
-	{ USB_DEVICE(VENDOR_ITRON, 0x7002) },   /* Itron ione Libra Q-11 */
-	{ USB_DEVICE(VENDOR_FIC, 0x9242) },     /* FIC eHome Infrared Transceiver */
-	{ USB_DEVICE(VENDOR_LG, 0x9803) },      /* LG eHome Infrared Transceiver */
-	{ USB_DEVICE(VENDOR_MICROSOFT, 0x00a0) }, /* Microsoft MCE Infrared Transceiver */
-	{ }					/* Terminating entry */
+	/* Philips eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },
+	/* Philips Infrared Transceiver - HP branded */
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x060c) },
+	/* Philips SRM5100 */
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x060d) },
+	/* SMK/Toshiba G83C0004D410 */
+	{ USB_DEVICE(VENDOR_SMK, 0x031d) },
+	/* SMK eHome Infrared Transceiver (Sony VAIO) */
+	{ USB_DEVICE(VENDOR_SMK, 0x0322) },
+	/* bundled with Hauppauge PVR-150 */
+	{ USB_DEVICE(VENDOR_SMK, 0x0334) },
+	/* Tatung eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_TATUNG, 0x9150) },
+	/* Shuttle eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_SHUTTLE, 0xc001) },
+	/* Shuttle eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_SHUTTLE2, 0xc001) },
+	/* Gateway eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_GATEWAY, 0x3009) },
+	/* Mitsumi */
+	{ USB_DEVICE(VENDOR_MITSUMI, 0x2501) },
+	/* Topseed eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_TOPSEED, 0x0001) },
+	/* Topseed HP eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_TOPSEED, 0x0006) },
+	/* Topseed eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_TOPSEED, 0x0007) },
+	/* Topseed eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_TOPSEED, 0x0008) },
+	/* Ricavision internal Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_RICAVISION, 0x0010) },
+	/* Itron ione Libra Q-11 */
+	{ USB_DEVICE(VENDOR_ITRON, 0x7002) },
+	/* FIC eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_FIC, 0x9242) },
+	/* LG eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_LG, 0x9803) },
+	/* Microsoft MCE Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_MICROSOFT, 0x00a0) },
+	/* Formosa eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_FORMOSA, 0xe015) },
+	/* Formosa aim / Trust MCE Infrared Receiver */
+	{ USB_DEVICE(VENDOR_FORMOSA, 0xe017) },
+	/* Formosa Industrial Computing / Beanbag Emulation Device */
+	{ USB_DEVICE(VENDOR_FORMOSA, 0xe018) },
+	/* Fintek eHome Infrared Transceiver */
+	{ USB_DEVICE(VENDOR_FINTEK, 0x0602) },
+	/* Terminating entry */
+	{ }
 };
 
 /* data structure for each usb remote */
@@ -147,8 +192,8 @@ struct irctl {
 	struct usb_device *usbdev;
 	struct urb *urb_in;
 	int devnum;
-        struct usb_endpoint_descriptor *usb_ep_in;
-        struct usb_endpoint_descriptor *usb_ep_out;
+	struct usb_endpoint_descriptor *usb_ep_in;
+	struct usb_endpoint_descriptor *usb_ep_out;
 
 	/* buffers and dma */
 	unsigned char *buf_in;
@@ -161,14 +206,14 @@ struct irctl {
 	lirc_t lircdata;
 	unsigned char is_pulse;
 	int connected;
-	
+
 	unsigned char transmitter_mask;
-        unsigned int carrier_freq;
+	unsigned int carrier_freq;
 
 	/* handle sending (init strings) */
 	int send_flags;
 	wait_queue_head_t wait_out;
-   
+
 	struct semaphore lock;
 };
 
@@ -200,10 +245,10 @@ static void usb_remote_printdata(struct irctl *ir, char *buf, int len)
 	if (len <= 0)
 		return;
 
-	for (i = 0; i < len && i < USB_BUFLEN; i++) {
+	for (i = 0; i < len && i < USB_BUFLEN; i++)
 		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
-	}
-	printk(DRIVER_NAME "[%d]: data received %s (length=%d)\n",
+
+	printk(KERN_INFO "" DRIVER_NAME "[%d]: data received %s (length=%d)\n",
 		ir->devnum, codes, len);
 }
 
@@ -214,67 +259,86 @@ static void usb_async_callback(struct urb *urb, struct pt_regs *regs)
 
 	if (!urb)
 		return;
-	
-	if ((ir = urb->context)) {
+
+	ir = urb->context;
+	if (ir) {
 		len = urb->actual_length;
 
-		dprintk(DRIVER_NAME "[%d]: callback called (status=%d len=%d)\n",ir->devnum,urb->status,len);
+		dprintk(DRIVER_NAME
+			"[%d]: callback called (status=%d len=%d)\n",
+			ir->devnum, urb->status, len);
 
 		if (debug)
-			usb_remote_printdata(ir,urb->transfer_buffer,len);
+			usb_remote_printdata(ir, urb->transfer_buffer, len);
 	}
 
 }
 
 
 /* request incoming or send outgoing usb packet - used to initialize remote */
-static void request_packet_async(struct irctl *ir, struct usb_endpoint_descriptor *ep, unsigned char* data, int size, int urb_type)
+static void request_packet_async(struct irctl *ir,
+				 struct usb_endpoint_descriptor *ep,
+				 unsigned char *data, int size, int urb_type)
 {
 	int res;
 	struct urb *async_urb;
 	unsigned char *async_buf;
 
 	if (urb_type) {
-	    	if ((async_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+		async_urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (async_urb) {
 			/* alloc buffer */
-			if ((async_buf = kmalloc(size, GFP_KERNEL))) {
-				if (urb_type==PHILUSB_OUTBOUND) {
+			async_buf = kmalloc(size, GFP_KERNEL);
+			if (async_buf) {
+				if (urb_type == PHILUSB_OUTBOUND) {
 					/* outbound data */
-					usb_fill_int_urb(async_urb, ir->usbdev, usb_sndintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
-					size, (usb_complete_t) usb_async_callback, ir, ep->bInterval);
+					usb_fill_int_urb(async_urb, ir->usbdev,
+						usb_sndintpipe(ir->usbdev,
+							ep->bEndpointAddress),
+					async_buf,
+					size,
+					(usb_complete_t) usb_async_callback,
+					ir, ep->bInterval);
 
 					memcpy(async_buf, data, size);
-					async_urb->transfer_flags=URB_ASYNC_UNLINK;
-				}
-				else {
+					async_urb->transfer_flags =
+						URB_ASYNC_UNLINK;
+				} else {
 					/* inbound data */
-					usb_fill_int_urb(async_urb, ir->usbdev, usb_rcvintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
-					size, (usb_complete_t) usb_async_callback, ir, ep->bInterval);
-
-					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+					usb_fill_int_urb(async_urb, ir->usbdev,
+						usb_rcvintpipe(ir->usbdev,
+							ep->bEndpointAddress),
+					async_buf, size,
+					(usb_complete_t) usb_async_callback,
+					ir, ep->bInterval);
+
+					async_urb->transfer_flags =
+						URB_ASYNC_UNLINK;
 				}
-			}
-			else {
+			} else {
 				usb_free_urb(async_urb);
 				return;
 			}
 		}
-	}
-	else {
+	} else {
 		/* standard request */
-		async_urb=ir->urb_in;
+		async_urb = ir->urb_in;
 		ir->send_flags = RECV_FLAG_IN_PROGRESS;
 	}
-	dprintk(DRIVER_NAME "[%d]: receive request called (size=%#x)\n", ir->devnum, size);
+	dprintk(DRIVER_NAME "[%d]: receive request called (size=%#x)\n",
+		ir->devnum, size);
 
 	async_urb->transfer_buffer_length = size;
 	async_urb->dev = ir->usbdev;
 
-	if ((res=usb_submit_urb(async_urb, GFP_ATOMIC))) {
-	    dprintk(DRIVER_NAME "[%d]: receive request FAILED! (res=%d)\n", ir->devnum, res);
-	    return;
+	res = usb_submit_urb(async_urb, GFP_ATOMIC);
+	if (res) {
+		dprintk(DRIVER_NAME "[%d]: receive request FAILED! (res=%d)\n",
+			ir->devnum, res);
+		return;
 	}
-	dprintk(DRIVER_NAME "[%d]: receive request complete (res=%d)\n", ir->devnum, res);
+	dprintk(DRIVER_NAME "[%d]: receive request complete (res=%d)\n",
+		ir->devnum, res);
 }
 
 static int unregister_from_lirc(struct irctl *ir)
@@ -286,7 +350,8 @@ static int unregister_from_lirc(struct irctl *ir)
 	devnum = ir->devnum;
 	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
 
-	if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+	rtn = lirc_unregister_plugin(p->minor);
+	if (rtn > 0) {
 		printk(DRIVER_NAME "[%d]: error in lirc_unregister minor: %d\n"
 			"Trying again...\n", devnum, p->minor);
 		if (rtn == -EBUSY) {
@@ -298,10 +363,10 @@ static int unregister_from_lirc(struct irctl *ir)
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
 
-		if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+		rtn = lirc_unregister_plugin(p->minor);
+		if (rtn > 0)
 			printk(DRIVER_NAME "[%d]: lirc_unregister failed\n",
 			devnum);
-		}
 	}
 
 	if (rtn != SUCCESS) {
@@ -359,11 +424,11 @@ static void set_use_dec(void *data)
 
 static void send_packet_to_lirc(struct irctl *ir)
 {
-	if (ir->lircdata!=0)
-	{
-		lirc_buffer_write_1(ir->p->rbuf, (unsigned char*) &ir->lircdata);
+	if (ir->lircdata != 0) {
+		lirc_buffer_write_1(ir->p->rbuf,
+				    (unsigned char *) &ir->lircdata);
 		wake_up(&ir->p->rbuf->wait_poll);
-		ir->lircdata=0;
+		ir->lircdata = 0;
 	}
 }
 
@@ -376,35 +441,32 @@ static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
 	if (!urb)
 		return;
 
-	if (!(ir = urb->context))
-	{
+	ir = urb->context;
+	if (!ir) {
 		urb->transfer_flags |= URB_ASYNC_UNLINK;
 		usb_unlink_urb(urb);
 		return;
 	}
 
 	buf_len = urb->actual_length;
-	packet_len=0;
-	
+	packet_len = 0;
+
 	if (debug)
-		usb_remote_printdata(ir,urb->transfer_buffer,buf_len);
+		usb_remote_printdata(ir, urb->transfer_buffer, buf_len);
 
-	if (ir->send_flags==RECV_FLAG_IN_PROGRESS)
-	{
-	  	ir->send_flags = SEND_FLAG_COMPLETE;
-		dprintk(DRIVER_NAME "[%d]: setup answer received %d bytes\n", ir->devnum, buf_len);
+	if (ir->send_flags == RECV_FLAG_IN_PROGRESS) {
+		ir->send_flags = SEND_FLAG_COMPLETE;
+		dprintk(DRIVER_NAME "[%d]: setup answer received %d bytes\n",
+			ir->devnum, buf_len);
 	}
 
-	switch (urb->status)
-	{
-		/* success */
+	switch (urb->status) {
+	/* success */
 	case SUCCESS:
-		for (i=0; i < buf_len; i++)
-		{
+		for (i = 0; i < buf_len; i++) {
 			/* decode mce packets on the form (84),AA,BB,CC,DD */
-			switch(ir->buf_in[i])
-			{
-				/* data headers */
+			switch (ir->buf_in[i]) {
+			/* data headers */
 			case 0x8F:
 			case 0x8E:
 			case 0x8D:
@@ -422,52 +484,58 @@ static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
 			case 0x81:
 			case 0x80:
 				/* decode packet data */
-				packet_len=ir->buf_in[i] & MCE_PULSE_MASK;
-				for (j=1; j<=packet_len && (i+j < buf_len); j++)
-				{
-
+				packet_len = ir->buf_in[i] & MCE_PULSE_MASK;
+				for (j = 1;
+				     j <= packet_len && (i+j < buf_len);
+				     j++) {
 					/* rising/falling flank */
-					if (ir->is_pulse!=(ir->buf_in[i+j]&MCE_PULSE_BIT))
-					{
+					if (ir->is_pulse !=
+					    (ir->buf_in[i + j] &
+					     MCE_PULSE_BIT)) {
 						send_packet_to_lirc(ir);
-						ir->is_pulse=ir->buf_in[i+j]&MCE_PULSE_BIT;
+						ir->is_pulse =
+							ir->buf_in[i + j] &
+								MCE_PULSE_BIT;
 					}
-					
+
 					/* accumulate mce pulse/space values */
-					ir->lircdata += (ir->buf_in[i+j]&MCE_PULSE_MASK)*MCE_TIME_UNIT;
-					ir->lircdata |= (ir->is_pulse?PULSE_BIT:0);
+					ir->lircdata +=
+						(ir->buf_in[i + j] &
+						 MCE_PULSE_MASK)*MCE_TIME_UNIT;
+					ir->lircdata |=
+						(ir->is_pulse ? PULSE_BIT : 0);
 				}
-				
-				i+=packet_len;
+
+				i += packet_len;
 				break;
-	          
+
 				/* status header (0x9F) */
 			case MCE_CONTROL_HEADER:
-				/* A transmission containing one or 
-                                   more consecutive ir commands always
-                                   ends with a GAP of 100ms followed by the
+				/* A transmission containing one or
+				   more consecutive ir commands always
+				   ends with a GAP of 100ms followed by the
 				   sequence 0x9F 0x01 0x01 0x9F 0x15
 				   0x00 0x00 0x80 */
-				
-                /* 
-                Uncomment this if the last 100ms
-                "infinity"-space should be transmitted
-                to lirc directly instead of at the beginning
-                of the next transmission. Changes pulse/space order.
-          
+
+		/*
+		Uncomment this if the last 100ms
+		"infinity"-space should be transmitted
+		to lirc directly instead of at the beginning
+		of the next transmission. Changes pulse/space order.
+
 				if (++i < buf_len && ir->buf_in[i]==0x01)
 					send_packet_to_lirc(ir);
-				
-                */ 
-                                                               
+
+		*/
+
 				/* end decode loop */
-				i=buf_len;
+				i = buf_len;
 				break;
 			default:
 				break;
 			}
 		}
-	    
+
 		break;
 
 		/* unlink */
@@ -488,84 +556,89 @@ static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
 }
 
 
-static ssize_t lirc_write(struct file *file, const char *buf, size_t n, loff_t * ppos) {
-
-	int i, count=0, cmdcount=0;
-	struct irctl *ir=NULL;
-	lirc_t wbuf[LIRCBUF_SIZE];                  /* Workbuffer with values from lirc */
-	unsigned char cmdbuf[MCE_CMDBUF_SIZE];      /* MCE command buffer */
-	unsigned long signal_duration=0;            /* Singnal length in us */
+static ssize_t lirc_write(struct file *file, const char *buf,
+			  size_t n, loff_t *ppos)
+{
+	int i, count = 0, cmdcount = 0;
+	struct irctl *ir = NULL;
+	lirc_t wbuf[LIRCBUF_SIZE]; /* Workbuffer with values from lirc */
+	unsigned char cmdbuf[MCE_CMDBUF_SIZE]; /* MCE command buffer */
+	unsigned long signal_duration = 0; /* Singnal length in us */
 	struct timeval start_time, end_time;
-	
+
 	do_gettimeofday(&start_time);
-	
+
 	/* Retrieve lirc_plugin data for the device */
 	ir = lirc_get_pdata(file);
-	if (!ir && !ir->usb_ep_out) return -EFAULT;
+	if (!ir && !ir->usb_ep_out)
+		return -EFAULT;
 
-	if(n%sizeof(lirc_t)) return(-EINVAL);
-	count=n/sizeof(lirc_t);
+	if (n % sizeof(lirc_t))
+		return(-EINVAL);
+	count = n / sizeof(lirc_t);
 
 	/* Check if command is within limits */
-	if(count>LIRCBUF_SIZE || count%2==0) return(-EINVAL);
-	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+	if (count > LIRCBUF_SIZE || count%2 == 0)
+		return(-EINVAL);
+	if (copy_from_user(wbuf, buf, n))
+		return -EFAULT;
 
 	/* MCE tx init header */
-	cmdbuf[cmdcount++]=MCE_CONTROL_HEADER;
-	cmdbuf[cmdcount++]=0x08;
-	cmdbuf[cmdcount++]=ir->transmitter_mask;
+	cmdbuf[cmdcount++] = MCE_CONTROL_HEADER;
+	cmdbuf[cmdcount++] = 0x08;
+	cmdbuf[cmdcount++] = ir->transmitter_mask;
 
 	/* Generate mce packet data */
-	for(i=0;(i<count) && (cmdcount < MCE_CMDBUF_SIZE);i++)
-	{
-		signal_duration+=wbuf[i];
-		wbuf[i]=wbuf[i]/MCE_TIME_UNIT;
+	for (i = 0; (i < count) && (cmdcount < MCE_CMDBUF_SIZE); i++) {
+		signal_duration += wbuf[i];
+		wbuf[i] = wbuf[i] / MCE_TIME_UNIT;
 
 		do { /* loop to support long pulses/spaces > 127*50us=6.35ms */
 
 			/* Insert mce packet header every 4th entry */
-			if ((cmdcount<MCE_CMDBUF_SIZE) &&
-			    (cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH==0)
-			{
+			if ((cmdcount < MCE_CMDBUF_SIZE) &&
+			    (cmdcount - MCE_TX_HEADER_LENGTH) %
+			     MCE_CODE_LENGTH == 0)
 				cmdbuf[cmdcount++] = MCE_PACKET_HEADER;
-			}
 
 			/* Insert mce packet data */
-			if (cmdcount<MCE_CMDBUF_SIZE)
-			{
-				cmdbuf[cmdcount++] = (wbuf[i]<MCE_PULSE_BIT?wbuf[i]:MCE_MAX_PULSE_LENGTH) | (i & 1?0x00:MCE_PULSE_BIT);
-			}
+			if (cmdcount < MCE_CMDBUF_SIZE)
+				cmdbuf[cmdcount++] =
+					(wbuf[i] < MCE_PULSE_BIT ?
+					 wbuf[i] : MCE_MAX_PULSE_LENGTH) |
+					 (i & 1 ? 0x00 : MCE_PULSE_BIT);
 			else
-		       	{
 				return -EINVAL;
-			}
 		} while ((wbuf[i] > MCE_MAX_PULSE_LENGTH) &&
-			 (wbuf[i]-=MCE_MAX_PULSE_LENGTH));
+			 (wbuf[i] -= MCE_MAX_PULSE_LENGTH));
 	}
 
 	/* Fix packet length in last header */
-	cmdbuf[cmdcount-(cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH] =
-		0x80+(cmdcount-MCE_TX_HEADER_LENGTH)%MCE_CODE_LENGTH-1;
+	cmdbuf[cmdcount - (cmdcount - MCE_TX_HEADER_LENGTH) % MCE_CODE_LENGTH] =
+		0x80 + (cmdcount - MCE_TX_HEADER_LENGTH) % MCE_CODE_LENGTH - 1;
 
 	/* Check if we have room for the empty packet at the end */
-	if (cmdcount>=MCE_CMDBUF_SIZE) return -EINVAL;
+	if (cmdcount >= MCE_CMDBUF_SIZE)
+		return -EINVAL;
 
 	/* All mce commands end with an empty packet (0x80) */
-	cmdbuf[cmdcount++]=0x80;
+	cmdbuf[cmdcount++] = 0x80;
 
 	/* Transmit the command to the mce device */
-	request_packet_async(ir, ir->usb_ep_out, cmdbuf, cmdcount, PHILUSB_OUTBOUND);
+	request_packet_async(ir, ir->usb_ep_out, cmdbuf,
+			     cmdcount, PHILUSB_OUTBOUND);
 
 	/* The lircd gap calculation expects the write function to
 	   wait the time it takes for the ircommand to be sent before
 	   it returns. */
 	do_gettimeofday(&end_time);
-	signal_duration-=(end_time.tv_usec-start_time.tv_usec)+(end_time.tv_sec-start_time.tv_sec)*1000000;
-	
+	signal_duration -= (end_time.tv_usec - start_time.tv_usec) +
+			   (end_time.tv_sec - start_time.tv_sec) * 1000000;
+
 	/* delay with the closest number of ticks */
 	set_current_state(TASK_INTERRUPTIBLE);
-	schedule_timeout (usecs_to_jiffies(signal_duration));
-	
+	schedule_timeout(usecs_to_jiffies(signal_duration));
+
 	return n;
 }
 
@@ -574,17 +647,18 @@ static void set_transmitter_mask(struct irctl *ir, unsigned int mask)
 
 	/* SMK Transceiver does not use the inverted scheme, nor does Topseed*/
 	if ((ir->usbdev->descriptor.idVendor == VENDOR_SMK &&
-	     (ir->usbdev->descriptor.idProduct == 0x031d || ir->usbdev->descriptor.idProduct == 0x0322)) ||
-	    (ir->usbdev->descriptor.idVendor == VENDOR_TOPSEED && ir->usbdev->descriptor.idProduct == 0x0001))
-	{
+	     (ir->usbdev->descriptor.idProduct == 0x031d ||
+	      ir->usbdev->descriptor.idProduct == 0x0322 ||
+	      ir->usbdev->descriptor.idProduct == 0x0334)) ||
+	    (ir->usbdev->descriptor.idVendor == VENDOR_TOPSEED &&
+	     (ir->usbdev->descriptor.idProduct == 0x0001 ||
+	      ir->usbdev->descriptor.idProduct == 0x0007 ||
+	      ir->usbdev->descriptor.idProduct == 0x0008)))
 		ir->transmitter_mask = mask;
-	}
 	else
-	{
 		/* The mask begins at 0x02 and has an inverted
 		   numbering scheme */
-		ir->transmitter_mask = (mask!=0x03?mask ^ 0x03:mask) << 1;
-	}
+		ir->transmitter_mask = (mask != 0x03 ? mask ^ 0x03 : mask) << 1;
 }
 
 
@@ -636,7 +710,7 @@ static int set_send_carrier(struct irctl *ir, int carrier)
 
 
 static int lirc_ioctl(struct inode *node, struct file *filep,
-	       	      unsigned int cmd, unsigned long arg)
+		      unsigned int cmd, unsigned long arg)
 {
 	int result;
 	unsigned int ivalue;
@@ -644,20 +718,18 @@ static int lirc_ioctl(struct inode *node, struct file *filep,
 	struct irctl *ir = NULL;
 
 	/* Retrieve lirc_plugin data for the device */
-	ir=lirc_get_pdata(filep);
+	ir = lirc_get_pdata(filep);
 	if (!ir && !ir->usb_ep_out)
 		return -EFAULT;
 
 
-	switch(cmd)
-	{
+	switch (cmd) {
 	case LIRC_SET_TRANSMITTER_MASK:
 
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-
-		switch(ivalue)
-		{
+		result = get_user(ivalue, (unsigned int *) arg);
+		if (result)
+			return result;
+		switch (ivalue) {
 		case 0x01: /* Transmitter 1     => 0x04 */
 		case 0x02: /* Transmitter 2     => 0x02 */
 		case 0x03: /* Transmitter 1 & 2 => 0x06 */
@@ -673,27 +745,32 @@ static int lirc_ioctl(struct inode *node, struct file *filep,
 
 	case LIRC_GET_SEND_MODE:
 
-		result=put_user(LIRC_SEND2MODE (LIRC_CAN_SEND_PULSE&LIRC_CAN_SEND_MASK), (unsigned long *) arg);
+		result = put_user(LIRC_SEND2MODE(LIRC_CAN_SEND_PULSE &
+						 LIRC_CAN_SEND_MASK),
+				  (unsigned long *) arg);
 
-		if(result) return(result);
+		if (result)
+			return result;
 		break;
 
 	case LIRC_SET_SEND_MODE:
 
-		result=get_user(lvalue,(unsigned long *) arg);
+		result = get_user(lvalue, (unsigned long *) arg);
 
-		if(result) return(result);
-		if(lvalue!=(LIRC_MODE_PULSE&LIRC_CAN_SEND_MASK)) return -EINVAL;
+		if (result)
+			return result;
+		if (lvalue != (LIRC_MODE_PULSE&LIRC_CAN_SEND_MASK))
+			return -EINVAL;
 		break;
-		
+
 	case LIRC_SET_SEND_CARRIER:
 
 		result = get_user(ivalue, (unsigned int *) arg);
-                if (result)
-			return (result);
-		
-                set_send_carrier(ir, ivalue);
-                break;
+		if (result)
+			return result;
+
+		set_send_carrier(ir, ivalue);
+		break;
 
 	default:
 		return -ENOIOCTLCMD;
@@ -702,9 +779,8 @@ static int lirc_ioctl(struct inode *node, struct file *filep,
 	return 0;
 }
 
-static struct file_operations lirc_fops =
-{
-	write:	lirc_write,
+static struct file_operations lirc_fops = {
+	.write	= lirc_write,
 };
 
 
@@ -713,7 +789,9 @@ static int usb_remote_probe(struct usb_interface *intf,
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct usb_host_interface *idesc;
-	struct usb_endpoint_descriptor *ep=NULL, *ep_in=NULL, *ep_out=NULL;
+	struct usb_endpoint_descriptor *ep = NULL;
+	struct usb_endpoint_descriptor *ep_in = NULL;
+	struct usb_endpoint_descriptor *ep_out = NULL;
 	struct usb_host_config *config;
 	struct irctl *ir = NULL;
 	struct lirc_plugin *plugin = NULL;
@@ -721,14 +799,14 @@ static int usb_remote_probe(struct usb_interface *intf,
 	int devnum, pipe, maxp;
 	int minor = 0;
 	int i;
-	char buf[63], name[128]="";
+	char buf[63], name[128] = "";
 	int mem_failure = 0;
 
 	dprintk(DRIVER_NAME ": usb probe called\n");
 
 	usb_reset_device(dev);
 
-	config=dev->actconfig;
+	config = dev->actconfig;
 
 	idesc = intf->cur_altsetting;
 
@@ -737,25 +815,33 @@ static int usb_remote_probe(struct usb_interface *intf,
 		ep = &idesc->endpoint[i].desc;
 
 		if ((ep_in == NULL)
-			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
-			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)
-			||  ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))) {
-
-			dprintk(DRIVER_NAME ": acceptable inbound endpoint found\n");
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    == USB_DIR_IN)
+			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+			    == USB_ENDPOINT_XFER_BULK)
+			|| ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+			    == USB_ENDPOINT_XFER_INT))) {
+
+			dprintk(DRIVER_NAME ": acceptable inbound endpoint "
+				"found\n");
 			ep_in = ep;
-			ep_in->bmAttributes=USB_ENDPOINT_XFER_INT;
-			ep_in->bInterval=1;
+			ep_in->bmAttributes = USB_ENDPOINT_XFER_INT;
+			ep_in->bInterval = 1;
 		}
 
 		if ((ep_out == NULL)
-			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
-			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)
-			||  ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))) {
-
-			dprintk(DRIVER_NAME ": acceptable outbound endpoint found\n");
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    == USB_DIR_OUT)
+			&& (((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+			    == USB_ENDPOINT_XFER_BULK)
+			|| ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+			    == USB_ENDPOINT_XFER_INT))) {
+
+			dprintk(DRIVER_NAME ": acceptable outbound endpoint "
+				"found\n");
 			ep_out = ep;
-			ep_out->bmAttributes=USB_ENDPOINT_XFER_INT;
-			ep_out->bInterval=1;
+			ep_out->bmAttributes = USB_ENDPOINT_XFER_INT;
+			ep_out->bInterval = 1;
 		}
 	}
 	if (ep_in == NULL) {
@@ -769,58 +855,78 @@ static int usb_remote_probe(struct usb_interface *intf,
 
 	/* allocate kernel memory */
 	mem_failure = 0;
-	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+	ir = kmalloc(sizeof(struct irctl), GFP_KERNEL);
+	if (!ir) {
 		mem_failure = 1;
-	} else {
-		memset(ir, 0, sizeof(struct irctl));
-
-		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
-			mem_failure = 2;
-		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
-			mem_failure = 3;
-		} else if (lirc_buffer_init(rbuf, sizeof(lirc_t), LIRCBUF_SIZE)) {
-			mem_failure = 4;
-		} else if (!(ir->buf_in = usb_buffer_alloc(dev, maxp, GFP_ATOMIC, &ir->dma_in))) {
-			mem_failure = 5;
-		} else if (!(ir->urb_in = usb_alloc_urb(0, GFP_KERNEL))) {
-			mem_failure = 7;
-		} else {
-
-			memset(plugin, 0, sizeof(struct lirc_plugin));
-
-			strcpy(plugin->name, DRIVER_NAME " ");
-			plugin->minor = -1;
-			plugin->features = LIRC_CAN_SEND_PULSE |
-				LIRC_CAN_SET_TRANSMITTER_MASK |
-				LIRC_CAN_REC_MODE2 |
-				LIRC_CAN_SET_SEND_CARRIER;
-			plugin->data = ir;
-			plugin->rbuf = rbuf;
-			plugin->set_use_inc = &set_use_inc;
-			plugin->set_use_dec = &set_use_dec;
-			plugin->code_length = sizeof(lirc_t) * 8;
-			plugin->ioctl = lirc_ioctl;
-			plugin->fops  = &lirc_fops;
-			plugin->dev   = &dev->dev;
-			plugin->owner = THIS_MODULE;
-
-			init_MUTEX(&ir->lock);
-			init_waitqueue_head(&ir->wait_out);
-
-			if ((minor = lirc_register_plugin(plugin)) < 0) {
-				mem_failure = 9;
-			}
-		}
+		goto mem_failure_switch;
+	}
+
+	memset(ir, 0, sizeof(struct irctl));
+
+	plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL);
+	if (!plugin) {
+		mem_failure = 2;
+		goto mem_failure_switch;
 	}
 
+	rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+	if (!rbuf) {
+		mem_failure = 3;
+		goto mem_failure_switch;
+	}
+
+	if (lirc_buffer_init(rbuf, sizeof(lirc_t), LIRCBUF_SIZE)) {
+		mem_failure = 4;
+		goto mem_failure_switch;
+	}
+
+	ir->buf_in = usb_buffer_alloc(dev, maxp, GFP_ATOMIC, &ir->dma_in);
+	if (!ir->buf_in) {
+		mem_failure = 5;
+		goto mem_failure_switch;
+	}
+
+	ir->urb_in = usb_alloc_urb(0, GFP_KERNEL);
+	if (!ir->urb_in) {
+		mem_failure = 7;
+		goto mem_failure_switch;
+	}
+
+	memset(plugin, 0, sizeof(struct lirc_plugin));
+
+	strcpy(plugin->name, DRIVER_NAME " ");
+	plugin->minor = -1;
+	plugin->features = LIRC_CAN_SEND_PULSE |
+		LIRC_CAN_SET_TRANSMITTER_MASK |
+		LIRC_CAN_REC_MODE2 |
+		LIRC_CAN_SET_SEND_CARRIER;
+	plugin->data = ir;
+	plugin->rbuf = rbuf;
+	plugin->set_use_inc = &set_use_inc;
+	plugin->set_use_dec = &set_use_dec;
+	plugin->code_length = sizeof(lirc_t) * 8;
+	plugin->ioctl = lirc_ioctl;
+	plugin->fops  = &lirc_fops;
+	plugin->dev   = &dev->dev;
+	plugin->owner = THIS_MODULE;
+
+	init_MUTEX(&ir->lock);
+	init_waitqueue_head(&ir->wait_out);
+
+	minor = lirc_register_plugin(plugin);
+	if (minor < 0)
+		mem_failure = 9;
+
+mem_failure_switch:
+
 	/* free allocated memory incase of failure */
 	switch (mem_failure) {
 	case 9:
-		lirc_buffer_free(rbuf);
-	case 7:
 		usb_free_urb(ir->urb_in);
-	case 5:
+	case 7:
 		usb_buffer_free(dev, maxp, ir->buf_in, ir->dma_in);
+	case 5:
+		lirc_buffer_free(rbuf);
 	case 4:
 		kfree(rbuf);
 	case 3:
@@ -839,15 +945,15 @@ static int usb_remote_probe(struct usb_interface *intf,
 	ir->usbdev = dev;
 	ir->len_in = maxp;
 	ir->connected = 0;
-	
-        ir->lircdata=PULSE_MASK;
-        ir->is_pulse=0;
-	
+
+	ir->lircdata = PULSE_MASK;
+	ir->is_pulse = 0;
+
 	/* ir->usbdev must be set */
 	set_transmitter_mask(ir, MCE_DEFAULT_TX_MASK);
 	/* Saving usb interface data for use by the transmitter routine */
-	ir->usb_ep_in=ep_in;
-	ir->usb_ep_out=ep_out;
+	ir->usb_ep_in = ep_in;
+	ir->usb_ep_out = ep_out;
 
 	if (dev->descriptor.iManufacturer
 		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
@@ -863,12 +969,14 @@ static int usb_remote_probe(struct usb_interface *intf,
 		maxp, (usb_complete_t) usb_remote_recv, ir, ep_in->bInterval);
 
 	/* initialize device */
-	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
-	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
-	request_packet_async( ir, ep_out, init1, sizeof(init1), PHILUSB_OUTBOUND );
-	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
-	request_packet_async( ir, ep_out, init2, sizeof(init2), PHILUSB_OUTBOUND );
-	request_packet_async( ir, ep_in, NULL, maxp, 0);
+	request_packet_async(ir, ep_in, NULL, maxp, PHILUSB_INBOUND);
+	request_packet_async(ir, ep_in, NULL, maxp, PHILUSB_INBOUND);
+	request_packet_async(ir, ep_out, init1,
+			     sizeof(init1), PHILUSB_OUTBOUND);
+	request_packet_async(ir, ep_in, NULL, maxp, PHILUSB_INBOUND);
+	request_packet_async(ir, ep_out, init2,
+			     sizeof(init2), PHILUSB_OUTBOUND);
+	request_packet_async(ir, ep_in, NULL, maxp, 0);
 
 	usb_set_intfdata(intf, ir);
 
@@ -912,9 +1020,7 @@ static int usb_remote_resume(struct usb_interface *intf)
 	struct irctl *ir = usb_get_intfdata(intf);
 	printk(DRIVER_NAME "[%d]: resume\n", ir->devnum);
 	if (usb_submit_urb(ir->urb_in, GFP_ATOMIC))
-	{
 		return -EIO;
-	}
 	return 0;
 }
 #endif
@@ -935,13 +1041,15 @@ static int __init usb_remote_init(void)
 {
 	int i;
 
-	printk("\n" DRIVER_NAME ": " DRIVER_DESC " " DRIVER_VERSION "\n");
-	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	printk(KERN_INFO "\n");
+	printk(KERN_INFO DRIVER_NAME ": " DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(KERN_INFO DRIVER_NAME ": " DRIVER_AUTHOR "\n");
 	dprintk(DRIVER_NAME ": debug mode enabled\n");
 
 	request_module("lirc_dev");
 
-	if ((i = usb_register(&usb_remote_driver)) < 0) {
+	i = usb_register(&usb_remote_driver);
+	if (i < 0) {
 		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
 		return -ENODEV;
 	}
diff --git a/drivers/char/lirc/lirc_parallel.c b/drivers/char/lirc/lirc_parallel.c
index eed0b97..66d33c1 100644
--- a/drivers/char/lirc/lirc_parallel.c
+++ b/drivers/char/lirc/lirc_parallel.c
@@ -1,12 +1,12 @@
-/*      $Id: lirc_parallel.c,v 5.37 2007/04/29 14:23:04 lirc Exp $      */
+/*      $Id: lirc_parallel.c,v 5.40 2008/01/13 11:13:50 lirc Exp $      */
 
 /****************************************************************************
  ** lirc_parallel.c *********************************************************
  ****************************************************************************
- * 
+ *
  * lirc_parallel - device driver for infra-red signal receiving and
  *                 transmitting unit built by the author
- * 
+ *
  * Copyright (C) 1998 Christoph Bartelmus <lirc@bartelmus.de>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -23,7 +23,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- */ 
+ */
 
 /***********************************************************************
  *************************       Includes        ***********************
@@ -58,14 +58,21 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/io.h>
 #include <asm/signal.h>
 #include <asm/irq.h>
+#include <asm/uaccess.h>
+#else
+#include <linux/io.h>
+#include <linux/signal.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
 #include <asm/div64.h>
 #endif
 
-#include <asm/uaccess.h>
 #include <linux/poll.h>
 #include <linux/parport.h>
 
@@ -91,11 +98,13 @@
  *************************   Globale Variablen   ***********************
  ***********************************************************************/
 
-static int debug = 0;
+static int debug;
+static int check_pselecd;
+
 unsigned int irq = LIRC_IRQ;
 unsigned int io = LIRC_PORT;
 #ifdef LIRC_TIMER
-unsigned int timer = 0;
+unsigned int timer;
 unsigned int default_timer = LIRC_TIMER;
 #endif
 
@@ -107,13 +116,14 @@ static lirc_t rbuf[RBUF_SIZE];
 
 DECLARE_WAIT_QUEUE_HEAD(lirc_wait);
 
-unsigned int rptr=0,wptr=0;
-unsigned int lost_irqs=0;
-int is_open=0;
+unsigned int rptr;
+unsigned int wptr;
+unsigned int lost_irqs;
+int is_open;
 
 struct parport *pport;
 struct pardevice *ppdevice;
-int is_claimed=0;
+int is_claimed;
 
 unsigned int tx_mask = 1;
 
@@ -121,29 +131,27 @@ unsigned int tx_mask = 1;
  *************************   Interne Funktionen  ***********************
  ***********************************************************************/
 
-static unsigned int __inline__ in(int offset)
+static inline unsigned int in(int offset)
 {
-	switch(offset)
-	{
+	switch (offset) {
 	case LIRC_LP_BASE:
-		return(parport_read_data(pport));
+		return (parport_read_data(pport));
 	case LIRC_LP_STATUS:
-		return(parport_read_status(pport));
+		return (parport_read_status(pport));
 	case LIRC_LP_CONTROL:
-		return(parport_read_control(pport));
+		return (parport_read_control(pport));
 	}
-	return(0); /* make compiler happy */
+	return 0; /* make compiler happy */
 }
 
-static void __inline__ out(int offset, int value)
+static inline void out(int offset, int value)
 {
-	switch(offset)
-	{
+	switch (offset) {
 	case LIRC_LP_BASE:
-		parport_write_data(pport,value);
+		parport_write_data(pport, value);
 		break;
 	case LIRC_LP_CONTROL:
-		parport_write_control(pport,value);
+		parport_write_control(pport, value);
 		break;
 	case LIRC_LP_STATUS:
 		printk(KERN_INFO "%s: attempt to write to status register\n",
@@ -152,103 +160,92 @@ static void __inline__ out(int offset, int value)
 	}
 }
 
-static unsigned int __inline__ lirc_get_timer(void)
+static inline unsigned int lirc_get_timer(void)
 {
-	return(in(LIRC_PORT_TIMER)&LIRC_PORT_TIMER_BIT);
+	return (in(LIRC_PORT_TIMER)&LIRC_PORT_TIMER_BIT);
 }
 
-static unsigned int __inline__  lirc_get_signal(void)
+static inline  unsigned int lirc_get_signal(void)
 {
-	return(in(LIRC_PORT_SIGNAL)&LIRC_PORT_SIGNAL_BIT);
+	return (in(LIRC_PORT_SIGNAL)&LIRC_PORT_SIGNAL_BIT);
 }
 
-static void __inline__ lirc_on(void)
+static inline void lirc_on(void)
 {
 	out(LIRC_PORT_DATA, tx_mask);
 }
 
-static void __inline__ lirc_off(void)
+static inline void lirc_off(void)
 {
-	out(LIRC_PORT_DATA,0);
+	out(LIRC_PORT_DATA, 0);
 }
 
 static unsigned int init_lirc_timer(void)
 {
-	struct timeval tv,now;
-	unsigned int level,newlevel,timeelapsed,newtimer;
-	int count=0;
-	
+	struct timeval tv, now;
+	unsigned int level, newlevel, timeelapsed, newtimer;
+	int count = 0;
+
 	do_gettimeofday(&tv);
 	tv.tv_sec++;                     /* wait max. 1 sec. */
-	level=lirc_get_timer();
-	do
-	{
-		newlevel=lirc_get_timer();
-		if(level==0 && newlevel!=0) count++;
-		level=newlevel;
+	level = lirc_get_timer();
+	do {
+		newlevel = lirc_get_timer();
+		if (level == 0 && newlevel != 0)
+			count++;
+		level = newlevel;
 		do_gettimeofday(&now);
-	}
-	while(count<1000 && (now.tv_sec<tv.tv_sec 
-			     || (now.tv_sec==tv.tv_sec 
-				 && now.tv_usec<tv.tv_usec)));
-
-	timeelapsed=((now.tv_sec+1-tv.tv_sec)*1000000
-		     +(now.tv_usec-tv.tv_usec));
-	if(count>=1000 && timeelapsed>0)
-	{
-		if(default_timer==0)                    /* autodetect timer */
-		{
-			newtimer=(1000000*count)/timeelapsed;
+	} while (count < 1000 && (now.tv_sec < tv.tv_sec
+			     || (now.tv_sec == tv.tv_sec
+				 && now.tv_usec < tv.tv_usec)));
+
+	timeelapsed = ((now.tv_sec + 1 - tv.tv_sec)*1000000
+		     + (now.tv_usec - tv.tv_usec));
+	if (count >= 1000 && timeelapsed > 0) {
+		if (default_timer == 0) {
+			/* autodetect timer */
+			newtimer = (1000000*count)/timeelapsed;
 			printk(KERN_INFO "%s: %u Hz timer detected\n",
-			       LIRC_DRIVER_NAME,newtimer);
-			return(newtimer);
-		}
-		else
-		{
-			newtimer=(1000000*count)/timeelapsed;
-			if(abs(newtimer-default_timer)>
-			   default_timer/10) /* bad timer */
-			{
+			       LIRC_DRIVER_NAME, newtimer);
+			return newtimer;
+		}  else {
+			newtimer = (1000000*count)/timeelapsed;
+			if (abs(newtimer - default_timer) > default_timer/10) {
+				/* bad timer */
 				printk(KERN_NOTICE "%s: bad timer: %u Hz\n",
-				       LIRC_DRIVER_NAME,newtimer);
+				       LIRC_DRIVER_NAME, newtimer);
 				printk(KERN_NOTICE "%s: using default timer: "
 				       "%u Hz\n",
-				       LIRC_DRIVER_NAME,default_timer);
-				return(default_timer);
-			}
-			else
-			{
+				       LIRC_DRIVER_NAME, default_timer);
+				return default_timer;
+			} else {
 				printk(KERN_INFO "%s: %u Hz timer detected\n",
-				       LIRC_DRIVER_NAME,newtimer);
-				return(newtimer); /* use detected value */
+				       LIRC_DRIVER_NAME, newtimer);
+				return newtimer; /* use detected value */
 			}
 		}
-	}
-	else
-	{
-		printk(KERN_NOTICE "%s: no timer detected\n",LIRC_DRIVER_NAME);
-		return(0);
+	} else {
+		printk(KERN_NOTICE "%s: no timer detected\n", LIRC_DRIVER_NAME);
+		return 0;
 	}
 }
 
 static int lirc_claim(void)
 {
-	if(parport_claim(ppdevice)!=0)
-	{
+	if (parport_claim(ppdevice) != 0) {
 		printk(KERN_WARNING "%s: could not claim port\n",
 		       LIRC_DRIVER_NAME);
 		printk(KERN_WARNING "%s: waiting for port becoming available"
-		       "\n",LIRC_DRIVER_NAME);
-		if(parport_claim_or_block(ppdevice)<0)
-		{
+		       "\n", LIRC_DRIVER_NAME);
+		if (parport_claim_or_block(ppdevice) < 0) {
 			printk(KERN_NOTICE "%s: could not claim port, giving"
-			       " up\n",LIRC_DRIVER_NAME);
-			return(0);
+			       " up\n", LIRC_DRIVER_NAME);
+			return 0;
 		}
 	}
-	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
-	is_claimed=1;
-	return(1);
+	out(LIRC_LP_CONTROL, LP_PSELECP|LP_PINITP);
+	is_claimed = 1;
+	return 1;
 }
 
 /***********************************************************************
@@ -259,133 +256,118 @@ static inline void rbuf_write(lirc_t signal)
 {
 	unsigned int nwptr;
 
-	nwptr=(wptr+1) & (RBUF_SIZE-1);
-	if(nwptr==rptr) /* no new signals will be accepted */
-	{
+	nwptr = (wptr + 1) & (RBUF_SIZE - 1);
+	if (nwptr == rptr) {
+		/* no new signals will be accepted */
 		lost_irqs++;
-		printk(KERN_NOTICE "%s: buffer overrun\n",LIRC_DRIVER_NAME);
+		printk(KERN_NOTICE "%s: buffer overrun\n", LIRC_DRIVER_NAME);
 		return;
-	}	
-	rbuf[wptr]=signal;
-	wptr=nwptr;
+	}
+	rbuf[wptr] = signal;
+	wptr = nwptr;
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void irq_handler(int i,void *blah,struct pt_regs * regs)
+static void irq_handler(int i, void *blah, struct pt_regs *regs)
 #else
-static void irq_handler(int i,void *blah)
+static void irq_handler(int i, void *blah)
 #endif
 {
 	struct timeval tv;
 	static struct timeval lasttv;
-	static int init=0;
+	static int init;
 	long signal;
 	lirc_t data;
-	unsigned int level,newlevel;
+	unsigned int level, newlevel;
 	unsigned int timeout;
 
-	if(!MOD_IN_USE)
+	if (!MOD_IN_USE)
 		return;
 
-	if(!is_claimed)
-	{
+	if (!is_claimed)
 		return;
-	}
 
 	/* disable interrupt */
 	/*
 	  disable_irq(irq);
-	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)&(~LP_PINTEN));
+	  out(LIRC_PORT_IRQ, in(LIRC_PORT_IRQ) & (~LP_PINTEN));
 	*/
-	if(in(1)&LP_PSELECD)
-	{
+	if (check_pselecd && (in(1) & LP_PSELECD))
 		return;
-	}
 
 #ifdef LIRC_TIMER
-	if(init)
-	{
+	if (init) {
 		do_gettimeofday(&tv);
-		
-	        signal=tv.tv_sec-lasttv.tv_sec;
-		if(signal>15)
-		{
-			data=PULSE_MASK;  /* really long time */
-		}
+
+		signal = tv.tv_sec - lasttv.tv_sec;
+		if (signal > 15)
+			/* really long time */
+			data = PULSE_MASK;
 		else
-		{
-			data=(lirc_t) (signal*1000000+
-				       tv.tv_usec-lasttv.tv_usec+
-				       LIRC_SFH506_DELAY);
-		};
+			data = (lirc_t) (signal*1000000 +
+					 tv.tv_usec - lasttv.tv_usec +
+					 LIRC_SFH506_DELAY);
 
 		rbuf_write(data); /* space */
-	}
-	else
-	{
-		if(timer==0) /* wake up; we'll lose this signal 
-				but it will be garbage if the device 
-				is turned on anyway
-			      */
-		{
-			timer=init_lirc_timer();
+	} else {
+		if (timer == 0) {
+			/* wake up; we'll lose this signal
+			 * but it will be garbage if the device
+			 * is turned on anyway */
+			timer = init_lirc_timer();
 			/* enable_irq(irq); */
 			return;
 		}
-		init=1;
+		init = 1;
 	}
 
-	timeout=timer/10;           /* timeout after 1/10 sec. */
-	signal=1;
-	level=lirc_get_timer();
-	do{
-		newlevel=lirc_get_timer();
-		if(level==0 && newlevel!=0) signal++;
-		level=newlevel;
+	timeout = timer/10;	/* timeout after 1/10 sec. */
+	signal = 1;
+	level = lirc_get_timer();
+	do {
+		newlevel = lirc_get_timer();
+		if (level == 0 && newlevel != 0)
+			signal++;
+		level = newlevel;
 
 		/* giving up */
-		if(signal>timeout || (in(1)&LP_PSELECD))
-		{
-			signal=0;
-			printk(KERN_NOTICE "%s: timeout\n",LIRC_DRIVER_NAME);
+		if (signal > timeout
+		    || (check_pselecd && (in(1) & LP_PSELECD))) {
+			signal = 0;
+			printk(KERN_NOTICE "%s: timeout\n", LIRC_DRIVER_NAME);
 			break;
 		}
 	}
-	while(lirc_get_signal());
-	if(signal!=0)
-	{
+	while (lirc_get_signal());
+	if (signal != 0) {
 		/* ajust value to usecs */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
 		unsigned long long helper;
-		
+
 		helper = ((unsigned long long) signal)*1000000;
 		do_div(helper, timer);
 		signal = (long) helper;
 #else
-		signal=(long) ((((double) signal)*1000000)/timer);
+		signal = (long) ((((double) signal)*1000000)/timer);
 #endif
 
-		if(signal>LIRC_SFH506_DELAY)
-		{
-			data=signal-LIRC_SFH506_DELAY;
-		}
+		if (signal > LIRC_SFH506_DELAY)
+			data = signal - LIRC_SFH506_DELAY;
 		else
-		{
-			data=1;
-		}
+			data = 1;
 		rbuf_write(PULSE_BIT|data); /* pulse */
 	}
 	do_gettimeofday(&lasttv);
 #else
 	/* add your code here */
 #endif
-	
+
 	wake_up_interruptible(&lirc_wait);
 
 	/* enable interrupt */
 	/*
 	  enable_irq(irq);
-	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)|LP_PINTEN);
+	  out(LIRC_PORT_IRQ, in(LIRC_PORT_IRQ)|LP_PINTEN);
 	*/
 }
 
@@ -393,240 +375,236 @@ static void irq_handler(int i,void *blah)
  **************************   file_operations   ************************
  ***********************************************************************/
 
-static loff_t lirc_lseek(struct file *filep,loff_t offset,int orig)
+static loff_t lirc_lseek(struct file *filep, loff_t offset, int orig)
 {
-	return(-ESPIPE);
+	return -ESPIPE;
 }
 
-static ssize_t lirc_read(struct file *filep,char *buf,size_t n,loff_t *ppos)
+static ssize_t lirc_read(struct file *filep, char *buf, size_t n, loff_t *ppos)
 {
-	int result=0;
-	int count=0;
+	int result = 0;
+	int count = 0;
 	DECLARE_WAITQUEUE(wait, current);
-	
-	if(n%sizeof(lirc_t)) return(-EINVAL);
-	
-	add_wait_queue(&lirc_wait,&wait);
+
+	if (n % sizeof(lirc_t))
+		return -EINVAL;
+
+	add_wait_queue(&lirc_wait, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
-	while(count<n)
-	{
-		if(rptr!=wptr)
-		{
-			if(copy_to_user(buf+count,(char *) &rbuf[rptr],
-					sizeof(lirc_t)))
-			{
+	while (count < n) {
+		if (rptr != wptr) {
+			if (copy_to_user(buf+count, (char *) &rbuf[rptr],
+					 sizeof(lirc_t))) {
 				result = -EFAULT;
 				break;
 			}
-			rptr=(rptr+1)&(RBUF_SIZE-1);
-			count+=sizeof(lirc_t);
-		}
-		else
-		{
-			if(filep->f_flags & O_NONBLOCK)
-			{
-				result=-EAGAIN;
+			rptr = (rptr + 1) & (RBUF_SIZE - 1);
+			count += sizeof(lirc_t);
+		} else {
+			if (filep->f_flags & O_NONBLOCK) {
+				result = -EAGAIN;
 				break;
 			}
-			if (signal_pending(current))
-			{
-				result=-ERESTARTSYS;
+			if (signal_pending(current)) {
+				result = -ERESTARTSYS;
 				break;
 			}
 			schedule();
 			set_current_state(TASK_INTERRUPTIBLE);
 		}
 	}
-	remove_wait_queue(&lirc_wait,&wait);
+	remove_wait_queue(&lirc_wait, &wait);
 	set_current_state(TASK_RUNNING);
-	return(count ? count:result);
+	return (count ? count : result);
 }
 
-static ssize_t lirc_write(struct file *filep,const char *buf,size_t n,
+static ssize_t lirc_write(struct file *filep, const char *buf, size_t n,
 			  loff_t *ppos)
 {
 	int count;
 	unsigned int i;
-	unsigned int level,newlevel;
+	unsigned int level, newlevel;
 	unsigned long flags;
 	lirc_t counttimer;
-	
-	if(!is_claimed)
-	{
+
+	if (!is_claimed)
 		return(-EBUSY);
-	}
-	if(n%sizeof(lirc_t)) return(-EINVAL);
-	
-	count=n/sizeof(lirc_t);
-	
-	if(count>WBUF_SIZE || count%2==0) return(-EINVAL);
-	
-	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
-	
+
+	if (n % sizeof(lirc_t))
+		return(-EINVAL);
+
+	count = n / sizeof(lirc_t);
+
+	if (count > WBUF_SIZE || count % 2 == 0)
+		return(-EINVAL);
+
+	if (copy_from_user(wbuf, buf, n))
+		return -EFAULT;
+
 #ifdef LIRC_TIMER
-	if(timer==0) /* try again if device is ready */
-	{
-		timer=init_lirc_timer();
-		if(timer==0) return(-EIO);
+	if (timer == 0) {
+		/* try again if device is ready */
+		timer = init_lirc_timer();
+		if (timer == 0)
+			return(-EIO);
 	}
 
 	/* ajust values from usecs */
-	for(i=0;i<count;i++)
-	{
+	for (i = 0; i < count; i++) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
 		unsigned long long helper;
-		
+
 		helper = ((unsigned long long) wbuf[i])*timer;
 		do_div(helper, 1000000);
 		wbuf[i] = (lirc_t) helper;
 #else
-		wbuf[i]=(lirc_t) (((double) wbuf[i])*timer/1000000);
+		wbuf[i] = (lirc_t) (((double) wbuf[i])*timer/1000000);
 #endif
 	}
-	
+
 	local_irq_save(flags);
-	i=0;
-	while(i<count)
-	{
-		level=lirc_get_timer();
-		counttimer=0;
+	i = 0;
+	while (i < count) {
+		level = lirc_get_timer();
+		counttimer = 0;
 		lirc_on();
-		do
-		{
-			newlevel=lirc_get_timer();
-			if(level==0 && newlevel!=0) counttimer++;
-			level=newlevel;
-			if(in(1)&LP_PSELECD)
-			{
+		do {
+			newlevel = lirc_get_timer();
+			if (level == 0 && newlevel != 0)
+				counttimer++;
+			level = newlevel;
+			if (check_pselecd && (in(1) & LP_PSELECD)) {
 				lirc_off();
 				local_irq_restore(flags);
-				return(-EIO);
+				return -EIO;
 			}
-		}
-		while(counttimer<wbuf[i]);i++;
-		
+		} while (counttimer < wbuf[i]);
+		i++;
+
 		lirc_off();
-		if(i==count) break;
-		counttimer=0;
-		do
-		{
-			newlevel=lirc_get_timer();
-			if(level==0 && newlevel!=0) counttimer++;
-			level=newlevel;
-			if(in(1)&LP_PSELECD)
-			{
+		if (i == count)
+			break;
+		counttimer = 0;
+		do {
+			newlevel = lirc_get_timer();
+			if (level == 0 && newlevel != 0)
+				counttimer++;
+			level = newlevel;
+			if (check_pselecd && (in(1) & LP_PSELECD)) {
 				local_irq_restore(flags);
-				return(-EIO);
+				return -EIO;
 			}
-		}
-		while(counttimer<wbuf[i]);i++;
+		} while (counttimer < wbuf[i]);
+		i++;
 	}
 	local_irq_restore(flags);
 #else
-	/* 
-	   place code that handles write
-	   without extarnal timer here
-	*/
+	/* place code that handles write
+	 * without external timer here */
 #endif
-	return(n);
+	return n;
 }
 
-static unsigned int lirc_poll(struct file *file, poll_table * wait)
+static unsigned int lirc_poll(struct file *file, poll_table *wait)
 {
-	poll_wait(file, &lirc_wait,wait);
-	if (rptr!=wptr)
-		return(POLLIN|POLLRDNORM);
-	return(0);
+	poll_wait(file, &lirc_wait, wait);
+	if (rptr != wptr)
+		return (POLLIN|POLLRDNORM);
+	return 0;
 }
 
-static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+static int lirc_ioctl(struct inode *node, struct file *filep, unsigned int cmd,
 		      unsigned long arg)
 {
-        int result;
-	unsigned long features=LIRC_CAN_SET_TRANSMITTER_MASK|LIRC_CAN_SEND_PULSE|LIRC_CAN_REC_MODE2,mode;
+	int result;
+	unsigned long features = LIRC_CAN_SET_TRANSMITTER_MASK |
+				 LIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;
+	unsigned long mode;
 	unsigned int ivalue;
-	
-	switch(cmd)
-	{
+
+	switch (cmd) {
 	case LIRC_GET_FEATURES:
-		result=put_user(features,(unsigned long *) arg);
-		if(result) return(result); 
+		result = put_user(features, (unsigned long *) arg);
+		if (result)
+			return result;
 		break;
 	case LIRC_GET_SEND_MODE:
-		result=put_user(LIRC_MODE_PULSE,(unsigned long *) arg);
-		if(result) return(result); 
+		result = put_user(LIRC_MODE_PULSE, (unsigned long *) arg);
+		if (result)
+			return result;
 		break;
 	case LIRC_GET_REC_MODE:
-		result=put_user(LIRC_MODE_MODE2,(unsigned long *) arg);
-		if(result) return(result); 
+		result = put_user(LIRC_MODE_MODE2, (unsigned long *) arg);
+		if (result)
+			return result;
 		break;
 	case LIRC_SET_SEND_MODE:
-		result=get_user(mode,(unsigned long *) arg);
-		if(result) return(result);
-		if(mode!=LIRC_MODE_PULSE) return(-EINVAL);
+		result = get_user(mode, (unsigned long *) arg);
+		if (result)
+			return result;
+		if (mode != LIRC_MODE_PULSE)
+			return -EINVAL;
 		break;
 	case LIRC_SET_REC_MODE:
-		result=get_user(mode,(unsigned long *) arg);
-		if(result) return(result);
-		if(mode!=LIRC_MODE_MODE2) return(-ENOSYS);
+		result = get_user(mode, (unsigned long *) arg);
+		if (result)
+			return result;
+		if (mode != LIRC_MODE_MODE2)
+			return -ENOSYS;
 		break;
 	case LIRC_SET_TRANSMITTER_MASK:
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		if((ivalue&LIRC_PARALLEL_TRANSMITTER_MASK) != ivalue) return (LIRC_PARALLEL_MAX_TRANSMITTERS);
+		result = get_user(ivalue, (unsigned int *) arg);
+		if (result)
+			return result;
+		if ((ivalue & LIRC_PARALLEL_TRANSMITTER_MASK) != ivalue)
+			return LIRC_PARALLEL_MAX_TRANSMITTERS;
 		tx_mask = ivalue;
 		break;
 	default:
-		return(-ENOIOCTLCMD);
+		return -ENOIOCTLCMD;
 	}
-	return(0);
+	return 0;
 }
 
-static int lirc_open(struct inode* node,struct file* filep)
+static int lirc_open(struct inode *node, struct file *filep)
 {
-	if(MOD_IN_USE)
-	{
-		return(-EBUSY);
-	}
-	if(!lirc_claim())
-	{
-		return(-EBUSY);
-	}
+	if (MOD_IN_USE || !lirc_claim())
+		return -EBUSY;
+
 	parport_enable_irq(pport);
 
 	/* init read ptr */
-	rptr=wptr=0;
-	lost_irqs=0;
+	rptr = 0;
+	wptr = 0;
+	lost_irqs = 0;
 
 	MOD_INC_USE_COUNT;
-	is_open=1;
-	return(0);
+	is_open = 1;
+	return 0;
 }
 
-static int lirc_close(struct inode* node,struct file* filep)
+static int lirc_close(struct inode *node, struct file *filep)
 {
-	if(is_claimed)
-	{
-		is_claimed=0;
+	if (is_claimed) {
+		is_claimed = 0;
 		parport_release(ppdevice);
 	}
-	is_open=0;
+	is_open = 0;
 	MOD_DEC_USE_COUNT;
-	return(0);
+	return 0;
 }
 
-static struct file_operations lirc_fops = 
-{
-	llseek:  lirc_lseek,
-	read:    lirc_read,
-	write:   lirc_write,
-	poll:    lirc_poll,
-	ioctl:   lirc_ioctl,
-	open:    lirc_open,
-	release: lirc_close
+static struct file_operations lirc_fops = {
+	.llseek		= lirc_lseek,
+	.read		= lirc_read,
+	.write		= lirc_write,
+	.poll		= lirc_poll,
+	.ioctl		= lirc_ioctl,
+	.open		= lirc_open,
+	.release	= lirc_close
 };
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_INC_USE_COUNT;
@@ -634,7 +612,7 @@ static int set_use_inc(void* data)
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_DEC_USE_COUNT;
@@ -642,18 +620,18 @@ static void set_use_dec(void* data)
 }
 
 static struct lirc_plugin plugin = {
-       name:           LIRC_DRIVER_NAME,
-       minor:          -1,
-       code_length:    1,
-       sample_rate:    0,
-       data:           NULL,
-       add_to_buf:     NULL,
-       get_queue:      NULL,
-       set_use_inc:    set_use_inc,
-       set_use_dec:    set_use_dec,
-       fops:           &lirc_fops,
-       dev:            NULL,
-       owner:          THIS_MODULE,
+       .name		= LIRC_DRIVER_NAME,
+       .minor		= -1,
+       .code_length	= 1,
+       .sample_rate	= 0,
+       .data		= NULL,
+       .add_to_buf	= NULL,
+       .get_queue	= NULL,
+       .set_use_inc	= set_use_inc,
+       .set_use_dec	= set_use_dec,
+       .fops		= &lirc_fops,
+       .dev		= NULL,
+       .owner		= THIS_MODULE,
 };
 
 #ifdef MODULE
@@ -669,17 +647,16 @@ static void poll_state(unsigned long ignored)
 	printk(KERN_NOTICE "%s: time\n",
 	       LIRC_DRIVER_NAME);
 	del_timer(&poll_timer);
-	if(is_claimed)
+	if (is_claimed)
 		return;
 	kf(NULL);
-	if(!is_claimed)
-	{
+	if (!is_claimed) {
 		printk(KERN_NOTICE "%s: could not claim port, giving up\n",
 		       LIRC_DRIVER_NAME);
 		init_timer(&poll_timer);
-		poll_timer.expires=jiffies+HZ;
-		poll_timer.data=(unsigned long) current;
-		poll_timer.function=poll_state;
+		poll_timer.expires = jiffies + HZ;
+		poll_timer.data = (unsigned long)current;
+		poll_timer.function = poll_state;
 		add_timer(&poll_timer);
 	}
 }
@@ -687,21 +664,21 @@ static void poll_state(unsigned long ignored)
 static int pf(void *handle)
 {
 	parport_disable_irq(pport);
-	is_claimed=0;
-	return(0);
+	is_claimed = 0;
+	return 0;
 }
 
 static void kf(void *handle)
 {
-	if(!is_open)
+	if (!is_open)
 		return;
-	if(!lirc_claim())
+	if (!lirc_claim())
 		return;
 	parport_enable_irq(pport);
 	lirc_off();
 	/* this is a bit annoying when you actually print...*/
 	/*
-	printk(KERN_INFO "%s: reclaimed port\n",LIRC_DRIVER_NAME);
+	printk(KERN_INFO "%s: reclaimed port\n", LIRC_DRIVER_NAME);
 	*/
 }
 
@@ -712,77 +689,69 @@ static void kf(void *handle)
 int init_module(void)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 3)
-	pport=parport_find_base(io);
+	pport = parport_find_base(io);
 #else
-	pport=parport_enumerate();
-	while(pport!=NULL)
-	{
-		if(pport->base==io)
-		{
+	pport = parport_enumerate();
+	while (pport != NULL) {
+		if (pport->base == io)
 			break;
-		}
-		pport=pport->next;
+		pport = pport->next;
 	}
 #endif
-	if(pport==NULL)
-	{
+	if (pport == NULL) {
 		printk(KERN_NOTICE "%s: no port at %x found\n",
-		       LIRC_DRIVER_NAME,io);
-		return(-ENXIO);
+		       LIRC_DRIVER_NAME, io);
+		return -ENXIO;
 	}
-	ppdevice=parport_register_device(pport,LIRC_DRIVER_NAME,
-					 pf,kf,irq_handler,0,NULL);
+	ppdevice = parport_register_device(pport, LIRC_DRIVER_NAME,
+					   pf, kf, irq_handler, 0, NULL);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 3)
 	parport_put_port(pport);
 #endif
-	if(ppdevice==NULL)
-	{
+	if (ppdevice == NULL) {
 		printk(KERN_NOTICE "%s: parport_register_device() failed\n",
 		       LIRC_DRIVER_NAME);
-		return(-ENXIO);
+		return -ENXIO;
 	}
-	if(parport_claim(ppdevice)!=0)
+	if (parport_claim(ppdevice) != 0)
 		goto skip_init;
-	is_claimed=1;
-	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
+	is_claimed = 1;
+	out(LIRC_LP_CONTROL, LP_PSELECP|LP_PINITP);
 
 #ifdef LIRC_TIMER
-	if(debug) 
-	{
+	if (debug)
 		out(LIRC_PORT_DATA, tx_mask);
-	}
-	
-	timer=init_lirc_timer();
 
-#       if 0 	/* continue even if device is offline */
-	if(timer==0) 
-	{
-		is_claimed=0;
+	timer = init_lirc_timer();
+
+#if 0	/* continue even if device is offline */
+	if (timer == 0) {
+		is_claimed = 0;
 		parport_release(pport);
 		parport_unregister_device(ppdevice);
-		return(-EIO);
+		return -EIO;
 	}
-	
-#       endif
-	if(debug)
-	{
-		out(LIRC_PORT_DATA,0);
-	}
-#endif 
 
-	is_claimed=0;
+#endif
+	if (debug)
+		out(LIRC_PORT_DATA, 0);
+#endif
+
+	is_claimed = 0;
 	parport_release(ppdevice);
  skip_init:
-	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0)
-	{
-		printk(KERN_NOTICE "%s: register_chrdev() failed\n",LIRC_DRIVER_NAME);
+	plugin.minor = lirc_register_plugin(&plugin);
+	if (plugin.minor < 0) {
+		printk(KERN_NOTICE "%s: register_chrdev() failed\n",
+		       LIRC_DRIVER_NAME);
 		parport_unregister_device(ppdevice);
-		return(-EIO);
+		return -EIO;
 	}
-	printk(KERN_INFO "%s: installed using port 0x%04x irq %d\n",LIRC_DRIVER_NAME,io,irq);
-	return(0);
+	printk(KERN_INFO "%s: installed using port 0x%04x irq %d\n",
+	       LIRC_DRIVER_NAME, io, irq);
+	return 0;
 }
-  
+
 void cleanup_module(void)
 {
 	parport_unregister_device(ppdevice);
@@ -805,6 +774,9 @@ MODULE_PARM_DESC(tx_maxk, "Transmitter mask (default: 0x01)");
 module_param(debug, bool, 0644);
 MODULE_PARM_DESC(debug, "Enable debugging messages");
 
+module_param(check_pselecd, bool, 0644);
+MODULE_PARM_DESC(debug, "Check for printer (default: 0)");
+
 EXPORT_NO_SYMBOLS;
 
 #endif /* MODULE */
diff --git a/drivers/char/lirc/lirc_sasem.c b/drivers/char/lirc/lirc_sasem.c
index 0bd5883..d1167ce 100644
--- a/drivers/char/lirc/lirc_sasem.c
+++ b/drivers/char/lirc/lirc_sasem.c
@@ -1,10 +1,10 @@
-/*      $Id: lirc_sasem.c,v 1.19 2007/04/29 14:23:04 lirc Exp $      */
+/*      $Id: lirc_sasem.c,v 1.21 2007/09/30 09:58:46 lirc Exp $      */
 
 /* lirc_sasem.c - USB remote support for LIRC
- * Version 0.5 
+ * Version 0.5
  *
  * Copyright (C) 2004-2005 Oliver Stabel <oliver.stabel@gmx.de>
- *                         Tim Davies <tim@opensystems.net.au>
+ *			 Tim Davies <tim@opensystems.net.au>
  *
  * This driver was derived from:
  *   Venky Raju <dev@venky.ws>
@@ -16,24 +16,26 @@
  *
  *
  * 2004/06/13   -   0.1
- *                  initial version
+ *		  initial version
  *
  * 2004/06/28   -   0.2
- *                  added file system support to write data to VFD device (used  
- *                  in conjunction with LCDProc)
+ *		  added file system support to write data to VFD device (used
+ *		  in conjunction with LCDProc)
  *
  * 2004/11/22   -   0.3
- *                  Ported to 2.6 kernel - Tim Davies <tim@opensystems.net.au>
+ *		  Ported to 2.6 kernel
+ *		  	- Tim Davies <tim@opensystems.net.au>
  *
  * 2005/03/29   -   0.4
- *                  A few tidyups and keypress timings - Tim Davies <tim@opensystems.net.au>
+ *		  A few tidyups and keypress timings
+ *		  	- Tim Davies <tim@opensystems.net.au>
  *
  * 2005/06/23   -   0.5
- *                  A complete rewrite (shamelessly) based on lirc_imon.c
- *                  Tim Davies <tim@opensystems.net.au>
+ *		  A complete rewrite (shamelessly) based on lirc_imon.c
+ *		  Tim Davies <tim@opensystems.net.au>
  *
  * NOTE - The LCDproc iMon driver should work with this module.  More info at
- *        http://www.frogstorm.info/sasem
+ *	http://www.frogstorm.info/sasem
  */
 
 /*
@@ -54,7 +56,7 @@
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 22)
 #error "*** Sorry, this driver requires kernel version 2.4.22 or higher"
 #endif
 
@@ -65,7 +67,11 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
 #include <linux/usb.h>
 
 #include "kcompat.h"
@@ -73,13 +79,14 @@
 #include "lirc_dev.h"
 
 
-#define MOD_AUTHOR	"Oliver Stabel <oliver.stabel@gmx.de>, Tim Davies <tim@opensystems.net.au>"
+#define MOD_AUTHOR	"Oliver Stabel <oliver.stabel@gmx.de>, " \
+			"Tim Davies <tim@opensystems.net.au>"
 #define MOD_DESC	"USB Driver for Sasem Remote Controller V1.1"
 #define MOD_NAME	"lirc_sasem"
 #define MOD_VERSION	"0.5"
 
 #define VFD_MINOR_BASE	144	/* Same as LCD */
-#define DEVFS_MODE	S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
+#define DEVFS_MODE S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
 #define DEVFS_NAME	LIRC_DEVFS_PREFIX "lcd%d"
 
 #define BUF_CHUNK_SIZE	8
@@ -92,48 +99,48 @@
 #define IOCTL_LCD_CONTRAST 1
 
 /* ------------------------------------------------------------
- *                     P R O T O T Y P E S
+ *		     P R O T O T Y P E S
  * ------------------------------------------------------------
  */
 
 /* USB Callback prototypes */
 #ifdef KERNEL_2_5
-static int sasem_probe (struct usb_interface *interface,
+static int sasem_probe(struct usb_interface *interface,
 			const struct usb_device_id *id);
-static void sasem_disconnect (struct usb_interface *interface);
+static void sasem_disconnect(struct usb_interface *interface);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_rx_callback (struct urb *urb, struct pt_regs *regs);
-static void usb_tx_callback (struct urb *urb, struct pt_regs *regs);
+static void usb_rx_callback(struct urb *urb, struct pt_regs *regs);
+static void usb_tx_callback(struct urb *urb, struct pt_regs *regs);
 #else
-static void usb_rx_callback (struct urb *urb);
-static void usb_tx_callback (struct urb *urb);
+static void usb_rx_callback(struct urb *urb);
+static void usb_tx_callback(struct urb *urb);
 #endif
 #else
-static void * sasem_probe (struct usb_device * dev, unsigned int intf,
+static void *sasem_probe(struct usb_device *dev, unsigned int intf,
 				const struct usb_device_id *id);
-static void sasem_disconnect (struct usb_device *dev, void *data);
-static void usb_rx_callback (struct urb *urb);
-static void usb_tx_callback (struct urb *urb);
+static void sasem_disconnect(struct usb_device *dev, void *data);
+static void usb_rx_callback(struct urb *urb);
+static void usb_tx_callback(struct urb *urb);
 #endif
 
 /* VFD file_operations function prototypes */
-static int vfd_open (struct inode *inode, struct file *file);
-static int vfd_ioctl (struct inode *inode, struct file *file, 
+static int vfd_open(struct inode *inode, struct file *file);
+static int vfd_ioctl(struct inode *inode, struct file *file,
 				unsigned cmd, unsigned long arg);
-static int vfd_close (struct inode *inode, struct file *file);
-static ssize_t vfd_write (struct file *file, const char *buf,
+static int vfd_close(struct inode *inode, struct file *file);
+static ssize_t vfd_write(struct file *file, const char *buf,
 				size_t n_bytes, loff_t *pos);
 
 /* LIRC plugin function prototypes */
-static int ir_open (void *data);
-static void ir_close (void *data);
+static int ir_open(void *data);
+static void ir_close(void *data);
 
 /* Driver init/exit prototypes */
-static int __init sasem_init (void);
-static void __exit sasem_exit (void);
+static int __init sasem_init(void);
+static void __exit sasem_exit(void);
 
 /* ------------------------------------------------------------
- *                     G L O B A L S
+ *		     G L O B A L S
  * ------------------------------------------------------------
  */
 
@@ -141,14 +148,14 @@ struct sasem_context {
 
 	struct usb_device *dev;
 	int vfd_isopen;			/* VFD port has been opened       */
-	unsigned int vfd_contrast;	/* VFD contrast                   */
-#if !defined (KERNEL_2_5)
-	int subminor;			/* index into minor_table         */
+	unsigned int vfd_contrast;	/* VFD contrast		   */
+#if !defined(KERNEL_2_5)
+	int subminor;			/* index into minor_table	 */
 	devfs_handle_t devfs;
 #endif
-	int ir_isopen;			/* IR port has been opened        */
-	int dev_present;		/* USB device presence            */
-	struct semaphore sem;		/* to lock this object            */
+	int ir_isopen;			/* IR port has been opened	*/
+	int dev_present;		/* USB device presence	    */
+	struct semaphore sem;		/* to lock this object	    */
 	wait_queue_head_t remove_ok;	/* For unexpected USB disconnects */
 
 	struct lirc_plugin *plugin;
@@ -160,9 +167,9 @@ struct sasem_context {
 	unsigned char usb_tx_buf [8];
 
 	struct tx_t {
-		unsigned char data_buf [32]; /* user data buffer          */
+		unsigned char data_buf [32]; /* user data buffer	  */
 		struct completion finished;  /* wait for write to finish  */
-		atomic_t busy;		     /* write in progress         */
+		atomic_t busy;		     /* write in progress	 */
 		int status;		     /* status of tx completion   */
 	} tx;
 
@@ -172,8 +179,8 @@ struct sasem_context {
 	int codesaved;
 };
 
-#define LOCK_CONTEXT	down (&context ->sem)
-#define UNLOCK_CONTEXT	up (&context ->sem)
+#define LOCK_CONTEXT	down(&context->sem)
+#define UNLOCK_CONTEXT	up(&context->sem)
 
 /* VFD file operations */
 static struct file_operations vfd_fops = {
@@ -216,14 +223,14 @@ static struct usb_class_driver sasem_class = {
 #endif
 
 /* to prevent races between open() and disconnect() */
-static DECLARE_MUTEX (disconnect_sem);
+static DECLARE_MUTEX(disconnect_sem);
 
-static int debug = 0;
+static int debug;
 
 #if !defined(KERNEL_2_5)
 
 #define MAX_DEVICES	4	/* In case there's more than one Sasem device */
-static struct sasem_context * minor_table [MAX_DEVICES];
+static struct sasem_context *minor_table [MAX_DEVICES];
 
 /* the global usb devfs handle */
 extern devfs_handle_t usb_devfs_handle;
@@ -231,40 +238,40 @@ extern devfs_handle_t usb_devfs_handle;
 #endif
 
 /* ------------------------------------------------------------
- *                     M O D U L E   C O D E
+ *		     M O D U L E   C O D E
  * ------------------------------------------------------------
  */
 
-MODULE_AUTHOR (MOD_AUTHOR);
-MODULE_DESCRIPTION (MOD_DESC);
-MODULE_LICENSE ("GPL");
-module_param (debug, int, 0);
-MODULE_PARM_DESC (debug, "Debug messages: 0=no, 1=yes (default: no)");
-
-static inline void delete_context (struct sasem_context *context) {
+MODULE_AUTHOR(MOD_AUTHOR);
+MODULE_DESCRIPTION(MOD_DESC);
+MODULE_LICENSE("GPL");
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug messages: 0=no, 1=yes (default: no)");
 
-	usb_free_urb (context ->tx_urb);  /* VFD */
-	usb_free_urb (context ->rx_urb);  /* IR */
-	lirc_buffer_free (context ->plugin ->rbuf);
-	kfree (context ->plugin ->rbuf);
-	kfree (context ->plugin);
-	kfree (context);
-
-	if (debug) info ("%s: context deleted", __FUNCTION__);
+static inline void delete_context(struct sasem_context *context)
+{
+	usb_free_urb(context->tx_urb);  /* VFD */
+	usb_free_urb(context->rx_urb);  /* IR */
+	lirc_buffer_free(context->plugin->rbuf);
+	kfree(context->plugin->rbuf);
+	kfree(context->plugin);
+	kfree(context);
+
+	if (debug)
+		info("%s: context deleted", __FUNCTION__);
 }
 
-static inline void deregister_from_lirc (struct sasem_context *context) {
-
+static inline void deregister_from_lirc(struct sasem_context *context)
+{
 	int retval;
-	int minor = context ->plugin ->minor;
+	int minor = context->plugin->minor;
 
-	if ((retval = lirc_unregister_plugin (minor))) {
-
-		err ("%s: unable to deregister from lirc (%d)", 
+	retval = lirc_unregister_plugin(minor);
+	if (retval)
+		err("%s: unable to deregister from lirc (%d)",
 			__FUNCTION__, retval);
-	}
 	else
-		info ("Deregistered Sasem plugin (minor:%d)", minor);
+		info("Deregistered Sasem plugin (minor:%d)", minor);
 
 }
 
@@ -272,7 +279,7 @@ static inline void deregister_from_lirc (struct sasem_context *context) {
  * Called when the VFD device (e.g. /dev/usb/lcd)
  * is opened by the application.
  */
-static int vfd_open (struct inode *inode, struct file *file)
+static int vfd_open(struct inode *inode, struct file *file)
 {
 #ifdef KERNEL_2_5
 	struct usb_interface *interface;
@@ -282,21 +289,22 @@ static int vfd_open (struct inode *inode, struct file *file)
 	int retval = SUCCESS;
 
 	/* prevent races with disconnect */
-	down (&disconnect_sem);
-	
+	down(&disconnect_sem);
+
 #ifdef KERNEL_2_5
-	subminor = iminor (inode);
-	interface = usb_find_interface (&sasem_driver, subminor);
+	subminor = iminor(inode);
+	interface = usb_find_interface(&sasem_driver, subminor);
 	if (!interface) {
-		err ("%s: could not find interface for minor %d", __FUNCTION__, subminor);
+		err("%s: could not find interface for minor %d",
+		    __FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
 	}
-	context = usb_get_intfdata (interface);
+	context = usb_get_intfdata(interface);
 #else
-	subminor = MINOR (inode ->i_rdev) - VFD_MINOR_BASE;
+	subminor = MINOR(inode->i_rdev) - VFD_MINOR_BASE;
 	if (subminor < 0 || subminor >= MAX_DEVICES) {
-		err ("%s: no record of minor %d", __FUNCTION__, subminor);
+		err("%s: no record of minor %d", __FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
 	}
@@ -304,7 +312,7 @@ static int vfd_open (struct inode *inode, struct file *file)
 #endif
 
 	if (!context) {
-		err ("%s: no context found for minor %d", 
+		err("%s: no context found for minor %d",
 					__FUNCTION__, subminor);
 		retval = -ENODEV;
 		goto exit;
@@ -312,22 +320,20 @@ static int vfd_open (struct inode *inode, struct file *file)
 
 	LOCK_CONTEXT;
 
-	if (context ->vfd_isopen) {
-		
-		err ("%s: VFD port is already open", __FUNCTION__);
+	if (context->vfd_isopen) {
+		err("%s: VFD port is already open", __FUNCTION__);
 		retval = -EBUSY;
-	}
-	else {
+	} else {
 		MOD_INC_USE_COUNT;
-		context ->vfd_isopen = TRUE;
-		file ->private_data = context;
-		info ("VFD port opened");
+		context->vfd_isopen = TRUE;
+		file->private_data = context;
+		info("VFD port opened");
 	}
 
 	UNLOCK_CONTEXT;
 
 exit:
-	up (&disconnect_sem);
+	up(&disconnect_sem);
 	return retval;
 }
 
@@ -335,29 +341,32 @@ exit:
  * Called when the VFD device (e.g. /dev/usb/lcd)
  * is closed by the application.
  */
-static int vfd_ioctl (struct inode *inode, struct file *file, unsigned cmd, unsigned long arg)
+static int vfd_ioctl(struct inode *inode, struct file *file,
+		     unsigned cmd, unsigned long arg)
 {
 	struct sasem_context *context = NULL;
 
-	context = (struct sasem_context *) file ->private_data;
+	context = (struct sasem_context *) file->private_data;
 
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
 	switch (cmd) {
-		case IOCTL_LCD_CONTRAST:
-			if (arg > 1000) arg = 1000;
-			if (arg < 0) arg = 0;
-			context ->vfd_contrast = (unsigned int)arg;
-			break;  
-		default:
-			info ("Unknown IOCTL command");
-			UNLOCK_CONTEXT;
-			return -ENOIOCTLCMD;  /* not supported */
+	case IOCTL_LCD_CONTRAST:
+		if (arg > 1000)
+			arg = 1000;
+		if (arg < 0)
+			arg = 0;
+		context->vfd_contrast = (unsigned int)arg;
+		break;
+	default:
+		info("Unknown IOCTL command");
+		UNLOCK_CONTEXT;
+		return -ENOIOCTLCMD;  /* not supported */
 	}
 
 	UNLOCK_CONTEXT;
@@ -368,34 +377,34 @@ static int vfd_ioctl (struct inode *inode, struct file *file, unsigned cmd, unsi
  * Called when the VFD device (e.g. /dev/usb/lcd)
  * is closed by the application.
  */
-static int vfd_close (struct inode *inode, struct file *file)
+static int vfd_close(struct inode *inode, struct file *file)
 {
 	struct sasem_context *context = NULL;
 	int retval = SUCCESS;
 
-	context = (struct sasem_context *) file ->private_data;
+	context = (struct sasem_context *) file->private_data;
 
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
-	if (!context ->vfd_isopen) {
-		err ("%s: VFD is not open", __FUNCTION__);
+	if (!context->vfd_isopen) {
+		err("%s: VFD is not open", __FUNCTION__);
 		retval = -EIO;
-	}
-	else {
-		context ->vfd_isopen = FALSE;
+	} else {
+		context->vfd_isopen = FALSE;
 		MOD_DEC_USE_COUNT;
-		info ("VFD port closed");
-		if (!context ->dev_present && !context ->ir_isopen) {
+		info("VFD port closed");
+		if (!context->dev_present && !context->ir_isopen) {
 
-			/* Device disconnected before close and IR port is not open.  */
-			/* If IR port is open, context will be deleted by ir_close.   */
+			/* Device disconnected before close and IR port is
+			 * not open. If IR port is open, context will be
+			 * deleted by ir_close. */
 			UNLOCK_CONTEXT;
-			delete_context (context);
+			delete_context(context);
 			return retval;
 		}
 	}
@@ -407,45 +416,44 @@ static int vfd_close (struct inode *inode, struct file *file)
 /**
  * Sends a packet to the VFD.
  */
-static inline int send_packet (struct sasem_context *context)
+static inline int send_packet(struct sasem_context *context)
 {
 	unsigned int pipe;
 	int interval = 0;
 	int retval = SUCCESS;
 
-	pipe = usb_sndintpipe (context ->dev,
-			context-> tx_endpoint ->bEndpointAddress);
+	pipe = usb_sndintpipe(context->dev,
+			context->tx_endpoint->bEndpointAddress);
 #ifdef KERNEL_2_5
-	interval = context ->tx_endpoint ->bInterval;
+	interval = context->tx_endpoint->bInterval;
 #endif	/* Use 0 for 2.4 kernels */
 
-	usb_fill_int_urb (context ->tx_urb, context ->dev, pipe,
-		context ->usb_tx_buf, sizeof (context ->usb_tx_buf),
+	usb_fill_int_urb(context->tx_urb, context->dev, pipe,
+		context->usb_tx_buf, sizeof(context->usb_tx_buf),
 		usb_tx_callback, context, interval);
 
-	context ->tx_urb ->actual_length = 0;
+	context->tx_urb->actual_length = 0;
 
-	init_completion (&context ->tx.finished);
-	atomic_set (&(context ->tx.busy), 1);
+	init_completion(&context->tx.finished);
+	atomic_set(&(context->tx.busy), 1);
 
 #ifdef KERNEL_2_5
-	retval =  usb_submit_urb (context ->tx_urb, GFP_KERNEL);
+	retval =  usb_submit_urb(context->tx_urb, GFP_KERNEL);
 #else
-	retval =  usb_submit_urb (context ->tx_urb);
+	retval =  usb_submit_urb(context->tx_urb);
 #endif
 	if (retval != SUCCESS) {
-		atomic_set (&(context ->tx.busy), 0);
-		err ("%s: error submitting urb (%d)", __FUNCTION__, retval);
-	}
-	else {
+		atomic_set(&(context->tx.busy), 0);
+		err("%s: error submitting urb (%d)", __FUNCTION__, retval);
+	} else {
 		/* Wait for tranmission to complete (or abort) */
 		UNLOCK_CONTEXT;
-		wait_for_completion (&context ->tx.finished);
+		wait_for_completion(&context->tx.finished);
 		LOCK_CONTEXT;
 
-		retval = context ->tx.status;
+		retval = context->tx.status;
 		if (retval != SUCCESS)
-			err ("%s: packet tx failed (%d)", __FUNCTION__, retval);
+			err("%s: packet tx failed (%d)", __FUNCTION__, retval);
 	}
 
 	return retval;
@@ -456,58 +464,81 @@ static inline int send_packet (struct sasem_context *context)
  * and requires data in 9 consecutive USB interrupt packets,
  * each packet carrying 8 bytes.
  */
-static ssize_t vfd_write (struct file *file, const char *buf,
+static ssize_t vfd_write(struct file *file, const char *buf,
 				size_t n_bytes, loff_t *pos)
 {
 	int i;
 	int retval = SUCCESS;
 	struct sasem_context *context;
 
-	context = (struct sasem_context *) file ->private_data;
+	context = (struct sasem_context *) file->private_data;
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return -ENODEV;
 	}
 
 	LOCK_CONTEXT;
 
-	if (!context ->dev_present) {
-		err ("%s: no Sasem device present", __FUNCTION__);
+	if (!context->dev_present) {
+		err("%s: no Sasem device present", __FUNCTION__);
 		retval = -ENODEV;
 		goto exit;
 	}
 
 	if (n_bytes <= 0 || n_bytes > 32) {
-		err ("%s: invalid payload size", __FUNCTION__);
+		err("%s: invalid payload size", __FUNCTION__);
 		retval = -EINVAL;
 		goto exit;
 	}
 
-	copy_from_user (context ->tx.data_buf, buf, n_bytes);
+	copy_from_user(context->tx.data_buf, buf, n_bytes);
 
 	/* Pad with spaces */
-	for (i=n_bytes; i < 32; ++i)
-		context ->tx.data_buf [i] = ' ';
-	
+	for (i = n_bytes; i < 32; ++i)
+		context->tx.data_buf [i] = ' ';
+
 	/* Nine 8 byte packets to be sent */
-	/* NOTE: "\x07\x01\0\0\0\0\0\0" or  "\x0c\0\0\0\0\0\0\0" will clear the VFD */
+	/* NOTE: "\x07\x01\0\0\0\0\0\0" or "\x0c\0\0\0\0\0\0\0"
+	 *       will clear the VFD */
 	for (i = 0; i < 9; i++) {
 		switch (i) {
-			case 0: memcpy (context ->usb_tx_buf, "\x07\0\0\0\0\0\0\0", 8); 
-				context ->usb_tx_buf[1] = (context ->vfd_contrast)?(0x2B - (context ->vfd_contrast-1) / 250):0x2B;
-				break;
-			case 1: memcpy (context ->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8); break;
-			case 2: memcpy (context ->usb_tx_buf, "\x0b\x01\0\0\0\0\0\0", 8); break;
-			case 3: memcpy (context ->usb_tx_buf, context ->tx.data_buf, 8); break;
-			case 4: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 8, 8); break;
-			case 5: memcpy (context ->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8); break;
-			case 6: memcpy (context ->usb_tx_buf, "\x0b\x02\0\0\0\0\0\0", 8); break;
-			case 7: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 16, 8); break;
-			case 8: memcpy (context ->usb_tx_buf, context ->tx.data_buf + 24, 8); break;
+		case 0:
+			memcpy(context->usb_tx_buf, "\x07\0\0\0\0\0\0\0", 8);
+			context->usb_tx_buf[1] = (context->vfd_contrast) ?
+				(0x2B - (context->vfd_contrast - 1) / 250):0x2B;
+			break;
+		case 1:
+			memcpy(context->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8);
+			break;
+		case 2:
+			memcpy(context->usb_tx_buf, "\x0b\x01\0\0\0\0\0\0", 8);
+			break;
+		case 3:
+			memcpy(context->usb_tx_buf, context->tx.data_buf, 8);
+			break;
+		case 4:
+			memcpy(context->usb_tx_buf,
+			       context->tx.data_buf + 8, 8);
+			break;
+		case 5:
+			memcpy(context->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8);
+			break;
+		case 6:
+			memcpy(context->usb_tx_buf, "\x0b\x02\0\0\0\0\0\0", 8);
+			break;
+		case 7:
+			memcpy(context->usb_tx_buf,
+			       context->tx.data_buf + 16, 8);
+			break;
+		case 8:
+			memcpy(context->usb_tx_buf,
+			       context->tx.data_buf + 24, 8);
+			break;
 		}
-		if ((retval = send_packet (context)) != SUCCESS) {
+		retval = send_packet(context);
+		if (retval != SUCCESS) {
 
-			err ("%s: send packet failed for packet #%d", 
+			err("%s: send packet failed for packet #%d",
 					__FUNCTION__, i);
 			goto exit;
 		}
@@ -523,21 +554,24 @@ exit:
  * Callback function for USB core API: transmit data
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_tx_callback (struct urb *urb, struct pt_regs *regs)
+static void usb_tx_callback(struct urb *urb, struct pt_regs *regs)
 #else
-static void usb_tx_callback (struct urb *urb)
+static void usb_tx_callback(struct urb *urb)
 #endif
 {
 	struct sasem_context *context;
 
-	if (!urb || !(context = (struct sasem_context *) urb->context))
+	if (!urb)
+		return;
+	context = (struct sasem_context *) urb->context;
+	if (!context)
 		return;
 
-	context ->tx.status = urb ->status;
+	context->tx.status = urb->status;
 
 	/* notify waiters that write has finished */
-	atomic_set (&context ->tx.busy, 0);
-	complete (&context ->tx.finished);
+	atomic_set(&context->tx.busy, 0);
+	complete(&context->tx.finished);
 
 	return;
 }
@@ -545,85 +579,85 @@ static void usb_tx_callback (struct urb *urb)
 /**
  * Called by lirc_dev when the application opens /dev/lirc
  */
-static int ir_open (void *data)
+static int ir_open(void *data)
 {
 	int retval = SUCCESS;
 	struct sasem_context *context;
 
 	/* prevent races with disconnect */
-	down (&disconnect_sem);
+	down(&disconnect_sem);
 
 	context = (struct sasem_context *) data;
 
 	LOCK_CONTEXT;
 
-	if (context ->ir_isopen) {
-		err ("%s: IR port is already open", __FUNCTION__);
+	if (context->ir_isopen) {
+		err("%s: IR port is already open", __FUNCTION__);
 		retval = -EBUSY;
 		goto exit;
 	}
 
-	usb_fill_int_urb (context ->rx_urb, context ->dev,
-		usb_rcvintpipe (context ->dev,
-				context ->rx_endpoint-> bEndpointAddress),
-		context ->usb_rx_buf, sizeof (context ->usb_rx_buf),
-		usb_rx_callback, context, context ->rx_endpoint ->bInterval);
+	usb_fill_int_urb(context->rx_urb, context->dev,
+		usb_rcvintpipe(context->dev,
+				context->rx_endpoint->bEndpointAddress),
+		context->usb_rx_buf, sizeof(context->usb_rx_buf),
+		usb_rx_callback, context, context->rx_endpoint->bInterval);
 
 #ifdef KERNEL_2_5
-	retval = usb_submit_urb (context ->rx_urb, GFP_KERNEL);
+	retval = usb_submit_urb(context->rx_urb, GFP_KERNEL);
 #else
-	retval = usb_submit_urb (context ->rx_urb);
+	retval = usb_submit_urb(context->rx_urb);
 #endif
 
-	if (retval) {
-		err ("%s: usb_submit_urb failed for ir_open (%d)", __FUNCTION__, retval);
-	}
+	if (retval)
+		err("%s: usb_submit_urb failed for ir_open (%d)",
+		    __FUNCTION__, retval);
 	else {
 		MOD_INC_USE_COUNT;
-		context ->ir_isopen = TRUE;
-		info ("IR port opened");
+		context->ir_isopen = TRUE;
+		info("IR port opened");
 	}
 
 exit:
 	UNLOCK_CONTEXT;
 
-	up (&disconnect_sem);
+	up(&disconnect_sem);
 	return SUCCESS;
 }
 
 /**
  * Called by lirc_dev when the application closes /dev/lirc
  */
-static void ir_close (void *data)
+static void ir_close(void *data)
 {
 	struct sasem_context *context;
 
 	context = (struct sasem_context *)data;
 	if (!context) {
-		err ("%s: no context for device", __FUNCTION__);
+		err("%s: no context for device", __FUNCTION__);
 		return;
 	}
 
 	LOCK_CONTEXT;
 
 	usb_kill_urb(context->rx_urb);
-	context ->ir_isopen = FALSE;
+	context->ir_isopen = FALSE;
 	MOD_DEC_USE_COUNT;
-	info ("IR port closed");
+	info("IR port closed");
 
-	if (!context ->dev_present) {
+	if (!context->dev_present) {
 
-		/* 
-		 * Device disconnected while IR port was 
-		 * still open. Plugin was not deregistered 
+		/*
+		 * Device disconnected while IR port was
+		 * still open. Plugin was not deregistered
 		 * at disconnect time, so do it now.
 		 */
-		deregister_from_lirc (context);
+		deregister_from_lirc(context);
 
-		if (!context ->vfd_isopen) {
+		if (!context->vfd_isopen) {
 
 			UNLOCK_CONTEXT;
-			delete_context (context);
+			delete_context(context);
 			return;
 		}
 		/* If VFD port is open, context will be deleted by vfd_close */
@@ -636,96 +670,97 @@ static void ir_close (void *data)
 /**
  * Process the incoming packet
  */
-static inline void incoming_packet (struct sasem_context *context, struct urb *urb)
+static inline void incoming_packet(struct sasem_context *context,
+				   struct urb *urb)
 {
-	int len = urb ->actual_length;
-	unsigned char *buf = urb ->transfer_buffer;
+	int len = urb->actual_length;
+	unsigned char *buf = urb->transfer_buffer;
 	long ms;
 	struct timeval tv;
 
 	if (len != 8) {
-		warn ("%s: invalid incoming packet size (%d)", __FUNCTION__, len);
+		warn("%s: invalid incoming packet size (%d)",
+		     __FUNCTION__, len);
 		return;
 	}
 
-#ifdef DEBUG	
+#ifdef DEBUG
 	int i;
-	for (i=0; i < 8; ++i)
-		printk ("%02x ", buf [i]);
-	printk ("\n");
+	for (i = 0; i < 8; ++i)
+		printk(KERN_INFO "%02x ", buf [i]);
+	printk(KERN_INFO "\n");
 #endif
 
-	// Lirc could deal with the repeat code, but we really need to block it
-	// if it arrives too late.  Otherwise we could repeat the wrong code.
+	/* Lirc could deal with the repeat code, but we really need to block it
+	 * if it arrives too late.  Otherwise we could repeat the wrong code. */
 
-	// get the time since the last button press
+	/* get the time since the last button press */
 	do_gettimeofday(&tv);
-	ms = (tv.tv_sec - context->presstime.tv_sec) * 1000 + (tv.tv_usec - context->presstime.tv_usec) / 1000;
+	ms = (tv.tv_sec - context->presstime.tv_sec) * 1000 +
+	     (tv.tv_usec - context->presstime.tv_usec) / 1000;
 
 	if (memcmp(buf, "\x08\0\0\0\0\0\0\0", 8) == 0) {
-		// the repeat code is being sent, so we copy
-		// the old code to LIRC
-			
-		// NOTE: Only if the last code was less than 250ms ago
-		// - no one should be able to push another (undetected) button
-		//   in that time and then get a false repeat of the previous press
-		// - but it is long enough for a genuine repeat
+		/* the repeat code is being sent, so we copy
+		 * the old code to LIRC */
+
+		/* NOTE: Only if the last code was less than 250ms ago
+		 * - no one should be able to push another (undetected) button
+		 *   in that time and then get a false repeat of the previous
+		 *   press but it is long enough for a genuine repeat */
 		if ((ms < 250) && (context->codesaved != 0)) {
 			memcpy(buf, &context->lastcode, 8);
-			context->presstime.tv_sec = tv.tv_sec; 
+			context->presstime.tv_sec = tv.tv_sec;
 			context->presstime.tv_usec = tv.tv_usec;
 		}
-		// there was no old code
-		else {
-			// Do Nothing!
-		}
-	}
-	else {
-		// save the current valid code for repeats
+	} else {
+		/* save the current valid code for repeats */
 		memcpy(&context->lastcode, buf, 8);
-		// set flag to signal a valid code was save;
-		// just for safety reasons
+		/* set flag to signal a valid code was save;
+		 * just for safety reasons */
 		context->codesaved = 1;
-		context->presstime.tv_sec = tv.tv_sec; 
+		context->presstime.tv_sec = tv.tv_sec;
 		context->presstime.tv_usec = tv.tv_usec;
 	}
 
-	lirc_buffer_write_1 (context ->plugin ->rbuf, buf);
-	wake_up (&context ->plugin ->rbuf ->wait_poll);
+	lirc_buffer_write_1(context->plugin->rbuf, buf);
+	wake_up(&context->plugin->rbuf->wait_poll);
 }
 
 /**
  * Callback function for USB core API: receive data
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_rx_callback (struct urb *urb, struct pt_regs *regs)
+static void usb_rx_callback(struct urb *urb, struct pt_regs *regs)
 #else
-static void usb_rx_callback (struct urb *urb)
+static void usb_rx_callback(struct urb *urb)
 #endif
 {
 	struct sasem_context *context;
 
-	if (!urb || !(context = (struct sasem_context *) urb->context))
+	if (!urb)
+		return;
+	context = (struct sasem_context *) urb->context;
+	if (!context)
 		return;
 
-	switch (urb ->status) {
+	switch (urb->status) {
 
-		case -ENOENT: 		/* usbcore unlink successful! */ 
-			return;
+	case -ENOENT: 		/* usbcore unlink successful! */
+		return;
 
-		case SUCCESS:
-			if (context ->ir_isopen)
-				incoming_packet (context, urb);
-		       	break;
+	case SUCCESS:
+		if (context->ir_isopen)
+			incoming_packet(context, urb);
+		break;
 
-		default	:
-			warn ("%s: status (%d): ignored",
-				 __FUNCTION__, urb ->status);
-			break;
+	default:
+		warn("%s: status (%d): ignored",
+			 __FUNCTION__, urb->status);
+		break;
 	}
 
 #ifdef KERNEL_2_5
-	usb_submit_urb (context ->rx_urb, GFP_ATOMIC);
+	usb_submit_urb(context->rx_urb, GFP_ATOMIC);
 #endif
 	return;
 }
@@ -736,10 +771,10 @@ static void usb_rx_callback (struct urb *urb)
  * Callback function for USB core API: Probe
  */
 #ifdef KERNEL_2_5
-static int sasem_probe (struct usb_interface *interface,
+static int sasem_probe(struct usb_interface *interface,
 			const struct usb_device_id *id)
 #else
-static void * sasem_probe (struct usb_device * dev, unsigned int intf,
+static void *sasem_probe(struct usb_device *dev, unsigned int intf,
 			const struct usb_device_id *id)
 #endif
 {
@@ -767,7 +802,7 @@ static void * sasem_probe (struct usb_device * dev, unsigned int intf,
 	struct sasem_context *context = NULL;
 	int i;
 
-	info ("%s: found Sasem device", __FUNCTION__);
+	info("%s: found Sasem device", __FUNCTION__);
 
 #if !defined(KERNEL_2_5)
 	for (subminor = 0; subminor < MAX_DEVICES; ++subminor) {
@@ -775,21 +810,21 @@ static void * sasem_probe (struct usb_device * dev, unsigned int intf,
 			break;
 	}
 	if (subminor == MAX_DEVICES) {
-	
-		err ("%s: allowed number of devices already present", __FUNCTION__);
+		err("%s: allowed number of devices already present",
+		    __FUNCTION__);
 		retval = -ENOMEM;
 		goto exit;
 	}
 #endif
 
 #ifdef KERNEL_2_5
-	dev = usb_get_dev (interface_to_usbdev (interface));
-	iface_desc = interface ->cur_altsetting;
-	num_endpoints = iface_desc ->desc.bNumEndpoints;
+	dev = usb_get_dev(interface_to_usbdev(interface));
+	iface_desc = interface->cur_altsetting;
+	num_endpoints = iface_desc->desc.bNumEndpoints;
 #else
-	interface = &dev ->actconfig ->interface [intf];
-	iface_desc = &interface ->altsetting [interface ->act_altsetting];
-	num_endpoints = iface_desc ->bNumEndpoints;
+	interface = &dev->actconfig->interface [intf];
+	iface_desc = &interface->altsetting [interface->act_altsetting];
+	num_endpoints = iface_desc->bNumEndpoints;
 #endif
 
 	/*
@@ -798,185 +833,204 @@ static void * sasem_probe (struct usb_device * dev, unsigned int intf,
 	 * 	first output endpoint = VFD endpoint
 	 */
 
-	ir_ep_found = vfd_ep_found = FALSE;
+	ir_ep_found = FALSE;
+	vfd_ep_found = FALSE;
 
-	for (i=0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
+	for (i = 0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {
 
 		struct usb_endpoint_descriptor *ep;
 		int ep_dir;
 		int ep_type;
 #ifdef KERNEL_2_5
-		ep = &iface_desc ->endpoint [i].desc;
+		ep = &iface_desc->endpoint [i].desc;
 #else
-		ep = &iface_desc ->endpoint [i];
+		ep = &iface_desc->endpoint [i];
 #endif
-		ep_dir = ep ->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
-		ep_type = ep ->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+		ep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;
+		ep_type = ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
-		if (!ir_ep_found && 
-			ep_dir == USB_DIR_IN && 
+		if (!ir_ep_found &&
+			ep_dir == USB_DIR_IN &&
 			ep_type == USB_ENDPOINT_XFER_INT) {
 
 			rx_endpoint = ep;
 			ir_ep_found = TRUE;
-			if (debug) 
-				info ("%s: found IR endpoint", __FUNCTION__);
+			if (debug)
+				info("%s: found IR endpoint", __FUNCTION__);
 
-		}
-		else if (!vfd_ep_found &&
-			ep_dir == USB_DIR_OUT && 
+		} else if (!vfd_ep_found &&
+			ep_dir == USB_DIR_OUT &&
 			ep_type == USB_ENDPOINT_XFER_INT) {
 
 			tx_endpoint = ep;
 			vfd_ep_found = TRUE;
-			if (debug) 
-				info ("%s: found VFD endpoint", __FUNCTION__);
+			if (debug)
+				info("%s: found VFD endpoint", __FUNCTION__);
 		}
 	}
 
 	/* Input endpoint is mandatory */
 	if (!ir_ep_found) {
 
-		err ("%s: no valid input (IR) endpoint found.", __FUNCTION__);
+		err("%s: no valid input (IR) endpoint found.", __FUNCTION__);
 		retval = -ENODEV;
 		goto exit;
 	}
 
 	/* Warning if no VFD endpoint */
-	if (!vfd_ep_found) 
-		info ("%s: no valid output (VFD) endpoint found.", __FUNCTION__);
+	if (!vfd_ep_found)
+		info("%s: no valid output (VFD) endpoint found.", __FUNCTION__);
 
 
 	/* Allocate memory */
 	alloc_status = SUCCESS;
 
-	if (!(context = kmalloc (sizeof(struct sasem_context), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for context", __FUNCTION__);
+	context = kmalloc(sizeof(struct sasem_context), GFP_KERNEL);
+	if (!context) {
+		err("%s: kmalloc failed for context", __FUNCTION__);
 		alloc_status = 1;
+		goto alloc_status_switch;
 	}
-	else if (!(plugin = kmalloc (sizeof(struct lirc_plugin), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
+	plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL);
+	if (!plugin) {
+		err("%s: kmalloc failed for lirc_plugin", __FUNCTION__);
 		alloc_status = 2;
+		goto alloc_status_switch;
 	}
-	else if (!(rbuf = kmalloc (sizeof(struct lirc_buffer), GFP_KERNEL))) {
-		err ("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
+	rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+	if (!rbuf) {
+		err("%s: kmalloc failed for lirc_buffer", __FUNCTION__);
 		alloc_status = 3;
+		goto alloc_status_switch;
 	}
-	else if (lirc_buffer_init (rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
-		err ("%s: lirc_buffer_init failed", __FUNCTION__);
+	if (lirc_buffer_init(rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {
+		err("%s: lirc_buffer_init failed", __FUNCTION__);
 		alloc_status = 4;
+		goto alloc_status_switch;
 	}
 #ifdef KERNEL_2_5
-	else if (!(rx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+	rx_urb = usb_alloc_urb(0, GFP_KERNEL);
 #else
-	else if (!(rx_urb = usb_alloc_urb (0))) {
+	rx_urb = usb_alloc_urb(0);
 #endif
-		err ("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
+	if (!rx_urb) {
+		err("%s: usb_alloc_urb failed for IR urb", __FUNCTION__);
 		alloc_status = 5;
+		goto alloc_status_switch;
 	}
+	if (vfd_ep_found) {
 #ifdef KERNEL_2_5
-	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0, GFP_KERNEL))) {
+		tx_urb = usb_alloc_urb(0, GFP_KERNEL);
 #else
-	else if (vfd_ep_found && !(tx_urb = usb_alloc_urb (0))) {
+		tx_urb = usb_alloc_urb(0);
 #endif
-		err ("%s: usb_alloc_urb failed for VFD urb", __FUNCTION__);
-		alloc_status = 6;
+		if (!tx_urb) {
+			err("%s: usb_alloc_urb failed for VFD urb",
+			    __FUNCTION__);
+			alloc_status = 6;
+			goto alloc_status_switch;
+		}
 	}
-	else {
 
-		/* clear all members of sasem_context and lirc_plugin */
-		memset (context, 0, sizeof (struct sasem_context));
-		init_MUTEX (&context ->sem);
-
-		memset (plugin, 0, sizeof (struct lirc_plugin));
-
-		strcpy (plugin ->name, MOD_NAME);
-		plugin ->minor = -1;
-		plugin ->code_length = 64;
-		plugin ->sample_rate = 0;
-		plugin ->features = LIRC_CAN_REC_LIRCCODE;
-		plugin ->data = context;
-		plugin ->rbuf = rbuf;
-		plugin ->set_use_inc = ir_open;
-		plugin ->set_use_dec = ir_close;
+	/* clear all members of sasem_context and lirc_plugin */
+	memset(context, 0, sizeof(struct sasem_context));
+	init_MUTEX(&context->sem);
+
+	memset(plugin, 0, sizeof(struct lirc_plugin));
+
+	strcpy(plugin->name, MOD_NAME);
+	plugin->minor = -1;
+	plugin->code_length = 64;
+	plugin->sample_rate = 0;
+	plugin->features = LIRC_CAN_REC_LIRCCODE;
+	plugin->data = context;
+	plugin->rbuf = rbuf;
+	plugin->set_use_inc = ir_open;
+	plugin->set_use_dec = ir_close;
 #ifdef LIRC_HAVE_SYSFS
-		plugin->dev   = &dev->dev;
+	plugin->dev   = &dev->dev;
 #endif
-		plugin->owner = THIS_MODULE;
+	plugin->owner = THIS_MODULE;
 
-		LOCK_CONTEXT;
+	LOCK_CONTEXT;
 
-		if ((lirc_minor = lirc_register_plugin (plugin)) < 0) {
-			err ("%s: lirc_register_plugin failed", __FUNCTION__);
-			alloc_status = 7;
-			UNLOCK_CONTEXT;
-		}
-		else
-			info ("%s: Registered Sasem plugin (minor:%d)", 
-				__FUNCTION__, lirc_minor);
-	}
+	lirc_minor = lirc_register_plugin(plugin);
+	if (lirc_minor < 0) {
+		err("%s: lirc_register_plugin failed", __FUNCTION__);
+		alloc_status = 7;
+		UNLOCK_CONTEXT;
+	} else
+		info("%s: Registered Sasem plugin (minor:%d)",
+			__FUNCTION__, lirc_minor);
+
+alloc_status_switch:
 
 	switch (alloc_status) {
 
-		case 7:		if (vfd_ep_found)
-					usb_free_urb (tx_urb);
-		case 6:		usb_free_urb (rx_urb);
-		case 5:		lirc_buffer_free (rbuf);
-		case 4:		kfree (rbuf);
-		case 3:		kfree (plugin);
-		case 2:		kfree (context);
-				context = NULL;
-		case 1:		retval = -ENOMEM;
-				goto exit;
+	case 7:
+		if (vfd_ep_found)
+			usb_free_urb(tx_urb);
+	case 6:
+		usb_free_urb(rx_urb);
+	case 5:
+		lirc_buffer_free(rbuf);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(context);
+		context = NULL;
+	case 1:
+		retval = -ENOMEM;
+		goto exit;
 	}
 
-	// Needed while unregistering!
-	plugin ->minor = lirc_minor;
+	/* Needed while unregistering! */
+	plugin->minor = lirc_minor;
 
-	context ->dev = dev;
-	context ->dev_present = TRUE;
-	context ->rx_endpoint = rx_endpoint;
-	context ->rx_urb = rx_urb;
+	context->dev = dev;
+	context->dev_present = TRUE;
+	context->rx_endpoint = rx_endpoint;
+	context->rx_urb = rx_urb;
 	if (vfd_ep_found) {
-		context ->tx_endpoint = tx_endpoint;
-		context ->tx_urb = tx_urb;
-		context ->vfd_contrast = 1000;   /* range 0 - 1000 */
+		context->tx_endpoint = tx_endpoint;
+		context->tx_urb = tx_urb;
+		context->vfd_contrast = 1000;   /* range 0 - 1000 */
 	}
-	context ->plugin = plugin;
+	context->plugin = plugin;
 
 #ifdef KERNEL_2_5
-	usb_set_intfdata (interface, context);
+	usb_set_intfdata(interface, context);
 #else
 	minor_table [subminor] = context;
-	context ->subminor = subminor;
+	context->subminor = subminor;
 #endif
 
 	if (vfd_ep_found) {
 
-		if (debug) info ("Registering VFD with devfs");
+		if (debug)
+			info("Registering VFD with devfs");
 #ifdef KERNEL_2_5
-		if (usb_register_dev (interface, &sasem_class)) {
-
-			// Not a fatal error, so ignore
-			info ("%s: could not get a minor number for VFD", 
+		if (usb_register_dev(interface, &sasem_class))
+			/* Not a fatal error, so ignore */
+			info("%s: could not get a minor number for VFD",
 				__FUNCTION__);
-		}
 #else
-		sprintf (name, DEVFS_NAME, subminor);
-		if (!(context ->devfs = devfs_register (usb_devfs_handle, name, 
-					DEVFS_FL_DEFAULT,
-					USB_MAJOR, VFD_MINOR_BASE + subminor,
-					DEVFS_MODE, &vfd_fops, NULL))) {
-
-			// not a fatal error so ignore
-			info ("%s: devfs register failed for VFD",
+		sprintf(name, DEVFS_NAME, subminor);
+		context->devfs = devfs_register(usb_devfs_handle, name,
+				 DEVFS_FL_DEFAULT,
+				 USB_MAJOR, VFD_MINOR_BASE + subminor,
+				 DEVFS_MODE, &vfd_fops, NULL);
+		if (!context->devfs)
+			/* not a fatal error so ignore */
+			info("%s: devfs register failed for VFD",
 					__FUNCTION__);
-		}
 #endif
 	}
 
-	info ("%s: Sasem device on usb<%d:%d> initialized",
-			__FUNCTION__, dev ->bus ->busnum, dev ->devnum);
+	info("%s: Sasem device on usb<%d:%d> initialized",
+			__FUNCTION__, dev->bus->busnum, dev->devnum);
 
 	UNLOCK_CONTEXT;
 exit:
@@ -991,84 +1045,85 @@ exit:
  * Callback function for USB core API: disonnect
  */
 #ifdef KERNEL_2_5
-static void sasem_disconnect (struct usb_interface *interface)
+static void sasem_disconnect(struct usb_interface *interface)
 #else
-static void sasem_disconnect (struct usb_device *dev, void *data)
+static void sasem_disconnect(struct usb_device *dev, void *data)
 #endif
 {
 	struct sasem_context *context;
 
 	/* prevent races with ir_open()/vfd_open() */
-	down (&disconnect_sem);
+	down(&disconnect_sem);
 
 #ifdef KERNEL_2_5
-	context = usb_get_intfdata (interface);
+	context = usb_get_intfdata(interface);
 #else
 	context = (struct sasem_context *)data;
 #endif
 	LOCK_CONTEXT;
 
-	info ("%s: Sasem device disconnected", __FUNCTION__);
+	info("%s: Sasem device disconnected", __FUNCTION__);
 
 #ifdef KERNEL_2_5
-	usb_set_intfdata (interface, NULL);
+	usb_set_intfdata(interface, NULL);
 #else
-	minor_table [context ->subminor] = NULL;
+	minor_table [context->subminor] = NULL;
 #endif
-	context ->dev_present = FALSE;
+	context->dev_present = FALSE;
 
 	/* Stop reception */
 	usb_kill_urb(context->rx_urb);
 
 	/* Abort ongoing write */
-	if (atomic_read (&context ->tx.busy)) {
+	if (atomic_read(&context->tx.busy)) {
 
 		usb_kill_urb(context->tx_urb);
-		wait_for_completion (&context ->tx.finished);
+		wait_for_completion(&context->tx.finished);
 	}
 
 	/* De-register from lirc_dev if IR port is not open */
-	if (!context ->ir_isopen)
-		deregister_from_lirc (context);
+	if (!context->ir_isopen)
+		deregister_from_lirc(context);
 
 #ifdef KERNEL_2_5
-	usb_deregister_dev (interface, &sasem_class);
+	usb_deregister_dev(interface, &sasem_class);
 #else
-	if (context ->devfs)
-		devfs_unregister (context ->devfs);
+	if (context->devfs)
+		devfs_unregister(context->devfs);
 #endif
 
 	UNLOCK_CONTEXT;
 
-	if (!context ->ir_isopen && !context ->vfd_isopen)
-		delete_context (context);
-	
-	up (&disconnect_sem);
+	if (!context->ir_isopen && !context->vfd_isopen)
+		delete_context(context);
+
+	up(&disconnect_sem);
 }
 
-static int __init sasem_init (void)
+static int __init sasem_init(void)
 {
 	int rc;
 
-	info (MOD_DESC ", v" MOD_VERSION);
-	info (MOD_AUTHOR);
+	info(MOD_DESC ", v" MOD_VERSION);
+	info(MOD_AUTHOR);
 
-	if ((rc = usb_register (&sasem_driver)) < 0) {
-		err ("%s: usb register failed (%d)", __FUNCTION__, rc);
+	rc = usb_register(&sasem_driver);
+	if (rc < 0) {
+		err("%s: usb register failed (%d)", __FUNCTION__, rc);
 		return -ENODEV;
 	}
 	return SUCCESS;
 }
 
-static void __exit sasem_exit (void)
+static void __exit sasem_exit(void)
 {
-	usb_deregister (&sasem_driver);
-	info ("module removed. Goodbye!");
+	usb_deregister(&sasem_driver);
+	info("module removed. Goodbye!");
 }
 
 
-module_init (sasem_init);
-module_exit (sasem_exit);
+module_init(sasem_init);
+module_exit(sasem_exit);
 
 #if !defined(KERNEL_2_5)
 EXPORT_NO_SYMBOLS;
diff --git a/drivers/char/lirc/lirc_serial.c b/drivers/char/lirc/lirc_serial.c
index 60d4ec4..2f5152c 100644
--- a/drivers/char/lirc/lirc_serial.c
+++ b/drivers/char/lirc/lirc_serial.c
@@ -1,11 +1,11 @@
-/*      $Id: lirc_serial.c,v 5.80 2007/05/11 16:40:24 lirc Exp $      */
+/*      $Id: lirc_serial.c,v 5.89 2008/04/06 19:03:52 lirc Exp $      */
 
 /****************************************************************************
  ** lirc_serial.c ***********************************************************
  ****************************************************************************
  *
  * lirc_serial - Device driver that records pulse- and pause-lengths
- *               (space-lengths) between DDCD event on a serial port.
+ *	       (space-lengths) between DDCD event on a serial port.
  *
  * Copyright (C) 1996,97 Ralph Metzler <rjkm@thp.uni-koeln.de>
  * Copyright (C) 1998 Trent Piepho <xyzzy@u.washington.edu>
@@ -29,7 +29,7 @@
  */
 
 /* Steve's changes to improve transmission fidelity:
-     - for systems with the rdtsc instruction and the clock counter, a 
+     - for systems with the rdtsc instruction and the clock counter, a
        send_pule that times the pulses directly using the counter.
        This means that the LIRC_SERIAL_TRANSMITTER_LATENCY fudge is
        not needed. Measurement shows very stable waveform, even where
@@ -53,7 +53,7 @@
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
- 
+
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
 #error "**********************************************************"
@@ -68,7 +68,7 @@
 #warning " Your serial port driver is compiled into "
 #warning " the kernel. You will have to release the "
 #warning " port you want to use for LIRC with:      "
-#warning "    setserial /dev/ttySx uart none        "
+#warning "    setserial /dev/ttySx uart none	"
 #warning "******************************************"
 #endif
 
@@ -94,10 +94,18 @@
 #endif
 
 #include <asm/system.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
 #include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/fcntl.h>
+#else
+#include <linux/io.h>
+#endif
+#include <linux/irq.h>
+#include <linux/fcntl.h>
 
 #if defined(LIRC_SERIAL_NSLU2)
 #include <asm/hardware.h>
@@ -105,6 +113,10 @@
 /* ftp://download.intel.com/design/network/manuals/25248005.pdf */
 #define UART_IE_IXP42X_UUE   0x40 /* IXP42X UART Unit enable */
 #define UART_IE_IXP42X_RTOIE 0x10 /* IXP42X Receiver Data Timeout int.enable */
+#ifndef NSLU2_LED_GRN_GPIO
+/* added in 2.6.22 */
+#define NSLU2_LED_GRN_GPIO NSLU2_LED_GRN
+#endif
 #endif
 
 #include <linux/lirc.h>
@@ -115,7 +127,7 @@
 #warning "Software carrier only affects transmitting"
 #endif
 
-#if defined(rdtsc)
+#if defined(rdtscl)
 
 #define USE_RDTSC
 #warning "Note: using rdtsc instruction"
@@ -124,16 +136,15 @@
 #ifdef LIRC_SERIAL_ANIMAX
 #ifdef LIRC_SERIAL_TRANSMITTER
 #warning "******************************************"
-#warning " This receiver does not have a            "
-#warning " transmitter diode                        "
+#warning " This receiver does not have a	    "
+#warning " transmitter diode			"
 #warning "******************************************"
 #endif
 #endif
 
 #define LIRC_DRIVER_NAME "lirc_serial"
 
-struct lirc_serial
-{
+struct lirc_serial {
 	int signal_pin;
 	int signal_pin_change;
 	int on;
@@ -143,25 +154,25 @@ struct lirc_serial
 	int features;
 };
 
-#define LIRC_HOMEBREW        0
-#define LIRC_IRDEO           1
+#define LIRC_HOMEBREW	0
+#define LIRC_IRDEO	   1
 #define LIRC_IRDEO_REMOTE    2
-#define LIRC_ANIMAX          3
-#define LIRC_IGOR            4
-#define LIRC_NSLU2           5
+#define LIRC_ANIMAX	  3
+#define LIRC_IGOR	    4
+#define LIRC_NSLU2	   5
 
 #ifdef LIRC_SERIAL_IRDEO
-static int type=LIRC_IRDEO;
+static int type = LIRC_IRDEO;
 #elif defined(LIRC_SERIAL_IRDEO_REMOTE)
-static int type=LIRC_IRDEO_REMOTE;
+static int type = LIRC_IRDEO_REMOTE;
 #elif defined(LIRC_SERIAL_ANIMAX)
-static int type=LIRC_ANIMAX;
+static int type = LIRC_ANIMAX;
 #elif defined(LIRC_SERIAL_IGOR)
-static int type=LIRC_IGOR;
+static int type = LIRC_IGOR;
 #elif defined(LIRC_SERIAL_NSLU2)
-static int type=LIRC_NSLU2;
+static int type = LIRC_NSLU2;
 #else
-static int type=LIRC_HOMEBREW;
+static int type = LIRC_HOMEBREW;
 #endif
 
 /* Set defaults for NSLU2 */
@@ -195,20 +206,20 @@ static int ioshift = LIRC_IOSHIFT;
 #endif
 
 #ifdef LIRC_SERIAL_SOFTCARRIER
-static int softcarrier=1;
+static int softcarrier = 1;
 #else
-static int softcarrier=0;
+static int softcarrier;
 #endif
 
-static int share_irq = 0;
-static int debug = 0;
+static int share_irq;
+static int debug;
 
-#define dprintk(fmt, args...)                                   \
-	do{                                                     \
-		if(debug)                                       \
-	                printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
-                               fmt, ## args);                   \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG LIRC_DRIVER_NAME ": "	\
+			       fmt, ## args);			\
+	} while (0)
 
 /* forward declarations */
 static long send_pulse_irdeo(unsigned long length);
@@ -216,8 +227,7 @@ static long send_pulse_homebrew(unsigned long length);
 static void send_space_irdeo(long length);
 static void send_space_homebrew(long length);
 
-static struct lirc_serial hardware[]=
-{
+static struct lirc_serial hardware[] = {
 	/* home-brew receiver/transmitter */
 	{
 		UART_MSR_DCD,
@@ -234,7 +244,7 @@ static struct lirc_serial hardware[]=
 #endif
 		 LIRC_CAN_REC_MODE2)
 	},
-	
+
 	/* IRdeo classic */
 	{
 		UART_MSR_DSR,
@@ -247,7 +257,7 @@ static struct lirc_serial hardware[]=
 		 LIRC_CAN_SEND_PULSE|
 		 LIRC_CAN_REC_MODE2)
 	},
-	
+
 	/* IRdeo remote */
 	{
 		UART_MSR_DSR,
@@ -260,7 +270,7 @@ static struct lirc_serial hardware[]=
 		 LIRC_CAN_SEND_PULSE|
 		 LIRC_CAN_REC_MODE2)
 	},
-	
+
 	/* AnimaX */
 	{
 		UART_MSR_DCD,
@@ -271,7 +281,7 @@ static struct lirc_serial hardware[]=
 		NULL,
 		LIRC_CAN_REC_MODE2
 	},
-	
+
 	/* home-brew receiver/transmitter (Igor Cesko's variation) */
 	{
 		UART_MSR_DSR,
@@ -288,7 +298,7 @@ static struct lirc_serial hardware[]=
 #endif
 		 LIRC_CAN_REC_MODE2)
 	},
-	
+
 #if defined(LIRC_SERIAL_NSLU2)
 	/* Modified Linksys Network Storage Link USB 2.0 (NSLU2):
 	   We receive on CTS of the 2nd serial port (R142,LHS), we
@@ -311,7 +321,7 @@ static struct lirc_serial hardware[]=
 		 LIRC_CAN_REC_MODE2)
 	},
 #endif
-	
+
 };
 
 #define RS_ISR_PASS_LIMIT 256
@@ -328,8 +338,8 @@ static struct lirc_serial hardware[]=
 #define RBUF_LEN 256
 #define WBUF_LEN 256
 
-static int sense = -1;   /* -1 = auto, 0 = active high, 1 = active low */
-static int txsense = 0;   /* 0 = active high, 1 = active low */
+static int sense = -1;	/* -1 = auto, 0 = active high, 1 = active low */
+static int txsense;     /* 0 = active high, 1 = active low */
 
 #ifndef LIRC_IRQ
 #define LIRC_IRQ 4
@@ -351,9 +361,9 @@ static unsigned int freq = 38000;
 static unsigned int duty_cycle = 50;
 
 /* Initialized in init_timing_params() */
-static unsigned long period = 0;
-static unsigned long pulse_width = 0;
-static unsigned long space_width = 0;
+static unsigned long period;
+static unsigned long pulse_width;
+static unsigned long space_width;
 
 #if defined(__i386__)
 /*
@@ -361,7 +371,7 @@ static unsigned long space_width = 0;
   Linux I/O port programming mini-HOWTO
   Author: Riku Saikkonen <Riku.Saikkonen@hut.fi>
   v, 28 December 1997
-  
+
   [...]
   Actually, a port I/O instruction on most ports in the 0-0x3ff range
   takes almost exactly 1 microsecond, so if you're, for example, using
@@ -392,11 +402,11 @@ static unsigned long space_width = 0;
 static inline unsigned int sinp(int offset)
 {
 #if defined(LIRC_ALLOW_MMAPPED_IO)
-	if(iommap != 0) /* the register is memory-mapped */
-	{
+	if (iommap != 0) {
+		/* the register is memory-mapped */
 		offset <<= ioshift;
 		return readb(io + offset);
-	} 
+	}
 #endif
 	return inb(io + offset);
 }
@@ -404,8 +414,8 @@ static inline unsigned int sinp(int offset)
 static inline void soutp(int offset, int value)
 {
 #if defined(LIRC_ALLOW_MMAPPED_IO)
-	if(iommap != 0) /* the register is memory-mapped */
-	{
+	if (iommap != 0) {
+		/* the register is memory-mapped */
 		offset <<= ioshift;
 		writeb(value, io + offset);
 	}
@@ -418,39 +428,29 @@ static inline void on(void)
 #if defined(LIRC_SERIAL_NSLU2)
 	/* On NSLU2, we put the transmit diode between the output of the green
 	   status LED and ground */
-	if(type == LIRC_NSLU2)
-	{
-		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_LOW);
+	if (type == LIRC_NSLU2) {
+		gpio_line_set(NSLU2_LED_GRN_GPIO, IXP4XX_GPIO_LOW);
 		return;
 	}
 #endif
 	if (txsense)
-	{
-		soutp(UART_MCR,hardware[type].off);
-	}
+		soutp(UART_MCR, hardware[type].off);
 	else
-	{
-		soutp(UART_MCR,hardware[type].on);
-	}
+		soutp(UART_MCR, hardware[type].on);
 }
-  
+
 static inline void off(void)
 {
 #if defined(LIRC_SERIAL_NSLU2)
-	if(type == LIRC_NSLU2)
-	{
-		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_HIGH);
+	if (type == LIRC_NSLU2) {
+		gpio_line_set(NSLU2_LED_GRN_GPIO, IXP4XX_GPIO_HIGH);
 		return;
 	}
 #endif
 	if (txsense)
-	{
-		soutp(UART_MCR,hardware[type].on);
-	}
+		soutp(UART_MCR, hardware[type].on);
 	else
-	{
-		soutp(UART_MCR,hardware[type].off);
-	}
+		soutp(UART_MCR, hardware[type].off);
 }
 
 #ifndef MAX_UDELAY_MS
@@ -461,10 +461,9 @@ static inline void off(void)
 
 static inline void safe_udelay(unsigned long usecs)
 {
-	while(usecs>MAX_UDELAY_US)
-	{
+	while (usecs > MAX_UDELAY_US) {
 		udelay(MAX_UDELAY_US);
-		usecs-=MAX_UDELAY_US;
+		usecs -= MAX_UDELAY_US;
 	}
 	udelay(usecs);
 }
@@ -480,28 +479,28 @@ static inline void safe_udelay(unsigned long usecs)
  */
 
 /* So send_pulse can quickly convert microseconds to clocks */
-static unsigned long conv_us_to_clocks = 0;
+static unsigned long conv_us_to_clocks;
 
 static inline int init_timing_params(unsigned int new_duty_cycle,
 		unsigned int new_freq)
 {
-	unsigned long long loops_per_sec,work;
-	
-	duty_cycle=new_duty_cycle;
-	freq=new_freq;
-
-	loops_per_sec=current_cpu_data.loops_per_jiffy;
-	loops_per_sec*=HZ;
-	
+	unsigned long long loops_per_sec, work;
+
+	duty_cycle = new_duty_cycle;
+	freq = new_freq;
+
+	loops_per_sec = current_cpu_data.loops_per_jiffy;
+	loops_per_sec *= HZ;
+
 	/* How many clocks in a microsecond?, avoiding long long divide */
-	work=loops_per_sec;
-	work*=4295;  /* 4295 = 2^32 / 1e6 */
-	conv_us_to_clocks=(work>>32);
-	
+	work = loops_per_sec;
+	work *= 4295;  /* 4295 = 2^32 / 1e6 */
+	conv_us_to_clocks = (work>>32);
+
 	/* Carrier period in clocks, approach good up to 32GHz clock,
-           gets carrier frequency within 8Hz */
-	period=loops_per_sec>>3;
-	period/=(freq>>3);
+	   gets carrier frequency within 8Hz */
+	period = loops_per_sec>>3;
+	period /= (freq>>3);
 
 	/* Derive pulse and space from the period */
 
@@ -520,15 +519,17 @@ static inline int init_timing_params(unsigned int new_duty_cycle,
 {
 /* period, pulse/space width are kept with 8 binary places -
  * IE multiplied by 256. */
-	if(256*1000000L/new_freq*new_duty_cycle/100<=
-	   LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
-	if(256*1000000L/new_freq*(100-new_duty_cycle)/100<=
-	   LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
-	duty_cycle=new_duty_cycle;
-	freq=new_freq;
-	period=256*1000000L/freq;
-	pulse_width=period*duty_cycle/100;
-	space_width=period-pulse_width;
+	if (256*1000000L/new_freq*new_duty_cycle/100 <=
+	    LIRC_SERIAL_TRANSMITTER_LATENCY)
+		return -EINVAL;
+	if (256*1000000L/new_freq*(100-new_duty_cycle)/100 <=
+	    LIRC_SERIAL_TRANSMITTER_LATENCY)
+		return -EINVAL;
+	duty_cycle = new_duty_cycle;
+	freq = new_freq;
+	period = 256*1000000L/freq;
+	pulse_width = period*duty_cycle/100;
+	space_width = period-pulse_width;
 	dprintk("in init_timing_params, freq=%d pulse=%ld, "
 		"space=%ld\n", freq, pulse_width, space_width);
 	return 0;
@@ -543,40 +544,35 @@ static long send_pulse_irdeo(unsigned long length)
 	long rawbits;
 	int i;
 	unsigned char output;
-	unsigned char chunk,shifted;
-	
+	unsigned char chunk, shifted;
+
 	/* how many bits have to be sent ? */
-	rawbits=length*1152/10000;
-	if(duty_cycle>50) chunk=3;
-	else chunk=1;
-	for(i=0,output=0x7f;rawbits>0;rawbits-=3)
-	{
-		shifted=chunk<<(i*3);
-		shifted>>=1;
-		output&=(~shifted);
+	rawbits = length*1152/10000;
+	if (duty_cycle > 50)
+		chunk = 3;
+	else
+		chunk = 1;
+	for (i = 0, output = 0x7f; rawbits > 0; rawbits -= 3) {
+		shifted = chunk<<(i*3);
+		shifted >>= 1;
+		output &= (~shifted);
 		i++;
-		if(i==3)
-		{
-			soutp(UART_TX,output);
-			while(!(sinp(UART_LSR) & UART_LSR_THRE));
-			output=0x7f;
-			i=0;
+		if (i == 3) {
+			soutp(UART_TX, output);
+			while (!(sinp(UART_LSR) & UART_LSR_THRE));
+			output = 0x7f;
+			i = 0;
 		}
 	}
-	if(i!=0)
-	{
-		soutp(UART_TX,output);
-		while(!(sinp(UART_LSR) & UART_LSR_TEMT));
+	if (i != 0) {
+		soutp(UART_TX, output);
+		while (!(sinp(UART_LSR) & UART_LSR_TEMT));
 	}
 
-	if(i==0)
-	{
-		return((-rawbits)*10000/1152);
-	}
+	if (i == 0)
+		return ((-rawbits)*10000/1152);
 	else
-	{
-		return((3-i)*3*10000/1152+(-rawbits)*10000/1152);
-	}
+		return ((3-i)*3*10000/1152+(-rawbits)*10000/1152);
 }
 
 #ifdef USE_RDTSC
@@ -593,36 +589,31 @@ static inline long send_pulse_homebrew_softcarrier(unsigned long length)
 	unsigned long target, start, now;
 
 	/* Get going quick as we can */
-	rdtscl(start);on();
+	rdtscl(start); on();
 	/* Convert length from microseconds to clocks */
-	length*=conv_us_to_clocks;
+	length *= conv_us_to_clocks;
 	/* And loop till time is up - flipping at right intervals */
-	now=start;
-	target=pulse_width;
-	flag=1;
-	while((now-start)<length)
-	{
+	now = start;
+	target = pulse_width;
+	flag = 1;
+	while ((now-start) < length) {
 		/* Delay till flip time */
 		do
-		{
 			rdtscl(now);
-		}
-		while ((now-start)<target);
+		while ((now-start) < target);
+
 		/* flip */
-		if(flag)
-		{
-			rdtscl(now);off();
-			target+=space_width;
+		if (flag) {
+			rdtscl(now); off();
+			target += space_width;
+		} else {
+			rdtscl(now); on();
+			target += pulse_width;
 		}
-		else
-		{
-			rdtscl(now);on();
-			target+=pulse_width;
-		}
-		flag=!flag;
+		flag = !flag;
 	}
 	rdtscl(now);
-	return(((now-start)-length)/conv_us_to_clocks);
+	return (((now-start)-length)/conv_us_to_clocks);
 }
 #else /* ! USE_RDTSC */
 /* Version using udelay() */
@@ -637,114 +628,106 @@ static inline long send_pulse_homebrew_softcarrier(unsigned long length)
 {
 	int flag;
 	unsigned long actual, target, d;
-	length<<=8;
+	length <<= 8;
 
-	actual=target=0; flag=0;
-	while(actual<length)
-	{
-		if(flag)
-		{
+	actual = 0; target = 0; flag = 0;
+	while (actual < length) {
+		if (flag) {
 			off();
-			target+=space_width;
-		}
-		else
-		{
+			target += space_width;
+		} else {
 			on();
-			target+=pulse_width;
+			target += pulse_width;
 		}
-		d=(target-actual-LIRC_SERIAL_TRANSMITTER_LATENCY+128)>>8;
+		d = (target-actual-LIRC_SERIAL_TRANSMITTER_LATENCY+128)>>8;
 		/* Note - we've checked in ioctl that the pulse/space
 		   widths are big enough so that d is > 0 */
 		udelay(d);
-		actual+=(d<<8)+LIRC_SERIAL_TRANSMITTER_LATENCY;
-		flag=!flag;
+		actual += (d<<8)+LIRC_SERIAL_TRANSMITTER_LATENCY;
+		flag = !flag;
 	}
-	return((actual-length)>>8);
+	return ((actual-length)>>8);
 }
 #endif /* USE_RDTSC */
 
 static long send_pulse_homebrew(unsigned long length)
 {
-	if(length<=0) return 0;
-	if(softcarrier)
-	{
+	if (length <= 0)
+		return 0;
+
+	if (softcarrier)
 		return send_pulse_homebrew_softcarrier(length);
-	}
-	else
-	{
+	else {
 		on();
 		safe_udelay(length);
-		return(0);
+		return 0;
 	}
 }
 
 static void send_space_irdeo(long length)
 {
-	if(length<=0) return;
+	if (length <= 0)
+		return;
+
 	safe_udelay(length);
 }
 
 static void send_space_homebrew(long length)
 {
-        off();
-	if(length<=0) return;
+	off();
+	if (length <= 0)
+		return;
 	safe_udelay(length);
 }
 
-static void inline rbwrite(lirc_t l)
+static inline void rbwrite(lirc_t l)
 {
-	if(lirc_buffer_full(&rbuf))    /* no new signals will be accepted */
-	{
+	if (lirc_buffer_full(&rbuf)) {
+		/* no new signals will be accepted */
 		dprintk("Buffer overrun\n");
 		return;
 	}
 	_lirc_buffer_write_1(&rbuf, (void *)&l);
 }
 
-static void inline frbwrite(lirc_t l)
+static inline void frbwrite(lirc_t l)
 {
 	/* simple noise filter */
-	static lirc_t pulse=0L,space=0L;
-	static unsigned int ptr=0;
-	
-	if(ptr>0 && (l&PULSE_BIT))
-	{
-		pulse+=l&PULSE_MASK;
-		if(pulse>250)
-		{
+	static lirc_t pulse = 0L, space = 0L;
+	static unsigned int ptr;
+
+	if (ptr > 0 && (l&PULSE_BIT)) {
+		pulse += l&PULSE_MASK;
+		if (pulse > 250) {
 			rbwrite(space);
 			rbwrite(pulse|PULSE_BIT);
-			ptr=0;
-			pulse=0;
+			ptr = 0;
+			pulse = 0;
 		}
 		return;
 	}
-	if(!(l&PULSE_BIT))
-	{
-		if(ptr==0)
-		{
-			if(l>20000)
-			{
-				space=l;
+	if (!(l&PULSE_BIT)) {
+		if (ptr == 0) {
+			if (l > 20000) {
+				space = l;
 				ptr++;
 				return;
 			}
-		}
-		else
-		{
-			if(l>20000)
-			{
-				space+=pulse;
-				if(space>PULSE_MASK) space=PULSE_MASK;
-				space+=l;
-				if(space>PULSE_MASK) space=PULSE_MASK;
-				pulse=0;
+		} else {
+			if (l > 20000) {
+				space += pulse;
+				if (space > PULSE_MASK)
+					space = PULSE_MASK;
+				space += l;
+				if (space > PULSE_MASK)
+					space = PULSE_MASK;
+				pulse = 0;
 				return;
 			}
 			rbwrite(space);
 			rbwrite(pulse|PULSE_BIT);
-			ptr=0;
-			pulse=0;
+			ptr = 0;
+			pulse = 0;
 		}
 	}
 	rbwrite(l);
@@ -757,38 +740,36 @@ static irqreturn_t irq_handler(int i, void *blah, struct pt_regs *regs)
 #endif
 {
 	struct timeval tv;
-	int status,counter,dcd;
+	int status, counter, dcd;
 	long deltv;
 	lirc_t data;
-	
-	if((sinp(UART_IIR) & UART_IIR_NO_INT))
-	{
+	static int last_dcd = -1;
+
+	if ((sinp(UART_IIR) & UART_IIR_NO_INT)) {
 		/* not our interrupt */
 		return IRQ_RETVAL(IRQ_NONE);
 	}
-	
-	counter=0;
-	do{
+
+	counter = 0;
+	do {
 		counter++;
-		status=sinp(UART_MSR);
-		if(counter>RS_ISR_PASS_LIMIT)
-		{
+		status = sinp(UART_MSR);
+		if (counter > RS_ISR_PASS_LIMIT) {
 			printk(KERN_WARNING LIRC_DRIVER_NAME ": AIEEEE: "
 			       "We're caught!\n");
 			break;
 		}
-		if((status&hardware[type].signal_pin_change) && sense!=-1)
-		{
+		if ((status&hardware[type].signal_pin_change) && sense != -1) {
 			/* get current time */
 			do_gettimeofday(&tv);
-			
-			/* New mode, written by Trent Piepho 
+
+			/* New mode, written by Trent Piepho
 			   <xyzzy@u.washington.edu>. */
-			
+
 			/* The old format was not very portable.
 			   We now use the type lirc_t to pass pulses
 			   and spaces to user space.
-			   
+
 			   If PULSE_BIT is set a pulse has been
 			   received, otherwise a space has been
 			   received.  The driver needs to know if your
@@ -805,49 +786,54 @@ static irqreturn_t irq_handler(int i, void *blah, struct pt_regs *regs)
 
 			/* calculate time since last interrupt in
 			   microseconds */
-			dcd=(status & hardware[type].signal_pin) ? 1:0;
-			
-			deltv=tv.tv_sec-lasttv.tv_sec;
-			if(tv.tv_sec<lasttv.tv_sec ||
-			   (tv.tv_sec==lasttv.tv_sec &&
-			    tv.tv_usec<lasttv.tv_usec))
-			{
+			dcd = (status & hardware[type].signal_pin) ? 1:0;
+
+			if (dcd == last_dcd) {
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				": ignoring spike: %d %d %lx %lx %lx %lx\n",
+				dcd, sense,
+				tv.tv_sec, lasttv.tv_sec,
+				tv.tv_usec, lasttv.tv_usec);
+				continue;
+			}
+
+			deltv = tv.tv_sec-lasttv.tv_sec;
+			if (tv.tv_sec < lasttv.tv_sec ||
+			    (tv.tv_sec == lasttv.tv_sec &&
+			     tv.tv_usec < lasttv.tv_usec)) {
 				printk(KERN_WARNING LIRC_DRIVER_NAME
 				       ": AIEEEE: your clock just jumped "
 				       "backwards\n");
 				printk(KERN_WARNING LIRC_DRIVER_NAME
 				       ": %d %d %lx %lx %lx %lx\n",
-				       dcd,sense,
-				       tv.tv_sec,lasttv.tv_sec,
-				       tv.tv_usec,lasttv.tv_usec);
-				data=PULSE_MASK;
-			}
-			else if(deltv>15) 
-			{
-				data=PULSE_MASK; /* really long time */
-				if(!(dcd^sense)) /* sanity check */
-				{
+				       dcd, sense,
+				       tv.tv_sec, lasttv.tv_sec,
+				       tv.tv_usec, lasttv.tv_usec);
+				data = PULSE_MASK;
+			} else if (deltv > 15) {
+				data = PULSE_MASK; /* really long time */
+				if (!(dcd^sense)) {
+					/* sanity check */
 					printk(KERN_WARNING LIRC_DRIVER_NAME
-					       "AIEEEE: %d %d %lx %lx %lx %lx\n",
-					       dcd,sense,
-					       tv.tv_sec,lasttv.tv_sec,
-					       tv.tv_usec,lasttv.tv_usec);
-				        /* detecting pulse while this
+					       ": AIEEEE: "
+					       "%d %d %lx %lx %lx %lx\n",
+					       dcd, sense,
+					       tv.tv_sec, lasttv.tv_sec,
+					       tv.tv_usec, lasttv.tv_usec);
+					/* detecting pulse while this
 					   MUST be a space! */
-				        sense=sense ? 0:1;
+					sense = sense ? 0:1;
 				}
-			}
-			else
-			{
-				data=(lirc_t) (deltv*1000000+
-					       tv.tv_usec-
+			} else
+				data = (lirc_t) (deltv*1000000 +
+					       tv.tv_usec -
 					       lasttv.tv_usec);
-			}
 			frbwrite(dcd^sense ? data : (data|PULSE_BIT));
-			lasttv=tv;
+			lasttv = tv;
+			last_dcd = dcd;
 			wake_up_interruptible(&rbuf.wait_poll);
 		}
-	} while(!(sinp(UART_IIR) & UART_IIR_NO_INT)); /* still pending ? */
+	} while (!(sinp(UART_IIR) & UART_IIR_NO_INT)); /* still pending ? */
 	return IRQ_RETVAL(IRQ_HANDLED);
 }
 
@@ -855,162 +841,151 @@ static void hardware_init_port(void)
 {
 	unsigned long flags;
 	local_irq_save(flags);
-	
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	/* First of all, disable all interrupts */
-	soutp(UART_IER, sinp(UART_IER)&
+	soutp(UART_IER, sinp(UART_IER) &
 	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
-	
+
 	/* Clear registers. */
 	sinp(UART_LSR);
 	sinp(UART_RX);
 	sinp(UART_IIR);
 	sinp(UART_MSR);
-	
+
 #if defined(LIRC_SERIAL_NSLU2)
-	if(type == LIRC_NSLU2) /* Setup NSLU2 UART */
-	{
+	if (type == LIRC_NSLU2) {
+		/* Setup NSLU2 UART */
+
 		/* Enable UART */
 		soutp(UART_IER, sinp(UART_IER) | UART_IE_IXP42X_UUE);
 		/* Disable Receiver data Time out interrupt */
 		soutp(UART_IER, sinp(UART_IER) & ~UART_IE_IXP42X_RTOIE);
 		/* set out2 = interupt unmask; off() doesn't set MCR
 		   on NSLU2 */
-		soutp(UART_MCR,UART_MCR_RTS|UART_MCR_OUT2);
+		soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
 	}
 #endif
 
 	/* Set line for power source */
 	off();
-	
+
 	/* Clear registers again to be sure. */
 	sinp(UART_LSR);
 	sinp(UART_RX);
 	sinp(UART_IIR);
 	sinp(UART_MSR);
 
-	switch(type)
-	{
+	switch (type) {
 	case LIRC_IRDEO:
 	case LIRC_IRDEO_REMOTE:
 		/* setup port to 7N1 @ 115200 Baud */
 		/* 7N1+start = 9 bits at 115200 ~ 3 bits at 38kHz */
-		
+
 		/* Set DLAB 1. */
 		soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
 		/* Set divisor to 1 => 115200 Baud */
-		soutp(UART_DLM,0);
-		soutp(UART_DLL,1);
+		soutp(UART_DLM, 0);
+		soutp(UART_DLL, 1);
 		/* Set DLAB 0 +  7N1 */
-		soutp(UART_LCR,UART_LCR_WLEN7);
+		soutp(UART_LCR, UART_LCR_WLEN7);
 		/* THR interrupt already disabled at this point */
 		break;
 	default:
 		break;
 	}
-	
+
 	local_irq_restore(flags);
 }
-	
+
 static int init_port(void)
 {
 	int i, nlow, nhigh;
-	
+
 	/* Reserve io region. */
 #if defined(LIRC_ALLOW_MMAPPED_IO)
 	/* Future MMAP-Developers: Attention!
 	   For memory mapped I/O you *might* need to use ioremap() first,
 	   for the NSLU2 it's done in boot code. */
-	if(((iommap != 0)
-	    && (request_mem_region(iommap, 8<<ioshift,
-				   LIRC_DRIVER_NAME) == NULL))
+	if (((iommap != 0)
+	     && (request_mem_region(iommap, 8<<ioshift,
+				    LIRC_DRIVER_NAME) == NULL))
 	   || ((iommap == 0)
-	       && (request_region(io, 8, LIRC_DRIVER_NAME) == NULL)))
+	       && (request_region(io, 8, LIRC_DRIVER_NAME) == NULL))) {
 #else
-	if(request_region(io, 8, LIRC_DRIVER_NAME)==NULL)
+	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {
 #endif
-	{
-		printk(KERN_ERR  LIRC_DRIVER_NAME  
+		printk(KERN_ERR  LIRC_DRIVER_NAME
 		       ": port %04x already in use\n", io);
-		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		printk(KERN_WARNING LIRC_DRIVER_NAME
 		       ": use 'setserial /dev/ttySX uart none'\n");
-		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		printk(KERN_WARNING LIRC_DRIVER_NAME
 		       ": or compile the serial port driver as module and\n");
-		printk(KERN_WARNING LIRC_DRIVER_NAME  
+		printk(KERN_WARNING LIRC_DRIVER_NAME
 		       ": make sure this module is loaded first\n");
-		return(-EBUSY);
+		return -EBUSY;
 	}
-	
+
 	hardware_init_port();
 
 	/* Initialize pulse/space widths */
 	init_timing_params(duty_cycle, freq);
 
 	/* If pin is high, then this must be an active low receiver. */
-	if(sense==-1)
-	{
+	if (sense == -1) {
 		/* wait 1/2 sec for the power supply */
-		
+
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ/2);
-		
+
 		/* probe 9 times every 0.04s, collect "votes" for
 		   active high/low */
 		nlow = 0;
 		nhigh = 0;
-		for(i = 0; i < 9; i ++)
-		{
+		for (i = 0; i < 9; i ++) {
 			if (sinp(UART_MSR) & hardware[type].signal_pin)
-			{
 				nlow++;
-			}
 			else
-			{
 				nhigh++;
-			}
 			schedule_timeout(HZ/25);
 		}
 		sense = (nlow >= nhigh ? 1 : 0);
 		printk(KERN_INFO  LIRC_DRIVER_NAME  ": auto-detected active "
-		       "%s receiver\n",sense ? "low":"high");
-	}
-	else
-	{
+		       "%s receiver\n", sense ? "low":"high");
+	} else
 		printk(KERN_INFO  LIRC_DRIVER_NAME  ": Manually using active "
-		       "%s receiver\n",sense ? "low":"high");
-	};
-	
+		       "%s receiver\n", sense ? "low":"high");
+
 	return 0;
 }
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	int result;
 	unsigned long flags;
-	
+
 	/* Init read buffer. */
 	if (lirc_buffer_init(&rbuf, sizeof(lirc_t), RBUF_LEN) < 0)
 		return -ENOMEM;
-	
+
 	/* initialize timestamp */
 	do_gettimeofday(&lasttv);
 
-	result=request_irq(irq,irq_handler,
-			   SA_INTERRUPT | (share_irq ? SA_SHIRQ:0),
-			   LIRC_DRIVER_NAME,(void *)&hardware);
-	
-	switch(result)
-	{
+	result = request_irq(irq, irq_handler,
+			   IRQF_DISABLED | (share_irq ? IRQF_SHARED:0),
+			   LIRC_DRIVER_NAME, (void *)&hardware);
+
+	switch (result) {
 	case -EBUSY:
 		printk(KERN_ERR LIRC_DRIVER_NAME ": IRQ %d busy\n", irq);
-                lirc_buffer_free(&rbuf);
+		lirc_buffer_free(&rbuf);
 		return -EBUSY;
 	case -EINVAL:
 		printk(KERN_ERR LIRC_DRIVER_NAME
 		       ": Bad irq number or handler\n");
-                lirc_buffer_free(&rbuf);
+		lirc_buffer_free(&rbuf);
 		return -EINVAL;
 	default:
 		dprintk("Interrupt %d, port %04x obtained\n", irq, io);
@@ -1018,160 +993,158 @@ static int set_use_inc(void* data)
 	};
 
 	local_irq_save(flags);
-	
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	soutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);
-	
+
 	local_irq_restore(flags);
-	
+
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {	unsigned long flags;
-	
+
 	local_irq_save(flags);
-	
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	/* First of all, disable all interrupts */
-	soutp(UART_IER, sinp(UART_IER)&
+	soutp(UART_IER, sinp(UART_IER) &
 	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
 	local_irq_restore(flags);
 
 	free_irq(irq, (void *)&hardware);
-	
+
 	dprintk("freed IRQ %d\n", irq);
 	lirc_buffer_free(&rbuf);
-	
+
 	MOD_DEC_USE_COUNT;
 }
 
 static ssize_t lirc_write(struct file *file, const char *buf,
-			 size_t n, loff_t * ppos)
+			 size_t n, loff_t *ppos)
 {
-	int i,count;
+	int i, count;
 	unsigned long flags;
-	long delta=0;
-	
-	if(!(hardware[type].features&LIRC_CAN_SEND_PULSE))
-	{
-		return(-EBADF);
-	}
-	
-	if(n%sizeof(lirc_t)) return(-EINVAL);
-	count=n/sizeof(lirc_t);
-	if(count>WBUF_LEN || count%2==0) return(-EINVAL);
-	if(copy_from_user(wbuf,buf,n)) return -EFAULT;
+	long delta = 0;
+
+	if (!(hardware[type].features&LIRC_CAN_SEND_PULSE))
+		return -EBADF;
+
+	if (n % sizeof(lirc_t))
+		return -EINVAL;
+	count = n / sizeof(lirc_t);
+	if (count > WBUF_LEN || count % 2 == 0)
+		return -EINVAL;
+	if (copy_from_user(wbuf, buf, n))
+		return -EFAULT;
 	local_irq_save(flags);
-	if(type == LIRC_IRDEO)
-	{
+	if (type == LIRC_IRDEO) {
 		/* DTR, RTS down */
 		on();
 	}
-	for(i=0;i<count;i++)
-	{
-		if(i%2) hardware[type].send_space(wbuf[i]-delta);
-		else delta=hardware[type].send_pulse(wbuf[i]);
+	for (i = 0; i < count; i++) {
+		if (i%2)
+			hardware[type].send_space(wbuf[i]-delta);
+		else
+			delta = hardware[type].send_pulse(wbuf[i]);
 	}
 	off();
 	local_irq_restore(flags);
-	return(n);
+	return n;
 }
 
-static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+static int lirc_ioctl(struct inode *node, struct file *filep, unsigned int cmd,
 		      unsigned long arg)
 {
-        int result;
+	int result;
 	unsigned long value;
 	unsigned int ivalue;
-	
-	switch(cmd)
-	{
+
+	switch (cmd) {
 	case LIRC_GET_SEND_MODE:
-		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=put_user(LIRC_SEND2MODE
-				(hardware[type].features&LIRC_CAN_SEND_MASK),
-				(unsigned long *) arg);
-		if(result) return(result); 
+		if (!(hardware[type].features&LIRC_CAN_SEND_MASK))
+			return -ENOIOCTLCMD;
+
+		result = put_user(LIRC_SEND2MODE
+				  (hardware[type].features&LIRC_CAN_SEND_MASK),
+				  (unsigned long *) arg);
+		if (result)
+			return result;
 		break;
-		
+
 	case LIRC_SET_SEND_MODE:
-		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=get_user(value,(unsigned long *) arg);
-		if(result) return(result);
+		if (!(hardware[type].features&LIRC_CAN_SEND_MASK))
+			return -ENOIOCTLCMD;
+
+		result = get_user(value, (unsigned long *) arg);
+		if (result)
+			return result;
 		/* only LIRC_MODE_PULSE supported */
-		if(value!=LIRC_MODE_PULSE) return(-ENOSYS);
+		if (value != LIRC_MODE_PULSE)
+			return -ENOSYS;
 		break;
-		
+
 	case LIRC_GET_LENGTH:
-		return(-ENOSYS);
+		return -ENOSYS;
 		break;
-		
+
 	case LIRC_SET_SEND_DUTY_CYCLE:
 		dprintk("SET_SEND_DUTY_CYCLE\n");
-		if(!(hardware[type].features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		if (!(hardware[type].features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
+			return -ENOIOCTLCMD;
+
+		result = get_user(ivalue, (unsigned int *) arg);
+		if (result)
+			return result;
+		if (ivalue <= 0 || ivalue > 100)
+			return -EINVAL;
 		return init_timing_params(ivalue, freq);
 		break;
-		
+
 	case LIRC_SET_SEND_CARRIER:
 		dprintk("SET_SEND_CARRIER\n");
-		if(!(hardware[type].features&LIRC_CAN_SET_SEND_CARRIER))
-		{
-			return(-ENOIOCTLCMD);
-		}
-		
-		result=get_user(ivalue,(unsigned int *) arg);
-		if(result) return(result);
-		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
+		if (!(hardware[type].features&LIRC_CAN_SET_SEND_CARRIER))
+			return -ENOIOCTLCMD;
+
+		result = get_user(ivalue, (unsigned int *) arg);
+		if (result)
+			return result;
+		if (ivalue > 500000 || ivalue < 20000)
+			return -EINVAL;
 		return init_timing_params(duty_cycle, ivalue);
 		break;
-		
+
 	default:
-		return(-ENOIOCTLCMD);
+		return -ENOIOCTLCMD;
 	}
-	return(0);
+	return 0;
 }
 
-static struct file_operations lirc_fops =
-{
-	write:   lirc_write,
+static struct file_operations lirc_fops = {
+	.write	= lirc_write,
 };
 
 static struct lirc_plugin plugin = {
-	name:		LIRC_DRIVER_NAME,
-	minor:		-1,
-	code_length:	1,
-	sample_rate:	0,
-	data:		NULL,
-	add_to_buf:	NULL,
-	get_queue:	NULL,
-	rbuf:		&rbuf,
-	set_use_inc:	set_use_inc,
-	set_use_dec:	set_use_dec,
-	ioctl:		lirc_ioctl,
-	fops:		&lirc_fops,
-	dev:		NULL,
-	owner:		THIS_MODULE,
+	.name		= LIRC_DRIVER_NAME,
+	.minor		= -1,
+	.code_length	= 1,
+	.sample_rate	= 0,
+	.data		= NULL,
+	.add_to_buf	= NULL,
+	.get_queue	= NULL,
+	.rbuf		= &rbuf,
+	.set_use_inc	= set_use_inc,
+	.set_use_dec	= set_use_dec,
+	.ioctl		= lirc_ioctl,
+	.fops		= &lirc_fops,
+	.dev		= NULL,
+	.owner		= THIS_MODULE,
 };
 
 #ifdef MODULE
@@ -1179,20 +1152,24 @@ static struct lirc_plugin plugin = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
 static struct platform_device *lirc_serial_dev;
 
-static int __devinit lirc_serial_probe(struct platform_device *dev) {
+static int __devinit lirc_serial_probe(struct platform_device *dev)
+{
 	return 0;
 }
 
-static int __devexit lirc_serial_remove(struct platform_device * dev) {
+static int __devexit lirc_serial_remove(struct platform_device *dev)
+{
 	return 0;
 }
 
-static int lirc_serial_suspend(struct platform_device *dev, pm_message_t state) {
+static int lirc_serial_suspend(struct platform_device *dev,
+			       pm_message_t state)
+{
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	/* Disable all interrupts */
-	soutp(UART_IER, sinp(UART_IER)&
+	soutp(UART_IER, sinp(UART_IER) &
 	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
 
 	/* Clear registers. */
@@ -1204,7 +1181,8 @@ static int lirc_serial_suspend(struct platform_device *dev, pm_message_t state)
 	return 0;
 }
 
-static int lirc_serial_resume(struct platform_device *dev) {
+static int lirc_serial_resume(struct platform_device *dev)
+{
 	unsigned long flags;
 
 	hardware_init_port();
@@ -1224,7 +1202,7 @@ static int lirc_serial_resume(struct platform_device *dev) {
 
 static struct platform_driver lirc_serial_driver = {
 	.probe		= lirc_serial_probe,
-	.remove	= 	__devexit_p(lirc_serial_remove),
+	.remove		= __devexit_p(lirc_serial_remove),
 	.suspend	= lirc_serial_suspend,
 	.resume		= lirc_serial_resume,
 	.driver		= {
@@ -1237,35 +1215,48 @@ static int __init lirc_serial_init(void)
 {
 	int result;
 
-	lirc_serial_dev = platform_device_alloc("lirc_serial", 0);
-	if (!lirc_serial_dev)
-		return -ENOMEM;
-	result = platform_device_add(lirc_serial_dev);
-	if (result) {
-		platform_device_put(lirc_serial_dev);
-		return result;
-	}
 	result = platform_driver_register(&lirc_serial_driver);
 	if (result) {
 		printk("lirc register returned %d\n", result);
-		platform_device_del(lirc_serial_dev);
-		platform_device_put(lirc_serial_dev);
 		return result;
 	}
+
+	lirc_serial_dev = platform_device_alloc("lirc_serial", 0);
+	if (!lirc_serial_dev) {
+		result = -ENOMEM;
+		goto exit_driver_unregister;
+	}
+
+	result = platform_device_add(lirc_serial_dev);
+	if (result)
+		goto exit_device_put;
+
 	return 0;
+
+exit_device_put:
+	platform_device_put(lirc_serial_dev);
+exit_driver_unregister:
+	platform_driver_unregister(&lirc_serial_driver);
+	return result;
+}
+
+static void __exit lirc_serial_exit(void)
+{
+	platform_device_unregister(lirc_serial_dev);
+	platform_driver_unregister(&lirc_serial_driver);
 }
 #endif
 
 int __init init_module(void)
 {
 	int result;
-	
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
 	result = lirc_serial_init();
-	if(result) return result;
+	if (result)
+		return result;
 #endif
-	switch(type)
-	{
+	switch (type) {
 	case LIRC_HOMEBREW:
 	case LIRC_IRDEO:
 	case LIRC_IRDEO_REMOTE:
@@ -1276,44 +1267,40 @@ int __init init_module(void)
 #endif
 		break;
 	default:
-		return -EINVAL;
+		result = -EINVAL;
+		goto exit_serial_exit;
 	}
-	if(!softcarrier)
-	{
-		switch(type)
-		{
+	if (!softcarrier) {
+		switch (type) {
 		case LIRC_HOMEBREW:
 		case LIRC_IGOR:
 		case LIRC_NSLU2:
-			hardware[type].features&=
+			hardware[type].features &=
 				~(LIRC_CAN_SET_SEND_DUTY_CYCLE|
 				  LIRC_CAN_SET_SEND_CARRIER);
 			break;
 		}
 	}
-	if((result = init_port()) < 0)
-	{
-		return result;
-	}
+	result = init_port();
+	if (result < 0)
+		goto exit_serial_exit;
 	plugin.features = hardware[type].features;
-	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) {
-		printk(KERN_ERR  LIRC_DRIVER_NAME  
+	plugin.minor = lirc_register_plugin(&plugin);
+	if (plugin.minor < 0) {
+		printk(KERN_ERR  LIRC_DRIVER_NAME
 		       ": register_chrdev failed!\n");
-		release_region(io, 8);
-		return -EIO;
+		result = -EIO;
+		goto exit_release;
 	}
 	return 0;
-}
-
+exit_release:
+	release_region(io, 8);
+exit_serial_exit:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
-static void __exit lirc_serial_exit(void)
-{
-	struct platform_device *pdev = lirc_serial_dev;
-	lirc_serial_dev = NULL;
-	platform_driver_unregister(&lirc_serial_driver);
-	platform_device_unregister(pdev);
-}
+	lirc_serial_exit();
 #endif
+	return result;
+}
 
 void __exit cleanup_module(void)
 {
@@ -1321,14 +1308,10 @@ void __exit cleanup_module(void)
 	lirc_serial_exit();
 #endif
 #if defined(LIRC_ALLOW_MMAPPED_IO)
-	if(iommap != 0)
-	{
+	if (iommap != 0)
 		release_mem_region(iommap, 8<<ioshift);
-	}
 	else
-	{
 		release_region(io, 8);
-	}
 #else
 	release_region(io, 8);
 #endif
@@ -1337,19 +1320,18 @@ void __exit cleanup_module(void)
 }
 
 MODULE_DESCRIPTION("Infra-red receiver driver for serial ports.");
-MODULE_AUTHOR("Ralph Metzler, Trent Piepho, Ben Pfaff, Christoph Bartelmus, Andrei Tanas");
+MODULE_AUTHOR("Ralph Metzler, Trent Piepho, Ben Pfaff, "
+	      "Christoph Bartelmus, Andrei Tanas");
 MODULE_LICENSE("GPL");
 
 module_param(type, int, 0444);
 #if defined(LIRC_SERIAL_NSLU2)
 MODULE_PARM_DESC(type, "Hardware type (0 = home-brew, 1 = IRdeo,"
 		 " 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug,"
-		 " 5 = NSLU2 RX:CTS2/TX:GreenLED"
-		 );
+		 " 5 = NSLU2 RX:CTS2/TX:GreenLED)");
 #else
 MODULE_PARM_DESC(type, "Hardware type (0 = home-brew, 1 = IRdeo,"
-		 " 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug"
-		 );
+		 " 2 = IRdeo Remote, 3 = AnimaX, 4 = IgorPlug)");
 #endif
 
 module_param(io, int, 0444);
diff --git a/drivers/char/lirc/lirc_sir.c b/drivers/char/lirc/lirc_sir.c
index 5db3186..e1b422f 100644
--- a/drivers/char/lirc/lirc_sir.c
+++ b/drivers/char/lirc/lirc_sir.c
@@ -22,13 +22,13 @@
  * 2000/09/16 Frank Przybylski <mail@frankprzybylski.de> :
  *  added timeout and relaxed pulse detection, removed gap bug
  *
- * 2000/12/15 Christoph Bartelmus <lirc@bartelmus.de> : 
+ * 2000/12/15 Christoph Bartelmus <lirc@bartelmus.de> :
  *   added support for Tekram Irmate 210 (sending does not work yet,
  *   kind of disappointing that nobody was able to implement that
  *   before),
  *   major clean-up
  *
- * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> : 
+ * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
  *   added support for StrongARM SA1100 embedded microprocessor
  *   parts cut'n'pasted from sa1100_ir.c (C) 2000 Russell King
  */
@@ -45,7 +45,7 @@
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
- 
+
 #include <linux/autoconf.h>
 
 #if !defined(LIRC_ON_SA1100) && !defined(CONFIG_SERIAL_MODULE)
@@ -121,8 +121,7 @@ static void init_act220(void);
 
 /******************************* SA1100 ********************************/
 #ifdef LIRC_ON_SA1100
-struct sa1100_ser2_registers
-{
+struct sa1100_ser2_registers {
 	/* HSSP control register */
 	unsigned char hscr0;
 	/* UART registers */
@@ -136,7 +135,7 @@ struct sa1100_ser2_registers
 	unsigned char utsr1;
 } sr;
 
-static int irq=IRQ_Ser2ICP;
+static int irq = IRQ_Ser2ICP;
 
 #define LIRC_ON_SA1100_TRANSMITTER_LATENCY 0
 
@@ -179,40 +178,42 @@ static int irq = LIRC_IRQ;
 static int threshold = 3;
 #endif
 
-static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(timer_lock);
 static struct timer_list timerlist;
 /* time of last signal change detected */
 static struct timeval last_tv = {0, 0};
 /* time of last UART data ready interrupt */
 static struct timeval last_intr_tv = {0, 0};
-static int last_value = 0;
+static int last_value;
 
 static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
 
-static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(hardware_lock);
+static DEFINE_SPINLOCK(dev_lock);
 
-static lirc_t rx_buf[RBUF_LEN]; 
-static unsigned int rx_tail = 0, rx_head = 0;
+static lirc_t rx_buf[RBUF_LEN];
+static unsigned int rx_tail, rx_head;
 static lirc_t tx_buf[WBUF_LEN];
 
-static int debug = 0;
-#define dprintk(fmt, args...)                                     \
-	do{                                                       \
-		if(debug) printk(KERN_DEBUG LIRC_DRIVER_NAME ": " \
-                                 fmt, ## args);                   \
-	}while(0)
+static int debug;
+#define dprintk(fmt, args...)						\
+	do {								\
+		if (debug)						\
+			printk(KERN_DEBUG LIRC_DRIVER_NAME ": "		\
+				fmt, ## args);				\
+	} while (0)
 
 /* SECTION: Prototypes */
 
 /* Communication with user-space */
-static int lirc_open(struct inode * inode, struct file * file);
-static int lirc_close(struct inode * inode, struct file *file);
-static unsigned int lirc_poll(struct file * file, poll_table * wait);
-static ssize_t lirc_read(struct file * file, char * buf, size_t count,
-		loff_t * ppos);
-static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos);
-static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+static int lirc_open(struct inode *inode, struct file *file);
+static int lirc_close(struct inode *inode, struct file *file);
+static unsigned int lirc_poll(struct file *file, poll_table *wait);
+static ssize_t lirc_read(struct file *file, char *buf, size_t count,
+		loff_t *ppos);
+static ssize_t lirc_write(struct file *file, const char *buf, size_t n,
+		loff_t *pos);
+static int lirc_ioctl(struct inode *node, struct file *filep, unsigned int cmd,
 		unsigned long arg);
 static void add_read_queue(int flag, unsigned long val);
 #ifdef MODULE
@@ -221,10 +222,10 @@ static void drop_chrdev(void);
 #endif
 	/* Hardware */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static irqreturn_t sir_interrupt(int irq, void * dev_id,
-				 struct pt_regs * regs);
+static irqreturn_t sir_interrupt(int irq, void *dev_id,
+				 struct pt_regs *regs);
 #else
-static irqreturn_t sir_interrupt(int irq, void * dev_id);
+static irqreturn_t sir_interrupt(int irq, void *dev_id);
 #endif
 static void send_space(unsigned long len);
 static void send_pulse(unsigned long len);
@@ -237,14 +238,14 @@ int init_module(void);
 void cleanup_module(void);
 
 #ifdef LIRC_ON_SA1100
-static void inline on(void)
+static inline void on(void)
 {
-	PPSR|=PPC_TXD2;
+	PPSR |= PPC_TXD2;
 }
-  
-static void inline off(void)
+
+static inline void off(void)
 {
-	PPSR&=~PPC_TXD2;
+	PPSR &= ~PPC_TXD2;
 }
 #else
 static inline unsigned int sinp(int offset)
@@ -266,17 +267,16 @@ static inline void soutp(int offset, int value)
 
 static inline void safe_udelay(unsigned long usecs)
 {
-	while(usecs>MAX_UDELAY_US)
-	{
+	while (usecs > MAX_UDELAY_US) {
 		udelay(MAX_UDELAY_US);
-		usecs-=MAX_UDELAY_US;
+		usecs -= MAX_UDELAY_US;
 	}
 	udelay(usecs);
 }
 
 /* SECTION: Communication with user-space */
 
-static int lirc_open(struct inode * inode, struct file * file)
+static int lirc_open(struct inode *inode, struct file *file)
 {
 	spin_lock(&dev_lock);
 	if (MOD_IN_USE) {
@@ -288,13 +288,13 @@ static int lirc_open(struct inode * inode, struct file * file)
 	return 0;
 }
 
-static int lirc_close(struct inode * inode, struct file *file)
+static int lirc_close(struct inode *inode, struct file *file)
 {
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
-static unsigned int lirc_poll(struct file * file, poll_table * wait)
+static unsigned int lirc_poll(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &lirc_read_queue, wait);
 	if (rx_head != rx_tail)
@@ -302,64 +302,60 @@ static unsigned int lirc_poll(struct file * file, poll_table * wait)
 	return 0;
 }
 
-static ssize_t lirc_read(struct file * file, char * buf, size_t count,
-		loff_t * ppos)
+static ssize_t lirc_read(struct file *file, char *buf, size_t count,
+		loff_t *ppos)
 {
-	int n=0;
+	int n = 0;
 	int retval = 0;
-	DECLARE_WAITQUEUE(wait,current);
-	
-	if(n%sizeof(lirc_t)) return(-EINVAL);
-	
-	add_wait_queue(&lirc_read_queue,&wait);
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (n % sizeof(lirc_t))
+		return -EINVAL;
+
+	add_wait_queue(&lirc_read_queue, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
-	while(n<count)
-	{
-		if(rx_head!=rx_tail)
-		{
-			if(copy_to_user((void *) buf+n,
-					(void *) (rx_buf+rx_head),
-					sizeof(lirc_t)))
-			{
-				retval=-EFAULT;
+	while (n < count) {
+		if (rx_head != rx_tail) {
+			if (copy_to_user((void *) buf + n,
+					(void *) (rx_buf + rx_head),
+					sizeof(lirc_t))) {
+				retval = -EFAULT;
 				break;
 			}
-			rx_head=(rx_head+1)&(RBUF_LEN-1);
-			n+=sizeof(lirc_t);
-		}
-		else
-		{
-			if(file->f_flags & O_NONBLOCK)
-			{
-				retval=-EAGAIN;
+			rx_head = (rx_head + 1) & (RBUF_LEN - 1);
+			n += sizeof(lirc_t);
+		} else {
+			if (file->f_flags & O_NONBLOCK) {
+				retval = -EAGAIN;
 				break;
 			}
-			if(signal_pending(current))
-			{
-				retval=-ERESTARTSYS;
+			if (signal_pending(current)) {
+				retval = -ERESTARTSYS;
 				break;
 			}
 			schedule();
 			set_current_state(TASK_INTERRUPTIBLE);
 		}
 	}
-	remove_wait_queue(&lirc_read_queue,&wait);
+	remove_wait_queue(&lirc_read_queue, &wait);
 	set_current_state(TASK_RUNNING);
 	return (n ? n : retval);
 }
-static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos)
+static ssize_t lirc_write(struct file *file, const char *buf, size_t n,
+				loff_t *pos)
 {
 	unsigned long flags;
 	int i;
 
-        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
-		return(-EINVAL);
-	if(copy_from_user(tx_buf, buf, n)) return -EFAULT;
+	if (n % sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
+		return -EINVAL;
+	if (copy_from_user(tx_buf, buf, n))
+		return -EFAULT;
 	i = 0;
-	n/=sizeof(lirc_t);
+	n /= sizeof(lirc_t);
 #ifdef LIRC_ON_SA1100
 	/* disable receiver */
-	Ser2UTCR3=0;
+	Ser2UTCR3 = 0;
 #endif
 	local_irq_save(flags);
 	while (1) {
@@ -378,16 +374,16 @@ static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t
 #ifdef LIRC_ON_SA1100
 	off();
 	udelay(1000); /* wait 1ms for IR diode to recover */
-	Ser2UTCR3=0;
+	Ser2UTCR3 = 0;
 	/* clear status register to prevent unwanted interrupts */
 	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
 	/* enable receiver */
-	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
+	Ser2UTCR3 = UTCR3_RXE|UTCR3_RIE;
 #endif
 	return n;
 }
 
-static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+static int lirc_ioctl(struct inode *node, struct file *filep, unsigned int cmd,
 		unsigned long arg)
 {
 	int retval = 0;
@@ -426,36 +422,40 @@ static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
 		break;
 #ifdef LIRC_ON_SA1100
 	case LIRC_SET_SEND_DUTY_CYCLE:
-		retval=get_user(ivalue,(unsigned int *) arg);
-		if(retval) return(retval);
-		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		retval = get_user(ivalue, (unsigned int *) arg);
+		if (retval)
+			return reetval;
+		if (ivalue <= 0 || ivalue > 100)
+			return -EINVAL;
 		/* (ivalue/100)*(1000000/freq) */
-		duty_cycle=ivalue;
-		pulse_width=(unsigned long) duty_cycle*10000/freq;
-		space_width=(unsigned long) 1000000L/freq-pulse_width;
-		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
-			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
-		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
-			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		duty_cycle = ivalue;
+		pulse_width = (unsigned long) duty_cycle*10000/freq;
+		space_width = (unsigned long) 1000000L/freq-pulse_width;
+		if (pulse_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if (space_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;
 		break;
 	case LIRC_SET_SEND_CARRIER:
-		retval=get_user(ivalue,(unsigned int *) arg);
-		if(retval) return(retval);
-		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
-		freq=ivalue;
-		pulse_width=(unsigned long) duty_cycle*10000/freq;
-		space_width=(unsigned long) 1000000L/freq-pulse_width;
-		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
-			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
-		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
-			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		retval = get_user(ivalue, (unsigned int *) arg);
+		if (retval)
+			return retval;
+		if (ivalue > 500000 || ivalue < 20000)
+			return -EINVAL;
+		freq = ivalue;
+		pulse_width = (unsigned long) duty_cycle*10000/freq;
+		space_width = (unsigned long) 1000000L/freq-pulse_width;
+		if (pulse_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if (space_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;
 		break;
 #endif
 	default:
 		retval = -ENOIOCTLCMD;
 
 	}
-	
+
 	if (retval)
 		return retval;
 	if (cmd == LIRC_SET_REC_MODE) {
@@ -480,21 +480,15 @@ static void add_read_queue(int flag, unsigned long val)
 
 	/* statistically pulses are ~TIME_CONST/2 too long: we could
 	   maybe make this more exactly but this is good enough */
-	if(flag) /* pulse */
-	{
-		if(newval>TIME_CONST/2)
-		{
-			newval-=TIME_CONST/2;
-		}
+	if (flag) {
+		/* pulse */
+		if (newval > TIME_CONST/2)
+			newval -= TIME_CONST/2;
 		else /* should not ever happen */
-		{
-			newval=1;
-		}
-		newval|=PULSE_BIT;
-	}
-	else
-	{
-		newval+=TIME_CONST/2;
+			newval = 1;
+		newval |= PULSE_BIT;
+	} else {
+		newval += TIME_CONST/2;
 	}
 	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
 	if (new_rx_tail == rx_head) {
@@ -506,17 +500,16 @@ static void add_read_queue(int flag, unsigned long val)
 	wake_up_interruptible(&lirc_read_queue);
 }
 
-static struct file_operations lirc_fops =
-{
-	read:    lirc_read,
-	write:   lirc_write,
-	poll:    lirc_poll,
-	ioctl:   lirc_ioctl,
-	open:    lirc_open,
-	release: lirc_close,
+static struct file_operations lirc_fops = {
+	.read		= lirc_read,
+	.write		= lirc_write,
+	.poll		= lirc_poll,
+	.ioctl		= lirc_ioctl,
+	.open		= lirc_open,
+	.release	= lirc_close,
 };
 
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_INC_USE_COUNT;
@@ -524,25 +517,25 @@ static int set_use_inc(void* data)
        return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 #if WE_DONT_USE_LOCAL_OPEN_CLOSE
 	MOD_DEC_USE_COUNT;
 #endif
 }
 static struct lirc_plugin plugin = {
-       name:           LIRC_DRIVER_NAME,
-       minor:          -1,
-       code_length:    1,
-       sample_rate:    0,
-       data:           NULL,
-       add_to_buf:     NULL,
-       get_queue:      NULL,
-       set_use_inc:    set_use_inc,
-       set_use_dec:    set_use_dec,
-       fops:           &lirc_fops,
-       dev:            NULL,
-       owner:          THIS_MODULE,
+       .name		= LIRC_DRIVER_NAME,
+       .minor		= -1,
+       .code_length	= 1,
+       .sample_rate	= 0,
+       .data		= NULL,
+       .add_to_buf	= NULL,
+       .get_queue	= NULL,
+       .set_use_inc	= set_use_inc,
+       .set_use_dec	= set_use_dec,
+       .fops		= &lirc_fops,
+       .dev		= NULL,
+       .owner		= THIS_MODULE,
 };
 
 
@@ -564,10 +557,10 @@ static void drop_chrdev(void)
 #endif
 
 /* SECTION: Hardware */
-static long delta(struct timeval * tv1, struct timeval * tv2)
+static long delta(struct timeval *tv1, struct timeval *tv2)
 {
 	unsigned long deltv;
-	
+
 	deltv = tv2->tv_sec - tv1->tv_sec;
 	if (deltv > 15)
 		deltv = 0xFFFFFF;
@@ -578,39 +571,38 @@ static long delta(struct timeval * tv1, struct timeval * tv2)
 	return deltv;
 }
 
-static void sir_timeout(unsigned long data) 
+static void sir_timeout(unsigned long data)
 {
 	/* if last received signal was a pulse, but receiving stopped
 	   within the 9 bit frame, we need to finish this pulse and
 	   simulate a signal change to from pulse to space. Otherwise
 	   upper layers will receive two sequences next time. */
-	
+
 	unsigned long flags;
 	unsigned long pulse_end;
-	
+
 	/* avoid interference with interrupt */
- 	spin_lock_irqsave(&timer_lock, flags);
-	if (last_value)
-	{
+	spin_lock_irqsave(&timer_lock, flags);
+	if (last_value) {
 #ifndef LIRC_ON_SA1100
 		/* clear unread bits in UART and restart */
 		outb(UART_FCR_CLEAR_RCVR, io + UART_FCR);
 #endif
 		/* determine 'virtual' pulse end: */
-	 	pulse_end = delta(&last_tv, &last_intr_tv);
-		dprintk("timeout add %d for %lu usec\n",last_value,pulse_end);
-		add_read_queue(last_value,pulse_end);
+		pulse_end = delta(&last_tv, &last_intr_tv);
+		dprintk("timeout add %d for %lu usec\n", last_value, pulse_end);
+		add_read_queue(last_value, pulse_end);
 		last_value = 0;
-		last_tv=last_intr_tv;
+		last_tv = last_intr_tv;
 	}
-	spin_unlock_irqrestore(&timer_lock, flags);		
+	spin_unlock_irqrestore(&timer_lock, flags);
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static irqreturn_t sir_interrupt(int irq, void * dev_id,
-				 struct pt_regs * regs)
+static irqreturn_t sir_interrupt(int irq, void *dev_id,
+				 struct pt_regs *regs)
 #else
-static irqreturn_t sir_interrupt(int irq, void * dev_id)
+static irqreturn_t sir_interrupt(int irq, void *dev_id)
 #endif
 {
 	unsigned char data;
@@ -618,22 +610,20 @@ static irqreturn_t sir_interrupt(int irq, void * dev_id)
 	static unsigned long deltv;
 #ifdef LIRC_ON_SA1100
 	int status;
-	static int n=0;
-	
-	//printk("interrupt\n");
+	static int n;
+
 	status = Ser2UTSR0;
 	/*
 	 * Deal with any receive errors first.  The bytes in error may be
 	 * the only bytes in the receive FIFO, so we do this first.
 	 */
-	while (status & UTSR0_EIF)
-	{
+	while (status & UTSR0_EIF) {
 		int bstat;
 
-		if(debug) {
+		if (debug) {
 			dprintk("EIF\n");
 			bstat = Ser2UTSR1;
-		
+
 			if (bstat & UTSR1_FRE)
 				dprintk("frame error\n");
 			if (bstat & UTSR1_ROR)
@@ -641,41 +631,34 @@ static irqreturn_t sir_interrupt(int irq, void * dev_id)
 			if (bstat & UTSR1_PRE)
 				dprintk("parity error\n");
 		}
-		
+
 		bstat = Ser2UTDR;
 		n++;
 		status = Ser2UTSR0;
 	}
 
-	if (status & (UTSR0_RFS | UTSR0_RID))
-	{
+	if (status & (UTSR0_RFS | UTSR0_RID)) {
 		do_gettimeofday(&curr_tv);
 		deltv = delta(&last_tv, &curr_tv);
-		do
-		{
-			data=Ser2UTDR;
+		do {
+			data = Ser2UTDR;
 			dprintk("%d data: %u\n", n, (unsigned int) data);
 			n++;
-		}
-		while(status&UTSR0_RID && /* do not empty fifo in
-                                             order to get UTSR0_RID in
-                                             any case */
+		} while (status & UTSR0_RID && /* do not empty fifo in
+						order to get UTSR0_RID in
+						any case */
 		      Ser2UTSR1 & UTSR1_RNE); /* data ready */
-		
-		if(status&UTSR0_RID)
-		{
-			//printk("add\n");
-			add_read_queue(0,deltv-n*TIME_CONST); /*space*/
-			add_read_queue(1,n*TIME_CONST); /*pulse*/
-			n=0;
-			last_tv=curr_tv;
+
+		if (status&UTSR0_RID) {
+			add_read_queue(0 , deltv - n * TIME_CONST); /*space*/
+			add_read_queue(1, n * TIME_CONST); /*pulse*/
+			n = 0;
+			last_tv = curr_tv;
 		}
 	}
 
-	if (status & UTSR0_TFS) {
-
-		printk("transmit fifo not full, shouldn't ever happen\n");
-	}
+	if (status & UTSR0_TFS)
+		printk(KERN_ERR "transmit fifo not full, shouldn't happen\n");
 
 	/*
 	 * We must clear certain bits.
@@ -704,15 +687,14 @@ static irqreturn_t sir_interrupt(int irq, void * dev_id)
 			break;
 		case UART_IIR_RDI:
 			/* avoid interference with timer */
-		 	spin_lock_irqsave(&timer_lock, flags);
-			do
-			{
+			spin_lock_irqsave(&timer_lock, flags);
+			do {
 				del_timer(&timerlist);
 				data = inb(io + UART_RX);
 				do_gettimeofday(&curr_tv);
 				deltv = delta(&last_tv, &curr_tv);
 				deltintrtv = delta(&last_intr_tv, &curr_tv);
-				dprintk("t %lu , d %d\n", deltintrtv, (int)data);
+				dprintk("t %lu, d %d\n", deltintrtv, (int)data);
 				/* if nothing came in last X cycles,
 				   it was gap */
 				if (deltintrtv > TIME_CONST * threshold) {
@@ -720,39 +702,39 @@ static irqreturn_t sir_interrupt(int irq, void * dev_id)
 						dprintk("GAP\n");
 						/* simulate signal change */
 						add_read_queue(last_value,
-							       deltv-
+							       deltv -
 							       deltintrtv);
 						last_value = 0;
-						last_tv.tv_sec = last_intr_tv.tv_sec;
-						last_tv.tv_usec = last_intr_tv.tv_usec;
+						last_tv.tv_sec =
+							last_intr_tv.tv_sec;
+						last_tv.tv_usec =
+							last_intr_tv.tv_usec;
 						deltv = deltintrtv;
 					}
 				}
 				data = 1;
 				if (data ^ last_value) {
 					/* deltintrtv > 2*TIME_CONST,
-                                           remember ? */
+						remember ? */
 					/* the other case is timeout */
 					add_read_queue(last_value,
 						       deltv-TIME_CONST);
 					last_value = data;
 					last_tv = curr_tv;
-					if(last_tv.tv_usec>=TIME_CONST)
-					{
-						last_tv.tv_usec-=TIME_CONST;
-					}
-					else
-					{
+					if (last_tv.tv_usec >= TIME_CONST) {
+						last_tv.tv_usec -= TIME_CONST;
+					} else {
 						last_tv.tv_sec--;
-						last_tv.tv_usec+=1000000-
+						last_tv.tv_usec += 1000000 -
 							TIME_CONST;
 					}
 				}
 				last_intr_tv = curr_tv;
-				if (data)
-				{
-					/* start timer for end of sequence detection */
-					timerlist.expires = jiffies + SIR_TIMEOUT;
+				if (data) {
+					/* start timer for end of
+					 * sequence detection */
+					timerlist.expires = jiffies +
+								SIR_TIMEOUT;
 					add_timer(&timerlist);
 				}
 			}
@@ -771,24 +753,21 @@ static irqreturn_t sir_interrupt(int irq, void * dev_id)
 #ifdef LIRC_ON_SA1100
 static void send_pulse(unsigned long length)
 {
-	unsigned long k,delay;
+	unsigned long k, delay;
 	int flag;
 
-	if(length==0) return;
+	if (length == 0)
+		return;
 	/* this won't give us the carrier frequency we really want
 	   due to integer arithmetic, but we can accept this inaccuracy */
 
-	for(k=flag=0;k<length;k+=delay,flag=!flag)
-	{
-		if(flag)
-		{
+	for (k = flag = 0; k < length; k += delay, flag = !flag) {
+		if (flag) {
 			off();
-			delay=space_width;
-		}
-		else
-		{
+			delay = space_width;
+		} else {
 			on();
-			delay=pulse_width;
+			delay = pulse_width;
 		}
 		safe_udelay(delay);
 	}
@@ -797,7 +776,8 @@ static void send_pulse(unsigned long length)
 
 static void send_space(unsigned long length)
 {
-	if(length==0) return;
+	if (length == 0)
+		return;
 	off();
 	safe_udelay(length);
 }
@@ -813,13 +793,11 @@ static void send_pulse(unsigned long len)
 	long time_left;
 
 	time_left = (long)len - (long)bytes_out * (long)TIME_CONST;
-	if (bytes_out == 0)
-	{
+	if (bytes_out == 0) {
 		bytes_out++;
 		time_left = 0;
 	}
-	while (bytes_out--)
-       	{
+	while (bytes_out--) {
 		outb(PULSE, io + UART_TX);
 		/* FIXME treba seriozne cakanie z drivers/char/serial.c */
 		while (!(inb(io + UART_LSR) & UART_LSR_THRE));
@@ -845,8 +823,7 @@ static inline int sa1100_irda_set_power_collie(int state)
 					 TC35143_IODIR_OUTPUT);
 		ucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_LOW);
 		udelay(100);
-	}
-	else {
+	} else {
 		/* OFF */
 		ucb1200_set_io_direction(TC35143_GPIO_IR_ON,
 					 TC35143_IODIR_OUTPUT);
@@ -859,121 +836,121 @@ static inline int sa1100_irda_set_power_collie(int state)
 static int init_hardware(void)
 {
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&hardware_lock, flags);
 	/* reset UART */
 #ifdef LIRC_ON_SA1100
 #ifdef CONFIG_SA1100_BITSY
 	if (machine_is_bitsy()) {
-		printk("Power on IR module\n");
+		printk(KERN_INFO "Power on IR module\n");
 		set_bitsy_egpio(EGPIO_BITSY_IR_ON);
 	}
 #endif
 #ifdef CONFIG_SA1100_COLLIE
 	sa1100_irda_set_power_collie(3);	/* power on */
 #endif
-	sr.hscr0=Ser2HSCR0;
+	sr.hscr0 = Ser2HSCR0;
 
-	sr.utcr0=Ser2UTCR0;
-	sr.utcr1=Ser2UTCR1;
-	sr.utcr2=Ser2UTCR2;
-	sr.utcr3=Ser2UTCR3;
-	sr.utcr4=Ser2UTCR4;
+	sr.utcr0 = Ser2UTCR0;
+	sr.utcr1 = Ser2UTCR1;
+	sr.utcr2 = Ser2UTCR2;
+	sr.utcr3 = Ser2UTCR3;
+	sr.utcr4 = Ser2UTCR4;
 
-	sr.utdr=Ser2UTDR;
-	sr.utsr0=Ser2UTSR0;
-	sr.utsr1=Ser2UTSR1;
+	sr.utdr = Ser2UTDR;
+	sr.utsr0 = Ser2UTSR0;
+	sr.utsr1 = Ser2UTSR1;
 
 	/* configure GPIO */
 	/* output */
-	PPDR|=PPC_TXD2;
-	PSDR|=PPC_TXD2;
+	PPDR |= PPC_TXD2;
+	PSDR |= PPC_TXD2;
 	/* set output to 0 */
 	off();
-	
+
 	/*
 	 * Enable HP-SIR modulation, and ensure that the port is disabled.
 	 */
-	Ser2UTCR3=0;
-	Ser2HSCR0=sr.hscr0 & (~HSCR0_HSSP);
-	
+	Ser2UTCR3 = 0;
+	Ser2HSCR0 = sr.hscr0 & (~HSCR0_HSSP);
+
 	/* clear status register to prevent unwanted interrupts */
 	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
-	
+
 	/* 7N1 */
-	Ser2UTCR0=UTCR0_1StpBit|UTCR0_7BitData;
+	Ser2UTCR0 = UTCR0_1StpBit|UTCR0_7BitData;
 	/* 115200 */
-	Ser2UTCR1=0;
-	Ser2UTCR2=1;
+	Ser2UTCR1 = 0;
+	Ser2UTCR2 = 1;
 	/* use HPSIR, 1.6 usec pulses */
-	Ser2UTCR4=UTCR4_HPSIR|UTCR4_Z1_6us;
-	
+	Ser2UTCR4 = UTCR4_HPSIR|UTCR4_Z1_6us;
+
 	/* enable receiver, receive fifo interrupt */
-	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
-	
+	Ser2UTCR3 = UTCR3_RXE|UTCR3_RIE;
+
 	/* clear status register to prevent unwanted interrupts */
 	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
-	
+
 #elif defined(LIRC_SIR_TEKRAM)
-	/* disable FIFO */ 
+	/* disable FIFO */
 	soutp(UART_FCR,
 	      UART_FCR_CLEAR_RCVR|
 	      UART_FCR_CLEAR_XMIT|
 	      UART_FCR_TRIGGER_1);
-	
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	/* First of all, disable all interrupts */
-	soutp(UART_IER, sinp(UART_IER)&
+	soutp(UART_IER, sinp(UART_IER) &
 	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
-	
+
 	/* Set DLAB 1. */
 	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
-	
+
 	/* Set divisor to 12 => 9600 Baud */
-	soutp(UART_DLM,0);
-	soutp(UART_DLL,12);
-	
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 12);
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
-	
+
 	/* power supply */
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
 	safe_udelay(50*1000);
-	
+
 	/* -DTR low -> reset PIC */
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
 	udelay(1*1000);
-	
+
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
 	udelay(100);
 
 
-        /* -RTS low -> send control byte */
+	/* -RTS low -> send control byte */
 	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
 	udelay(7);
 	soutp(UART_TX, TEKRAM_115200|TEKRAM_PW);
-	
+
 	/* one byte takes ~1042 usec to transmit at 9600,8N1 */
 	udelay(1500);
-	
+
 	/* back to normal operation */
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
 	udelay(50);
 
 	udelay(1500);
-	
+
 	/* read previous control byte */
 	printk(KERN_INFO LIRC_DRIVER_NAME
-	       ": 0x%02x\n",sinp(UART_RX));
-	
+	       ": 0x%02x\n", sinp(UART_RX));
+
 	/* Set DLAB 1. */
 	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
-	
+
 	/* Set divisor to 1 => 115200 Baud */
-	soutp(UART_DLM,0);
-	soutp(UART_DLL,1);
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 1);
 
 	/* Set DLAB 0, 8 Bit */
 	soutp(UART_LCR, UART_LCR_WLEN8);
@@ -991,8 +968,8 @@ static int init_hardware(void)
 		/* FIFO operation */
 	outb(UART_FCR_ENABLE_FIFO, io + UART_FCR);
 		/* interrupts */
-	// outb(UART_IER_RLSI|UART_IER_RDI|UART_IER_THRI, io + UART_IER);
-	outb(UART_IER_RDI, io + UART_IER);	
+	/* outb(UART_IER_RLSI|UART_IER_RDI|UART_IER_THRI, io + UART_IER); */
+	outb(UART_IER_RDI, io + UART_IER);
 	/* turn on UART */
 	outb(UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2, io + UART_MCR);
 #ifdef LIRC_SIR_ACTISYS_ACT200L
@@ -1012,26 +989,25 @@ static void drop_hardware(void)
 	spin_lock_irqsave(&hardware_lock, flags);
 
 #ifdef LIRC_ON_SA1100
-	Ser2UTCR3=0;
-	
-	Ser2UTCR0=sr.utcr0;
-	Ser2UTCR1=sr.utcr1;
-	Ser2UTCR2=sr.utcr2;
-	Ser2UTCR4=sr.utcr4;
-	Ser2UTCR3=sr.utcr3;
-	
-	Ser2HSCR0=sr.hscr0;
+	Ser2UTCR3 = 0;
+
+	Ser2UTCR0 = sr.utcr0;
+	Ser2UTCR1 = sr.utcr1;
+	Ser2UTCR2 = sr.utcr2;
+	Ser2UTCR4 = sr.utcr4;
+	Ser2UTCR3 = sr.utcr3;
+
+	Ser2HSCR0 = sr.hscr0;
 #ifdef CONFIG_SA1100_BITSY
-	if (machine_is_bitsy()) {
+	if (machine_is_bitsy())
 		clr_bitsy_egpio(EGPIO_BITSY_IR_ON);
-	}
 #endif
 #ifdef CONFIG_SA1100_COLLIE
 	sa1100_irda_set_power_collie(0);	/* power off */
 #endif
 #else
 	/* turn off interrupts */
-	outb(0, io + UART_IER);	
+	outb(0, io + UART_IER);
 #endif
 	spin_unlock_irqrestore(&hardware_lock, flags);
 }
@@ -1041,17 +1017,16 @@ static void drop_hardware(void)
 static int init_port(void)
 {
 	int retval;
-	
+
 	/* get I/O port access and IRQ line */
 #ifndef LIRC_ON_SA1100
-	if(request_region(io, 8, LIRC_DRIVER_NAME) == NULL)
-	{
+	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {
 		printk(KERN_ERR LIRC_DRIVER_NAME
 		       ": i/o port 0x%.4x already in use.\n", io);
 		return -EBUSY;
 	}
 #endif
-	retval = request_irq(irq, sir_interrupt, SA_INTERRUPT,
+	retval = request_irq(irq, sir_interrupt, IRQF_DISABLED,
 			     LIRC_DRIVER_NAME, NULL);
 	if (retval < 0) {
 #               ifndef LIRC_ON_SA1100
@@ -1170,26 +1145,24 @@ static void init_act200(void)
 
 	/* Set DLAB 1. */
 	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);
-	
+
 	/* Set divisor to 12 => 9600 Baud */
-	soutp(UART_DLM,0);
-	soutp(UART_DLL,12);
-	
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 12);
+
 	/* Set DLAB 0. */
 	soutp(UART_LCR, UART_LCR_WLEN8);
 	/* Set divisor to 12 => 9600 Baud */
 
 	/* power supply */
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
-	for (i=0; i<50; i++) {
+	for (i = 0; i < 50; i++)
 		safe_udelay(1000);
-	}
 
 		/* Reset the dongle : set RTS low for 25 ms */
 	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
-	for (i=0; i<25; i++) {
+	for (i = 0; i < 25; i++)
 		udelay(1000);
-	}
 
 	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
 	udelay(100);
@@ -1199,7 +1172,7 @@ static void init_act200(void)
 	udelay(7);
 
 /* send out the control register settings for 115K 7N1 SIR operation */
-	for (i=0; i<sizeof(control); i++) {
+	for (i = 0; i < sizeof(control); i++) {
 		soutp(UART_TX, control[i]);
 		/* one byte takes ~1042 usec to transmit at 9600,8N1 */
 		udelay(1500);
@@ -1216,8 +1189,8 @@ static void init_act200(void)
 	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);
 
 	/* Set divisor to 1 => 115200 Baud */
-	soutp(UART_DLM,0);
-	soutp(UART_DLL,1);
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 1);
 
 	/* Set DLAB 0. */
 	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
@@ -1231,10 +1204,11 @@ static void init_act200(void)
 #endif
 
 #ifdef LIRC_SIR_ACTISYS_ACT220L
-/* Derived from linux IrDA driver (drivers/net/irda/actisys.c) 
+/* Derived from linux IrDA driver (drivers/net/irda/actisys.c)
  * Drop me a mail for any kind of comment: maxx@spaceboyz.net */
 
-void init_act220(void) {
+void init_act220(void)
+{
 	int i;
 
 	/* DLAB 1 */
@@ -1256,8 +1230,7 @@ void init_act220(void) {
 
 	/* send RTS pulses until we reach 115200
 	 * i hope this is really the same for act220l/act220l+ */
-	for(i = 0; i < 3; i++)
-	{
+	for (i = 0; i < 3; i++) {
 		udelay(10);
 		/* set RTS low for 10 us */
 		soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
@@ -1265,7 +1238,7 @@ void init_act220(void) {
 		/* set RTS high for 10 us */
 		soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
 	}
-	
+
 	/* back to normal operation */
 	udelay(1500); /* better safe than sorry ;) */
 
@@ -1273,8 +1246,8 @@ void init_act220(void) {
 	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);
 
 	/* Set divisor to 1 => 115200 Baud */
-	soutp(UART_DLM,0);
-	soutp(UART_DLL,1);
+	soutp(UART_DLM, 0);
+	soutp(UART_DLL, 1);
 
 	/* Set DLAB 0, 7 Bit */
 	/* The dongle doesn't seem to have any problems with operation
@@ -1305,9 +1278,9 @@ static int init_lirc_sir(void)
 int init_module(void)
 {
 	int retval;
-	
-	retval=init_chrdev();
-	if(retval < 0)
+
+	retval = init_chrdev();
+	if (retval < 0)
 		return retval;
 	retval = init_lirc_sir();
 	if (retval) {
diff --git a/drivers/char/lirc/lirc_streamzap.c b/drivers/char/lirc/lirc_streamzap.c
index 0c3cf2e..e70e060 100644
--- a/drivers/char/lirc/lirc_streamzap.c
+++ b/drivers/char/lirc/lirc_streamzap.c
@@ -1,10 +1,10 @@
-/*      $Id: lirc_streamzap.c,v 1.22 2007/04/29 14:23:04 lirc Exp $      */
+/*      $Id: lirc_streamzap.c,v 1.27 2008/01/13 11:13:50 lirc Exp $      */
 
 /*
  * Streamzap Remote Control driver
  *
  * Copyright (c) 2005 Christoph Bartelmus <lirc@bartelmus.de>
- * 
+ *
  * This driver was based on the work of Greg Wickham and Adrian
  * Dewhurst. It was substantially rewritten to support correct signal
  * gaps and now maintains a delay buffer, which is used to present
@@ -31,7 +31,7 @@
  *
  */
 
-#include	<linux/version.h>
+#include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
 #error "*******************************************************"
 #error "Sorry, this driver needs kernel version 2.4.0 or higher"
@@ -46,31 +46,35 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 #include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
 #include <linux/usb.h>
 
 #include <linux/lirc.h>
 #include "kcompat.h"
 #include "lirc_dev.h"
 
-#define DRIVER_VERSION	"$Revision: 1.22 $"
+#define DRIVER_VERSION	"$Revision: 1.27 $"
 #define DRIVER_NAME	"lirc_streamzap"
-#define DRIVER_DESC     "Streamzap Remote Control driver"
+#define DRIVER_DESC	"Streamzap Remote Control driver"
 
 /* ------------------------------------------------------------------ */
 
-static int debug = 0;
+static int debug;
 
 #define USB_STREAMZAP_VENDOR_ID		0x0e9c
 #define USB_STREAMZAP_PRODUCT_ID	0x0000
 
 /* Use our own dbg macro */
-#define dprintk(fmt, args...)                                   \
-	do{                                                     \
-		if(debug)                                       \
-	                printk(KERN_DEBUG DRIVER_NAME "[%d]: "  \
-                               fmt "\n", ## args);              \
-	}while(0)
+#define dprintk(fmt, args...)					\
+	do {							\
+		if (debug)					\
+			printk(KERN_DEBUG DRIVER_NAME "[%d]: "	\
+			       fmt "\n", ## args);		\
+	} while (0)
 
 /*
  * table of devices that work with this driver
@@ -80,17 +84,16 @@ static struct usb_device_id streamzap_table [] = {
 	{ }	/* Terminating entry */
 };
 
-MODULE_DEVICE_TABLE (usb, streamzap_table);
+MODULE_DEVICE_TABLE(usb, streamzap_table);
 
 #define STREAMZAP_PULSE_MASK 0xf0
 #define STREAMZAP_SPACE_MASK 0x0f
 #define STREAMZAP_RESOLUTION 256
 
 /* number of samples buffered */
-#define STREAMZAP_BUFFER_SIZE 64
+#define STREAMZAP_BUFFER_SIZE 128
 
-enum StreamzapDecoderState
-{
+enum StreamzapDecoderState {
 	PulseSpace,
 	FullPulse,
 	FullSpace,
@@ -100,18 +103,18 @@ enum StreamzapDecoderState
 /* Structure to hold all of our device specific stuff */
 /* some remarks regarding locking:
    theoretically this struct can be accessed from three threads:
-   
+
    - from lirc_dev through set_use_inc/set_use_dec
-   
+
    - from the USB layer throuh probe/disconnect/irq
-   
+
      Careful placement of lirc_register_plugin/lirc_unregister_plugin
      calls will prevent conflicts. lirc_dev makes sure that
      set_use_inc/set_use_dec are not being executed and will not be
      called after lirc_unregister_plugin returns.
 
    - by the timer callback
-   
+
      The timer is only running when the device is connected and the
      LIRC device is open. Making sure the timer is deleted by
      set_use_dec will make conflicts impossible.
@@ -120,12 +123,12 @@ struct usb_streamzap {
 
 	/* usb */
 	/* save off the usb device pointer */
-	struct usb_device *	udev;
+	struct usb_device	*udev;
 	/* the interface for this device */
-	struct usb_interface *	interface;
+	struct usb_interface	*interface;
 
 	/* buffer & dma */
-	unsigned char *		buf_in;
+	unsigned char		*buf_in;
 	dma_addr_t		dma_in;
 	unsigned int		buf_in_len;
 
@@ -135,26 +138,26 @@ struct usb_streamzap {
 	struct urb		*urb_in;
 
 	/* lirc */
-	struct lirc_plugin	plugin;	
-	struct lirc_buffer      delay_buf;
-	struct lirc_buffer      lirc_buf;
-	
+	struct lirc_plugin	plugin;
+	struct lirc_buffer	delay_buf;
+	struct lirc_buffer	lirc_buf;
+
 	/* timer used to support delay buffering */
 	struct timer_list	delay_timer;
-	int                     timer_running;
-	spinlock_t              timer_lock;
-	
+	int			timer_running;
+	spinlock_t		timer_lock;
+
 	/* tracks whether we are currently receiving some signal */
-	int                     idle;
+	int			idle;
 	/* sum of signal lengths received since signal start */
-	unsigned long           sum;
+	unsigned long		sum;
 	/* start time of signal; necessary for gap tracking */
-	struct timeval          signal_last;
-	struct timeval          signal_start;
+	struct timeval		signal_last;
+	struct timeval		signal_start;
 	enum StreamzapDecoderState decoder_state;
 	struct timer_list	flush_timer;
-	int                     flush;
-	int                     in_use;
+	int			flush;
+	int			in_use;
 };
 
 
@@ -174,8 +177,8 @@ static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
 static void streamzap_disconnect(struct usb_device *dev, void *ptr);
 static void usb_streamzap_irq(struct urb *urb);
 #endif
-static int streamzap_use_inc( void *data );
-static void streamzap_use_dec( void *data );
+static int streamzap_use_inc(void *data);
+static void streamzap_use_dec(void *data);
 static int streamzap_ioctl(struct inode *node, struct file *filep,
 			   unsigned int cmd, unsigned long arg);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
@@ -200,10 +203,9 @@ static struct usb_driver streamzap_driver = {
 static void stop_timer(struct usb_streamzap *sz)
 {
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&sz->timer_lock, flags);
-	if(sz->timer_running)
-	{
+	if (sz->timer_running) {
 		sz->timer_running = 0;
 		del_timer_sync(&sz->delay_timer);
 	}
@@ -213,7 +215,7 @@ static void stop_timer(struct usb_streamzap *sz)
 static void flush_timeout(unsigned long arg)
 {
 	struct usb_streamzap *sz = (struct usb_streamzap *) arg;
-	
+
 	/* finally start accepting data */
 	sz->flush = 0;
 }
@@ -221,41 +223,38 @@ static void delay_timeout(unsigned long arg)
 {
 	unsigned long flags;
 	/* deliver data every 10 ms */
-	static unsigned long timer_inc = 
+	static unsigned long timer_inc =
 		(10000/(1000000/HZ)) == 0 ? 1:(10000/(1000000/HZ));
 	struct usb_streamzap *sz = (struct usb_streamzap *) arg;
 	lirc_t data;
-	
+
 	spin_lock_irqsave(&sz->timer_lock, flags);
-	if(!lirc_buffer_empty(&sz->delay_buf))
-	{
-		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
+
+	if (!lirc_buffer_empty(&sz->delay_buf) &&
+	    !lirc_buffer_full(&sz->lirc_buf)) {
+		lirc_buffer_read_1(&sz->delay_buf, (unsigned char *) &data);
 		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
 	}
-	if(!lirc_buffer_empty(&sz->delay_buf))
-	{
-		while(lirc_buffer_available(&sz->delay_buf) < 
-		      STREAMZAP_BUFFER_SIZE/2)
-		{
-			lirc_buffer_read_1( &sz->delay_buf,
-					    (unsigned char *) &data);
+	if (!lirc_buffer_empty(&sz->delay_buf)) {
+		while (lirc_buffer_available(&sz->delay_buf) <
+		      STREAMZAP_BUFFER_SIZE/2 &&
+		      !lirc_buffer_full(&sz->lirc_buf)) {
+			lirc_buffer_read_1(&sz->delay_buf,
+					   (unsigned char *) &data);
 			lirc_buffer_write_1(&sz->lirc_buf,
 					    (unsigned char *) &data);
 		}
-		if(sz->timer_running)
-		{
+		if (sz->timer_running) {
 			sz->delay_timer.expires += timer_inc;
 			add_timer(&sz->delay_timer);
 		}
-	}
-	else
-	{
+	} else {
 		sz->timer_running = 0;
 	}
-	if(!lirc_buffer_empty(&sz->lirc_buf))
-	{
+
+	if (!lirc_buffer_empty(&sz->lirc_buf))
 		wake_up(&sz->lirc_buf.wait_poll);
-	}
+
 	spin_unlock_irqrestore(&sz->timer_lock, flags);
 }
 
@@ -263,35 +262,41 @@ static inline void flush_delay_buffer(struct usb_streamzap *sz)
 {
 	lirc_t data;
 	int empty = 1;
-	
-	while(!lirc_buffer_empty(&sz->delay_buf))
-	{
+
+	while (!lirc_buffer_empty(&sz->delay_buf)) {
 		empty = 0;
-		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
-		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
+		lirc_buffer_read_1(&sz->delay_buf, (unsigned char *) &data);
+		if (!lirc_buffer_full(&sz->lirc_buf)) {
+			lirc_buffer_write_1(&sz->lirc_buf,
+					    (unsigned char *) &data);
+		} else {
+			dprintk("buffer overflow\n", sz->plugin.minor);
+		}
 	}
-	if(!empty) wake_up( &sz->lirc_buf.wait_poll );
+	if (!empty)
+		wake_up(&sz->lirc_buf.wait_poll);
 }
 
 static inline void push(struct usb_streamzap *sz, unsigned char *data)
 {
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&sz->timer_lock, flags);
-	if(lirc_buffer_full(&sz->delay_buf))
-	{
+	if (lirc_buffer_full(&sz->delay_buf)) {
 		lirc_t data;
-		
-		lirc_buffer_read_1( &sz->delay_buf, (unsigned char *) &data);
-		lirc_buffer_write_1(&sz->lirc_buf, (unsigned char *) &data);
-		
-		dprintk("buffer overflow", sz->plugin.minor);
+
+		lirc_buffer_read_1(&sz->delay_buf, (unsigned char *) &data);
+		if (!lirc_buffer_full(&sz->lirc_buf)) {
+			lirc_buffer_write_1(&sz->lirc_buf,
+					    (unsigned char *) &data);
+		} else {
+			dprintk("buffer overflow", sz->plugin.minor);
+		}
 	}
-	
+
 	lirc_buffer_write_1(&sz->delay_buf, data);
-	
-	if(!sz->timer_running)
-	{
+
+	if (!sz->timer_running) {
 		sz->delay_timer.expires = jiffies + HZ/10;
 		add_timer(&sz->delay_timer);
 		sz->timer_running = 1;
@@ -304,39 +309,35 @@ static inline void push_full_pulse(struct usb_streamzap *sz,
 				   unsigned char value)
 {
 	lirc_t pulse;
-	
-	if(sz->idle)
-	{
+
+	if (sz->idle) {
 		long deltv;
 		lirc_t tmp;
-			
+
 		sz->signal_last = sz->signal_start;
 		do_gettimeofday(&sz->signal_start);
-		
-		deltv=sz->signal_start.tv_sec-sz->signal_last.tv_sec;
-		if(deltv>15) 
-		{
-			tmp=PULSE_MASK; /* really long time */
-		}
-		else
-		{
-			tmp=(lirc_t) (deltv*1000000+
-				      sz->signal_start.tv_usec-
-				      sz->signal_last.tv_usec);
-			tmp-=sz->sum;
+
+		deltv = sz->signal_start.tv_sec-sz->signal_last.tv_sec;
+		if (deltv > 15) {
+			tmp = PULSE_MASK; /* really long time */
+		} else {
+			tmp = (lirc_t) (deltv*1000000+
+					sz->signal_start.tv_usec -
+					sz->signal_last.tv_usec);
+			tmp -= sz->sum;
 		}
 		dprintk("ls %u", sz->plugin.minor, tmp);
 		push(sz, (char *)&tmp);
-		
+
 		sz->idle = 0;
 		sz->sum = 0;
 	}
-	
+
 	pulse = ((lirc_t) value)*STREAMZAP_RESOLUTION;
 	pulse += STREAMZAP_RESOLUTION/2;
 	sz->sum += pulse;
 	pulse |= PULSE_BIT;
-	
+
 	dprintk("p %u", sz->plugin.minor, pulse&PULSE_MASK);
 	push(sz, (char *)&pulse);
 }
@@ -351,7 +352,7 @@ static inline void push_full_space(struct usb_streamzap *sz,
 				   unsigned char value)
 {
 	lirc_t space;
-	
+
 	space = ((lirc_t) value)*STREAMZAP_RESOLUTION;
 	space += STREAMZAP_RESOLUTION/2;
 	sz->sum += space;
@@ -372,23 +373,22 @@ static inline void push_half_space(struct usb_streamzap *sz,
  * the usb remote.
  */
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void usb_streamzap_irq(struct urb *urb, struct pt_regs *regs) 
+static void usb_streamzap_irq(struct urb *urb, struct pt_regs *regs)
 #else
-static void usb_streamzap_irq(struct urb *urb) 
+static void usb_streamzap_irq(struct urb *urb)
 #endif
 {
 	struct usb_streamzap *sz;
 	int		len;
 	unsigned int	i = 0;
 
-	if ( ! urb )
+	if (!urb)
 		return;
 
 	sz = urb->context;
 	len = urb->actual_length;
 
-	switch (urb->status)
-	{
+	switch (urb->status) {
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
@@ -401,68 +401,55 @@ static void usb_streamzap_irq(struct urb *urb)
 	}
 
 	dprintk("received %d", sz->plugin.minor, urb->actual_length);
-	if(!sz->flush) for (i=0; i < urb->actual_length; i++)
-	{
-		dprintk("%d: %x", sz->plugin.minor,
-			i, (unsigned char) sz->buf_in[i]);
-		switch(sz->decoder_state)
-		{
-		case PulseSpace:
-			if( (sz->buf_in[i]&STREAMZAP_PULSE_MASK) ==
-			    STREAMZAP_PULSE_MASK)
-			{
-				sz->decoder_state = FullPulse;
-				continue;
-			}
-			else if( (sz->buf_in[i]&STREAMZAP_SPACE_MASK) ==
-				 STREAMZAP_SPACE_MASK)
-			{
-				push_half_pulse(sz, sz->buf_in[i]);
-				sz->decoder_state = FullSpace;
-				continue;
-			}
-			else
-			{
-				push_half_pulse(sz, sz->buf_in[i]);
+	if (!sz->flush) {
+		for (i = 0; i < urb->actual_length; i++) {
+			dprintk("%d: %x", sz->plugin.minor,
+				i, (unsigned char) sz->buf_in[i]);
+			switch (sz->decoder_state) {
+			case PulseSpace:
+				if ((sz->buf_in[i]&STREAMZAP_PULSE_MASK) ==
+				    STREAMZAP_PULSE_MASK) {
+					sz->decoder_state = FullPulse;
+					continue;
+				} else if ((sz->buf_in[i]&STREAMZAP_SPACE_MASK)
+					   == STREAMZAP_SPACE_MASK) {
+					push_half_pulse(sz, sz->buf_in[i]);
+					sz->decoder_state = FullSpace;
+					continue;
+				} else {
+					push_half_pulse(sz, sz->buf_in[i]);
+					push_half_space(sz, sz->buf_in[i]);
+				}
+				break;
+			case FullPulse:
+				push_full_pulse(sz, sz->buf_in[i]);
+				sz->decoder_state = IgnorePulse;
+				break;
+			case FullSpace:
+				if (sz->buf_in[i] == 0xff) {
+					sz->idle = 1;
+					stop_timer(sz);
+					flush_delay_buffer(sz);
+				} else
+					push_full_space(sz, sz->buf_in[i]);
+				sz->decoder_state = PulseSpace;
+				break;
+			case IgnorePulse:
+				if ((sz->buf_in[i]&STREAMZAP_SPACE_MASK) ==
+				    STREAMZAP_SPACE_MASK) {
+					sz->decoder_state = FullSpace;
+					continue;
+				}
 				push_half_space(sz, sz->buf_in[i]);
+				sz->decoder_state = PulseSpace;
+				break;
 			}
-			break;
-		
-		case FullPulse:
-			push_full_pulse(sz, sz->buf_in[i]);
-			sz->decoder_state = IgnorePulse;
-			break;
-		
-		case FullSpace:
-			if(sz->buf_in[i] == 0xff)
-			{
-				sz->idle=1;
-				stop_timer(sz);
-				flush_delay_buffer(sz);
-			}
-			else
-			{
-				push_full_space(sz, sz->buf_in[i]);
-			}
-			sz->decoder_state = PulseSpace;
-			break;
-		
-		case IgnorePulse:
-			if( (sz->buf_in[i]&STREAMZAP_SPACE_MASK) == 
-			    STREAMZAP_SPACE_MASK)
-			{
-				sz->decoder_state = FullSpace;
-				continue;
-			}
-			push_half_space(sz, sz->buf_in[i]);
-			sz->decoder_state = PulseSpace;
-			break;
 		}
 	}
 
 #ifdef KERNEL_2_5
 	/* resubmit only for 2.6 */
-	usb_submit_urb( urb, GFP_ATOMIC );
+	usb_submit_urb(urb, GFP_ATOMIC);
 #endif
 
 	return;
@@ -476,7 +463,8 @@ static void usb_streamzap_irq(struct urb *urb)
  *	On success return 0
  */
 #ifdef KERNEL_2_5
-static int streamzap_probe( struct usb_interface *interface, const struct usb_device_id *id )
+static int streamzap_probe(struct usb_interface *interface,
+			   const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(interface);
 	struct usb_host_interface *iface_host;
@@ -494,101 +482,99 @@ static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
 	/***************************************************
 	 * Allocate space for device driver specific data
 	 */
-	if (( sz = kmalloc (sizeof(struct usb_streamzap), GFP_KERNEL)) == NULL )
+	sz = kmalloc(sizeof(struct usb_streamzap), GFP_KERNEL);
+	if (sz == NULL)
 		goto error;
 
 	memset(sz, 0, sizeof(*sz));
-        sz->udev = udev;
-        sz->interface = interface;
-	
+	sz->udev = udev;
+	sz->interface = interface;
+
 	/***************************************************
 	 * Check to ensure endpoint information matches requirements
 	 */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
-	iface_host = interface->cur_altsetting;
-#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
 	iface_host = &interface->altsetting[interface->act_altsetting];
+#else
+	iface_host = interface->cur_altsetting;
 #endif
 
 #ifdef KERNEL_2_5
-        if (iface_host->desc.bNumEndpoints != 1) {
+	if (iface_host->desc.bNumEndpoints != 1) {
 #else
-	if(iface_host->bNumEndpoints != 1) {
+	if (iface_host->bNumEndpoints != 1) {
 #endif
 #ifdef KERNEL_2_5
-                err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
+		err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
 		    iface_host->desc.bNumEndpoints);
 #else
-                err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
+		err("%s: Unexpected desc.bNumEndpoints (%d)", __FUNCTION__,
 		    iface_host->bNumEndpoints);
 #endif
 		retval = -ENODEV;
-                goto error;
-        }
+		goto error;
+	}
 
 #ifdef KERNEL_2_5
 	sz->endpoint = &(iface_host->endpoint[0].desc);
 #else
 	sz->endpoint = &(iface_host->endpoint[0]);
 #endif
-        if (( sz->endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+	if ((sz->endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
 	    != USB_DIR_IN) {
-                err("%s: endpoint doesn't match input device 02%02x",
-		    __FUNCTION__, sz->endpoint->bEndpointAddress );
-                retval = -ENODEV;
-                goto error;
-        }
+		err("%s: endpoint doesn't match input device 02%02x",
+		    __FUNCTION__, sz->endpoint->bEndpointAddress);
+		retval = -ENODEV;
+		goto error;
+	}
 
-        if (( sz->endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+	if ((sz->endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
 	    != USB_ENDPOINT_XFER_INT) {
-                err("%s: endpoint attributes don't match xfer 02%02x",
-		    __FUNCTION__, sz->endpoint->bmAttributes );
-                retval = -ENODEV;
-                goto error;
-        }
-
-        if ( sz->endpoint->wMaxPacketSize == 0 ) {
-                err("%s: endpoint message size==0? ", __FUNCTION__);
-                retval = -ENODEV;
-                goto error;
-        }
+		err("%s: endpoint attributes don't match xfer 02%02x",
+		    __FUNCTION__, sz->endpoint->bmAttributes);
+		retval = -ENODEV;
+		goto error;
+	}
+
+	if (sz->endpoint->wMaxPacketSize == 0) {
+		err("%s: endpoint message size==0? ", __FUNCTION__);
+		retval = -ENODEV;
+		goto error;
+	}
 
 	/***************************************************
-	 * Allocate the USB buffer and IRQ URB 
+	 * Allocate the USB buffer and IRQ URB
 	 */
 
 	sz->buf_in_len = sz->endpoint->wMaxPacketSize;
 #ifdef KERNEL_2_5
-        if((sz->buf_in = usb_buffer_alloc(sz->udev, sz->buf_in_len,
-					  GFP_ATOMIC, &sz->dma_in)) == NULL )
-	{
-                goto error;
-	}
-	if (!( sz->urb_in = usb_alloc_urb(0, GFP_KERNEL)))
-		goto error;
+	sz->buf_in = usb_buffer_alloc(sz->udev, sz->buf_in_len,
+				      GFP_ATOMIC, &sz->dma_in);
 #else
-	if( (sz->buf_in = kmalloc(sz->buf_in_len, GFP_KERNEL))
-	    == NULL)
-	{
-		goto error;
-	}
-	if( (sz->urb_in = usb_alloc_urb(0)) == NULL)
-	{
+	sz->buf_in = kmalloc(sz->buf_in_len, GFP_KERNEL);
+#endif
+	if (sz->buf_in == NULL)
 		goto error;
-	}
+
+#ifdef KERNEL_2_5
+	sz->urb_in = usb_alloc_urb(0, GFP_KERNEL);
+#else
+
+	sz->urb_in = usb_alloc_urb(0);
 #endif
+	if (sz->urb_in == NULL)
+		goto error;
+
 	/***************************************************
 	 * Connect this device to the LIRC sub-system
 	 */
 
-	if(lirc_buffer_init(&sz->lirc_buf, sizeof(lirc_t),
-			    STREAMZAP_BUFFER_SIZE))
-	{
+	if (lirc_buffer_init(&sz->lirc_buf, sizeof(lirc_t),
+			     STREAMZAP_BUFFER_SIZE))
 		goto error;
-	}
-	if(lirc_buffer_init(&sz->delay_buf, sizeof(lirc_t),
-			    STREAMZAP_BUFFER_SIZE))
-	{
+
+	if (lirc_buffer_init(&sz->delay_buf, sizeof(lirc_t),
+			     STREAMZAP_BUFFER_SIZE)) {
 		lirc_buffer_free(&sz->lirc_buf);
 		goto error;
 	}
@@ -603,7 +589,7 @@ static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
 	sz->plugin.minor = -1;
 	sz->plugin.sample_rate = 0;
 	sz->plugin.code_length = sizeof(lirc_t) * 8;
-	sz->plugin.features = LIRC_CAN_REC_MODE2;
+	sz->plugin.features = LIRC_CAN_REC_MODE2|LIRC_CAN_GET_REC_RESOLUTION;
 	sz->plugin.data = sz;
 	sz->plugin.rbuf = &sz->lirc_buf;
 	sz->plugin.set_use_inc = &streamzap_use_inc;
@@ -630,28 +616,27 @@ static void *streamzap_probe(struct usb_device *udev, unsigned int ifnum,
 	 */
 
 	usb_fill_int_urb(sz->urb_in, udev,
-		usb_rcvintpipe( udev, sz->endpoint->bEndpointAddress ),
+		usb_rcvintpipe(udev, sz->endpoint->bEndpointAddress),
 		sz->buf_in, sz->buf_in_len, usb_streamzap_irq, sz,
 		sz->endpoint->bInterval);
 
-        if ( udev->descriptor.iManufacturer
-                && usb_string( udev,  udev->descriptor.iManufacturer, buf, 63) > 0)
-                strncpy(name, buf, 128);
+	if (udev->descriptor.iManufacturer
+	    && usb_string(udev, udev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
 
-        if ( udev->descriptor.iProduct
-                && usb_string( udev,  udev->descriptor.iProduct, buf, 63) > 0)
-                snprintf(name, 128, "%s %s", name, buf);
+	if (udev->descriptor.iProduct
+	    && usb_string(udev,  udev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
 
-        printk(KERN_INFO DRIVER_NAME "[%d]: %s on usb%d:%d attached\n",
+	printk(KERN_INFO DRIVER_NAME "[%d]: %s on usb%d:%d attached\n",
 	       sz->plugin.minor, name,
 	       udev->bus->busnum, sz->udev->devnum);
 
 #ifdef KERNEL_2_5
-	usb_set_intfdata( interface , sz );
+	usb_set_intfdata(interface, sz);
 #endif
 
-	if(lirc_register_plugin(&sz->plugin) < 0)
-	{
+	if (lirc_register_plugin(&sz->plugin) < 0) {
 		lirc_buffer_free(&sz->delay_buf);
 		lirc_buffer_free(&sz->lirc_buf);
 		goto error;
@@ -671,16 +656,15 @@ error:
 	 * including freeing any necessary memory blocks
 	 */
 
-	if ( retval == -ENOMEM )
-		err ("Out of memory");
+	if (retval == -ENOMEM)
+		err("Out of memory");
 
-	if ( sz ) {
+	if (sz) {
 
-		if ( sz->urb_in )
-			usb_free_urb( sz->urb_in );
+		if (sz->urb_in)
+			usb_free_urb(sz->urb_in);
 
-		if ( sz->buf_in )
-		{
+		if (sz->buf_in) {
 #ifdef KERNEL_2_5
 			usb_buffer_free(udev, sz->buf_in_len,
 					sz->buf_in, sz->dma_in);
@@ -688,7 +672,7 @@ error:
 			kfree(sz->buf_in);
 #endif
 		}
-		kfree( sz );
+		kfree(sz);
 	}
 
 #ifdef KERNEL_2_5
@@ -702,80 +686,77 @@ static int streamzap_use_inc(void *data)
 {
 	struct usb_streamzap *sz = data;
 
-	if(!sz)
-	{
+	if (!sz) {
 		dprintk("%s called with no context", -1, __FUNCTION__);
 		return -EINVAL;
 	}
 	dprintk("set use inc", sz->plugin.minor);
 
 	MOD_INC_USE_COUNT;
-	
-	while(!lirc_buffer_empty(&sz->lirc_buf))
+
+	while (!lirc_buffer_empty(&sz->lirc_buf))
 		lirc_buffer_remove_1(&sz->lirc_buf);
-	while(!lirc_buffer_empty(&sz->delay_buf))
+	while (!lirc_buffer_empty(&sz->delay_buf))
 		lirc_buffer_remove_1(&sz->delay_buf);
-		
+
 	sz->flush_timer.expires = jiffies + HZ;
 	sz->flush = 1;
 	add_timer(&sz->flush_timer);
 
 	sz->urb_in->dev = sz->udev;
 #ifdef KERNEL_2_5
-	if (usb_submit_urb(sz->urb_in, GFP_ATOMIC))
+	if (usb_submit_urb(sz->urb_in, GFP_ATOMIC)) {
 #else
-	if (usb_submit_urb(sz->urb_in))
+	if (usb_submit_urb(sz->urb_in)) {
 #endif
-	{
 		dprintk("open result = -EIO error submitting urb",
 			sz->plugin.minor);
 		MOD_DEC_USE_COUNT;
 		return -EIO;
 	}
 	sz->in_use++;
-	
+
 	return 0;
 }
 
 static void streamzap_use_dec(void *data)
 {
-        struct usb_streamzap *sz = data;
-
-        if (!sz) {
-                dprintk("%s called with no context", -1, __FUNCTION__);
-                return;
-        }
-        dprintk("set use dec", sz->plugin.minor);
-	
-	if(sz->flush)
-	{
+	struct usb_streamzap *sz = data;
+
+	if (!sz) {
+		dprintk("%s called with no context", -1, __FUNCTION__);
+		return;
+	}
+	dprintk("set use dec", sz->plugin.minor);
+
+	if (sz->flush) {
 		sz->flush = 0;
 		del_timer_sync(&sz->flush_timer);
 	}
-	
+
 	stop_timer(sz);
-	
+
 	usb_kill_urb(sz->urb_in);
-	
-        MOD_DEC_USE_COUNT;
+
+	MOD_DEC_USE_COUNT;
 	sz->in_use--;
 }
 
 static int streamzap_ioctl(struct inode *node, struct file *filep,
 			   unsigned int cmd, unsigned long arg)
 {
-        int result;
-	
-	switch(cmd)
-	{
+	int result;
+
+	switch (cmd) {
 	case LIRC_GET_REC_RESOLUTION:
-		result=put_user(STREAMZAP_RESOLUTION, (unsigned long *) arg);
-		if(result) return(result); 
+		result = put_user(STREAMZAP_RESOLUTION, (unsigned long *) arg);
+		if (result)
+			return(result);
 		break;
 	default:
-		return(-ENOIOCTLCMD);
+		return -ENOIOCTLCMD;
 	}
-	return(0);
+	return 0;
 }
 
 /**
@@ -785,11 +766,11 @@ static int streamzap_ioctl(struct inode *node, struct file *filep,
  *
  *	This routine guarantees that the driver will not submit any more urbs
  *	by clearing dev->udev.  It is also supposed to terminate any currently
- *	active urbs.  Unfortunately, usb_bulk_msg(), used in streamzap_read(), does
- *	not provide any way to do this.
+ *	active urbs.  Unfortunately, usb_bulk_msg(), used in streamzap_read(),
+ *	does not provide any way to do this.
  */
 #ifdef KERNEL_2_5
-static void streamzap_disconnect( struct usb_interface *interface )
+static void streamzap_disconnect(struct usb_interface *interface)
 #else
 static void streamzap_disconnect(struct usb_device *dev, void *ptr)
 #endif
@@ -799,7 +780,7 @@ static void streamzap_disconnect(struct usb_device *dev, void *ptr)
 	int minor;
 
 #ifdef KERNEL_2_5
-	sz = usb_get_intfdata( interface );
+	sz = usb_get_intfdata(interface);
 #else
 	sz = ptr;
 #endif
@@ -808,11 +789,10 @@ static void streamzap_disconnect(struct usb_device *dev, void *ptr)
 	 * unregister from the LIRC sub-system
 	 */
 
-        if (( errnum = lirc_unregister_plugin( sz->plugin.minor )) != 0) {
-
-                dprintk("error in lirc_unregister: (returned %d)",
-			sz->plugin.minor, errnum );
-        }
+	errnum = lirc_unregister_plugin(sz->plugin.minor);
+	if (errnum != 0)
+		dprintk("error in lirc_unregister: (returned %d)",
+			sz->plugin.minor, errnum);
 
 	lirc_buffer_free(&sz->delay_buf);
 	lirc_buffer_free(&sz->lirc_buf);
@@ -821,36 +801,34 @@ static void streamzap_disconnect(struct usb_device *dev, void *ptr)
 	 * unregister from the USB sub-system
 	 */
 
-	usb_free_urb( sz->urb_in );
+	usb_free_urb(sz->urb_in);
 
 #ifdef KERNEL_2_5
-        usb_buffer_free( sz->udev , sz->buf_in_len, sz->buf_in, sz->dma_in );
+	usb_buffer_free(sz->udev, sz->buf_in_len, sz->buf_in, sz->dma_in);
 #else
 	kfree(sz->buf_in);
 #endif
 
 	minor = sz->plugin.minor;
-	kfree( sz );
+	kfree(sz);
 
-        printk(KERN_INFO DRIVER_NAME "[%d]: disconnected\n", minor);
+	printk(KERN_INFO DRIVER_NAME "[%d]: disconnected\n", minor);
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 static int streamzap_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct usb_streamzap *sz = usb_get_intfdata(intf);
-	
+
 	printk(DRIVER_NAME "[%d]: suspend\n", sz->plugin.minor);
-	if(sz->in_use)
-	{
-		if(sz->flush)
-		{
+	if (sz->in_use) {
+		if (sz->flush) {
 			sz->flush = 0;
 			del_timer_sync(&sz->flush_timer);
 		}
-		
+
 		stop_timer(sz);
-		
+
 		usb_kill_urb(sz->urb_in);
 	}
 	return 0;
@@ -859,25 +837,23 @@ static int streamzap_suspend(struct usb_interface *intf, pm_message_t message)
 static int streamzap_resume(struct usb_interface *intf)
 {
 	struct usb_streamzap *sz = usb_get_intfdata(intf);
-	
-	while(!lirc_buffer_empty(&sz->lirc_buf))
+
+	while (!lirc_buffer_empty(&sz->lirc_buf))
 		lirc_buffer_remove_1(&sz->lirc_buf);
-	while(!lirc_buffer_empty(&sz->delay_buf))
+	while (!lirc_buffer_empty(&sz->delay_buf))
 		lirc_buffer_remove_1(&sz->delay_buf);
-		
-	if(sz->in_use)
-	{
+
+	if (sz->in_use) {
 		sz->flush_timer.expires = jiffies + HZ;
 		sz->flush = 1;
 		add_timer(&sz->flush_timer);
 
 		sz->urb_in->dev = sz->udev;
 #ifdef KERNEL_2_5
-		if (usb_submit_urb(sz->urb_in, GFP_ATOMIC))
+		if (usb_submit_urb(sz->urb_in, GFP_ATOMIC)) {
 #else
-		if (usb_submit_urb(sz->urb_in))
+		if (usb_submit_urb(sz->urb_in)) {
 #endif
-		{
 			dprintk("open result = -EIO error submitting urb",
 				sz->plugin.minor);
 			MOD_DEC_USE_COUNT;
@@ -899,7 +875,7 @@ static int __init usb_streamzap_init(void)
 
 	/* register this driver with the USB subsystem */
 
-	result = usb_register( &streamzap_driver );
+	result = usb_register(&streamzap_driver);
 
 	if (result) {
 		err("usb_register failed. Error number %d",
@@ -921,8 +897,8 @@ static void __exit usb_streamzap_exit(void)
 }
 
 
-module_init (usb_streamzap_init);
-module_exit (usb_streamzap_exit);
+module_init(usb_streamzap_init);
+module_exit(usb_streamzap_exit);
 
 MODULE_AUTHOR("Christoph Bartelmus, Greg Wickham, Adrian Dewhurst");
 MODULE_DESCRIPTION(DRIVER_DESC);
diff --git a/drivers/char/lirc/lirc_ttusbir.c b/drivers/char/lirc/lirc_ttusbir.c
index d7428ac..d01b75b 100644
--- a/drivers/char/lirc/lirc_ttusbir.c
+++ b/drivers/char/lirc/lirc_ttusbir.c
@@ -21,6 +21,17 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  */
+
+/* This LIRC driver provides access to the TechnoTrend USB IR Receiver.
+ * The receiver delivers the IR signal as raw sampled true/false data in
+ * isochronous USB packets each of size 128 byte.
+ * Currently the driver reduces the sampling rate by factor of 8 as this
+ * is still more than enough to decode RC-5 - others should be analyzed.
+ * But the driver does not rely on RC-5 it should be able to decode every
+ * IR signal that is not too fast.
+ */
+
+#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -36,10 +47,7 @@ MODULE_DESCRIPTION("TechnoTrend USB IR device driver for LIRC");
 MODULE_AUTHOR("Stefan Macher (st_maker-lirc@yahoo.de)");
 MODULE_LICENSE("GPL");
 
-/* @TODO Is it enough to have only two, I guess yes */
-#define NUM_URBS 4 /* Number of URBs used in the queue */
-
-//#define DEBUG
+/* #define DEBUG */
 #ifdef DEBUG
 #define DPRINTK printk
 #else
@@ -50,19 +58,25 @@ MODULE_LICENSE("GPL");
 static int probe(struct usb_interface *intf, const struct usb_device_id *id);
 static void disconnect(struct usb_interface *intf);
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void urb_complete(struct urb* urb, struct pt_regs* pt_regs);
+static void urb_complete(struct urb *urb, struct pt_regs *pt_regs);
 #else
-static void urb_complete(struct urb* urb);
+static void urb_complete(struct urb *urb);
 #endif
-static int set_use_inc(void* data);
-static void set_use_dec(void* data);
+static int set_use_inc(void *data);
+static void set_use_dec(void *data);
+
+static int num_urbs = 2;
+module_param(num_urbs, int, 0444);
+MODULE_PARM_DESC(num_urbs,
+		 "Number of URBs in queue. Try to increase to 4 in case "
+		 "of problems (default: 2; minimum: 2)");
 
 /* table of devices that work with this driver */
-static struct usb_device_id device_id_table [ ] = {
+static struct usb_device_id device_id_table[] = {
     { USB_DEVICE(0x0B48, 0x2003) },
     { } /* Terminating entry */
 };
-MODULE_DEVICE_TABLE (usb, device_id_table);
+MODULE_DEVICE_TABLE(usb, device_id_table);
 
 /* USB driver definition */
 static struct usb_driver driver = {
@@ -73,21 +87,20 @@ static struct usb_driver driver = {
 };
 
 /* USB device definition */
-struct ttusbir_device
-{
-	struct usb_driver* driver;
-	struct usb_device* udev;
-	struct usb_interface* interf;
+struct ttusbir_device {
+	struct usb_driver *driver;
+	struct usb_device *udev;
+	struct usb_interface *interf;
 	struct usb_class_driver class_driver;
 	unsigned int ifnum; /* Interface number to use */
 	unsigned int alt_setting; /* alternate setting to use */
 	unsigned int endpoint; /* Endpoint to use */
-	struct urb *urb[NUM_URBS];
-	char buffer[NUM_URBS][128];
+	struct urb **urb; /* num_urb URB pointers*/
+	char **buffer; /* 128 byte buffer for each URB */
 	struct lirc_buffer rbuf; /* Buffer towards LIRC */
 	struct lirc_plugin plugin;
 	int minor;
-	int last_pulse; /* remembers if last received byte was a pulse or a space */
+	int last_pulse; /* remembers if last received byte was pulse or space */
 	int last_num; /* remembers how many last bytes appeared */
 	int opened;
 };
@@ -95,22 +108,22 @@ struct ttusbir_device
 /*************************************
  * LIRC specific functions
  */
-static int set_use_inc(void* data)
+static int set_use_inc(void *data)
 {
 	int i;
 	struct ttusbir_device *ttusbir = data;
 
 	DPRINTK("Sending first URBs\n");
-
+	/* @TODO Do I need to check if I am already opened */
 	ttusbir->opened = 1;
 
-	for(i = 0; i < NUM_URBS; i++)
+	for (i = 0; i < num_urbs; i++)
 		usb_submit_urb(ttusbir->urb[i], GFP_KERNEL);
 
 	return 0;
 }
 
-static void set_use_dec(void* data)
+static void set_use_dec(void *data)
 {
 	struct ttusbir_device *ttusbir = data;
 
@@ -123,35 +136,52 @@ static void set_use_dec(void* data)
  * USB specific functions
  */
 
-/* This mapping table is used to do a very simple filtering of the input signal
- * For a value with at least 4 bits set it returns 0xFF otherwise 0x00.
- * For faster IR signals this can not be used. But for RC-5 we still have
- * about 14 bytes per pulse/space
- */
+/* This mapping table is used to do a very simple filtering of the
+ * input signal.
+ * For a value with at least 4 bits set it returns 0xFF otherwise
+ * 0x00.  For faster IR signals this can not be used. But for RC-5 we
+ * still have about 14 samples per pulse/space, i.e. we sample with 14
+ * times higher frequency than the signal frequency */
 const unsigned char map_table[] =
 {
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 };
 
 #if defined(KERNEL_2_5) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
-static void urb_complete(struct urb* urb, struct pt_regs* pt_regs)
+static void urb_complete(struct urb *urb, struct pt_regs *pt_regs)
 #else
-static void urb_complete(struct urb* urb)
+static void urb_complete(struct urb *urb)
 #endif
 {
 	struct ttusbir_device *ttusbir;
@@ -161,23 +191,24 @@ static void urb_complete(struct urb* urb)
 
 	ttusbir = urb->context;
 
-	if(!ttusbir->opened)
+	if (!ttusbir->opened)
 		return;
 
-	buf = (unsigned char*)urb->transfer_buffer;
+	buf = (unsigned char *)urb->transfer_buffer;
 
-	for(i=0; i < 128; i++) {
+	for (i = 0; i < 128; i++) {
+		/* Here we do the filtering and some kind of down sampling */
 		buf[i] = ~map_table[buf[i]];
-		if(ttusbir->last_pulse == buf[i]) {
-			if(ttusbir->last_num < PULSE_MASK/63)
+		if (ttusbir->last_pulse == buf[i]) {
+			if (ttusbir->last_num < PULSE_MASK/63)
 				ttusbir->last_num++;
-			/* else we are in a idle period and do not need to increment any longer */
-		}
-		else {
-			l = ttusbir->last_num * 62; /* about 62 = s/byte */
-			if(ttusbir->last_pulse) /* pulse or space? */
+		/* else we are in a idle period and do not need to
+		 * increment any longer */
+		} else {
+			l = ttusbir->last_num * 62; /* about 62 = us/byte */
+			if (ttusbir->last_pulse) /* pulse or space? */
 				l |= PULSE_BIT;
-			if(!lirc_buffer_full(&ttusbir->rbuf)) {
+			if (!lirc_buffer_full(&ttusbir->rbuf)) {
 				lirc_buffer_write_1(&ttusbir->rbuf, (void *)&l);
 				wake_up_interruptible(&ttusbir->rbuf.wait_poll);
 			}
@@ -196,18 +227,35 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 	int alt_set, endp;
 	int found = 0;
 	int i, j;
-	struct usb_host_interface* host_interf;
+	int struct_size;
+	struct usb_host_interface *host_interf;
 	struct usb_interface_descriptor *interf_desc;
 	struct usb_host_endpoint *host_endpoint;
 	struct ttusbir_device *ttusbir;
 
 	DPRINTK("Module ttusbir probe\n");
 
-	ttusbir = (struct ttusbir_device*)kzalloc(sizeof(struct ttusbir_device), GFP_KERNEL);
-	if(!ttusbir)
+	/* To reduce memory fragmentation we use only one allocation */
+	struct_size =  sizeof(struct ttusbir_device) +
+		(sizeof(struct urb *) * num_urbs) +
+		(sizeof(char *) * num_urbs) +
+		(num_urbs * 128);
+	ttusbir = kmalloc(struct_size, GFP_KERNEL);
+	if (!ttusbir)
 		return -ENOMEM;
+	memset(ttusbir, 0, struct_size);
+
+	ttusbir->urb = (struct urb **)((char *)ttusbir +
+				      sizeof(struct ttusbir_device));
+	ttusbir->buffer = (char **)((char *)ttusbir->urb +
+				   (sizeof(struct urb *) * num_urbs));
+	for (i = 0; i < num_urbs; i++)
+		ttusbir->buffer[i] = (char *)ttusbir->buffer +
+			(sizeof(char *)*num_urbs) + (i * 128);
+
 	ttusbir->driver = &driver;
 	ttusbir->alt_setting = -1;
+	/* @TODO check if error can be returned */
 	ttusbir->udev = usb_get_dev(interface_to_usbdev(intf));
 	ttusbir->interf = intf;
 	ttusbir->last_pulse = 0x00;
@@ -217,13 +265,13 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 	   We are searching for the alt setting where end point
 	   0x82 has max packet size 16
 	*/
-	for(alt_set=0; alt_set < intf->num_altsetting && !found; alt_set++) {
+	for (alt_set = 0; alt_set < intf->num_altsetting && !found; alt_set++) {
 		host_interf = &intf->altsetting[alt_set];
 		interf_desc = &host_interf->desc;
-		for(endp=0; endp < interf_desc->bNumEndpoints; endp++) {
+		for (endp = 0; endp < interf_desc->bNumEndpoints; endp++) {
 			host_endpoint = &host_interf->endpoint[endp];
-			if( (host_endpoint->desc.bEndpointAddress == 0x82) &&
-			    (host_endpoint->desc.wMaxPacketSize == 0x10) ) {
+			if ((host_endpoint->desc.bEndpointAddress == 0x82) &&
+			    (host_endpoint->desc.wMaxPacketSize == 0x10)) {
 				ttusbir->alt_setting = alt_set;
 				ttusbir->endpoint = endp;
 				found = 1;
@@ -231,7 +279,7 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 			}
 		}
 	}
-	if(ttusbir->alt_setting != -1)
+	if (ttusbir->alt_setting != -1)
 		DPRINTK("alt setting: %d\n", ttusbir->alt_setting);
 	else {
 		err("Could not find alternate setting\n");
@@ -246,7 +294,7 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 	usb_set_intfdata(intf, ttusbir);
 
 	/* Register as a LIRC plugin */
-	if(lirc_buffer_init(&ttusbir->rbuf, sizeof(lirc_t), 256 ) < 0) {
+	if (lirc_buffer_init(&ttusbir->rbuf, sizeof(lirc_t), 256) < 0) {
 		err("Could not get memory for LIRC data buffer\n");
 		usb_set_intfdata(intf, NULL);
 		kfree(ttusbir);
@@ -266,7 +314,8 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 	ttusbir->plugin.fops = NULL;
 	ttusbir->plugin.owner = THIS_MODULE;
 	ttusbir->plugin.features = LIRC_CAN_REC_MODE2;
-	if ((ttusbir->minor = lirc_register_plugin(&ttusbir->plugin)) < 0) {
+	ttusbir->minor = lirc_register_plugin(&ttusbir->plugin);
+	if (ttusbir->minor < 0) {
 		err("Error registering as LIRC plugin\n");
 		usb_set_intfdata(intf, NULL);
 		lirc_buffer_free(&ttusbir->rbuf);
@@ -275,11 +324,11 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 	}
 
 	/* Allocate and setup the URB that we will use to talk to the device */
-	for(i=0; i < NUM_URBS; i++) {
+	for (i = 0; i < num_urbs; i++) {
 		ttusbir->urb[i] = usb_alloc_urb(8, GFP_KERNEL);
-		if(!ttusbir->urb[i]) {
+		if (!ttusbir->urb[i]) {
 			err("Could not allocate memory for the URB\n");
-			for(j=i-1; j >= 0; j--)
+			for (j = i - 1; j >= 0; j--)
 				kfree(ttusbir->urb[j]);
 			lirc_buffer_free(&ttusbir->rbuf);
 			lirc_unregister_plugin(ttusbir->minor);
@@ -289,14 +338,15 @@ static int probe(struct usb_interface *intf, const struct usb_device_id *id)
 		}
 		ttusbir->urb[i]->dev = ttusbir->udev;
 		ttusbir->urb[i]->context = ttusbir;
-		ttusbir->urb[i]->pipe = usb_rcvisocpipe(ttusbir->udev, ttusbir->endpoint);
+		ttusbir->urb[i]->pipe = usb_rcvisocpipe(ttusbir->udev,
+							ttusbir->endpoint);
 		ttusbir->urb[i]->interval = 1;
 		ttusbir->urb[i]->transfer_flags = URB_ISO_ASAP;
 		ttusbir->urb[i]->transfer_buffer = &ttusbir->buffer[i][0];
 		ttusbir->urb[i]->complete = urb_complete;
 		ttusbir->urb[i]->number_of_packets = 8;
 		ttusbir->urb[i]->transfer_buffer_length = 128;
-		for(j=0; j < 8; j++) {
+		for (j = 0; j < 8; j++) {
 			ttusbir->urb[i]->iso_frame_desc[j].offset = j*16;
 			ttusbir->urb[i]->iso_frame_desc[j].length = 16;
 		}
@@ -313,14 +363,16 @@ static void disconnect(struct usb_interface *intf)
 
 	DPRINTK("Module ttusbir disconnect\n");
 
-	lock_kernel();
-	ttusbir = (struct ttusbir_device*) usb_get_intfdata(intf);
+	ttusbir = (struct ttusbir_device *) usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 	lirc_unregister_plugin(ttusbir->minor);
-	unlock_kernel();
+	DPRINTK("unregistered\n");
 
-	for(i=0; i < NUM_URBS; i++)
+	for (i = 0; i < num_urbs; i++) {
+		usb_kill_urb(ttusbir->urb[i]);
 		usb_free_urb(ttusbir->urb[i]);
+	}
+	DPRINTK("URBs killed\n");
 	lirc_buffer_free(&ttusbir->rbuf);
 	kfree(ttusbir);
 }
@@ -329,7 +381,7 @@ static int ttusbir_init_module(void)
 {
 	int result;
 
-	DPRINTK( KERN_DEBUG "Module ttusbir init\n" );
+	DPRINTK(KERN_DEBUG "Module ttusbir init\n");
 
 	/* register this driver with the USB subsystem */
 	result = usb_register(&driver);
@@ -340,7 +392,7 @@ static int ttusbir_init_module(void)
 
 static void ttusbir_exit_module(void)
 {
-	printk( KERN_DEBUG "Module ttusbir exit\n" );
+	printk(KERN_DEBUG "Module ttusbir exit\n");
 	/* deregister this driver with the USB subsystem */
 	usb_deregister(&driver);
 }
diff --git a/include/linux/lirc.h b/include/linux/lirc.h
index e70ada2..88e152e 100644
--- a/include/linux/lirc.h
+++ b/include/linux/lirc.h
@@ -64,6 +64,7 @@ typedef int lirc_t;
 
 #define LIRC_CAN_SET_REC_DUTY_CYCLE_RANGE 0x40000000
 #define LIRC_CAN_SET_REC_CARRIER_RANGE    0x80000000
+#define LIRC_CAN_GET_REC_RESOLUTION       0x20000000
 
 #define LIRC_CAN_SEND(x) ((x)&LIRC_CAN_SEND_MASK)
 #define LIRC_CAN_REC(x) ((x)&LIRC_CAN_REC_MASK)
-- 
1.5.3.6

