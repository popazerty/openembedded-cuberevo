Integrate ST SPI support into kernel SPI subsystem

Signed-off-by: Angus Clark <angus.clark@st.com>

Index: linux-2.6.23/drivers/spi/Kconfig
===================================================================
--- linux-2.6.23.orig/drivers/spi/Kconfig	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/drivers/spi/Kconfig	2008-04-29 15:36:00.000000000 +0100
@@ -174,6 +174,28 @@
 	  the inbuilt hardware cannot provide the transfer mode, or
 	  where the board is using non hardware connected pins.
 
+config SPI_STM
+	bool "STMicroelectronics SPI support"
+	depends on SPI_MASTER && CPU_SUBTYPE_ST40
+	select SPI_BITBANG
+	help
+	  STMicroelectronics SoCs support for SPI.
+
+config SPI_STM_PIO
+        bool "SPI bit-banging PIO driver"
+	depends on SPI_STM
+	help
+	  If you say yes to this option, support will be included for the
+	  PIO driven SPI in bit-banging mode.
+	  This driver can also be built as a module.
+
+config SPI_STM_SSC
+	bool "SPI hardware SSC driver"
+	depends on SPI_STM
+	help
+	  If you say yes to this option, support will be included for the
+	  SSC driven SPI.
+
 config SPI_TXX9
 	tristate "Toshiba TXx9 SPI controller"
 	depends on SPI_MASTER && GENERIC_GPIO && CPU_TX49XX
Index: linux-2.6.23/drivers/spi/spi_stm_gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23/drivers/spi/spi_stm_gpio.c	2008-04-29 15:36:00.000000000 +0100
@@ -0,0 +1,294 @@
+/*
+ *  -------------------------------------------------------------------------
+ *  spi_stm_gpio.c SPI/GPIO driver for STMicroelectronics platforms
+ *  -------------------------------------------------------------------------
+ *
+ *  Copyright (c) 2008 STMicroelectronics Limited
+ *  Author: Francesco Virlinzi <francesco.virlinzi@st.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License version 2.0 ONLY.  See linux/COPYING for more information.
+ *
+ *  -------------------------------------------------------------------------
+ *  Changelog:
+ *  2008-01-24 Angus Clark <angus.clark@st.com>
+ *    - chip_select modified to ignore devices with no chip_select, and keep
+ *      hold of PIO pin (freeing pin selects STPIO_IN (high-Z) mode).
+ *    - added spi_stmpio_setup() and spi_stmpio_setup_transfer() to enfore
+ *	SPI_STMPIO_MAX_SPEED_HZ
+ *
+ *  -------------------------------------------------------------------------
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/stm/pio.h>
+#include <linux/stm/soc.h>
+#include <linux/io.h>
+#include <linux/param.h>
+
+#ifdef CONFIG_SPI_DEBUG
+#define dgb_print(fmt, args...)  printk(KERN_INFO "%s: " \
+					fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NAME "spi_stm_pio"
+
+/* Maybe this should be included in platform_data? */
+#define SPI_STMPIO_MAX_SPEED_HZ		1000000
+
+static inline void setsck(struct spi_device *dev, int on)
+{
+	struct platform_device *pdev =
+		container_of(dev->dev.parent, struct platform_device, dev);
+	struct ssc_pio_t *pio_info =
+		(struct ssc_pio_t *)pdev->dev.platform_data;
+	stpio_set_pin(pio_info->clk, on ? 1 : 0);
+}
+
+static inline void setmosi(struct spi_device *dev, int on)
+{
+	struct platform_device *pdev
+		= container_of(dev->dev.parent, struct platform_device, dev);
+	struct ssc_pio_t *pio_info =
+		(struct ssc_pio_t *)pdev->dev.platform_data;
+	stpio_set_pin(pio_info->sdout, on ? 1 : 0);
+}
+
+static inline u32 getmiso(struct spi_device *dev)
+{
+	struct platform_device *pdev
+		= container_of(dev->dev.parent, struct platform_device, dev);
+	struct ssc_pio_t *pio_info =
+		(struct ssc_pio_t *)pdev->dev.platform_data;
+	return stpio_get_pin(pio_info->sdin) ? 1 : 0;
+}
+
+#define EXPAND_BITBANG_TXRX
+#define spidelay(x) ndelay(x)
+#include <linux/spi/spi_bitbang.h>
+
+static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
+				unsigned nsecs, u32 word, u8 bits)
+{
+	dgb_print("\n");
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+
+static void spi_gpio_chipselect(struct spi_device *spi, int value)
+{
+	unsigned int out;
+
+	dgb_print("\n");
+	if (spi->chip_select == SPI_NO_CHIPSELECT)
+		return;
+
+	/* Request stpio_pin if not already done so */
+	/*  (stored in spi_device->controller_data) */
+	if (!spi->controller_data)
+		spi->controller_data =
+			stpio_request_pin(spi_get_bank(spi->chip_select),
+					  spi_get_line(spi->chip_select),
+					  "spi-cs", STPIO_OUT);
+
+	if (!spi->controller_data) {
+		printk(KERN_ERR NAME " Error spi-cs locked or not-exist\n");
+		return;
+	}
+
+	if (value == BITBANG_CS_ACTIVE)
+		out = spi->mode & SPI_CS_HIGH ? 1 : 0;
+	else
+		out = spi->mode & SPI_CS_HIGH ? 0 : 1;
+
+	stpio_set_pin((struct stpio_pin *)spi->controller_data, out);
+
+	dgb_print("%s PIO%d[%d] -> %d \n",
+		  value == BITBANG_CS_ACTIVE ? "select" : "deselect",
+		  spi_get_bank(spi->chip_select),
+		  spi_get_line(spi->chip_select), out);
+
+	return;
+}
+
+struct spi_stm_gpio {
+	struct spi_bitbang	bitbang;
+	struct platform_device	*pdev;
+
+	/* Max speed supported by STPIO bit-banging SPI controller */
+	int max_speed_hz;
+};
+
+static int spi_stmpio_setup(struct spi_device *spi)
+{
+	struct spi_stm_gpio *spi_st = spi_master_get_devdata(spi->master);
+
+	dgb_print("\n");
+
+	if (spi->max_speed_hz > spi_st->max_speed_hz) {
+		printk(KERN_ERR NAME " requested baud rate (%dhz) exceeds "
+		       "max (%dhz)\n",
+		       spi->max_speed_hz, spi_st->max_speed_hz);
+		return -EINVAL;
+	}
+
+	return spi_bitbang_setup(spi);
+}
+
+static int spi_stmpio_setup_transfer(struct spi_device *spi,
+				     struct spi_transfer *t)
+{
+	dgb_print("\n");
+
+	if (t)
+		if (t->speed_hz > spi->max_speed_hz) {
+			printk(KERN_ERR NAME " requested baud rate (%dhz) "
+			       "exceeds max (%dhz)\n",
+			       t->speed_hz, spi->max_speed_hz);
+			return -EINVAL;
+		}
+
+	return spi_bitbang_setup_transfer(spi, t);
+}
+
+static int __init spi_probe(struct platform_device *pdev)
+{
+	struct ssc_pio_t *pio_info =
+			(struct ssc_pio_t *)pdev->dev.platform_data;
+	struct spi_master *master;
+	struct spi_stm_gpio *st_bitbang;
+
+	dgb_print("\n");
+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_stm_gpio));
+	if (!master)
+		return -1;
+
+	st_bitbang = spi_master_get_devdata(master);
+	if (!st_bitbang)
+		return -1;
+
+	platform_set_drvdata(pdev, st_bitbang);
+	st_bitbang->bitbang.master = master;
+	st_bitbang->bitbang.master->setup = spi_stmpio_setup;
+	st_bitbang->bitbang.setup_transfer = spi_stmpio_setup_transfer;
+	st_bitbang->bitbang.chipselect = spi_gpio_chipselect;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
+	st_bitbang->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
+
+	master->num_chipselect = SPI_NO_CHIPSELECT + 1;
+	master->bus_num = pdev->id;
+	st_bitbang->max_speed_hz = SPI_STMPIO_MAX_SPEED_HZ;
+
+	pio_info->clk = stpio_request_pin(pio_info->pio_port,
+					  pio_info->pio_pin[0],
+					  "SPI Clock", STPIO_OUT);
+	if (!pio_info->clk) {
+		printk(KERN_ERR NAME " Faild to clk pin allocation PIO%d[%d]\n",
+		       pio_info->pio_port, pio_info->pio_pin[0]);
+		return -1;
+	}
+	pio_info->sdout = stpio_request_pin(pio_info->pio_port,
+					    pio_info->pio_pin[1],
+					    "SPI Data Out", STPIO_OUT);
+	if (!pio_info->sdout) {
+		printk(KERN_ERR NAME " Faild to sda pin allocation PIO%d[%d]\n",
+		       pio_info->pio_port, pio_info->pio_pin[1]);
+		return -1;
+	}
+	pio_info->sdin = stpio_request_pin(pio_info->pio_port,
+					   pio_info->pio_pin[2],
+					   "SPI Data In", STPIO_IN);
+	if (!pio_info->sdin) {
+		printk(KERN_ERR NAME " Faild to sdo pin allocation PIO%d[%d]\n",
+		       pio_info->pio_port, pio_info->pio_pin[2]);
+		return -1;
+	}
+
+	stpio_set_pin(pio_info->clk, 0);
+	stpio_set_pin(pio_info->sdout, 0);
+	stpio_set_pin(pio_info->sdin, 0);
+
+	if (spi_bitbang_start(&st_bitbang->bitbang)) {
+		printk(KERN_ERR NAME
+		       "The SPI Core refuses the spi_stm_gpio adapter\n");
+		return -1;
+	}
+
+	printk(KERN_INFO NAME ": Registered SPI Bus %d: PIO%d[%d/%d/%d]\n",
+	       master->bus_num, pio_info->pio_port, pio_info->pio_pin[0],
+	       pio_info->pio_pin[1], pio_info->pio_pin[2]);
+
+	return 0;
+}
+
+static int spi_remove(struct platform_device *pdev)
+{
+	struct ssc_pio_t *pio_info =
+			(struct ssc_pio_t *)pdev->dev.platform_data;
+	struct spi_stm_gpio *sp = platform_get_drvdata(pdev);
+
+	dgb_print("\n");
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+	stpio_free_pin(pio_info->clk);
+	stpio_free_pin(pio_info->sdout);
+	stpio_free_pin(pio_info->sdin);
+	return 0;
+}
+
+static struct platform_driver spi_sw_driver = {
+	.driver.name = "spi_st_pio",
+	.driver.owner = THIS_MODULE,
+	.probe = spi_probe,
+	.remove = spi_remove,
+};
+
+static int __init spi_gpio_init(void)
+{
+	printk(KERN_INFO NAME ": PIO based SPI Driver\n");
+	return platform_driver_register(&spi_sw_driver);
+}
+
+static void __exit spi_gpio_exit(void)
+{
+	dgb_print("\n");
+	platform_driver_unregister(&spi_sw_driver);
+}
+
+MODULE_AUTHOR("Francesco Virlinzi <francesco.virlinzi@st.com>");
+MODULE_DESCRIPTION("GPIO based SPI Driver");
+MODULE_LICENSE("GPL");
+
+module_init(spi_gpio_init);
+module_exit(spi_gpio_exit);
+
Index: linux-2.6.23/drivers/spi/spi_stm_ssc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23/drivers/spi/spi_stm_ssc.c	2008-04-29 15:36:00.000000000 +0100
@@ -0,0 +1,562 @@
+/*
+ *  ------------------------------------------------------------------------
+ *  spi_stm_ssc.c SPI/SSC driver for STMicroelectronics platforms
+ *  ------------------------------------------------------------------------
+ *
+ *  Copyright (c) 2008 STMicroelectronics Limited
+ *  Author: Angus Clark <Angus.Clark@st.com>
+
+ *  ------------------------------------------------------------------------
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License Version 2.0 only.  See linux/COPYING for more information.
+ *
+ *  ------------------------------------------------------------------------
+ */
+
+#include <linux/stm/pio.h>
+#include <asm/semaphore.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/stssc.h>
+#include <linux/uaccess.h>
+#include <linux/param.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/delay.h>
+
+#undef dgb_print
+
+#ifdef CONFIG_SPI_DEBUG
+#define SPI_LOOP_DEBUG
+#define dgb_print(fmt, args...)  printk(KERN_INFO "%s: " \
+					fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NAME "spi_stm_ssc"
+
+struct spi_stm_ssc {
+
+	/* SSC SPI Controller */
+	struct spi_bitbang	bitbang;
+	unsigned long		base;
+	unsigned int		fcomms;
+	struct platform_device  *pdev;
+
+	/* SSC SPI current transaction */
+	const u8		*tx_ptr;
+	u8			*rx_ptr;
+	u16			bits_per_word;
+	unsigned int		baud;
+	unsigned int		tx_bytes_pending;
+	unsigned int		rx_bytes_pending;
+	struct completion	done;
+
+};
+
+static void spi_stmssc_chipselect(struct spi_device *spi, int value)
+{
+	unsigned int out;
+
+	dgb_print("\n");
+	if (spi->chip_select == SPI_NO_CHIPSELECT)
+		return;
+
+	/* Request stpio_pin if not already done so */
+	/*  (stored in spi_device->controller_data) */
+	if (!spi->controller_data)
+		spi->controller_data =
+			stpio_request_pin(spi_get_bank(spi->chip_select),
+					  spi_get_line(spi->chip_select),
+					  "spi-cs", STPIO_OUT);
+	if (!spi->controller_data) {
+		printk(KERN_ERR NAME " Error spi-cs locked or not-exist\n");
+		return;
+	}
+
+	if (value == BITBANG_CS_ACTIVE)
+		out = spi->mode & SPI_CS_HIGH ? 1 : 0;
+	else
+		out = spi->mode & SPI_CS_HIGH ? 0 : 1;
+
+	stpio_set_pin((struct stpio_pin *)spi->controller_data, out);
+
+	dgb_print("%s PIO%d[%d] -> %d \n",
+		  value == BITBANG_CS_ACTIVE ? "select" : "deselect",
+		  spi_get_bank(spi->chip_select),
+		  spi_get_line(spi->chip_select), out);
+
+	return;
+}
+
+static int spi_stmssc_setup_transfer(struct spi_device *spi,
+				     struct spi_transfer *t)
+{
+	struct spi_stm_ssc *st_ssc;
+	u32 hz;
+	u8 bits_per_word;
+	u16 reg;
+	u32 sscbrg;
+
+	st_ssc = spi_master_get_devdata(spi->master);
+	bits_per_word = (t) ? t->bits_per_word : 0;
+	hz = (t) ? t->speed_hz : 0;
+
+	/* If not specified, use defaults */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+	if (!hz)
+		hz = spi->max_speed_hz;
+
+	/* Actually, can probably support 2-16 without any other change!!! */
+	if (bits_per_word != 8 && bits_per_word != 16) {
+		printk(KERN_ERR NAME " unsupported bits_per_word=%d\n",
+		       bits_per_word);
+		return -EINVAL;
+	}
+	st_ssc->bits_per_word = bits_per_word;
+
+	/* Set SSC_BRF */
+	/* TODO: program prescaler for slower baudrates */
+	sscbrg = st_ssc->fcomms/(2*hz);
+	if (sscbrg < 0x07 || sscbrg > (0x1 << 16)) {
+		printk(KERN_ERR NAME " baudrate outside valid range"
+		       " %d (sscbrg = %d)\n", hz, sscbrg);
+		return -EINVAL;
+	}
+	st_ssc->baud = st_ssc->fcomms/(2*sscbrg);
+	if (sscbrg == (0x1 << 16)) /* 16-bit counter wraps */
+		sscbrg = 0x0;
+	dgb_print("setting baudrate: hz = %d, sscbrg = %d\n", hz, sscbrg);
+	ssc_store16(st_ssc, SSC_BRG, sscbrg);
+
+	 /* Set SSC_CTL and enable SSC */
+	 reg = ssc_load16(st_ssc, SSC_CTL);
+	 reg |= SSC_CTL_MS;
+
+	 if (spi->mode & SPI_CPOL)
+		 reg |= SSC_CTL_PO;
+	 else
+		 reg &= ~SSC_CTL_PO;
+
+	 if (spi->mode & SPI_CPHA)
+		 reg |= SSC_CTL_PH;
+	 else
+		 reg &= ~SSC_CTL_PH;
+
+	 if ((spi->mode & SPI_LSB_FIRST) == 0)
+		 reg |= SSC_CTL_HB;
+	 else
+		 reg &= ~SSC_CTL_HB;
+
+	 if (spi->mode & SPI_LOOP)
+		 reg |= SSC_CTL_LPB;
+	 else
+		 reg &= ~SSC_CTL_LPB;
+
+	 reg &= 0xfff0;
+	 reg |= (bits_per_word - 1);
+
+	 /* CHECK!: are we always going to use FIFO or
+	    do I need CONFIG_STM_SPI_HW_FIFO? */
+	 reg |= SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO;
+	 reg |= SSC_CTL_EN;
+
+	 dgb_print("ssc_ctl = 0x%04x\n", reg);
+	 ssc_store16(st_ssc, SSC_CTL, reg);
+
+	 /* Clear the status register */
+	 ssc_load16(st_ssc, SSC_RBUF);
+
+	 return 0;
+}
+
+/* the spi->mode bits understood by this driver: */
+#define MODEBITS  (SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_LOOP | SPI_CS_HIGH)
+static int spi_stmssc_setup(struct spi_device *spi)
+{
+	struct spi_stm_ssc *st_ssc;
+	int retval;
+
+	st_ssc = spi_master_get_devdata(spi->master);
+
+	if (spi->mode & ~MODEBITS) {
+		printk(KERN_ERR NAME "unsupported mode bits %x\n",
+			  spi->mode & ~MODEBITS);
+		return -EINVAL;
+	}
+
+	if (!spi->max_speed_hz)  {
+		printk(KERN_ERR NAME " max_speed_hz unspecified\n");
+		return -EINVAL;
+	}
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	retval = spi_stmssc_setup_transfer(spi, NULL);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+/* For SSC SPI as MASTER, TX/RX is handled as follows:
+
+   1. Fill the TX_FIFO with up to (SSC_TXFIFO_SIZE - 1) words, and enable
+      TX_FIFO_EMPTY interrupts.
+   2. When the last word of TX_FIFO is copied to the shift register,
+      a TX_FIFO_EMPTY interrupt is issued, and the last word will *start* being
+      shifted out/in.
+   3. On receiving a TX_FIFO_EMPTY interrupt, copy all *available* received
+      words from the RX_FIFO. Note, depending on the time taken to shift out/in
+      the 'last' word compared to the IRQ latency, the 'last' word may not be
+      available yet in the RX_FIFO.
+   4. If there are more bytes to TX, refill the TX_FIFO.  Since the 'last' word
+      from the previous iteration may still be (or about to be) in the RX_FIFO,
+      only add up to (SSC_TXFIFO_SIZE - 1) words.  If all bytes have been
+      transmitted, disable TX and set completion.
+   5. If we are interested in the received data, check to see if the 'last' word
+      has been received.  If not, then wait the period of shifting 1 word, then
+      read the 'last' word from the RX_FIFO.
+
+*/
+static void spi_stmssc_fill_tx_fifo(struct spi_stm_ssc *st_ssc)
+{
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+	int i;
+
+	for (i = 0;
+	     i < SSC_TXFIFO_SIZE - 1 && st_ssc->tx_bytes_pending > 0; i++) {
+		if (st_ssc->bits_per_word > 8) {
+			if (st_ssc->tx_ptr) {
+				tmp.bytes[1] = *st_ssc->tx_ptr++;
+				tmp.bytes[0] = *st_ssc->tx_ptr++;
+			} else {
+				tmp.bytes[1] = 0;
+				tmp.bytes[0] = 0;
+			}
+
+			st_ssc->tx_bytes_pending -= 2;
+
+		} else {
+			if (st_ssc->tx_ptr)
+				tmp.bytes[0] = *st_ssc->tx_ptr++;
+			else
+				tmp.bytes[0] = 0;
+
+			st_ssc->tx_bytes_pending--;
+		}
+		ssc_store16(st_ssc, SSC_TBUF, tmp.word);
+	}
+}
+
+static int spi_stmssc_rx_mopup(struct spi_stm_ssc *st_ssc)
+{
+	unsigned long word_period_ns;
+	u16 rx_fifo_status;
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+
+	dgb_print("\n");
+
+	word_period_ns = 1000000000 / st_ssc->baud;
+	word_period_ns *= st_ssc->bits_per_word;
+
+	/* delay for period equivalent to shifting 1 complete word
+	   out of and into shift register */
+	ndelay(word_period_ns);
+
+	/* Check 'last' word is actually there! */
+	rx_fifo_status = ssc_load16(st_ssc, SSC_RX_FSTAT);
+	if (rx_fifo_status == 1) {
+		tmp.word = ssc_load16(st_ssc, SSC_RBUF);
+		if (st_ssc->rx_ptr) {
+			if (st_ssc->bits_per_word > 8) {
+				*st_ssc->rx_ptr++ = tmp.bytes[1];
+				*st_ssc->rx_ptr++ = tmp.bytes[0];
+				st_ssc->rx_bytes_pending -= 2;
+			} else {
+				*st_ssc->rx_ptr++ = tmp.bytes[0];
+				st_ssc->rx_bytes_pending--;
+			}
+		}
+		if (st_ssc->rx_bytes_pending)
+			dgb_print("rx_bytes_pending = %d\n",
+				  st_ssc->rx_bytes_pending);
+	} else
+		dgb_print("should only be one word in RX_FIFO"
+			  "(rx_fifo_status = %d)\n", rx_fifo_status);
+
+	return 0;
+}
+
+
+static int spi_stmssc_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct spi_stm_ssc *st_ssc;
+
+	dgb_print("\n");
+
+	st_ssc = spi_master_get_devdata(spi->master);
+
+	st_ssc->tx_ptr = t->tx_buf;
+	st_ssc->rx_ptr = t->rx_buf;
+	st_ssc->tx_bytes_pending = t->len;
+	st_ssc->rx_bytes_pending = t->len;
+	INIT_COMPLETION(st_ssc->done);
+
+	/* fill TX_FIFO */
+	spi_stmssc_fill_tx_fifo(st_ssc);
+
+	/* enable TX_FIFO_EMPTY interrupts */
+	ssc_store16(st_ssc, SSC_IEN, SSC_IEN_TIEN);
+
+	/* wait for all bytes to be transmitted*/
+	wait_for_completion(&st_ssc->done);
+
+	/* if necessary, check all bytes have been received */
+	if (st_ssc->rx_bytes_pending && st_ssc->rx_ptr)
+		spi_stmssc_rx_mopup(st_ssc);
+
+	/* disable ints */
+	ssc_store16(st_ssc, SSC_IEN, 0x0);
+
+	return t->len - st_ssc->tx_bytes_pending;
+}
+
+static irqreturn_t spi_stmssc_irq(int irq, void *dev_id)
+{
+	struct spi_stm_ssc *st_ssc = (struct spi_stm_ssc *)dev_id;
+	unsigned int rx_fifo_status;
+	u16 ssc_status;
+
+	union {
+		unsigned char bytes[2];
+		unsigned short word;
+	} tmp = {.word = 0,};
+
+
+	ssc_status = ssc_load16(st_ssc, SSC_STA);
+
+	/* FIFO_TX_EMPTY */
+	if (ssc_status & SSC_STA_TIR) {
+		/* Find number of words available in RX_FIFO: 8 if RX_FIFO_FULL,
+		   else SSC_RX_FSTAT (0-7)
+		*/
+		rx_fifo_status = (ssc_status & SSC_STA_RIR) ? 8 :
+			ssc_load16(st_ssc, SSC_RX_FSTAT);
+		/* Read all available words from RX_FIFO */
+		while (rx_fifo_status) {
+			tmp.word = ssc_load16(st_ssc, SSC_RBUF);
+
+			if (st_ssc->rx_ptr) {
+				if (st_ssc->bits_per_word > 8) {
+					*st_ssc->rx_ptr++ = tmp.bytes[1];
+					*st_ssc->rx_ptr++ = tmp.bytes[0];
+					st_ssc->rx_bytes_pending -= 2;
+				} else {
+					*st_ssc->rx_ptr++ = tmp.bytes[0];
+					st_ssc->rx_bytes_pending--;
+				}
+			}
+
+			rx_fifo_status = ssc_load16(st_ssc, SSC_RX_FSTAT);
+		}
+
+		/* See if there is more data to send */
+		if (st_ssc->tx_bytes_pending > 0)
+			spi_stmssc_fill_tx_fifo(st_ssc);
+		else {
+			/* No more data to send */
+			ssc_store16(st_ssc, SSC_IEN, 0x0);
+			complete(&st_ssc->done);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init spi_stm_probe(struct platform_device *pdev)
+{
+	struct ssc_pio_t *pio_info =
+			(struct ssc_pio_t *)pdev->dev.platform_data;
+	struct spi_master *master;
+	struct resource *res;
+	struct spi_stm_ssc *st_ssc;
+
+	u16 reg;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_stm_ssc));
+	if (!master)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, master);
+
+	st_ssc = spi_master_get_devdata(master);
+	st_ssc->bitbang.master     = spi_master_get(master);
+	st_ssc->bitbang.chipselect = spi_stmssc_chipselect;
+	st_ssc->bitbang.setup_transfer = spi_stmssc_setup_transfer;
+	st_ssc->bitbang.txrx_bufs  = spi_stmssc_txrx_bufs;
+	st_ssc->bitbang.master->setup = spi_stmssc_setup;
+
+	master->num_chipselect = SPI_NO_CHIPSELECT + 1;
+	master->bus_num = pdev->id;
+	init_completion(&st_ssc->done);
+
+	/* Get resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!devm_request_mem_region(&pdev->dev, res->start,
+				     res->end - res->start, "spi")) {
+		printk(KERN_ERR NAME " Request mem 0x%x region failed\n",
+		       res->start);
+		return -ENOMEM;
+	}
+
+	st_ssc->base =
+		(unsigned long) devm_ioremap_nocache(&pdev->dev, res->start,
+						     res->end - res->start);
+	if (!st_ssc->base) {
+		printk(KERN_ERR NAME " Request iomem 0x%x region failed\n",
+		       res->start);
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		printk(KERN_ERR NAME " Request irq %d failed\n", res->start);
+		return -ENODEV;
+	}
+
+	if (devm_request_irq(&pdev->dev, res->start, spi_stmssc_irq,
+		IRQF_DISABLED, "stspi", st_ssc) < 0) {
+		printk(KERN_ERR NAME " Request irq failed\n");
+		return -ENODEV;
+	}
+
+	/* Get PIO pins */
+	pio_info->clk = stpio_request_set_pin(pio_info->pio_port,
+					      pio_info->pio_pin[0],
+					      "SPI Clock", STPIO_BIDIR, 0);
+	if (!pio_info->clk) {
+		printk(KERN_ERR NAME
+		       " Failed to allocate clk pin (PIO%d[%d])\n",
+		       pio_info->pio_port, pio_info->pio_pin[0]);
+		return -ENODEV;
+	}
+	pio_info->sdout = stpio_request_set_pin(pio_info->pio_port,
+						pio_info->pio_pin[1],
+						"SPI Data out", STPIO_BIDIR, 0);
+	if (!pio_info->sdout) {
+		printk(KERN_ERR NAME
+		       " Failed to allocate sdo pin (PIO%d[%d])\n",
+		       pio_info->pio_port, pio_info->pio_pin[1]);
+		return -ENODEV;
+	}
+	pio_info->sdin = stpio_request_pin(pio_info->pio_port,
+					   pio_info->pio_pin[2],
+					   "SPI Data in", STPIO_IN);
+	if (!pio_info->sdin) {
+		printk(KERN_ERR NAME
+		       " Failed to allocate sdi pin (PIO%d[%d])\n",
+		       pio_info->pio_port, pio_info->pio_pin[2]);
+		return -ENODEV;
+	}
+
+	/* Disable I2C and Reset SSC */
+	ssc_store16(st_ssc, SSC_I2C, 0x0);
+	reg = ssc_load16(st_ssc, SSC_CTL);
+	reg |= SSC_CTL_SR;
+	ssc_store16(st_ssc, SSC_CTL, reg);
+
+	udelay(1);
+	reg = ssc_load16(st_ssc, SSC_CTL);
+	reg &= ~SSC_CTL_SR;
+	ssc_store16(st_ssc, SSC_CTL, reg);
+
+	/* Set SSC into slave mode before reconfiguring PIO pins */
+	reg = ssc_load16(st_ssc, SSC_CTL);
+	reg &= ~SSC_CTL_MS;
+	ssc_store16(st_ssc, SSC_CTL, reg);
+
+	stpio_configure_pin(pio_info->clk, STPIO_ALT_OUT);
+	stpio_configure_pin(pio_info->sdout, STPIO_ALT_OUT);
+	stpio_configure_pin(pio_info->sdin, STPIO_IN);
+
+	st_ssc->fcomms = clk_get_rate(clk_get(NULL, "comms_clk"));;
+
+	/* Start bitbang worker */
+	if (spi_bitbang_start(&st_ssc->bitbang)) {
+		printk(KERN_ERR NAME
+		       " The SPI Core refuses the spi_stm_ssc adapter\n");
+		return -1;
+	}
+
+	printk(KERN_INFO NAME ": Registered SPI Bus %d: PIO%d[%d/%d/%d]\n",
+	       master->bus_num, pio_info->pio_port, pio_info->pio_pin[0],
+	       pio_info->pio_pin[1], pio_info->pio_pin[2]);
+
+	return 0;
+}
+
+static int  spi_stm_remove(struct platform_device *pdev)
+{
+	struct spi_stm_ssc *st_ssc;
+	struct spi_master *master;
+	struct ssc_pio_t *pio_info =
+		(struct ssc_pio_t *)pdev->dev.platform_data;
+
+	master = platform_get_drvdata(pdev);
+	st_ssc = spi_master_get_devdata(master);
+
+	spi_bitbang_stop(&st_ssc->bitbang);
+
+	stpio_free_pin(pio_info->sdin);
+	stpio_free_pin(pio_info->clk);
+	stpio_free_pin(pio_info->sdout);
+
+	return 0;
+}
+
+static struct platform_driver spi_hw_driver = {
+	.driver.name = "spi_st_ssc",
+	.driver.owner = THIS_MODULE,
+	.probe = spi_stm_probe,
+	.remove = spi_stm_remove,
+};
+
+
+static int __init spi_stm_ssc_init(void)
+{
+	printk(KERN_INFO NAME ": SSC SPI Driver\n");
+	return platform_driver_register(&spi_hw_driver);
+}
+
+static void __exit spi_stm_ssc_exit(void)
+{
+	dgb_print("\n");
+	platform_driver_unregister(&spi_hw_driver);
+}
+
+module_init(spi_stm_ssc_init);
+module_exit(spi_stm_ssc_exit);
+
+MODULE_AUTHOR("STMicroelectronics <www.st.com>");
+MODULE_DESCRIPTION("STM SSC SPI driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.23/arch/sh/boards/st/mb442/setup.c
===================================================================
--- linux-2.6.23.orig/arch/sh/boards/st/mb442/setup.c	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/arch/sh/boards/st/mb442/setup.c	2008-04-29 15:36:00.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/platform_device.h>
 #include <linux/stm/pio.h>
 #include <linux/stm/soc.h>
+#include <linux/spi/spi.h>
 #include <linux/delay.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/physmap.h>
Index: linux-2.6.23/arch/sh/boards/st/mb519/setup.c
===================================================================
--- linux-2.6.23.orig/arch/sh/boards/st/mb519/setup.c	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/arch/sh/boards/st/mb519/setup.c	2008-04-29 15:36:00.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/stm/pio.h>
 #include <linux/stm/soc.h>
 #include <linux/stm/emi.h>
+#include <linux/spi/spi.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/partitions.h>
@@ -208,7 +209,6 @@
 	.rbn_pin		= -1,
 };
 
-
 static struct platform_device *mb519_devices[] __initdata = {
 	&epld_device,
 	&physmap_flash,
Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c
===================================================================
--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c	2008-04-29 15:36:00.000000000 +0100
@@ -319,7 +319,7 @@
 		ssc_sc = sysconf_claim(SYS_CFG, 7, i+1, i+1, "stssc");
 		if(capability & SSC_SPI_CAPABILITY){
 			stssc_devices[i].name = spi_st;
-			sysconf_write(ssc_sc, 1);
+			sysconf_write(ssc_sc, 0);
 			stssc_devices[i].id = num_spi++;
 		} else {
 			stssc_devices[i].name = i2c_st;
Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7200.c
===================================================================
--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stx7200.c	2008-04-29 15:31:52.000000000 +0100
+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7200.c	2008-04-29 15:36:00.000000000 +0100
@@ -504,7 +504,7 @@
 
 /* SSC resources ----------------------------------------------------------- */
 static char i2c_st[] = "i2c_st";
-static char spi_st[] = "spi_st";
+static char spi_st[] = "spi_st_ssc";
 static struct platform_device stssc_devices[] = {
 	STSSC_DEVICE(0xfd040000, ILC_IRQ(108), 2, 0, 1, 2),
 	STSSC_DEVICE(0xfd041000, ILC_IRQ(109), 3, 0, 1, 2),
@@ -528,8 +528,17 @@
 		 * ssc<x>_mux_sel = 0 */
 		ssc_sc = sysconf_claim(SYS_CFG, 7, i, i, "ssc");
 		if(capability & SSC_SPI_CAPABILITY){
+			/* !!FIXME!!
+			   For some reason, nand_rb signal (PIO2[7]) must be
+			   disabled for SSC0/SPI to get input */
+			if (i == 0) {
+				ssc_sc = sysconf_claim(SYS_CFG,
+						       7, 15, 15, "ssc");
+				sysconf_write(ssc_sc, 0);
+			}
+
 			stssc_devices[i].name = spi_st;
-			sysconf_write(ssc_sc, 1);
+			sysconf_write(ssc_sc, 0);
 			stssc_devices[i].id = num_spi++;
 		} else {
 			stssc_devices[i].name = i2c_st;
Index: linux-2.6.23/drivers/spi/Makefile
===================================================================
--- linux-2.6.23.orig/drivers/spi/Makefile	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/drivers/spi/Makefile	2008-04-29 15:36:00.000000000 +0100
@@ -25,6 +25,8 @@
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
+obj-$(CONFIG_SPI_STM_PIO)		+= spi_stm_gpio.o
+obj-$(CONFIG_SPI_STM_SSC)		+= spi_stm_ssc.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 # 	... add above this line ...
Index: linux-2.6.23/drivers/stm/Kconfig
===================================================================
--- linux-2.6.23.orig/drivers/stm/Kconfig	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/drivers/stm/Kconfig	2008-04-29 15:36:00.000000000 +0100
@@ -71,30 +71,6 @@
 
 endchoice
 
-config STM_SPI
-	bool "STM Serial Peripheral Interface"
-	---help---
-	  This driver is required to support the SPI Protocol
-
-config  STM_SPI_DEBUG
-        bool "STM SPI Debug"
-        depends on STM_SPI
-        default n
-        ---help---
-        Enable this option to print out information on STM SPI device driver
-
-config STM_SPI_CHAR_DEV
-	bool "STM SPI: add char device interface"
-	depends on STM_SPI
-	---help---
-	Enable this option to add the device file interface
-
-config STM_SPI_HW_FIFO
-	bool "STM SPI: hardware Fifo support"
-	depends on STM_SPI
-	---help---
-	Enable this option to add the ssc-hardware fifo support
-
 config STM_COPROCESSOR_SUPPORT
 	bool "STMicroelectronics coprocessor support"
 	default y
Index: linux-2.6.23/drivers/stm/Makefile
===================================================================
--- linux-2.6.23.orig/drivers/stm/Makefile	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/drivers/stm/Makefile	2008-04-29 15:36:00.000000000 +0100
@@ -5,7 +5,6 @@
 obj-y				+= sysconf.o
 obj-$(CONFIG_STM_DMA)		+= 710x_fdma2.o
 obj-$(CONFIG_STM_PIO)		+= pio.o
-obj-$(CONFIG_STM_SPI)		+= stm_spi.o
 obj-$(CONFIG_STM_COPROCESSOR_SUPPORT)	+= copro-st_socs.o
 obj-$(CONFIG_STM_COPROCESSOR)		+= stm-coprocessor.o
 obj-$(CONFIG_STM_COPROCESSOR_FRMW)	+= stm-coprocessor_frmw.o
Index: linux-2.6.23/drivers/stm/stm_spi.c
===================================================================
--- linux-2.6.23.orig/drivers/stm/stm_spi.c	2008-04-17 13:15:37.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,1011 +0,0 @@
-/*
-   -------------------------------------------------------------------------
-   stm_spi.c
-   -------------------------------------------------------------------------
-   STMicroelectronics
-   Version: 2.0 (1 April 2007)
-   ----------------------------------------------------------------------------
-   May be copied or modified under the terms of the GNU General Public
-   License V.2.  See linux/COPYING for more information.
-
-   ------------------------------------------------------------------------- */
-
-#include "stm_spi.h"
-#include <linux/stm/pio.h>
-#include <linux/stm/soc.h>
-#include <asm/semaphore.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <linux/clk.h>
-#include <linux/wait.h>
-#include <asm/uaccess.h>
-#include <asm/param.h>		/* for HZ */
-
-#undef dgb_print
-
-#ifdef  CONFIG_STM_SPI_DEBUG
-#define SPI_LOOP_DEBUG
-#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
-#else
-#define dgb_print(fmt, args...)
-#endif
-
-#define NANOSEC_PER_SEC         1000000000
-
-#define SPI_LINE_SHIFT      0x0
-#define SPI_BANK_SHIFT      0x3
-#define SPI_MODE_SHIFT      0x7
-
-#define SPI_LINE_MASK       0x7
-#define SPI_BANK_MASK       0xf
-#define SPI_MODE_MASK       0x1
-#define SPI_DEVICE_MASK     0xff
-
-#define spi_get_mode(address)       ( (address >> SPI_MODE_SHIFT) & SPI_MODE_MASK )
-#define spi_get_bank(address)       ( (address >> SPI_BANK_SHIFT) & SPI_BANK_MASK )
-#define spi_get_line(address)       ( (address >> SPI_LINE_SHIFT) & SPI_LINE_MASK )
-#define spi_get_device(address)     (  address & SPI_DEVICE_MASK )
-
-enum spi_state_machine_e {
-	SPI_FSM_VOID = 0,
-	SPI_FSM_PREPARE,
-	SPI_FSM_RUNNING,
-	SPI_FSM_STOP,
-	SPI_FSM_COMPLETE,
-	SPI_FSM_ABORT
-};
-
-#define SPI_PHASE_MASK            0x01
-#define SPI_PHASE_HIGH            0x01
-#define SPI_PHASE_LOW             0x00
-
-#define SPI_POLARITY_MASK         0x02
-#define SPI_POLARITY_HIGH         0x02
-#define SPI_POLARITY_LOW          0x00
-
-#define SPI_MSB_MASK              0x04
-#define SPI_MSB                   0x04
-#define SPI_LSB                   0x00
-
-#define SPI_FULLDUPLEX_MASK       0x08
-#define SPI_FULLDUPLEX            0x08
-#define SPI_HALFDUPLEX            0x00
-
-#define SPI_WIDE_MASK             0x10
-#define SPI_WIDE_16BITS           0x10
-#define SPI_WIDE_8BITS            0x00
-
-#define SPI_CSACTIVE_MASK         0x20
-#define SPI_CSACTIVE_HIGH         0x20
-#define SPI_CSACTIVE_LOW          0x00
-
-#define SPI_BAUDRATE_MASK         0xffff0000
-#define SPI_BAUDRATE_SHIFT        0x10
-
-/*
- *  * Virtual Configuration *
- *
- *  [  0: POLARITY  :0]
- *  [  1: PHASE     :1]
- *  [  2: MSB       :2]
- *  [  3: FULL/HALF :3]
- *  [  4: WIDE      :4]
- *  [  5: CS_ACTIVE :5]
- *  [ 15: FREE      :6]
- *  [ 31: BAUDRATE  :16]
- *
- */
-
-struct spi_transaction_t {
-	struct spi_client_t *client;	/* the transaction's owner */
-	enum spi_state_machine_e state;
-	enum spi_state_machine_e next_state;
-	unsigned int msg_length;
-	unsigned int idx_write;
-	unsigned int idx_read;
-};
-
-/*
- *  In this way i can manage no more than 5 bus spi
- *  but 5 it's enough for our platform
- */
-#define MAX_NUMBER_SPI_BUSSES 5
-/*
- *  This array is used to speed up the
- *  open device file
- */
-struct spi_device_t *spi_busses_array[MAX_NUMBER_SPI_BUSSES];
-/*
- * In this way the spi bus will be available
- * with the spi_busses_array array
- */
-
-#define jump_on_fsm_complete(trsc)	{ (trsc)->state = SPI_FSM_COMPLETE;	\
-					 goto be_fsm_complete;}
-
-#define jump_on_fsm_abort(trsc)		{ (trsc)->state = SPI_FSM_ABORT;	\
-					 goto be_fsm_abort;}
-
-static int spi_state_machine(int this_irq,struct spi_device_t *ssc_bus)
-{
-	struct spi_transaction_t *transaction = ssc_bus->trns;
-	struct spi_client_t *client = transaction->client;
-	unsigned short status;
-	short tx_fifo_status;
-	short rx_fifo_status;
-	unsigned int config = client->config;
-	unsigned int phase, polarity;
-	unsigned int hb;
-	unsigned int wide_frame = (config & SPI_WIDE_MASK) ? 1 : 0;
-
-	union {
-		char bytes[2];
-		short word;
-	} tmp = {.word = 0,};
-
-	transaction->state = transaction->next_state;
-
-	dgb_print("\n");
-	switch (transaction->state) {
-	case SPI_FSM_PREPARE:
-		dgb_print("-SPI_FSM_PREPARE\n");
-		phase    = ((config & SPI_PHASE_MASK) ? 1 : 0);
-		polarity = ((config & SPI_POLARITY_MASK) ? 1 : 0);
-		hb       = ((config & SPI_MSB_MASK) ? 1 : 0);
-		wide_frame = ((config & SPI_WIDE_MASK) ? 1 : 0) * 0x8 + 0x7;
-
-		ssc_store32(ssc_bus, SSC_BRG,
-			    (config & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
-
-		ssc_store32(ssc_bus, SSC_CTL, SSC_CTL_SR | 0x1);
-		ssc_store32(ssc_bus, SSC_I2C, 0x0);
-		ssc_store32(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
-			    (SSC_CTL_PO * polarity) |
-			    (SSC_CTL_PH * phase) | (SSC_CTL_HB * hb) |
-#ifdef SPI_LOOP_DEBUG
-			    SSC_CTL_LPB |
-#endif
-#ifdef CONFIG_STM_SPI_HW_FIFO
-			    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO |
-#endif
-			    wide_frame);
-
-		transaction->next_state = SPI_FSM_RUNNING;
-		ssc_load32(ssc_bus, SSC_RBUF);	/* only to clear the status register */
-#ifdef CONFIG_STM_SPI_HW_FIFO
-		for (tx_fifo_status = 0;
-		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
-		     transaction->idx_write < transaction->msg_length;
-		     ++tx_fifo_status)
-#endif
-		{
-			if (wide_frame > 0x7) {
-				dgb_print(" Writing %c %c\n",
-					  client->wr_buf[transaction->
-							 idx_write * 2],
-					  client->wr_buf[transaction->
-							 idx_write * 2 + 1]);
-				tmp.bytes[1] =
-				    client->wr_buf[transaction->idx_write * 2];
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write * 2 +
-						   1];
-			} else {
-				dgb_print(" Writing %c\n",
-					  client->wr_buf[transaction->
-							 idx_write]);
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write];
-			}
-			++transaction->idx_write;
-			ssc_store32(ssc_bus, SSC_TBUF, tmp.word);
-		}
-		ssc_store32(ssc_bus, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_RIEN);
-		break;
-
-	case SPI_FSM_RUNNING:
-		status = ssc_load32(ssc_bus, SSC_STA);
-		dgb_print(" SPI_FSM_RUNNING 0x%x\n", status);
-#ifndef CONFIG_STM_SPI_HW_FIFO
-		if ((status & SSC_STA_RIR) &&
-		    transaction->idx_read < transaction->msg_length) {
-#else
-		for (rx_fifo_status = ssc_load32(ssc_bus, SSC_RX_FSTAT);
-		     rx_fifo_status &&
-		     transaction->idx_read < transaction->msg_length;
-		     --rx_fifo_status) {
-#endif
-			tmp.word = ssc_load32(ssc_bus, SSC_RBUF);
-			if (wide_frame) {
-				client->rd_buf[transaction->idx_read * 2] =
-				    tmp.bytes[1];
-				client->rd_buf[transaction->idx_read * 2 + 1] =
-				    tmp.bytes[0];
-				dgb_print(" Reading: %c %c\n", tmp.bytes[1],
-					  tmp.bytes[0]);
-			} else {
-				client->rd_buf[transaction->idx_read] =
-				    tmp.bytes[0];
-				dgb_print(" Reading: %c\n", tmp.bytes[0]);
-			}
-			++transaction->idx_read;
-		}
-#ifndef CONFIG_STM_SPI_HW_FIFO
-		if ((status & SSC_STA_TIR)
-		    && transaction->idx_write < transaction->msg_length) {
-#else
-		for (tx_fifo_status = ssc_load32(ssc_bus, SSC_TX_FSTAT);
-		     tx_fifo_status < SSC_TXFIFO_SIZE - 1 &&
-		     transaction->idx_write < transaction->msg_length;
-		     ++tx_fifo_status) {
-#endif
-			if (wide_frame) {
-				dgb_print(" Writing %c %c\n",
-					  client->wr_buf[transaction->
-							 idx_write * 2],
-					  client->wr_buf[transaction->
-							 idx_write * 2 + 1]);
-				tmp.bytes[1] =
-				    client->wr_buf[transaction->idx_write * 2];
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write * 2 +
-						   1];
-			} else {
-				dgb_print(" Writing %c\n",
-					  client->wr_buf[transaction->
-							 idx_write]);
-				tmp.bytes[0] =
-				    client->wr_buf[transaction->idx_write];
-			}
-			++transaction->idx_write;
-			ssc_store32(ssc_bus, SSC_TBUF, tmp.word);
-		}
-
-		if (transaction->idx_write >= transaction->msg_length &&
-		    transaction->idx_read >= transaction->msg_length)
-			jump_on_fsm_complete(transaction);
-		break;
-	case SPI_FSM_COMPLETE:
-	      be_fsm_complete:
-		dgb_print(" SPI_FSM_COMPLETE\n");
-		ssc_store32(ssc_bus, SSC_IEN, 0x0);
-		wake_up(&(ssc_bus->wait_queue));
-		break;
-
-	case SPI_FSM_VOID:
-	default:
-		;
-	}
-	return IRQ_HANDLED;
-}
-
-#define chip_asserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
-			     stpio_set_pin((client)->pio_chip, 0x1);		\
-			else stpio_set_pin((client)->pio_chip, 0x0);
-
-#define chip_deasserted(client) if ((client)->config & SPI_CSACTIVE_MASK )	\
-			       stpio_set_pin((client)->pio_chip, 0x0);		\
-			  else stpio_set_pin((client)->pio_chip, 0x1);
-
-int spi_write(struct spi_client_t *client, char *wr_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct spi_device_t *spi_bus =client->dev;
-	struct spi_transaction_t transaction = {.client = client,
-
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	dgb_print("\n");
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	mutex_lock(&spi_bus->mutex_bus);
-	chip_asserted(client);
-
-	client->rd_buf = kmalloc(count, GFP_KERNEL);
-	client->wr_buf = wr_buffer;
-	if (client->config & SPI_WIDE_MASK)
-		transaction.msg_length >>= 1;
-
-	spi_bus->trns = &transaction;
-	spi_state_machine(NULL,spi_bus);
-	timeout = wait_event_interruptible_timeout(spi_bus->wait_queue,
-						   (transaction.state == SPI_FSM_COMPLETE),
-						   client->timeout * HZ);
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(NULL,spi_bus);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI write\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-	mutex_unlock(&spi_bus->mutex_bus);
-	kfree(client->rd_buf);
-	client->rd_buf = NULL;
-	client->wr_buf = NULL;
-	return result;
-}
-
-int spi_read(struct spi_client_t *client, char *rd_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct spi_device_t *spi_bus =client->dev;
-	unsigned int wide_frame =
-	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
-	struct spi_transaction_t transaction = {.client = client,
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	/*
-	 * the first step is request the bus access
-	 */
-	mutex_lock(&spi_bus->mutex_bus);
-
-	chip_asserted(client);
-
-#ifdef SPI_LOOP_DEBUG
-#define DUMMY   "dummy_string_only_for_test"
-	count = strlen(DUMMY);
-#endif
-
-	client->rd_buf = rd_buffer;
-	client->wr_buf = (char *)kmalloc(count, GFP_KERNEL);
-
-#ifdef SPI_LOOP_DEBUG
-	strcpy(client->wr_buf, DUMMY);
-#endif
-
-/*
- *  When the data frame is 16 bits long
- *  then msg_length must be %2=0
- *
- */
-	if (wide_frame)
-		transaction.msg_length >>= 1;	// frame oriented
-	spi_bus->trns=&transaction;
-	spi_state_machine(NULL,spi_bus);
-	timeout = wait_event_interruptible_timeout(spi_bus->wait_queue,
-						   (transaction.state == SPI_FSM_COMPLETE),
-						   client->timeout * HZ);
-
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(NULL,spi_bus);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in read wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-
-	mutex_unlock(&spi_bus->mutex_bus);
-	kfree(client->wr_buf);
-	client->rd_buf = NULL;
-	client->wr_buf = NULL;
-	return result;
-}
-
-int spi_write_then_read(struct spi_client_t *client, char *wr_buffer,
-			char *rd_buffer, size_t count)
-{
-	unsigned long flag;
-	int timeout;
-	int result = (int)count;
-	struct spi_device_t *spi_bus =client->dev;
-	struct spi_transaction_t transaction = {.client = client,
-		.msg_length = count,
-		.next_state = SPI_FSM_PREPARE,
-		.idx_write = 0,
-		.idx_read = 0,
-	};
-	dgb_print("\n");
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	mutex_lock(&spi_bus->mutex_bus);
-
-	chip_asserted(client);
-
-	client->rd_buf = rd_buffer;
-	client->wr_buf = wr_buffer;
-
-	if (client->config & SPI_WIDE_MASK)
-		transaction.msg_length >>= 1;	// frame oriented...
-
-	spi_bus->trns=&transaction;
-	spi_state_machine(NULL,spi_bus);
-	timeout = wait_event_interruptible_timeout(spi_bus->wait_queue,
-						  (transaction.state == SPI_FSM_COMPLETE),
-						  client->timeout * HZ);
-	if (timeout <= 0) {
-		/* Terminate transaction */
-		local_irq_save(flag);
-		transaction.next_state = SPI_FSM_COMPLETE;
-		spi_state_machine(NULL,spi_bus);
-		local_irq_restore(flag);
-
-		if (!timeout) {
-			printk(KERN_ERR "stm_spi: timeout during SPI read\n");
-			result = -ETIMEDOUT;
-		} else {
-			dgb_print
-			    ("stm_spi: interrupt or error in read wait event\n");
-			result = timeout;
-		}
-	}
-
-	chip_deasserted(client);
-	mutex_unlock(&spi_bus->mutex_bus);
-
-	return count;
-}
-
-struct spi_client_t *spi_create_client(int bus_number)
-{
-	struct spi_client_t *client;
-
-	dgb_print("\n");
-
-	if (bus_number >= MAX_NUMBER_SPI_BUSSES)
-		return NULL;
-	if (!spi_busses_array[bus_number])
-		return NULL;
-	client =
-	    (struct spi_client_t *)kzalloc(sizeof(struct spi_client_t),
-					   GFP_KERNEL);
-	if (!client)
-		return NULL;
-	client->dev = spi_busses_array[bus_number];
-	client->timeout = 5;	/* 5 seconds */
-/*
- *  1 Phase
- *  1 Polarity
- *  1 Heading
- *  - Full/Half
- *  1 Wide (16bits)
- *  0 CSActive
- *  1 MHz (at 100MHz of common clock)
- */
-	client->config = 0x420017;
-
-	return client;
-}
-
-int spi_client_release(struct spi_client_t *client)
-{
-	dgb_print("\n");
-	if (!client)
-		return 0;
-	if (client->pio_chip != NULL) {
-		stpio_free_pin(client->pio_chip);
-		client->pio_chip = NULL;
-	}
-	dgb_print("PIO-chip released\n");
-	if (client->rd_buf != NULL)
-		kfree(client->rd_buf);
-	kfree(client);
-	return 1;
-}
-
-int spi_client_addressing(struct spi_client_t *client, unsigned int slave_address)
-{
-	unsigned int spi_device;
-
-	spi_device = spi_get_device(slave_address);
-
-	dgb_print("Spi opening Slave 0x%x (%d)\n", spi_device, spi_device);
-
-/* 1. release the Pio of previous addressing*/
-	if (client->pio_chip)
-		stpio_free_pin(client->pio_chip);
-	client->pio_chip = NULL;
-// 2. check if the pio[BANK][LINE] used for chip_selector is free
-	client->pio_chip =
-	    stpio_request_pin(spi_get_bank(slave_address),
-			      spi_get_line(slave_address), "spi-chip-selector",
-			      STPIO_OUT);
-
-	if (!(client->pio_chip)) {
-/*
- * Somebody already requested the PIO[bank][line]
- * therefore we abort the addressing
- */
-		dgb_print("Error Pio locked or not-exist\n");
-		return -ENOSYS;
-	}
-	dgb_print("->with PIO [%d][%d]\n", spi_get_bank(slave_address),
-		  spi_get_line(slave_address));
-
-	client->config &= ~SPI_FULLDUPLEX;
-	dgb_print("->with FULLDUPLEX = 0x%x\n", spi_get_mode(slave_address));
-	client->config |= ( SPI_FULLDUPLEX * spi_get_mode(slave_address));
-/*
- *  Free the data of prev addressing
- */
-	if (client->rd_buf != NULL)
-		kfree(client->rd_buf);
-
-	client->rd_buf = NULL;
-	chip_deasserted(client);
-
-	return 0;
-
-}
-
-int spi_client_control(struct spi_client_t *client, int cmd, int arg)
-{
-	dgb_print("\n");
-	switch (cmd) {
-	case SPI_IOCTL_WIDEFRAME:
-		client->config &= ~SPI_WIDE_MASK;
-		if (arg)
-			client->config |= SPI_WIDE_16BITS;
-		break;
-	case SPI_IOCTL_POLARITY:
-		client->config &=  ~SPI_POLARITY_MASK;
-		if (arg)
-			client->config |= SPI_POLARITY_HIGH;
-		break;
-	case SPI_IOCTL_PHASE:
-		client->config &= ~SPI_PHASE_MASK;
-		if (arg)
-			client->config |= SPI_PHASE_HIGH;
-		break;
-	case SPI_IOCTL_HEADING:
-		client->config &= ~SPI_MSB_MASK;
-		if (arg)
-			client->config |= SPI_MSB;
-		break;
-	case SPI_IOCTL_BUADRATE:
-		{
-			unsigned long baudrate;
-			baudrate = clk_get_rate(clk_get(NULL,"comms_clk")) / (2 * arg);
-			client->config &= ~SPI_BAUDRATE_MASK;
-			client->config |= (baudrate << SPI_BAUDRATE_SHIFT);
-		}
-		break;
-	case SPI_IOCTL_CSACTIVE:
-		client->config &= ~SPI_CSACTIVE_MASK;
-		if (arg)
-			client->config |= SPI_CSACTIVE_HIGH;
-		break;
-	case SPI_IOCTL_ADDRESS:
-		if (spi_client_addressing(client, (unsigned int)arg) != 0)
-			return -1;
-		break;
-	case SPI_IOCTL_TIMEOUT:
-		client->timeout = arg;
-		break;
-	default:
-		;
-	}
-#ifdef SPI_STM_DEBUG
-	{
-		unsigned int conf = client->config;
-		dgb_print("SPI - Virtual Config:\n");
-		dgb_print(" - PHASE:    0x%x\n", (conf & SPI_PHASE_MASK) != 0);
-		dgb_print(" - POLARITY: 0x%x\n",
-			  (conf & SPI_POLARITY_MASK) != 0);
-		dgb_print(" - HEADING:  0x%x\n", (conf & SPI_MSB_MASK) != 0);
-		dgb_print(" - FULLDUP:  0x%x\n",
-			  (conf & SPI_FULLDUPLEX_MASK) != 0);
-		dgb_print(" - WIDE:     0x%x\n", (conf & SPI_WIDE_MASK) != 0);
-		dgb_print(" - CSACTIVE: 0x%x\n",
-			  (conf & SPI_CSACTIVE_MASK) != 0);
-		dgb_print(" - BUADRATE: 0x%x\n",
-			  (conf & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
-	}
-#endif
-
-}
-
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-#define SPI_MAJOR 153
-static struct class *spi_dev_class;
-static struct cdev spi_cdev;
-
-static ssize_t spi_cdev_read(struct file *filp,
-			     char __user * buff, size_t count, loff_t * offp)
-{
-	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
-	unsigned int wide_frame =
-	    (client->config & SPI_WIDE_MASK) ? 1 : 0;
-	char *read_buffer;
-
-	if (client->pio_chip == NULL)
-		return -ENODATA;
-
-	if (client->config & SPI_FULLDUPLEX_MASK) {
-/*
- * In FullDuplex Mode
- * The Datas are already ready...
- */
-		if (!client->rd_buf)
-			return 0;
-		dgb_print("Reading in FullD\n");
-		if (wide_frame)
-			count &= ~0x1;
-		copy_to_user(buff, client->rd_buf, count);
-		kfree(client->rd_buf);
-		client->rd_buf = NULL;
-		return count;
-	}
-
-	dgb_print("Reading in Half/D %d bytes\n", count);
-	read_buffer = (char *)kmalloc(count, GFP_KERNEL);
-	spi_read(client, read_buffer, count);
-	copy_to_user(buff, read_buffer, count);
-	kfree(read_buffer);
-	return count;
-}
-
-static ssize_t spi_cdev_write(struct file *filp,
-			      const char __user * buff,
-			      size_t count, loff_t * offp)
-{
-	struct spi_client_t *client = (struct spi_client_t *)filp->private_data;
-	char *wr_buffer;
-	char *rd_buffer;
-	int result;
-	dgb_print("\n");
-
-	wr_buffer = kmalloc(count, GFP_KERNEL);
-	if (!wr_buffer)
-		return -ENOMEM;
-	rd_buffer = kmalloc(count, GFP_KERNEL);
-	if (!rd_buffer){
-		kfree(wr_buffer);
-		return -ENOMEM;
-	}
-
-	copy_from_user(wr_buffer, buff, count);
-
-	result = spi_write_then_read(client, wr_buffer, rd_buffer, count);
-
-	if (result >= 0)
-		result = count;
-
-	if (!(client->config & SPI_FULLDUPLEX)) {
-#ifdef SPI_LOOP_DEBUG
-		dgb_print("Read: %s\n", rd_buffer);
-#endif
-		kfree(rd_buffer);
-		client->rd_buf = NULL;
-	}
-
-	return result;
-}
-
-static int spi_cdev_ioctl(struct inode *inode,
-			  struct file *filp, unsigned int cmd,
-			  unsigned long arg)
-{
-	dgb_print("\n");
-	spi_client_control((struct spi_client_t *)filp->private_data, cmd, arg);
-	return 0;
-}
-
-static int spi_cdev_open(struct inode *inode, struct file *filp)
-{
-	unsigned int minor;
-	struct spi_client_t *client;
-
-	dgb_print("\n");
-	minor = iminor(inode);
-	client = spi_create_client(minor);
-	filp->private_data = client;
-	if (client)
-		return 0;
-	else
-		return -ENODEV;
-}
-
-static int spi_cdev_release(struct inode *inode, struct file *filp)
-{
-	dgb_print("\n");
-	spi_client_release((struct spi_client_t *)filp->private_data);
-	filp->private_data = NULL;
-	return 0;
-}
-
-struct file_operations spi_fops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.open = spi_cdev_open,
-	.release = spi_cdev_release,
-	.read = spi_cdev_read,
-	.write = spi_cdev_write,
-	.ioctl = spi_cdev_ioctl
-};
-#endif
-
-static int spi_stm_match(struct device *dev, struct device_driver *drv)
-{
-	dgb_print("\n");
-	if (dev == NULL || drv == NULL)
-		return 0;
-	return !strncmp(dev->bus_id, drv->name, 3);
-}
-
-struct bus_type spi_bus_type = {
-	.name = "spi",
-	.match = spi_stm_match,
-};
-
-void spi_del_adapter(struct spi_device_t *spi_dev)
-{
-	dgb_print("\n");
-	spi_busses_array[spi_dev->idx_dev] = 0;
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	class_device_destroy(spi_dev_class, MKDEV(SPI_MAJOR, spi_dev->idx_dev));
-#endif
-	kfree(spi_dev);
-	return;
-}
-
-static int spi_bus_driver_probe(struct device *dev)
-{
-	struct spi_device_t *spi_dev;
-
-	dgb_print("\n");
-	spi_dev = container_of(dev, struct spi_device_t, dev);
-
-	return spi_dev->dev_type == SPI_DEV_BUS_ADAPTER;
-};
-
-static void spi_bus_driver_shutdown(struct device *dev)
-{
-	struct spi_device_t *spi_dev;
-	spi_dev = container_of(dev, struct spi_device_t, dev);
-	dgb_print("\n");
-	spi_del_adapter(spi_dev);
-	return;
-}
-static struct device_driver spi_bus_drv = {
-	.owner = THIS_MODULE,
-	.name = "spi_bus_drv",
-	.bus = &spi_bus_type,
-	.probe = spi_bus_driver_probe,
-	.shutdown = spi_bus_driver_shutdown,
-};
-
-int spi_add_adapter(struct spi_device_t *spi_dev)
-{
-	unsigned int ret;
-	unsigned int idx_dev = spi_dev->idx_dev;
-	struct device *dev;
-
-	dgb_print("\n");
-	spi_dev->dev_type = SPI_DEV_BUS_ADAPTER;
-	spi_dev->dev.bus = &(spi_bus_type);
-	sprintf(spi_dev->dev.bus_id, "spi-%d", idx_dev);
-	spi_dev->dev.driver = &spi_bus_drv;
-	ret = device_register(&spi_dev->dev);
-	if (ret) {
-		printk(KERN_WARNING "Unable to register %s bus\n",
-		       spi_dev->dev.bus_id);
-		kfree(spi_dev);
-	} else
-		spi_busses_array[idx_dev] = spi_dev;
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	dev = spi_dev->dev.parent;
-	spi_dev->class_dev = class_device_create(spi_dev_class, NULL,
-						 MKDEV(SPI_MAJOR,
-						 spi_dev->idx_dev), dev,
-						 "spi-%d", spi_dev->idx_dev);
-#endif
-	return ret;
-}
-
-static void __init spi_core_init(void)
-{
-	unsigned int ret;
-	dgb_print("\n");
-	ret = bus_register(&spi_bus_type);
-	if(ret){
-		printk(KERN_WARNING "Unable to register spi bus\n");
-		return ;
-		}
-	ret = driver_register(&spi_bus_drv);
-	if (ret) {
-		printk(KERN_WARNING "Unable to register spi driver\n");
-		return ;
-        }
-        printk(KERN_INFO "spi layer initialized\n");
-}
-
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-static void __init spi_cdev_init(void)
-{
-	dev_t ch_device;
-	dgb_print("\n");
-
-	spi_dev_class = class_create(THIS_MODULE, "spi-dev");
-	if (IS_ERR(spi_dev_class))
-		return 0;
-
-	ch_device = MKDEV(SPI_MAJOR, 0);
-	register_chrdev_region(ch_device, 255, "spi");
-	cdev_init(&(spi_cdev), &(spi_fops));
-	cdev_add(&(spi_cdev), ch_device, 255);
-	printk(KERN_INFO "spi /dev layer initialized\n");
-	return 0;
-}
-fs_initcall(spi_cdev_init);
-#endif
-#define NAME "spi_stm_probe"
-static int __init spi_stm_probe(struct platform_device *pdev)
-{
-	struct ssc_pio_t *pio_info =
-			(struct ssc_pio_t *)pdev->dev.platform_data;
-        struct resource *res;
-	struct spi_device_t *dev;
-
-	dev = devm_kzalloc(&pdev->dev,sizeof(struct spi_device_t), GFP_KERNEL);
-
-	if(!dev)
-		return -ENOMEM;
-
-	if (!(res=platform_get_resource(pdev, IORESOURCE_MEM, 0)))
-		return -ENODEV;
-	if (!devm_request_mem_region(&pdev->dev, res->start, res->end - res->start, "spi")){
-		printk(KERN_ERR NAME " Request mem 0x%x region not done\n",res->start);
-		return -ENOMEM;
-	}
-	if (!(dev->base =
-		devm_ioremap_nocache(&pdev->dev, res->start, res->end - res->start))){
-		printk(KERN_ERR NAME " Request iomem 0x%x region not done\n",res->start);
-		return -ENOMEM;
-	}
-	if (!(res=platform_get_resource(pdev, IORESOURCE_IRQ, 0))){
-		printk(KERN_ERR NAME " Request irq %d not done\n",res->start);
-		return -ENODEV;
-	}
-	if(devm_request_irq(&pdev->dev,res->start, spi_state_machine,
-		IRQF_DISABLED, "spi", dev)<0){
-		printk(KERN_ERR NAME " Request irq not done\n");
-		return -ENODEV;
-	}
-	pio_info->clk = stpio_request_pin(pio_info->pio_port,pio_info->pio_pin[0],
-                                "SPI Clock", STPIO_OUT);
-	if(!pio_info->clk){
-		printk(KERN_ERR "Faild to clk pin allocation\n");
-		return -ENODEV;
-	}
-	pio_info->sdout = stpio_request_pin(pio_info->pio_port,pio_info->pio_pin[1],
-				"SPI Data out", STPIO_OUT);
-	if(!pio_info->sdout){
-		printk(KERN_ERR "Faild to sda pin allocation\n");
-		stpio_free_pin(pio_info->clk);
-		return -ENODEV;
-		}
-	pio_info->sdin = stpio_request_pin(pio_info->pio_port,pio_info->pio_pin[2],
-				"SPI Data in", STPIO_IN);
-	if(!pio_info->sdin){
-		printk(KERN_ERR "Faild to sdo pin allocation\n");
-		stpio_free_pin(pio_info->sdout);
-		stpio_free_pin(pio_info->clk);
-		return -ENODEV;
-		}
-
-	init_waitqueue_head(&dev->wait_queue);
-        mutex_init(&dev->mutex_bus);
-	dev->idx_dev = pdev->id;
-	dev->dev.parent = &pdev->dev;
-	pdev->dev.driver_data = dev;
-	if (spi_add_adapter(dev) < 0) {
-		printk(KERN_ERR
-			"spi/stm: The SPI Core refuses the spi/stm adapter\n");
-		return -ENODEV;
-	}
-	return 0;
-}
-
-static int  spi_stm_remove(struct platform_device *pdev)
-{
-	struct ssc_pio_t *pio_info =
-			(struct ssc_pio_t *)pdev->dev.platform_data;
-        struct resource *res;
-        struct spi_device_t *dev = pdev->dev.driver_data;
-
-	spi_del_adapter(dev);
-	devm_iounmap(&pdev->dev,dev->base);
-	devm_free_irq(&pdev->dev,res->start, dev);
-	devm_kfree(&pdev->dev,dev);
-	stpio_free_pin(pio_info->sdin);
-	stpio_free_pin(pio_info->clk);
-	stpio_free_pin(pio_info->sdout);
-        return 0;
-}
-
-#ifdef CONFIG_PM
-static int spi_stm_suspend(struct platform_device *pdev,pm_message_t state)
-{
-	struct spi_device_t *dev = pdev->dev.driver_data;
-	return 0;
-}
-
-static int spi_stm_resume(struct platform_device *pdev)
-{
-	struct spi_device_t *dev = pdev->dev.driver_data;
-	return 0;
-}
-#else
-#define spi_stm_suspend		NULL
-#define spi_stm_resume		NULL
-#endif
-
-static struct platform_driver spi_hw_driver = {
-        .driver.name = "spi_st",
-        .driver.owner = THIS_MODULE,
-        .probe = spi_stm_probe,
-        .remove = spi_stm_remove,
-	.suspend = spi_stm_suspend,
-	.resume = spi_stm_resume,
-};
-
-
-static int __init spi_init(void)
-{
-        platform_driver_register(&spi_hw_driver);
-        return 0;
-}
-
-static int __exit spi_exit(void)
-{
-	dev_t ch_device;
-
-	dgb_print("\n");
-#ifdef CONFIG_STM_SPI_CHAR_DEV
-	ch_device = MKDEV(SPI_MAJOR, 0);
-	cdev_del(&(spi_cdev));
-	unregister_chrdev_region(ch_device, 255);
-#endif
-
-	driver_unregister(&spi_bus_drv);
-	bus_unregister(&spi_bus_type);
-	return 0;
-}
-
-subsys_initcall(spi_core_init);
-module_init(spi_init);
-module_exit(spi_exit);
-
-MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
-MODULE_DESCRIPTION("Module for stm spi device");
-MODULE_LICENSE("GPL");
Index: linux-2.6.23/drivers/stm/stm_spi.h
===================================================================
--- linux-2.6.23.orig/drivers/stm/stm_spi.h	2008-04-17 13:15:37.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,111 +0,0 @@
-/*
-   --------------------------------------------------------------------
-
-   stm_spi.h
-   define and struct for SPI device driver
-   based on STMicroelectronics SSC device
-
-   --------------------------------------------------------------------
-
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
-
-*/
-#ifndef STM_SPI
-#define STM_SPI
-
-#define SPI_IOCTL_WIDEFRAME     0x01
-#define SPI_ARG_WIDE_16BITS     0x01
-#define SPI_ARG_WIDE_8BITS      0x00
-
-#define SPI_IOCTL_PHASE         0x02
-#define SPI_ARG_PHASE_HIGH      0x01
-#define SPI_ARG_PHASE_LOW       0x00
-
-#define SPI_IOCTL_POLARITY      0x04
-#define SPI_ARG_POLARITY_HIGH   0x01
-#define SPI_ARG_POLARIT_LOWY    0x00
-
-#define SPI_IOCTL_HEADING       0x08
-#define SPI_ARG_HEADING_MSB     0x01
-#define SPI_ARG_HEADING_LSB     0x00
-
-#define SPI_IOCTL_CSACTIVE      0x10
-#define SPI_ARG_CSACTIVE_HIGH   0x01
-#define SPI_ARG_CSACTIVE_LOW    0x00
-
-#define SPI_IOCTL_BUADRATE      0x20
-
-#define SPI_IOCTL_ADDRESS       0x40
-
-#define SPI_IOCTL_TIMEOUT       0x80
-
-/*#define SPI_IOCTL_NOSELECTION   0x100*/
-
-
-#ifdef __KERNEL__
-#include <linux/stm/stssc.h>
-#include <linux/device.h>
-#include <linux/wait.h>
-#include <linux/mutex.h>
-
-extern struct bus_type spi_bus_type;
-
-#define SPI_DEV_BUS_ADAPTER      0x01
-#define SPI_DEV_CLIENT_ADAPTER   0x02
-
-struct spi_transaction_t;
-
-struct spi_device_t {
-	unsigned int idx_dev;
-        unsigned int dev_type; /* SPI_DEV_BUS_ADAPTER xor SPI_DEV_CLIENT_ADAPTER*/
-	struct device dev;
-	struct class_device *class_dev;
-	unsigned long base;
-	struct mutex      mutex_bus;
-        wait_queue_head_t wait_queue;
-	struct spi_transaction_t *trns;
-};
-
-struct spi_client_t {
-	struct spi_device_t *dev;       /* the bus device used */
-	struct stpio_pin *pio_chip;
-	char *wr_buf;
-	char *rd_buf;
-	unsigned long config;		/* the clinet configuration */
-	unsigned long timeout;
-};
-
-struct spi_client_t* spi_create_client(int bus_number);
-
-int spi_client_release(struct spi_client_t* spi);
-
-int spi_client_control(struct spi_client_t* spi, int cmd, int arg);
-
-int spi_write(struct spi_client_t* spi, char *wr_buffer, size_t count);
-
-int spi_read(struct spi_client_t* spi, char *rd_buffer, size_t count);
-
-int spi_write_then_read(struct spi_client_t* spi,char *wr_buffer,
-			char *rd_buffer, size_t count);
-
-#endif
-
-#endif
Index: linux-2.6.23/include/linux/stm/soc.h
===================================================================
--- linux-2.6.23.orig/include/linux/stm/soc.h	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/include/linux/stm/soc.h	2008-04-29 15:36:00.000000000 +0100
@@ -35,6 +35,21 @@
 	unsigned short		capability;	/* bitmask on the ssc capability */
 };
 
+#define SPI_LINE_SHIFT		0x0
+#define SPI_LINE_MASK		0x7
+#define SPI_BANK_SHIFT		0x3
+#define SPI_BANK_MASK		0xf
+#define spi_get_bank(address)  (((address) >> SPI_BANK_SHIFT) & SPI_BANK_MASK)
+#define spi_get_line(address)  (((address) >> SPI_LINE_SHIFT) & SPI_LINE_MASK)
+#define spi_set_cs(bank, line) ((((bank) & SPI_BANK_MASK) << SPI_BANK_SHIFT) | \
+				 (((line) & SPI_LINE_MASK) << SPI_LINE_SHIFT))
+/* each spi bus is able to manage 'all' the pios as chip selector
+   therefore each master must have 8(pioline)x10(piobank)
+   10 pio banks is enough for our boards
+   SPI_NO_CHIPSELECT to specify SPI device with no CS (ie CS tied to 'active')
+*/
+#define SPI_NO_CHIPSELECT	(spi_set_cs(9, 7) + 1)
+
 
 /* Private data for the SATA driver */
 struct plat_sata_data {
Index: linux-2.6.23/include/linux/stm/stssc.h
===================================================================
--- linux-2.6.23.orig/include/linux/stm/stssc.h	2008-04-17 13:15:37.000000000 +0100
+++ linux-2.6.23/include/linux/stm/stssc.h	2008-04-29 15:36:00.000000000 +0100
@@ -1,11 +1,11 @@
 /*
-   --------------------------------------------------------------------
-
-   stssc.h
-   define and struct for STMicroelectronics SSC device
-
-   --------------------------------------------------------------------
-
+ *  --------------------------------------------------------------------------
+ *
+ *  stssc.h
+ *  define and struct for STMicroelectronics SSC device
+ *
+ *  --------------------------------------------------------------------------
+ *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
  *  Free Software Foundation;  either version 2 of the  License.
@@ -13,8 +13,8 @@
  *  You should have received a copy of the  GNU General Public License along
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
-
-*/
+ *  --------------------------------------------------------------------------
+ */
 
 #ifndef STM_SSC_H
 #define STM_SSC_H 1
@@ -131,11 +131,13 @@
 
 #define SSC_TXFIFO_SIZE         0x8
 #define SSC_RXFIFO_SIZE         0x8
-/*
-   we have to use the following macro
-   to access the SSC I/O Memory
-*/
-#define ssc_store32(ssc , offset, value) iowrite32(value,ssc->base+offset)
-#define ssc_load32( ssc,offset)	         ioread32( ssc->base+offset)
+
+/* Use the following macros to access SSC I/O memory */
+#define ssc_store32(ssc, offset, value)	iowrite32(value, ssc->base+offset)
+#define ssc_store16(ssc, offset, value)	iowrite16(value, ssc->base+offset)
+#define ssc_store8(ssc, offset, value)	iowrite8(value, ssc->base+offset)
+#define ssc_load32(ssc, offset)		ioread32(ssc->base+offset)
+#define ssc_load16(ssc, offset)		ioread16(ssc->base+offset)
+#define ssc_load8(ssc, offset)		XSioread8(ssc->base+offset)
 
 #endif				/* STM_SSC_H */
