diff -Naur linux-2.6.17.8/arch/i386/Kconfig linux-2.6.17.8-sh/arch/i386/Kconfig
--- linux-2.6.17.8/arch/i386/Kconfig	2006-08-21 14:42:22.503772000 +0100
+++ linux-2.6.17.8-sh/arch/i386/Kconfig	2006-08-23 13:29:32.064438000 +0100
@@ -610,6 +610,15 @@
 	  If you are not sure, say Y; apart from resulting in a 66 KB bigger
 	  kernel, it won't hurt.
 
+config BIGPHYS_AREA
+	bool "Support for big physical area reservation"
+	---help---
+	  Enables kernel support for reserving large areas of physical memory
+	  at boot-time for use by certain device drivers (such as video
+	  framegrabbers, etc.) which require it. To use this feature, boot
+	  the kernel with the boot-time option 'bigphysarea=nnn' where
+	  'nnn' is the number of pages (a page is usually 4K) to reserve.
+
 config MTRR
 	bool "MTRR (Memory Type Range Register) support"
 	---help---
diff -Naur linux-2.6.17.8/arch/sh/boards/dreamcast/irq.c linux-2.6.17.8-sh/arch/sh/boards/dreamcast/irq.c
--- linux-2.6.17.8/arch/sh/boards/dreamcast/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/dreamcast/irq.c	2006-08-23 13:29:14.000024000 +0100
@@ -26,10 +26,10 @@
    event.
 
    There are three 32-bit ESRs located at 0xa05f8900 - 0xa05f6908.  Event
-   types can be found in include/asm-sh/dc_sysasic.h.  There are three groups
-   of EMRs that parallel the ESRs.  Each EMR group corresponds to an IRQ, so
-   0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928 triggers
-   IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.
+   types can be found in include/asm-sh/dreamcast/sysasic.h. There are three
+   groups of EMRs that parallel the ESRs.  Each EMR group corresponds to an
+   IRQ, so 0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928
+   triggers IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.
 
    In the kernel, these events are mapped to virtual IRQs so that drivers can
    respond to them as they would a normal interrupt.  In order to keep this
diff -Naur linux-2.6.17.8/arch/sh/boards/dreamcast/rtc.c linux-2.6.17.8-sh/arch/sh/boards/dreamcast/rtc.c
--- linux-2.6.17.8/arch/sh/boards/dreamcast/rtc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/dreamcast/rtc.c	2006-08-23 13:29:26.936323000 +0100
@@ -1,4 +1,5 @@
-/* arch/sh/kernel/rtc-aica.c
+/*
+ * arch/sh/boards/dreamcast/rtc.c
  *
  * Dreamcast AICA RTC routines.
  *
@@ -10,15 +11,12 @@
  */
 
 #include <linux/time.h>
-
+#include <asm/rtc.h>
 #include <asm/io.h>
 
-extern void (*rtc_get_time)(struct timespec *);
-extern int (*rtc_set_time)(const time_t);
-
 /* The AICA RTC has an Epoch of 1/1/1950, so we must subtract 20 years (in
-   seconds to get the standard Unix Epoch when getting the time, and add 20
-   years when setting the time. */
+   seconds) to get the standard Unix Epoch when getting the time, and add
+   20 years when setting the time. */
 #define TWENTY_YEARS ((20 * 365LU + 5) * 86400)
 
 /* The AICA RTC is represented by a 32-bit seconds counter stored in 2 16-bit
@@ -32,7 +30,8 @@
  *
  * Grabs the current RTC seconds counter and adjusts it to the Unix Epoch.
  */
-void aica_rtc_gettimeofday(struct timespec *ts) {
+void aica_rtc_gettimeofday(struct timespec *ts)
+{
 	unsigned long val1, val2;
 
 	do {
@@ -55,7 +54,8 @@
  *
  * Adjusts the given @tv to the AICA Epoch and sets the RTC seconds counter.
  */
-int aica_rtc_settimeofday(const time_t secs) {
+int aica_rtc_settimeofday(const time_t secs)
+{
 	unsigned long val1, val2;
 	unsigned long adj = secs + TWENTY_YEARS;
 
@@ -75,7 +75,7 @@
 
 void aica_time_init(void)
 {
-	rtc_get_time = aica_rtc_gettimeofday;
-	rtc_set_time = aica_rtc_settimeofday;
+	rtc_sh_get_time = aica_rtc_gettimeofday;
+	rtc_sh_set_time = aica_rtc_settimeofday;
 }
 
diff -Naur linux-2.6.17.8/arch/sh/boards/dreamcast/setup.c linux-2.6.17.8-sh/arch/sh/boards/dreamcast/setup.c
--- linux-2.6.17.8/arch/sh/boards/dreamcast/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/dreamcast/setup.c	2006-08-23 13:29:17.552116000 +0100
@@ -25,18 +25,16 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/rtc.h>
 #include <asm/machvec.h>
-#include <asm/machvec_init.h>
 #include <asm/mach/sysasic.h>
 
 extern struct hw_interrupt_type systemasic_int;
-/* XXX: Move this into it's proper header. */
-extern void (*board_time_init)(void);
 extern void aica_time_init(void);
 extern int gapspci_init(void);
 extern int systemasic_irq_demux(int);
 
-void *dreamcast_consistent_alloc(struct device *, size_t, dma_addr_t *, int);
+void *dreamcast_consistent_alloc(struct device *, size_t, dma_addr_t *, gfp_t);
 int dreamcast_consistent_free(struct device *, size_t, void *, dma_addr_t);
 
 const char *get_system_type(void)
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/irq.c linux-2.6.17.8-sh/arch/sh/boards/harp/irq.c
--- linux-2.6.17.8/arch/sh/boards/harp/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/irq.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,148 +0,0 @@
-/* 
- * Copyright (C) 2000 David J. Mckay (david.mckay@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
- *
- * Looks after interrupts on the HARP board.
- *
- * Bases on the IPR irq system
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/harp/harp.h>
-
-
-#define NUM_EXTERNAL_IRQS 16
-
-// Early versions of the STB1 Overdrive required this nasty frig
-//#define INVERT_INTMASK_WRITES
-
-static void enable_harp_irq(unsigned int irq);
-static void disable_harp_irq(unsigned int irq);
-
-/* shutdown is same as "disable" */
-#define shutdown_harp_irq disable_harp_irq
-
-static void mask_and_ack_harp(unsigned int);
-static void end_harp_irq(unsigned int irq);
-
-static unsigned int startup_harp_irq(unsigned int irq)
-{
-	enable_harp_irq(irq);
-	return 0;		/* never anything pending */
-}
-
-static struct hw_interrupt_type harp_irq_type = {
-	.typename = "Harp-IRQ",
-	.startup = startup_harp_irq,
-	.shutdown = shutdown_harp_irq,
-	.enable = enable_harp_irq,
-	.disable = disable_harp_irq,
-	.ack = mask_and_ack_harp,
-	.end = end_harp_irq
-};
-
-static void disable_harp_irq(unsigned int irq)
-{
-	unsigned val, flags;
-	unsigned maskReg;
-	unsigned mask;
-	int pri;
-
-	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
-		return;
-
-	pri = 15 - irq;
-
-	if (pri < 8) {
-		maskReg = EPLD_INTMASK0;
-	} else {
-		maskReg = EPLD_INTMASK1;
-		pri -= 8;
-	}
-
-	local_irq_save(flags);
-	mask = ctrl_inl(maskReg);
-	mask &= (~(1 << pri));
-#if defined(INVERT_INTMASK_WRITES)
-	mask ^= 0xff;
-#endif
-	ctrl_outl(mask, maskReg);
-	local_irq_restore(flags);
-}
-
-static void enable_harp_irq(unsigned int irq)
-{
-	unsigned flags;
-	unsigned maskReg;
-	unsigned mask;
-	int pri;
-
-	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
-		return;
-
-	pri = 15 - irq;
-
-	if (pri < 8) {
-		maskReg = EPLD_INTMASK0;
-	} else {
-		maskReg = EPLD_INTMASK1;
-		pri -= 8;
-	}
-
-	local_irq_save(flags);
-	mask = ctrl_inl(maskReg);
-
-
-	mask |= (1 << pri);
-
-#if defined(INVERT_INTMASK_WRITES)
-	mask ^= 0xff;
-#endif
-	ctrl_outl(mask, maskReg);
-
-	local_irq_restore(flags);
-}
-
-/* This functions sets the desired irq handler to be an overdrive type */
-static void __init make_harp_irq(unsigned int irq)
-{
-	disable_irq_nosync(irq);
-	irq_desc[irq].handler = &harp_irq_type;
-	disable_harp_irq(irq);
-}
-
-static void mask_and_ack_harp(unsigned int irq)
-{
-	disable_harp_irq(irq);
-}
-
-static void end_harp_irq(unsigned int irq)
-{
-	enable_harp_irq(irq);
-}
-
-void __init init_harp_irq(void)
-{
-	int i;
-
-#if !defined(INVERT_INTMASK_WRITES)
-	// On the harp these are set to enable an interrupt
-	ctrl_outl(0x00, EPLD_INTMASK0);
-	ctrl_outl(0x00, EPLD_INTMASK1);
-#else
-	// On the Overdrive the data is inverted before being stored in the reg
-	ctrl_outl(0xff, EPLD_INTMASK0);
-	ctrl_outl(0xff, EPLD_INTMASK1);
-#endif
-
-	for (i = 0; i < NUM_EXTERNAL_IRQS; i++) {
-		make_harp_irq(i);
-	}
-}
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/led.c linux-2.6.17.8-sh/arch/sh/boards/harp/led.c
--- linux-2.6.17.8/arch/sh/boards/harp/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/led.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- * linux/arch/sh/stboards/led.c
- *
- * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * This file contains ST40STB1 HARP and compatible code.
- */
-
-#include <linux/config.h>
-#include <asm/io.h>
-#include <asm/harp/harp.h>
-
-/* Harp: Flash LD10 (front pannel) connected to EPLD (IC8) */
-/* Overdrive: Flash LD1 (front panel) connected to EPLD (IC4) */
-/* Works for HARP and overdrive */
-static void mach_led(int position, int value)
-{
-	if (value) {
-		ctrl_outl(EPLD_LED_ON, EPLD_LED);
-	} else {
-		ctrl_outl(EPLD_LED_OFF, EPLD_LED);
-	}
-}
-
-#ifdef CONFIG_HEARTBEAT
-
-#include <linux/sched.h>
-
-/* acts like an actual heart beat -- ie thump-thump-pause... */
-void heartbeat_harp(void)
-{
-	static unsigned cnt = 0, period = 0, dist = 0;
-
-	if (cnt == 0 || cnt == dist)
-		mach_led( -1, 1);
-	else if (cnt == 7 || cnt == dist+7)
-		mach_led( -1, 0);
-
-	if (++cnt > period) {
-		cnt = 0;
-		/* The hyperbolic function below modifies the heartbeat period
-		 * length in dependency of the current (5min) load. It goes
-		 * through the points f(0)=126, f(1)=86, f(5)=51,
-		 * f(inf)->30. */
-		period = ((672<<FSHIFT)/(5*avenrun[0]+(7<<FSHIFT))) + 30;
-		dist = period / 4;
-	}
-}
-#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/mach.c linux-2.6.17.8-sh/arch/sh/boards/harp/mach.c
--- linux-2.6.17.8/arch/sh/boards/harp/mach.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/mach.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-/*
- * linux/arch/sh/boards/harp/mach.c
- *
- * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Machine vector for the STMicroelectronics STB1 HARP and compatible boards
- */
-
-#include <linux/init.h>
-
-#include <asm/machvec.h>
-#include <asm/rtc.h>
-#include <asm/machvec_init.h>
-#include <asm/hd64465/io.h>
-#include <asm/hd64465/hd64465.h>
-
-void setup_harp(void);
-void init_harp_irq(void);
-void heartbeat_harp(void);
-
-/*
- * The Machine Vector
- */
-
-struct sh_machine_vector mv_harp __initmv = {
-	.mv_nr_irqs		= 89 + HD64465_IRQ_NUM,
-
-	.mv_inb			= hd64465_inb,
-	.mv_inw			= hd64465_inw,
-	.mv_inl			= hd64465_inl,
-	.mv_outb		= hd64465_outb,
-	.mv_outw		= hd64465_outw,
-	.mv_outl		= hd64465_outl,
-
-	.mv_inb_p		= hd64465_inb_p,
-	.mv_inw_p		= hd64465_inw,
-	.mv_inl_p		= hd64465_inl,
-	.mv_outb_p		= hd64465_outb_p,
-	.mv_outw_p		= hd64465_outw,
-	.mv_outl_p		= hd64465_outl,
-
-	.mv_insb		= hd64465_insb,
-	.mv_insw		= hd64465_insw,
-	.mv_insl		= hd64465_insl,
-	.mv_outsb		= hd64465_outsb,
-	.mv_outsw		= hd64465_outsw,
-	.mv_outsl		= hd64465_outsl,
-
-        .mv_isa_port2addr       = hd64465_isa_port2addr,
-
-#ifdef CONFIG_PCI
-	.mv_init_irq		= init_harp_irq,
-#endif
-#ifdef CONFIG_HEARTBEAT
-	.mv_heartbeat		= heartbeat_harp,
-#endif
-};
-
-ALIAS_MV(harp)
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/Makefile linux-2.6.17.8-sh/arch/sh/boards/harp/Makefile
--- linux-2.6.17.8/arch/sh/boards/harp/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-#
-# Makefile for STMicroelectronics board specific parts of the kernel
-#
-
-obj-y := irq.o setup.o mach.o led.o
-
-obj-$(CONFIG_PCI) += pcidma.o
-
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/pcidma.c linux-2.6.17.8-sh/arch/sh/boards/harp/pcidma.c
--- linux-2.6.17.8/arch/sh/boards/harp/pcidma.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/pcidma.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/* 
- * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
- *
- * Dynamic DMA mapping support.
- */
-
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-#include <asm/addrspace.h>
-
-
-void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
-			   dma_addr_t * dma_handle)
-{
-	void *ret;
-	int gfp = GFP_ATOMIC;
-
-	ret = (void *) __get_free_pages(gfp, get_order(size));
-
-	if (ret != NULL) {
-	        /* Is it neccessary to do the memset? */
-		memset(ret, 0, size);
-		*dma_handle = virt_to_bus(ret);
-	}
-	/* We must flush the cache before we pass it on to the device */
-	flush_cache_all();
-	return  P2SEGADDR(ret);
-}
-
-void pci_free_consistent(struct pci_dev *hwdev, size_t size,
-			 void *vaddr, dma_addr_t dma_handle)
-{
-        unsigned long p1addr=P1SEGADDR((unsigned long)vaddr);
-
-	free_pages(p1addr, get_order(size));
-}
diff -Naur linux-2.6.17.8/arch/sh/boards/harp/setup.c linux-2.6.17.8-sh/arch/sh/boards/harp/setup.c
--- linux-2.6.17.8/arch/sh/boards/harp/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/harp/setup.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/*
- * arch/sh/stboard/setup.c
- *
- * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * STMicroelectronics ST40STB1 HARP and compatible support.
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/io.h>
-#include <asm/harp/harp.h>
-
-const char *get_system_type(void)
-{
-	return "STB1 Harp";
-}
-
-/*
- * Initialize the board
- */
-int __init platform_setup(void)
-{
-#ifdef CONFIG_SH_STB1_HARP
-	unsigned long ic8_version, ic36_version;
-
-	ic8_version = ctrl_inl(EPLD_REVID2);
-	ic36_version = ctrl_inl(EPLD_REVID1);
-
-        printk("STMicroelectronics STB1 HARP initialisaton\n");
-        printk("EPLD versions: IC8: %d.%02d, IC36: %d.%02d\n",
-               (ic8_version >> 4) & 0xf, ic8_version & 0xf,
-               (ic36_version >> 4) & 0xf, ic36_version & 0xf);
-#elif defined(CONFIG_SH_STB1_OVERDRIVE)
-	unsigned long version;
-
-	version = ctrl_inl(EPLD_REVID);
-
-        printk("STMicroelectronics STB1 Overdrive initialisaton\n");
-        printk("EPLD version: %d.%02d\n",
-	       (version >> 4) & 0xf, version & 0xf);
-#else
-#error Undefined machine
-#endif
- 
-        /* Currently all STB1 chips have problems with the sleep instruction,
-         * so disable it here.
-         */
-	disable_hlt();
-
-	return 0;
-}
-
-/*
- * pcibios_map_platform_irq
- *
- * This is board specific and returns the IRQ for a given PCI device.
- * It is used by the PCI code (arch/sh/kernel/st40_pci*)
- *
- */
-
-#define HARP_PCI_IRQ    1
-#define HARP_BRIDGE_IRQ 2
-#define OVERDRIVE_SLOT0_IRQ 0
-
-
-int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	switch (slot) {
-#ifdef CONFIG_SH_STB1_HARP
-	case 2:		/*This is the PCI slot on the */
-		return HARP_PCI_IRQ;
-	case 1:		/* this is the bridge */
-		return HARP_BRIDGE_IRQ;
-#elif defined(CONFIG_SH_STB1_OVERDRIVE)
-	case 1:
-	case 2:
-	case 3:
-		return slot - 1;
-#else
-#error Unknown board
-#endif
-	default:
-		return -1;
-	}
-}
-
diff -Naur linux-2.6.17.8/arch/sh/boards/hp6xx/hp6xx_apm.c linux-2.6.17.8-sh/arch/sh/boards/hp6xx/hp6xx_apm.c
--- linux-2.6.17.8/arch/sh/boards/hp6xx/hp6xx_apm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/hp6xx/hp6xx_apm.c	2006-08-23 13:29:22.642232000 +0100
@@ -0,0 +1,123 @@
+/*
+ * bios-less APM driver for hp680
+ *
+ * Copyright 2005 (c) Andriy Skulysh <askulysh@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/apm_bios.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/apm.h>
+#include <asm/adc.h>
+#include <asm/hp6xx/hp6xx.h>
+
+#define SH7709_PGDR			0xa400012c
+
+#define APM_CRITICAL			10
+#define APM_LOW				30
+
+#define HP680_BATTERY_MAX		875
+#define HP680_BATTERY_MIN		600
+#define HP680_BATTERY_AC_ON		900
+
+#define MODNAME "hp6x0_apm"
+
+static int hp6x0_apm_get_info(char *buf, char **start, off_t fpos, int length)
+{
+	u8 pgdr;
+	char *p;
+	int battery_status;
+	int battery_flag;
+	int ac_line_status;
+	int time_units = APM_BATTERY_LIFE_UNKNOWN;
+
+	int battery = adc_single(ADC_CHANNEL_BATTERY);
+	int backup = adc_single(ADC_CHANNEL_BACKUP);
+	int charging = adc_single(ADC_CHANNEL_CHARGE);
+	int percentage;
+
+	percentage = 100 * (battery - HP680_BATTERY_MIN) /
+			   (HP680_BATTERY_MAX - HP680_BATTERY_MIN);
+
+	ac_line_status = (battery > HP680_BATTERY_AC_ON) ?
+			 APM_AC_ONLINE : APM_AC_OFFLINE;
+
+	p = buf;
+
+	pgdr = ctrl_inb(SH7709_PGDR);
+	if (pgdr & PGDR_MAIN_BATTERY_OUT) {
+		battery_status = APM_BATTERY_STATUS_NOT_PRESENT;
+		battery_flag = 0x80;
+		percentage = -1;
+	} else if (charging < 8 ) {
+		battery_status = APM_BATTERY_STATUS_CHARGING;
+		battery_flag = 0x08;
+		ac_line_status = 0xff;
+	} else if (percentage <= APM_CRITICAL) {
+		battery_status = APM_BATTERY_STATUS_CRITICAL;
+		battery_flag = 0x04;
+	} else if (percentage <= APM_LOW) {
+		battery_status = APM_BATTERY_STATUS_LOW;
+		battery_flag = 0x02;
+	} else {
+		battery_status = APM_BATTERY_STATUS_HIGH;
+		battery_flag = 0x01;
+	}
+
+	p += sprintf(p, "1.0 1.2 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\n",
+		     APM_32_BIT_SUPPORT,
+		     ac_line_status,
+		     battery_status,
+		     battery_flag,
+		     percentage,
+		     time_units,
+		     "min");
+	p += sprintf(p, "bat=%d backup=%d charge=%d\n",
+		     battery, backup, charging);
+
+	return p - buf;
+}
+
+static irqreturn_t hp6x0_apm_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	if (!apm_suspended)
+		apm_queue_event(APM_USER_SUSPEND);
+
+	return IRQ_HANDLED;
+}
+
+static int __init hp6x0_apm_init(void)
+{
+	int ret;
+
+	ret = request_irq(HP680_BTN_IRQ, hp6x0_apm_interrupt,
+			  SA_INTERRUPT, MODNAME, 0);
+	if (unlikely(ret < 0)) {
+		printk(KERN_ERR MODNAME ": IRQ %d request failed\n",
+		       HP680_BTN_IRQ);
+		return ret;
+	}
+
+	apm_get_info = hp6x0_apm_get_info;
+
+	return ret;
+}
+
+static void __exit hp6x0_apm_exit(void)
+{
+	free_irq(HP680_BTN_IRQ, 0);
+	apm_get_info = 0;
+}
+
+module_init(hp6x0_apm_init);
+module_exit(hp6x0_apm_exit);
+
+MODULE_AUTHOR("Adriy Skulysh");
+MODULE_DESCRIPTION("hp6xx Advanced Power Management");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/arch/sh/boards/hp6xx/Makefile linux-2.6.17.8-sh/arch/sh/boards/hp6xx/Makefile
--- linux-2.6.17.8/arch/sh/boards/hp6xx/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/hp6xx/Makefile	2006-08-23 13:29:21.898213000 +0100
@@ -2,5 +2,8 @@
 # Makefile for the HP6xx specific parts of the kernel
 #
 
-obj-y	 := mach.o setup.o
+obj-y	 		:= mach.o setup.o
+obj-$(CONFIG_PM)	+= pm.o pm_wakeup.o
+obj-$(CONFIG_APM)	+= hp6xx_apm.o
+
 
diff -Naur linux-2.6.17.8/arch/sh/boards/hp6xx/pm.c linux-2.6.17.8-sh/arch/sh/boards/hp6xx/pm.c
--- linux-2.6.17.8/arch/sh/boards/hp6xx/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/hp6xx/pm.c	2006-08-23 13:29:22.667233000 +0100
@@ -0,0 +1,88 @@
+/*
+ * hp6x0 Power Management Routines
+ *
+ * Copyright (c) 2006 Andriy Skulysh <askulsyh@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <asm/hd64461.h>
+#include <asm/hp6xx/hp6xx.h>
+#include <asm/cpu/dac.h>
+#include <asm/pm.h>
+
+#define STBCR		0xffffff82
+#define STBCR2		0xffffff88
+
+static int hp6x0_pm_enter(suspend_state_t state)
+{
+	u8 stbcr, stbcr2;
+#ifdef CONFIG_HD64461_ENABLER
+	u8 scr;
+	u16 hd64461_stbcr;
+#endif
+
+	if (state != PM_SUSPEND_MEM)
+		return -EINVAL;
+
+#ifdef CONFIG_HD64461_ENABLER
+	outb(0, HD64461_PCC1CSCIER);
+
+	scr = inb(HD64461_PCC1SCR);
+	scr |= HD64461_PCCSCR_VCC1;
+	outb(scr, HD64461_PCC1SCR);
+
+	hd64461_stbcr = inw(HD64461_STBCR);
+	hd64461_stbcr |= HD64461_STBCR_SPC1ST;
+	outw(hd64461_stbcr, HD64461_STBCR);
+#endif
+
+	ctrl_outb(0x1f, DACR);
+
+	stbcr = ctrl_inb(STBCR);
+	ctrl_outb(0x01, STBCR);
+
+	stbcr2 = ctrl_inb(STBCR2);
+	ctrl_outb(0x7f , STBCR2);
+
+	outw(0xf07f, HD64461_SCPUCR);
+
+	pm_enter();
+
+	outw(0, HD64461_SCPUCR);
+	ctrl_outb(stbcr, STBCR);
+	ctrl_outb(stbcr2, STBCR2);
+
+#ifdef CONFIG_HD64461_ENABLER
+	hd64461_stbcr = inw(HD64461_STBCR);
+	hd64461_stbcr &= ~HD64461_STBCR_SPC1ST;
+	outw(hd64461_stbcr, HD64461_STBCR);
+
+	outb(0x4c, HD64461_PCC1CSCIER);
+	outb(0x00, HD64461_PCC1CSCR);
+#endif
+
+	return 0;
+}
+
+/*
+ * Set to PM_DISK_FIRMWARE so we can quickly veto suspend-to-disk.
+ */
+static struct pm_ops hp6x0_pm_ops = {
+	.pm_disk_mode	= PM_DISK_FIRMWARE,
+	.enter		= hp6x0_pm_enter,
+};
+
+static int __init hp6x0_pm_init(void)
+{
+	pm_set_ops(&hp6x0_pm_ops);
+	return 0;
+}
+
+late_initcall(hp6x0_pm_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/hp6xx/pm_wakeup.S linux-2.6.17.8-sh/arch/sh/boards/hp6xx/pm_wakeup.S
--- linux-2.6.17.8/arch/sh/boards/hp6xx/pm_wakeup.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/hp6xx/pm_wakeup.S	2006-08-23 13:29:22.674231000 +0100
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2006 Andriy Skulysh <askulsyh@gmail.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/cpu/mmu_context.h>
+
+#define k0	r0
+#define k1	r1
+#define k2	r2
+#define k3	r3
+#define k4	r4
+
+/*
+ * Kernel mode register usage:
+ *	k0	scratch
+ *	k1	scratch
+ *	k2	scratch (Exception code)
+ *	k3	scratch (Return address)
+ *	k4	scratch
+ *	k5	reserved
+ *	k6	Global Interrupt Mask (0--15 << 4)
+ *	k7	CURRENT_THREAD_INFO (pointer to current thread info)
+ */
+
+ENTRY(wakeup_start)
+! clear STBY bit
+	mov	#-126, k2
+   	and	#127, k0
+	mov.b	k0, @k2
+! enable refresh
+	mov.l	5f, k1
+	mov.w	6f, k0
+  	mov.w	k0, @k1
+! jump to handler
+	mov.l	2f, k2
+	mov.l	3f, k3
+	mov.l	@k2, k2
+
+	mov.l	4f, k1
+	jmp	@k1
+	nop
+
+	.align	2
+1:	.long	EXPEVT
+2:	.long	INTEVT
+3:	.long	ret_from_irq
+4:	.long	handle_exception
+5:	.long	0xffffff68
+6:	.word	0x0524
+
+ENTRY(wakeup_end)
+	nop
diff -Naur linux-2.6.17.8/arch/sh/boards/hp6xx/setup.c linux-2.6.17.8-sh/arch/sh/boards/hp6xx/setup.c
--- linux-2.6.17.8/arch/sh/boards/hp6xx/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/hp6xx/setup.c	2006-08-23 13:29:22.354231000 +0100
@@ -16,6 +16,9 @@
 #include <asm/hp6xx/hp6xx.h>
 #include <asm/cpu/dac.h>
 
+#define	SCPCR	0xa4000116
+#define SCPDR	0xa4000136
+
 const char *get_system_type(void)
 {
 	return "HP6xx";
@@ -25,6 +28,7 @@
 {
 	u8 v8;
 	u16 v;
+
 	v = inw(HD64461_STBCR);
 	v |= HD64461_STBCR_SURTST | HD64461_STBCR_SIRST |
 	    HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST |
@@ -51,5 +55,15 @@
 	v8 &= ~DACR_DAE;
 	ctrl_outb(v8,DACR);
 
+	v8 = ctrl_inb(SCPDR);
+	v8 |= SCPDR_TS_SCAN_X | SCPDR_TS_SCAN_Y;
+	v8 &= ~SCPDR_TS_SCAN_ENABLE;
+	ctrl_outb(v8, SCPDR);
+
+	v = ctrl_inw(SCPCR);
+	v &= ~SCPCR_TS_MASK;
+	v |= SCPCR_TS_ENABLE;
+	ctrl_outw(v, SCPCR);
+
 	return 0;
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/io.c linux-2.6.17.8-sh/arch/sh/boards/landisk/io.c
--- linux-2.6.17.8/arch/sh/boards/landisk/io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/io.c	2006-08-23 13:29:24.012254000 +0100
@@ -0,0 +1,250 @@
+/*
+ * arch/sh/boards/landisk/io.c
+ *
+ * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
+ * Based largely on io_se.c.
+ *
+ * I/O routine for I-O Data Device, Inc. LANDISK.
+ *
+ * Initial version only to support LAN access; some
+ * placeholder code from io_landisk.c left in with the
+ * expectation of later SuperIO and PCMCIA access.
+ */
+/*
+ * modifed by kogiidena
+ * 2005.03.03
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/landisk/iodata_landisk.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+
+extern void *area5_io_base;	/* Area 5 I/O Base address */
+extern void *area6_io_base;	/* Area 6 I/O Base address */
+
+static inline unsigned long port2adr(unsigned int port)
+{
+	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
+		if (port == 0x3f6)
+			return ((unsigned long)area5_io_base + 0x2c);
+		else
+			return ((unsigned long)area5_io_base + PA_PIDE_OFFSET +
+				((port - 0x1f0) << 1));
+	else if ((0x170 <= port && port < 0x178) || port == 0x376)
+		if (port == 0x376)
+			return ((unsigned long)area6_io_base + 0x2c);
+		else
+			return ((unsigned long)area6_io_base + PA_SIDE_OFFSET +
+				((port - 0x170) << 1));
+	else
+		maybebadio((unsigned long)port);
+
+	return port;
+}
+
+/*
+ * General outline: remap really low stuff [eventually] to SuperIO,
+ * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)
+ * is mapped through the PCI IO window.  Stuff with high bits (PXSEG)
+ * should be way beyond the window, and is used  w/o translation for
+ * compatibility.
+ */
+u8 landisk_inb(unsigned long port)
+{
+	if (PXSEG(port))
+		return ctrl_inb(port);
+	else if (is_pci_ioaddr(port))
+		return ctrl_inb(pci_ioaddr(port));
+
+	return ctrl_inw(port2adr(port)) & 0xff;
+}
+
+u8 landisk_inb_p(unsigned long port)
+{
+	u8 v;
+
+	if (PXSEG(port))
+		v = ctrl_inb(port);
+	else if (is_pci_ioaddr(port))
+		v = ctrl_inb(pci_ioaddr(port));
+	else
+		v = ctrl_inw(port2adr(port)) & 0xff;
+
+	ctrl_delay();
+
+	return v;
+}
+
+u16 landisk_inw(unsigned long port)
+{
+	if (PXSEG(port))
+		return ctrl_inw(port);
+	else if (is_pci_ioaddr(port))
+		return ctrl_inw(pci_ioaddr(port));
+	else
+		maybebadio(port);
+
+	return 0;
+}
+
+u32 landisk_inl(unsigned long port)
+{
+	if (PXSEG(port))
+		return ctrl_inl(port);
+	else if (is_pci_ioaddr(port))
+		return ctrl_inl(pci_ioaddr(port));
+	else
+		maybebadio(port);
+
+	return 0;
+}
+
+void landisk_outb(u8 value, unsigned long port)
+{
+	if (PXSEG(port))
+		ctrl_outb(value, port);
+	else if (is_pci_ioaddr(port))
+		ctrl_outb(value, pci_ioaddr(port));
+	else
+		ctrl_outw(value, port2adr(port));
+}
+
+void landisk_outb_p(u8 value, unsigned long port)
+{
+	if (PXSEG(port))
+		ctrl_outb(value, port);
+	else if (is_pci_ioaddr(port))
+		ctrl_outb(value, pci_ioaddr(port));
+	else
+		ctrl_outw(value, port2adr(port));
+	ctrl_delay();
+}
+
+void landisk_outw(u16 value, unsigned long port)
+{
+	if (PXSEG(port))
+		ctrl_outw(value, port);
+	else if (is_pci_ioaddr(port))
+		ctrl_outw(value, pci_ioaddr(port));
+	else
+		maybebadio(port);
+}
+
+void landisk_outl(u32 value, unsigned long port)
+{
+	if (PXSEG(port))
+		ctrl_outl(value, port);
+	else if (is_pci_ioaddr(port))
+		ctrl_outl(value, pci_ioaddr(port));
+	else
+		maybebadio(port);
+}
+
+void landisk_insb(unsigned long port, void *dst, unsigned long count)
+{
+        volatile u16 *p;
+        u8 *buf = dst;
+
+        if (PXSEG(port)) {
+                while (count--)
+                        *buf++ = *(volatile u8 *)port;
+	} else if (is_pci_ioaddr(port)) {
+                volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
+
+                while (count--)
+                        *buf++ = *bp;
+	} else {
+                p = (volatile u16 *)port2adr(port);
+                while (count--)
+                        *buf++ = *p & 0xff;
+	}
+}
+
+void landisk_insw(unsigned long port, void *dst, unsigned long count)
+{
+        volatile u16 *p;
+        u16 *buf = dst;
+
+	if (PXSEG(port))
+		p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port))
+		p = (volatile u16 *)pci_ioaddr(port);
+	else
+		p = (volatile u16 *)port2adr(port);
+	while (count--)
+		*buf++ = *p;
+}
+
+void landisk_insl(unsigned long port, void *dst, unsigned long count)
+{
+        u32 *buf = dst;
+
+	if (is_pci_ioaddr(port)) {
+                volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+
+                while (count--)
+                        *buf++ = *p;
+	} else
+		maybebadio(port);
+}
+
+void landisk_outsb(unsigned long port, const void *src, unsigned long count)
+{
+        volatile u16 *p;
+        const u8 *buf = src;
+
+	if (PXSEG(port))
+                while (count--)
+                        ctrl_outb(*buf++, port);
+	else if (is_pci_ioaddr(port)) {
+                volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
+
+                while (count--)
+                        *bp = *buf++;
+	} else {
+                p = (volatile u16 *)port2adr(port);
+                while (count--)
+                        *p = *buf++;
+	}
+}
+
+void landisk_outsw(unsigned long port, const void *src, unsigned long count)
+{
+        volatile u16 *p;
+        const u16 *buf = src;
+
+	if (PXSEG(port))
+                p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port))
+                p = (volatile u16 *)pci_ioaddr(port);
+	else
+                p = (volatile u16 *)port2adr(port);
+
+        while (count--)
+                *p = *buf++;
+}
+
+void landisk_outsl(unsigned long port, const void *src, unsigned long count)
+{
+        const u32 *buf = src;
+
+	if (is_pci_ioaddr(port)) {
+                volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+
+                while (count--)
+                        *p = *buf++;
+	} else
+		maybebadio(port);
+}
+
+void __iomem *landisk_ioport_map(unsigned long port, unsigned int size)
+{
+        if (PXSEG(port))
+                return (void __iomem *)port;
+        else if (is_pci_ioaddr(port))
+                return (void __iomem *)pci_ioaddr(port);
+
+        return (void __iomem *)port2adr(port);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/irq.c linux-2.6.17.8-sh/arch/sh/boards/landisk/irq.c
--- linux-2.6.17.8/arch/sh/boards/landisk/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/irq.c	2006-08-23 13:29:15.921070000 +0100
@@ -0,0 +1,105 @@
+/*
+ * arch/sh/boards/landisk/irq.c
+ *
+ * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
+ * Based largely on io_se.c.
+ *
+ * I/O routine for I-O Data Device, Inc. LANDISK.
+ *
+ * Initial version only to support LAN access; some
+ * placeholder code from io_landisk.c left in with the
+ * expectation of later SuperIO and PCMCIA access.
+ */
+/*
+ * modified by kogiidena
+ * 2005.03.03
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/landisk/iodata_landisk.h>
+
+static void enable_landisk_irq(unsigned int irq);
+static void disable_landisk_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_landisk_irq disable_landisk_irq
+
+static void ack_landisk_irq(unsigned int irq);
+static void end_landisk_irq(unsigned int irq);
+
+static unsigned int startup_landisk_irq(unsigned int irq)
+{
+	enable_landisk_irq(irq);
+	return 0;		/* never anything pending */
+}
+
+static void disable_landisk_irq(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned char val;
+	unsigned char mask = 0xff ^ (0x01 << (irq - 5));
+
+	/* Set the priority in IPR to 0 */
+	local_irq_save(flags);
+	val = ctrl_inb(PA_IMASK);
+	val &= mask;
+	ctrl_outb(val, PA_IMASK);
+	local_irq_restore(flags);
+}
+
+static void enable_landisk_irq(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned char val;
+	unsigned char value = (0x01 << (irq - 5));
+
+	/* Set priority in IPR back to original value */
+	local_irq_save(flags);
+	val = ctrl_inb(PA_IMASK);
+	val |= value;
+	ctrl_outb(val, PA_IMASK);
+	local_irq_restore(flags);
+}
+
+static void ack_landisk_irq(unsigned int irq)
+{
+	disable_landisk_irq(irq);
+}
+
+static void end_landisk_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		enable_landisk_irq(irq);
+}
+
+static struct hw_interrupt_type landisk_irq_type = {
+	.typename = "LANDISK IRQ",
+	.startup = startup_landisk_irq,
+	.shutdown = shutdown_landisk_irq,
+	.enable = enable_landisk_irq,
+	.disable = disable_landisk_irq,
+	.ack = ack_landisk_irq,
+	.end = end_landisk_irq
+};
+
+static void make_landisk_irq(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+	irq_desc[irq].handler = &landisk_irq_type;
+	disable_landisk_irq(irq);
+}
+
+/*
+ * Initialize IRQ setting
+ */
+void __init init_landisk_IRQ(void)
+{
+	int i;
+
+	for (i = 5; i < 14; i++)
+		make_landisk_irq(i);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/landisk_pwb.c linux-2.6.17.8-sh/arch/sh/boards/landisk/landisk_pwb.c
--- linux-2.6.17.8/arch/sh/boards/landisk/landisk_pwb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/landisk_pwb.c	2006-08-23 13:29:15.951070000 +0100
@@ -0,0 +1,348 @@
+/*
+ * arch/sh/boards/landisk/landisk_pwb.c -- driver for the Power control switch.
+ *
+ * This driver will also support the I-O DATA Device, Inc. LANDISK Board.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copylight (C) 2002 Atom Create Engineering Co., Ltd.
+ *
+ * LED control drive function added by kogiidena
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/major.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/landisk/iodata_landisk.h>
+
+#define SHUTDOWN_BTN_MINOR	1	/* Shutdown button device minor no. */
+#define LED_MINOR	       21	/* LED minor no. */
+#define BTN_MINOR	       22	/* BUTTON minor no. */
+#define GIO_MINOR	       40	/* GIO minor no. */
+
+static int openCnt;
+static int openCntLED;
+static int openCntGio;
+static int openCntBtn;
+static int landisk_btn;
+static int landisk_btnctrlpid;
+/*
+ * Functions prototypes
+ */
+
+static int gio_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		     unsigned long arg);
+
+static int swdrv_open(struct inode *inode, struct file *filp)
+{
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	filp->private_data = (void *)minor;
+
+	if (minor == SHUTDOWN_BTN_MINOR) {
+		if (openCnt > 0) {
+			return -EALREADY;
+		} else {
+			openCnt++;
+			return 0;
+		}
+	} else if (minor == LED_MINOR) {
+		if (openCntLED > 0) {
+			return -EALREADY;
+		} else {
+			openCntLED++;
+			return 0;
+		}
+	} else if (minor == BTN_MINOR) {
+		if (openCntBtn > 0) {
+			return -EALREADY;
+		} else {
+			openCntBtn++;
+			return 0;
+		}
+	} else if (minor == GIO_MINOR) {
+		if (openCntGio > 0) {
+			return -EALREADY;
+		} else {
+			openCntGio++;
+			return 0;
+		}
+	}
+	return -ENOENT;
+
+}
+
+static int swdrv_close(struct inode *inode, struct file *filp)
+{
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	if (minor == SHUTDOWN_BTN_MINOR) {
+		openCnt--;
+	} else if (minor == LED_MINOR) {
+		openCntLED--;
+	} else if (minor == BTN_MINOR) {
+		openCntBtn--;
+	} else if (minor == GIO_MINOR) {
+		openCntGio--;
+	}
+	return 0;
+}
+
+static int swdrv_read(struct file *filp, char *buff, size_t count,
+		      loff_t * ppos)
+{
+	int minor;
+	minor = (int)(filp->private_data);
+
+	if (!access_ok(VERIFY_WRITE, (void *)buff, count))
+		return -EFAULT;
+
+	if (minor == SHUTDOWN_BTN_MINOR) {
+		if (landisk_btn & 0x10) {
+			put_user(1, buff);
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static int swdrv_write(struct file *filp, const char *buff, size_t count,
+		       loff_t * ppos)
+{
+	int minor;
+	minor = (int)(filp->private_data);
+
+	if (minor == SHUTDOWN_BTN_MINOR) {
+		return count;
+	}
+	return count;
+}
+
+static irqreturn_t sw_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	landisk_btn = (0x0ff & (~ctrl_inb(PA_STATUS)));
+	disable_irq(IRQ_BUTTON);
+	disable_irq(IRQ_POWER);
+	ctrl_outb(0x00, PA_PWRINT_CLR);
+
+	if (landisk_btnctrlpid != 0) {
+		kill_proc(landisk_btnctrlpid, SIGUSR1, 1);
+		landisk_btnctrlpid = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct file_operations swdrv_fops = {
+	.read = swdrv_read,	/* read */
+	.write = swdrv_write,	/* write */
+	.open = swdrv_open,	/* open */
+	.release = swdrv_close,	/* release */
+	.ioctl = gio_ioctl,	/* ioctl */
+
+};
+
+static char banner[] __initdata =
+    KERN_INFO "LANDISK and USL-5P Button, LED and GIO driver initialized\n";
+
+int __init swdrv_init(void)
+{
+	int error;
+
+	printk("%s", banner);
+
+	openCnt = 0;
+	openCntLED = 0;
+	openCntBtn = 0;
+	openCntGio = 0;
+	landisk_btn = 0;
+	landisk_btnctrlpid = 0;
+
+	if ((error = register_chrdev(SHUTDOWN_BTN_MAJOR, "swdrv", &swdrv_fops))) {
+		printk(KERN_ERR
+		       "Button, LED and GIO driver:Couldn't register driver, error=%d\n",
+		       error);
+		return 1;
+	}
+
+	if (request_irq(IRQ_POWER, sw_interrupt, 0, "SHUTDOWNSWITCH", NULL)) {
+		printk(KERN_ERR "Unable to get IRQ 11.\n");
+		return 1;
+	}
+	if (request_irq(IRQ_BUTTON, sw_interrupt, 0, "USL-5P BUTTON", NULL)) {
+		printk(KERN_ERR "Unable to get IRQ 12.\n");
+		return 1;
+	}
+	ctrl_outb(0x00, PA_PWRINT_CLR);
+
+	return 0;
+}
+
+module_init(swdrv_init);
+
+/*
+ * gio driver
+ *
+ */
+
+#include <asm/landisk/gio.h>
+
+static int gio_ioctl(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg)
+{
+	int minor;
+	unsigned int data, mask;
+	static unsigned int addr = 0;
+
+	minor = (int)(filp->private_data);
+
+	/* access control */
+	if (minor == GIO_MINOR) {
+		;
+	} else if (minor == LED_MINOR) {
+		if (((cmd & 0x0ff) >= 9) && ((cmd & 0x0ff) < 20)) {
+			;
+		} else {
+			return -EINVAL;
+		}
+	} else if (minor == BTN_MINOR) {
+		if (((cmd & 0x0ff) >= 20) && ((cmd & 0x0ff) < 30)) {
+			;
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	if (cmd & 0x01) {	/* write */
+		if (copy_from_user(&data, (int *)arg, sizeof(int))) {
+			return -EFAULT;
+		}
+	}
+
+	switch (cmd) {
+	case GIODRV_IOCSGIOSETADDR:	/* addres set */
+		addr = data;
+		break;
+
+	case GIODRV_IOCSGIODATA1:	/* write byte */
+		ctrl_outb((unsigned char)(0x0ff & data), addr);
+		break;
+
+	case GIODRV_IOCSGIODATA2:	/* write word */
+		if (addr & 0x01) {
+			return -EFAULT;
+		}
+		ctrl_outw((unsigned short int)(0x0ffff & data), addr);
+		break;
+
+	case GIODRV_IOCSGIODATA4:	/* write long */
+		if (addr & 0x03) {
+			return -EFAULT;
+		}
+		ctrl_outl(data, addr);
+		break;
+
+	case GIODRV_IOCGGIODATA1:	/* read byte */
+		data = ctrl_inb(addr);
+		break;
+
+	case GIODRV_IOCGGIODATA2:	/* read word */
+		if (addr & 0x01) {
+			return -EFAULT;
+		}
+		data = ctrl_inw(addr);
+		break;
+
+	case GIODRV_IOCGGIODATA4:	/* read long */
+		if (addr & 0x03) {
+			return -EFAULT;
+		}
+		data = ctrl_inl(addr);
+		break;
+	case GIODRV_IOCSGIO_LED:	/* write */
+		mask = ((data & 0x00ffffff) << 8)
+		    | ((data & 0x0000ffff) << 16)
+		    | ((data & 0x000000ff) << 24);
+		landisk_ledparam = data & (~mask);
+		if (landisk_arch == 0) {	/* arch == landisk */
+			landisk_ledparam &= 0x03030303;
+			mask = (~(landisk_ledparam >> 22)) & 0x000c;
+			landisk_ledparam |= mask;
+		} else {	                /* arch == usl-5p */
+			mask = (landisk_ledparam >> 24) & 0x0001;
+			landisk_ledparam |= mask;
+			landisk_ledparam &= 0x007f7f7f;
+		}
+		landisk_ledparam |= 0x80;
+		break;
+	case GIODRV_IOCGGIO_LED:	/* read */
+		data = landisk_ledparam;
+		if (landisk_arch == 0) {	/* arch == landisk */
+			data &= 0x03030303;
+		} else {	                /* arch == usl-5p */
+			;
+		}
+		data &= (~0x080);
+		break;
+	case GIODRV_IOCSGIO_BUZZER:	/* write */
+		landisk_buzzerparam = data;
+		landisk_ledparam |= 0x80;
+		break;
+	case GIODRV_IOCGGIO_LANDISK:	/* read */
+		data = landisk_arch & 0x01;
+		break;
+	case GIODRV_IOCGGIO_BTN:	/* read */
+		data = (0x0ff & ctrl_inb(PA_PWRINT_CLR));
+		data <<= 8;
+		data |= (0x0ff & ctrl_inb(PA_IMASK));
+		data <<= 8;
+		data |= (0x0ff & landisk_btn);
+		data <<= 8;
+		data |= (0x0ff & (~ctrl_inb(PA_STATUS)));
+		break;
+	case GIODRV_IOCSGIO_BTNPID:	/* write */
+		landisk_btnctrlpid = data;
+		landisk_btn = 0;
+		if (irq_desc[IRQ_BUTTON].depth) {
+			enable_irq(IRQ_BUTTON);
+		}
+		if (irq_desc[IRQ_POWER].depth) {
+			enable_irq(IRQ_POWER);
+		}
+		break;
+	case GIODRV_IOCGGIO_BTNPID:	/* read */
+		data = landisk_btnctrlpid;
+		break;
+	default:
+		return -EFAULT;
+		break;
+	}
+
+	if ((cmd & 0x01) == 0) {	/* read */
+		if (copy_to_user((int *)arg, &data, sizeof(int))) {
+			return -EFAULT;
+		}
+	}
+	return 0;
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/Makefile linux-2.6.17.8-sh/arch/sh/boards/landisk/Makefile
--- linux-2.6.17.8/arch/sh/boards/landisk/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/Makefile	2006-08-23 13:29:25.060277000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for I-O DATA DEVICE, INC. "LANDISK Series"
+#
+
+obj-y	 := setup.o io.o irq.o rtc.o landisk_pwb.o
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/rtc.c linux-2.6.17.8-sh/arch/sh/boards/landisk/rtc.c
--- linux-2.6.17.8/arch/sh/boards/landisk/rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/rtc.c	2006-08-23 13:29:26.962323000 +0100
@@ -0,0 +1,93 @@
+/*
+ * arch/sh/boards/landisk/rtc.c --  RTC support
+ *
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ */
+/*
+ * modifed by kogiidena
+ * 2005.09.16
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/bcd.h>
+#include <asm/rtc.h>
+
+extern spinlock_t rtc_lock;
+
+extern void
+rs5c313_set_cmos_time(unsigned int BCD_yr, unsigned int BCD_mon,
+		      unsigned int BCD_day, unsigned int BCD_hr,
+		      unsigned int BCD_min, unsigned int BCD_sec);
+
+extern unsigned long
+rs5c313_get_cmos_time(unsigned int *BCD_yr, unsigned int *BCD_mon,
+		      unsigned int *BCD_day, unsigned int *BCD_hr,
+		      unsigned int *BCD_min, unsigned int *BCD_sec);
+
+void landisk_rtc_gettimeofday(struct timespec *tv)
+{
+	unsigned int BCD_yr, BCD_mon, BCD_day, BCD_hr, BCD_min, BCD_sec;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+	tv->tv_sec = rs5c313_get_cmos_time
+	    (&BCD_yr, &BCD_mon, &BCD_day, &BCD_hr, &BCD_min, &BCD_sec);
+	tv->tv_nsec = 0;
+	spin_unlock_irqrestore(&rtc_lock, flags);
+}
+
+int landisk_rtc_settimeofday(const time_t secs)
+{
+	int retval = 0;
+	int real_seconds, real_minutes, cmos_minutes;
+	unsigned long flags;
+	unsigned long nowtime = secs;
+	unsigned int BCD_yr, BCD_mon, BCD_day, BCD_hr, BCD_min, BCD_sec;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+
+	rs5c313_get_cmos_time
+	  (&BCD_yr, &BCD_mon, &BCD_day, &BCD_hr, &BCD_min, &BCD_sec);
+	cmos_minutes = BCD_min;
+	BCD_TO_BIN(cmos_minutes);
+
+	/*
+	 * since we're only adjusting minutes and seconds,
+	 * don't interfere with hour overflow. This avoids
+	 * messing with unknown time zones but requires your
+	 * RTC not to be off by more than 15 minutes
+	 */
+	real_seconds = nowtime % 60;
+	real_minutes = nowtime / 60;
+	if (((abs(real_minutes - cmos_minutes) + 15) / 30) & 1)
+		real_minutes += 30;	/* correct for half hour time zone */
+	real_minutes %= 60;
+
+	if (abs(real_minutes - cmos_minutes) < 30) {
+		BIN_TO_BCD(real_seconds);
+		BIN_TO_BCD(real_minutes);
+		rs5c313_set_cmos_time(BCD_yr, BCD_mon, BCD_day, BCD_hr,
+				      real_minutes, real_seconds);
+	} else {
+		printk(KERN_WARNING
+		       "set_rtc_time: can't update from %d to %d\n",
+		       cmos_minutes, real_minutes);
+		retval = -1;
+	}
+
+	spin_unlock_irqrestore(&rtc_lock, flags);
+	return retval;
+}
+
+void landisk_time_init(void)
+{
+	rtc_sh_get_time = landisk_rtc_gettimeofday;
+	rtc_sh_set_time = landisk_rtc_settimeofday;
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/landisk/setup.c linux-2.6.17.8-sh/arch/sh/boards/landisk/setup.c
--- linux-2.6.17.8/arch/sh/boards/landisk/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/landisk/setup.c	2006-08-23 13:29:17.286116000 +0100
@@ -0,0 +1,179 @@
+/*
+ * arch/sh/boards/landisk/setup.c
+ *
+ * Copyright (C) 2000 Kazumoto Kojima
+ * Copyright (C) 2002 Paul Mundt
+ *
+ * I-O DATA Device, Inc. LANDISK Support.
+ *
+ * Modified for LANDISK by
+ * Atom Create Engineering Co., Ltd. 2002.
+ *
+ * modifed by kogiidena
+ * 2005.09.16
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/mm.h>
+#include <asm/machvec.h>
+#include <asm/rtc.h>
+#include <asm/landisk/iodata_landisk.h>
+#include <asm/io.h>
+
+void landisk_time_init(void);
+void init_landisk_IRQ(void);
+
+int landisk_ledparam;
+int landisk_buzzerparam;
+int landisk_arch;
+
+/* cycle the led's in the clasic knightrider/sun pattern */
+static void heartbeat_landisk(void)
+{
+	static unsigned int cnt = 0, blink = 0x00, period = 25;
+        volatile u8 *p = (volatile u8 *)PA_LED;
+	char data;
+
+        if ((landisk_ledparam & 0x080) == 0)
+		return;
+
+	cnt += 1;
+
+        if (cnt < period)
+		return;
+
+	cnt = 0;
+	blink++;
+
+	data = (blink & 0x01) ? (landisk_ledparam >> 16) : 0;
+	data |= (blink & 0x02) ? (landisk_ledparam >> 8) : 0;
+	data |= landisk_ledparam;
+
+	/* buzzer */
+	if (landisk_buzzerparam & 0x1) {
+		data |= 0x80;
+	} else {
+		data &= 0x7f;
+	}
+	*p = data;
+
+        if (((landisk_ledparam & 0x007f7f00) == 0) &&
+             (landisk_buzzerparam == 0))
+		landisk_ledparam &= (~0x0080);
+
+	landisk_buzzerparam >>= 1;
+}
+
+/*
+ * The Machine Vector
+ */
+struct sh_machine_vector mv_landisk __initmv = {
+	.mv_nr_irqs = 72,
+	.mv_inb = landisk_inb,
+	.mv_inw = landisk_inw,
+	.mv_inl = landisk_inl,
+	.mv_outb = landisk_outb,
+	.mv_outw = landisk_outw,
+	.mv_outl = landisk_outl,
+	.mv_inb_p = landisk_inb_p,
+	.mv_inw_p = landisk_inw,
+	.mv_inl_p = landisk_inl,
+	.mv_outb_p = landisk_outb_p,
+	.mv_outw_p = landisk_outw,
+	.mv_outl_p = landisk_outl,
+	.mv_insb = landisk_insb,
+	.mv_insw = landisk_insw,
+	.mv_insl = landisk_insl,
+	.mv_outsb = landisk_outsb,
+	.mv_outsw = landisk_outsw,
+	.mv_outsl = landisk_outsl,
+        .mv_ioport_map = landisk_ioport_map,
+	.mv_init_irq = init_landisk_IRQ,
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat = heartbeat_landisk,
+#endif
+};
+ALIAS_MV(landisk)
+
+const char *get_system_type(void)
+{
+        return "LANDISK";
+}
+
+static void landisk_power_off(void)
+{
+        ctrl_outb(0x01, PA_SHUTDOWN);
+}
+
+static void check_usl5p(void)
+{
+        volatile u8 *p = (volatile u8 *)PA_LED;
+        u8 tmp1, tmp2;
+
+        tmp1 = *p;
+        *p = 0x40;
+        tmp2 = *p;
+        *p = tmp1;
+
+        landisk_arch = (tmp2 == 0x40);
+        if (landisk_arch == 1) {
+                /* arch == usl-5p */
+                landisk_ledparam = 0x00000380;
+                landisk_ledparam |= (tmp1 & 0x07c);
+        } else {
+                /* arch == landisk */
+                landisk_ledparam = 0x02000180;
+                landisk_ledparam |= 0x04;
+        }
+}
+
+void __init platform_setup(void)
+{
+        landisk_buzzerparam = 0;
+        check_usl5p();
+
+        printk(KERN_INFO "I-O DATA DEVICE, INC. \"LANDISK Series\" support.\n");
+        board_time_init = landisk_time_init;
+        pm_power_off = landisk_power_off;
+}
+
+void *area5_io_base;
+void *area6_io_base;
+
+static int __init landisk_cf_init(void)
+{
+	pgprot_t prot;
+	unsigned long paddrbase, psize;
+
+	/* open I/O area window */
+	paddrbase = virt_to_phys((void *)PA_AREA5_IO);
+	psize = PAGE_SIZE;
+	prot = PAGE_KERNEL_PCC(1, _PAGE_PCC_IO16);
+	area5_io_base = p3_ioremap(paddrbase, psize, prot.pgprot);
+	if (!area5_io_base) {
+		printk("allocate_cf_area : can't open CF I/O window!\n");
+		return -ENOMEM;
+	}
+
+	paddrbase = virt_to_phys((void *)PA_AREA6_IO);
+	psize = PAGE_SIZE;
+	prot = PAGE_KERNEL_PCC(0, _PAGE_PCC_IO16);
+	area6_io_base = p3_ioremap(paddrbase, psize, prot.pgprot);
+	if (!area6_io_base) {
+		printk("allocate_cf_area : can't open HDD I/O window!\n");
+		return -ENOMEM;
+	}
+
+	printk(KERN_INFO "Allocate Area5/6 success.\n");
+
+	/* XXX : do we need attribute and common-memory area also? */
+
+	return 0;
+}
+
+__initcall(landisk_cf_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/mpc1211/rtc.c linux-2.6.17.8-sh/arch/sh/boards/mpc1211/rtc.c
--- linux-2.6.17.8/arch/sh/boards/mpc1211/rtc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/mpc1211/rtc.c	2006-08-23 13:29:26.978323000 +0100
@@ -130,7 +130,7 @@
 
 void mpc1211_time_init(void)
 {
-	rtc_get_time = mpc1211_rtc_gettimeofday;
-	rtc_set_time = mpc1211_rtc_settimeofday;
+	rtc_sh_get_time = mpc1211_rtc_gettimeofday;
+	rtc_sh_set_time = mpc1211_rtc_settimeofday;
 }
 
diff -Naur linux-2.6.17.8/arch/sh/boards/mpc1211/setup.c linux-2.6.17.8-sh/arch/sh/boards/mpc1211/setup.c
--- linux-2.6.17.8/arch/sh/boards/mpc1211/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/mpc1211/setup.c	2006-08-23 13:29:24.033254000 +0100
@@ -256,23 +256,12 @@
 	}
 }
 
-/*
-  Initialize the board
-*/
-
-
-static void delay (void)
-{
-	volatile unsigned short tmp;
-	tmp = *(volatile unsigned short *) 0xa0000000;
-}
-
-static void delay1000 (void)
+static void delay1000(void)
 {
 	int i;
 
 	for (i=0; i<1000; i++)
-		delay ();
+		ctrl_delay();
 }
 
 static int put_smb_blk(unsigned char *p, int address, int command, int no)
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/edosk7705/Makefile linux-2.6.17.8-sh/arch/sh/boards/renesas/edosk7705/Makefile
--- linux-2.6.17.8/arch/sh/boards/renesas/edosk7705/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/edosk7705/Makefile	2006-08-23 13:29:15.374070000 +0100
@@ -1,10 +1,6 @@
 #
 # Makefile for the EDOSK7705 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o
 
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/io.c linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/io.c
--- linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/io.c	2006-08-23 13:29:24.052254000 +0100
@@ -14,18 +14,13 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <asm/hs7751rvoip/hs7751rvoip.h>
 #include <asm/addrspace.h>
 
-#include <linux/module.h>
-#include <linux/pci.h>
-#include "../../../drivers/pci/pci-sh7751.h"
-
-extern void *area5_io8_base;	/* Area 5 8bit I/O Base address */
 extern void *area6_io8_base;	/* Area 6 8bit I/O Base address */
 extern void *area5_io16_base;	/* Area 5 16bit I/O Base address */
-extern void *area6_io16_base;	/* Area 6 16bit I/O Base address */
 
 /*
  * The 7751R HS7751RVoIP uses the built-in PCI controller (PCIC)
@@ -34,25 +29,8 @@
  * like the other Solution Engine boards.
  */
 
-#define PCIIOBR		(volatile long *)PCI_REG(SH7751_PCIIOBR)
-#define PCIMBR          (volatile long *)PCI_REG(SH7751_PCIMBR)
-#define PCI_IO_AREA	SH7751_PCI_IO_BASE
-#define PCI_MEM_AREA	SH7751_PCI_CONFIG_BASE
-
-#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7751_PCIIOBR_MASK))
-
-#if defined(CONFIG_HS7751RVOIP_CODEC)
 #define CODEC_IO_BASE	0x1000
-#endif
-
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
+#define CODEC_IOMAP(a)	((unsigned long)area6_io8_base + ((a) - CODEC_IO_BASE))
 
 static inline unsigned long port2adr(unsigned int port)
 {
@@ -60,9 +38,10 @@
 		if (port == 0x3f6)
 			return ((unsigned long)area5_io16_base + 0x0c);
 		else
-			return ((unsigned long)area5_io16_base + 0x800 + ((port-0x1f0) << 1));
+			return ((unsigned long)area5_io16_base + 0x800 +
+				((port-0x1f0) << 1));
 	else
-		maybebadio(port2adr, (unsigned long)port);
+		maybebadio((unsigned long)port);
 	return port;
 }
 
@@ -79,25 +58,10 @@
 }
 
 #if defined(CONFIG_HS7751RVOIP_CODEC)
-static inline int
-codec_port(unsigned long port)
-{
-	if (CODEC_IO_BASE <= port && port < (CODEC_IO_BASE+0x20))
-		return 1;
-	else
-		return 0;
-}
-#endif
-
-/* In case someone configures the kernel w/o PCI support: in that */
-/* scenario, don't ever bother to check for PCI-window addresses */
-
-/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
-#if defined(CONFIG_PCI)
-#define CHECK_SH7751_PCIIO(port) \
-  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7751_PCI_IO_SIZE)))
+#define codec_port(port)	\
+	((CODEC_IO_BASE <= (port)) && ((port) < (CODEC_IO_BASE + 0x20)))
 #else
-#define CHECK_SH7751_PCIIO(port) (0)
+#define codec_port(port)	(0)
 #endif
 
 /*
@@ -110,15 +74,13 @@
 unsigned char hs7751rvoip_inb(unsigned long port)
 {
 	if (PXSEG(port))
-		return *(volatile unsigned char *)port;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		return ctrl_inb(port);
 	else if (codec_port(port))
-		return *(volatile unsigned char *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE));
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		return *(volatile unsigned char *)PCI_IOMAP(port);
+		return ctrl_inb(CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inb(pci_ioaddr(port));
 	else
-		return (*(volatile unsigned short *)port2adr(port) & 0xff);
+		return ctrl_inw(port2adr(port)) & 0xff;
 }
 
 unsigned char hs7751rvoip_inb_p(unsigned long port)
@@ -126,38 +88,36 @@
 	unsigned char v;
 
         if (PXSEG(port))
-                v = *(volatile unsigned char *)port;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		v = ctrl_inb(port);
 	else if (codec_port(port))
-		v = *(volatile unsigned char *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE));
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-                v = *(volatile unsigned char *)PCI_IOMAP(port);
+		v = ctrl_inb(CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		v = ctrl_inb(pci_ioaddr(port));
 	else
-		v = (*(volatile unsigned short *)port2adr(port) & 0xff);
-	delay();
+		v = ctrl_inw(port2adr(port)) & 0xff;
+	ctrl_delay();
 	return v;
 }
 
 unsigned short hs7751rvoip_inw(unsigned long port)
 {
         if (PXSEG(port))
-                return *(volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-                return *(volatile unsigned short *)PCI_IOMAP(port);
+		return ctrl_inw(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inw(pci_ioaddr(port));
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 	return 0;
 }
 
 unsigned int hs7751rvoip_inl(unsigned long port)
 {
         if (PXSEG(port))
-                return *(volatile unsigned long *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-                return *(volatile unsigned long *)PCI_IOMAP(port);
+		return ctrl_inl(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inl(pci_ioaddr(port));
 	else
-		maybebadio(inl, port);
+		maybebadio(port);
 	return 0;
 }
 
@@ -165,146 +125,160 @@
 {
 
         if (PXSEG(port))
-                *(volatile unsigned char *)port = value;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		ctrl_outb(value, port);
 	else if (codec_port(port))
-		*(volatile unsigned cjar *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE)) = value;
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-        	*(unsigned char *)PCI_IOMAP(port) = value;
+		ctrl_outb(value, CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outb(value, pci_ioaddr(port));
 	else
-		*(volatile unsigned short *)port2adr(port) = value;
+		ctrl_outb(value, port2adr(port));
 }
 
 void hs7751rvoip_outb_p(unsigned char value, unsigned long port)
 {
         if (PXSEG(port))
-                *(volatile unsigned char *)port = value;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		ctrl_outb(value, port);
 	else if (codec_port(port))
-		*(volatile unsigned cjar *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE)) = value;
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-        	*(unsigned char *)PCI_IOMAP(port) = value;
+		ctrl_outb(value, CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outb(value, pci_ioaddr(port));
 	else
-		*(volatile unsigned short *)port2adr(port) = value;
-	delay();
+		ctrl_outw(value, port2adr(port));
+
+	ctrl_delay();
 }
 
 void hs7751rvoip_outw(unsigned short value, unsigned long port)
 {
         if (PXSEG(port))
-                *(volatile unsigned short *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-        	*(unsigned short *)PCI_IOMAP(port) = value;
+		ctrl_outw(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outw(value, pci_ioaddr(port));
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
 void hs7751rvoip_outl(unsigned int value, unsigned long port)
 {
         if (PXSEG(port))
-                *(volatile unsigned long *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-        	*((unsigned long *)PCI_IOMAP(port)) = value;
+		ctrl_outl(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outl(value, pci_ioaddr(port));
 	else
-		maybebadio(outl, port);
+		maybebadio(port);
 }
 
 void hs7751rvoip_insb(unsigned long port, void *addr, unsigned long count)
 {
+	u8 *buf = addr;
+
 	if (PXSEG(port))
-		while (count--) *((unsigned char *) addr)++ = *(volatile unsigned char *)port;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		while (count--)
+			*buf++ = ctrl_inb(port);
 	else if (codec_port(port))
-		while (count--) *((unsigned char *) addr)++ = *(volatile unsigned char *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE));
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u8 *bp = (__u8 *)PCI_IOMAP(port);
+		while (count--)
+			*buf++ = ctrl_inb(CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
 
-		while (count--) *((volatile unsigned char *) addr)++ = *bp;
+		while (count--)
+			*buf++ = *bp;
 	} else {
-		volatile __u16 *p = (volatile unsigned short *)port2adr(port);
+		volatile u16 *p = (volatile u16 *)port2adr(port);
 
-		while (count--) *((unsigned char *) addr)++ = *p & 0xff;
+		while (count--)
+			*buf++ = *p & 0xff;
 	}
 }
 
 void hs7751rvoip_insw(unsigned long port, void *addr, unsigned long count)
 {
-	volatile __u16 *p;
+	volatile u16 *p;
+	u16 *buf = addr;
 
 	if (PXSEG(port))
-		p = (volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		p = (volatile unsigned short *)PCI_IOMAP(port);
-	else
-		p = (volatile unsigned short *)port2adr(port);
-	while (count--) *((__u16 *) addr)++ = *p;
+		p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile u16 *)pci_ioaddr(port);
+	else
+		p = (volatile u16 *)port2adr(port);
+	while (count--)
+		*buf++ = *p;
 }
 
 void hs7751rvoip_insl(unsigned long port, void *addr, unsigned long count)
 {
-	if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u32 *p = (__u32 *)PCI_IOMAP(port);
 
-		while (count--) *((__u32 *) addr)++ = *p;
+	if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+		u32 *buf = addr;
+
+		while (count--)
+			*buf++ = *p;
 	} else
-		maybebadio(insl, port);
+		maybebadio(port);
 }
 
 void hs7751rvoip_outsb(unsigned long port, const void *addr, unsigned long count)
 {
+	const u8 *buf = addr;
+
 	if (PXSEG(port))
-		while (count--) *(volatile unsigned char *)port = *((unsigned char *) addr)++;
-#if defined(CONFIG_HS7751RVOIP_CODEC)
+		while (count--)
+			ctrl_outb(*buf++, port);
 	else if (codec_port(port))
-		while (count--) *(volatile unsigned char *)((unsigned long)area6_io8_base+(port-CODEC_IO_BASE)) = *((unsigned char *) addr)++;
-#endif
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u8 *bp = (__u8 *)PCI_IOMAP(port);
+		while (count--)
+			ctrl_outb(*buf++, CODEC_IOMAP(port));
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
 
-		while (count--) *bp = *((volatile unsigned char *) addr)++;
+		while (count--)
+			*bp = *buf++;
 	} else {
-		volatile __u16 *p = (volatile unsigned short *)port2adr(port);
+		volatile u16 *p = (volatile u16 *)port2adr(port);
 
-		while (count--) *p = *((unsigned char *) addr)++;
+		while (count--)
+			*p = *buf++;
 	}
 }
 
 void hs7751rvoip_outsw(unsigned long port, const void *addr, unsigned long count)
 {
-	volatile __u16 *p;
+	volatile u16 *p;
+	const u16 *buf = addr;
 
 	if (PXSEG(port))
-		p = (volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		p = (volatile unsigned short *)PCI_IOMAP(port);
+		p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile u16 *)pci_ioaddr(port);
 	else
-		p = (volatile unsigned short *)port2adr(port);
-	while (count--) *p = *((__u16 *) addr)++;
+		p = (volatile u16 *)port2adr(port);
+
+	while (count--)
+		*p = *buf++;
 }
 
 void hs7751rvoip_outsl(unsigned long port, const void *addr, unsigned long count)
 {
-	if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u32 *p = (__u32 *)PCI_IOMAP(port);
+	const u32 *buf = addr;
 
-		while (count--) *p = *((__u32 *) addr)++;
+	if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+
+		while (count--)
+			*p = *buf++;
 	} else
-		maybebadio(outsl, port);
+		maybebadio(port);
 }
 
-void *hs7751rvoip_ioremap(unsigned long offset, unsigned long size)
+void __iomem *hs7751rvoip_ioport_map(unsigned long port, unsigned int size)
 {
-	if (offset >= 0xfd000000)
-		return (void *)offset;
-	else
-		return (void *)P2SEGADDR(offset);
-}
-EXPORT_SYMBOL(hs7751rvoip_ioremap);
+        if (PXSEG(port))
+                return (void __iomem *)port;
+	else if (unlikely(codec_port(port) && (size == 1)))
+		return (void __iomem *)CODEC_IOMAP(port);
+        else if (is_pci_ioaddr(port))
+                return (void __iomem *)pci_ioaddr(port);
 
-unsigned long hs7751rvoip_isa_port2addr(unsigned long offset)
-{
-	return port2adr(offset);
+        return (void __iomem *)port2adr(port);
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/Kconfig linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/Kconfig
--- linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/Kconfig	2006-08-23 13:29:12.588001000 +0100
@@ -0,0 +1,12 @@
+if SH_HS7751RVOIP
+
+menu "HS7751RVoIP options"
+
+config HS7751RVOIP_CODEC
+	bool "Support VoIP Codec section"
+	help
+	  Selecting this option will support CODEC section.
+
+endmenu
+
+endif
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/Makefile linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/Makefile
--- linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/Makefile	2006-08-23 13:29:16.077070000 +0100
@@ -1,12 +1,8 @@
 #
 # Makefile for the HS7751RVoIP specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
-obj-y	 := mach.o setup.o io.o irq.o led.o
+obj-y	 := setup.o io.o irq.o
 
 obj-$(CONFIG_PCI) += pci.o
 
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/setup.c linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/setup.c
--- linux-2.6.17.8/arch/sh/boards/renesas/hs7751rvoip/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/hs7751rvoip/setup.c	2006-08-23 13:29:18.021116000 +0100
@@ -13,25 +13,68 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
-
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
+#include <linux/pm.h>
 #include <asm/io.h>
 #include <asm/hs7751rvoip/hs7751rvoip.h>
+#include <asm/machvec.h>
+#include <asm/rtc.h>
+#include <asm/irq.h>
 
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
+unsigned int debug_counter;
+
+static void __init hs7751rvoip_init_irq(void)
+{
+#if defined(CONFIG_HS7751RVOIP_CODEC)
+	make_ipr_irq(DMTE0_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+	make_ipr_irq(DMTE1_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+#endif
 
-/* defined in mm/ioremap.c */
-extern void * p3_ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags);
+	init_hs7751rvoip_IRQ();
+}
 
-unsigned int debug_counter;
+struct sh_machine_vector mv_hs7751rvoip __initmv = {
+	.mv_nr_irqs		= 72,
+
+	.mv_inb			= hs7751rvoip_inb,
+	.mv_inw			= hs7751rvoip_inw,
+	.mv_inl			= hs7751rvoip_inl,
+	.mv_outb		= hs7751rvoip_outb,
+	.mv_outw		= hs7751rvoip_outw,
+	.mv_outl		= hs7751rvoip_outl,
+
+	.mv_inb_p		= hs7751rvoip_inb_p,
+	.mv_inw_p		= hs7751rvoip_inw,
+	.mv_inl_p		= hs7751rvoip_inl,
+	.mv_outb_p		= hs7751rvoip_outb_p,
+	.mv_outw_p		= hs7751rvoip_outw,
+	.mv_outl_p		= hs7751rvoip_outl,
+
+	.mv_insb		= hs7751rvoip_insb,
+	.mv_insw		= hs7751rvoip_insw,
+	.mv_insl		= hs7751rvoip_insl,
+	.mv_outsb		= hs7751rvoip_outsb,
+	.mv_outsw		= hs7751rvoip_outsw,
+	.mv_outsl		= hs7751rvoip_outsl,
+
+	.mv_init_irq		= hs7751rvoip_init_irq,
+	.mv_ioport_map		= hs7751rvoip_ioport_map,
+};
+ALIAS_MV(hs7751rvoip)
 
 const char *get_system_type(void)
 {
 	return "HS7751RVoIP";
 }
 
+static void hs7751rvoip_power_off(void)
+{
+	ctrl_outw(ctrl_inw(PA_OUTPORTR) & 0xffdf, PA_OUTPORTR);
+}
+
 /*
  * Initialize the board
  */
@@ -39,6 +82,7 @@
 {
 	printk(KERN_INFO "Renesas Technology Sales HS7751RVoIP-2 support.\n");
 	ctrl_outb(0xf0, PA_OUTPORTR);
+	pm_power_off = hs7751rvoip_power_off;
 	debug_counter = 0;
 }
 
@@ -47,16 +91,15 @@
 void *area5_io16_base;
 void *area6_io16_base;
 
-int __init cf_init(void)
+static int __init hs7751rvoip_cf_init(void)
 {
 	pgprot_t prot;
-	unsigned long paddrbase, psize;
+	unsigned long paddrbase;
 
 	/* open I/O area window */
 	paddrbase = virt_to_phys((void *)(PA_AREA5_IO+0x00000800));
-	psize = PAGE_SIZE;
 	prot = PAGE_KERNEL_PCC(1, _PAGE_PCC_COM16);
-	area5_io16_base = p3_ioremap(paddrbase, psize, prot.pgprot);
+	area5_io16_base = p3_ioremap(paddrbase, PAGE_SIZE, prot.pgprot);
 	if (!area5_io16_base) {
 		printk("allocate_cf_area : can't open CF I/O window!\n");
 		return -ENOMEM;
@@ -65,19 +108,18 @@
 	/* XXX : do we need attribute and common-memory area also? */
 
 	paddrbase = virt_to_phys((void *)PA_AREA6_IO);
-	psize = PAGE_SIZE;
 #if defined(CONFIG_HS7751RVOIP_CODEC)
 	prot = PAGE_KERNEL_PCC(0, _PAGE_PCC_COM8);
 #else
 	prot = PAGE_KERNEL_PCC(0, _PAGE_PCC_IO8);
 #endif
-	area6_io8_base = p3_ioremap(paddrbase, psize, prot.pgprot);
+	area6_io8_base = p3_ioremap(paddrbase, PAGE_SIZE, prot.pgprot);
 	if (!area6_io8_base) {
 		printk("allocate_cf_area : can't open CODEC I/O 8bit window!\n");
 		return -ENOMEM;
 	}
 	prot = PAGE_KERNEL_PCC(0, _PAGE_PCC_IO16);
-	area6_io16_base = p3_ioremap(paddrbase, psize, prot.pgprot);
+	area6_io16_base = p3_ioremap(paddrbase, PAGE_SIZE, prot.pgprot);
 	if (!area6_io16_base) {
 		printk("allocate_cf_area : can't open CODEC I/O 16bit window!\n");
 		return -ENOMEM;
@@ -86,4 +128,4 @@
 	return 0;
 }
 
-__initcall (cf_init);
+__initcall(hs7751rvoip_cf_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/io.c linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/io.c
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/io.c	2006-08-23 13:29:24.062254000 +0100
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
+ * Based largely on io_se.c.
+ *
+ * I/O routine for Renesas Solutions Highlander R7780RP-1
+ *
+ * Initial version only to support LAN access; some
+ * placeholder code from io_r7780rp.c left in with the
+ * expectation of later SuperIO and PCMCIA access.
+ */
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/r7780rp/r7780rp.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+
+static inline unsigned long port2adr(unsigned int port)
+{
+	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
+		if (port == 0x3f6)
+			return (PA_AREA5_IO + 0x80c);
+		else
+			return (PA_AREA5_IO + 0x1000 + ((port-0x1f0) << 1));
+	else
+		maybebadio((unsigned long)port);
+
+	return port;
+}
+
+static inline unsigned long port88796l(unsigned int port, int flag)
+{
+	unsigned long addr;
+
+	if (flag)
+		addr = PA_AX88796L + ((port - AX88796L_IO_BASE) << 1);
+	else
+		addr = PA_AX88796L + ((port - AX88796L_IO_BASE) << 1) + 0x1000;
+
+	return addr;
+}
+
+/* The 7780 R7780RP-1 seems to have everything hooked */
+/* up pretty normally (nothing on high-bytes only...) so this */
+/* shouldn't be needed */
+static inline int shifted_port(unsigned long port)
+{
+	/* For IDE registers, value is not shifted */
+	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
+		return 0;
+	else
+		return 1;
+}
+
+#if defined(CONFIG_NE2000) || defined(CONFIG_NE2000_MODULE)
+#define CHECK_AX88796L_PORT(port) \
+  ((port >= AX88796L_IO_BASE) && (port < (AX88796L_IO_BASE+0x20)))
+#else
+#define CHECK_AX88796L_PORT(port) (0)
+#endif
+
+/*
+ * General outline: remap really low stuff [eventually] to SuperIO,
+ * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)
+ * is mapped through the PCI IO window.  Stuff with high bits (PXSEG)
+ * should be way beyond the window, and is used  w/o translation for
+ * compatibility.
+ */
+u8 r7780rp_inb(unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		return ctrl_inw(port88796l(port, 0)) & 0xff;
+	else if (PXSEG(port))
+		return ctrl_inb(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inb(pci_ioaddr(port));
+
+	return ctrl_inw(port2adr(port)) & 0xff;
+}
+
+u8 r7780rp_inb_p(unsigned long port)
+{
+	u8 v;
+
+	if (CHECK_AX88796L_PORT(port))
+		v = ctrl_inw(port88796l(port, 0)) & 0xff;
+	else if (PXSEG(port))
+		v = ctrl_inb(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		v = ctrl_inb(pci_ioaddr(port));
+	else
+		v = ctrl_inw(port2adr(port)) & 0xff;
+
+	ctrl_delay();
+
+	return v;
+}
+
+u16 r7780rp_inw(unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (PXSEG(port))
+		return ctrl_inw(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inw(pci_ioaddr(port));
+	else
+		maybebadio(port);
+
+	return 0;
+}
+
+u32 r7780rp_inl(unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (PXSEG(port))
+		return ctrl_inl(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return ctrl_inl(pci_ioaddr(port));
+	else
+		maybebadio(port);
+
+	return 0;
+}
+
+void r7780rp_outb(u8 value, unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		ctrl_outw(value, port88796l(port, 0));
+	else if (PXSEG(port))
+		ctrl_outb(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outb(value, pci_ioaddr(port));
+	else
+		ctrl_outw(value, port2adr(port));
+}
+
+void r7780rp_outb_p(u8 value, unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		ctrl_outw(value, port88796l(port, 0));
+	else if (PXSEG(port))
+		ctrl_outb(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outb(value, pci_ioaddr(port));
+	else
+		ctrl_outw(value, port2adr(port));
+
+	ctrl_delay();
+}
+
+void r7780rp_outw(u16 value, unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (PXSEG(port))
+		ctrl_outw(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outw(value, pci_ioaddr(port));
+	else
+		maybebadio(port);
+}
+
+void r7780rp_outl(u32 value, unsigned long port)
+{
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (PXSEG(port))
+		ctrl_outl(value, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		ctrl_outl(value, pci_ioaddr(port));
+	else
+		maybebadio(port);
+}
+
+void r7780rp_insb(unsigned long port, void *dst, unsigned long count)
+{
+	volatile u16 *p;
+	u8 *buf = dst;
+
+	if (CHECK_AX88796L_PORT(port)) {
+		p = (volatile u16 *)port88796l(port, 0);
+		while (count--)
+			*buf++ = *p & 0xff;
+	} else if (PXSEG(port)) {
+		while (count--)
+			*buf++ = *(volatile u8 *)port;
+	} else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
+
+		while (count--)
+			*buf++ = *bp;
+	} else {
+		p = (volatile u16 *)port2adr(port);
+		while (count--)
+			*buf++ = *p & 0xff;
+	}
+}
+
+void r7780rp_insw(unsigned long port, void *dst, unsigned long count)
+{
+	volatile u16 *p;
+	u16 *buf = dst;
+
+	if (CHECK_AX88796L_PORT(port))
+		p = (volatile u16 *)port88796l(port, 1);
+	else if (PXSEG(port))
+		p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile u16 *)pci_ioaddr(port);
+	else
+		p = (volatile u16 *)port2adr(port);
+
+	while (count--)
+		*buf++ = *p;
+}
+
+void r7780rp_insl(unsigned long port, void *dst, unsigned long count)
+{
+	u32 *buf = dst;
+
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+
+		while (count--)
+			*buf++ = *p;
+	} else
+		maybebadio(port);
+}
+
+void r7780rp_outsb(unsigned long port, const void *src, unsigned long count)
+{
+	volatile u16 *p;
+	const u8 *buf = src;
+
+	if (CHECK_AX88796L_PORT(port)) {
+		p = (volatile u16 *)port88796l(port, 0);
+		while (count--)
+			*p = *buf++;
+	} else if (PXSEG(port))
+		while (count--)
+			ctrl_outb(*buf++, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u8 *bp = (volatile u8 *)pci_ioaddr(port);
+
+		while (count--)
+			*bp = *buf++;
+	} else {
+		p = (volatile u16 *)port2adr(port);
+		while (count--)
+			*p = *buf++;
+	}
+}
+
+void r7780rp_outsw(unsigned long port, const void *src, unsigned long count)
+{
+	volatile u16 *p;
+	const u16 *buf = src;
+
+	if (CHECK_AX88796L_PORT(port))
+		p = (volatile u16 *)port88796l(port, 1);
+	else if (PXSEG(port))
+		p = (volatile u16 *)port;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile u16 *)pci_ioaddr(port);
+	else
+		p = (volatile u16 *)port2adr(port);
+
+	while (count--)
+		*p = *buf++;
+}
+
+void r7780rp_outsl(unsigned long port, const void *src, unsigned long count)
+{
+	const u32 *buf = src;
+
+	if (CHECK_AX88796L_PORT(port))
+		maybebadio(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		volatile u32 *p = (volatile u32 *)pci_ioaddr(port);
+
+		while (count--)
+			*p = *buf++;
+	} else
+		maybebadio(port);
+}
+
+void __iomem *r7780rp_ioport_map(unsigned long port, unsigned int size)
+{
+	if (CHECK_AX88796L_PORT(port))
+		return (void __iomem *)port88796l(port, size > 1);
+	else if (PXSEG(port))
+		return (void __iomem *)port;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return (void __iomem *)pci_ioaddr(port);
+
+	return (void __iomem *)port2adr(port);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/irq.c linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/irq.c
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/irq.c	2006-08-23 13:29:26.361324000 +0100
@@ -0,0 +1,123 @@
+/*
+ * linux/arch/sh/boards/renesas/r7780rp/irq.c
+ *
+ * Copyright (C) 2000  Kazumoto Kojima
+ *
+ * Renesas Solutions Highlander R7780RP-1 Support.
+ *
+ * Modified for R7780RP-1 by
+ * Atom Create Engineering Co., Ltd. 2002.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/r7780rp/r7780rp.h>
+
+#ifdef CONFIG_SH_R7780MP
+static int mask_pos[] = {12, 11, 9, 14, 15, 8, 13, 6, 5, 4, 3, 2, 0, 0, 1, 0};
+#else
+static int mask_pos[] = {15, 14, 13, 12, 11, 10, 9, 8, 7, 5, 6, 4, 0, 1, 2, 0};
+#endif
+
+static void enable_r7780rp_irq(unsigned int irq);
+static void disable_r7780rp_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_r7780rp_irq disable_r7780rp_irq
+
+static void ack_r7780rp_irq(unsigned int irq);
+static void end_r7780rp_irq(unsigned int irq);
+
+static unsigned int startup_r7780rp_irq(unsigned int irq)
+{
+	enable_r7780rp_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static void disable_r7780rp_irq(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned short val;
+	unsigned short mask = 0xffff ^ (0x0001 << mask_pos[irq]);
+
+	/* Set the priority in IPR to 0 */
+	local_irq_save(flags);
+	val = ctrl_inw(IRLCNTR1);
+	val &= mask;
+	ctrl_outw(val, IRLCNTR1);
+	local_irq_restore(flags);
+}
+
+static void enable_r7780rp_irq(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned short val;
+	unsigned short value = (0x0001 << mask_pos[irq]);
+
+	/* Set priority in IPR back to original value */
+	local_irq_save(flags);
+	val = ctrl_inw(IRLCNTR1);
+	val |= value;
+	ctrl_outw(val, IRLCNTR1);
+	local_irq_restore(flags);
+}
+
+static void ack_r7780rp_irq(unsigned int irq)
+{
+	disable_r7780rp_irq(irq);
+}
+
+static void end_r7780rp_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_r7780rp_irq(irq);
+}
+
+static struct hw_interrupt_type r7780rp_irq_type = {
+	.typename = "R7780RP-IRQ",
+	.startup = startup_r7780rp_irq,
+	.shutdown = shutdown_r7780rp_irq,
+	.enable = enable_r7780rp_irq,
+	.disable = disable_r7780rp_irq,
+	.ack = ack_r7780rp_irq,
+	.end = end_r7780rp_irq,
+};
+
+static void make_r7780rp_irq(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+	irq_desc[irq].handler = &r7780rp_irq_type;
+	disable_r7780rp_irq(irq);
+}
+
+/*
+ * Initialize IRQ setting
+ */
+void __init init_r7780rp_IRQ(void)
+{
+	int i;
+
+	/* IRL0=PCI Slot #A
+	 * IRL1=PCI Slot #B
+	 * IRL2=PCI Slot #C
+	 * IRL3=PCI Slot #D
+	 * IRL4=CF Card
+	 * IRL5=CF Card Insert
+	 * IRL6=M66596
+	 * IRL7=SD Card
+	 * IRL8=Touch Panel
+	 * IRL9=SCI
+	 * IRL10=Serial
+	 * IRL11=Extention #A
+	 * IRL11=Extention #B
+	 * IRL12=Debug LAN
+	 * IRL13=Push Switch
+	 * IRL14=ZiggBee IO
+	 */
+
+	for (i=0; i<15; i++)
+		make_r7780rp_irq(i);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/Kconfig linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/Kconfig
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/Kconfig	2006-08-23 13:29:26.384323000 +0100
@@ -0,0 +1,14 @@
+if SH_R7780RP
+
+menu "R7780RP options"
+
+config SH_R7780MP
+	bool "R7780MP board support"
+	default y
+	help
+	  Selecting this option will enable support for the mass-production
+	  version of the R7780RP. If in doubt, say Y.
+
+endmenu
+
+endif
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/led.c linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/led.c
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/led.c	2006-08-23 13:29:19.734163000 +0100
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) Atom Create Engineering Co., Ltd.
+ *
+ * May be copied or modified under the terms of GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains Renesas Solutions HIGHLANDER R7780RP-1 specific LED code.
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/r7780rp/r7780rp.h>
+
+/* Cycle the LED's in the clasic Knightriger/Sun pattern */
+void heartbeat_r7780rp(void)
+{
+	static unsigned int cnt = 0, period = 0;
+	volatile unsigned short *p = (volatile unsigned short *)PA_OBLED;
+	static unsigned bit = 0, up = 1;
+	unsigned bit_pos[] = {2, 1, 0, 3, 6, 5, 4, 7};
+
+	cnt += 1;
+	if (cnt < period)
+		return;
+
+	cnt = 0;
+
+	/* Go through the points (roughly!):
+	 * f(0)=10, f(1)=16, f(2)=20, f(5)=35, f(int)->110
+	 */
+	period = 110 - ((300 << FSHIFT)/((avenrun[0]/5) + (3<<FSHIFT)));
+
+	*p = 1 << bit_pos[bit];
+	if (up)
+		if (bit == 7) {
+			bit--;
+			up = 0;
+		} else
+			bit++;
+	else if (bit == 0)
+		up = 1;
+	else
+		bit--;
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/Makefile linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/Makefile
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/Makefile	2006-08-23 13:29:19.691163000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the R7780RP-1 specific parts of the kernel
+#
+
+obj-y	 := setup.o io.o irq.o
+obj-$(CONFIG_HEARTBEAT)	+= led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/setup.c linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/setup.c
--- linux-2.6.17.8/arch/sh/boards/renesas/r7780rp/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/r7780rp/setup.c	2006-08-23 13:29:26.390324000 +0100
@@ -0,0 +1,164 @@
+/*
+ * arch/sh/boards/renesas/r7780rp/setup.c
+ *
+ * Copyright (C) 2002 Atom Create Engineering Co., Ltd.
+ * Copyright (C) 2005, 2006 Paul Mundt
+ *
+ * Renesas Solutions Highlander R7780RP-1 Support.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <asm/machvec.h>
+#include <asm/r7780rp/r7780rp.h>
+#include <asm/clock.h>
+#include <asm/io.h>
+
+extern void heartbeat_r7780rp(void);
+extern void init_r7780rp_IRQ(void);
+
+/*
+ * The Machine Vector
+ */
+struct sh_machine_vector mv_r7780rp __initmv = {
+	.mv_nr_irqs		= 109,
+
+	.mv_inb			= r7780rp_inb,
+	.mv_inw			= r7780rp_inw,
+	.mv_inl			= r7780rp_inl,
+	.mv_outb		= r7780rp_outb,
+	.mv_outw		= r7780rp_outw,
+	.mv_outl		= r7780rp_outl,
+
+	.mv_inb_p		= r7780rp_inb_p,
+	.mv_inw_p		= r7780rp_inw,
+	.mv_inl_p		= r7780rp_inl,
+	.mv_outb_p		= r7780rp_outb_p,
+	.mv_outw_p		= r7780rp_outw,
+	.mv_outl_p		= r7780rp_outl,
+
+	.mv_insb		= r7780rp_insb,
+	.mv_insw		= r7780rp_insw,
+	.mv_insl		= r7780rp_insl,
+	.mv_outsb		= r7780rp_outsb,
+	.mv_outsw		= r7780rp_outsw,
+	.mv_outsl		= r7780rp_outsl,
+
+	.mv_ioport_map		= r7780rp_ioport_map,
+	.mv_init_irq		= init_r7780rp_IRQ,
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_r7780rp,
+#endif
+};
+ALIAS_MV(r7780rp)
+
+static struct resource m66596_usb_host_resources[] = {
+	[0] = {
+		.start	= 0xa4800000,
+		.end	= 0xa4ffffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 6,		/* irq number */
+		.end	= 6,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device m66596_usb_host_device = {
+	.name		= "m66596-hcd",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= NULL,		/* don't use dma */
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(m66596_usb_host_resources),
+	.resource	= m66596_usb_host_resources,
+};
+
+static struct platform_device *r7780rp_devices[] __initdata = {
+	&m66596_usb_host_device,
+};
+
+static int __init r7780rp_devices_setup(void)
+{
+	return platform_add_devices(r7780rp_devices,
+				    ARRAY_SIZE(r7780rp_devices));
+}
+__initcall(r7780rp_devices_setup);
+
+/*
+ * Platform specific clocks
+ */
+static void ivdr_clk_enable(struct clk *clk)
+{
+	ctrl_outw(ctrl_inw(PA_IVDRCTL) | (1 << 8), PA_IVDRCTL);
+}
+
+static void ivdr_clk_disable(struct clk *clk)
+{
+	ctrl_outw(ctrl_inw(PA_IVDRCTL) & ~(1 << 8), PA_IVDRCTL);
+}
+
+static struct clk_ops ivdr_clk_ops = {
+	.enable		= ivdr_clk_enable,
+	.disable	= ivdr_clk_disable,
+};
+
+static struct clk ivdr_clk = {
+	.name		= "ivdr_clk",
+	.ops		= &ivdr_clk_ops,
+};
+
+static struct clk *r7780rp_clocks[] = {
+	&ivdr_clk,
+};
+
+const char *get_system_type(void)
+{
+	return "Highlander R7780RP-1";
+}
+
+static void r7780rp_power_off(void)
+{
+#ifdef CONFIG_SH_R7780MP
+	ctrl_outw(0x0001, PA_POFF);
+#endif
+}
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	u16 ver = ctrl_inw(PA_VERREG);
+	int i;
+
+	printk(KERN_INFO "Renesas Solutions Highlander R7780RP-1 support.\n");
+
+	printk(KERN_INFO "Board version: %d (revision %d), "
+			 "FPGA version: %d (revision %d)\n",
+			 (ver >> 12) & 0xf, (ver >> 8) & 0xf,
+			 (ver >>  4) & 0xf, ver & 0xf);
+
+	/*
+	 * Enable the important clocks right away..
+	 */
+	for (i = 0; i < ARRAY_SIZE(r7780rp_clocks); i++) {
+		struct clk *clk = r7780rp_clocks[i];
+
+		clk_register(clk);
+		clk_enable(clk);
+	}
+
+	ctrl_outw(0x0000, PA_OBLED);	/* Clear LED. */
+#ifndef CONFIG_SH_R7780MP
+	ctrl_outw(0x0001, PA_SDPOW);	/* SD Power ON */
+#endif
+	ctrl_outw(ctrl_inw(PA_IVDRCTL) | 0x0100, PA_IVDRCTL);	/* Si13112 */
+
+	pm_power_off = r7780rp_power_off;
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/io.c linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/io.c
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/io.c	2006-08-23 13:29:24.072255000 +0100
@@ -1,6 +1,4 @@
 /*
- * linux/arch/sh/kernel/io_rts7751r2d.c
- *
  * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
  * Based largely on io_se.c.
  *
@@ -10,17 +8,13 @@
  * placeholder code from io_rts7751r2d.c left in with the
  * expectation of later SuperIO and PCMCIA access.
  */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <asm/io.h>
+#include <linux/pci.h>
 #include <asm/rts7751r2d/rts7751r2d.h>
+#include <asm/io.h>
 #include <asm/addrspace.h>
 
-#include <linux/module.h>
-#include <linux/pci.h>
-#include "../../../drivers/pci/pci-sh7751.h"
-
 /*
  * The 7751R RTS7751R2D uses the built-in PCI controller (PCIC)
  * of the 7751R processor, and has a SuperIO accessible via the PCI.
@@ -28,22 +22,6 @@
  * like the other Solution Engine boards.
  */
 
-#define PCIIOBR		(volatile long *)PCI_REG(SH7751_PCIIOBR)
-#define PCIMBR          (volatile long *)PCI_REG(SH7751_PCIMBR)
-#define PCI_IO_AREA	SH7751_PCI_IO_BASE
-#define PCI_MEM_AREA	SH7751_PCI_CONFIG_BASE
-
-#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7751_PCIIOBR_MASK))
-
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
 static inline unsigned long port2adr(unsigned int port)
 {
 	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
@@ -52,7 +30,7 @@
 		else
 			return (PA_AREA5_IO + 0x1000 + ((port-0x1f0) << 1));
 	else
-		maybebadio(port2adr, (unsigned long)port);
+		maybebadio((unsigned long)port);
 
 	return port;
 }
@@ -81,17 +59,6 @@
 		return 1;
 }
 
-/* In case someone configures the kernel w/o PCI support: in that */
-/* scenario, don't ever bother to check for PCI-window addresses */
-
-/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
-#if defined(CONFIG_PCI)
-#define CHECK_SH7751_PCIIO(port) \
-  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7751_PCI_IO_SIZE)))
-#else
-#define CHECK_SH7751_PCIIO(port) (0)
-#endif
-
 #if defined(CONFIG_NE2000) || defined(CONFIG_NE2000_MODULE)
 #define CHECK_AX88796L_PORT(port) \
   ((port >= AX88796L_IO_BASE) && (port < (AX88796L_IO_BASE+0x20)))
@@ -112,8 +79,8 @@
 		return (*(volatile unsigned short *)port88796l(port, 0)) & 0xff;
 	else if (PXSEG(port))
 		return *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		return *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return *(volatile unsigned char *)pci_ioaddr(port);
 	else
 		return (*(volatile unsigned short *)port2adr(port) & 0xff);
 }
@@ -126,11 +93,12 @@
 		v = (*(volatile unsigned short *)port88796l(port, 0)) & 0xff;
         else if (PXSEG(port))
 		v = *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		v = *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		v = *(volatile unsigned char *)pci_ioaddr(port);
 	else
 		v = (*(volatile unsigned short *)port2adr(port) & 0xff);
-	delay();
+
+	ctrl_delay();
 
 	return v;
 }
@@ -138,13 +106,13 @@
 unsigned short rts7751r2d_inw(unsigned long port)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(inw, port);
+		maybebadio(port);
         else if (PXSEG(port))
 		return *(volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		return *(volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return *(volatile unsigned short *)pci_ioaddr(port);
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 
 	return 0;
 }
@@ -152,13 +120,13 @@
 unsigned int rts7751r2d_inl(unsigned long port)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(inl, port);
+		maybebadio(port);
         else if (PXSEG(port))
 		return *(volatile unsigned long *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		return *(volatile unsigned long *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		return *(volatile unsigned long *)pci_ioaddr(port);
 	else
-		maybebadio(inl, port);
+		maybebadio(port);
 
 	return 0;
 }
@@ -169,8 +137,8 @@
 		*((volatile unsigned short *)port88796l(port, 0)) = value;
         else if (PXSEG(port))
 		*(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		*(volatile unsigned char *)PCI_IOMAP(port) = value;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		*(volatile unsigned char *)pci_ioaddr(port) = value;
 	else
 		*(volatile unsigned short *)port2adr(port) = value;
 }
@@ -181,143 +149,152 @@
 		*((volatile unsigned short *)port88796l(port, 0)) = value;
         else if (PXSEG(port))
 		*(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		*(volatile unsigned char *)PCI_IOMAP(port) = value;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		*(volatile unsigned char *)pci_ioaddr(port) = value;
 	else
 		*(volatile unsigned short *)port2adr(port) = value;
-	delay();
+
+	ctrl_delay();
 }
 
 void rts7751r2d_outw(unsigned short value, unsigned long port)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(outw, port);
+		maybebadio(port);
         else if (PXSEG(port))
 		*(volatile unsigned short *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		*(volatile unsigned short *)PCI_IOMAP(port) = value;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		*(volatile unsigned short *)pci_ioaddr(port) = value;
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
 void rts7751r2d_outl(unsigned int value, unsigned long port)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(outl, port);
+		maybebadio(port);
         else if (PXSEG(port))
 		*(volatile unsigned long *)port = value;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		*(volatile unsigned long *)PCI_IOMAP(port) = value;
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		*(volatile unsigned long *)pci_ioaddr(port) = value;
 	else
-		maybebadio(outl, port);
+		maybebadio(port);
 }
 
 void rts7751r2d_insb(unsigned long port, void *addr, unsigned long count)
 {
+	unsigned long a = (unsigned long)addr;
 	volatile __u8 *bp;
 	volatile __u16 *p;
-	unsigned char *s = addr;
 
 	if (CHECK_AX88796L_PORT(port)) {
 		p = (volatile unsigned short *)port88796l(port, 0);
-		while (count--) *s++ = *p & 0xff;
+		while (count--)
+			ctrl_outb(*p & 0xff, a++);
 	} else if (PXSEG(port))
-		while (count--) *s++ = *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		bp = (__u8 *)PCI_IOMAP(port);
-		while (count--) *s++ = *bp;
+		while (count--)
+			ctrl_outb(ctrl_inb(port), a++);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		bp = (__u8 *)pci_ioaddr(port);
+		while (count--)
+			ctrl_outb(*bp, a++);
 	} else {
 		p = (volatile unsigned short *)port2adr(port);
-		while (count--) *s++ = *p & 0xff;
+		while (count--)
+			ctrl_outb(*p & 0xff, a++);
 	}
 }
 
 void rts7751r2d_insw(unsigned long port, void *addr, unsigned long count)
 {
+	unsigned long a = (unsigned long)addr;
 	volatile __u16 *p;
-	__u16 *s = addr;
 
 	if (CHECK_AX88796L_PORT(port))
 		p = (volatile unsigned short *)port88796l(port, 1);
 	else if (PXSEG(port))
 		p = (volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		p = (volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile unsigned short *)pci_ioaddr(port);
 	else
 		p = (volatile unsigned short *)port2adr(port);
-	while (count--) *s++ = *p;
+	while (count--)
+		ctrl_outw(*p, a++);
 }
 
 void rts7751r2d_insl(unsigned long port, void *addr, unsigned long count)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(insl, port);
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u32 *p = (__u32 *)PCI_IOMAP(port);
-		__u32 *s = addr;
-
-		while (count--) *s++ = *p;
+		maybebadio(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		unsigned long a = (unsigned long)addr;
+
+		while (count--) {
+			ctrl_outl(ctrl_inl(pci_ioaddr(port)), a);
+			a += 4;
+		}
 	} else
-		maybebadio(insl, port);
+		maybebadio(port);
 }
 
 void rts7751r2d_outsb(unsigned long port, const void *addr, unsigned long count)
 {
+	unsigned long a = (unsigned long)addr;
 	volatile __u8 *bp;
 	volatile __u16 *p;
-	const __u8 *s = addr;
 
 	if (CHECK_AX88796L_PORT(port)) {
 		p = (volatile unsigned short *)port88796l(port, 0);
-		while (count--) *p = *s++;
+		while (count--)
+			*p = ctrl_inb(a++);
 	} else if (PXSEG(port))
-		while (count--) *(volatile unsigned char *)port = *s++;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		bp = (__u8 *)PCI_IOMAP(port);
-		while (count--) *bp = *s++;
+		while (count--)
+			ctrl_outb(a++, port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		bp = (__u8 *)pci_ioaddr(port);
+		while (count--)
+			*bp = ctrl_inb(a++);
 	} else {
 		p = (volatile unsigned short *)port2adr(port);
-		while (count--) *p = *s++;
+		while (count--)
+			*p = ctrl_inb(a++);
 	}
 }
 
 void rts7751r2d_outsw(unsigned long port, const void *addr, unsigned long count)
 {
+	unsigned long a = (unsigned long)addr;
 	volatile __u16 *p;
-	const __u16 *s = addr;
 
 	if (CHECK_AX88796L_PORT(port))
 		p = (volatile unsigned short *)port88796l(port, 1);
 	else if (PXSEG(port))
 		p = (volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port))
-		p = (volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port))
+		p = (volatile unsigned short *)pci_ioaddr(port);
 	else
 		p = (volatile unsigned short *)port2adr(port);
-	while (count--) *p = *s++;
+
+	while (count--) {
+		ctrl_outw(*p, a);
+		a += 2;
+	}
 }
 
 void rts7751r2d_outsl(unsigned long port, const void *addr, unsigned long count)
 {
 	if (CHECK_AX88796L_PORT(port))
-		maybebadio(outsl, port);
-	else if (CHECK_SH7751_PCIIO(port) || shifted_port(port)) {
-		volatile __u32 *p = (__u32 *)PCI_IOMAP(port);
-		const __u32 *s = addr;
-
-		while (count--) *p = *s++;
+		maybebadio(port);
+	else if (is_pci_ioaddr(port) || shifted_port(port)) {
+		unsigned long a = (unsigned long)addr;
+
+		while (count--) {
+			ctrl_outl(ctrl_inl(a), pci_ioaddr(port));
+			a += 4;
+		}
 	} else
-		maybebadio(outsl, port);
-}
-
-void *rts7751r2d_ioremap(unsigned long offset, unsigned long size)
-{
-	if (offset >= 0xfd000000)
-		return (void *)offset;
-	else
-		return (void *)P2SEGADDR(offset);
+		maybebadio(port);
 }
-EXPORT_SYMBOL(rts7751r2d_ioremap);
 
 unsigned long rts7751r2d_isa_port2addr(unsigned long offset)
 {
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/Kconfig linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/Kconfig
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/Kconfig	2006-08-23 13:29:12.641001000 +0100
@@ -0,0 +1,12 @@
+if SH_RTS7751R2D
+
+menu "RTS7751R2D options"
+
+config RTS7751R2D_REV11
+	bool "RTS7751R2D Rev. 1.1 board support"
+	help
+	  Selecting this option will support version rev. 1.1.
+endmenu
+
+endif
+
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/led.c linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/led.c
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/led.c	2006-08-23 13:29:26.876326000 +0100
@@ -13,8 +13,6 @@
 #include <asm/io.h>
 #include <asm/rts7751r2d/rts7751r2d.h>
 
-extern unsigned int debug_counter;
-
 #ifdef CONFIG_HEARTBEAT
 
 #include <linux/sched.h>
@@ -56,12 +54,3 @@
 	ctrl_outw(value, PA_OUTPORT);
 }
 
-void debug_led_disp(void)
-{
-	unsigned short value;
-
-	value = (unsigned short)debug_counter++;
-	rts7751r2d_led(value);
-	if (value == 0xff)
-		debug_counter = 0;
-}
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/mach.c linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/mach.c
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/mach.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/mach.c	2006-08-23 13:29:17.337116000 +0100
@@ -16,15 +16,16 @@
 #include <asm/machvec.h>
 #include <asm/rtc.h>
 #include <asm/irq.h>
-#include <asm/rts7751r2d/io.h>
+#include <asm/mach/rts7751r2d.h>
 
 extern void heartbeat_rts7751r2d(void);
 extern void init_rts7751r2d_IRQ(void);
-extern void *rts7751r2d_ioremap(unsigned long, unsigned long);
 extern int rts7751r2d_irq_demux(int irq);
 
+#ifdef CONFIG_USB_SM501
 extern void *voyagergx_consistent_alloc(struct device *, size_t, dma_addr_t *, gfp_t);
 extern int voyagergx_consistent_free(struct device *, size_t, void *, dma_addr_t);
+#endif
 
 /*
  * The Machine Vector
@@ -54,15 +55,13 @@
 	.mv_outsw		= rts7751r2d_outsw,
 	.mv_outsl		= rts7751r2d_outsl,
 
-	.mv_ioremap		= rts7751r2d_ioremap,
-	.mv_isa_port2addr	= rts7751r2d_isa_port2addr,
 	.mv_init_irq		= init_rts7751r2d_IRQ,
 #ifdef CONFIG_HEARTBEAT
 	.mv_heartbeat		= heartbeat_rts7751r2d,
 #endif
 	.mv_irq_demux		= rts7751r2d_irq_demux,
 
-#ifdef CONFIG_USB_OHCI_HCD
+#ifdef CONFIG_USB_SM501
 	.mv_consistent_alloc	= voyagergx_consistent_alloc,
 	.mv_consistent_free	= voyagergx_consistent_free,
 #endif
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/Makefile linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/Makefile
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/Makefile	2006-08-23 13:29:15.405072000 +0100
@@ -1,10 +1,6 @@
 #
 # Makefile for the RTS7751R2D specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o setup.o io.o irq.o led.o
 
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/setup.c linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/setup.c
--- linux-2.6.17.8/arch/sh/boards/renesas/rts7751r2d/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/rts7751r2d/setup.c	2006-08-23 13:29:28.006346000 +0100
@@ -1,25 +1,87 @@
 /*
- * linux/arch/sh/kernel/setup_rts7751r2d.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
  * Renesas Technology Sales RTS7751R2D Support.
  *
- * Modified for RTS7751R2D by
- * Atom Create Engineering Co., Ltd. 2002.
+ * Copyright (C) 2002 Atom Create Engineering Co., Ltd.
+ * Copyright (C) 2004 - 2006 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
 #include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/pm.h>
 #include <asm/io.h>
-#include <asm/rts7751r2d/rts7751r2d.h>
+#include <asm/mach/rts7751r2d.h>
+#include <asm/voyagergx.h>
+
+static struct plat_serial8250_port uart_platform_data[] = {
+	{
+		.membase	= (void *)VOYAGER_UART_BASE,
+		.mapbase	= VOYAGER_UART_BASE,
+		.iotype		= UPIO_MEM,
+		.irq		= VOYAGER_UART0_IRQ,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.regshift	= 2,
+		.uartclk	= (9600 * 16),
+	}, {
+		.flags		= 0,
+	},
+};
 
-unsigned int debug_counter;
+static void __init voyagergx_serial_init(void)
+{
+	unsigned long val;
+
+	/*
+	 * GPIO Control
+	 */
+	val = inl(GPIO_MUX_HIGH);
+	val |= 0x00001fe0;
+	outl(val, GPIO_MUX_HIGH);
+
+	/*
+	 * Power Mode Gate
+	 */
+	val = inl(POWER_MODE0_GATE);
+	val |= (POWER_MODE0_GATE_U0 | POWER_MODE0_GATE_U1);
+	outl(val, POWER_MODE0_GATE);
+
+	val = inl(POWER_MODE1_GATE);
+	val |= (POWER_MODE1_GATE_U0 | POWER_MODE1_GATE_U1);
+	outl(val, POWER_MODE1_GATE);
+}
+
+static struct platform_device uart_device = {
+	.name		= "serial8250",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= uart_platform_data,
+	},
+};
+
+static struct platform_device *rts7751r2d_devices[] __initdata = {
+	&uart_device,
+};
+
+static int __init rts7751r2d_devices_setup(void)
+{
+	return platform_add_devices(rts7751r2d_devices,
+				    ARRAY_SIZE(rts7751r2d_devices));
+}
+__initcall(rts7751r2d_devices_setup);
 
 const char *get_system_type(void)
 {
 	return "RTS7751R2D";
 }
 
+static void rts7751r2d_power_off(void)
+{
+	ctrl_outw(0x0001, PA_POWOFF);
+}
+
 /*
  * Initialize the board
  */
@@ -27,5 +89,7 @@
 {
 	printk(KERN_INFO "Renesas Technology Sales RTS7751R2D support.\n");
 	ctrl_outw(0x0000, PA_OUTPORT);
-	debug_counter = 0;
+	pm_power_off = rts7751r2d_power_off;
+
+	voyagergx_serial_init();
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/systemh/io.c linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/io.c
--- linux-2.6.17.8/arch/sh/boards/renesas/systemh/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/io.c	2006-08-23 13:29:24.081256000 +0100
@@ -5,66 +5,25 @@
  * Based largely on io_se.c.
  *
  * I/O routine for Hitachi 7751 Systemh.
- *
  */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <asm/systemh/7751systemh.h>
+#include <linux/pci.h>
+#include <asm/systemh7751.h>
 #include <asm/addrspace.h>
 #include <asm/io.h>
 
-#include <linux/pci.h>
-#include "../../drivers/pci/pci-sh7751.h"
-
-/*
- * The 7751 SystemH Engine uses the built-in PCI controller (PCIC)
- * of the 7751 processor, and has a SuperIO accessible on its memory
- * bus.
- */
-
-#define PCIIOBR		(volatile long *)PCI_REG(SH7751_PCIIOBR)
-#define PCIMBR          (volatile long *)PCI_REG(SH7751_PCIMBR)
-#define PCI_IO_AREA	SH7751_PCI_IO_BASE
-#define PCI_MEM_AREA	SH7751_PCI_CONFIG_BASE
-
-#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7751_PCIIOBR_MASK))
 #define ETHER_IOMAP(adr) (0xB3000000 + (adr)) /*map to 16bits access area
                                                 of smc lan chip*/
-
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
 static inline volatile __u16 *
 port2adr(unsigned int port)
 {
 	if (port >= 0x2000)
 		return (volatile __u16 *) (PA_MRSHPC + (port - 0x2000));
-#if 0
-	else
-		return (volatile __u16 *) (PA_SUPERIO + (port << 1));
-#endif
-	maybebadio(name,(unsigned long)port);
+	maybebadio((unsigned long)port);
 	return (volatile __u16*)port;
 }
 
-/* In case someone configures the kernel w/o PCI support: in that */
-/* scenario, don't ever bother to check for PCI-window addresses */
-
-/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
-#if defined(CONFIG_PCI)
-#define CHECK_SH7751_PCIIO(port) \
-  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7751_PCI_IO_SIZE)))
-#else
-#define CHECK_SH7751_PCIIO(port) (0)
-#endif
-
 /*
  * General outline: remap really low stuff [eventually] to SuperIO,
  * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)
@@ -76,8 +35,8 @@
 {
 	if (PXSEG(port))
 		return *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		return *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		return *(volatile unsigned char *)pci_ioaddr(port);
 	else if (port <= 0x3F1)
 		return *(volatile unsigned char *)ETHER_IOMAP(port);
 	else
@@ -90,13 +49,13 @@
 
         if (PXSEG(port))
                 v = *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                v = *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                v = *(volatile unsigned char *)pci_ioaddr(port);
 	else if (port <= 0x3F1)
 		v = *(volatile unsigned char *)ETHER_IOMAP(port);
 	else
 		v = (*port2adr(port))&0xff;
-	delay();
+	ctrl_delay();
 	return v;
 }
 
@@ -104,14 +63,14 @@
 {
         if (PXSEG(port))
                 return *(volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                return *(volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                return *(volatile unsigned short *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else if (port <= 0x3F1)
 		return *(volatile unsigned int *)ETHER_IOMAP(port);
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 	return 0;
 }
 
@@ -119,14 +78,14 @@
 {
         if (PXSEG(port))
                 return *(volatile unsigned long *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                return *(volatile unsigned int *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                return *(volatile unsigned int *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else if (port <= 0x3F1)
 		return *(volatile unsigned int *)ETHER_IOMAP(port);
 	else
-		maybebadio(inl, port);
+		maybebadio(port);
 	return 0;
 }
 
@@ -135,8 +94,8 @@
 
         if (PXSEG(port))
                 *(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else if (port <= 0x3F1)
 		*(volatile unsigned char *)ETHER_IOMAP(port) = value;
 	else
@@ -147,37 +106,37 @@
 {
         if (PXSEG(port))
                 *(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else if (port <= 0x3F1)
 		*(volatile unsigned char *)ETHER_IOMAP(port) = value;
 	else
 		*(port2adr(port)) = value;
-	delay();
+	ctrl_delay();
 }
 
 void sh7751systemh_outw(unsigned short value, unsigned long port)
 {
         if (PXSEG(port))
                 *(volatile unsigned short *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned short *)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned short *)pci_ioaddr(port)) = value;
 	else if (port >= 0x2000)
 		*port2adr(port) = value;
 	else if (port <= 0x3F1)
 		*(volatile unsigned short *)ETHER_IOMAP(port) = value;
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
 void sh7751systemh_outl(unsigned int value, unsigned long port)
 {
         if (PXSEG(port))
                 *(volatile unsigned long *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned long*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned long*)pci_ioaddr(port)) = value;
 	else
-		maybebadio(outl, port);
+		maybebadio(port);
 }
 
 void sh7751systemh_insb(unsigned long port, void *addr, unsigned long count)
@@ -194,7 +153,7 @@
 
 void sh7751systemh_insl(unsigned long port, void *addr, unsigned long count)
 {
-	maybebadio(insl, port);
+	maybebadio(port);
 }
 
 void sh7751systemh_outsb(unsigned long port, const void *addr, unsigned long count)
@@ -211,73 +170,5 @@
 
 void sh7751systemh_outsl(unsigned long port, const void *addr, unsigned long count)
 {
-	maybebadio(outsw, port);
-}
-
-/* For read/write calls, just copy generic (pass-thru); PCIMBR is  */
-/* already set up.  For a larger memory space, these would need to */
-/* reset PCIMBR as needed on a per-call basis...                   */
-
-unsigned char sh7751systemh_readb(unsigned long addr)
-{
-	return *(volatile unsigned char*)addr;
-}
-
-unsigned short sh7751systemh_readw(unsigned long addr)
-{
-	return *(volatile unsigned short*)addr;
-}
-
-unsigned int sh7751systemh_readl(unsigned long addr)
-{
-	return *(volatile unsigned long*)addr;
-}
-
-void sh7751systemh_writeb(unsigned char b, unsigned long addr)
-{
-	*(volatile unsigned char*)addr = b;
-}
-
-void sh7751systemh_writew(unsigned short b, unsigned long addr)
-{
-	*(volatile unsigned short*)addr = b;
-}
-
-void sh7751systemh_writel(unsigned int b, unsigned long addr)
-{
-        *(volatile unsigned long*)addr = b;
-}
-
-
-
-/* Map ISA bus address to the real address. Only for PCMCIA.  */
-
-/* ISA page descriptor.  */
-static __u32 sh_isa_memmap[256];
-
-#if 0
-static int
-sh_isa_mmap(__u32 start, __u32 length, __u32 offset)
-{
-	int idx;
-
-	if (start >= 0x100000 || (start & 0xfff) || (length != 0x1000))
-		return -1;
-
-	idx = start >> 12;
-	sh_isa_memmap[idx] = 0xb8000000 + (offset &~ 0xfff);
-	printk("sh_isa_mmap: start %x len %x offset %x (idx %x paddr %x)\n",
-	       start, length, offset, idx, sh_isa_memmap[idx]);
-	return 0;
-}
-#endif
-
-unsigned long
-sh7751systemh_isa_port2addr(unsigned long offset)
-{
-	int idx;
-
-	idx = (offset >> 12) & 0xff;
-	offset &= 0xfff;
-	return sh_isa_memmap[idx] + offset;
+	maybebadio(port);
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/systemh/irq.c linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/irq.c
--- linux-2.6.17.8/arch/sh/boards/renesas/systemh/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/irq.c	2006-08-23 13:29:19.080140000 +0100
@@ -16,7 +16,7 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <asm/io.h>
-#include <asm/mach/7751systemh.h>
+#include <asm/systemh7751.h>
 #include <asm/smc37c93x.h>
 
 /* address of external interrupt mask register
diff -Naur linux-2.6.17.8/arch/sh/boards/renesas/systemh/setup.c linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/setup.c
--- linux-2.6.17.8/arch/sh/boards/renesas/systemh/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/renesas/systemh/setup.c	2006-08-23 13:29:19.088139000 +0100
@@ -15,9 +15,8 @@
  * for more details.
  */
 #include <linux/init.h>
-#include <asm/mach/7751systemh.h>
-#include <asm/mach/io.h>
 #include <asm/machvec.h>
+#include <asm/systemh7751.h>
 
 extern void make_systemh_irq(unsigned int irq);
 
@@ -31,8 +30,6 @@
  */
 void __init init_7751systemh_IRQ(void)
 {
-/*  	make_ipr_irq(10, BCR_ILCRD, 1, 0x0f-10); LAN */
-/*  	make_ipr_irq(14, BCR_ILCRA, 2, 0x0f-4); */
 	make_systemh_irq(0xb);	/* Ethernet interrupt */
 }
 
@@ -60,15 +57,6 @@
 	.mv_outsw		= sh7751systemh_outsw,
 	.mv_outsl		= sh7751systemh_outsl,
 
-	.mv_readb		= sh7751systemh_readb,
-	.mv_readw		= sh7751systemh_readw,
-	.mv_readl		= sh7751systemh_readl,
-	.mv_writeb		= sh7751systemh_writeb,
-	.mv_writew		= sh7751systemh_writew,
-	.mv_writel		= sh7751systemh_writel,
-
-	.mv_isa_port2addr	= sh7751systemh_isa_port2addr,
-
 	.mv_init_irq		= init_7751systemh_IRQ,
 };
 ALIAS_MV(7751systemh)
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7300/io.c linux-2.6.17.8-sh/arch/sh/boards/se/7300/io.c
--- linux-2.6.17.8/arch/sh/boards/se/7300/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7300/io.c	2006-08-23 13:29:18.227139000 +0100
@@ -10,8 +10,8 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <asm/mach/se7300.h>
 #include <asm/io.h>
+#include <asm/se7300.h>
 
 #define badio(fn, a) panic("bad i/o operation %s for %08lx.", #fn, a)
 
@@ -100,6 +100,7 @@
 	badio(inw, port);
 }
 
+#ifdef CONFIG_SMC91X
 /* MSTLANEX01 LAN at 0xb400:0000 */
 static struct iop laniop = {
 	.start = 0x300,
@@ -111,6 +112,7 @@
 	.outb = simple_outb,
 	.outw = simple_outw,
 };
+#endif
 
 /* NE2000 pc card NIC */
 static struct iop neiop = {
@@ -124,6 +126,7 @@
 	.outw = simple_outw,
 };
 
+#ifdef CONFIG_IDE
 /* CF in CF slot */
 static struct iop cfiop = {
 	.base = 0xb0600000,
@@ -133,12 +136,13 @@
 	.outb = pcc_outb,
 	.outw = simple_outw,
 };
+#endif
 
 static __inline__ struct iop *
 port2iop(unsigned long port)
 {
 	if (0) ;
-#if defined(CONFIG_SMC91111)
+#if defined(CONFIG_SMC91X)
 	else if (laniop.check(&laniop, port))
 		return &laniop;
 #endif
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7300/irq.c linux-2.6.17.8-sh/arch/sh/boards/se/7300/irq.c
--- linux-2.6.17.8/arch/sh/boards/se/7300/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7300/irq.c	2006-08-23 13:29:18.267139000 +0100
@@ -12,7 +12,7 @@
 #include <linux/irq.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/mach/se7300.h>
+#include <asm/se7300.h>
 
 /*
  * Initialize IRQ setting
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7300/led.c linux-2.6.17.8-sh/arch/sh/boards/se/7300/led.c
--- linux-2.6.17.8/arch/sh/boards/se/7300/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7300/led.c	2006-08-23 13:29:18.275139000 +0100
@@ -13,24 +13,10 @@
 
 #include <linux/config.h>
 #include <linux/sched.h>
-#include <asm/mach/se7300.h>
-
-static void
-mach_led(int position, int value)
-{
-	volatile unsigned short *p = (volatile unsigned short *) PA_LED;
-
-	if (value) {
-		*p |= (1 << 8);
-	} else {
-		*p &= ~(1 << 8);
-	}
-}
-
+#include <asm/se7300.h>
 
 /* Cycle the LED's in the clasic Knightrider/Sun pattern */
-void
-heartbeat_7300se(void)
+void heartbeat_7300se(void)
 {
 	static unsigned int cnt = 0, period = 0;
 	volatile unsigned short *p = (volatile unsigned short *) PA_LED;
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7300/setup.c linux-2.6.17.8-sh/arch/sh/boards/se/7300/setup.c
--- linux-2.6.17.8/arch/sh/boards/se/7300/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7300/setup.c	2006-08-23 13:29:18.282139000 +0100
@@ -10,8 +10,7 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <asm/machvec.h>
-#include <asm/machvec_init.h>
-#include <asm/mach/io.h>
+#include <asm/se7300.h>
 
 void heartbeat_7300se(void);
 void init_7300se_IRQ(void);
diff -Naur linux-2.6.17.8/arch/sh/boards/se/73180/io.c linux-2.6.17.8-sh/arch/sh/boards/se/73180/io.c
--- linux-2.6.17.8/arch/sh/boards/se/73180/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/73180/io.c	2006-08-23 13:29:10.933955000 +0100
@@ -100,6 +100,7 @@
 	badio(inw, port);
 }
 
+#ifdef CONFIG_SMC91X
 /* MSTLANEX01 LAN at 0xb400:0000 */
 static struct iop laniop = {
 	.start = 0x300,
@@ -111,6 +112,7 @@
 	.outb = simple_outb,
 	.outw = simple_outw,
 };
+#endif
 
 /* NE2000 pc card NIC */
 static struct iop neiop = {
@@ -124,6 +126,7 @@
 	.outw = simple_outw,
 };
 
+#ifdef CONFIG_IDE
 /* CF in CF slot */
 static struct iop cfiop = {
 	.base = 0xb0600000,
@@ -133,12 +136,13 @@
 	.outb = pcc_outb,
 	.outw = simple_outw,
 };
+#endif
 
 static __inline__ struct iop *
 port2iop(unsigned long port)
 {
 	if (0) ;
-#if defined(CONFIG_SMC91111)
+#if defined(CONFIG_SMC91X)
 	else if (laniop.check(&laniop, port))
 		return &laniop;
 #endif
diff -Naur linux-2.6.17.8/arch/sh/boards/se/73180/irq.c linux-2.6.17.8-sh/arch/sh/boards/se/73180/irq.c
--- linux-2.6.17.8/arch/sh/boards/se/73180/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/73180/irq.c	2006-08-23 13:29:10.989955000 +0100
@@ -7,7 +7,6 @@
  * Modified for SH-Mobile SolutionEngine 73180 Support
  *              by YOSHII Takashi <yoshii-takashi@hitachi-ul.co.jp>
  *
- *
  */
 
 #include <linux/config.h>
@@ -18,14 +17,6 @@
 #include <asm/mach/se73180.h>
 
 static int
-intreq2irq(int i)
-{
-	if (i == 5)
-		return 10;
-	return 32 + 7 - i;
-}
-
-static int
 irq2intreq(int irq)
 {
 	if (irq == 10)
diff -Naur linux-2.6.17.8/arch/sh/boards/se/73180/led.c linux-2.6.17.8-sh/arch/sh/boards/se/73180/led.c
--- linux-2.6.17.8/arch/sh/boards/se/73180/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/73180/led.c	2006-08-23 13:29:11.019955000 +0100
@@ -15,21 +15,8 @@
 #include <linux/sched.h>
 #include <asm/mach/se73180.h>
 
-static void
-mach_led(int position, int value)
-{
-	volatile unsigned short *p = (volatile unsigned short *) PA_LED;
-
-	if (value) {
-		*p |= (1 << LED_SHIFT);
-	} else {
-		*p &= ~(1 << LED_SHIFT);
-	}
-}
-
 /* Cycle the LED's in the clasic Knightrider/Sun pattern */
-void
-heartbeat_73180se(void)
+void heartbeat_73180se(void)
 {
 	static unsigned int cnt = 0, period = 0;
 	volatile unsigned short *p = (volatile unsigned short *) PA_LED;
diff -Naur linux-2.6.17.8/arch/sh/boards/se/73180/setup.c linux-2.6.17.8-sh/arch/sh/boards/se/73180/setup.c
--- linux-2.6.17.8/arch/sh/boards/se/73180/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/73180/setup.c	2006-08-23 13:29:20.685186000 +0100
@@ -12,8 +12,8 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <asm/machvec.h>
-#include <asm/machvec_init.h>
-#include <asm/mach/io.h>
+#include <asm/se73180.h>
+#include <asm/irq.h>
 
 void heartbeat_73180se(void);
 void init_73180se_IRQ(void);
@@ -52,6 +52,7 @@
 	.mv_outsl = sh73180se_outsl,
 
 	.mv_init_irq = init_73180se_IRQ,
+	.mv_irq_demux = shmse_irq_demux,
 #ifdef CONFIG_HEARTBEAT
 	.mv_heartbeat = heartbeat_73180se,
 #endif
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/io.c linux-2.6.17.8-sh/arch/sh/boards/se/770x/io.c
--- linux-2.6.17.8/arch/sh/boards/se/770x/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/io.c	2006-08-23 13:29:24.091254000 +0100
@@ -1,4 +1,4 @@
-/* $Id: io.c,v 1.5 2004/02/22 23:08:43 kkojima Exp $
+/* $Id: io.c,v 1.7 2006/02/05 21:55:29 lethal Exp $
  *
  * linux/arch/sh/kernel/io_se.c
  *
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <asm/io.h>
-#include <asm/se/se.h>
+#include <asm/se.h>
 
 /* SH pcmcia io window base, start and end.  */
 int sh_pcic_io_wbase = 0xb8400000;
@@ -20,11 +20,6 @@
 int sh_pcic_io_type;
 int sh_pcic_io_dummy;
 
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
 /* MS7750 requires special versions of in*, out* routines, since
    PC-like io ports are located at upper half byte of 16-bit word which
    can be accessed only with 16-bit wide.  */
@@ -52,10 +47,6 @@
 		return 1;
 }
 
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
 unsigned char se_inb(unsigned long port)
 {
 	if (sh_pcic_io_start <= port && port <= sh_pcic_io_stop)
@@ -76,7 +67,7 @@
 		v = (*port2adr(port) >> 8); 
 	else
 		v = (*port2adr(port))&0xff; 
-	delay();
+	ctrl_delay();
 	return v;
 }
 
@@ -86,13 +77,13 @@
 	    (sh_pcic_io_start <= port && port <= sh_pcic_io_stop))
 		return *port2adr(port);
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 	return 0;
 }
 
 unsigned int se_inl(unsigned long port)
 {
-	maybebadio(inl, port);
+	maybebadio(port);
 	return 0;
 }
 
@@ -114,7 +105,7 @@
 		*(port2adr(port)) = value << 8;
 	else
 		*(port2adr(port)) = value;
-	delay();
+	ctrl_delay();
 }
 
 void se_outw(unsigned short value, unsigned long port)
@@ -123,12 +114,12 @@
 	    (sh_pcic_io_start <= port && port <= sh_pcic_io_stop))
 		*port2adr(port) = value;
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
 void se_outl(unsigned int value, unsigned long port)
 {
-	maybebadio(outl, port);
+	maybebadio(port);
 }
 
 void se_insb(unsigned long port, void *addr, unsigned long count)
@@ -159,7 +150,7 @@
 
 void se_insl(unsigned long port, void *addr, unsigned long count)
 {
-	maybebadio(insl, port);
+	maybebadio(port);
 }
 
 void se_outsb(unsigned long port, const void *addr, unsigned long count)
@@ -190,37 +181,5 @@
 
 void se_outsl(unsigned long port, const void *addr, unsigned long count)
 {
-	maybebadio(outsw, port);
-}
-
-/* Map ISA bus address to the real address. Only for PCMCIA.  */
-
-/* ISA page descriptor.  */
-static __u32 sh_isa_memmap[256];
-
-static int
-sh_isa_mmap(__u32 start, __u32 length, __u32 offset)
-{
-	int idx;
-
-	if (start >= 0x100000 || (start & 0xfff) || (length != 0x1000))
-		return -1;
-
-	idx = start >> 12;
-	sh_isa_memmap[idx] = 0xb8000000 + (offset &~ 0xfff);
-#if 0
-	printk("sh_isa_mmap: start %x len %x offset %x (idx %x paddr %x)\n",
-	       start, length, offset, idx, sh_isa_memmap[idx]);
-#endif
-	return 0;
-}
-
-unsigned long
-se_isa_port2addr(unsigned long offset)
-{
-	int idx;
-
-	idx = (offset >> 12) & 0xff;
-	offset &= 0xfff;
-	return sh_isa_memmap[idx] + offset;
+	maybebadio(port);
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/irq.c linux-2.6.17.8-sh/arch/sh/boards/se/770x/irq.c
--- linux-2.6.17.8/arch/sh/boards/se/770x/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/irq.c	2006-08-23 13:29:18.514139000 +0100
@@ -12,7 +12,7 @@
 #include <linux/irq.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/se/se.h>
+#include <asm/se.h>
 
 /*
  * Initialize IRQ setting
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/led.c linux-2.6.17.8-sh/arch/sh/boards/se/770x/led.c
--- linux-2.6.17.8/arch/sh/boards/se/770x/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/led.c	2006-08-23 13:29:18.521140000 +0100
@@ -10,22 +10,8 @@
  */
 
 #include <linux/config.h>
-#include <asm/se/se.h>
-
-static void mach_led(int position, int value)
-{
-	volatile unsigned short* p = (volatile unsigned short*)PA_LED;
-
-	if (value) {
-		*p |= (1<<8);
-	} else {
-		*p &= ~(1<<8);
-	}
-}
-
-#ifdef CONFIG_HEARTBEAT
-
 #include <linux/sched.h>
+#include <asm/se.h>
 
 /* Cycle the LED's in the clasic Knightrider/Sun pattern */
 void heartbeat_se(void)
@@ -65,4 +51,3 @@
 	*p = 1<<(bit+8);
 
 }
-#endif /* CONFIG_HEARTBEAT */
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/mach.c linux-2.6.17.8-sh/arch/sh/boards/se/770x/mach.c
--- linux-2.6.17.8/arch/sh/boards/se/770x/mach.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/mach.c	2006-08-23 13:29:18.531140000 +0100
@@ -14,12 +14,9 @@
 
 #include <asm/machvec.h>
 #include <asm/rtc.h>
-#include <asm/machvec_init.h>
-
-#include <asm/se/io.h>
+#include <asm/se.h>
 
 void heartbeat_se(void);
-void setup_se(void);
 void init_se_IRQ(void);
 
 /*
@@ -58,8 +55,6 @@
 	.mv_outsw		= se_outsw,
 	.mv_outsl		= se_outsl,
 
-	.mv_isa_port2addr	= se_isa_port2addr,
-
 	.mv_init_irq		= init_se_IRQ,
 #ifdef CONFIG_HEARTBEAT
 	.mv_heartbeat		= heartbeat_se,
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/Makefile linux-2.6.17.8-sh/arch/sh/boards/se/770x/Makefile
--- linux-2.6.17.8/arch/sh/boards/se/770x/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/Makefile	2006-08-23 13:29:11.837978000 +0100
@@ -2,5 +2,6 @@
 # Makefile for the 770x SolutionEngine specific parts of the kernel
 #
 
-obj-y	 := mach.o setup.o io.o irq.o led.o
+obj-y	 := mach.o setup.o io.o irq.o
 
+obj-$(CONFIG_HEARTBEAT) += led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/se/770x/setup.c linux-2.6.17.8-sh/arch/sh/boards/se/770x/setup.c
--- linux-2.6.17.8/arch/sh/boards/se/770x/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/770x/setup.c	2006-08-23 13:29:18.538139000 +0100
@@ -1,4 +1,4 @@
-/* $Id: setup.c,v 1.1.2.4 2002/03/02 21:57:07 lethal Exp $
+/* $Id: setup.c,v 1.3 2003/05/04 19:29:47 lethal Exp $
  *
  * linux/arch/sh/boards/se/770x/setup.c
  *
@@ -15,8 +15,8 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <asm/io.h>
-#include <asm/se/se.h>
-#include <asm/se/smc37c93x.h>
+#include <asm/se.h>
+#include <asm/smc37c93x.h>
 
 /*
  * Configure the Super I/O chip
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/io.c linux-2.6.17.8-sh/arch/sh/boards/se/7751/io.c
--- linux-2.6.17.8/arch/sh/boards/se/7751/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/io.c	2006-08-23 13:29:24.101254000 +0100
@@ -1,6 +1,4 @@
-/* 
- * linux/arch/sh/kernel/io_7751se.c
- *
+/*
  * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
  * Based largely on io_se.c.
  *
@@ -10,96 +8,21 @@
  * placeholder code from io_se.c left in with the
  * expectation of later SuperIO and PCMCIA access.
  */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
+#include <linux/pci.h>
 #include <asm/io.h>
-#include <asm/se7751/se7751.h>
+#include <asm/se7751.h>
 #include <asm/addrspace.h>
 
-#include <linux/pci.h>
-#include "../../../drivers/pci/pci-sh7751.h"
-
-#if 0
-/******************************************************************
- * Variables from io_se.c, related to PCMCIA (not PCI); we're not
- * compiling them in, and have removed references from functions
- * which follow.  [Many checked for IO ports in the range bounded
- * by sh_pcic_io_start/stop, and used sh_pcic_io_wbase as offset.
- * As start/stop are uninitialized, only port 0x0 would match?]
- * When used, remember to adjust names to avoid clash with io_se?
- *****************************************************************/
-/* SH pcmcia io window base, start and end.  */
-int sh_pcic_io_wbase = 0xb8400000;
-int sh_pcic_io_start;
-int sh_pcic_io_stop;
-int sh_pcic_io_type;
-int sh_pcic_io_dummy;
-/*************************************************************/
-#endif
-
-/*
- * The 7751 Solution Engine uses the built-in PCI controller (PCIC)
- * of the 7751 processor, and has a SuperIO accessible via the PCI.
- * The board also includes a PCMCIA controller on its memory bus,
- * like the other Solution Engine boards.
- */ 
-
-#define PCIIOBR		(volatile long *)PCI_REG(SH7751_PCIIOBR)
-#define PCIMBR          (volatile long *)PCI_REG(SH7751_PCIMBR)
-#define PCI_IO_AREA	SH7751_PCI_IO_BASE
-#define PCI_MEM_AREA	SH7751_PCI_CONFIG_BASE
-
-#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7751_PCIIOBR_MASK))
-
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
-static inline volatile __u16 *
-port2adr(unsigned int port)
+static inline volatile u16 *port2adr(unsigned int port)
 {
 	if (port >= 0x2000)
 		return (volatile __u16 *) (PA_MRSHPC + (port - 0x2000));
-#if 0
-	else
-		return (volatile __u16 *) (PA_SUPERIO + (port << 1));
-#endif
-	maybebadio(name,(unsigned long)port);
+	maybebadio((unsigned long)port);
 	return (volatile __u16*)port;
 }
 
-#if 0
-/* The 7751 Solution Engine seems to have everything hooked */
-/* up pretty normally (nothing on high-bytes only...) so this */
-/* shouldn't be needed */
-static inline int
-shifted_port(unsigned long port)
-{
-	/* For IDE registers, value is not shifted */
-	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
-		return 0;
-	else
-		return 1;
-}
-#endif
-
-/* In case someone configures the kernel w/o PCI support: in that */
-/* scenario, don't ever bother to check for PCI-window addresses */
-
-/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
-#if defined(CONFIG_PCI)
-#define CHECK_SH7751_PCIIO(port) \
-  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7751_PCI_IO_SIZE)))
-#else
-#define CHECK_SH7751_PCIIO(port) (0)
-#endif
-
 /*
  * General outline: remap really low stuff [eventually] to SuperIO,
  * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)
@@ -111,10 +34,10 @@
 {
 	if (PXSEG(port))
 		return *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		return *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		return *(volatile unsigned char *)pci_ioaddr(port);
 	else
-		return (*port2adr(port))&0xff; 
+		return (*port2adr(port)) & 0xff;
 }
 
 unsigned char sh7751se_inb_p(unsigned long port)
@@ -123,11 +46,11 @@
 
         if (PXSEG(port))
                 v = *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                v = *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                v = *(volatile unsigned char *)pci_ioaddr(port);
 	else
-		v = (*port2adr(port))&0xff; 
-	delay();
+		v = (*port2adr(port)) & 0xff;
+	ctrl_delay();
 	return v;
 }
 
@@ -135,12 +58,12 @@
 {
         if (PXSEG(port))
                 return *(volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                return *(volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                return *(volatile unsigned short *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 	return 0;
 }
 
@@ -148,12 +71,12 @@
 {
         if (PXSEG(port))
                 return *(volatile unsigned long *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-                return *(volatile unsigned int *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+                return *(volatile unsigned int *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else
-		maybebadio(inl, port);
+		maybebadio(port);
 	return 0;
 }
 
@@ -162,8 +85,8 @@
 
         if (PXSEG(port))
                 *(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else
 		*(port2adr(port)) = value;
 }
@@ -172,73 +95,41 @@
 {
         if (PXSEG(port))
                 *(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else
 		*(port2adr(port)) = value;
-	delay();
+	ctrl_delay();
 }
 
 void sh7751se_outw(unsigned short value, unsigned long port)
 {
         if (PXSEG(port))
                 *(volatile unsigned short *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned short *)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned short *)pci_ioaddr(port)) = value;
 	else if (port >= 0x2000)
 		*port2adr(port) = value;
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
 void sh7751se_outl(unsigned int value, unsigned long port)
 {
         if (PXSEG(port))
                 *(volatile unsigned long *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-        	*((unsigned long*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned long*)pci_ioaddr(port)) = value;
 	else
-		maybebadio(outl, port);
+		maybebadio(port);
 }
 
 void sh7751se_insl(unsigned long port, void *addr, unsigned long count)
 {
-	maybebadio(insl, port);
+	maybebadio(port);
 }
 
 void sh7751se_outsl(unsigned long port, const void *addr, unsigned long count)
 {
-	maybebadio(outsw, port);
-}
-
-/* Map ISA bus address to the real address. Only for PCMCIA.  */
-
-/* ISA page descriptor.  */
-static __u32 sh_isa_memmap[256];
-
-#if 0
-static int
-sh_isa_mmap(__u32 start, __u32 length, __u32 offset)
-{
-	int idx;
-
-	if (start >= 0x100000 || (start & 0xfff) || (length != 0x1000))
-		return -1;
-
-	idx = start >> 12;
-	sh_isa_memmap[idx] = 0xb8000000 + (offset &~ 0xfff);
-	printk("sh_isa_mmap: start %x len %x offset %x (idx %x paddr %x)\n",
-	       start, length, offset, idx, sh_isa_memmap[idx]);
-	return 0;
-}
-#endif
-
-unsigned long
-sh7751se_isa_port2addr(unsigned long offset)
-{
-	int idx;
-
-	idx = (offset >> 12) & 0xff;
-	offset &= 0xfff;
-	return sh_isa_memmap[idx] + offset;
+	maybebadio(port);
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/irq.c linux-2.6.17.8-sh/arch/sh/boards/se/7751/irq.c
--- linux-2.6.17.8/arch/sh/boards/se/7751/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/irq.c	2006-08-23 13:29:18.723140000 +0100
@@ -13,7 +13,7 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <asm/irq.h>
-#include <asm/se7751/se7751.h>
+#include <asm/se7751.h>
 
 /*
  * Initialize IRQ setting
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/led.c linux-2.6.17.8-sh/arch/sh/boards/se/7751/led.c
--- linux-2.6.17.8/arch/sh/boards/se/7751/led.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/led.c	2006-08-23 13:29:18.730141000 +0100
@@ -8,24 +8,8 @@
  *
  * This file contains Solution Engine specific LED code.
  */
-
-#include <linux/config.h>
-#include <asm/se7751/se7751.h>
-
-static void mach_led(int position, int value)
-{
-	volatile unsigned short* p = (volatile unsigned short*)PA_LED;
-
-	if (value) {
-		*p |= (1<<8);
-	} else {
-		*p &= ~(1<<8);
-	}
-}
-
-#ifdef CONFIG_HEARTBEAT
-
 #include <linux/sched.h>
+#include <asm/se7751.h>
 
 /* Cycle the LED's in the clasic Knightrider/Sun pattern */
 void heartbeat_7751se(void)
@@ -65,4 +49,3 @@
 	*p = 1<<(bit+8);
 
 }
-#endif /* CONFIG_HEARTBEAT */
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/mach.c linux-2.6.17.8-sh/arch/sh/boards/se/7751/mach.c
--- linux-2.6.17.8/arch/sh/boards/se/7751/mach.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/mach.c	2006-08-23 13:29:18.744139000 +0100
@@ -11,12 +11,8 @@
 
 #include <linux/config.h>
 #include <linux/init.h>
-
 #include <asm/machvec.h>
-#include <asm/rtc.h>
-#include <asm/machvec_init.h>
-
-#include <asm/se7751/io.h>
+#include <asm/se7751.h>
 
 void heartbeat_7751se(void);
 void init_7751se_IRQ(void);
@@ -45,8 +41,6 @@
 	.mv_insl		= sh7751se_insl,
 	.mv_outsl		= sh7751se_outsl,
 
-	.mv_isa_port2addr	= sh7751se_isa_port2addr,
-
 	.mv_init_irq		= init_7751se_IRQ,
 #ifdef CONFIG_HEARTBEAT
 	.mv_heartbeat		= heartbeat_7751se,
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/Makefile linux-2.6.17.8-sh/arch/sh/boards/se/7751/Makefile
--- linux-2.6.17.8/arch/sh/boards/se/7751/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/Makefile	2006-08-23 13:29:11.933980000 +0100
@@ -2,7 +2,8 @@
 # Makefile for the 7751 SolutionEngine specific parts of the kernel
 #
 
-obj-y	 := mach.o setup.o io.o irq.o led.o
+obj-y	 := mach.o setup.o io.o irq.o
 
 obj-$(CONFIG_PCI) += pci.o
+obj-$(CONFIG_HEARTBEAT) += led.o
 
diff -Naur linux-2.6.17.8/arch/sh/boards/se/7751/setup.c linux-2.6.17.8-sh/arch/sh/boards/se/7751/setup.c
--- linux-2.6.17.8/arch/sh/boards/se/7751/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/se/7751/setup.c	2006-08-23 13:29:18.752139000 +0100
@@ -1,4 +1,4 @@
-/* 
+/*
  * linux/arch/sh/kernel/setup_7751se.c
  *
  * Copyright (C) 2000  Kazumoto Kojima
@@ -12,11 +12,9 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
-
-#include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <asm/io.h>
-#include <asm/se7751/se7751.h>
+#include <asm/se7751.h>
 
 #ifdef CONFIG_SH_KGDB
 #include <asm/kgdb.h>
diff -Naur linux-2.6.17.8/arch/sh/boards/sh03/rtc.c linux-2.6.17.8-sh/arch/sh/boards/sh03/rtc.c
--- linux-2.6.17.8/arch/sh/boards/sh03/rtc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/sh03/rtc.c	2006-08-23 13:29:27.018323000 +0100
@@ -10,9 +10,10 @@
 #include <linux/sched.h>
 #include <linux/time.h>
 #include <linux/bcd.h>
-#include <asm/io.h>
 #include <linux/rtc.h>
 #include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/rtc.h>
 
 #define RTC_BASE	0xb0000000
 #define RTC_SEC1	(RTC_BASE + 0)
@@ -34,8 +35,6 @@
 #define RTC_BUSY	1
 #define RTC_STOP	2
 
-extern void (*rtc_get_time)(struct timespec *);
-extern int (*rtc_set_time)(const time_t);
 extern spinlock_t rtc_lock;
 
 unsigned long get_cmos_time(void)
@@ -128,6 +127,6 @@
 
 void sh03_time_init(void)
 {
-	rtc_get_time = sh03_rtc_gettimeofday;
-	rtc_set_time = sh03_rtc_settimeofday;
+	rtc_sh_get_time = sh03_rtc_gettimeofday;
+	rtc_sh_set_time = sh03_rtc_settimeofday;
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/sh03/setup.c linux-2.6.17.8-sh/arch/sh/boards/sh03/setup.c
--- linux-2.6.17.8/arch/sh/boards/sh03/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/sh03/setup.c	2006-08-23 13:29:24.110254000 +0100
@@ -8,22 +8,18 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
 #include <asm/io.h>
+#include <asm/rtc.h>
 #include <asm/sh03/io.h>
 #include <asm/sh03/sh03.h>
 #include <asm/addrspace.h>
-#include "../../drivers/pci/pci-sh7751.h"
-
-extern void (*board_time_init)(void);
 
 const char *get_system_type(void)
 {
-	return "Interface CTP/PCI-SH03)";
+	return "Interface (CTP/PCI-SH03)";
 }
 
-void init_sh03_IRQ(void)
+static void init_sh03_IRQ(void)
 {
 	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
 
@@ -35,31 +31,26 @@
 
 extern void *cf_io_base;
 
-unsigned long sh03_isa_port2addr(unsigned long port)
+static void __iomem *sh03_ioport_map(unsigned long port, unsigned int size)
 {
 	if (PXSEG(port))
-		return port;
+		return (void __iomem *)port;
 	/* CompactFlash (IDE) */
-	if (((port >= 0x1f0) && (port <= 0x1f7)) || (port == 0x3f6)) {
-		return (unsigned long)cf_io_base + port;
-	}
-        return port + SH7751_PCI_IO_BASE;
-}
+	if (((port >= 0x1f0) && (port <= 0x1f7)) || (port == 0x3f6))
+		return (void __iomem *)((unsigned long)cf_io_base + port);
 
-/*
- * The Machine Vector
- */
+        return (void __iomem *)(port + PCI_IO_BASE);
+}
 
 struct sh_machine_vector mv_sh03 __initmv = {
 	.mv_nr_irqs		= 48,
-	.mv_isa_port2addr	= sh03_isa_port2addr,
+	.mv_ioport_map		= sh03_ioport_map,
 	.mv_init_irq		= init_sh03_IRQ,
 
 #ifdef CONFIG_HEARTBEAT
 	.mv_heartbeat		= heartbeat_sh03,
 #endif
 };
-
 ALIAS_MV(sh03)
 
 /* arch/sh/boards/sh03/rtc.c */
diff -Naur linux-2.6.17.8/arch/sh/boards/snapgear/io.c linux-2.6.17.8-sh/arch/sh/boards/snapgear/io.c
--- linux-2.6.17.8/arch/sh/boards/snapgear/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/snapgear/io.c	2006-08-23 13:29:24.119254000 +0100
@@ -1,6 +1,4 @@
-/* 
- * linux/arch/sh/kernel/io_7751se.c
- *
+/*
  * Copyright (C) 2002  David McCullough <davidm@snapgear.com>
  * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
  * Based largely on io_se.c.
@@ -11,67 +9,22 @@
  * placeholder code from io_se.c left in with the
  * expectation of later SuperIO and PCMCIA access.
  */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <asm/io.h>
 #include <asm/addrspace.h>
 
-#include <asm/pci.h>
-#include "../../drivers/pci/pci-sh7751.h"
-
 #ifdef CONFIG_SH_SECUREEDGE5410
 unsigned short secureedge5410_ioport;
 #endif
 
-/*
- * The SnapGear uses the built-in PCI controller (PCIC)
- * of the 7751 processor
- */ 
-
-#define PCIIOBR		(volatile long *)PCI_REG(SH7751_PCIIOBR)
-#define PCIMBR          (volatile long *)PCI_REG(SH7751_PCIMBR)
-#define PCI_IO_AREA	SH7751_PCI_IO_BASE
-#define PCI_MEM_AREA	SH7751_PCI_CONFIG_BASE
-
-
-#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7751_PCIIOBR_MASK))
-
-
-#define maybebadio(name,port) \
-  printk("bad PC-like io %s for port 0x%lx at 0x%08x\n", \
-	 #name, (port), (__u32) __builtin_return_address(0))
-
-
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
-
 static inline volatile __u16 *port2adr(unsigned int port)
 {
-#if 0
-	if (port >= 0x2000)
-		return (volatile __u16 *) (PA_MRSHPC + (port - 0x2000));
-#endif
-	maybebadio(name,(unsigned long)port);
+	maybebadio((unsigned long)port);
 	return (volatile __u16*)port;
 }
 
-
-/* In case someone configures the kernel w/o PCI support: in that */
-/* scenario, don't ever bother to check for PCI-window addresses */
-
-/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
-#if defined(CONFIG_PCI)
-#define CHECK_SH7751_PCIIO(port) \
-  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7751_PCI_IO_SIZE)))
-#else
-#define CHECK_SH7751_PCIIO(port) (0)
-#endif
-
 /*
  * General outline: remap really low stuff [eventually] to SuperIO,
  * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)
@@ -79,148 +32,106 @@
  * should be way beyond the window, and is used  w/o translation for
  * compatibility.
  */
-
 unsigned char snapgear_inb(unsigned long port)
 {
 	if (PXSEG(port))
 		return *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		return *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		return *(volatile unsigned char *)pci_ioaddr(port);
 	else
-		return (*port2adr(port))&0xff; 
+		return (*port2adr(port)) & 0xff;
 }
 
-
 unsigned char snapgear_inb_p(unsigned long port)
 {
 	unsigned char v;
 
 	if (PXSEG(port))
 		v = *(volatile unsigned char *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		v = *(volatile unsigned char *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		v = *(volatile unsigned char *)pci_ioaddr(port);
 	else
-		v = (*port2adr(port))&0xff; 
-	delay();
+		v = (*port2adr(port))&0xff;
+	ctrl_delay();
 	return v;
 }
 
-
 unsigned short snapgear_inw(unsigned long port)
 {
 	if (PXSEG(port))
 		return *(volatile unsigned short *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		return *(volatile unsigned short *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		return *(volatile unsigned short *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else
-		maybebadio(inw, port);
+		maybebadio(port);
 	return 0;
 }
 
-
 unsigned int snapgear_inl(unsigned long port)
 {
 	if (PXSEG(port))
 		return *(volatile unsigned long *)port;
-	else if (CHECK_SH7751_PCIIO(port))
-		return *(volatile unsigned int *)PCI_IOMAP(port);
+	else if (is_pci_ioaddr(port))
+		return *(volatile unsigned int *)pci_ioaddr(port);
 	else if (port >= 0x2000)
 		return *port2adr(port);
 	else
-		maybebadio(inl, port);
+		maybebadio(port);
 	return 0;
 }
 
-
 void snapgear_outb(unsigned char value, unsigned long port)
 {
 
 	if (PXSEG(port))
 		*(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-		*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else
 		*(port2adr(port)) = value;
 }
 
-
 void snapgear_outb_p(unsigned char value, unsigned long port)
 {
 	if (PXSEG(port))
 		*(volatile unsigned char *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-		*((unsigned char*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned char*)pci_ioaddr(port)) = value;
 	else
 		*(port2adr(port)) = value;
-	delay();
+	ctrl_delay();
 }
 
-
 void snapgear_outw(unsigned short value, unsigned long port)
 {
 	if (PXSEG(port))
 		*(volatile unsigned short *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-		*((unsigned short *)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned short *)pci_ioaddr(port)) = value;
 	else if (port >= 0x2000)
 		*port2adr(port) = value;
 	else
-		maybebadio(outw, port);
+		maybebadio(port);
 }
 
-
 void snapgear_outl(unsigned int value, unsigned long port)
 {
 	if (PXSEG(port))
 		*(volatile unsigned long *)port = value;
-	else if (CHECK_SH7751_PCIIO(port))
-		*((unsigned long*)PCI_IOMAP(port)) = value;
+	else if (is_pci_ioaddr(port))
+		*((unsigned long*)pci_ioaddr(port)) = value;
 	else
-		maybebadio(outl, port);
+		maybebadio(port);
 }
 
 void snapgear_insl(unsigned long port, void *addr, unsigned long count)
 {
-	maybebadio(insl, port);
+	maybebadio(port);
 }
 
 void snapgear_outsl(unsigned long port, const void *addr, unsigned long count)
 {
-	maybebadio(outsw, port);
-}
-
-/* Map ISA bus address to the real address. Only for PCMCIA.  */
-
-
-/* ISA page descriptor.  */
-static __u32 sh_isa_memmap[256];
-
-
-#if 0
-static int sh_isa_mmap(__u32 start, __u32 length, __u32 offset)
-{
-	int idx;
-
-	if (start >= 0x100000 || (start & 0xfff) || (length != 0x1000))
-		return -1;
-
-	idx = start >> 12;
-	sh_isa_memmap[idx] = 0xb8000000 + (offset &~ 0xfff);
-#if 0
-	printk("sh_isa_mmap: start %x len %x offset %x (idx %x paddr %x)\n",
-	       start, length, offset, idx, sh_isa_memmap[idx]);
-#endif
-	return 0;
-}
-#endif
-
-unsigned long snapgear_isa_port2addr(unsigned long offset)
-{
-	int idx;
-
-	idx = (offset >> 12) & 0xff;
-	offset &= 0xfff;
-	return sh_isa_memmap[idx] + offset;
+	maybebadio(port);
 }
diff -Naur linux-2.6.17.8/arch/sh/boards/snapgear/rtc.c linux-2.6.17.8-sh/arch/sh/boards/snapgear/rtc.c
--- linux-2.6.17.8/arch/sh/boards/snapgear/rtc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/snapgear/rtc.c	2006-08-23 13:29:27.048323000 +0100
@@ -17,10 +17,7 @@
 #include <linux/time.h>
 #include <linux/rtc.h>
 #include <linux/mc146818rtc.h>
-
 #include <asm/io.h>
-#include <asm/rtc.h>
-#include <asm/mc146818rtc.h>
 
 /****************************************************************************/
 
@@ -168,11 +165,11 @@
 		}
 
 	if (use_ds1302) {
-		rtc_get_time = snapgear_rtc_gettimeofday;
-		rtc_set_time = snapgear_rtc_settimeofday;
+		rtc_sh_get_time = snapgear_rtc_gettimeofday;
+		rtc_sh_set_time = snapgear_rtc_settimeofday;
 	} else {
-		rtc_get_time = sh_rtc_gettimeofday;
-		rtc_set_time = sh_rtc_settimeofday;
+		rtc_sh_get_time = sh_rtc_gettimeofday;
+		rtc_sh_set_time = sh_rtc_settimeofday;
 	}
 		
 	printk("SnapGear RTC: using %s rtc.\n", use_ds1302 ? "ds1302" : "internal");
diff -Naur linux-2.6.17.8/arch/sh/boards/snapgear/setup.c linux-2.6.17.8-sh/arch/sh/boards/snapgear/setup.c
--- linux-2.6.17.8/arch/sh/boards/snapgear/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/snapgear/setup.c	2006-08-23 13:29:18.962139000 +0100
@@ -1,5 +1,4 @@
-/****************************************************************************/
-/* 
+/*
  * linux/arch/sh/boards/snapgear/setup.c
  *
  * Copyright (C) 2002  David McCullough <davidm@snapgear.com>
@@ -12,8 +11,6 @@
  *           Modified for 7751 Solution Engine by
  *           Ian da Silva and Jeremy Siegel, 2001.
  */
-/****************************************************************************/
-
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -22,14 +19,13 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/sched.h>
-
 #include <asm/machvec.h>
-#include <asm/mach/io.h>
+#include <asm/snapgear.h>
 #include <asm/irq.h>
 #include <asm/io.h>
+#include <asm/rtc.h>
 #include <asm/cpu/timer.h>
 
-extern void (*board_time_init)(void);
 extern void secureedge5410_rtc_init(void);
 extern void pcibios_init(void);
 
@@ -86,91 +82,6 @@
 	make_ipr_irq(IRL3_IRQ, IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY);
 }
 
-/****************************************************************************/
-/*
- *	Fast poll interrupt simulator.
- */
-
-/*
- * Leave all of the fast timer/fast poll stuff commented out for now, since
- * it's not clear whether it actually works or not. Since it wasn't being used
- * at all in 2.4, we'll assume it's not sane for 2.6 either.. -- PFM
- */
-#if 0
-#define FAST_POLL	1000
-//#define FAST_POLL_INTR
-
-#define FASTTIMER_IRQ   17
-#define FASTTIMER_IPR_ADDR  INTC_IPRA
-#define FASTTIMER_IPR_POS    2
-#define FASTTIMER_PRIORITY   3
-
-#ifdef FAST_POLL_INTR
-#define TMU1_TCR_INIT	0x0020
-#else
-#define TMU1_TCR_INIT	0
-#endif
-#define TMU_TSTR_INIT	1
-#define TMU1_TCR_CALIB	0x0000
-
-
-#ifdef FAST_POLL_INTR
-static void fast_timer_irq(int irq, void *dev_instance, struct pt_regs *regs)
-{
-	unsigned long timer_status;
-    timer_status = ctrl_inw(TMU1_TCR);
-	timer_status &= ~0x100;
-	ctrl_outw(timer_status, TMU1_TCR);
-}
-#endif
-
-/*
- * return the current ticks on the fast timer
- */
-
-unsigned long fast_timer_count(void)
-{
-	return(ctrl_inl(TMU1_TCNT));
-}
-
-/*
- * setup a fast timer for profiling etc etc
- */
-
-static void setup_fast_timer()
-{
-	unsigned long interval;
-
-#ifdef FAST_POLL_INTR
-	interval = (current_cpu_data.module_clock/4 + FAST_POLL/2) / FAST_POLL;
-
-	make_ipr_irq(FASTTIMER_IRQ, FASTTIMER_IPR_ADDR, FASTTIMER_IPR_POS,
-			FASTTIMER_PRIORITY);
-
-	printk("SnapGear: %dHz fast timer on IRQ %d\n",FAST_POLL,FASTTIMER_IRQ);
-
-	if (request_irq(FASTTIMER_IRQ, fast_timer_irq, 0, "SnapGear fast timer",
-			NULL) != 0)
-		printk("%s(%d): request_irq() failed?\n", __FILE__, __LINE__);
-#else
-	printk("SnapGear: fast timer running\n",FAST_POLL,FASTTIMER_IRQ);
-	interval = 0xffffffff;
-#endif
-
-	ctrl_outb(ctrl_inb(TMU_TSTR) & ~0x2, TMU_TSTR); /* disable timer 1 */
-	ctrl_outw(TMU1_TCR_INIT, TMU1_TCR);
-	ctrl_outl(interval, TMU1_TCOR);
-	ctrl_outl(interval, TMU1_TCNT);
-	ctrl_outb(ctrl_inb(TMU_TSTR) | 0x2, TMU_TSTR); /* enable timer 1 */
-
-	printk("Timer count 1 = 0x%x\n", fast_timer_count());
-	udelay(1000);
-	printk("Timer count 2 = 0x%x\n", fast_timer_count());
-}
-#endif
-
-/****************************************************************************/
-
 const char *get_system_type(void)
 {
 	return "SnapGear SecureEdge5410";
@@ -197,8 +108,6 @@
 	.mv_outw_p		= snapgear_outw,
 	.mv_outl_p		= snapgear_outl,
 
-	.mv_isa_port2addr	= snapgear_isa_port2addr,
-
 	.mv_init_irq		= init_snapgear_IRQ,
 };
 ALIAS_MV(snapgear)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/harp-common/irq.c linux-2.6.17.8-sh/arch/sh/boards/st/harp-common/irq.c
--- linux-2.6.17.8/arch/sh/boards/st/harp-common/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/harp-common/irq.c	2006-08-23 13:29:47.941809000 +0100
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2000 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Looks after interrupts on the HARP board.
+ *
+ * Bases on the IPR irq system
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/mach/harp.h>
+
+#ifndef epld_out
+#define epld_out(val,addr) ctrl_outl(val,addr)
+#define epld_in(addr)      ctrl_inl(addr)
+#endif
+
+#define NUM_EXTERNAL_IRQS 16
+
+static void enable_harp_irq(unsigned int irq);
+static void disable_harp_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_harp_irq disable_harp_irq
+
+static void mask_and_ack_harp(unsigned int);
+static void end_harp_irq(unsigned int irq);
+
+static unsigned int startup_harp_irq(unsigned int irq)
+{
+	enable_harp_irq(irq);
+	return 0;		/* never anything pending */
+}
+
+static struct hw_interrupt_type harp_irq_type = {
+	.typename = "Harp-IRQ",
+	.startup = startup_harp_irq,
+	.shutdown = shutdown_harp_irq,
+	.enable = enable_harp_irq,
+	.disable = disable_harp_irq,
+	.ack = mask_and_ack_harp,
+	.end = end_harp_irq
+};
+
+static void disable_harp_irq(unsigned int irq)
+{
+	unsigned maskReg;
+	unsigned mask;
+	int pri;
+
+	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
+		return;
+
+	pri = 15 - irq;
+
+	if (pri < 8) {
+		maskReg = EPLD_INTMASK0CLR;
+	} else {
+		maskReg = EPLD_INTMASK1CLR;
+		pri -= 8;
+	}
+	mask=1<<pri;
+
+	epld_out(mask, maskReg);
+
+	/* Read back the value we just wrote to flush any write posting */
+	epld_in(maskReg);
+}
+
+static void enable_harp_irq(unsigned int irq)
+{
+	unsigned maskReg;
+	unsigned mask;
+	int pri;
+
+	if (irq < 0 || irq >= NUM_EXTERNAL_IRQS)
+		return;
+
+	pri = 15 - irq;
+
+	if (pri < 8) {
+		maskReg = EPLD_INTMASK0SET;
+	} else {
+		maskReg = EPLD_INTMASK1SET;
+		pri -= 8;
+	}
+	mask=1<<pri;
+
+	epld_out(mask, maskReg);
+}
+
+/* This functions sets the desired irq handler to be an overdrive type */
+static void __init make_harp_irq(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+	irq_desc[irq].handler = &harp_irq_type;
+	disable_harp_irq(irq);
+}
+
+static void mask_and_ack_harp(unsigned int irq)
+{
+	disable_harp_irq(irq);
+}
+
+static void end_harp_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_harp_irq(irq);
+}
+
+static void __init disable_all_interrupts(void)
+{
+	epld_out(0x00, EPLD_INTMASK0);
+	epld_out(0x00, EPLD_INTMASK1);
+}
+
+void __init harp_init_irq(void)
+{
+	int i;
+
+	disable_all_interrupts();
+
+	if (! harp_has_intmask_setclr()) {
+		printk(KERN_ERR "HARP does not have interrupt set/clr registers\n");
+	}
+
+	for (i = 0; i < NUM_EXTERNAL_IRQS; i++) {
+		make_harp_irq(i);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/harp-common/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/harp-common/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/harp-common/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/harp-common/Makefile	2006-08-23 13:29:29.140371000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics boards which look like the ST40STB1 HARP.
+#
+
+obj-y := irq.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/mediaref/led.c linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/led.c
--- linux-2.6.17.8/arch/sh/boards/st/mediaref/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/led.c	2006-08-23 13:29:29.168392000 +0100
@@ -0,0 +1,35 @@
+/*
+ * linux/arch/sh/boards/mediaref/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the MediaX.
+ */
+
+#include <linux/config.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include <asm/led.h>
+
+#define GX1SYSCONF_BASE                 0xBB190000
+#define  GX1SYSCONF_SYS_CON2_LO         (GX1SYSCONF_BASE + 0x18)        /* SYS_CON2 is 64 bits */
+#define  GX1SYSCONF_SYS_CON2_HI         (GX1SYSCONF_BASE + 0x1C)
+
+/* MediaX: Flash H6 connected to comms block PIO bit 5 */
+void mach_led(int position, int value)
+{
+	static struct stpio_pin *led = NULL;
+
+	if (led == NULL) {
+		unsigned long val;
+		val = ctrl_inl(GX1SYSCONF_SYS_CON2_LO);
+		ctrl_outl(val | (3<<18), GX1SYSCONF_SYS_CON2_LO);
+		led = stpio_request_pin(STPIO_IO_PIO_BANK(0), 5, "LED",
+					STPIO_OUT);
+	}
+
+	stpio_set_pin(led, value);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/mediaref/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/mediaref/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/mach.c	2006-08-23 13:29:51.139875000 +0100
@@ -0,0 +1,67 @@
+/*
+ * linux/arch/sh/boards/mediaref/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics/Futarque Mediaref and MediaX.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+void init_harp_irq(void);
+void heartbeat_harp(void);
+
+static void __iomem *mediaref_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((port >= PCIBIOS_MIN_IO) &&
+            (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return (void __iomem *)(port + ST40PCI_IO_ADDRESS);
+        }
+#endif
+
+        /* However picking somewhere safe isn't as easy as you might think.
+         * I used to use external ROM, but that can cause problems if you are
+         * in the middle of updating Flash. So I'm now using the processor core
+         * version register, which is guaranted to be available, and non-writable.
+         */
+        return (void __iomem *)CCN_PVR;
+}
+
+static void __init mediaref_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+	/* Only IRL0 is connected, to the 5514 pio3_4 */
+	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
+}
+
+struct sh_machine_vector mv_mediaref __initmv = {
+        .mv_nr_irqs             = NR_IRQS,
+	.mv_init_irq		= mediaref_init_irq,
+        .mv_ioport_map		= mediaref_ioport_map,
+
+#ifdef CONFIG_HEARTBEAT
+        .mv_heartbeat           = heartbeat_heart,
+#endif
+};
+ALIAS_MV(mediaref)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/mediaref/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/mediaref/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/Makefile	2006-08-23 13:29:29.158384000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for STMicroelectronics Mediaref and MediaX Eval boards
+#
+
+obj-y := setup.o mach.o
+obj-$(CONFIG_SH_MEDIAX_DEMO) += led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/mediaref/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/mediaref/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/mediaref/setup.c	2006-08-23 13:29:51.352898000 +0100
@@ -0,0 +1,68 @@
+/*
+ * arch/sh/stboard/setup_mediaref.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics Mediaref support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	struct stpio_pin *pio;
+
+        printk("STMicroelectronics MediaRef initialisation\n");
+
+	/* Make sure we turn PCI interrupt BCD into an input pin ASAP */
+	/* Note there is no support for using this yet! */
+	pio = stpio_request_pin(STPIO_PIO_BANK(0), 7, "PCI INT B/C/D",
+				STPIO_IN);
+
+	/* Drive M66ENA low to ensure the bridge correctly sees the
+	 * primary bus as running at 33MHz (assuming it is!)
+	 */
+	pio = stpio_request_pin(STPIO_PIO_BANK(0), 6, "PCI M66ENA", STPIO_OUT);
+	stpio_set_pin(pio, 0);
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+}
+
+const char *get_system_type(void)
+{
+#ifdef CONFIG_SH_MEDIAX_DEMO
+	return "MediaX";
+#else
+	return "MediaRef";
+#endif
+}
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+
+/*
+ * PCI based boards need a function that maps IRQ's to given PCI
+ * slots. This code is used by the st40 pci routines in arch/sh/kernel
+ */
+
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	/* All interrupts are hardwired to the PCI cell's INTA pin. Ahhhh! */
+	return ST40PCI_AD_IRQ;
+}
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st220eval/led.c linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/led.c
--- linux-2.6.17.8/arch/sh/boards/st/st220eval/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/led.c	2006-08-23 13:29:30.124392000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/arch/sh/boards/st220eval/led.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the ST220 Eval board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/st220eval/st220eval.h>
+
+void mach_led(int position, int value)
+{
+	if (value) {
+		ctrl_outb(EPLD_LED_ON, EPLD_LED);
+	} else {
+		ctrl_outb(EPLD_LED_OFF, EPLD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st220eval/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/st220eval/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/mach.c	2006-08-23 13:29:51.166875000 +0100
@@ -0,0 +1,71 @@
+/*
+ * linux/arch/sh/boards/st220eval/mach.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the ST220 Eval.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *st220eval_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#else
+	/* No devices which support I/O addressing. */
+	return (void __iomem *)CCN_PVR;
+#endif
+}
+
+static void __init st220eval_init_irq(void)
+{
+	/* Initialise the ILC */
+	init_IRQ_STm8000_ilc();
+
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+	/* IRQ0: STEM_INT1 (active low) */
+	/* IRL1: STEM_INT0 (active low) */
+	/* IRL2: Front End interface (active low) */
+	/* IRL3: Ethernet (active high) */
+
+	/*
+	 * No point in configuring IRL0-2 as they can't be used
+	 * make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
+	 * make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
+	 * make_ipr_irq(IRL2_IRQ, IRL2_IPR_ADDR, IRL2_IPR_POS, IRL2_PRIORITY);
+	 */
+	make_ipr_irq(IRL3_IRQ, IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY);
+}
+
+struct sh_machine_vector mv_st220eval __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= st220eval_init_irq,
+	.mv_ioport_map		= st220eval_ioport_map,
+	.mv_irq_demux		= stm8000_irq_demux,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(st220eval)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st220eval/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/st220eval/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/Makefile	2006-08-23 13:29:42.508691000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST220 Eval board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st220eval/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/st220eval/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st220eval/setup.c	2006-08-23 13:29:51.193899000 +0100
@@ -0,0 +1,281 @@
+/*
+ * linux/arch/sh/boards/st220eval/setup.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Setup functions for the ST220 Eval board.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <asm/io.h>
+#include <asm/st220eval/st220eval.h>
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+        unsigned char epld_ver;
+        unsigned char pcb_ver;
+
+        epld_ver = ctrl_inb(EPLD_EPLD_VER);
+        pcb_ver  = ctrl_inb(EPLD_PCB_VER);
+
+        printk("STMicroelectronics ST220 Eval initialisation\n");
+        printk("EPLD version: %d.%d PCB revision: %X\n", epld_ver >> 4, epld_ver & 0xf, pcb_ver);
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+
+	/* Flash powers up write protected. Enable it here. */
+	ctrl_outb(1, EPLD_FLASH_WE);
+}
+
+const char *get_system_type(void)
+{
+        return "ST220 Eval";
+}
+
+/* ssc parameters */
+static struct resource ssc_resource[] = {
+        [0] = {
+               .start = 0xB8340000,
+               .end = 0xB8340000 + 0x108,
+               .flags = IORESOURCE_MEM,
+               },
+        [1] = {
+               .start = 0xB8341000,
+               .end = 0xB8341000 + 0x108,
+               .flags = IORESOURCE_MEM,
+               },
+        [2] = {
+               .start = 7+ILC_FIRST_IRQ,
+               .end = 7+ILC_FIRST_IRQ,
+               .flags = IORESOURCE_IRQ,
+               },
+        [3] = {
+               .start = 8+ILC_FIRST_IRQ,
+               .end = 8+ILC_FIRST_IRQ,
+               .flags = IORESOURCE_IRQ,
+               },
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+        {6, 0, 6, 1, 0xff, 0xff},
+        {6, 2, 6, 3, 6, 4},
+};
+
+static struct plat_ssc_data ssc_private_info = {
+         .sscclk      = 133333333,
+         .capability  = 0x9,
+         .pio         = ssc_pio
+};
+
+struct platform_device ssc_device = {
+        .name = "ssc",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(ssc_resource),
+        .resource = ssc_resource,
+        .dev = {
+                 .platform_data = &ssc_private_info
+	}
+};
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+        /* Watchdog timer only needs a register address */
+        [0] = {
+               .start = 0xFFC00008,
+               .end = 0xFFC00010,
+               .flags = IORESOURCE_MEM,
+       }
+};
+
+struct platform_device wdt_device = {
+        .name = "wdt",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(wdt_resource),
+        .resource = wdt_resource,
+};
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 8000, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+        .irbclkdiv      = 0, /* automatically calculate */
+        .irbperiodmult  = 0,
+        .irbperioddiv   = 0,
+        .irbontimemult  = 0,
+        .irbontimediv   = 0,
+        .irbrxmaxperiod = 0x5000,
+        .irbversion     = 1,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1
+};
+
+static struct resource gpdma_resources[] = {
+	[0] = {
+		.start  = 0xb8100000,
+		.end    = 0xb8100000 + 0x4ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = ILC_FIRST_IRQ + 24,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start  = ILC_FIRST_IRQ + 25,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start  = ILC_FIRST_IRQ + 26,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start  = ILC_FIRST_IRQ + 27,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[5] = {
+		.start  = ILC_FIRST_IRQ + 28,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[6] = {
+		.start  = ILC_FIRST_IRQ + 29,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gpdma_device = {
+	.name		= "gpdma",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(gpdma_resources),
+	.resource	= gpdma_resources,
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa1800300,
+		.end	= 0xa1800300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL3_IRQ,
+		.end	= IRL3_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct resource st40_ohci_resources[] = {
+	[0] = {
+		.start =0xb4400000,
+		.end =0xb4400000 + 0xFFFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = ILC_FIRST_IRQ + 39,
+		.end   = ILC_FIRST_IRQ + 39,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x18318000,
+		.end   = 0x18318000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 176 + 15,
+		.end   = 176 + 15,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device st40_ohci_device = {
+	.name 		="ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+
+	};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+static struct resource rtc_resource[]= {
+        [0] = {
+                .start = 0xffc80000,
+                .end   = 0xffc80000 + 0x40,
+                .flags = IORESOURCE_MEM
+        },
+/* Be careful the
+ * arch/sh/kernel/cpu/irq/ipr.c
+ * must be update with the right value
+ */
+        [1] = {
+                .start = 20,
+                .flags = IORESOURCE_IRQ
+        },
+        [2] = {
+                .start = 21,
+                .flags = IORESOURCE_IRQ
+        },
+};
+static struct platform_device rtc_device = {
+        .name           = "rtc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(rtc_resource),
+        .resource       = rtc_resource,
+};
+
+static struct platform_device *st220eval_devices[] __initdata = {
+	&gpdma_device,
+	&smc91x_device,
+	&st40_ohci_device,
+	&lirc_device,
+	&wdt_device,
+	&ssc_device,
+	&rtc_device,
+};
+
+static int __init device_init(void)
+{
+	int ret = 0;
+	ret = platform_add_devices(st220eval_devices, ARRAY_SIZE(st220eval_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/led.c linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/led.c
--- linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/led.c	2006-08-23 13:29:29.212393000 +0100
@@ -0,0 +1,24 @@
+/*
+ * linux/arch/sh/boards/st40gx1eval/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the ST40GX1 Eval board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/st40gx1eval/harp.h>
+
+void mach_led(int position, int value)
+{
+        if (value) {
+                ctrl_outl(EPLD_LED_ON, EPLD_LED);
+        } else {
+                ctrl_outl(EPLD_LED_OFF, EPLD_LED);
+        }
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/mach.c	2006-08-23 13:29:51.209898000 +0100
@@ -0,0 +1,69 @@
+/*
+ * linux/arch/sh/boards/st40gx1eval/mach.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics GX1 Eval
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/led.h>
+#include <asm/machvec.h>
+#include <asm/machvec_init.h>
+#include <asm/irq.h>
+#include <asm/st40gx1eval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *stb1eval_ioport_map(unsigned long port, unsigned int size)
+{
+	/* Treat IO addresses in one of three ways:
+	 *   legacy	: black hole
+	 *		  This is to trap accesses by drivers probing for
+	 *		  devices at fixed addresses (especially IDE).
+	 *   PCI	: map to PCI IO space
+	 *   other	: pass straight through
+	 *		  To catch other devices which on a PC would be
+	 *		  in IO space, but which on an SH are memory mapped.
+	 *		  (eg IDE).
+	 */
+
+	if (unlikely(port < PCIBIOS_MIN_IO)) {
+		/*
+		 * However picking somewhere safe isn't as easy as you
+		 * might think.  I used to use external ROM, but that
+		 * can cause problems if you are in the middle of
+		 * updating Flash. So I'm now using the processor core
+		 * version register, which is guaranted to be
+		 * available, and non-writable.
+		 */
+		return (void __iomem *)CCN_PVR;
+	}
+
+	if (port < (64 * 1024)) {
+		return (void __iomem *)(port + ST40PCI_IO_ADDRESS);
+	}
+
+	return (void __iomem *)port;
+}
+
+/*
+ * The Machine Vector
+ */
+
+struct sh_machine_vector mv_gx1eval __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_ioport_map		= stb1eval_ioport_map,
+
+#if defined(CONFIG_PCI)
+	.mv_init_irq		= harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(gx1eval)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/Makefile	2006-08-23 13:29:29.195393000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40GX1 Eval board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/st40gx1eval/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40gx1eval/setup.c	2006-08-23 13:29:51.360899000 +0100
@@ -0,0 +1,100 @@
+/*
+ * linux/arch/sh/boards/st40gx1eval/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40GX1 Eval support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/st40gx1eval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+const char *get_system_type(void)
+{
+	return "ST40GX1 Eval";
+}
+
+/*
+ * Initialize the board
+ */
+static void __init epld_test(unsigned long addr, const char* desc)
+{
+	unsigned char expected, got;
+	unsigned char try[5] = {0, 0xff, 0xaa, 0x55, 0x23};
+	int i;
+
+	for (i=0; i<5; i++) {
+		ctrl_outl(try[i], addr);
+		got = ctrl_inl(addr) & 0xff;
+		expected = ~try[i];
+		if (got != expected) {
+			printk("EPLD test failed: %s: wrote %02x, read %02x, expected %02x\n",
+			       desc, try[i], got, expected);
+		}
+	}
+}
+
+void __init platform_setup(void)
+{
+	unsigned char ic42_version, ic43_version;
+
+	ic42_version = ctrl_inl(EPLD_REVID1) & 0xff;
+	ic43_version = ctrl_inl(EPLD_REVID2) & 0xff;
+
+	printk("STMicroelectronics GX1 Eval initialisation\n");
+	printk("EPLD version: IC42: %d.%02d, IC43: %d.%02d\n",
+	       (ic42_version >> 4) & 0xf, ic42_version & 0xf,
+	       (ic43_version >> 4) & 0xf, ic43_version & 0xf);
+	epld_test(EPLD_TEST1, "IC42");
+	epld_test(EPLD_TEST2, "IC43");
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+}
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+
+/*
+ * pcibios_map_platform_irq
+ *
+ * This is board specific and returns the IRQ for a given PCI device.
+ * It is used by the PCI code (arch/sh/drivers/pci/pci-st40.c)
+ */
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	switch(slot) {
+	case 1 ... 3 :
+		irq=slot-1;
+		break;
+	case 9:
+		irq=4;
+		break;
+	case 10:
+		irq=3;
+		break;
+	}
+
+	/* Are we asking for a known slot ? */
+	if(irq==-1) return -1;
+
+	if(pin==1) return irq;
+	/* An INTB,INTC,INTD - these are commoned up */
+	return pin+3;
+}
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40raeval/led.c linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/led.c
--- linux-2.6.17.8/arch/sh/boards/st/st40raeval/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/led.c	2006-08-23 13:29:29.243396000 +0100
@@ -0,0 +1,28 @@
+/*
+ * linux/arch/sh/boards/st40raeval/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the ST40RA/ST40STB1 Eval board.
+ */
+
+#include <linux/config.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/st40raeval/harp.h>
+
+/* ST40 Eval: Flash LD9 (PIO LED) connected to PIO1 bit 3 */
+void mach_led(int position, int value)
+{
+	static struct stpio_pin *led = NULL;
+
+	if (led == NULL) {
+		led = stpio_request_pin(1, 3, "LED", STPIO_OUT);
+	}
+
+	stpio_set_pin(led, value);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40raeval/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/st40raeval/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/mach.c	2006-08-23 13:29:51.226898000 +0100
@@ -0,0 +1,58 @@
+/*
+ * linux/arch/sh/boards/st40raeval/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB1 HARP and compatible boards
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/st40raeval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *stb1eval_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((port >= PCIBIOS_MIN_IO) &&
+            (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return (void __iomem *)(offset + ST40PCI_IO_ADDRESS);
+        }
+#endif
+
+        /* However picking somewhere safe isn't as easy as you might think.
+         * I used to use external ROM, but that can cause problems if you are
+         * in the middle of updating Flash. So I'm now using the processor core
+         * version register, which is guaranted to be available, and non-writable.
+         */
+	return (void __iomem *)CCN_PVR;
+}
+
+struct sh_machine_vector mv_stb1eval __initmv = {
+        .mv_nr_irqs             = NR_IRQS,
+        .mv_ioport_map		= stb1eval_ioport_map,
+
+#ifdef CONFIG_PCI
+        .mv_init_irq            = harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+        .mv_heartbeat           = heartbeat_heart,
+#endif
+};
+ALIAS_MV(stb1eval)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40raeval/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/st40raeval/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/Makefile	2006-08-23 13:29:29.234394000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40RA Eval board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40raeval/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/st40raeval/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40raeval/setup.c	2006-08-23 13:29:51.377898000 +0100
@@ -0,0 +1,72 @@
+/*
+ * arch/sh/boards/st40raeval/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40RA/ST40STB1 Eval support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/st40raeval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+const char *get_system_type(void)
+{
+	return "ST40 Eval";
+}
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+        unsigned board=ctrl_inl(EPLD_REVID_PLD);
+        unsigned pld=ctrl_inl(EPLD_REVID_BOARD);
+
+        printk("STMicroelectronics ST40RA/ST40STB1 Eval initialisaton\n");
+        printk("Board version %c EPLD version: %d.%02d\n",
+               'A'+(board&0xf), (pld >> 4) & 0xf, pld & 0xf);
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+}
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+        int irq=-1;
+
+
+        switch (slot) {
+        case 2:
+                irq=0;
+                break;
+        case 9 ... 12:
+                irq = 12-slot+1;
+                break;
+        }
+
+        /* Are we asking for a known slot ? */
+        if(irq==-1) return -1;
+
+	pr_debug("Asking for slot %d pin %d - given %d\n",slot,pin,irq);
+
+        if(pin==1) return irq;
+        /* An INTB,INTC,INTD - these are commoned up */
+        return pin+3;
+}
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40rastarter/led.c linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/led.c
--- linux-2.6.17.8/arch/sh/boards/st/st40rastarter/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/led.c	2006-08-23 13:29:29.268394000 +0100
@@ -0,0 +1,38 @@
+/*
+ * linux/arch/sh/boards/st40rastarter/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains ST40RA/ST40STB1 Starter code.
+ */
+
+#include <linux/config.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/st40rastarter/harp.h>
+
+void mach_led(int position, int value)
+{
+	static struct stpio_pin *led6 = NULL, *led7 = NULL;
+
+	if(led6 == NULL) {
+		led6 = stpio_request_pin(0,3, "LED", STPIO_OUT);
+		led7 = stpio_request_pin(0,0, "LED", STPIO_OUT);
+	}
+
+	switch(position) {
+	case 6:
+		stpio_set_pin(led6, value);
+		break;
+	case 7:
+		stpio_set_pin(led7, value);
+		break;
+	default:
+		ctrl_outl(1<<position,(value) ? EPLD_LED_SET : EPLD_LED_CLR);
+		break;
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40rastarter/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/st40rastarter/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/mach.c	2006-08-23 13:29:51.256898000 +0100
@@ -0,0 +1,59 @@
+/*
+ * linux/arch/sh/boards/st40rastarter/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB40RA Starter board.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/st40rastarter/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *st40rastarter_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((port >= PCIBIOS_MIN_IO) &&
+            (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return (void __iomem *)(port + ST40PCI_IO_ADDRESS);
+        }
+#endif
+
+        /* However picking somewhere safe isn't as easy as you might think.
+         * I used to use external ROM, but that can cause problems if you are
+         * in the middle of updating Flash. So I'm now using the processor core
+         * version register, which is guaranted to be available, and non-writable.
+         */
+	return (void __iomem *)CCN_PVR;
+}
+
+struct sh_machine_vector mv_st40rastarter __initmv = {
+        .mv_nr_irqs             = NR_IRQS,
+        .mv_ioport_map		= st40rastarter_ioport_map,
+
+#ifdef CONFIG_PCI
+        .mv_init_irq            = harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+        .mv_heartbeat           = heartbeat_knightrider,
+#endif
+};
+
+ALIAS_MV(st40rastarter)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40rastarter/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/st40rastarter/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/Makefile	2006-08-23 13:29:29.259393000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40RA/ST40STB1 Starter board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/st40rastarter/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/st40rastarter/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/st40rastarter/setup.c	2006-08-23 13:29:51.394898000 +0100
@@ -0,0 +1,95 @@
+/*
+ * arch/sh/boards/st40rastarter/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40RA/ST40STB1 Starter support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/st40rastarter/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+const char *get_system_type(void)
+{
+	return "ST40RA/ST40STB1 Starter";
+}
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned char version;
+
+	version = ctrl_inl(EPLD_REVID) & 0xff;
+
+	printk("STMicroelectronics ST40 Starter initialisation\n");
+	printk("EPLD version: %d.%02d\n",(version >> 4) & 0xf, version & 0xf);
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+}
+
+#if 1
+// This code should be moved into arch/sh/drivers/pci/ops-<board>.c
+
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	pr_debug("%s: slot %d, pin %d\n", __FUNCTION__, slot, pin);
+
+	switch(slot) {
+	case 1:
+		irq=0;
+		break;
+	case 2:
+		irq=3;
+		break;
+	case 3:
+		irq=1;
+		break;
+	case 4:
+		irq=2;
+		break;
+	}
+
+	/* Are we asking for a known slot ? */
+	if(irq==-1) return -1;
+
+	if(pin==1) return irq;
+
+	/* if INTB/C/D h then this can only come from the PCI add in slot */
+	if(slot!=1) return -1;
+
+	/* An INTB,INTC,INTD - these are commoned up */
+	switch(pin) {
+	case 2:
+		irq=4;
+		break;
+	case 3:
+		irq=5;
+		break;
+	case 4:
+		irq=7;
+		break;
+	default:
+		irq=-1;
+		break;
+	}
+
+	return irq;
+}
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1harp/led.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/led.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1harp/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/led.c	2006-08-23 13:29:29.295392000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/arch/sh/boards/st/stb1harp/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains ST40STB1 HARP and compatible code.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/stb1harp/harp.h>
+
+/* Harp: Flash LD10 (front pannel) connected to EPLD (IC8) */
+void mach_led(int position, int value)
+{
+	if (value) {
+		ctrl_outl(EPLD_LED_ON, EPLD_LED);
+	} else {
+		ctrl_outl(EPLD_LED_OFF, EPLD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1harp/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1harp/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/mach.c	2006-08-23 13:29:30.695415000 +0100
@@ -0,0 +1,61 @@
+/*
+ * linux/arch/sh/boards/harp/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB1 HARP and compatible boards
+ */
+
+#include <linux/init.h>
+
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/hd64465/io.h>
+#include <asm/hd64465/hd64465.h>
+#include <asm/stb1harp/harp.h>
+
+/*
+ * The Machine Vector
+ */
+
+struct sh_machine_vector mv_harp __initmv = {
+	.mv_nr_irqs		= 89 + HD64465_IRQ_NUM,
+
+	.mv_inb			= hd64465_inb,
+	.mv_inw			= hd64465_inw,
+	.mv_inl			= hd64465_inl,
+	.mv_outb		= hd64465_outb,
+	.mv_outw		= hd64465_outw,
+	.mv_outl		= hd64465_outl,
+
+	.mv_inb_p		= hd64465_inb_p,
+	.mv_inw_p		= hd64465_inw,
+	.mv_inl_p		= hd64465_inl,
+	.mv_outb_p		= hd64465_outb_p,
+	.mv_outw_p		= hd64465_outw,
+	.mv_outl_p		= hd64465_outl,
+
+	.mv_insb		= hd64465_insb,
+	.mv_insw		= hd64465_insw,
+	.mv_insl		= hd64465_insl,
+	.mv_outsb		= hd64465_outsb,
+	.mv_outsw		= hd64465_outsw,
+	.mv_outsl		= hd64465_outsl,
+
+        .mv_isa_port2addr       = hd64465_isa_port2addr,
+
+#ifdef CONFIG_PCI
+	.mv_init_irq		= harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+
+	.mv_irq_demux		= hd64465_irq_demux,
+};
+
+ALIAS_MV(harp)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1harp/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stb1harp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/Makefile	2006-08-23 13:29:29.284395000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STB1 HARP board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1harp/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1harp/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1harp/setup.c	2006-08-23 13:29:51.406898000 +0100
@@ -0,0 +1,77 @@
+/*
+ * arch/sh/boards/st/stb1harp/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40STB1 HARP and compatible support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/stb1harp/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+const char *get_system_type(void)
+{
+	return "STB1 Harp";
+}
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long ic8_version, ic36_version;
+
+	ic8_version = ctrl_inl(EPLD_REVID2);
+	ic36_version = ctrl_inl(EPLD_REVID1);
+
+        printk("STMicroelectronics STB1 HARP initialisaton\n");
+        printk("EPLD versions: IC8: %ld.%02ld, IC36: %ld.%02ld\n",
+               (ic8_version >> 4) & 0xf, ic8_version & 0xf,
+               (ic36_version >> 4) & 0xf, ic36_version & 0xf);
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+}
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+
+/*
+ * pcibios_map_platform_irq
+ *
+ * This is board specific and returns the IRQ for a given PCI device.
+ * It is used by the PCI code (arch/sh/drivers/pci/pci-st40.c)
+ */
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	switch (slot) {
+	case 2:
+		irq=0;
+		break;
+	case 9 ... 12:
+		irq = 12-slot+1;
+		break;
+	}
+
+	/* Are we asking for a known slot ? */
+	if(irq==-1) return -1;
+
+	if(pin==1) return irq;
+	/* An INTB,INTC,INTD - these are commoned up */
+	return pin+3;
+
+}
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/led.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/led.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/led.c	2006-08-23 13:29:29.351393000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/arch/sh/boards/stb1overdrive/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the ST40RA/ST40STB1 Overdrive board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/stb1overdrive/harp.h>
+
+/* Overdrive: Flash LD1 (front panel) connected to EPLD (IC4) */
+void mach_led(int position, int value)
+{
+	if (value) {
+		ctrl_outl(EPLD_LED_ON, EPLD_LED);
+	} else {
+		ctrl_outl(EPLD_LED_OFF, EPLD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/mach.c	2006-08-23 13:29:30.714415000 +0100
@@ -0,0 +1,61 @@
+/*
+ * linux/arch/sh/boards/stb1overdrive/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STB1 HARP and compatible boards
+ */
+
+#include <linux/init.h>
+
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/hd64465/io.h>
+#include <asm/hd64465/hd64465.h>
+#include <asm/stb1overdrive/harp.h>
+
+/*
+ * The Machine Vector
+ */
+
+struct sh_machine_vector mv_stb1overdrive __initmv = {
+	.mv_nr_irqs		= 89 + HD64465_IRQ_NUM,
+
+	.mv_inb			= hd64465_inb,
+	.mv_inw			= hd64465_inw,
+	.mv_inl			= hd64465_inl,
+	.mv_outb		= hd64465_outb,
+	.mv_outw		= hd64465_outw,
+	.mv_outl		= hd64465_outl,
+
+	.mv_inb_p		= hd64465_inb_p,
+	.mv_inw_p		= hd64465_inw,
+	.mv_inl_p		= hd64465_inl,
+	.mv_outb_p		= hd64465_outb_p,
+	.mv_outw_p		= hd64465_outw,
+	.mv_outl_p		= hd64465_outl,
+
+	.mv_insb		= hd64465_insb,
+	.mv_insw		= hd64465_insw,
+	.mv_insl		= hd64465_insl,
+	.mv_outsb		= hd64465_outsb,
+	.mv_outsw		= hd64465_outsw,
+	.mv_outsl		= hd64465_outsl,
+
+	.mv_isa_port2addr	= hd64465_isa_port2addr,
+
+#ifdef CONFIG_PCI
+	.mv_init_irq		= harp_init_irq,
+#endif
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+
+	.mv_irq_demux		= hd64465_irq_demux,
+};
+
+ALIAS_MV(stb1overdrive)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/Makefile	2006-08-23 13:29:29.309396000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics ST40STB1 Overdrive board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stb1overdrive/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb1overdrive/setup.c	2006-08-23 13:29:51.415898000 +0100
@@ -0,0 +1,72 @@
+/*
+ * arch/sh/boards/stb1overdrive/setup.c
+ *
+ * Copyright (C) 2001 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics ST40RA/ST40STB1 Overdrive support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/stb1overdrive/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+const char *get_system_type(void)
+{
+	return "ST40RA/ST40STB1 Overdrive";
+}
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long version;
+	unsigned long xswitch;
+
+	version = ctrl_inl(EPLD_REVID);
+	xswitch = ctrl_inl(EPLD_SWITCH);
+
+	printk("STMicroelectronics STB1 Overdrive initialisation\n");
+	printk("EPLD version: %ld.%02ld\n",
+	       (version >> 4) & 0xf, version & 0xf);
+	printk("Switch settings: SW1 %lx, STEM %lx\n",
+	       xswitch& 0xf, (xswitch >> 4) & 0x3);
+}
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+
+/*
+ * pcibios_map_platform_irq
+ *
+ * This is board specific and returns the IRQ for a given PCI device.
+ * It is used by the PCI code (arch/sh/drivers/pci/pci-st40.c)
+ */
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	switch (slot) {
+	case 1 ... 3 :
+		irq=slot - 1;
+		break;
+	}
+
+	/* Are we asking for a known slot ? */
+	if(irq==-1) return -1;
+
+	if(pin==1) return irq;
+	/* An INTB,INTC,INTD - these are commoned up */
+	return pin+2;
+}
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/led.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/led.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/led.c	2006-08-23 13:29:32.438462000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/arch/sh/boards/st/stb7100mboard/led.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains code to drive the LED on the STb7100 Validation board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/stb7100mboard/harp.h>
+
+void mach_led(int position, int value)
+{
+	if (value) {
+		ctrl_outb(EPLD_LED_ON, EPLD_POD_LED);
+	} else {
+		ctrl_outb(EPLD_LED_OFF, EPLD_POD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/mach.c	2006-08-23 13:29:51.265898000 +0100
@@ -0,0 +1,82 @@
+/*
+ * arch/sh/boards/st/stb7100mboard/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7100 Validation board.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/stb7100mboard/harp.h>
+
+static void __iomem *stb7100mboard_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+        /* This is something of a hack, to avoid problems with the IDE
+         * driver trying to access non-existant memory. So we only
+         * return valid addresses for PCI, and redirect everything else
+         * to somewhere safe.
+         */
+        if ((port >= PCIBIOS_MIN_IO) &&
+            (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+                return (void __iomem *)(offset + ST40PCI_IO_ADDRESS);
+        }
+#endif
+
+#ifdef CONFIG_BLK_DEV_ST40IDE
+        /*
+         * The IDE driver appears to use memory addresses with IO port
+         * calls. This needs fixing.
+         */
+	return (void __iomem *)port;
+#endif
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init stb7100mboard_init_irq(void)
+{
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+
+        /* Route e/net PHY interrupt to SH4 - only for STb7109 */
+#ifdef CONFIG_STB7109_ETH
+        /* Note that we invert the signal - the ste101p is connected
+           to the mb411 as active low. The sh4 INTC expects active high */
+        ilc_route_external(70, 7, 1);
+        /*ilc_route_external(70, 7, 0);*/
+#else
+        ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+#endif
+
+	/* ...where they are hadled as normal HARP style (encoded) interrpts */
+	harp_init_irq();
+}
+
+struct sh_machine_vector mv_stb7100mboard __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= stb7100mboard_init_irq,
+	.mv_ioport_map		= stb7100mboard_ioport_map,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(stb7100mboard)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/Makefile	2006-08-23 13:29:42.523692000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7100 Validation board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7100mboard/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100mboard/setup.c	2006-08-23 13:29:51.424898000 +0100
@@ -0,0 +1,555 @@
+/*
+ * arch/sh/boards/st/stb7100mboard/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7100 MBoard board support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/io.h>
+#include <asm/stb7100mboard/harp.h>
+
+#define SYSCONF_BASE 0xb9001000
+#define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
+#define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
+#define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
+
+#ifdef CONFIG_STB7109_ETH
+#define MAC_SPEED_SEL	    0x00100000 /* MAC is running at 100 Mbps speed */
+#define PHY_CLK_EXT	    0x00080000 /* PHY clock is external (RMII mode)*/
+#define MII_MODE	    0x00040000 /* RMII interface activated */
+#define	ETH_IF_ON	    0x00010000 /* ETH interface on */
+#define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
+#define STB7109ETH_RESOURCE_NAME	"stb7109eth"
+
+/* ETH MAC pad configuration */
+void stb7109eth_hw_setup(void)
+{
+	unsigned long sysconf;
+
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
+
+#ifdef CONFIG_STE101P_RMII
+	sysconf |= MII_MODE; /* RMII selected*/
+#else
+	sysconf &= ~MII_MODE; /* MII selected */
+#endif
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* STe101P: enable the external interrupts */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(10));
+	sysconf |= 0x0000000f;
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
+
+       /* Configure e/net PHY clock */
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
+
+	return;
+}
+#endif
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long sysconf;
+	unsigned long chip_revision, chip_7109;
+	unsigned char devid;
+	unsigned char epldver;
+
+        printk("STMicroelectronics STb7100 MBoard board initialisation\n");
+
+	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+	chip_7109 = (((sysconf >> 12) & 0x3ff) == 0x02c);
+	chip_revision = (sysconf >> 28) +1;
+
+	if (chip_7109)
+		printk("STb7109 version %ld.x\n", chip_revision);
+	else
+		printk("STb7100 version %ld.x\n", chip_revision);
+
+	epldver = ctrl_inb(EPLD_EPLDVER),
+	printk("EPLD v%dr%d, PCB ver %X\n",
+	       epldver >> 4, epldver & 0xf,
+	       ctrl_inb(EPLD_PCBVER));
+
+	devid = ctrl_inb(EPLD_POD_DEVID);
+	printk("POD EPLD version: %d, DevID: MB411(%d) Rev.%c\n",
+	       ctrl_inb(EPLD_POD_REVID),
+	       devid >> 4, 'A'-1+(devid & 0xf));
+
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+
+	/* SCIF_PIO_OUT_EN=0 */
+	/* Route UART2 and PWM to PIO4 instead of SCIF */
+	sysconf &= ~(1<<0);
+
+	/* Set SSC2_MUX_SEL = 0 */
+	/* Treat SSC2 as I2C instead of SSC */
+	sysconf &= ~(1<<3);
+
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+        /* The ST40RTC sources its clock from clock */
+        /* generator B */
+        sysconf = ctrl_inl(SYSCONF_SYS_CFG(8));
+        ctrl_outl(sysconf | 0x2, SYSCONF_SYS_CFG(8));
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 710x being active high.
+	 *
+	 * This test is wrong for 7100 cut 3.0 (which needs the work
+	 * around), but as we can't reliably determine the minor
+	 * revision number, hard luck, this works for most people.
+	 */
+	if ( ( chip_7109 && (chip_revision < 2)) ||
+	     (!chip_7109 && (chip_revision < 3)) ) {
+		static struct stpio_pin *pin;
+		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
+		stpio_set_pin(pin, 0);
+	}
+
+        /* Currently all STB1 chips have problems with the sleep instruction,
+         * so disable it here.
+         */
+	disable_hlt();
+
+#ifdef CONFIG_STB7109_ETH
+	stb7109eth_hw_setup();
+#endif
+
+#ifdef CONFIG_ST_LIRC
+	/* Configure the pio pins for LIRC */
+	stpio_request_pin(3, 3, "IR", STPIO_IN);
+	stpio_request_pin(3, 4, "IR", STPIO_IN);
+	stpio_request_pin(3, 5, "IR", STPIO_ALT_OUT);
+	stpio_request_pin(3, 6, "IR", STPIO_ALT_OUT);
+#endif
+
+#ifdef CONFIG_STM_PWM
+	stpio_request_pin(4, 6, "PWM", STPIO_ALT_OUT);
+	stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
+#endif
+}
+
+const char *get_system_type(void)
+{
+	return "STb7100 MBoard board";
+}
+
+static struct resource ssc_resource[] = {
+        [0] = {
+               .start = 0xB8040000,
+               .end = 0xB8040000 + 0x108,
+               .flags = IORESOURCE_MEM,
+              },
+        [1] = {
+               .start = 0xB8041000,
+               .end = 0xB8041000 + 0x108,
+               .flags = IORESOURCE_MEM,
+              },
+        [2] = {
+               .start = 0xB8042000,
+               .end = 0xB8042000 + 0x108,
+               .flags = IORESOURCE_MEM,
+              },
+        [3] = {
+               .start = 119,
+               .end = 119,
+               .flags = IORESOURCE_IRQ,
+              },
+        [4] = {
+               .start = 118,
+               .end = 118,
+               .flags = IORESOURCE_IRQ,
+              },
+        [5] = {
+               .start = 117,
+               .end = 117,
+               .flags = IORESOURCE_IRQ,
+              },
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+        {2, 0, 2, 1, 2, 2},
+        {3, 0, 3, 1, 3, 2},
+        {4, 0, 4, 1, 0xff, 0xff},
+};
+static struct plat_ssc_data ssc_private_info = {
+         .sscclk      = 133333333,
+         .capability  = 0x1f,
+         .pio         = ssc_pio
+};
+struct platform_device ssc_device = {
+        .name = "ssc",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(ssc_resource),
+        .resource = ssc_resource,
+        .dev = {
+                 .platform_data = &ssc_private_info
+	}
+};
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 7100, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv      = 0, /* automatically calculate */
+	.irbperiodmult  = 0,
+	.irbperioddiv   = 0,
+	.irbontimemult  = 0,
+	.irbontimediv   = 0,
+	.irbrxmaxperiod = 0x5000,
+	.irbversion     = 2,
+	.sysclkdiv	= 2,
+	.rxpolarity	= 1,
+	.subcarrwidth	= 50
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa3e00300,
+		.end	= 0xa3e00300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 7,
+		.end	= 7,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource stb7109eth_resources[] = {
+        [0] = {
+                .start = 0x18110000,
+                .end   = 0x1811ffff,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = 133,
+                .end    = 133,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct resource st40_ohci_resources[] = {
+	/*this lot for the ohci block*/
+	[0] = {
+		.start = 0xb9100000 + 0xffc00,
+		.end  =  0xb9100000 +0xffcff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 168,
+			.end   = 168,
+			.flags = IORESOURCE_IRQ,
+	}
+};
+static struct resource st40_ehci_resources[] = {
+	/*now this for the ehci*/
+	[0] =  {
+			.start = 0xb9100000 + 0xffe00,
+			.end = 0xb9100000 + 0xffeff,
+			.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 169,
+			.end   = 169,
+			.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+        /* Watchdog timer only needs a register address */
+        [0] = {
+               .start = 0xFFC00008,
+               .end = 0xFFC00010,
+               .flags = IORESOURCE_MEM,
+              }
+};
+
+struct platform_device wdt_device = {
+        .name = "wdt",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(wdt_resource),
+        .resource = wdt_resource,
+};
+
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x18018000,
+		.end   = 0x18018000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 125,
+		.end   = 125,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device  st40_ohci_devices = {
+	.name = "ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+};
+
+static struct platform_device  st40_ehci_devices = {
+	.name = "ST40-ehci",
+	.id=2,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ehci_resources),
+	.resource = st40_ehci_resources,
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct platform_device stb7109eth_device = {
+        .name           = "stb7109eth",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(stb7109eth_resources),
+        .resource       = stb7109eth_resources,
+};
+
+static struct resource ste101p_resources[] = {
+        [0] = {
+                .flags  = IORESOURCE_DISABLED,
+        },
+        [1] = {
+                .start  = 7,
+                .end    = 7,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device ste101p_device = {
+        .name           = "ste101p",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(ste101p_resources),
+        .resource       = ste101p_resources,
+};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+static struct resource sata_resource[]= {
+	[0] = {
+		.start = 0x18000000 + 0x01209000,
+		.end   = 0x18000000 + 0x01209000 + 0xfff,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 0xaa,
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct plat_sata_data sata_private_info = {
+	.phy_init	= 0,
+};
+
+static struct platform_device sata_device = {
+	.name		= "stm-sata",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(sata_resource),
+	.resource	= sata_resource,
+	.dev = {
+		.platform_data = &sata_private_info,
+	}
+};
+
+static struct resource rtc_resource[]= {
+        [0] = {
+                .start = 0xffc80000,
+                .end   = 0xffc80000 + 0x40,
+                .flags = IORESOURCE_MEM
+        },
+/* Be careful the
+ * arch/sh/kernel/cpu/irq/ipr.c
+ * must be update with the right value
+ */
+        [1] = {
+                .start = 20,/* Alarm IRQ   */
+                .flags = IORESOURCE_IRQ
+        },
+        [2] = {
+                .start = 21,/* Periodic IRQ*/
+                .flags = IORESOURCE_IRQ
+        },
+};
+static struct platform_device rtc_device = {
+        .name           = "rtc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(rtc_resource),
+        .resource       = rtc_resource,
+};
+
+#ifdef CONFIG_MTD_PHYSMAP
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+	 .name = "Boot firmware",
+	 .size = 0x00040000,
+	 .offset = 0x00000000,
+	 },
+	{
+	 .name = "Kernel",
+	 .size = 0x00100000,
+	 .offset = 0x00040000,
+
+	 },
+	{
+	 .name = "Root FS",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x00140000,
+	 }
+};
+
+static void stb7100_mtd_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp) {
+		harp_set_vpp_on();
+	} else {
+		harp_set_vpp_off();
+	}
+}
+
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= stb7100_mtd_set_vpp,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+#define physmap_flash_data_addr &physmap_flash_data
+#else
+#define physmap_flash_data_addr NULL
+#endif
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= physmap_flash_data_addr,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct resource stm_pwm_resource[]= {
+	[0] = {
+		.start	= 0x18010000,
+		.end	= 0x18010000 + 0x67,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start	= 126,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT0 | PLAT_STM_PWM_OUT1,
+};
+
+static struct platform_device stm_pwm_device = {
+	.name		= "stm-pwm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
+	.resource	= stm_pwm_resource,
+	.dev = {
+		.platform_data = &pwm_private_info,
+	}
+};
+
+static struct platform_device *stb7100mboard_devices[] __initdata = {
+	&smc91x_device,
+	&stb7109eth_device,
+	&ste101p_device,
+	&st40_ohci_devices,
+	&st40_ehci_devices,
+	&lirc_device,
+	&sata_device,
+	&wdt_device,
+	&ssc_device,
+	&rtc_device,
+	&physmap_flash,
+	&stm_pwm_device,
+};
+
+static int __init device_init(void)
+{
+	int ret =0;
+	unsigned long devid;
+	unsigned long chip_revision, chip_7109;
+
+	devid = ctrl_inl(SYSCONF_DEVICEID);
+	chip_7109 = (((devid >> 12) & 0x3ff) == 0x02c);
+	chip_revision = (devid >> 28) + 1;
+
+	if ((! chip_7109) && (chip_revision == 1)) {
+		/* 7100 cut 1.x */
+		sata_private_info.phy_init = 0x0013704A;
+	} else {
+		/* 7100 cut 2.x and cut 3.x and 7109 */
+		sata_private_info.phy_init = 0x388fc;
+	}
+
+	if ((! chip_7109) || (chip_7109 && (chip_revision == 1))) {
+		sata_private_info.only_32bit = 1;
+		sata_private_info.pc_glue_logic_init = 0x1ff;
+	} else {
+		sata_private_info.only_32bit = 0;
+		sata_private_info.pc_glue_logic_init = 0x100ff;
+	}
+
+	ret = platform_add_devices(stb7100mboard_devices, ARRAY_SIZE(stb7100mboard_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100ref/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7100ref/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/mach.c	2006-08-23 13:29:51.276899000 +0100
@@ -0,0 +1,65 @@
+/*
+ * arch/sh/boards/st/stb7100ref/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7100 Reference board.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+
+static void __iomem *stb7100ref_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+        /*
+         * The IDE driver appears to use memory addresses with IO port
+         * calls. This needs fixing.
+         */
+	return (void __iomem *)port;
+#endif
+
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init stb7100ref_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+        /* Set the ILC to route external interrupts to the the INTC */
+        /* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+        ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+        ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+        ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+        ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+
+        make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
+        make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
+        make_ipr_irq(IRL2_IRQ, IRL2_IPR_ADDR, IRL2_IPR_POS, IRL2_PRIORITY);
+        make_ipr_irq(IRL3_IRQ, IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY);
+}
+
+struct sh_machine_vector mv_stb7100ref __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= stb7100ref_init_irq,
+	.mv_ioport_map		= stb7100ref_ioport_map,
+};
+ALIAS_MV(stb7100ref)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100ref/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stb7100ref/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/Makefile	2006-08-23 13:29:40.403645000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7100 Reference board
+#
+
+obj-y := setup.o mach.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7100ref/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7100ref/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7100ref/setup.c	2006-08-23 13:29:51.430899000 +0100
@@ -0,0 +1,440 @@
+/*
+ * arch/sh/boards/st/stb7100ref/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7100 Reference board support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/io.h>
+
+#define SYSCONF_BASE 0xb9001000
+#define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
+#define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
+#define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long sysconf;
+	unsigned long chip_revision, chip_7109;
+	static struct stpio_pin *ethreset;
+
+	printk("STMicroelectronics STb7100 Reference board initialisation\n");
+
+	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+	chip_7109 = (((sysconf >> 12) & 0x3ff) == 0x02c);
+	chip_revision = (sysconf >> 28) +1;
+
+	if (chip_7109)
+		printk("STb7109 version %ld.x\n", chip_revision);
+	else
+		printk("STb7100 version %ld.x\n", chip_revision);
+
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+
+	/* SCIF_PIO_OUT_EN=0 */
+	/* Route UART2 and PWM to PIO4 instead of SCIF */
+	sysconf &= ~(1<<0);
+
+	/* Set SSC2_MUX_SEL = 0 */
+	/* Treat SSC2 as I2C instead of SSC */
+	sysconf &= ~(1<<3);
+
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* Reset the SMSC 91C111 Ethernet chip */
+	ethreset = stpio_request_pin(2, 6, "SMSC_RST", STPIO_OUT);
+	stpio_set_pin(ethreset, 0);
+	udelay(1);
+	stpio_set_pin(ethreset, 1);
+	udelay(1);
+	stpio_set_pin(ethreset, 0);
+
+	/* The ST40RTC sources its clock from clock */
+	/* generator B */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(8));
+	ctrl_outl(sysconf | 0x2, SYSCONF_SYS_CFG(8));
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+
+	/* Configure the pio pins for LIRC */
+	stpio_request_pin(3, 3, "IR", STPIO_IN);
+	stpio_request_pin(3, 4, "IR", STPIO_IN);
+	stpio_request_pin(3, 5, "IR", STPIO_ALT_OUT);
+	stpio_request_pin(3, 6, "IR", STPIO_ALT_OUT);
+
+#ifdef CONFIG_STM_PWM
+	stpio_request_pin(4, 7, "PWM", STPIO_ALT_OUT);
+#endif
+}
+
+const char *get_system_type(void)
+{
+	return "STb7100 Reference board";
+}
+
+static struct resource ssc_resource[] = {
+	[0] = {
+		.start = 0xB8040000,
+		.end = 0xB8040000 + 0x108,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 0xB8041000,
+		.end = 0xB8041000 + 0x108,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = 0xB8042000,
+		.end = 0xB8042000 + 0x108,
+		.flags = IORESOURCE_MEM,
+	},
+	[3] = {
+		.start = 119,
+		.end = 119,
+		.flags = IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start = 118,
+		.end = 118,
+		.flags = IORESOURCE_IRQ,
+	},
+	[5] = {
+		.start = 117,
+		.end = 117,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+	{2, 0, 2, 1, 2, 2},
+	{3, 0, 3, 1, 3, 2},
+	{4, 0, 4, 1, 0xff, 0xff},
+};
+static struct plat_ssc_data ssc_private_info = {
+	.sscclk      = 133333333,
+	.capability  = 0x1b,
+	.pio         = ssc_pio
+};
+struct platform_device ssc_device = {
+	.name = "ssc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ssc_resource),
+	.resource = ssc_resource,
+	.dev = {
+		.platform_data = &ssc_private_info
+	}
+};
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 7100, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+        .irbclkdiv      = 0, /* automatically calculate */
+        .irbperiodmult  = 0,
+        .irbperioddiv   = 0,
+        .irbontimemult  = 0,
+        .irbontimediv   = 0,
+        .irbrxmaxperiod = 0x5000,
+        .irbversion     = 2,
+	.sysclkdiv	= 2,
+	.rxpolarity	= 1
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa2000300,
+		.end	= 0xa2000300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL0_IRQ,
+		.end	= IRL0_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource st40_ohci_resources[] = {
+	/*this lot for the ohci block*/
+	[0] = {
+		.start = 0xb9100000 + 0xffc00,
+		.end  =  0xb9100000 +0xffcff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 168,
+			.end   = 168,
+			.flags = IORESOURCE_IRQ,
+	}
+};
+static struct resource st40_ehci_resources[] = {
+	/*now this for the ehci*/
+	[0] =  {
+			.start = 0xb9100000 + 0xffe00,
+			.end = 0xb9100000 + 0xffeff,
+			.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 169,
+			.end   = 169,
+			.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+	/* Watchdog timer only needs a register address */
+	[0] = {
+		.start = 0xFFC00008,
+		.end = 0xFFC00010,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+struct platform_device wdt_device = {
+	.name = "wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(wdt_resource),
+	.resource = wdt_resource,
+};
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x18018000,
+		.end   = 0x18018000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 125,
+		.end   = 125,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device  st40_ohci_devices = {
+	.name = "ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+};
+
+static struct platform_device  st40_ehci_devices = {
+	.name = "ST40-ehci",
+	.id=2,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ehci_resources),
+	.resource = st40_ehci_resources,
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+static struct resource sata_resource[]= {
+	[0] = {
+		.start = 0x18000000 + 0x01209000,
+		.end   = 0x18000000 + 0x01209000 + 0xfff,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 0xaa,
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct plat_sata_data sata_private_info = {
+	.phy_init	= 0,
+};
+
+static struct platform_device sata_device = {
+	.name		= "stm-sata",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(sata_resource),
+	.resource	= sata_resource,
+	.dev = {
+		.platform_data = &sata_private_info,
+	}
+};
+
+static struct resource rtc_resource[]= {
+	[0] = {
+		.start = 0xffc80000,
+		.end   = 0xffc80000 + 0x40,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 20,/* Alarm IRQ   */
+		.flags = IORESOURCE_IRQ
+	},
+	[2] = {
+		.start = 21,/* Periodic IRQ*/
+		.flags = IORESOURCE_IRQ
+	},
+};
+static struct platform_device rtc_device = {
+	.name		= "rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resource),
+	.resource	= rtc_resource,
+};
+
+static struct resource stm_pwm_resource[]= {
+	[0] = {
+		.start	= 0x18010000,
+		.end	= 0x18010000 + 0x67,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start	= 126,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+static struct plat_stm_pwm_data pwm_private_info = {
+	.flags		= PLAT_STM_PWM_OUT1,
+};
+
+static struct platform_device stm_pwm_device = {
+	.name		= "stm-pwm",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(stm_pwm_resource),
+	.resource	= stm_pwm_resource,
+	.dev = {
+		.platform_data = &pwm_private_info,
+	}
+};
+
+#ifdef CONFIG_MTD_PHYSMAP
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+	 .name = "Boot firmware",
+	 .size = 0x00040000,
+	 .offset = 0x00000000,
+	 },
+	{
+	 .name = "Kernel",
+	 .size = 0x00100000,
+	 .offset = 0x00040000,
+
+	 },
+	{
+	 .name = "Root FS",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x00140000,
+	 }
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= NULL,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+#define physmap_flash_data_addr &physmap_flash_data
+#else
+#define physmap_flash_data_addr NULL
+#endif
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= physmap_flash_data_addr,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct platform_device *stb7100ref_devices[] __initdata = {
+	&smc91x_device,
+	&st40_ohci_devices,
+	&st40_ehci_devices,
+	&lirc_device,
+	&sata_device,
+	&wdt_device,
+	&ssc_device,
+	&rtc_device,
+	&stm_pwm_device,
+	&physmap_flash,
+};
+
+static int __init device_init(void)
+{
+	int ret =0;
+	unsigned long devid;
+	unsigned long chip_revision, chip_7109;
+
+	devid = ctrl_inl(SYSCONF_DEVICEID);
+	chip_7109 = (((devid >> 12) & 0x3ff) == 0x02c);
+	chip_revision = (devid >> 28) + 1;
+
+	if ((! chip_7109) && (chip_revision == 1)) {
+		/* 7100 cut 1.x */
+		sata_private_info.phy_init = 0x0013704A;
+	} else {
+		/* 7100 cut 2.x and cut 3.x and 7109 */
+		sata_private_info.phy_init = 0x388fc;
+	}
+
+	if ((! chip_7109) || (chip_7109 && (chip_revision == 1))) {
+		sata_private_info.only_32bit = 1;
+		sata_private_info.pc_glue_logic_init = 0x1ff;
+	} else {
+		sata_private_info.only_32bit = 0;
+		sata_private_info.pc_glue_logic_init = 0x100ff;
+	}
+
+	ret = platform_add_devices(stb7100ref_devices, ARRAY_SIZE(stb7100ref_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7109eref/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7109eref/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/mach.c	2006-08-23 13:29:51.284898000 +0100
@@ -0,0 +1,64 @@
+/*
+ * arch/sh/boards/st/stb7109eref/mach.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STMicroelectronics STb7109E Reference board.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+
+static void __iomem *stb7109eref_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init stb7109eref_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(70, 4, 1);	/* MDINT */
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);	/* VoIP */
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);	/* ATA */
+	ilc_route_external(ILC_EXT_IRQ3, 7, 0);	/* SMC Ethernet */
+
+	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
+	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
+	make_ipr_irq(IRL2_IRQ, IRL2_IPR_ADDR, IRL2_IPR_POS, IRL2_PRIORITY);
+	make_ipr_irq(IRL3_IRQ, IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY);
+}
+
+struct sh_machine_vector mv_stb7109eref __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= stb7109eref_init_irq,
+	.mv_ioport_map		= stb7109eref_ioport_map,
+};
+ALIAS_MV(stb7109eref)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7109eref/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stb7109eref/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/Makefile	2006-08-23 13:29:43.004691000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STb7109E Reference board
+#
+
+obj-y := setup.o mach.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stb7109eref/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stb7109eref/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stb7109eref/setup.c	2006-08-23 13:29:51.448899000 +0100
@@ -0,0 +1,492 @@
+/*
+ * arch/sh/boards/st/stb7109eref/setup.c
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * STMicroelectronics STb7109E Reference board support.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/io.h>
+
+#define SYSCONF_BASE 0xb9001000
+#define SYSCONF_DEVICEID	(SYSCONF_BASE + 0x000)
+#define SYSCONF_SYS_STA(n)	(SYSCONF_BASE + 0x008 + ((n) * 4))
+#define SYSCONF_SYS_CFG(n)	(SYSCONF_BASE + 0x100 + ((n) * 4))
+
+#ifdef CONFIG_STB7109_ETH
+#define MAC_SPEED_SEL	    0x00100000 /* MAC is running at 100 Mbps speed */
+#define PHY_CLK_EXT	    0x00080000 /* PHY clock is external (RMII mode)*/
+#define MII_MODE	    0x00040000 /* RMII interface activated */
+#define	ETH_IF_ON	    0x00010000 /* ETH interface on */
+#define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
+#define STB7109ETH_RESOURCE_NAME	"stb7109eth"
+
+/* ETH MAC pad configuration */
+static void stb7109eth_hw_setup(void)
+{
+	unsigned long sysconf;
+
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
+
+#ifdef CONFIG_STE101P_RMII
+	sysconf |= MII_MODE; /* RMII selected*/
+#else
+	sysconf &= ~MII_MODE; /* MII selected */
+#endif
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* STe101P: enable the external interrupts */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(10));
+	sysconf |= 0x0000000f;
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(10));
+
+       /* Configure e/net PHY clock */
+	stpio_request_pin(3, 7, STB7109ETH_RESOURCE_NAME, STPIO_ALT_OUT);
+
+	return;
+}
+#else
+static void stb7109eth_hw_setup(void) { }
+#endif
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long sysconf;
+	unsigned long chip_revision;
+	static struct stpio_pin *ethreset;
+
+	printk("STMicroelectronics STb7109E Reference board initialisation\n");
+
+	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+	chip_revision = (sysconf >> 28) + 1;
+	printk("STb7109 version %ld.x\n", chip_revision);
+
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+	sysconf &= ~(1<<3);
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+
+	/* Permanently enable Flash VPP */
+	{
+		static struct stpio_pin *pin;
+		pin = stpio_request_pin(2,7, "VPP", STPIO_OUT);
+		stpio_set_pin(pin, 1);
+	}
+
+	/* Reset the SMSC 91C111 Ethernet chip */
+	ethreset = stpio_request_pin(2, 6, "SMSC_RST", STPIO_OUT);
+	stpio_set_pin(ethreset, 0);
+	udelay(1);
+	stpio_set_pin(ethreset, 1);
+	udelay(1);
+	stpio_set_pin(ethreset, 0);
+
+	/* The ST40RTC sources its clock from clock */
+	/* generator B */
+	sysconf = ctrl_inl(SYSCONF_SYS_CFG(8));
+	ctrl_outl(sysconf | 0x2, SYSCONF_SYS_CFG(8));
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 7109 being active high */
+	if (chip_revision < 2) {
+		static struct stpio_pin *pin;
+		pin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);
+		stpio_set_pin(pin, 0);
+	}
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+
+	stb7109eth_hw_setup();
+
+	/* Configure the pio pins for LIRC */
+	stpio_request_pin(3, 3, "IR", STPIO_IN);
+	stpio_request_pin(3, 4, "IR", STPIO_IN);
+	stpio_request_pin(3, 5, "IR", STPIO_ALT_OUT);
+	stpio_request_pin(3, 6, "IR", STPIO_ALT_OUT);
+}
+
+const char *get_system_type(void)
+{
+	return "STb7109E Reference board";
+}
+
+static struct resource ssc_resource[] = {
+	[0] = {
+	       .start = 0xB8040000,
+	       .end = 0xB8040000 + 0x108,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = 0xB8041000,
+	       .end = 0xB8041000 + 0x108,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[2] = {
+	       .start = 0xB8042000,
+	       .end = 0xB8042000 + 0x108,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[3] = {
+	       .start = 119,
+	       .end = 119,
+	       .flags = IORESOURCE_IRQ,
+	      },
+	[4] = {
+	       .start = 118,
+	       .end = 118,
+	       .flags = IORESOURCE_IRQ,
+	      },
+	[5] = {
+	       .start = 117,
+	       .end = 117,
+	       .flags = IORESOURCE_IRQ,
+	      },
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+	{2, 0, 2, 1, 2, 2},
+	{3, 0, 3, 1, 3, 2},
+	{4, 0, 4, 1, 0xff, 0xff},
+};
+static struct plat_ssc_data ssc_private_info = {
+	 .sscclk      = 133333333,
+	 .capability  = 0x1f,
+	 .pio	      = ssc_pio
+};
+struct platform_device ssc_device = {
+	.name = "ssc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ssc_resource),
+	.resource = ssc_resource,
+	.dev = {
+		 .platform_data = &ssc_private_info
+	}
+};
+
+static struct plat_lirc_data lirc_private_info = {
+	/* For the 7100, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv	= 0, /* automatically calculate */
+	.irbperiodmult	= 0,
+	.irbperioddiv	= 0,
+	.irbontimemult	= 0,
+	.irbontimediv	= 0,
+	.irbrxmaxperiod = 0x5000,
+	.irbversion	= 2,
+	.sysclkdiv	= 2,
+	.rxpolarity	= 1
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa2000300,
+		.end	= 0xa2000300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL3_IRQ,
+		.end	= IRL3_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource stb7109eth_resources[] = {
+        [0] = {
+                .start = 0x18110000,
+                .end   = 0x1811ffff,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = 133,
+                .end    = 133,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct resource st40_ohci_resources[] = {
+	/*this lot for the ohci block*/
+	[0] = {
+		.start = 0xb9100000 + 0xffc00,
+		.end  =	 0xb9100000 +0xffcff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 168,
+			.end   = 168,
+			.flags = IORESOURCE_IRQ,
+	}
+};
+static struct resource st40_ehci_resources[] = {
+	/*now this for the ehci*/
+	[0] =  {
+			.start = 0xb9100000 + 0xffe00,
+			.end = 0xb9100000 + 0xffeff,
+			.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = 169,
+			.end   = 169,
+			.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+	/* Watchdog timer only needs a register address */
+	[0] = {
+	       .start = 0xFFC00008,
+	       .end = 0xFFC00010,
+	       .flags = IORESOURCE_MEM,
+	      }
+};
+
+struct platform_device wdt_device = {
+	.name = "wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(wdt_resource),
+	.resource = wdt_resource,
+};
+
+
+static struct resource lirc_resource[]= {
+	/* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x18018000,
+		.end   = 0x18018000 + 0xa0,
+		.flags = IORESOURCE_MEM
+	},
+	/* The LIRC block has one interrupt */
+	[1] = {
+		.start = 125,
+		.end   = 125,
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device  st40_ohci_devices = {
+	.name = "ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+};
+
+static struct platform_device  st40_ehci_devices = {
+	.name = "ST40-ehci",
+	.id=2,
+	.dev = {
+		.dma_mask = &st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+	.num_resources = ARRAY_SIZE(st40_ehci_resources),
+	.resource = st40_ehci_resources,
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct platform_device stb7109eth_device = {
+        .name           = "stb7109eth",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(stb7109eth_resources),
+        .resource       = stb7109eth_resources,
+};
+
+static struct resource ste101p_resources[] = {
+        [0] = {
+                .flags  = IORESOURCE_DISABLED,
+        },
+        [1] = {
+                .start  = IRL0_IRQ,
+                .end    = IRL0_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device ste101p_device = {
+        .name           = "ste101p",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(ste101p_resources),
+        .resource       = ste101p_resources,
+};
+
+static struct platform_device lirc_device = {
+	.name		= "lirc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(lirc_resource),
+	.resource	= lirc_resource,
+	.dev = {
+		   .platform_data = &lirc_private_info
+	}
+};
+
+static struct resource sata_resource[]= {
+	[0] = {
+		.start = 0x18000000 + 0x01209000,
+		.end   = 0x18000000 + 0x01209000 + 0xfff,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 0xaa,
+		.flags = IORESOURCE_IRQ
+	},
+};
+
+static struct plat_sata_data sata_private_info = {
+	.phy_init	= 0,
+};
+
+static struct platform_device sata_device = {
+	.name		= "stm-sata",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(sata_resource),
+	.resource	= sata_resource,
+	.dev = {
+		.platform_data = &sata_private_info,
+	}
+};
+
+static struct resource rtc_resource[]= {
+	[0] = {
+		.start = 0xffc80000,
+		.end   = 0xffc80000 + 0x40,
+		.flags = IORESOURCE_MEM
+	},
+/* Be careful the
+ * arch/sh/kernel/cpu/irq_ipr.c
+ * must be update with the right value
+ */
+	[1] = {
+		.start = 20,/* Alarm IRQ   */
+		.flags = IORESOURCE_IRQ
+	},
+	[2] = {
+		.start = 21,/* Periodic IRQ*/
+		.flags = IORESOURCE_IRQ
+	},
+};
+static struct platform_device rtc_device = {
+	.name		= "rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resource),
+	.resource	= rtc_resource,
+};
+
+#ifdef CONFIG_MTD_PHYSMAP
+static struct mtd_partition mtd_parts_table[3] = {
+	{
+	 .name = "Boot firmware",
+	 .size = 0x00040000,
+	 .offset = 0x00000000,
+	 },
+	{
+	 .name = "Kernel",
+	 .size = 0x00100000,
+	 .offset = 0x00040000,
+
+	 },
+	{
+	 .name = "Root FS",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x00140000,
+	 }
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= 2,
+	.set_vpp	= NULL,
+	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+	.parts		= mtd_parts_table
+};
+#define physmap_flash_data_addr &physmap_flash_data
+#else
+#define physmap_flash_data_addr NULL
+#endif
+
+static struct resource physmap_flash_resource = {
+	.start		= 0x00000000,
+	.end		= 0x00800000 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= physmap_flash_data_addr,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+
+static struct platform_device *stb7109eref_devices[] __initdata = {
+	&smc91x_device,
+	&stb7109eth_device,
+	&ste101p_device,
+	&st40_ohci_devices,
+	&st40_ehci_devices,
+	&lirc_device,
+	&sata_device,
+	&wdt_device,
+	&ssc_device,
+	&rtc_device,
+	&physmap_flash,
+};
+
+static int __init device_init(void)
+{
+	int ret =0;
+	unsigned long devid;
+	unsigned long chip_revision;
+
+	devid = ctrl_inl(SYSCONF_DEVICEID);
+	chip_revision = (devid >> 28) + 1;
+
+	sata_private_info.phy_init = 0x388FC;
+
+	if (chip_revision == 1) {
+		/* 7109 cut 1.x */
+		sata_private_info.only_32bit = 1;
+		sata_private_info.pc_glue_logic_init = 0x1ff;
+	} else {
+		/* 7109 cut >= 2.0 */
+		sata_private_info.only_32bit = 0;
+		sata_private_info.pc_glue_logic_init = 0x100ff;
+	}
+
+	ret = platform_add_devices(stb7109eref_devices, ARRAY_SIZE(stb7109eref_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/led.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/led.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/led.c	2006-08-23 13:29:30.173415000 +0100
@@ -0,0 +1,27 @@
+/*
+ * linux/arch/sh/boards/sti5528espresso/led.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the Espresso.
+ */
+
+#include <linux/config.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include <asm/led.h>
+
+void mach_led(int position, int value)
+{
+	static struct stpio_pin *led = NULL;
+
+	if (led == NULL) {
+		led = stpio_request_pin(4, 7, "LED", STPIO_OUT);
+	}
+
+	stpio_set_pin(led, value);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/mach.c	2006-08-23 13:29:51.301898000 +0100
@@ -0,0 +1,92 @@
+/*
+ * linux/arch/sh/boards/sti5528espresso/mach.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the Espresso.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *espresso_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+	/* This is something of a hack, to avoid problems with the IDE
+	 * driver trying to access non-existant memory. So we only
+	 * return valid addresses for PCI, and redirect everything else
+	 * to somewhere safe.
+	 */
+	if ((port >= PCIBIOS_MIN_IO) &&
+	    (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+		return (void __iomem *)(port + ST40PCI_IO_ADDRESS);
+	}
+#endif
+
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+/*
+ * The External Interrupt on the Espresso pass through an EPLD before
+ * reaching the ILC but the EPLD doesn't perform any encoding action.
+ * Hence they are managed as 4 independent lines!
+ */
+static void __init espresso_init_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+	/* Set the ILC to route external interrupts to the the INTC */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+	ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+
+	/* Looking at the Espresso datasheet the IRL mapping seems to be:
+	 *     IRL0  <--  Int. SLB (STV6412)
+	 *     IRL1  <--  from STi4629 (not used by Linux)
+	 *     IRL2  <--    "  Common Interface (STV0701)
+	 *     IRL3  <--    "  Ethernet CMC91c111
+	 */
+	make_ipr_irq(IRL0_IRQ, IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY);
+	make_ipr_irq(IRL1_IRQ, IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY);
+	make_ipr_irq(IRL2_IRQ, IRL2_IPR_ADDR, IRL2_IPR_POS, IRL2_PRIORITY);
+	make_ipr_irq(IRL3_IRQ, IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY);
+}
+
+struct sh_machine_vector mv_espresso __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= espresso_init_irq,
+	.mv_ioport_map		= espresso_ioport_map,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(espresso)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/Makefile	2006-08-23 13:29:30.143392000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics/CiaoLAB Espresso reference platform
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528espresso/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528espresso/setup.c	2006-08-23 13:29:51.463898000 +0100
@@ -0,0 +1,321 @@
+/*
+ * linux/arch/sh/boards/sti5528espresso/setup.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Setup functions for the Espresso.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+#define SYSCONF_BASE	0xf9162000 /* 19162000 */
+#define SYS_CFG03	(SYSCONF_BASE + 0x3C)	 /* Comms. ports     */
+#define SYS_CFG07	(SYSCONF_BASE + 0x4C)	 /* ST20 boot contro */
+#define SYS_CFG10	(SYSCONF_BASE + 0x58)	 /* Ext. IRQs & USB  */
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned long sysreg;
+
+	/*
+	 * The Espresso has an EPLD but has not the same function
+	 * as in the STi5528 Eval board (MB376).
+	 */
+	printk("STMicroelectronics STi5528 Espresso initialization\n");
+
+	/*
+	 * Assert External interrupt handled as input signals
+	 * (it shoul be the default, but...)
+	 * Pay attention: this reg. also used for USB
+	 * See the irq.c source to have more infos...
+	 */
+	sysreg = ctrl_inl(SYS_CFG10);
+	sysreg |= 0x0F;
+	ctrl_outl(sysreg, SYS_CFG10);
+
+	/*
+	 * Enable ST40 SCIF serial system console:
+	 * Set System configuration registers so that the
+	 * PIO7[0-3] and PIO7[4-7] are used respectively for
+	 * SCI0 and SCI1 ST40 serial lines.
+	 * Also set PCI_REQN1_EN to enable PCI_REQ1
+	 * (connected to PIO3[4]).
+	 */
+	sysreg = ctrl_inl(SYS_CFG03);
+	sysreg |= 0x00010600 | (1<<19);
+	ctrl_outl(sysreg, SYS_CFG03);
+
+	/* Enable PCI_GNT1 */
+	stpio_request_pin(4, 0, "PCI GNT1", STPIO_ALT_OUT);
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+
+	/* Configure the pio pins for LIRC */
+	sysreg = ctrl_inl(SYS_CFG03);
+	sysreg |= 0x00020060;
+	ctrl_outl(sysreg, SYS_CFG03);
+
+	stpio_request_pin(5, 0, "IR", STPIO_IN);
+	stpio_request_pin(5, 1, "IR", STPIO_IN);
+	stpio_request_pin(5, 2, "IR", STPIO_OUT);
+	stpio_request_pin(5, 3, "IR", STPIO_ALT_OUT);
+}
+
+const char *get_system_type(void)
+{
+	return "Espresso";
+}
+
+static u64 st40_dma_mask = 0xffffffful;
+
+/* ssc parameters */
+static struct resource ssc_resource[] = {
+        [0] = {
+               .start = 0xBA040000,
+               .end = 0xBA040000 + 0x108,
+               .flags = IORESOURCE_MEM,
+               },
+        [1] = {
+               .start = 0xBA041000,
+               .end = 0xBA041000 + 0x108,
+               .flags = IORESOURCE_MEM,
+               },
+        [2] = {
+               .start = 117,
+               .end = 117,
+               .flags = IORESOURCE_IRQ,
+               },
+        [3] = {
+               .start = 118,
+               .end = 118,
+               .flags = IORESOURCE_IRQ,
+               },
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+        {3, 1, 3, 0, 0xff, 0xff},
+        {3, 3, 3, 2, 0xff, 0xff}
+};
+static struct plat_ssc_data ssc_private_info = {
+         .sscclk      = 133333333,
+         .capability  = 5,
+         .pio         = ssc_pio
+};
+
+struct platform_device ssc_device = {
+        .name = "ssc",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(ssc_resource),
+        .resource = ssc_resource,
+        .dev = {
+                 .platform_data = &ssc_private_info
+	}
+};
+
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+        /* Watchdog timer only needs a register address */
+        [0] = {
+               .start = 0xFFC00008,
+               .end = 0xFFC00010,
+               .flags = IORESOURCE_MEM,
+}
+};
+
+struct platform_device wdt_device = {
+        .name = "wdt",
+        .id = -1,
+        .num_resources = ARRAY_SIZE(wdt_resource),
+        .resource = wdt_resource,
+};
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 5528, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+        .irbclkdiv      = 0, /* automatically calculate */
+        .irbperiodmult  = 0,
+        .irbperioddiv   = 0,
+        .irbontimemult  = 0,
+        .irbontimediv   = 0,
+        .irbrxmaxperiod = 0x5000,
+        .irbversion     = 1,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1
+};
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x1a018000,
+		.end   = 0x1a018000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 128,
+		.end   = 128,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa3800300,
+		.end	= 0xa3800300 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRL3_IRQ,
+		.end	= IRL3_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct resource st40_ohci_resources[2][2] = {
+{
+	[0] = {
+		.start =0xb9141000,
+		.end =0xb9141000 + 0xff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 136,
+		.end   = 136,
+		.flags = IORESOURCE_IRQ,
+	}
+}, {
+	[0] = {
+		.start = 0xb9142000,
+		.end = 0xb9142000 + 0xff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 137,
+		.end = 137,
+		.flags  = IORESOURCE_IRQ,
+	},
+}};
+
+static struct platform_device st40_ohci_devices[2] = {
+{
+	.name 		="ST40-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources[0]),
+	.resource = st40_ohci_resources[0],
+}, {
+	.name 		="ST40-ohci",
+	.id = 1,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources[1]),
+	.resource = st40_ohci_resources[1],
+}};
+
+static struct resource rtc_resource[]= {
+        [0] = {
+                .start = 0xffc80000,
+                .end   = 0xffc80000 + 0x40,
+                .flags = IORESOURCE_MEM
+        },
+/* Be careful the
+ * arch/sh/kernel/cpu/irq/ipr.c
+ * must be update with the right value
+ */
+        [1] = {
+                .start = 20,/* Alarm IRQ   */
+                .flags = IORESOURCE_IRQ
+        },
+        [2] = {
+                .start = 21,/* Periodic IRQ*/
+                .flags = IORESOURCE_IRQ
+        },
+};
+static struct platform_device rtc_device = {
+        .name           = "rtc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(rtc_resource),
+        .resource       = rtc_resource,
+};
+
+static struct platform_device *espresso_devices[] __initdata = {
+	&smc91x_device,
+	&st40_ohci_devices[0],
+	&st40_ohci_devices[1],
+	&lirc_device,
+	&wdt_device,
+	&rtc_device,
+	&ssc_device,
+};
+
+static int __init device_init(void)
+{
+	int ret = 0;
+	ret = platform_add_devices(espresso_devices, ARRAY_SIZE(espresso_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+/*
+ * PCI based boards need a function that maps IRQ's to given PCI
+ * slots. This code is used by the st40 pci routines in arch/sh/kernel
+ */
+
+int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	static int first_time = 1;
+	if ((pin != 1) && (first_time)) {
+		pr_info("Warning: PCI INTB/C/D only active if resistor D15 fitted\n");
+		first_time = 0;
+	}
+	return ST40PCI_AD_IRQ;
+}
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528eval/led.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/led.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528eval/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/led.c	2006-08-23 13:29:30.204417000 +0100
@@ -0,0 +1,25 @@
+/*
+ * linux/arch/sh/boards/sti5528eval/led.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the STi5528 Eval board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/sti5528eval/harp.h>
+
+void mach_led(int position, int value)
+{
+	if (value) {
+		epld_out(EPLD_LED_ON, EPLD_LED);
+	} else {
+		epld_out(EPLD_LED_OFF, EPLD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528eval/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528eval/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/mach.c	2006-08-23 13:29:51.310899000 +0100
@@ -0,0 +1,78 @@
+/*
+ * linux/arch/sh/boards/sti5528eval/mach.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STi5528 Eval.
+ */
+
+#include <linux/init.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/sti5528eval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+static void __iomem *sti5528eval_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_PCI
+	/* This is something of a hack, to avoid problems with the IDE
+	 * driver trying to access non-existant memory. So we only
+	 * return valid addresses for PCI, and redirect everything else
+	 * to somewhere safe.
+	 */
+	if ((port >= PCIBIOS_MIN_IO) &&
+	    (port < ((64 * 1024) - PCIBIOS_MIN_IO + 1))) {
+		return (void __iomem *)(port + ST40PCI_IO_ADDRESS);
+	}
+#endif
+
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#endif
+
+	/* However picking somewhere safe isn't as easy as you might think.
+	 * I used to use external ROM, but that can cause problems if you are
+	 * in the middle of updating Flash. So I'm now using the processor core
+	 * version register, which is guaranted to be available, and non-writable.
+	 */
+	return (void __iomem *)CCN_PVR;
+}
+
+static void __init sti5528eval_irq_init(void)
+{
+	/* Set the ILC to route external interrupts to the the INTC */
+	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
+	ilc_route_external(ILC_EXT_IRQ0, 4, 0);
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);
+	ilc_route_external(ILC_EXT_IRQ2, 6, 0);
+	ilc_route_external(ILC_EXT_IRQ3, 7, 0);
+
+	/* ...where they are hadled as normal HARP style (encoded) interrpts */
+	harp_init_irq();
+}
+
+struct sh_machine_vector mv_sti5528eval __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= sti5528eval_irq_init,
+	.mv_ioport_map		= sti5528eval_ioport_map,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(sti5528eval)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528eval/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/sti5528eval/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/Makefile	2006-08-23 13:29:30.193415000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STi5528 Eval board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/sti5528eval/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/sti5528eval/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/sti5528eval/setup.c	2006-08-23 13:29:51.484899000 +0100
@@ -0,0 +1,369 @@
+/*
+ * linux/arch/sh/boards/sti5528eval/setup.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Setup functions for the STi5528 Eval board.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/sti5528eval/harp.h>
+#include "../../../drivers/pci/pci-st40.h"
+
+#define SYSCONF_BASE	0xf9162000 /* 19162000 */
+#define SYS_DEVICEID	(SYSCONF_BASE + 0x00)
+#define SYS_REVISION	(SYSCONF_BASE + 0x04)
+#define SYS_REVISION2	(SYSCONF_BASE + 0x10)
+#define SYS_STA0	(SYSCONF_BASE + 0x1C)
+#define SYS_CFG03	(SYSCONF_BASE + 0x3C)	 /* Comms. ports     */
+#define SYS_CFG07	(SYSCONF_BASE + 0x4C)	 /* ST20 boot contro */
+#define SYS_CFG10	(SYSCONF_BASE + 0x58)	 /* Ext. IRQs & USB  */
+
+#define CLKGEN_BASE		0xb9163000
+#define CLKGEN_LP_CLK_CTRL	(CLKGEN_BASE + 0x7c)
+#define  CLKGEN_LP_CLK_STOP		(1<<10)
+#define  CLKGEN_LP_CLK_CLK_SEL_RTCCLK	(0<<11)
+#define  CLKGEN_LP_CLK_CLK_SEL_27MHZ	(1<<11)
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned char epld_ver = 0;
+	unsigned long sysreg;
+
+	epld_ver = epld_in(EPLD_REVID);
+	printk("STMicroelectronics STi5528 Eval initialisation (EPLD ver. %d.%d)\n",
+	       (epld_ver >>4), (epld_ver & 0x0f));
+
+	printk("DevID %08x, rev %08x %08x, STA %08x\n",
+	       ctrl_inl(SYS_DEVICEID), ctrl_inl(SYS_REVISION),
+	       ctrl_inl(SYS_REVISION2), ctrl_inl(SYS_STA0));
+
+	/*
+	** Assert External interrupt handled as input signals
+	** (it shoul be the default, but...)
+	** Pay attention: this reg. also used for USB
+	** See the irq.c source to have more infos...
+	*/
+	sysreg = ctrl_inl(SYS_CFG10);
+	sysreg |= 0x0F;
+	ctrl_outl(sysreg, SYS_CFG10);
+
+	/*
+	 * Enable ST40 SCIF serial system console:
+	 * Set System configuration registers so that the
+	 * PIO7[0-3] and PIO7[4-7] are used respectively for
+	 * SCI0 and SCI1 ST40 serial lines.
+	 * Also set PCI_REQN[1-3]_EN to enable PCI_REQ[1-3]
+	 * (connected to PIO3[4-6]).
+	 */
+	sysreg = ctrl_inl(SYS_CFG03);
+	sysreg |= 0x00010600 | (1<<19)|(1<<20)|(1<<21);
+	ctrl_outl(sysreg, SYS_CFG03);
+
+	/* Enable PCI_GNT[1-3] */
+	stpio_request_pin(4, 0, "PCI GNT1", STPIO_ALT_OUT);
+	stpio_request_pin(4, 1, "PCI GNT2", STPIO_ALT_OUT);
+	stpio_request_pin(4, 2, "PCI GNT3", STPIO_ALT_OUT);
+
+	/*
+	 * STi5528 Eval uses a VCXO to generate the 32KHz low power
+	 * clock. Unfortuntaly this is not very accurate (DDTS bug
+	 * report INSbl20690), and should be replaced by an oscilator
+	 * module.  Meanwhile, generate the LPCLK signal from the
+	 * 27Mhz input. This should be the default on cut2.
+	 *
+	 * Unfortunatly because of another bug (GNBvd31378) the SH4's
+	 * RTC is still clocked from the external 32K clock, so we have
+	 * use the comms block RTC.
+	 */
+	sysreg = ctrl_inl(CLKGEN_LP_CLK_CTRL);
+	sysreg |= CLKGEN_LP_CLK_STOP;
+	ctrl_outl(sysreg, CLKGEN_LP_CLK_CTRL);
+
+	sysreg = (27000000 + (32768/2)) / 32786;
+	sysreg |= CLKGEN_LP_CLK_CLK_SEL_27MHZ | CLKGEN_LP_CLK_STOP;
+	ctrl_outl(sysreg, CLKGEN_LP_CLK_CTRL);
+
+	sysreg &= ~CLKGEN_LP_CLK_STOP;
+	ctrl_outl(sysreg, CLKGEN_LP_CLK_CTRL);
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+
+	/* Configure the pio pins for LIRC */
+	sysreg = ctrl_inl(SYS_CFG03);
+	sysreg |= 0x00020060;
+	ctrl_outl(sysreg, SYS_CFG03);
+
+	stpio_request_pin(5, 0, "IR", STPIO_IN);
+	stpio_request_pin(5, 1, "IR", STPIO_IN);
+	stpio_request_pin(5, 2, "IR", STPIO_OUT);
+	stpio_request_pin(5, 3, "IR", STPIO_ALT_OUT);
+}
+
+const char *get_system_type(void)
+{
+	return "STi5528 Eval";
+}
+
+static u64 st40_dma_mask = 0xffffffful;
+
+/* ssc parameters */
+static struct resource ssc_resource[] = {
+	[0] = {
+		.start = 0xBA040000,
+		.end = 0xBA040000 + 0x108,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 0xBA041000,
+		.end = 0xBA041000 + 0x108,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = 117,
+		.end = 117,
+		.flags = IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start = 118,
+		.end = 118,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct plat_ssc_pio_t ssc_pio[] = {
+	{3, 1, 3, 0, 0xff, 0xff},
+	{3, 3, 3, 2, 0xff, 0xff}
+};
+static struct plat_ssc_data ssc_private_info = {
+	.sscclk      = 133333333,
+	.capability  = 5,
+	.pio         = ssc_pio
+};
+
+struct platform_device ssc_device = {
+	.name = "ssc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ssc_resource),
+	.resource = ssc_resource,
+	.dev = {
+		.platform_data = &ssc_private_info
+	}
+};
+
+/* Watchdog timer parameters */
+static struct resource wdt_resource[] = {
+	/* Watchdog timer only needs a register address */
+	[0] = {
+		.start = 0xFFC00008,
+		.end = 0xFFC00010,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+struct platform_device wdt_device = {
+	.name = "wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(wdt_resource),
+	.resource = wdt_resource,
+};
+
+static struct resource rtc_resource[]= {
+	[0] = {
+		.start = 0xffc80000,
+		.end   = 0xffc80000 + 0x40,
+		.flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = 20,/* Alarm IRQ   */
+		.flags = IORESOURCE_IRQ
+	},
+	[2] = {
+		.start = 21,/* Periodic IRQ*/
+		.flags = IORESOURCE_IRQ
+	 },
+};
+static struct platform_device rtc_device = {
+	.name		= "rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resource),
+	.resource	= rtc_resource,
+};
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 5528, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+        .irbclkdiv      = 0, /* automatically calculate */
+        .irbperiodmult  = 0,
+        .irbperioddiv   = 0,
+        .irbontimemult  = 0,
+        .irbontimediv   = 0,
+        .irbrxmaxperiod = 0x5000,
+        .irbversion     = 1,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1
+};
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x1a018000,
+		.end   = 0x1a018000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 128,
+		.end   = 128,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+/*
+ * Note that the SMC91C111 is on a STEM card, and so these values may
+ * need changing depending on jumper settings and EMI configuration.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa3020600,
+		.end	= 0xa3020600 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 10,
+		.end	= 10,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct resource st40_ohci_resources[2][2] = {
+{
+	[0] = {
+		.start =0xb9141000,
+		.end =0xb9141000 + 0xff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 136,
+		.end   = 136,
+		.flags = IORESOURCE_IRQ,
+	}
+}, {
+	[0] = {
+		.start = 0xb9142000,
+		.end = 0xb9142000 + 0xff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 137,
+		.end = 137,
+		.flags  = IORESOURCE_IRQ,
+	},
+}};
+
+static struct platform_device st40_ohci_devices[2] = {
+{
+	.name 		="ST40-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources[0]),
+	.resource = st40_ohci_resources[0],
+}, {
+	.name 		="ST40-ohci",
+	.id = 1,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources[1]),
+	.resource = st40_ohci_resources[1],
+}};
+
+static struct platform_device *sti5528eval_devices[] __initdata = {
+	&smc91x_device,
+	&st40_ohci_devices[0],
+	&st40_ohci_devices[1],
+	&lirc_device,
+	&wdt_device,
+	&rtc_device,
+	&ssc_device,
+};
+
+static int __init device_init(void)
+{
+	int ret = 0;
+	ret = platform_add_devices(sti5528eval_devices, ARRAY_SIZE(sti5528eval_devices));
+	return ret;
+}
+
+subsys_initcall(device_init);
+
+#if 0
+// This code should be moved into arch/sh/drivers/pci/{ops,fixups}-<board>.c
+/*
+ * PCI based boards need a function that maps IRQ's to given PCI
+ * slots. This code is used by the st40 pci routines in arch/sh/kernel
+ */
+
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	int irq=-1;
+
+	switch (slot) {
+	case 1 ... 4 :
+		irq=abs(slot - 4);
+		break;
+	default:
+		/* Unknown slot */
+		return -1;
+	}
+
+	if(pin != 1) {
+		/* An INTB,INTC,INTD - these are commoned up */
+		irq = pin+2;
+	}
+
+	return irq;
+}
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stm8000demo/led.c linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/led.c
--- linux-2.6.17.8/arch/sh/boards/st/stm8000demo/led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/led.c	2006-08-23 13:29:30.263415000 +0100
@@ -0,0 +1,32 @@
+/*
+ * linux/arch/sh/boards/stm8000demo/led.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains LED code for the STm8000 Demo board.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/led.h>
+#include <asm/stm8000demo/harp.h>
+
+void mach_led(int position, int value)
+{
+	static int called = 0;
+
+	if (!called) {
+		epld_out(0, EPLD_LED_CTRL);
+		called = 1;
+	}
+
+	if (value) {
+		epld_out(EPLD_LED_ON, EPLD_LED);
+	} else {
+		epld_out(EPLD_LED_OFF, EPLD_LED);
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stm8000demo/mach.c linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/mach.c
--- linux-2.6.17.8/arch/sh/boards/st/stm8000demo/mach.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/mach.c	2006-08-23 13:29:51.334898000 +0100
@@ -0,0 +1,56 @@
+/*
+ * linux/arch/sh/boards/stm8000demo/mach.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the STm8000 Demo.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+#include <asm/led.h>
+#include <asm/machvec_init.h>
+#include <asm/stm8000demo/harp.h>
+
+static void __iomem *stm8000demo_ioport_map(unsigned long port, unsigned int size)
+{
+#ifdef CONFIG_BLK_DEV_ST40IDE
+	/*
+	 * The IDE driver appears to use memory addresses with IO port
+	 * calls. This needs fixing.
+	 */
+	return (void __iomem *)port;
+#else
+	/* No IO address space */
+	return (void __iomem *)CCN_PVR;
+#endif
+}
+
+static void __init stm8000demo_irq_init(void)
+{
+	/* Initialise the ILC */
+	init_IRQ_STm8000_ilc();
+
+	/* Initialise the external interrupts as normal HARP style */
+	harp_init_irq();
+}
+
+struct sh_machine_vector mv_stm8000demo __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+	.mv_init_irq		= stm8000demo_irq_init,
+	.mv_ioport_map		= stm8000demo_ioport_map,
+	.mv_irq_demux		= stm8000_irq_demux,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_heart,
+#endif
+};
+ALIAS_MV(stm8000demo)
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stm8000demo/Makefile linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/Makefile
--- linux-2.6.17.8/arch/sh/boards/st/stm8000demo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/Makefile	2006-08-23 13:29:30.230418000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for STMicroelectronics STm8000 Demo board
+#
+
+obj-y := setup.o mach.o led.o
diff -Naur linux-2.6.17.8/arch/sh/boards/st/stm8000demo/setup.c linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/setup.c
--- linux-2.6.17.8/arch/sh/boards/st/stm8000demo/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/st/stm8000demo/setup.c	2006-08-23 13:29:51.496898000 +0100
@@ -0,0 +1,193 @@
+/*
+ * linux/arch/sh/boards/stm8000demo/setup.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Setup functions for the STm8000 Demo board.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/stm8000demo/harp.h>
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	unsigned char epld_ver;
+	unsigned char pcb_ver;
+
+	epld_ver = epld_in(EPLD_EPLD_VER) & 0xff;
+	pcb_ver	 = epld_in(EPLD_PCB_VER) & 0xff;
+
+	printk("STMicroelectronics STm8000 Demo initialisation\n");
+	printk("EPLD version: %d.%d PCB revision: %X\n",
+	       epld_ver >> 4, epld_ver & 0xf, pcb_ver);
+
+	/* Currently all STB1 chips have problems with the sleep instruction,
+	 * so disable it here.
+	 */
+	disable_hlt();
+}
+
+const char *get_system_type(void)
+{
+	return "STm8000 Demo";
+}
+
+static struct plat_lirc_data lirc_private_info = {
+        /* For the 8000, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+        .irbclkdiv      = 0, /* automatically calculate */
+        .irbperiodmult  = 0,
+        .irbperioddiv   = 0,
+        .irbontimemult  = 0,
+        .irbontimediv   = 0,
+        .irbrxmaxperiod = 0x5000,
+        .irbversion     = 1,
+	.sysclkdiv	= 1
+};
+
+static struct resource gpdma_resources[] = {
+	[0] = {
+		.start  = 0xb8100000,
+		.end    = 0xb8100000 + 0x4ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = ILC_FIRST_IRQ + 24,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start  = ILC_FIRST_IRQ + 25,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start  = ILC_FIRST_IRQ + 26,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start  = ILC_FIRST_IRQ + 27,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[5] = {
+		.start  = ILC_FIRST_IRQ + 28,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[6] = {
+		.start  = ILC_FIRST_IRQ + 29,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device gpdma_device = {
+	.name		= "gpdma",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(gpdma_resources),
+	.resource	= gpdma_resources,
+};
+
+/*
+ * Note that the SMC91C111 is on a STEM card, and so these values may
+ * need changing depending on jumper settings and EMI configuration.
+ */
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start	= 0xa3020600,
+		.end	= 0xa3020600 + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 12,
+		.end	= 12,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct resource st40_ohci_resources[] = {
+	[0] = {
+		.start =0xb4400000,
+		.end =0xb4400000 + 0xFFFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = ILC_FIRST_IRQ + 39,
+		.end   = ILC_FIRST_IRQ + 39,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource lirc_resource[]= {
+        /* This is the main LIRC register block, as defined by the spec */
+       [0] = {
+		.start = 0x18318000,
+		.end   = 0x18318000 + 0xa0,
+                .flags = IORESOURCE_MEM
+        },
+        /* The LIRC block has one interrupt */
+        [1] = {
+                .start = 176 + 15,
+		.end   = 176 + 15,
+                .flags = IORESOURCE_IRQ
+        },
+};
+
+static u64 st40_dma_mask = 0xfffffff;
+
+static struct platform_device st40_ohci_device = {
+	.name 		="ST40-ohci",
+	.id=1,
+	.dev = {
+		.dma_mask =&st40_dma_mask,
+		.coherent_dma_mask = 0xffffffful,
+	},
+
+	.num_resources = ARRAY_SIZE(st40_ohci_resources),
+	.resource = st40_ohci_resources,
+
+	};
+
+static struct platform_device lirc_device = {
+        .name           = "lirc",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(lirc_resource),
+        .resource       = lirc_resource,
+        .dev = {
+                   .platform_data = &lirc_private_info
+        }
+};
+
+static struct platform_device *platform_devices[] __initdata = {
+	&gpdma_device,
+	&smc91x_device,
+	&st40_ohci_device,
+	&lirc_device,
+};
+
+static int __init device_init(void)
+{
+        return platform_add_devices(platform_devices,
+				    ARRAY_SIZE(platform_devices));
+}
+
+subsys_initcall(device_init);
diff -Naur linux-2.6.17.8/arch/sh/boards/titan/io.c linux-2.6.17.8-sh/arch/sh/boards/titan/io.c
--- linux-2.6.17.8/arch/sh/boards/titan/io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/titan/io.c	2006-08-23 13:29:24.138256000 +0100
@@ -0,0 +1,126 @@
+/*
+ *	I/O routines for Titan
+ */
+#include <linux/pci.h>
+#include <asm/machvec.h>
+#include <asm/addrspace.h>
+#include <asm/titan.h>
+#include <asm/io.h>
+
+static inline unsigned int port2adr(unsigned int port)
+{
+        maybebadio((unsigned long)port);
+        return port;
+}
+
+u8 titan_inb(unsigned long port)
+{
+        if (PXSEG(port))
+                return ctrl_inb(port);
+        else if (is_pci_ioaddr(port))
+                return ctrl_inb(pci_ioaddr(port));
+        return ctrl_inw(port2adr(port)) & 0xff;
+}
+
+u8 titan_inb_p(unsigned long port)
+{
+        u8 v;
+
+        if (PXSEG(port))
+                v = ctrl_inb(port);
+        else if (is_pci_ioaddr(port))
+                v = ctrl_inb(pci_ioaddr(port));
+        else
+                v = ctrl_inw(port2adr(port)) & 0xff;
+        ctrl_delay();
+        return v;
+}
+
+u16 titan_inw(unsigned long port)
+{
+        if (PXSEG(port))
+                return ctrl_inw(port);
+        else if (is_pci_ioaddr(port))
+                return ctrl_inw(pci_ioaddr(port));
+        else if (port >= 0x2000)
+                return ctrl_inw(port2adr(port));
+        else
+                maybebadio(port);
+        return 0;
+}
+
+u32 titan_inl(unsigned long port)
+{
+        if (PXSEG(port))
+                return ctrl_inl(port);
+        else if (is_pci_ioaddr(port))
+                return ctrl_inl(pci_ioaddr(port));
+        else if (port >= 0x2000)
+                return ctrl_inw(port2adr(port));
+        else
+                maybebadio(port);
+        return 0;
+}
+
+void titan_outb(u8 value, unsigned long port)
+{
+        if (PXSEG(port))
+                ctrl_outb(value, port);
+        else if (is_pci_ioaddr(port))
+                ctrl_outb(value, pci_ioaddr(port));
+        else
+                ctrl_outw(value, port2adr(port));
+}
+
+void titan_outb_p(u8 value, unsigned long port)
+{
+        if (PXSEG(port))
+                ctrl_outb(value, port);
+        else if (is_pci_ioaddr(port))
+                ctrl_outb(value, pci_ioaddr(port));
+        else
+                ctrl_outw(value, port2adr(port));
+        ctrl_delay();
+}
+
+void titan_outw(u16 value, unsigned long port)
+{
+        if (PXSEG(port))
+                ctrl_outw(value, port);
+        else if (is_pci_ioaddr(port))
+                ctrl_outw(value, pci_ioaddr(port));
+        else if (port >= 0x2000)
+                ctrl_outw(value, port2adr(port));
+        else
+                maybebadio(port);
+}
+
+void titan_outl(u32 value, unsigned long port)
+{
+        if (PXSEG(port))
+                ctrl_outl(value, port);
+        else if (is_pci_ioaddr(port))
+                ctrl_outl(value, pci_ioaddr(port));
+        else
+                maybebadio(port);
+}
+
+void titan_insl(unsigned long port, void *dst, unsigned long count)
+{
+        maybebadio(port);
+}
+
+void titan_outsl(unsigned long port, const void *src, unsigned long count)
+{
+        maybebadio(port);
+}
+
+void __iomem *titan_ioport_map(unsigned long port, unsigned int size)
+{
+	if (PXSEG(port) || is_pci_memaddr(port))
+		return (void __iomem *)port;
+	else if (is_pci_ioaddr(port))
+		return (void __iomem *)pci_ioaddr(port);
+
+	return (void __iomem *)port2adr(port);
+}
diff -Naur linux-2.6.17.8/arch/sh/boards/titan/Makefile linux-2.6.17.8-sh/arch/sh/boards/titan/Makefile
--- linux-2.6.17.8/arch/sh/boards/titan/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/titan/Makefile	2006-08-23 13:29:15.671071000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the Nimble Microsystems TITAN specific parts of the kernel
+#
+
+obj-y	 := setup.o io.o
diff -Naur linux-2.6.17.8/arch/sh/boards/titan/setup.c linux-2.6.17.8-sh/arch/sh/boards/titan/setup.c
--- linux-2.6.17.8/arch/sh/boards/titan/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boards/titan/setup.c	2006-08-23 13:29:17.352116000 +0100
@@ -0,0 +1,59 @@
+/*
+ *	Setup for Titan
+ */
+
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <asm/titan.h>
+#include <asm/io.h>
+
+extern void __init pcibios_init_platform(void);
+
+static void __init init_titan_irq(void)
+{
+	/* enable individual interrupt mode for externals */
+	ctrl_outw(ctrl_inw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
+
+	make_ipr_irq( TITAN_IRQ_WAN,   IRL0_IPR_ADDR, IRL0_IPR_POS, IRL0_PRIORITY); /* PCIRQ0 */
+	make_ipr_irq( TITAN_IRQ_LAN,   IRL1_IPR_ADDR, IRL1_IPR_POS, IRL1_PRIORITY); /* PCIRQ1 */
+	make_ipr_irq( TITAN_IRQ_MPCIA, IRL2_IPR_ADDR, IRL2_IPR_POS, IRL2_PRIORITY); /* PCIRQ2 */
+	make_ipr_irq( TITAN_IRQ_USB,   IRL3_IPR_ADDR, IRL3_IPR_POS, IRL3_PRIORITY); /* PCIRQ3 */
+}
+
+const char *get_system_type(void)
+{
+	return "Titan";
+}
+
+int __init platform_setup(void)
+{
+	printk("%s Platform Setup\n", get_system_type());
+	return 0;
+}
+
+struct sh_machine_vector mv_titan __initmv = {
+	.mv_nr_irqs =	NR_IRQS,
+
+	.mv_inb =	titan_inb,
+	.mv_inw =	titan_inw,
+	.mv_inl =	titan_inl,
+	.mv_outb =	titan_outb,
+	.mv_outw =	titan_outw,
+	.mv_outl =	titan_outl,
+
+	.mv_inb_p =	titan_inb_p,
+	.mv_inw_p =	titan_inw,
+	.mv_inl_p =	titan_inl,
+	.mv_outb_p =	titan_outb_p,
+	.mv_outw_p =	titan_outw,
+	.mv_outl_p =	titan_outl,
+
+	.mv_insl =	titan_insl,
+	.mv_outsl =	titan_outsl,
+
+	.mv_ioport_map = titan_ioport_map,
+
+	.mv_init_irq =	init_titan_irq,
+	.mv_init_pci =	pcibios_init_platform,
+};
+ALIAS_MV(titan)
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/cache.c linux-2.6.17.8-sh/arch/sh/boot/compressed/cache.c
--- linux-2.6.17.8/arch/sh/boot/compressed/cache.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/cache.c	2006-08-23 13:29:33.385486000 +0100
@@ -0,0 +1,172 @@
+/*
+ * arch/sh/boot/compressed/cache.c -- simple cache management functions
+ *
+ * Code extracted from sh-ipl+g, sh-stub.c, which has the copyright:
+ *
+ *   This is originally based on an m68k software stub written by Glenn
+ *   Engel at HP, but has changed quite a bit.
+ *
+ *   Modifications for the SH by Ben Lee and Steve Chamberlain
+ *
+ *   March 2005, modified by Giuseppe Condorelli: to avoid
+ *   	compiling failure, cache_control function is now consistent only
+ *   	for SH3 and SH4 platforms. For others SH platforms (SH2,...) it's
+ *   	implemented as empty function.
+ *
+****************************************************************************
+
+		THIS SOFTWARE IS NOT COPYRIGHTED
+
+   HP offers the following for use in the public domain.  HP makes no
+   warranty with regard to the software or it's performance and the
+   user accepts the software "AS IS" with all faults.
+
+   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
+   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+****************************************************************************/
+
+#include <linux/config.h>
+
+static inline unsigned int ctrl_inl(unsigned long addr)
+{
+	return *(volatile unsigned long *)addr;
+}
+
+static inline void ctrl_outl(unsigned int b, unsigned long addr)
+{
+	*(volatile unsigned long *)addr = b;
+}
+
+/*
+ * Jump to P2 area.
+ * When handling TLB or caches, we need to do it from P2 area.
+ */
+#define jump_to_P2()			\
+do {					\
+	unsigned long __dummy;		\
+	__asm__ __volatile__(		\
+		"mov.l	1f, %0\n\t"	\
+		"or	%1, %0\n\t"	\
+		"jmp	@%0\n\t"	\
+		" nop\n\t" 		\
+		".balign 4\n"		\
+		"1:	.long 2f\n"	\
+		"2:"			\
+		: "=&r" (__dummy)	\
+		: "r" (0x20000000));	\
+} while (0)
+
+/*
+ * Back to P1 area.
+ */
+#define back_to_P1()					\
+do {							\
+	unsigned long __dummy;				\
+	__asm__ __volatile__(				\
+		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
+		"mov.l	1f, %0\n\t"			\
+		"jmp	@%0\n\t"			\
+		" nop\n\t"				\
+		".balign 4\n"				\
+		"1:	.long 2f\n"			\
+		"2:"					\
+		: "=&r" (__dummy));			\
+} while (0)
+
+#if defined(CONFIG_CPU_SH3)
+#define CCR		 0xffffffec
+#define CCR_CACHE_INIT	 0x0000000d	/* 8k-byte cache, CF, P1-wb, enable */
+#define CCR_CACHE_STOP	 0x00000008
+#define CCR_CACHE_ENABLE 0x00000001
+
+#define flush_icache_range(start,end)	do {} while(0)
+
+/* SH7707, SH7708, SH7709 has less cache than SH7709A,
+   but it's OK to have bigger value. */
+#define CACHE_OC_ADDRESS_ARRAY	0xf0000000
+#define CACHE_OC_WAY_SHIFT	12	/*  11 */
+#define CACHE_OC_NUM_ENTRIES	256	/* 128 */
+#define CACHE_OC_ENTRY_SHIFT    4
+#define CACHE_OC_NUM_WAYS	4
+
+#elif defined(CONFIG_CPU_SH4)
+#define CCR		 0xff00001c
+#define CCR_CACHE_INIT	 0x0000090d	/* ICI,ICE(8k), OCI,P1-wb,OCE(16k) */
+#define CCR_CACHE_STOP	 0x00000808
+#define CCR_CACHE_ENABLE 0x00000101
+#define CCR_CACHE_ICI	 0x00000800
+
+#define L1_CACHE_BYTES 32
+#define CACHE_IC_ADDRESS_ARRAY	0xf0000000
+#define CACHE_IC_ENTRY_MASK	0x1fe0
+
+#define CACHE_OC_ADDRESS_ARRAY	0xf4000000
+#define CACHE_OC_WAY_SHIFT       13
+#define CACHE_OC_NUM_ENTRIES	512
+#define CACHE_OC_ENTRY_SHIFT      5
+#define CACHE_OC_NUM_WAYS	  1
+
+#endif
+
+#define CACHE_VALID	  1
+#define CACHE_UPDATED	  2
+
+/*
+ * The following code is implemented for SH3 and SH4 cpus only.
+ * Others sh cpus are not yet implemented.
+ *
+ */
+
+#if defined(CONFIG_CPU_SH3) || defined(CONFIG_CPU_SH4)
+
+static void cache_wback_all(void)
+{
+	unsigned long addr, data, i, j;
+
+	jump_to_P2();
+	for (i = 0; i < CACHE_OC_NUM_ENTRIES; i++)
+		for (j = 0; j < CACHE_OC_NUM_WAYS; j++) {
+			addr =
+			    CACHE_OC_ADDRESS_ARRAY | (j << CACHE_OC_WAY_SHIFT)
+			    | (i << CACHE_OC_ENTRY_SHIFT);
+			data = ctrl_inl(addr);
+			if (data & CACHE_UPDATED) {
+				data &= ~CACHE_UPDATED;
+				ctrl_outl(data, addr);
+			}
+		}
+	back_to_P1();
+}
+
+#define CACHE_ENABLE      0
+#define CACHE_DISABLE     1
+
+int cache_control(unsigned int command)
+{
+	unsigned long ccr;
+
+	jump_to_P2();
+	ccr = ctrl_inl(CCR);
+
+	if (ccr & CCR_CACHE_ENABLE)
+		cache_wback_all();
+
+	if (command == CACHE_DISABLE)
+		ctrl_outl(CCR_CACHE_STOP, CCR);
+	else
+		ctrl_outl(CCR_CACHE_INIT, CCR);
+	back_to_P1();
+
+	return 0;
+}
+
+#else
+
+int cache_control(unsigned int command)
+{
+	return 0;
+}
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/head.S linux-2.6.17.8-sh/arch/sh/boot/compressed/head.S
--- linux-2.6.17.8/arch/sh/boot/compressed/head.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/head.S	2006-08-23 13:29:33.425485000 +0100
@@ -67,11 +67,24 @@
 	mov.l	end_addr, r1
 	mov.l	bss_start_addr, r2
 	mov	#0, r0
-l1:
+1:
 	mov.l	r0, @-r1
 	cmp/eq	r1,r2
-	bf	l1
+	bf	1b
 
+       /* Do we need to move data into RAM? */
+       mov.l   data_image_addr, r1
+       mov.l   data_addr, r2
+       cmp/eq  r1,r2
+       bt      2f
+       mov.l   edata_addr, r3
+1:
+       mov.l   @r1+, r0
+       mov.l   r0, @r2
+       add     #4, r2
+       cmp/eq  r2, r3
+       bf      1b
+2:
 	/* Set the initial pointer. */
 	mov.l	init_stack_addr, r0
 	mov.l	@r0, r15
@@ -87,6 +100,12 @@
 	nop
 	
 	.align	2
+data_image_addr:
+       .long   _data_image
+data_addr:
+       .long   _data
+edata_addr:
+       .long   _edata
 bss_start_addr:
 	.long	__bss_start
 end_addr:
@@ -98,7 +117,7 @@
 decompress_kernel_addr:
 	.long	decompress_kernel
 kernel_start_addr:
-	.long	_text+0x1000
+	.long   0x80000000 + CONFIG_MEMORY_START + 0x2000
 
 	.align	9
 fake_headers_as_bzImage:
@@ -117,4 +136,4 @@
 	.word	0x8000		! size to move, when setup is not
 	.long	0x100000	! 0x100000 = default for big kernel
 	.long	0		! address of loaded ramdisk image
-	.long	0		# its size in bytes
+	.long	0		! its size in bytes
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/Makefile linux-2.6.17.8-sh/arch/sh/boot/compressed/Makefile
--- linux-2.6.17.8/arch/sh/boot/compressed/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/Makefile	2006-08-23 13:29:33.375485000 +0100
@@ -4,10 +4,11 @@
 # create a compressed vmlinux image from the original vmlinux
 #
 
-targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o misc.o piggy.o
+targets		:= vmlinux vmlinux.lds vmlinux.bin vmlinux.bin.gz \
+			head.o misc.o cache.o
 EXTRA_AFLAGS	:= -traditional
 
-OBJECTS = $(obj)/head.o $(obj)/misc.o
+OBJECTS = $(obj)/head.o $(obj)/misc.o $(obj)/cache.o
 
 ifdef CONFIG_SH_STANDARD_BIOS
 OBJECTS += $(obj)/../../kernel/sh_bios.o
@@ -18,13 +19,35 @@
 # Assign dummy values if these 2 variables are not defined,
 # in order to suppress error message.
 #
+CONFIG_PAGE_OFFSET	?= 0x80000000
 CONFIG_MEMORY_START     ?= 0x0c000000
 CONFIG_BOOT_LINK_OFFSET ?= 0x00800000
-IMAGE_OFFSET := $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_MEMORY_START)+$(CONFIG_BOOT_LINK_OFFSET)])
 
-LDFLAGS_vmlinux := -Ttext $(IMAGE_OFFSET) -e startup -T $(obj)/../../kernel/vmlinux.lds
+ifdef CONFIG_ZIMAGE_ROM
 
-$(obj)/vmlinux: $(OBJECTS) $(obj)/piggy.o FORCE
+# ZTEXT_ADDR is the text address of the compression loader (in ROM)
+ZTEXT_ADDR = $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_ZIMAGE_ROM_START)])
+
+# ZDATA_ADDR is the data address for the compression loader (in RAM)
+# This is placed at an offset of 2M + 64K from the start of RAM
+# (2M for the decompressed kernel and 64K for use by the previous loader).
+ZDATA_ADDR = $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_MEMORY_START)+$(CONFIG_BOOT_LINK_OFFSET)])
+
+LDFLAGS_vmlinux := -Ttext $(ZTEXT_ADDR) -Tdata $(ZDATA_ADDR) -e startup -T
+
+else
+
+IMAGE_OFFSET	:= $(shell printf "0x%08x" $$[$(CONFIG_PAGE_OFFSET)  + \
+					      $(CONFIG_MEMORY_START) + \
+					      $(CONFIG_BOOT_LINK_OFFSET)])
+
+LIBGCC	:= $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+
+LDFLAGS_vmlinux := -Ttext $(IMAGE_OFFSET) -e startup -T
+
+endif
+
+$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/piggy.o $(OBJECTS) $(LIBGCC) FORCE
 	$(call if_changed,ld)
 	@:
 
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/misc.c linux-2.6.17.8-sh/arch/sh/boot/compressed/misc.c
--- linux-2.6.17.8/arch/sh/boot/compressed/misc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/misc.c	2006-08-23 13:29:33.437485000 +0100
@@ -9,6 +9,9 @@
  * Adapted for SH by Stuart Menefy, Aug 1999
  *
  * Modified to use standard LinuxSH BIOS by Greg Banks 7Jul2000
+ * Last modification for SH by Giuseppe Condorelli, Mar 2005:
+ *	enabled the use of caches while uncompressing the kernel
+ *	image from flash, to improve the boot time.
  */
 
 #include <linux/config.h>
@@ -17,6 +20,11 @@
 #include <asm/sh_bios.h>
 #endif
 
+/* cache.c */
+#define CACHE_ENABLE      0
+#define CACHE_DISABLE     1
+int cache_control (unsigned int command);
+
 /*
  * gzip declarations
  */
@@ -148,7 +156,48 @@
 	sh_bios_console_write(s, len);
 	return len;
 }
+#elif 0
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7708) || defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+#define SH_SCI_BASE 0xfffffe80
+#define SH_SCI_SCxTDR (SH_SCI_BASE + 0x06)
+#define SH_SCI_SCxSR  (SH_SCI_BASE + 0x08)
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750)
+#define SH_SCI_BASE 0xffe00000
+#define SH_SCI_SCxTDR (SH_SCI_BASE + 0x0c)
+#define SH_SCI_SCxSR  (SH_SCI_BASE + 0x10)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
+#error No SCIs on an ST40
+#else
+#error Unknown CPU
+#endif
+
+#define SCI_TDRE 0x80
+
+void putc(unsigned char c)
+{
+        volatile unsigned char* tdr = (volatile unsigned char*)SH_SCI_SCxTDR;
+        volatile unsigned char* sr  = (volatile unsigned char*)SH_SCI_SCxSR;
+
+        while (!(*sr & SCI_TDRE))
+                ;
+        *tdr = c;
+        *sr = ~(unsigned char)SCI_TDRE;
+}
+
+void puts(const char *s)
+{
+        unsigned char c;
+
+        for ( ; (c = *s) != '\0'; s++) {
+                putc(c);
+                if (c == '\n') {
+                        putc('\r');
+                }
+        }
+}
 #else
+
 int puts(const char *s)
 {
 	/* This should be updated to use the sh-sci routines */
@@ -229,12 +278,17 @@
 void decompress_kernel(void)
 {
 	output_data = 0;
-	output_ptr = (unsigned long)&_text+0x20001000;
+	output_ptr = (unsigned long)(0x80000000 + CONFIG_MEMORY_START + \
+					CONFIG_ZERO_PAGE_OFFSET + PAGE_SIZE);
+	/* empy_zero_page is stripped out by the objcopy which builds the image */
 	free_mem_ptr = (unsigned long)&_end;
 	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
 
 	makecrc();
 	puts("Uncompressing Linux... ");
+	cache_control(CACHE_ENABLE);
 	gunzip();
+	puts("\n");
 	puts("Ok, booting the kernel.\n");
+	cache_control(CACHE_DISABLE);
 }
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/vmlinux.lds.S linux-2.6.17.8-sh/arch/sh/boot/compressed/vmlinux.lds.S
--- linux-2.6.17.8/arch/sh/boot/compressed/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/vmlinux.lds.S	2006-08-23 13:29:33.443484000 +0100
@@ -0,0 +1,59 @@
+/*
+ * ld script to make compressed SuperH Linux kernel+decompression bootstrap
+ * Modified by Stuart Menefy from arch/sh/vmlinux.lds.S written by Niibe Yutaka
+ */
+
+#include <linux/config.h>
+#include <asm-generic/vmlinux.lds.h>
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+OUTPUT_FORMAT("elf32-sh-linux", "elf32-sh-linux", "elf32-sh-linux")
+#else
+OUTPUT_FORMAT("elf32-shbig-linux", "elf32-shbig-linux", "elf32-shbig-linux")
+#endif
+OUTPUT_ARCH(sh)
+ENTRY(_start)
+
+#define ALIGNED_GAP(section, align) (((ADDR(section)+SIZEOF(section)+(align)-1) & ~((align)-1))-ADDR(section))
+#define FOLLOWING(section, align) AT (LOADADDR(section) + ALIGNED_GAP(section,align))
+
+SECTIONS
+{
+  /* Note head.S in the compressed ROM uses this value for the start of the
+   * kernel! */
+  /* SIM: Not any more it doesn't! */
+  /* . = 0x80000000 + 0x04000000  + 0x1000; */
+  _text = .;			/* Text and read-only data */
+
+  .text : {
+	*(.text)
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x0009
+  . = ALIGN(4);
+  .rodata : { *(.rodata) }
+  . = ALIGN(4);
+  .image : { *(.image) }
+  . = ALIGN(4);
+  _etext = .;			/* End of text section */
+
+  .data :			/* Data */
+	FOLLOWING(.image, 4)
+	{
+	_data = .;
+	*(.data)
+	}
+  _data_image = LOADADDR(.data);/* Address of data section in ROM */
+
+  _edata = .;			/* End of data section */
+
+  .stack : { stack = .;  _stack = .; }
+
+  . = ALIGN(4);
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss)
+	}
+  . = ALIGN(4);
+  _end = . ;
+}
diff -Naur linux-2.6.17.8/arch/sh/boot/compressed/vmlinux.scr linux-2.6.17.8-sh/arch/sh/boot/compressed/vmlinux.scr
--- linux-2.6.17.8/arch/sh/boot/compressed/vmlinux.scr	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/compressed/vmlinux.scr	2006-08-23 13:29:33.453484000 +0100
@@ -1,6 +1,6 @@
 SECTIONS
 {
-  .data : { 
+  .image : {
 	input_len = .;
 	LONG(input_data_end - input_data) input_data = .; 
 	*(.data) 
diff -Naur linux-2.6.17.8/arch/sh/boot/Makefile linux-2.6.17.8-sh/arch/sh/boot/Makefile
--- linux-2.6.17.8/arch/sh/boot/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/boot/Makefile	2006-08-23 13:29:44.442737000 +0100
@@ -8,7 +8,7 @@
 # Copyright (C) 1999 Stuart Menefy
 #
 
-targets := zImage
+targets := zImage uImage
 subdir- := compressed
 
 $(obj)/zImage: $(obj)/compressed/vmlinux FORCE
@@ -18,3 +18,25 @@
 $(obj)/compressed/vmlinux: FORCE
 	$(Q)$(MAKE) $(build)=$(obj)/compressed $@
 
+# Set these to dummy values if not defined to avoid error messages.
+CONFIG_MEMORY_START     ?= 0
+CONFIG_ZERO_PAGE_OFFSET ?= 0
+
+MKIMAGE := $(srctree)/scripts/mkuboot.sh
+ULOADADDR := $(shell printf "0x%8x" $$[0x80000000 + $(CONFIG_MEMORY_START) + $(CONFIG_ZERO_PAGE_OFFSET)])
+UENTRYADDR := $(shell printf "0x%8x" $$[$(ULOADADDR) + 0x1000])
+
+quiet_cmd_uimage = UIMAGE  $@
+      cmd_uimage = $(CONFIG_SHELL) $(MKIMAGE) -A sh -O linux -T kernel \
+		   -C gzip -a $(ULOADADDR) -e $(UENTRYADDR) \
+		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
+
+$(obj)/vmlinux.bin: vmlinux FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
+	$(call if_changed,gzip)
+
+$(obj)/uImage: $(obj)/vmlinux.bin.gz FORCE
+	$(call if_changed,uimage)
+	@echo '  Image $@ is ready'
diff -Naur linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64461/io.c linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64461/io.c
--- linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64461/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64461/io.c	2006-08-23 13:29:24.147261000 +0100
@@ -1,12 +1,12 @@
 /*
- *	$Id: io.c,v 1.6 2004/03/16 00:07:50 lethal Exp $
+ *	$Id: io.c,v 1.8 2006/02/05 21:55:29 lethal Exp $
  *	Copyright (C) 2000 YAEGASHI Takeshi
  *	Typical I/O routines for HD64461 system.
  */
 
 #include <linux/config.h>
 #include <asm/io.h>
-#include <asm/hd64461/hd64461.h>
+#include <asm/hd64461.h>
 
 #define MEM_BASE (CONFIG_HD64461_IOBASE - HD64461_STBCR)
 
@@ -55,11 +55,6 @@
 	return 0xa0000000 + (port & 0x1fffffff);
 }
 
-static inline void delay(void)
-{
-	ctrl_inw(0xa0000000);
-}
-
 unsigned char hd64461_inb(unsigned long port)
 {
 	return *(volatile unsigned char*)PORT2ADDR(port);
@@ -68,7 +63,7 @@
 unsigned char hd64461_inb_p(unsigned long port)
 {
 	unsigned long v = *(volatile unsigned char*)PORT2ADDR(port);
-	delay();
+	ctrl_delay();
 	return v;
 }
 
@@ -90,7 +85,7 @@
 void hd64461_outb_p(unsigned char b, unsigned long port)
 {
 	*(volatile unsigned char*)PORT2ADDR(port) = b;
-	delay();
+	ctrl_delay();
 }
 
 void hd64461_outw(unsigned short b, unsigned long port)
@@ -145,13 +140,13 @@
 	while(count--) *addr=*buf++;
 }
 
-unsigned short hd64461_readw(unsigned long addr)
+unsigned short hd64461_readw(void __iomem *addr)
 {
-	return *(volatile unsigned short*)(MEM_BASE+addr);
+	return ctrl_inw(MEM_BASE+(unsigned long __force)addr);
 }
 
-void hd64461_writew(unsigned short b, unsigned long addr)
+void hd64461_writew(unsigned short b, void __iomem *addr)
 {
-	*(volatile unsigned short*)(MEM_BASE+addr) = b;
+	ctrl_outw(b, MEM_BASE+(unsigned long __force)addr);
 }
 
diff -Naur linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64461/setup.c linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64461/setup.c
--- linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64461/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64461/setup.c	2006-08-23 13:29:17.810116000 +0100
@@ -15,8 +15,7 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-
-#include <asm/hd64461/hd64461.h>
+#include <asm/hd64461.h>
 
 static void disable_hd64461_irq(unsigned int irq)
 {
diff -Naur linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64465/gpio.c linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64465/gpio.c
--- linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64465/gpio.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64465/gpio.c	2006-08-23 13:29:29.444392000 +0100
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/ioport.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/hd64465/gpio.h>
 
diff -Naur linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64465/io.c linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64465/io.c
--- linux-2.6.17.8/arch/sh/cchips/hd6446x/hd64465/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/hd6446x/hd64465/io.c	2006-08-23 13:29:29.483393000 +0100
@@ -175,6 +175,36 @@
 	return b;
 }
 
+void hd64465_insb(unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned char *buf=buffer;
+	volatile unsigned char *addr = (volatile unsigned char*)PORT2ADDR(port);
+	DIPRINTK(0, "insb(%08lx, %08lx)\n", addr, count);
+	if (addr) {
+		while(count--) *buf++=*addr;
+	}
+}
+
+void hd64465_insw(unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned short *buf=buffer;
+	volatile unsigned short *addr = (volatile unsigned short*)PORT2ADDR(port);
+	DIPRINTK(0, "insw(%08lx, %08lx)\n", addr, count);
+	if (addr) {
+		while(count--) *buf++=*addr;
+	}
+}
+
+void hd64465_insl(unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned long *buf=buffer;
+	volatile unsigned long *addr = (volatile unsigned long*)PORT2ADDR(port);
+	DIPRINTK(0, "insl(%08lx, %08lx)\n", addr, count);
+	if (addr) {
+		while(count--) *buf++=*addr;
+	}
+}
+
 void hd64465_outb(unsigned char b, unsigned long port)
 {
 	unsigned long addr = PORT2ADDR(port);
@@ -210,3 +240,32 @@
             *(volatile unsigned long*)addr = b;
 }
 
+void hd64465_outsb(unsigned long port, const void *buffer, unsigned long count)
+{
+	const unsigned char *buf=buffer;
+	volatile unsigned char* addr = (volatile unsigned char*)PORT2ADDR(port);
+	DIPRINTK(0, "outsb(%08lx, %08lx)\n", addr, count);
+	if (addr != 0) {
+		while(count--) *addr = *buf++;
+	}
+}
+
+void hd64465_outsw(unsigned long port, const void *buffer, unsigned long count)
+{
+	const unsigned short *buf=buffer;
+	volatile unsigned short* addr = (volatile unsigned short*)PORT2ADDR(port);
+	DIPRINTK(0, "outsw(%08lx, %08lx)\n", addr, count);
+	if (addr != 0) {
+		while(count--) *addr = *buf++;
+	}
+}
+
+void hd64465_outsl(unsigned long port, const void *buffer, unsigned long count)
+{
+	const unsigned long *buf=buffer;
+	volatile unsigned long *addr = (volatile unsigned long*)PORT2ADDR(port);
+	DIPRINTK(0, "outsl(%08lx, %08lx)\n", addr, count);
+	if (addr != 0) {
+		while(count--) *addr = *buf++;
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/cchips/Kconfig linux-2.6.17.8-sh/arch/sh/cchips/Kconfig
--- linux-2.6.17.8/arch/sh/cchips/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/Kconfig	2006-08-23 13:29:29.386392000 +0100
@@ -40,7 +40,7 @@
 
 config HD64465
 	bool "Hitachi HD64465 companion chip support"
-	depends on CPU_SUBTYPE_SH7750
+	depends on CPU_SUBTYPE_SH7750 || CPU_SUBTYPE_ST40STB1
 	---help---
 	  The Hitachi HD64465 provides an interface for
 	  the SH7750 CPU, supporting a LCD controller,
@@ -65,6 +65,11 @@
 
 	  Do not change this unless you know what you are doing.
 
+config HD64461_IOBASE
+	hex "HD64461 start address"
+	depends on HD64461
+	default "0xb0000000"
+
 config HD64461_ENABLER
 	bool "HD64461 PCMCIA enabler"
 	depends on HD64461
@@ -73,22 +78,31 @@
 	  via the HD64461 companion chip.
 	  Otherwise, say N.
 
-
 config HD64465_IOBASE
 	hex "HD64465 start address"
 	depends on HD64465
+        default "0xa2000000" if SH_STB1_HARP
+	default "0xa5000000" if SH_STB1_OVERDRIVE
 	default "0xb0000000"
 	help
-	  The default setting of the HD64465 IO base address is 0xb0000000.
+	  The default setting of the HD64465 IO base address is 0xb0000000
+	  for SH775x parts.
+	  For STMicroelectronics parts the address varies, but is usually:
+	  - 0xa2000000 ST40STB1 Extended HARP
+	  - 0xa5000000 ST40STB1 Overdrive
 
 	  Do not change this unless you know what you are doing.
 
 config HD64465_IRQ
 	int "HD64465 IRQ"
 	depends on HD64465
+	default "8" if SH_STB1_HARP || SH_STB1_OVERDRIVE
 	default "5"
 	help
-	  The default setting of the HD64465 IRQ is 5.
+	  The default setting of the HD64465 IRQ is 5 for SH775x parts.
+	  For STMicroelectronics parts the IRQ varies, but is usually:
+	  - 8 ST40STB1 Extended HARP
+	  - 8 ST40STB1 Overdrive
 
 	  Do not change this unless you know what you are doing.
 
diff -Naur linux-2.6.17.8/arch/sh/cchips/voyagergx/irq.c linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/irq.c
--- linux-2.6.17.8/arch/sh/cchips/voyagergx/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/irq.c	2006-08-23 13:29:28.021346000 +0100
@@ -33,8 +33,7 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/rts7751r2d/rts7751r2d.h>
-#include <asm/rts7751r2d/voyagergx_reg.h>
+#include <asm/voyagergx.h>
 
 static void disable_voyagergx_irq(unsigned int irq)
 {
diff -Naur linux-2.6.17.8/arch/sh/cchips/voyagergx/Makefile linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/Makefile
--- linux-2.6.17.8/arch/sh/cchips/voyagergx/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/Makefile	2006-08-23 13:29:11.641980000 +0100
@@ -4,5 +4,5 @@
 
 obj-y	:= irq.o setup.o
 
-obj-$(CONFIG_USB_OHCI_HCD)	+= consistent.o
+obj-$(CONFIG_USB_SM501)	+= consistent.o
 
diff -Naur linux-2.6.17.8/arch/sh/cchips/voyagergx/setup.c linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/setup.c
--- linux-2.6.17.8/arch/sh/cchips/voyagergx/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/cchips/voyagergx/setup.c	2006-08-23 13:29:28.031346000 +0100
@@ -13,7 +13,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <asm/io.h>
-#include <asm/rts7751r2d/voyagergx_reg.h>
+#include <asm/voyagergx.h>
 
 static int __init setup_voyagergx(void)
 {
diff -Naur linux-2.6.17.8/arch/sh/configs/adx_defconfig linux-2.6.17.8-sh/arch/sh/configs/adx_defconfig
--- linux-2.6.17.8/arch/sh/configs/adx_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/adx_defconfig	2006-08-23 13:29:15.010047000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:26 2005
+# Linux kernel version: 2.6.13-sh
+# Thu Oct  6 00:20:11 2005
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,6 +16,7 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
@@ -25,22 +26,23 @@
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,9 +59,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -76,46 +76,90 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 CONFIG_CPU_SUBTYPE_SH7750=y
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x08000000
 CONFIG_MEMORY_SIZE=0x00400000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
 CONFIG_CF_ENABLER=y
 # CONFIG_CF_AREA5 is not set
 CONFIG_CF_AREA6=y
 CONFIG_CF_BASE_ADDR=0xb8000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=50000000
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -133,18 +177,29 @@
 # CONFIG_HD6446X_SERIES is not set
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
 
 #
-# PC-card bridges
+# PCCARD (PCMCIA/CardBus) support
 #
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -158,9 +213,9 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET is not set
 
 #
 # Device Drivers
@@ -250,6 +305,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -260,9 +316,8 @@
 #
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -293,18 +348,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -322,6 +365,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -359,13 +412,17 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
+# CONFIG_I2C_SENSOR is not set
 
 #
 # Dallas's 1-wire bus
@@ -373,6 +430,12 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
@@ -393,7 +456,6 @@
 #
 # Console display driver support
 #
-CONFIG_VGA_CONSOLE=y
 CONFIG_DUMMY_CONSOLE=y
 
 #
@@ -408,10 +470,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -424,17 +482,22 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 
 #
 # XFS support
@@ -442,6 +505,7 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
@@ -466,7 +530,6 @@
 CONFIG_PROC_FS=y
 # CONFIG_PROC_KCORE is not set
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
@@ -509,7 +572,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 CONFIG_SH_STANDARD_BIOS=y
 # CONFIG_EARLY_SCIF_CONSOLE is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/cqreek_defconfig linux-2.6.17.8-sh/arch/sh/configs/cqreek_defconfig
--- linux-2.6.17.8/arch/sh/configs/cqreek_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/cqreek_defconfig	2006-08-23 13:29:15.056047000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:38 2005
+# Linux kernel version: 2.6.13-sh
+# Thu Oct  6 00:20:14 2005
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,6 +16,7 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
@@ -25,22 +26,23 @@
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,9 +59,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 CONFIG_SH_CQREEK=y
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -76,41 +76,86 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 CONFIG_CPU_SUBTYPE_SH7708=y
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x00400000
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_DSP=y
 CONFIG_SH_ADC=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=1193182
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -128,18 +173,29 @@
 # CONFIG_HD6446X_SERIES is not set
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
 
 #
-# PC-card bridges
+# PCCARD (PCMCIA/CardBus) support
 #
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -153,9 +209,9 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET is not set
 
 #
 # Device Drivers
@@ -245,6 +301,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -255,9 +312,8 @@
 #
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -288,18 +344,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -317,6 +361,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -354,13 +408,17 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
+# CONFIG_I2C_SENSOR is not set
 
 #
 # Dallas's 1-wire bus
@@ -368,6 +426,12 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
@@ -388,7 +452,6 @@
 #
 # Console display driver support
 #
-CONFIG_VGA_CONSOLE=y
 CONFIG_DUMMY_CONSOLE=y
 
 #
@@ -403,10 +466,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -419,17 +478,22 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 
 #
 # XFS support
@@ -437,6 +501,7 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
@@ -461,7 +526,6 @@
 CONFIG_PROC_FS=y
 # CONFIG_PROC_KCORE is not set
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
@@ -504,7 +568,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 CONFIG_SH_STANDARD_BIOS=y
 # CONFIG_EARLY_PRINTK is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/dreamcast_defconfig linux-2.6.17.8-sh/arch/sh/configs/dreamcast_defconfig
--- linux-2.6.17.8/arch/sh/configs/dreamcast_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/dreamcast_defconfig	2006-08-23 13:29:19.206162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:40 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 14:20:29 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -17,11 +17,13 @@
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -29,22 +31,26 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -58,6 +64,24 @@
 CONFIG_KMOD=y
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -67,9 +91,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -86,48 +108,97 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 CONFIG_CPU_SUBTYPE_SH7750=y
+CONFIG_CPU_SUBTYPE_SH7091=y
+CONFIG_CPU_SUBTYPE_SH7750R=y
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
 CONFIG_HUGETLB_PAGE_SIZE_64K=y
 # CONFIG_HUGETLB_PAGE_SIZE_1MB is not set
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
+
+#
+# Processor features
+#
 CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-CONFIG_SH_OCRAM=y
+CONFIG_SH_FPU=y
 CONFIG_SH_STORE_QUEUES=y
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
 CONFIG_SH_PCLK_FREQ=49876504
 
 #
 # CPU Frequency scaling
 #
 CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
 # CONFIG_CPU_FREQ_DEBUG is not set
 CONFIG_CPU_FREQ_STAT=y
 # CONFIG_CPU_FREQ_STAT_DETAILS is not set
@@ -137,16 +208,13 @@
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 # CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
-CONFIG_CPU_FREQ_TABLE=y
-CONFIG_SH_CPU_FREQ=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_SH_CPU_FREQ is not set
 
 #
 # DMA support
 #
-CONFIG_SH_DMA=y
-CONFIG_NR_ONCHIP_DMA_CHANNELS=4
-CONFIG_NR_DMA_CHANNELS_BOOL=y
-CONFIG_NR_DMA_CHANNELS=9
+# CONFIG_SH_DMA is not set
 
 #
 # Companion Chips
@@ -154,14 +222,28 @@
 # CONFIG_HD6446X_SERIES is not set
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,115200 panic=3"
+
+#
+# Bus options
 #
-CONFIG_MAPLE=y
 CONFIG_PCI=y
 # CONFIG_SH_PCIDMA_NONCOHERENT is not set
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -169,10 +251,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -185,9 +263,72 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -201,6 +342,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -217,7 +363,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -226,21 +371,9 @@
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
-CONFIG_BLK_DEV_RAM=y
+# CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=1024
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -251,6 +384,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -261,6 +395,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -273,70 +408,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
+# Network device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -349,6 +422,11 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -356,6 +434,7 @@
 # CONFIG_STNIC is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_SMC91X is not set
 
@@ -364,6 +443,7 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
@@ -398,13 +478,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -428,6 +512,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -457,19 +543,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -478,17 +551,26 @@
 # CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_MAPLE is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
 # CONFIG_MOUSE_SERIAL is not set
-# CONFIG_MOUSE_MAPLE is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -508,6 +590,7 @@
 CONFIG_SERIAL_SH_SCI_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -547,6 +630,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -557,10 +646,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -574,6 +674,10 @@
 # Graphics support
 #
 CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -583,6 +687,8 @@
 # CONFIG_FB_IMSTT is not set
 CONFIG_FB_PVR2=y
 # CONFIG_FB_EPSON1355 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -595,24 +701,27 @@
 # CONFIG_FB_KYRO is not set
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_CYBLA is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_VIRTUAL is not set
 
 #
 # Console display driver support
 #
-# CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
 CONFIG_FONTS=y
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
 # CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
 # CONFIG_FONT_PEARL_8x8 is not set
 # CONFIG_FONT_ACORN_8x8 is not set
 # CONFIG_FONT_MINI_4x6 is not set
 # CONFIG_FONT_SUN8x16 is not set
 # CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
 
 #
 # Logo configuration
@@ -634,12 +743,12 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -658,6 +767,10 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -665,17 +778,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
-CONFIG_ROMFS_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
+# CONFIG_DNOTIFY is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -696,15 +808,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 CONFIG_HUGETLBFS=y
 CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -716,7 +824,7 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-CONFIG_CRAMFS=y
+# CONFIG_CRAMFS is not set
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
@@ -726,22 +834,14 @@
 #
 # Network File Systems
 #
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFS_FS is not set
 # CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -758,13 +858,14 @@
 # Profiling support
 #
 CONFIG_PROFILING=y
-CONFIG_OPROFILE=y
+# CONFIG_OPROFILE is not set
 
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
-CONFIG_DEBUG_PREEMPT=y
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -789,6 +890,6 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/hp6xx_defconfig linux-2.6.17.8-sh/arch/sh/configs/hp6xx_defconfig
--- linux-2.6.17.8/arch/sh/configs/hp6xx_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/hp6xx_defconfig	2006-08-23 13:29:26.306324000 +0100
@@ -1,11 +1,12 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.15-sh
-# Wed Jan  4 15:32:56 2006
+# Linux kernel version: 2.6.17
+# Thu Jul  6 09:58:22 2006
 #
 CONFIG_SUPERH=y
-CONFIG_UID16=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
@@ -14,8 +15,6 @@
 # Code maturity level options
 #
 CONFIG_EXPERIMENTAL=y
-# CONFIG_CLEAN_COMPILE is not set
-CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 
@@ -28,25 +27,26 @@
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
-CONFIG_HOTPLUG=y
 # CONFIG_IKCONFIG is not set
+# CONFIG_RELAY is not set
 CONFIG_INITRAMFS_SOURCE=""
+CONFIG_UID16=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
+CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_SLAB=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
 
 #
 # Loadable module support
@@ -57,6 +57,8 @@
 # Block layer
 #
 # CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
 
 #
 # IO Schedulers
@@ -96,6 +98,7 @@
 # CONFIG_SH_SECUREEDGE5410 is not set
 # CONFIG_SH_HS7751RVOIP is not set
 # CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_R7780RP is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
 # CONFIG_SH_LANDISK is not set
@@ -175,12 +178,14 @@
 CONFIG_SH_RTC=y
 # CONFIG_SH_DSP is not set
 CONFIG_SH_ADC=y
+CONFIG_CPU_HAS_INTEVT=y
+CONFIG_CPU_HAS_PINT_IRQ=y
+CONFIG_CPU_HAS_SR_RB=y
 
 #
 # Timer support
 #
 CONFIG_SH_TMU=y
-CONFIG_SH_PCLK_FREQ_BOOL=y
 CONFIG_SH_PCLK_FREQ=22110000
 
 #
@@ -194,7 +199,6 @@
 CONFIG_SH_DMA=y
 CONFIG_NR_ONCHIP_DMA_CHANNELS=4
 # CONFIG_NR_DMA_CHANNELS_BOOL is not set
-# CONFIG_DMA_PAGE_OPS is not set
 
 #
 # Companion Chips
@@ -257,6 +261,14 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
+# Power management options (EXPERIMENTAL)
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_APM=y
+
+#
 # Networking
 #
 # CONFIG_NET is not set
@@ -315,7 +327,7 @@
 # CONFIG_BLK_DEV_IDE_SATA is not set
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDECS is not set
+CONFIG_BLK_DEV_IDECS=y
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -356,19 +368,12 @@
 #
 # IEEE 1394 (FireWire) support
 #
-# CONFIG_IEEE1394 is not set
 
 #
 # I2O device support
 #
 
 #
-# Network device support
-#
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-
-#
 # ISDN subsystem
 #
 
@@ -390,17 +395,31 @@
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=240
+CONFIG_INPUT_TSDEV_SCREEN_Y=320
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
 #
 # Input Device Drivers
 #
-# CONFIG_INPUT_KEYBOARD is not set
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_HP620 is not set
+CONFIG_KEYBOARD_HP680=y
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_HP600=y
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -471,6 +490,12 @@
 # CONFIG_I2C is not set
 
 #
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
 # Dallas's 1-wire bus
 #
 # CONFIG_W1 is not set
@@ -480,6 +505,7 @@
 #
 CONFIG_HWMON=y
 # CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_F71805F is not set
 # CONFIG_HWMON_DEBUG_CHIP is not set
 
 #
@@ -487,13 +513,10 @@
 #
 
 #
-# Multimedia Capabilities Port drivers
-#
-
-#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_V4L2=y
 
 #
 # Digital Video Broadcasting Devices
@@ -507,6 +530,7 @@
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_MACMODES is not set
+CONFIG_FB_FIRMWARE_EDID=y
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_EPSON1355 is not set
@@ -553,7 +577,6 @@
 # Open Sound System
 #
 CONFIG_SOUND_PRIME=y
-# CONFIG_OBSOLETE_OSS_DRIVER is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
 CONFIG_SOUND_SH_DAC_AUDIO=y
@@ -564,6 +587,7 @@
 #
 # CONFIG_USB_ARCH_HAS_HCD is not set
 # CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
@@ -580,13 +604,30 @@
 # CONFIG_MMC is not set
 
 #
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
 
 #
-# SN Devices
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
 #
+# CONFIG_RTC_CLASS is not set
 
 #
 # File systems
@@ -595,7 +636,6 @@
 # CONFIG_EXT2_FS_XATTR is not set
 # CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
@@ -635,7 +675,7 @@
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
-# CONFIG_RELAYFS_FS is not set
+# CONFIG_CONFIGFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -713,9 +753,11 @@
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_DEBUG_KERNEL is not set
 CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_FRAME_POINTER is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_UNWIND_INFO is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_KGDB is not set
 
diff -Naur linux-2.6.17.8/arch/sh/configs/hs7751rvoip_defconfig linux-2.6.17.8-sh/arch/sh/configs/hs7751rvoip_defconfig
--- linux-2.6.17.8/arch/sh/configs/hs7751rvoip_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/hs7751rvoip_defconfig	2006-08-23 13:29:19.228162000 +0100
@@ -0,0 +1,884 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 17:02:02 2006
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP6XX is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+CONFIG_SH_HS7751RVOIP=y
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
+# CONFIG_SH_UNKNOWN is not set
+
+#
+# Processor selection
+#
+CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
+CONFIG_MMU=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x04000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+# CONFIG_SH_STORE_QUEUES is not set
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+
+#
+# HS7751RVoIP options
+#
+CONFIG_HS7751RVOIP_CODEC=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="mem=64M console=ttySC1,115200 root=/dev/hda1"
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_LEGACY_PROC=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=1
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_IDEDMA_PCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/landisk_defconfig linux-2.6.17.8-sh/arch/sh/configs/landisk_defconfig
--- linux-2.6.17.8/arch/sh/configs/landisk_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/landisk_defconfig	2006-08-23 13:29:16.921094000 +0100
@@ -0,0 +1,1372 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-sh
+# Sun Dec 18 01:38:13 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP6XX is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+CONFIG_SH_LANDISK=y
+# CONFIG_SH_TITAN is not set
+# CONFIG_SH_UNKNOWN is not set
+
+#
+# Processor selection
+#
+CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
+CONFIG_MMU=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x04000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SH_FPU=y
+# CONFIG_SH_STORE_QUEUES is not set
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
+CONFIG_SH_PCLK_FREQ=33333333
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+CONFIG_SH_DMA=y
+CONFIG_NR_ONCHIP_DMA_CHANNELS=4
+# CONFIG_NR_DMA_CHANNELS_BOOL is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Kernel features
+#
+CONFIG_KEXEC=y
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_ISA=y
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_LEGACY_PROC=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=y
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_PROBE=y
+CONFIG_PCCARD_NONSTATIC=y
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_NETLINK is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_CT_ACCT=y
+CONFIG_IP_NF_CONNTRACK_MARK=y
+# CONFIG_IP_NF_CONNTRACK_EVENTS is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+# CONFIG_IP_NF_PPTP is not set
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_REALM=m
+CONFIG_IP_NF_MATCH_SCTP=m
+# CONFIG_IP_NF_MATCH_DCCP is not set
+CONFIG_IP_NF_MATCH_COMMENT=m
+CONFIG_IP_NF_MATCH_CONNMARK=m
+# CONFIG_IP_NF_MATCH_CONNBYTES is not set
+CONFIG_IP_NF_MATCH_HASHLIMIT=m
+# CONFIG_IP_NF_MATCH_STRING is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+# CONFIG_IP_NF_TARGET_NFQUEUE is not set
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_CLASSIFY=m
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_TARGET_CONNMARK=m
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_TARGET_NOTRACK=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+CONFIG_ATALK=m
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+CONFIG_BLK_DEV_IDESCSI=y
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_BLK_DEV_OFFBOARD=y
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_IDEDMA_ONLYDISK=y
+CONFIG_BLK_DEV_AEC62XX=y
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_RAID6 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BLK_DEV_DM is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NE2000 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+CONFIG_8139CP=y
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+CONFIG_RS5C313_RTC=y
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=m
+
+#
+# Video For Linux
+#
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_DPC is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FONT_8x16=y
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=m
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_OBSOLETE_OSS_USB_DRIVER=y
+CONFIG_USB_AUDIO=m
+# CONFIG_USB_BLUETOOTH_TTY is not set
+CONFIG_USB_MIDI=m
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+CONFIG_USB_DABUSB=m
+CONFIG_USB_VICAM=m
+CONFIG_USB_DSBR=m
+CONFIG_USB_IBMCAM=m
+CONFIG_USB_KONICAWC=m
+CONFIG_USB_OV511=m
+CONFIG_USB_SE401=m
+CONFIG_USB_SN9C102=m
+CONFIG_USB_STV680=m
+CONFIG_USB_PWC=m
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=y
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+CONFIG_UFS_FS=m
+CONFIG_UFS_FS_WRITE=y
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_FRAME_POINTER is not set
+CONFIG_SH_STANDARD_BIOS=y
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/mediax_defconfig linux-2.6.17.8-sh/arch/sh/configs/mediax_defconfig
--- linux-2.6.17.8/arch/sh/configs/mediax_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/mediax_defconfig	2006-08-23 13:29:34.494507000 +0100
@@ -0,0 +1,629 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Tue Oct 19 21:50:58 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+CONFIG_SH_MEDIAX_DEMO=y
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_CPU_SUBTYPE_ST40GX1=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x07000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_SH_MEDIAREF=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/r7780rp_defconfig linux-2.6.17.8-sh/arch/sh/configs/r7780rp_defconfig
--- linux-2.6.17.8/arch/sh/configs/r7780rp_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/r7780rp_defconfig	2006-08-23 13:29:19.778162000 +0100
@@ -0,0 +1,1099 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15-sh
+# Sat Jan  7 19:47:53 2006
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP6XX is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_R77703DRP is not set
+CONFIG_SH_R7780RP=y
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
+# CONFIG_SH_UNKNOWN is not set
+
+#
+# Processor selection
+#
+CONFIG_CPU_SH4=y
+CONFIG_CPU_SH4A=y
+
+#
+# SH-2 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+CONFIG_CPU_SUBTYPE_SH7780=y
+
+#
+# Memory management options
+#
+CONFIG_MMU=y
+CONFIG_32BIT=y
+CONFIG_HUGETLB_PAGE_SIZE_64K=y
+# CONFIG_HUGETLB_PAGE_SIZE_1MB is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x08000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SH_FPU=y
+CONFIG_SH_STORE_QUEUES=y
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
+CONFIG_SH_PCLK_FREQ=32000000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+CONFIG_SH_DMA=y
+CONFIG_NR_ONCHIP_DMA_CHANNELS=6
+# CONFIG_NR_DMA_CHANNELS_BOOL is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
+CONFIG_CPU_HAS_INTEVT=y
+CONFIG_CPU_HAS_INTC2_IRQ=y
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="mem=128M console=ttySC0,115200 root=/dev/hda1"
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_LEGACY_PROC=y
+# CONFIG_PCI_DEBUG is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=m
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDE_SATA=y
+CONFIG_BLK_DEV_IDEDISK=m
+CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+CONFIG_BLK_DEV_IDESCSI=m
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=m
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+CONFIG_BLK_DEV_AEC62XX=m
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+CONFIG_BLK_DEV_PDC202XX_NEW=m
+# CONFIG_PDC202XX_FORCE is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+CONFIG_BLK_DEV_SIIMAGE=m
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=m
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NE2000=y
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=m
+# CONFIG_E1000_NAPI is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_R8169_NAPI is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+CONFIG_HERMES=m
+# CONFIG_PLX_HERMES is not set
+# CONFIG_TMD_HERMES is not set
+# CONFIG_NORTEL_HERMES is not set
+# CONFIG_PCI_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+#
+CONFIG_PRISM54=m
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=m
+# CONFIG_OBSOLETE_OSS_DRIVER is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_VM is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/rts7751r2d_defconfig linux-2.6.17.8-sh/arch/sh/configs/rts7751r2d_defconfig
--- linux-2.6.17.8/arch/sh/configs/rts7751r2d_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/rts7751r2d_defconfig	2006-08-23 13:29:19.237162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:42 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 19:00:01 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,33 +16,39 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -55,6 +61,24 @@
 # CONFIG_KMOD is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -64,9 +88,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -83,44 +105,94 @@
 CONFIG_SH_RTS7751R2D=y
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="mem=64M console=ttySC0,115200 root=/dev/hda1"
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x04000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00010000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+
+#
+# RTS7751R2D options
+#
 CONFIG_RTS7751R2D_REV11=y
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=60000000
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -140,17 +212,31 @@
 CONFIG_VOYAGERGX=y
 # CONFIG_HD6446X_SERIES is not set
 CONFIG_HEARTBEAT=y
-CONFIG_RTC_9701JE=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00010000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="mem=64M console=ttySC0,115200 root=/dev/hda1"
+
+#
+# Bus options
 #
 CONFIG_PCI=y
 CONFIG_SH_PCIDMA_NONCOHERENT=y
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
 # CONFIG_PCI_LEGACY_PROC is not set
-CONFIG_PCI_NAMES=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -158,10 +244,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 CONFIG_HOTPLUG_PCI=y
@@ -177,6 +259,74 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
 # Device Drivers
 #
 
@@ -188,6 +338,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -204,7 +359,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -217,17 +371,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 # CONFIG_BLK_DEV_INITRD is not set
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -262,6 +406,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -272,6 +417,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -284,67 +430,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
+# Network device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -357,6 +444,11 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -364,6 +456,7 @@
 # CONFIG_STNIC is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_SMC91X is not set
 
@@ -372,6 +465,7 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
@@ -406,13 +500,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -437,6 +535,7 @@
 CONFIG_HERMES=m
 # CONFIG_PLX_HERMES is not set
 # CONFIG_TMD_HERMES is not set
+# CONFIG_NORTEL_HERMES is not set
 # CONFIG_PCI_HERMES is not set
 # CONFIG_ATMEL is not set
 
@@ -444,6 +543,7 @@
 # Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
 #
 # CONFIG_PRISM54 is not set
+# CONFIG_HOSTAP is not set
 CONFIG_NET_WIRELESS=y
 
 #
@@ -456,6 +556,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -473,20 +575,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -503,6 +595,7 @@
 # Non-8250 serial port support
 #
 # CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_JSM is not set
 # CONFIG_UNIX98_PTYS is not set
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -517,6 +610,7 @@
 #
 # CONFIG_WATCHDOG is not set
 # CONFIG_RTC is not set
+CONFIG_RTC_9701JE=y
 # CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
@@ -529,6 +623,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -539,10 +639,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -566,6 +677,8 @@
 # Advanced Linux Sound Architecture
 #
 CONFIG_SND=m
+CONFIG_SND_AC97_CODEC=m
+CONFIG_SND_AC97_BUS=m
 CONFIG_SND_TIMER=m
 CONFIG_SND_PCM=m
 CONFIG_SND_HWDEP=m
@@ -589,7 +702,6 @@
 #
 # PCI devices
 #
-CONFIG_SND_AC97_CODEC=m
 # CONFIG_SND_ALI5451 is not set
 # CONFIG_SND_ATIIXP is not set
 # CONFIG_SND_ATIIXP_MODEM is not set
@@ -610,9 +722,10 @@
 # CONFIG_SND_RME96 is not set
 # CONFIG_SND_RME9652 is not set
 # CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
 # CONFIG_SND_TRIDENT is not set
 CONFIG_SND_YMFPCI=m
-# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_AD1889 is not set
 # CONFIG_SND_CMIPCI is not set
 # CONFIG_SND_ENS1370 is not set
 # CONFIG_SND_ENS1371 is not set
@@ -628,43 +741,29 @@
 # CONFIG_SND_VIA82XX is not set
 # CONFIG_SND_VIA82XX_MODEM is not set
 # CONFIG_SND_VX222 is not set
+# CONFIG_SND_HDA_INTEL is not set
 
 #
 # Open Sound System
 #
 CONFIG_SOUND_PRIME=m
-# CONFIG_SOUND_BT878 is not set
-CONFIG_SOUND_CMPCI=m
-# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_OBSOLETE_OSS_DRIVER is not set
 # CONFIG_SOUND_FUSION is not set
-# CONFIG_SOUND_CS4281 is not set
-# CONFIG_SOUND_ES1370 is not set
-# CONFIG_SOUND_ES1371 is not set
-# CONFIG_SOUND_ESSSOLO1 is not set
-# CONFIG_SOUND_MAESTRO is not set
-# CONFIG_SOUND_MAESTRO3 is not set
 # CONFIG_SOUND_ICH is not set
-# CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_VIA82CXXX is not set
-# CONFIG_SOUND_OSS is not set
-# CONFIG_SOUND_ALI5455 is not set
-# CONFIG_SOUND_FORTE is not set
-# CONFIG_SOUND_RME96XX is not set
-# CONFIG_SOUND_AD1980 is not set
 CONFIG_SOUND_VOYAGERGX=m
 
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -683,25 +782,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 CONFIG_MINIX_FS=y
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -725,11 +828,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -758,6 +861,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -818,7 +922,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -843,5 +949,6 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/se7300_defconfig linux-2.6.17.8-sh/arch/sh/configs/se7300_defconfig
--- linux-2.6.17.8/arch/sh/configs/se7300_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/se7300_defconfig	2006-08-23 13:29:19.246162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:43 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 19:07:24 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,30 +16,35 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 # CONFIG_SWAP is not set
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 # CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 # CONFIG_FUTEX is not set
 # CONFIG_EPOLL is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -47,6 +52,24 @@
 # CONFIG_MODULES is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -56,9 +79,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -75,40 +96,88 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 CONFIG_CPU_SUBTYPE_SH7300=y
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC0,38400 root=/dev/ram0"
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x04000000
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_DSP=y
 # CONFIG_SH_ADC is not set
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00210000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SMP is not set
-# CONFIG_SH_PCLK_CALC is not set
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
 CONFIG_SH_PCLK_FREQ=33333333
 
 #
@@ -128,18 +197,30 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00210000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC0,38400 root=/dev/ram0"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
 
 #
-# PC-card bridges
+# PCCARD (PCMCIA/CardBus) support
 #
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -153,10 +234,9 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-CONFIG_EMBEDDED_RAMDISK=y
-CONFIG_EMBEDDED_RAMDISK_IMAGE="ramdisk.gz"
+# CONFIG_NET is not set
 
 #
 # Device Drivers
@@ -170,6 +250,10 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -186,26 +270,15 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
 
 #
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_AS is not set
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-
-#
 # ATA/ATAPI/MFM/RLL support
 #
 # CONFIG_IDE is not set
@@ -213,6 +286,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -223,6 +297,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -233,9 +308,8 @@
 #
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -266,18 +340,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -287,6 +349,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -336,10 +408,15 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -350,10 +427,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -379,7 +467,7 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -395,28 +483,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -437,13 +528,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -481,7 +570,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 CONFIG_SH_STANDARD_BIOS=y
 CONFIG_EARLY_PRINTK=y
@@ -527,5 +618,6 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/se73180_defconfig linux-2.6.17.8-sh/arch/sh/configs/se73180_defconfig
--- linux-2.6.17.8/arch/sh/configs/se73180_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/se73180_defconfig	2006-08-23 13:29:20.703186000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:44 2005
+# Linux kernel version: 2.6.15-sh
+# Sun Jan  8 13:54:18 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,30 +16,35 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 # CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 # CONFIG_FUTEX is not set
 # CONFIG_EPOLL is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -52,6 +57,24 @@
 # CONFIG_KMOD is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -61,9 +84,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -78,42 +99,95 @@
 # CONFIG_SH_SECUREEDGE5410 is not set
 # CONFIG_SH_HS7751RVOIP is not set
 # CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_R7780RP is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+CONFIG_CPU_SH4A=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-CONFIG_CPU_SUBTYPE_SH73180=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+CONFIG_CPU_SUBTYPE_SH73180=y
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC0,38400 root=/dev/ram"
+CONFIG_32BIT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x02000000
-# CONFIG_MEMORY_OVERRIDE is not set
-# CONFIG_SH_FPU is not set
-CONFIG_ZERO_PAGE_OFFSET=0x00010000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
+
+#
+# Processor features
+#
 CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_FPU is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-# CONFIG_SH_PCLK_CALC is not set
+CONFIG_CPU_HAS_INTEVT=y
+CONFIG_CPU_HAS_SR_RB=y
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
 CONFIG_SH_PCLK_FREQ=27000000
 
 #
@@ -133,18 +207,30 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00010000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC0,38400 root=/dev/ram"
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
 
 #
-# PC-card bridges
+# PCCARD (PCMCIA/CardBus) support
 #
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -158,10 +244,9 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-CONFIG_EMBEDDED_RAMDISK=y
-CONFIG_EMBEDDED_RAMDISK_IMAGE="ramdisk.gz"
+# CONFIG_NET is not set
 
 #
 # Device Drivers
@@ -175,6 +260,10 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -191,7 +280,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
@@ -199,19 +287,9 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
 
 #
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_AS is not set
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-
-#
 # ATA/ATAPI/MFM/RLL support
 #
 # CONFIG_IDE is not set
@@ -219,6 +297,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -229,6 +308,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -239,9 +319,8 @@
 #
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -260,20 +339,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -320,10 +389,15 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -334,10 +408,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -363,7 +448,7 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -379,28 +464,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -421,14 +509,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_SYSFS is not set
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -466,7 +551,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 CONFIG_SH_STANDARD_BIOS=y
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -477,7 +564,6 @@
 # Security options
 #
 # CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
@@ -492,5 +578,6 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/se7705_defconfig linux-2.6.17.8-sh/arch/sh/configs/se7705_defconfig
--- linux-2.6.17.8/arch/sh/configs/se7705_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/se7705_defconfig	2006-08-23 13:29:19.264162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:45 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 19:35:13 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -17,32 +17,38 @@
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 # CONFIG_SWAP is not set
 # CONFIG_SYSVIPC is not set
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 # CONFIG_KALLSYMS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -55,6 +61,24 @@
 CONFIG_KMOD=y
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 CONFIG_SH_SOLUTION_ENGINE=y
@@ -64,9 +88,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -83,44 +105,91 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 CONFIG_CPU_SUBTYPE_SH7705=y
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
-CONFIG_SH7705_CACHE_32KB=y
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+CONFIG_SH7705_CACHE_32KB=y
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
 # CONFIG_CF_ENABLER is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 # CONFIG_SH_DSP is not set
 # CONFIG_SH_ADC is not set
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=33333333
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -139,18 +208,29 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_PCI is not set
 
 #
-# PC-card bridges
+# PCCARD (PCMCIA/CardBus) support
 #
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -164,9 +244,75 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -180,12 +326,17 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -197,6 +348,7 @@
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -231,8 +383,7 @@
 # CONFIG_MTD_PHYSMAP is not set
 CONFIG_MTD_SOLUTIONENGINE=y
 CONFIG_MTD_SUPERH_RESERVE=0x300000
-# CONFIG_MTD_MPC1211 is not set
-# CONFIG_MTD_RTS7751R2D is not set
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -256,6 +407,11 @@
 # CONFIG_MTD_NAND is not set
 
 #
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
 # Parallel port support
 #
 # CONFIG_PARPORT is not set
@@ -267,7 +423,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
@@ -275,17 +430,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -296,6 +441,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -306,6 +452,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -316,70 +463,8 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -387,12 +472,18 @@
 # CONFIG_TUN is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 CONFIG_STNIC=y
 # CONFIG_SMC91X is not set
+# CONFIG_NE2000 is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -422,10 +513,13 @@
 # CONFIG_PPP_SYNC_TTY is not set
 CONFIG_PPP_DEFLATE=y
 # CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
 # CONFIG_PPPOE is not set
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -452,18 +546,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -473,6 +555,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -510,10 +602,15 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -524,10 +621,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -554,7 +662,7 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -570,28 +678,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -612,12 +723,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_SYSFS is not set
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -632,8 +742,8 @@
 # CONFIG_JFFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_NAND is not set
-# CONFIG_JFFS2_FS_NOR_ECC is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
 CONFIG_JFFS2_ZLIB=y
 CONFIG_JFFS2_RTIME=y
@@ -655,6 +765,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -663,6 +774,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -683,8 +795,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
-CONFIG_DEBUG_PREEMPT=y
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_KGDB is not set
@@ -693,7 +806,6 @@
 # Security options
 #
 # CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
@@ -708,6 +820,7 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/se7750_defconfig linux-2.6.17.8-sh/arch/sh/configs/se7750_defconfig
--- linux-2.6.17.8/arch/sh/configs/se7750_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/se7750_defconfig	2006-08-23 13:29:19.273162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:46 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 19:57:15 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,11 +16,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -28,23 +30,27 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,6 +63,24 @@
 CONFIG_KMOD=y
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 CONFIG_SH_SOLUTION_ENGINE=y
@@ -66,9 +90,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -85,47 +107,93 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 CONFIG_CPU_SUBTYPE_SH7750=y
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 # CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC1,38400 root=/dev/nfs ip=bootp"
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
 CONFIG_CF_ENABLER=y
 # CONFIG_CF_AREA5 is not set
 CONFIG_CF_AREA6=y
 CONFIG_CF_BASE_ADDR=0xb8000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=49876504
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -144,18 +212,30 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
 #
-# CONFIG_PCI is not set
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
 
 #
-# PCCARD (PCMCIA/CardBus) support
+# Boot options
 #
-# CONFIG_PCCARD is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,38400 root=/dev/nfs ip=bootp"
 
 #
-# PC-card bridges
+# Bus options
 #
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -169,6 +249,78 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
 # Device Drivers
 #
 
@@ -180,12 +332,17 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -197,6 +354,7 @@
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -231,8 +389,7 @@
 # CONFIG_MTD_PHYSMAP is not set
 CONFIG_MTD_SOLUTIONENGINE=y
 CONFIG_MTD_SUPERH_RESERVE=0x00010000
-# CONFIG_MTD_MPC1211 is not set
-# CONFIG_MTD_RTS7751R2D is not set
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -256,6 +413,11 @@
 # CONFIG_MTD_NAND is not set
 
 #
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
 # Parallel port support
 #
 # CONFIG_PARPORT is not set
@@ -267,23 +429,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -294,6 +445,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -304,6 +456,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -314,71 +467,8 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
+# Network device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -386,12 +476,18 @@
 # CONFIG_TUN is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 CONFIG_STNIC=y
 # CONFIG_SMC91X is not set
+# CONFIG_NE2000 is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -418,6 +514,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -435,20 +533,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -499,10 +587,15 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -513,10 +606,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -543,7 +647,7 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -559,7 +663,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -569,17 +676,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -600,13 +706,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -621,8 +725,8 @@
 # CONFIG_JFFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_NAND is not set
-# CONFIG_JFFS2_FS_NOR_ECC is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
 CONFIG_JFFS2_ZLIB=y
 CONFIG_JFFS2_RTIME=y
@@ -644,6 +748,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -652,6 +757,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -682,7 +788,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -707,6 +815,7 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/se7751_defconfig linux-2.6.17.8-sh/arch/sh/configs/se7751_defconfig
--- linux-2.6.17.8/arch/sh/configs/se7751_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/se7751_defconfig	2006-08-23 13:29:19.283162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:48 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 20:02:38 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,11 +16,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -28,22 +30,26 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,6 +62,24 @@
 # CONFIG_KMOD is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -65,9 +89,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -84,43 +106,89 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 CONFIG_CPU_SUBTYPE_SH7751=y
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC1,38400"
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x04000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00010000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=60013568
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -139,14 +207,29 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00010000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,38400"
+
+#
+# Bus options
 #
 CONFIG_PCI=y
 # CONFIG_SH_PCIDMA_NONCOHERENT is not set
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
 # CONFIG_PCI_LEGACY_PROC is not set
-# CONFIG_PCI_NAMES is not set
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -154,10 +237,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -170,9 +249,96 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_DEBUG=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NF_CONNTRACK is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+CONFIG_IP_NF_QUEUE=y
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -186,12 +352,17 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -203,6 +374,7 @@
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -236,8 +408,7 @@
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
 # CONFIG_MTD_SOLUTIONENGINE is not set
-# CONFIG_MTD_MPC1211 is not set
-# CONFIG_MTD_RTS7751R2D is not set
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -262,6 +433,11 @@
 # CONFIG_MTD_NAND is not set
 
 #
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
 # Parallel port support
 #
 # CONFIG_PARPORT is not set
@@ -273,7 +449,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -286,17 +461,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -307,6 +472,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -317,6 +483,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -329,92 +496,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-CONFIG_NETFILTER_DEBUG=y
-
+# Network device support
 #
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-# CONFIG_IP_NF_CONNTRACK_MARK is not set
-CONFIG_IP_NF_QUEUE=y
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -422,6 +510,11 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -429,6 +522,7 @@
 # CONFIG_STNIC is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_SMC91X is not set
 
@@ -437,6 +531,7 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
 CONFIG_NET_PCI=y
 CONFIG_PCNET32=y
 # CONFIG_AMD8111_ETH is not set
@@ -467,13 +562,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -497,6 +596,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -514,20 +615,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
+# Hardware I/O ports
 #
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -544,6 +635,7 @@
 # Non-8250 serial port support
 #
 # CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -583,6 +675,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -593,10 +691,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -619,12 +728,12 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -643,25 +752,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -682,13 +795,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -703,8 +814,8 @@
 # CONFIG_JFFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_NAND is not set
-# CONFIG_JFFS2_FS_NOR_ECC is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
 CONFIG_JFFS2_ZLIB=y
 CONFIG_JFFS2_RTIME=y
@@ -726,6 +837,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -746,7 +858,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -771,6 +885,7 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/sh03_defconfig linux-2.6.17.8-sh/arch/sh/configs/sh03_defconfig
--- linux-2.6.17.8/arch/sh/configs/sh03_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/sh03_defconfig	2006-08-23 13:29:19.293162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:49 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 20:14:31 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -18,11 +18,13 @@
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -30,22 +32,26 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -59,6 +65,24 @@
 CONFIG_KMOD=y
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -68,9 +92,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -87,47 +109,93 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 CONFIG_CPU_SUBTYPE_SH7751=y
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC1,115200 mem=64M root=/dev/nfs"
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x08000000
 CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
 CONFIG_CF_ENABLER=y
 CONFIG_CF_AREA5=y
 # CONFIG_CF_AREA6 is not set
 CONFIG_CF_BASE_ADDR=0xb4000000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00004000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=49876504
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -146,14 +214,29 @@
 CONFIG_HEARTBEAT=y
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00004000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,115200 mem=64M root=/dev/nfs"
+
+#
+# Bus options
 #
 CONFIG_PCI=y
 CONFIG_SH_PCIDMA_NONCOHERENT=y
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -161,10 +244,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 CONFIG_HOTPLUG_PCI=m
@@ -180,9 +259,78 @@
 CONFIG_BINFMT_MISC=y
 
 #
-# SH initrd options
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -196,6 +344,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -212,7 +365,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -226,17 +378,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -272,6 +414,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=m
 CONFIG_SCSI_PROC_FS=y
 
@@ -284,6 +427,7 @@
 CONFIG_BLK_DEV_SR=m
 CONFIG_BLK_DEV_SR_VENDOR=y
 CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -298,10 +442,12 @@
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
 
 #
 # SCSI low-level drivers
 #
+# CONFIG_ISCSI_TCP is not set
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
 # CONFIG_SCSI_3W_9XXX is not set
 # CONFIG_SCSI_ACARD is not set
@@ -313,22 +459,16 @@
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
 # CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_PCI2000 is not set
-# CONFIG_SCSI_PCI2220I is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=m
@@ -337,6 +477,8 @@
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
@@ -351,6 +493,9 @@
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -363,73 +508,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -442,6 +522,11 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -449,6 +534,7 @@
 # CONFIG_STNIC is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_SMC91X is not set
 
@@ -457,6 +543,7 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
@@ -487,13 +574,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -518,6 +609,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -547,14 +640,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -564,6 +649,12 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -585,6 +676,7 @@
 CONFIG_SERIAL_SH_SCI_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -625,6 +717,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -635,10 +733,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -656,7 +765,6 @@
 #
 # Console display driver support
 #
-# CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 
 #
@@ -667,12 +775,12 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -691,12 +799,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 # CONFIG_EXT2_FS_POSIX_ACL is not set
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -707,17 +820,15 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
-
-#
-# XFS support
-#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -745,13 +856,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -775,16 +884,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 CONFIG_NFS_V4=y
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 CONFIG_NFSD_TCP=y
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 CONFIG_SUNRPC_GSS=y
 CONFIG_RPCSEC_GSS_KRB5=y
@@ -794,6 +906,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -868,8 +981,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
-CONFIG_DEBUG_PREEMPT=y
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 CONFIG_SH_STANDARD_BIOS=y
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -894,6 +1008,7 @@
 # CONFIG_CRYPTO_SHA256 is not set
 # CONFIG_CRYPTO_SHA512 is not set
 # CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
 CONFIG_CRYPTO_DES=y
 # CONFIG_CRYPTO_BLOWFISH is not set
 # CONFIG_CRYPTO_TWOFISH is not set
@@ -918,6 +1033,7 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/snapgear_defconfig linux-2.6.17.8-sh/arch/sh/configs/snapgear_defconfig
--- linux-2.6.17.8/arch/sh/configs/snapgear_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/snapgear_defconfig	2006-08-23 13:29:19.302162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:51 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 20:30:46 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -16,33 +16,39 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 # CONFIG_SYSVIPC is not set
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,6 +56,24 @@
 # CONFIG_MODULES is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -59,9 +83,7 @@
 # CONFIG_SH_7751_SYSTEMH is not set
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -78,42 +100,89 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x08000000
 CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=60013568
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -133,14 +202,28 @@
 # CONFIG_HD6446X_SERIES is not set
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
 #
 CONFIG_PCI=y
 # CONFIG_SH_PCIDMA_NONCOHERENT is not set
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
 # CONFIG_PCI_LEGACY_PROC is not set
-CONFIG_PCI_NAMES=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -148,10 +231,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -164,9 +243,74 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_UNIX is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
 
 #
 # Device Drivers
@@ -180,6 +324,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -196,7 +345,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -209,17 +357,7 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
 # CONFIG_ATA_OVER_ETH is not set
 
 #
@@ -230,6 +368,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -240,6 +379,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -252,69 +392,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-# CONFIG_NETLINK_DEV is not set
-# CONFIG_UNIX is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
+# Network device support
 #
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -327,6 +406,11 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -334,6 +418,7 @@
 # CONFIG_STNIC is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 # CONFIG_SMC91X is not set
 
@@ -342,6 +427,7 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
@@ -376,13 +462,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -406,6 +496,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -435,18 +527,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -456,6 +536,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -472,6 +562,7 @@
 # Non-8250 serial port support
 #
 # CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -498,6 +589,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -508,10 +605,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -529,7 +637,6 @@
 #
 # Console display driver support
 #
-CONFIG_VGA_CONSOLE=y
 CONFIG_DUMMY_CONSOLE=y
 
 #
@@ -540,12 +647,12 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -564,25 +671,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -603,15 +714,11 @@
 CONFIG_PROC_FS=y
 # CONFIG_PROC_KCORE is not set
 CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -635,12 +742,14 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -649,6 +758,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -669,7 +779,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -694,6 +806,7 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/st220eval_defconfig linux-2.6.17.8-sh/arch/sh/configs/st220eval_defconfig
--- linux-2.6.17.8/arch/sh/configs/st220eval_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/st220eval_defconfig	2006-08-23 13:29:43.767714000 +0100
@@ -0,0 +1,1057 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Tue Aug  9 12:26:57 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+# CONFIG_SH_STI5528_ESPRESSO is not set
+# CONFIG_SH_STM8000_DEMO is not set
+CONFIG_SH_ST220_EVAL=y
+# CONFIG_SH_STB7100_MBOARD is not set
+# CONFIG_SH_STB7100_REF is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STI5528 is not set
+CONFIG_CPU_SUBTYPE_STM8000=y
+# CONFIG_CPU_SUBTYPE_STB7100 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+CONFIG_BLK_DEV_IDEDMA_STHDDI=y
+CONFIG_BLK_DEV_IDEDMA_ST40=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+CONFIG_LIRC_SUPPORT=y
+CONFIG_LIRC_MAX_DEV=2
+# CONFIG_LIRC_BT829 is not set
+# CONFIG_LIRC_IT87 is not set
+# CONFIG_LIRC_ATIUSB is not set
+# CONFIG_LIRC_MCEUSB is not set
+# CONFIG_LIRC_SIR is not set
+CONFIG_ST_LIRC=y
+CONFIG_IRB_RECEIVER=y
+# CONFIG_UHF_RECEIVER is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ST PCM-ALSA driver
+#
+CONFIG_SND_STM8000=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+# CONFIG_STM_DMA is not set
+# CONFIG_STB7100_FDMA is not set
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+CONFIG_STM_COPROCESSOR=y
+# CONFIG_COPROCESSOR_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/st40gx1eval_defconfig linux-2.6.17.8-sh/arch/sh/configs/st40gx1eval_defconfig
--- linux-2.6.17.8/arch/sh/configs/st40gx1eval_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/st40gx1eval_defconfig	2006-08-23 13:29:43.791714000 +0100
@@ -0,0 +1,628 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Mon Oct 18 13:12:48 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+CONFIG_SH_ST40GX1_EVAL=y
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_CPU_SUBTYPE_ST40GX1=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/st40raeval_defconfig linux-2.6.17.8-sh/arch/sh/configs/st40raeval_defconfig
--- linux-2.6.17.8/arch/sh/configs/st40raeval_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/st40raeval_defconfig	2006-08-23 13:29:43.799714000 +0100
@@ -0,0 +1,628 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Mon Oct 18 12:25:56 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+CONFIG_SH_ST40RA_EVAL=y
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+CONFIG_CPU_SUBTYPE_ST40STB1=y
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x02000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/st40rastarter_defconfig linux-2.6.17.8-sh/arch/sh/configs/st40rastarter_defconfig
--- linux-2.6.17.8/arch/sh/configs/st40rastarter_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/st40rastarter_defconfig	2006-08-23 13:29:43.807714000 +0100
@@ -0,0 +1,628 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Tue Oct 19 21:53:37 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+CONFIG_SH_ST40RA_STARTER=y
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+CONFIG_CPU_SUBTYPE_ST40STB1=y
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/stb1harp_defconfig linux-2.6.17.8-sh/arch/sh/configs/stb1harp_defconfig
--- linux-2.6.17.8/arch/sh/configs/stb1harp_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stb1harp_defconfig	2006-08-23 13:29:43.815714000 +0100
@@ -0,0 +1,632 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Mon Oct 18 17:07:42 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+CONFIG_SH_STB1_HARP=y
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+CONFIG_CPU_SUBTYPE_ST40STB1=y
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x02000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+CONFIG_HD6446X_SERIES=y
+# CONFIG_HD64461 is not set
+CONFIG_HD64465=y
+CONFIG_HD64465_IOBASE=0xa2000000
+CONFIG_HD64465_IRQ=8
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/stb1overdrive_defconfig linux-2.6.17.8-sh/arch/sh/configs/stb1overdrive_defconfig
--- linux-2.6.17.8/arch/sh/configs/stb1overdrive_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stb1overdrive_defconfig	2006-08-23 13:29:43.823714000 +0100
@@ -0,0 +1,632 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.9-rc3
+# Wed Oct 20 09:07:51 2004
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+CONFIG_SH_STB1_OVERDRIVE=y
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+CONFIG_CPU_SUBTYPE_ST40STB1=y
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x02000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=50260992
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+CONFIG_HD6446X_SERIES=y
+# CONFIG_HD64461 is not set
+CONFIG_HD64465=y
+CONFIG_HD64465_IOBASE=0xa5000000
+CONFIG_HD64465_IRQ=8
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.17.8/arch/sh/configs/stb7100mboard_defconfig linux-2.6.17.8-sh/arch/sh/configs/stb7100mboard_defconfig
--- linux-2.6.17.8/arch/sh/configs/stb7100mboard_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stb7100mboard_defconfig	2006-08-23 13:29:43.831715000 +0100
@@ -0,0 +1,1122 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Tue Aug  9 12:23:33 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+# CONFIG_SH_STI5528_ESPRESSO is not set
+# CONFIG_SH_STM8000_DEMO is not set
+# CONFIG_SH_ST220_EVAL is not set
+CONFIG_SH_STB7100_MBOARD=y
+# CONFIG_SH_STB7100_REF is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STI5528 is not set
+# CONFIG_CPU_SUBTYPE_STM8000 is not set
+CONFIG_CPU_SUBTYPE_STB7100=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x04000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+# CONFIG_BLK_DEV_IDEDMA_PIO is not set
+# CONFIG_BLK_DEV_IDEDMA_STHDDI is not set
+# CONFIG_BLK_DEV_IDEDMA_ST40 is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+CONFIG_LIRC_SUPPORT=y
+CONFIG_LIRC_MAX_DEV=2
+# CONFIG_LIRC_BT829 is not set
+# CONFIG_LIRC_IT87 is not set
+# CONFIG_LIRC_ATIUSB is not set
+# CONFIG_LIRC_MCEUSB is not set
+# CONFIG_LIRC_SIR is not set
+CONFIG_ST_LIRC=y
+CONFIG_IRB_RECEIVER=y
+# CONFIG_UHF_RECEIVER is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_STM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ST PCM-ALSA driver
+#
+CONFIG_SND_STB7100=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+CONFIG_STM_DMA=y
+CONFIG_STB7100_FDMA=y
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+CONFIG_STM_COPROCESSOR=y
+# CONFIG_COPROCESSOR_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/stb7100ref_defconfig linux-2.6.17.8-sh/arch/sh/configs/stb7100ref_defconfig
--- linux-2.6.17.8/arch/sh/configs/stb7100ref_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stb7100ref_defconfig	2006-08-23 13:29:43.840714000 +0100
@@ -0,0 +1,1123 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Tue Aug  9 12:23:33 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+# CONFIG_SH_STI5528_ESPRESSO is not set
+# CONFIG_SH_STM8000_DEMO is not set
+# CONFIG_SH_ST220_EVAL is not set
+# CONFIG_SH_STB7100_MBOARD is not set
+CONFIG_SH_STB7100_REF=y
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STI5528 is not set
+# CONFIG_CPU_SUBTYPE_STM8000 is not set
+CONFIG_CPU_SUBTYPE_STB7100=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x04000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=30000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+# CONFIG_BLK_DEV_IDEDMA_PIO is not set
+# CONFIG_BLK_DEV_IDEDMA_STHDDI is not set
+# CONFIG_BLK_DEV_IDEDMA_ST40 is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+CONFIG_LIRC_SUPPORT=y
+CONFIG_LIRC_MAX_DEV=2
+# CONFIG_LIRC_BT829 is not set
+# CONFIG_LIRC_IT87 is not set
+# CONFIG_LIRC_ATIUSB is not set
+# CONFIG_LIRC_MCEUSB is not set
+# CONFIG_LIRC_SIR is not set
+CONFIG_ST_LIRC=y
+CONFIG_IRB_RECEIVER=y
+# CONFIG_UHF_RECEIVER is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_STM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ST PCM-ALSA driver
+#
+CONFIG_SND_STB7100=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+CONFIG_STM_DMA=y
+CONFIG_STB7100_FDMA=y
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+# CONFIG_STM_SSC_DEBUG is not set
+# CONFIG_STM_SPI is not set
+CONFIG_STM_COPROCESSOR=y
+# CONFIG_COPROCESSOR_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/stb7109eref_defconfig linux-2.6.17.8-sh/arch/sh/configs/stb7109eref_defconfig
--- linux-2.6.17.8/arch/sh/configs/stb7109eref_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stb7109eref_defconfig	2006-08-23 13:29:43.855714000 +0100
@@ -0,0 +1,1135 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Mon Dec 19 19:23:59 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+# CONFIG_SH_STI5528_ESPRESSO is not set
+# CONFIG_SH_STM8000_DEMO is not set
+# CONFIG_SH_ST220_EVAL is not set
+# CONFIG_SH_STB7100_MBOARD is not set
+# CONFIG_SH_STB7100_REF is not set
+CONFIG_SH_STB7109E_REF=y
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STI5528 is not set
+# CONFIG_CPU_SUBTYPE_STM8000 is not set
+CONFIG_CPU_SUBTYPE_STB7100=y
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x04000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+# CONFIG_BLK_DEV_IDEDMA_PIO is not set
+# CONFIG_BLK_DEV_IDEDMA_STHDDI is not set
+# CONFIG_BLK_DEV_IDEDMA_ST40 is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+CONFIG_SCSI_SATA=y
+CONFIG_SCSI_SATA_STM=y
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+CONFIG_LIRC_SUPPORT=y
+CONFIG_LIRC_MAX_DEV=2
+# CONFIG_LIRC_BT829 is not set
+# CONFIG_LIRC_IT87 is not set
+# CONFIG_LIRC_ATIUSB is not set
+# CONFIG_LIRC_MCEUSB is not set
+# CONFIG_LIRC_SIR is not set
+CONFIG_ST_LIRC=y
+CONFIG_IRB_RECEIVER=y
+# CONFIG_UHF_RECEIVER is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_STM_WD is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_STM_RTC is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_EPSON1355 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ST PCM-ALSA driver
+#
+CONFIG_SND_STB7100=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+CONFIG_STM_DMA=y
+CONFIG_STB7100_FDMA=y
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+# CONFIG_STM_SSC_DEBUG is not set
+# CONFIG_STM_SPI is not set
+CONFIG_STM_COPROCESSOR=y
+# CONFIG_COPROCESSOR_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_KGDB is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/sti5528espresso_defconfig linux-2.6.17.8-sh/arch/sh/configs/sti5528espresso_defconfig
--- linux-2.6.17.8/arch/sh/configs/sti5528espresso_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/sti5528espresso_defconfig	2006-08-23 13:29:43.864714000 +0100
@@ -0,0 +1,1183 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Thu Sep  8 10:06:29 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+CONFIG_SH_STI5528_ESPRESSO=y
+# CONFIG_SH_STM8000_DEMO is not set
+# CONFIG_SH_ST220_EVAL is not set
+# CONFIG_SH_STB7100_MBOARD is not set
+# CONFIG_SH_STB7100_REF is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+CONFIG_CPU_SUBTYPE_STI5528=y
+# CONFIG_CPU_SUBTYPE_STM8000 is not set
+# CONFIG_CPU_SUBTYPE_STB7100 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x04000000
+CONFIG_MEMORY_SIZE=0x08000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+# CONFIG_MTD_CFI_I1 is not set
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+CONFIG_BLK_DEV_IDEDMA_STHDDI=y
+CONFIG_BLK_DEV_IDEDMA_ST40=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_TULIP_NAPI is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+# CONFIG_LIRC_SUPPORT is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_STM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+# CONFIG_STB7100_FDMA is not set
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/sti5528eval_defconfig linux-2.6.17.8-sh/arch/sh/configs/sti5528eval_defconfig
--- linux-2.6.17.8/arch/sh/configs/sti5528eval_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/sti5528eval_defconfig	2006-08-23 13:29:43.874714000 +0100
@@ -0,0 +1,1070 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Thu Sep  8 10:07:10 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+CONFIG_SH_STI5528_EVAL=y
+# CONFIG_SH_STI5528_ESPRESSO is not set
+# CONFIG_SH_STM8000_DEMO is not set
+# CONFIG_SH_ST220_EVAL is not set
+# CONFIG_SH_STB7100_MBOARD is not set
+# CONFIG_SH_STB7100_REF is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+CONFIG_CPU_SUBTYPE_STI5528=y
+# CONFIG_CPU_SUBTYPE_STM8000 is not set
+# CONFIG_CPU_SUBTYPE_STB7100 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x04000000
+CONFIG_MEMORY_SIZE=0x08000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+CONFIG_BLK_DEV_IDEDMA_STHDDI=y
+CONFIG_BLK_DEV_IDEDMA_ST40=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+# CONFIG_LIRC_SUPPORT is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_STM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+# CONFIG_STB7100_FDMA is not set
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/stm8000demo_defconfig linux-2.6.17.8-sh/arch/sh/configs/stm8000demo_defconfig
--- linux-2.6.17.8/arch/sh/configs/stm8000demo_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/stm8000demo_defconfig	2006-08-23 13:29:43.883714000 +0100
@@ -0,0 +1,1117 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11
+# Thu Sep  8 10:09:01 2005
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_ST40RA_EVAL is not set
+# CONFIG_SH_ST40RA_STARTER is not set
+# CONFIG_SH_ST40GX1_EVAL is not set
+# CONFIG_SH_MEDIAREF_DEMO is not set
+# CONFIG_SH_MEDIAX_DEMO is not set
+# CONFIG_SH_STI5528_EVAL is not set
+# CONFIG_SH_STI5528_ESPRESSO is not set
+CONFIG_SH_STM8000_DEMO=y
+# CONFIG_SH_ST220_EVAL is not set
+# CONFIG_SH_STB7100_MBOARD is not set
+# CONFIG_SH_STB7100_REF is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+# CONFIG_CPU_SUBTYPE_STI5528 is not set
+CONFIG_CPU_SUBTYPE_STM8000=y
+# CONFIG_CPU_SUBTYPE_STB7100 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_BIGPHYS_AREA=y
+CONFIG_SH_RTC_ST=y
+CONFIG_SH_FPU=y
+CONFIG_CPU_SUBTYPE_ST40=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+# CONFIG_ZIMAGE_ROM is not set
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_CALC=y
+CONFIG_SH_PCLK_FREQ=66000000
+CONFIG_SH_EXTERNAL_CLOCK=27000000
+# CONFIG_SH_FAST_HZ is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+# CONFIG_SH_DMA_ISA is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+CONFIG_HEARTBEAT=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# SH initrd options
+#
+# CONFIG_EMBEDDED_RAMDISK is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+CONFIG_MTD_STBOARDS=y
+# CONFIG_MTD_STBOARDS_STEM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+CONFIG_BLK_DEV_ST40IDE=y
+CONFIG_BLK_DEV_IDEDMA_STHDDI=y
+CONFIG_BLK_DEV_IDEDMA_ST40=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+CONFIG_NWHW_CONFIG=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+CONFIG_SMC91X=y
+# CONFIG_SMSC911x is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_ST_ASC=y
+CONFIG_SERIAL_ST_ASC_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# Linux InfraRed Controller
+#
+CONFIG_LIRC_SUPPORT=y
+CONFIG_LIRC_MAX_DEV=2
+# CONFIG_LIRC_BT829 is not set
+# CONFIG_LIRC_IT87 is not set
+# CONFIG_LIRC_ATIUSB is not set
+# CONFIG_LIRC_MCEUSB is not set
+# CONFIG_LIRC_SIR is not set
+CONFIG_ST_LIRC=y
+CONFIG_IRB_RECEIVER=y
+# CONFIG_UHF_RECEIVER is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_ST_PIO=y
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_STM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_ST40_PIO=y
+# CONFIG_I2C_STM is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ST PCM-ALSA driver
+#
+CONFIG_SND_STM8000=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=y
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+
+#
+# USB Host-to-Host Cables
+#
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_GENESYS is not set
+# CONFIG_USB_NET1080 is not set
+# CONFIG_USB_PL2301 is not set
+# CONFIG_USB_KC2190 is not set
+
+#
+# Intelligent USB Devices/Gadgets
+#
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ZAURUS is not set
+# CONFIG_USB_CDCETHER is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_AX8817X=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+CONFIG_STM_DRIVERS=y
+
+#
+# STM specific devices
+#
+# CONFIG_STM_DMA is not set
+# CONFIG_STB7100_FDMA is not set
+# CONFIG_STM_GPDMA is not set
+CONFIG_STM_SSC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_EARLY_SCIF_CONSOLE is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/systemh_defconfig linux-2.6.17.8-sh/arch/sh/configs/systemh_defconfig
--- linux-2.6.17.8/arch/sh/configs/systemh_defconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/systemh_defconfig	2006-08-23 13:29:19.311162000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:53 2005
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 20:44:53 2006
 #
 CONFIG_SUPERH=y
 CONFIG_UID16=y
@@ -18,31 +18,36 @@
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,6 +61,24 @@
 # CONFIG_KMOD is not set
 
 #
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
 # System type
 #
 # CONFIG_SH_SOLUTION_ENGINE is not set
@@ -65,9 +88,7 @@
 CONFIG_SH_7751_SYSTEMH=y
 # CONFIG_SH_STB1_HARP is not set
 # CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
+# CONFIG_SH_HP6XX is not set
 # CONFIG_SH_CQREEK is not set
 # CONFIG_SH_DMIDA is not set
 # CONFIG_SH_EC3104 is not set
@@ -84,41 +105,89 @@
 # CONFIG_SH_RTS7751R2D is not set
 # CONFIG_SH_EDOSK7705 is not set
 # CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
 # CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
+
+#
+# Processor selection
+#
 CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7300 is not set
 # CONFIG_CPU_SUBTYPE_SH7705 is not set
 # CONFIG_CPU_SUBTYPE_SH7707 is not set
 # CONFIG_CPU_SUBTYPE_SH7708 is not set
 # CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
 CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
 # CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
 # CONFIG_CPU_SUBTYPE_ST40STB1 is not set
 # CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
 CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
 CONFIG_MEMORY_START=0x0c000000
 CONFIG_MEMORY_SIZE=0x00400000
-# CONFIG_MEMORY_OVERRIDE is not set
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SH_RTC=y
 CONFIG_SH_FPU=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
 # CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=49876504
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+# CONFIG_SH_PCLK_FREQ_BOOL is not set
 
 #
 # CPU Frequency scaling
@@ -136,14 +205,28 @@
 # CONFIG_HD6446X_SERIES is not set
 
 #
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+CONFIG_PREEMPT=y
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
 #
 CONFIG_PCI=y
 # CONFIG_SH_PCIDMA_NONCOHERENT is not set
 CONFIG_PCI_AUTO=y
 CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -151,10 +234,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -167,9 +246,9 @@
 # CONFIG_BINFMT_MISC is not set
 
 #
-# SH initrd options
+# Networking
 #
-# CONFIG_EMBEDDED_RAMDISK is not set
+# CONFIG_NET is not set
 
 #
 # Device Drivers
@@ -183,6 +262,10 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -199,7 +282,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -211,19 +293,9 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=1024
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
 
 #
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-
-#
 # ATA/ATAPI/MFM/RLL support
 #
 # CONFIG_IDE is not set
@@ -231,6 +303,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -241,6 +314,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -253,9 +327,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -274,25 +347,15 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 # CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_LIBPS2 is not set
 # CONFIG_SERIO_RAW is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -309,6 +372,7 @@
 # Non-8250 serial port support
 #
 # CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -335,6 +399,12 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -345,10 +415,21 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -370,12 +451,12 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
@@ -394,6 +475,10 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -401,17 +486,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -432,15 +516,11 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -478,8 +558,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
-CONFIG_DEBUG_PREEMPT=y
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_FRAME_POINTER is not set
 # CONFIG_SH_STANDARD_BIOS is not set
 # CONFIG_EARLY_SCIF_CONSOLE is not set
@@ -504,6 +585,7 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
diff -Naur linux-2.6.17.8/arch/sh/configs/titan_defconfig linux-2.6.17.8-sh/arch/sh/configs/titan_defconfig
--- linux-2.6.17.8/arch/sh/configs/titan_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/configs/titan_defconfig	2006-08-23 13:29:26.530324000 +0100
@@ -0,0 +1,1551 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.17
+# Thu Jul  6 12:42:07 2006
+#
+CONFIG_SUPERH=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_UID16=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+CONFIG_OBSOLETE_INTERMODULE=m
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP6XX is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_R7780RP is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+CONFIG_SH_TITAN=y
+# CONFIG_SH_UNKNOWN is not set
+
+#
+# Processor selection
+#
+CONFIG_CPU_SH4=y
+
+#
+# SH-2 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+
+#
+# SH-4 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+CONFIG_CPU_SUBTYPE_SH7751R=y
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
+CONFIG_MMU=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+CONFIG_MEMORY_START=0x08030000
+CONFIG_MEMORY_SIZE=0x7fd0000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SH_RTC=y
+CONFIG_SH_FPU=y
+# CONFIG_SH_STORE_QUEUES is not set
+CONFIG_CPU_HAS_INTEVT=y
+CONFIG_CPU_HAS_SR_RB=y
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ=30000000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+CONFIG_SH_DMA=y
+CONFIG_NR_ONCHIP_DMA_CHANNELS=8
+# CONFIG_NR_DMA_CHANNELS_BOOL is not set
+
+#
+# Companion Chips
+#
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x009e0000
+# CONFIG_UBC_WAKEUP is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,38400N81 root=/dev/nfs ip=:::::eth1:autoconf"
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_SH_PCIDMA_NONCOHERENT=y
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+# CONFIG_PCI_DEBUG is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options (EXPERIMENTAL)
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_FWMARK is not set
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_MULTIPATH_CACHED=y
+CONFIG_IP_ROUTE_MULTIPATH_RR=m
+CONFIG_IP_ROUTE_MULTIPATH_RANDOM=m
+CONFIG_IP_ROUTE_MULTIPATH_WRANDOM=m
+CONFIG_IP_ROUTE_MULTIPATH_DRR=m
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_CT_ACCT=y
+CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_NETBIOS_NS=m
+CONFIG_IP_NF_TFTP=m
+# CONFIG_IP_NF_AMANDA is not set
+CONFIG_IP_NF_PPTP=m
+CONFIG_IP_NF_H323=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_PPTP=m
+CONFIG_IP_NF_NAT_H323=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_RAW=m
+
+#
+# Bridge: Netfilter Configuration
+#
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_PEDIT=m
+# CONFIG_NET_ACT_SIMP is not set
+CONFIG_NET_CLS_IND=y
+CONFIG_NET_ESTIMATOR=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+CONFIG_IEEE80211_SOFTMAC=m
+# CONFIG_IEEE80211_SOFTMAC_DEBUG is not set
+CONFIG_WIRELESS_EXT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=m
+CONFIG_MTD_DEBUG=y
+CONFIG_MTD_DEBUG_VERBOSE=0
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_PARTITIONS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=m
+# CONFIG_MTD_BLOCK_RO is not set
+CONFIG_FTL=m
+CONFIG_NFTL=m
+# CONFIG_NFTL_RW is not set
+CONFIG_INFTL=m
+CONFIG_RFD_FTL=m
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=m
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SOLUTIONENGINE is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=m
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_SSFDC=y
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NE2000 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_TUNE_TWISTER=y
+# CONFIG_8139TOO_8129 is not set
+CONFIG_8139_OLD_RX_RESET=y
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+CONFIG_NET_WIRELESS_RTNETLINK=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+#
+CONFIG_PRISM54=m
+# CONFIG_HOSTAP is not set
+CONFIG_BCM43XX=m
+CONFIG_BCM43XX_DEBUG=y
+CONFIG_BCM43XX_DMA=y
+CONFIG_BCM43XX_PIO=y
+CONFIG_BCM43XX_DMA_AND_PIO_MODE=y
+# CONFIG_BCM43XX_DMA_MODE is not set
+# CONFIG_BCM43XX_PIO_MODE is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_MPPE=m
+CONFIG_PPPOE=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_SH_WDT=m
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_V4L2=y
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_ZD1201 is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ANYDATA is not set
+CONFIG_USB_SERIAL_ARK3116=m
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+CONFIG_CONFIGFS_FS=m
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=m
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_FORCED_INLINING is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+CONFIG_EARLY_SCIF_CONSOLE=y
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/dma-api.c linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-api.c
--- linux-2.6.17.8/arch/sh/drivers/dma/dma-api.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-api.c	2006-08-23 13:29:43.634714000 +0100
@@ -17,6 +17,9 @@
 #include <linux/list.h>
 #include <linux/platform_device.h>
 #include <asm/dma.h>
+#include <asm/scatterlist.h>
+#include <asm/io.h>
+#include <linux/mm.h>
 
 DEFINE_SPINLOCK(dma_spin_lock);
 static LIST_HEAD(registered_dmac_list);
@@ -111,14 +114,44 @@
 
 int request_dma(unsigned int chan, const char *dev_id)
 {
+#ifdef CONFIG_STM_DMA
+	struct dma_info *info = { 0 };
+	struct dma_channel *channel = 0;
+	int ch_id = 0;
+	int i = 0;
+	if (chan == ANY_CHANNEL) {
+		do {
+			info = get_dma_info(i);
+			if (!info)
+				return -ENODEV;
+			channel = &info->channels[i];
+			i++;
+		} while (atomic_read(&channel->busy) == 1);
+	} else {
+		info = get_dma_info(chan);
+		channel = &info->channels[chan];
+	}
+	/*we should always find the channel free as it can only be used once requested */
+	if (info->ops->request)
+		ch_id = info->ops->request(channel);
+	else
+		return -ENODEV;
+
+	down(&channel->sem);
+	atomic_set(&channel->busy, 1);
+	strlcpy(channel->dev_id, dev_id, sizeof(channel->dev_id));
+	up(&channel->sem);
+	return ch_id;
+
+#else
 	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = &info->channels[chan];
 
+	struct dma_channel *channel = &info->channels[chan];
 	down(&channel->sem);
 
 	if (!info->ops || chan >= MAX_DMA_CHANNELS) {
 		up(&channel->sem);
-		return -EINVAL;
+		return -ENODEV;
 	}
 
 	atomic_set(&channel->busy, 1);
@@ -129,8 +162,9 @@
 
 	if (info->ops->request)
 		return info->ops->request(channel);
-
-	return 0;
+	else
+		return -ENODEV;
+#endif
 }
 
 void free_dma(unsigned int chan)
@@ -159,28 +193,82 @@
 		cpu_relax();
 }
 
-void dma_configure_channel(unsigned int chan, unsigned long flags)
+extern int dma_pause_channel(int flags, unsigned int chan)
+{
+
+	struct dma_info *info = get_dma_info(chan);
+	struct dma_channel *channel = &info->channels[chan];
+
+	if (info->ops->pause)
+		return info->ops->pause(flags, channel);
+
+	return -ENODEV;
+}
+
+extern void dma_unpause_channel(unsigned int chan)
+{
+	struct dma_info *info = get_dma_info(chan);
+	struct dma_channel *channel = &info->channels[chan];
+
+	if (info->ops->unpause)
+		info->ops->unpause(channel);
+}
+
+extern int dma_stop_channel(unsigned int chan)
 {
 	struct dma_info *info = get_dma_info(chan);
 	struct dma_channel *channel = &info->channels[chan];
 
+	if (info->ops->stop)
+		return info->ops->stop(channel);
+
+	return -ENODEV;
+}
+
+#ifdef CONFIG_STM_DMA
+int dma_configure_channel(struct dma_channel *channel)
+{
+	struct dma_info *info = get_dma_info(channel->chan);
+	if (info->ops->configure)
+		return info->ops->configure(channel, channel->flags);
+
+	else
+		return -ENODEV;
+}
+#else
+
+void dma_configure_channel(unsigned int chan, unsigned long flags)
+{
+
+	struct dma_info *info = get_dma_info(chan);
+	struct dma_channel *channel = &info->channels[chan];
 	if (info->ops->configure)
 		info->ops->configure(channel, flags);
 }
+#endif
+#ifdef CONFIG_STM_DMA
 
+int dma_xfer(unsigned int chan)
+{
+	struct dma_info *info = get_dma_info(chan);
+	struct dma_channel *channel = &info->channels[chan];
+	return info->ops->xfer(channel);
+}
+#else
 int dma_xfer(unsigned int chan, unsigned long from,
 	     unsigned long to, size_t size, unsigned int mode)
 {
 	struct dma_info *info = get_dma_info(chan);
 	struct dma_channel *channel = &info->channels[chan];
 
-	channel->sar	= from;
-	channel->dar	= to;
-	channel->count	= size;
-	channel->mode	= mode;
+	channel->sar = from;
+	channel->dar = to;
+	channel->count = size;
+	channel->mode = mode;
 
 	return info->ops->xfer(channel);
 }
+#endif
 
 #ifdef CONFIG_PROC_FS
 static int dma_read_proc(char *buf, char **start, off_t off,
@@ -216,7 +304,6 @@
 }
 #endif
 
-
 int register_dmac(struct dma_info *info)
 {
 	unsigned int total_channels, i;
@@ -224,8 +311,7 @@
 	INIT_LIST_HEAD(&info->list);
 
 	printk(KERN_INFO "DMA: Registering %s handler (%d channel%s).\n",
-	       info->name, info->nr_channels,
-	       info->nr_channels > 1 ? "s" : "");
+	       info->name, info->nr_channels, info->nr_channels > 1 ? "s" : "");
 
 	BUG_ON((info->flags & DMAC_CHANNELS_CONFIGURED) && !info->channels);
 
@@ -312,4 +398,6 @@
 EXPORT_SYMBOL(dma_xfer);
 EXPORT_SYMBOL(dma_wait_for_completion);
 EXPORT_SYMBOL(dma_configure_channel);
-
+EXPORT_SYMBOL(dma_pause_channel);
+EXPORT_SYMBOL(dma_unpause_channel);
+EXPORT_SYMBOL(dma_stop_channel);
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/dma-g2.c linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-g2.c
--- linux-2.6.17.8/arch/sh/drivers/dma/dma-g2.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-g2.c	2006-08-23 13:29:26.472323000 +0100
@@ -3,7 +3,7 @@
  *
  * G2 bus DMA support
  *
- * Copyright (C) 2003, 2004  Paul Mundt
+ * Copyright (C) 2003 - 2006  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -13,7 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
-
+#include <asm/cacheflush.h>
 #include <asm/mach/sysasic.h>
 #include <asm/mach/dma.h>
 #include <asm/dma.h>
@@ -47,17 +47,31 @@
 
 static volatile struct g2_dma_info *g2_dma = (volatile struct g2_dma_info *)0xa05f7800;
 
+#define g2_bytes_remaining(i) \
+	((g2_dma->channel[i].size - \
+	  g2_dma->status[i].size) & 0x0fffffff)
+
 static irqreturn_t g2_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	/* FIXME: Do some meaningful completion work here.. */
-	return IRQ_HANDLED;
-}
+	int i;
 
-static struct irqaction g2_dma_irq = {
-	.name		= "g2 DMA handler",
-	.handler	= g2_dma_interrupt,
-	.flags		= SA_INTERRUPT,
-};
+	for (i = 0; i < G2_NR_DMA_CHANNELS; i++) {
+		if (g2_dma->status[i].status & 0x20000000) {
+			unsigned int bytes = g2_bytes_remaining(i);
+
+			if (likely(bytes == 0)) {
+				struct dma_info *info = dev_id;
+				struct dma_channel *chan = info->channels + i;
+
+				wake_up(&chan->wait_queue);
+
+				return IRQ_HANDLED;
+			}
+		}
+	}
+
+	return IRQ_NONE;
+}
 
 static int g2_enable_dma(struct dma_channel *chan)
 {
@@ -135,8 +149,14 @@
 	return 0;
 }
 
+static int g2_get_residue(struct dma_channel *chan)
+{
+	return g2_bytes_remaining(chan->chan);
+}
+
 static struct dma_ops g2_dma_ops = {
 	.xfer		= g2_xfer_dma,
+	.get_residue	= g2_get_residue,
 };
 
 static struct dma_info g2_dma_info = {
@@ -148,13 +168,22 @@
 
 static int __init g2_dma_init(void)
 {
-	setup_irq(HW_EVENT_G2_DMA, &g2_dma_irq);
+	int ret;
 
+	ret = request_irq(HW_EVENT_G2_DMA, g2_dma_interrupt, SA_INTERRUPT,
+			  "g2 DMA handler", &g2_dma_info);
+	if (unlikely(ret))
+		return -EINVAL;
+ 
 	/* Magic */
 	g2_dma->wait_state	= 27;
 	g2_dma->magic		= 0x4659404f;
 
-	return register_dmac(&g2_dma_info);
+	ret = register_dmac(&g2_dma_info);
+	if (unlikely(ret != 0))
+		free_irq(HW_EVENT_G2_DMA, 0);
+
+	return ret;
 }
 
 static void __exit g2_dma_exit(void)
@@ -169,4 +198,3 @@
 MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
 MODULE_DESCRIPTION("G2 bus DMA driver");
 MODULE_LICENSE("GPL");
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/dma-pvr2.c linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-pvr2.c
--- linux-2.6.17.8/arch/sh/drivers/dma/dma-pvr2.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-pvr2.c	2006-08-23 13:29:23.425254000 +0100
@@ -18,8 +18,8 @@
 #include <asm/dma.h>
 #include <asm/io.h>
 
-static unsigned int xfer_complete = 0;
-static int count = 0;
+static unsigned int xfer_complete;
+static int count;
 
 static irqreturn_t pvr2_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
@@ -107,4 +107,3 @@
 MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
 MODULE_DESCRIPTION("NEC PowerVR 2 DMA driver");
 MODULE_LICENSE("GPL");
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/dma-sh.c linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-sh.c
--- linux-2.6.17.8/arch/sh/drivers/dma/dma-sh.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-sh.c	2006-08-23 13:29:23.367255000 +0100
@@ -11,15 +11,11 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-
 #include <linux/config.h>
 #include <linux/init.h>
-#include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/dreamcast/dma.h>
-#include <asm/signal.h>
-#include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"
@@ -87,6 +83,9 @@
 {
 	char name[32];
 
+	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
+		return 0;
+
 	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
 		 chan->chan);
 
@@ -260,7 +259,7 @@
 #ifdef CONFIG_CPU_SH4
 	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
 	i = request_irq(DMAE_IRQ, dma_err, SA_INTERRUPT, "DMAC Address Error", 0);
-	if (i < 0)
+	if (unlikely(i < 0))
 		return i;
 #endif
 
@@ -275,7 +274,7 @@
 	 * been set.
 	 */
 	i = dmaor_reset();
-	if (i < 0)
+	if (unlikely(i != 0))
 		return i;
 
 	return register_dmac(info);
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/dma-sysfs.c linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-sysfs.c
--- linux-2.6.17.8/arch/sh/drivers/dma/dma-sysfs.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/dma-sysfs.c	2006-08-23 13:29:39.158602000 +0100
@@ -28,14 +28,14 @@
 {
 	ssize_t len = 0;
 	int i;
+	struct dma_info *info;
 
-	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+	for (i = 0; NULL != (info = get_dma_info(i)); i++) {
 		struct dma_info *info = get_dma_info(i);
 		struct dma_channel *channel = &info->channels[i];
 
 		len += sprintf(buf + len, "%2d: %14s    %s\n",
-			       channel->chan, info->name,
-			       channel->dev_id);
+			       channel->chan, info->name, channel->dev_id);
 	}
 
 	return len;
@@ -70,7 +70,8 @@
 	return count;
 }
 
-static SYSDEV_ATTR(dev_id, S_IRUGO | S_IWUSR, dma_show_dev_id, dma_store_dev_id);
+static SYSDEV_ATTR(dev_id, S_IRUGO | S_IWUSR, dma_show_dev_id,
+		   dma_store_dev_id);
 
 static ssize_t dma_store_config(struct sys_device *dev,
 				const char *buf, size_t count)
@@ -79,8 +80,11 @@
 	unsigned long config;
 
 	config = simple_strtoul(buf, NULL, 0);
+#ifdef CONFIG_STM_DMA
+	dma_configure_channel(channel);
+#else
 	dma_configure_channel(channel->vchan, config);
-
+#endif
 	return count;
 }
 
@@ -119,7 +123,7 @@
 	char name[16];
 	int ret;
 
-	dev->id  = chan->vchan;
+	dev->id = chan->chan;
 	dev->cls = &dma_sysclass;
 
 	ret = sysdev_register(dev);
@@ -152,4 +156,3 @@
 
 	sysdev_unregister(dev);
 }
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/Kconfig linux-2.6.17.8-sh/arch/sh/drivers/dma/Kconfig
--- linux-2.6.17.8/arch/sh/drivers/dma/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/Kconfig	2006-08-23 13:29:43.745714000 +0100
@@ -1,16 +1,21 @@
 menu "DMA support"
 
 config SH_DMA
-	bool "DMA controller (DMAC) support"
+	bool "Hitachi/Renesas DMA controller (DMAC) support"
+	depends on !CPU_SUBTYPE_ST40
 	help
-	  Selecting this option will provide same API as PC's Direct Memory
-	  Access Controller(8237A) for SuperH DMAC.
+	  Selecting this option will allow the use of the Hitachi/Renesas
+          DMA controller (DMAC). The DMAC is programmed using the generic
+          SH DMA API, although a wrapper providing compatibility with the
+	  ISA DMA API used on PC's is also available.
 
 	  If unsure, say N.
 
 config NR_ONCHIP_DMA_CHANNELS
 	depends on SH_DMA
 	int "Number of on-chip DMAC channels"
+	default "8" if CPU_SUBTYPE_SH7750R || CPU_SUBTYPE_SH7751R
+	default "12" if CPU_SUBTYPE_SH7780
 	default "4"
 	help
 	  This allows you to specify the number of channels that the on-chip
@@ -51,5 +56,12 @@
 	  in case channel 3 is unavailable. On the SH4, channels 1,2, and 3
 	  are dual-address capable.
 
-endmenu
+config SH_DMA_ISA
+	bool "ISA DMA API compatibility layer"
+	help
+	  Selecting this option will provide same API as PC's Direct Memory
+	  Access Controller(8237A) for SuperH DMAC.
+
+	  If unsure, say N.
 
+endmenu
diff -Naur linux-2.6.17.8/arch/sh/drivers/dma/Makefile linux-2.6.17.8-sh/arch/sh/drivers/dma/Makefile
--- linux-2.6.17.8/arch/sh/drivers/dma/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/dma/Makefile	2006-08-23 13:29:43.758715000 +0100
@@ -2,7 +2,8 @@
 # Makefile for the SuperH DMA specific kernel interface routines under Linux.
 #
 
-obj-y				+= dma-api.o dma-isa.o
+obj-y				+= dma-api.o
+obj-$(CONFIG_SH_DMA_ISA)	+= dma-isa.o
 obj-$(CONFIG_SYSFS)		+= dma-sysfs.o
 obj-$(CONFIG_SH_DMA)		+= dma-sh.o
 obj-$(CONFIG_SH_DREAMCAST)	+= dma-pvr2.o dma-g2.o
diff -Naur linux-2.6.17.8/arch/sh/drivers/led/heartbeat-heart.c linux-2.6.17.8-sh/arch/sh/drivers/led/heartbeat-heart.c
--- linux-2.6.17.8/arch/sh/drivers/led/heartbeat-heart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/led/heartbeat-heart.c	2006-08-23 13:29:49.291852000 +0100
@@ -0,0 +1,41 @@
+/*
+ * linux/arch/sh/drivers/led/heartbeat-heart.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/sched.h>
+#include <asm/led.h>
+
+/* These constants used to be 672, 7 and 30 respectivly, which
+ * gives the correct values for the equation below when HZ=100.
+ * Recast them here in terms of HZ for when HZ != 100.
+ */
+#define NUMERATOR	(HZ*6)
+#define ON_TIME		(HZ/14)
+#define OFFSET		(HZ/3)
+
+/* acts like an actual heart beat -- ie thump-thump-pause... */
+void heartbeat_heart(void)
+{
+	static unsigned cnt = 0, period = 0, dist = 0;
+
+	if (cnt == 0 || cnt == dist)
+		mach_led( -1, 1);
+	else if (cnt == ON_TIME || cnt == dist+ON_TIME)
+		mach_led( -1, 0);
+
+	if (++cnt > period) {
+		cnt = 0;
+		/* The hyperbolic function below modifies the heartbeat period
+		 * length in dependency of the current (5min) load. It goes
+		 * through the points f(0)=126, f(1)=86, f(5)=51,
+		 * f(inf)->30. */
+		period = ((NUMERATOR<<FSHIFT)/(5*avenrun[0]+(7<<FSHIFT))) + OFFSET;
+		dist = period / 4;
+	}
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/led/heartbeat-knightrider.c linux-2.6.17.8-sh/arch/sh/drivers/led/heartbeat-knightrider.c
--- linux-2.6.17.8/arch/sh/drivers/led/heartbeat-knightrider.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/led/heartbeat-knightrider.c	2006-08-23 13:29:29.615392000 +0100
@@ -0,0 +1,51 @@
+/*
+ * linux/arch/sh/drivers/led/heartbeat-knightrider.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/sched.h>
+#include <asm/led.h>
+
+/* Cycle the LED's in the clasic Knightrider/Sun pattern */
+void heartbeat_knightrider(void)
+{
+	static unsigned int cnt = 0, period = 0;
+	static unsigned bit = 0, up = 1;
+
+	cnt += 1;
+	if (cnt < period) {
+		return;
+	}
+
+	cnt = 0;
+
+	/* Go through the points (roughly!):
+	 * f(0)=10, f(1)=16, f(2)=20, f(5)=35,f(inf)->110
+	 */
+	period = 110 - ( (300<<FSHIFT)/
+			 ((avenrun[0]/5) + (3<<FSHIFT)) );
+
+	mach_led(bit,0);
+
+	if (up) {
+		if (bit == 7) {
+			bit--;
+			up=0;
+		} else {
+			bit ++;
+		}
+	} else {
+		if (bit == 0) {
+			bit++;
+			up=1;
+		} else {
+			bit--;
+		}
+	}
+	mach_led(bit,1);
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/led/Makefile linux-2.6.17.8-sh/arch/sh/drivers/led/Makefile
--- linux-2.6.17.8/arch/sh/drivers/led/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/led/Makefile	2006-08-23 13:29:32.473461000 +0100
@@ -0,0 +1,15 @@
+#
+# Makefile for the LED specific files
+#
+
+obj-$(CONFIG_SH_ST40RA_EVAL)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_ST40RA_STARTER)		+= heartbeat-knightrider.o
+obj-$(CONFIG_SH_ST40GX1_EVAL)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_STB1_HARP)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_STB1_OVERDRIVE)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_MEDIAREF)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_STI5528_EVAL)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_STI5528_ESPRESSO)	+= heartbeat-heart.o
+obj-$(CONFIG_SH_STM8000_DEMO)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_ST220_EVAL)		+= heartbeat-heart.o
+obj-$(CONFIG_SH_STB7100_MBOARD)		+= heartbeat-heart.o
diff -Naur linux-2.6.17.8/arch/sh/drivers/Makefile linux-2.6.17.8-sh/arch/sh/drivers/Makefile
--- linux-2.6.17.8/arch/sh/drivers/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/Makefile	2006-08-23 13:29:39.175619000 +0100
@@ -4,5 +4,6 @@
 
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_SH_DMA)		+= dma/
+obj-$(CONFIG_STM_DMA)		+= dma/
 obj-$(CONFIG_SUPERHYWAY)	+= superhyway/
-
+obj-$(CONFIG_HEARTBEAT)	+= led/
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/fixups-dreamcast.c linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-dreamcast.c
--- linux-2.6.17.8/arch/sh/drivers/pci/fixups-dreamcast.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-dreamcast.c	2006-08-23 13:29:24.444277000 +0100
@@ -4,7 +4,7 @@
  * PCI fixups for the Sega Dreamcast
  *
  * Copyright (C) 2001, 2002  M. R. Brown
- * Copyright (C) 2002, 2003  Paul Mundt
+ * Copyright (C) 2002, 2003, 2006  Paul Mundt
  *
  * This file originally bore the message (with enclosed-$):
  *	Id: pci.c,v 1.3 2003/05/04 19:29:46 lethal Exp
@@ -46,36 +46,16 @@
 		printk("PCI: Failed resource fixup\n");
 	}
 }
-
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, gapspci_fixup_resources);
 
-void __init pcibios_fixup_bus(struct pci_bus *bus)
+int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-	/* 
-	 * We don't have any sub bus to fix up, and this is a rather
-	 * stupid place to put general device fixups. Don't do it.
-	 * Use the pcibios_fixups table or suffer the consequences.
+	/*
+	 * The interrupt routing semantics here are quite trivial.
+	 *
+	 * We basically only support one interrupt, so we only bother
+	 * updating a device's interrupt line with this single shared
+	 * interrupt. Keeps routing quite simple, doesn't it?
 	 */
+	return GAPSPCI_IRQ;
 }
-
-void __init pcibios_fixup_irqs(void)
-{
-	struct pci_dev *dev = 0;
-
-	for_each_pci_dev(dev) {
-		/*
-		 * The interrupt routing semantics here are quite trivial.
-		 *
-		 * We basically only support one interrupt, so we only bother
-		 * updating a device's interrupt line with this single shared
-		 * interrupt. Keeps routing quite simple, doesn't it?
-		 */
-		printk(KERN_NOTICE "PCI: Fixing up IRQ routing for device %s\n",
-		       pci_name(dev));
-
-		dev->irq = GAPSPCI_IRQ;
-
-		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
-	}
-}
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/fixups-r7780rp.c linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-r7780rp.c
--- linux-2.6.17.8/arch/sh/drivers/pci/fixups-r7780rp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-r7780rp.c	2006-08-23 13:29:24.588282000 +0100
@@ -0,0 +1,45 @@
+/*
+ * arch/sh/drivers/pci/fixups-r7780rp.c
+ *
+ * Highlander R7780RP-1 PCI fixups
+ *
+ * Copyright (C) 2003  Lineo uSolutions, Inc.
+ * Copyright (C) 2004 - 2006  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/pci.h>
+#include "pci-sh4.h"
+#include <asm/io.h>
+
+int pci_fixup_pcic(void)
+{
+	pci_write_reg(0x000043ff, SH4_PCIINTM);
+	pci_write_reg(0x0000380f, SH4_PCIAINTM);
+
+	pci_write_reg(0xfbb00047, SH7780_PCICMD);
+	pci_write_reg(0x00000000, SH7780_PCIIBAR);
+
+	pci_write_reg(0x00011912, SH7780_PCISVID);
+	pci_write_reg(0x08000000, SH7780_PCICSCR0);
+	pci_write_reg(0x0000001b, SH7780_PCICSAR0);
+	pci_write_reg(0xfd000000, SH7780_PCICSCR1);
+	pci_write_reg(0x0000000f, SH7780_PCICSAR1);
+
+	pci_write_reg(0xfd000000, SH7780_PCIMBR0);
+	pci_write_reg(0x00fc0000, SH7780_PCIMBMR0);
+
+#ifdef CONFIG_32BIT
+	pci_write_reg(0xc0000000, SH7780_PCIMBR2);
+	pci_write_reg(0x20000000 - SH7780_PCI_IO_SIZE, SH7780_PCIMBMR2);
+#endif
+
+	/* Set IOBR for windows containing area specified in pci.h */
+	pci_write_reg((PCIBIOS_MIN_IO & ~(SH7780_PCI_IO_SIZE - 1)),
+		      SH7780_PCIIOBR);
+	pci_write_reg(((SH7780_PCI_IO_SIZE-1) & (7<<18)), SH7780_PCIIOBMR);
+
+	return 0;
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/fixups-rts7751r2d.c linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-rts7751r2d.c
--- linux-2.6.17.8/arch/sh/drivers/pci/fixups-rts7751r2d.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-rts7751r2d.c	2006-08-23 13:29:25.624301000 +0100
@@ -10,8 +10,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-#include "pci-sh7751.h"
-#include <asm/io.h>
+#include "pci-sh4.h"
 
 #define PCIMCR_MRSET_OFF	0xBFFFFFFF
 #define PCIMCR_RFSH_OFF		0xFFFFFFFB
@@ -22,22 +21,23 @@
 
 	bcr1 = inl(SH7751_BCR1);
 	bcr1 |= 0x40080000;	/* Enable Bit 19 BREQEN, set PCIC to slave */
-	outl(bcr1, PCI_REG(SH7751_PCIBCR1));
+	pci_write_reg(bcr1, SH4_PCIBCR1);
 
 	/* Enable all interrupts, so we known what to fix */
-	outl(0x0000c3ff, PCI_REG(SH7751_PCIINTM));
-	outl(0x0000380f, PCI_REG(SH7751_PCIAINTM));
+	pci_write_reg(0x0000c3ff, SH4_PCIINTM);
+	pci_write_reg(0x0000380f, SH4_PCIAINTM);
 
-	outl(0xfb900047, PCI_REG(SH7751_PCICONF1));
-	outl(0xab000001, PCI_REG(SH7751_PCICONF4));
+	pci_write_reg(0xfb900047, SH7751_PCICONF1);
+	pci_write_reg(0xab000001, SH7751_PCICONF4);
 
 	mcr = inl(SH7751_MCR);
 	mcr = (mcr & PCIMCR_MRSET_OFF) & PCIMCR_RFSH_OFF;
-	outl(mcr, PCI_REG(SH7751_PCIMCR));
+	pci_write_reg(mcr, SH4_PCIMCR);
+
+	pci_write_reg(0x0c000000, SH7751_PCICONF5);
+	pci_write_reg(0xd0000000, SH7751_PCICONF6);
+	pci_write_reg(0x0c000000, SH4_PCILAR0);
+	pci_write_reg(0x00000000, SH4_PCILAR1);
 
-	outl(0x0c000000, PCI_REG(SH7751_PCICONF5));
-	outl(0xd0000000, PCI_REG(SH7751_PCICONF6));
-	outl(0x0c000000, PCI_REG(SH7751_PCILAR0));
-	outl(0x00000000, PCI_REG(SH7751_PCILAR1));
 	return 0;
 }
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/fixups-sh03.c linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-sh03.c
--- linux-2.6.17.8/arch/sh/drivers/pci/fixups-sh03.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/fixups-sh03.c	2006-08-23 13:29:23.723255000 +0100
@@ -3,11 +3,7 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 
-/*
- * 	IRQ functions
- */
-
-int __init pcibios_map_platform_irq(u8 slot, u8 pin, struct pci_dev *dev)
+int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
 
@@ -17,8 +13,9 @@
 		case 8: return 5;	/* eth1       */
 		case 6: return 2;	/* PCI bridge */
 		default:
-                	printk("PCI: Bad IRQ mapping request for slot %d\n", slot);
-                	return 2;
+			printk(KERN_ERR "PCI: Bad IRQ mapping request "
+					"for slot %d\n", slot);
+			return 2;
 		}
 	} else {
 		switch (pin) {
@@ -32,30 +29,3 @@
 	}
 	return irq;
 }
-
-static u8 __init sh03_no_swizzle(struct pci_dev *dev, u8 *pin)
-{
-	/* no swizzling */
-	return PCI_SLOT(dev->devfn);
-}
-
-static int sh03_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int irq = -1;
-
-	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
-	irq = pcibios_map_platform_irq(slot, pin, dev);
-	if( irq < 0 ) {
-		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
-		return irq;
-	}
-
-	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
-
-	return irq;
-}
-
-void __init pcibios_fixup_irqs(void)
-{
-	pci_fixup_irqs(sh03_no_swizzle, sh03_pci_lookup_irq);
-}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/Makefile linux-2.6.17.8-sh/arch/sh/drivers/pci/Makefile
--- linux-2.6.17.8/arch/sh/drivers/pci/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/Makefile	2006-08-23 13:29:29.621393000 +0100
@@ -5,8 +5,9 @@
 obj-y					+= pci.o
 obj-$(CONFIG_PCI_AUTO)			+= pci-auto.o
 
-obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= pci-st40.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o 
+obj-$(CONFIG_CPU_SUBTYPE_ST40)		+= pci-st40.o
+obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o ops-sh4.o
+obj-$(CONFIG_CPU_SUBTYPE_SH7780)	+= pci-sh7780.o ops-sh4.o
 
 obj-$(CONFIG_SH_DREAMCAST)		+= ops-dreamcast.o fixups-dreamcast.o \
 					   dma-dreamcast.o
@@ -14,3 +15,6 @@
 obj-$(CONFIG_SH_BIGSUR)			+= ops-bigsur.o
 obj-$(CONFIG_SH_RTS7751R2D)		+= ops-rts7751r2d.o fixups-rts7751r2d.o
 obj-$(CONFIG_SH_SH03)			+= ops-sh03.o fixups-sh03.o
+obj-$(CONFIG_SH_R7780RP)		+= ops-r7780rp.o fixups-r7780rp.o
+obj-$(CONFIG_SH_TITAN)			+= ops-titan.o
+obj-$(CONFIG_SH_LANDISK)		+= ops-landisk.o
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-bigsur.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-bigsur.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-bigsur.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-bigsur.c	2006-08-23 13:29:24.214277000 +0100
@@ -10,16 +10,13 @@
  *
  * PCI initialization for the Hitachi Big Sur Evaluation Board
  */
-
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>
-#include <linux/delay.h>
 #include <linux/pci.h>
-
 #include <asm/io.h>
-#include "pci-sh7751.h"
+#include "pci-sh4.h"
 #include <asm/bigsur/bigsur.h>
 
 #define BIGSUR_PCI_IO	0x4000
@@ -42,11 +39,11 @@
 extern struct pci_ops sh7751_pci_ops;
 
 struct pci_channel board_pci_channels[] = {
-	{ &sh7751_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
+	{ &sh4_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
 	{ 0, }
 };
 
-static struct sh7751_pci_address_map sh7751_pci_map = {
+static struct sh4_pci_address_map sh7751_pci_map = {
 	.window0	= {
 		.base	= SH7751_CS3_BASE_ADDR,
 		.size	= BIGSUR_LSR0_SIZE,
@@ -59,7 +56,7 @@
 };
 
 /*
- * Initialize the Big Sur PCI interface 
+ * Initialize the Big Sur PCI interface
  * Setup hardware to be Central Funtion
  * Copy the BSR regs to the PCI interface
  * Setup PCI windows into local RAM
@@ -69,15 +66,15 @@
 	return sh7751_pcic_init(&sh7751_pci_map);
 }
 
-int pcibios_map_platform_irq(u8 slot, u8 pin)
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
 {
-	/* 
+	/*
 	 * The Big Sur can be used in a CPCI chassis, but the SH7751 PCI
 	 * interface is on the wrong end of the board so that it can also
 	 * support a V320 CPI interface chip...  Therefor the IRQ mapping is
 	 * somewhat use dependent... I'l assume a linear map for now, i.e.
 	 * INTA=slot0,pin0... INTD=slot3,pin0...
-	 */ 
+	 */
 	int irq = (slot + pin-1) % 4 + BIGSUR_SH7751_PCI_IRQ_BASE;
 
 	PCIDBG(2, "PCI: Mapping Big Sur IRQ for slot %d, pin %c to irq %d\n",
@@ -85,4 +82,3 @@
 
 	return irq;
 }
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-landisk.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-landisk.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-landisk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-landisk.c	2006-08-23 13:29:25.090277000 +0100
@@ -0,0 +1,68 @@
+/*
+ * arch/sh/drivers/pci/ops-landisk.c
+ *
+ * PCI initialization for the I-O DATA Device, Inc. LANDISK board
+ *
+ * Copyright (C) 2006 kogiidena
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include "pci-sh4.h"
+
+static struct resource sh7751_io_resource = {
+	.name = "SH7751 IO",
+	.start = 0x4000,
+	.end = 0x4000 + SH7751_PCI_IO_SIZE - 1,
+	.flags = IORESOURCE_IO
+};
+
+static struct resource sh7751_mem_resource = {
+	.name = "SH7751 mem",
+	.start = SH7751_PCI_MEMORY_BASE,
+	.end = SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
+	.flags = IORESOURCE_MEM
+};
+
+struct pci_channel board_pci_channels[] = {
+	{&sh4_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0x3ff},
+	{NULL, NULL, NULL, 0, 0},
+};
+
+static struct sh4_pci_address_map sh7751_pci_map = {
+	.window0 = {
+		.base	= SH7751_CS3_BASE_ADDR,
+		.size	= (64 << 20),	/* 64MB */
+	},
+
+	.flags = SH4_PCIC_NO_RESET,
+};
+
+int __init pcibios_init_platform(void)
+{
+	return sh7751_pcic_init(&sh7751_pci_map);
+}
+
+int pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+	/*
+	 * slot0: pin1-4 = irq5,6,7,8
+	 * slot1: pin1-4 = irq6,7,8,5
+	 * slot2: pin1-4 = irq7,8,5,6
+	 * slot3: pin1-4 = irq8,5,6,7
+	 */
+	int irq = ((slot + pin - 1) & 0x3) + 5;
+
+	if ((slot | (pin - 1)) > 0x3) {
+		printk("PCI: Bad IRQ mapping request for slot %d pin %c\n",
+		       slot, pin - 1 + 'A');
+		return -1;
+	}
+	return irq;
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-r7780rp.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-r7780rp.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-r7780rp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-r7780rp.c	2006-08-23 13:29:24.220277000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Author:  Ian DaSilva (idasilva@mvista.com)
+ *
+ * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * PCI initialization for the Renesas SH7780 Highlander R7780RP-1 board
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <asm/r7780rp/r7780rp.h>
+#include <asm/io.h>
+#include "pci-sh4.h"
+
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+        switch (slot) {
+	case 0: return IRQ_PCISLOT1;		/* PCI Interrupt #1 */
+	case 1: return IRQ_PCISLOT2;		/* PCI Interrupt #2 */
+	case 2: return IRQ_PCISLOT3;		/* PCI Interrupt #3 */
+	case 3: return IRQ_PCISLOT4;		/* PCI Interrupt E4 */
+	default:
+		printk(KERN_ERR "PCI: Bad IRQ mapping "
+		       "request for slot %d, func %d\n", slot, pin-1);
+		return -1;
+	}
+}
+
+static struct resource sh7780_io_resource = {
+	.name	= "SH7780_IO",
+	.start	= 0x2000,
+	.end	= 0x2000 + SH7780_PCI_IO_SIZE - 1,
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource sh7780_mem_resource = {
+	.name	= "SH7780_mem",
+	.start	= SH7780_PCI_MEMORY_BASE,
+	.end	= SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+extern struct pci_ops sh7780_pci_ops;
+
+struct pci_channel board_pci_channels[] = {
+	{ &sh4_pci_ops, &sh7780_io_resource, &sh7780_mem_resource, 0, 0xff },
+	{ NULL, NULL, NULL, 0, 0 },
+};
+EXPORT_SYMBOL(board_pci_channels);
+
+static struct sh4_pci_address_map sh7780_pci_map = {
+	.window0	= {
+		.base	= SH7780_CS2_BASE_ADDR,
+		.size	= 0x04000000,
+	},
+
+	.window1	= {
+		.base	= SH7780_CS3_BASE_ADDR,
+		.size	= 0x04000000,
+	},
+
+	.flags	= SH4_PCIC_NO_RESET,
+};
+
+int __init pcibios_init_platform(void)
+{
+	return sh7780_pcic_init(&sh7780_pci_map);
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-rts7751r2d.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-rts7751r2d.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-rts7751r2d.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-rts7751r2d.c	2006-08-23 13:29:24.227279000 +0100
@@ -18,12 +18,11 @@
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/module.h>
-
-#include <asm/io.h>
-#include "pci-sh7751.h"
 #include <asm/rts7751r2d/rts7751r2d.h>
+#include <asm/io.h>
+#include "pci-sh4.h"
 
-int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
 {
         switch (slot) {
 	case 0: return IRQ_PCISLOT1;	/* PCI Extend slot #1 */
@@ -53,12 +52,12 @@
 extern struct pci_ops sh7751_pci_ops;
 
 struct pci_channel board_pci_channels[] = {
-	{ &sh7751_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
+	{ &sh4_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
 	{ NULL, NULL, NULL, 0, 0 },
 };
 EXPORT_SYMBOL(board_pci_channels);
 
-static struct sh7751_pci_address_map sh7751_pci_map = {
+static struct sh4_pci_address_map sh7751_pci_map = {
 	.window0	= {
 		.base	= SH7751_CS3_BASE_ADDR,
 		.size	= 0x04000000,
@@ -69,7 +68,7 @@
 		.size	= 0x00000000,	/* Unused */
 	},
 
-	.flags	= SH7751_PCIC_NO_RESET,
+	.flags	= SH4_PCIC_NO_RESET,
 };
 
 int __init pcibios_init_platform(void)
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-sh4.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-sh4.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-sh4.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-sh4.c	2006-08-23 13:29:24.234277000 +0100
@@ -0,0 +1,164 @@
+/*
+ * Generic SH-4 / SH-4A PCIC operations (SH7751, SH7780).
+ *
+ * Copyright (C) 2002 - 2006  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/pci.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include "pci-sh4.h"
+
+/*
+ * Direct access to PCI hardware...
+ */
+#define CONFIG_CMD(bus, devfn, where) \
+	P1SEGADDR((bus->number << 16) | (devfn << 8) | (where & ~3))
+
+static DEFINE_SPINLOCK(sh4_pci_lock);
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+static int sh4_pci_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	/*
+	 * PCIPDR may only be accessed as 32 bit words,
+	 * so we must do byte alignment by hand
+	 */
+	spin_lock_irqsave(&sh4_pci_lock, flags);
+	pci_write_reg(CONFIG_CMD(bus, devfn, where), SH4_PCIPAR);
+	data = pci_read_reg(SH4_PCIPDR);
+	spin_unlock_irqrestore(&sh4_pci_lock, flags);
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffff;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * Since SH4 only does 32bit access we'll have to do a read,
+ * mask,write operation.
+ * We'll allow an odd byte offset, though it should be illegal.
+ */
+static int sh4_pci_write(struct pci_bus *bus, unsigned int devfn,
+			 int where, int size, u32 val)
+{
+	unsigned long flags;
+	int shift;
+	u32 data;
+
+	spin_lock_irqsave(&sh4_pci_lock, flags);
+	pci_write_reg(CONFIG_CMD(bus, devfn, where), SH4_PCIPAR);
+	data = pci_read_reg(SH4_PCIPDR);
+	spin_unlock_irqrestore(&sh4_pci_lock, flags);
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xff << shift);
+		data |= ((val & 0xff) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffff << shift);
+		data |= ((val & 0xffff) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	pci_write_reg(data, SH4_PCIPDR);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops sh4_pci_ops = {
+	.read		= sh4_pci_read,
+	.write		= sh4_pci_write,
+};
+
+/*
+ * Not really related to pci_ops, but it's common and not worth shoving
+ * somewhere else for now..
+ */
+static unsigned int pci_probe = PCI_PROBE_CONF1;
+
+int __init sh4_pci_check_direct(void)
+{
+	/*
+	 * Check if configuration works.
+	 */
+	if (pci_probe & PCI_PROBE_CONF1) {
+		unsigned int tmp = pci_read_reg(SH4_PCIPAR);
+
+		pci_write_reg(P1SEG, SH4_PCIPAR);
+
+		if (pci_read_reg(SH4_PCIPAR) == P1SEG) {
+			pci_write_reg(tmp, SH4_PCIPAR);
+			printk(KERN_INFO "PCI: Using configuration type 1\n");
+			request_region(PCI_REG(SH4_PCIPAR), 8, "PCI conf1");
+
+			return 0;
+		}
+
+		pci_write_reg(tmp, SH4_PCIPAR);
+	}
+
+	pr_debug("PCI: pci_check_direct failed\n");
+	return -EINVAL;
+}
+
+/* Handle generic fixups */
+static void __init pci_fixup_ide_bases(struct pci_dev *d)
+{
+	int i;
+
+	/*
+	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
+	 */
+	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
+	for(i = 0; i < 4; i++) {
+		struct resource *r = &d->resource[i];
+
+		if ((r->start & ~0x80) == 0x374) {
+			r->start |= 2;
+			r->end = r->start;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
+
+char * __init pcibios_setup(char *str)
+{
+	if (!strcmp(str, "off")) {
+		pci_probe = 0;
+		return NULL;
+	}
+
+	return str;
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-snapgear.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-snapgear.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-snapgear.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-snapgear.c	2006-08-23 13:29:24.241277000 +0100
@@ -2,7 +2,7 @@
  * arch/sh/drivers/pci/ops-snapgear.c
  *
  * Author:  David McCullough <davidm@snapgear.com>
- * 
+ *
  * Ported to new API by Paul Mundt <lethal@linux-sh.org>
  *
  * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
@@ -12,16 +12,12 @@
  *
  * PCI initialization for the SnapGear boards
  */
-
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/init.h>
-#include <linux/delay.h>
 #include <linux/pci.h>
-
-#include <asm/io.h>
-#include "pci-sh7751.h"
+#include "pci-sh4.h"
 
 #define SNAPGEAR_PCI_IO		0x4000
 #define SNAPGEAR_PCI_MEM	0xfd000000
@@ -44,14 +40,12 @@
 	.flags		= IORESOURCE_MEM,
 };
 
-extern struct pci_ops sh7751_pci_ops;
-
 struct pci_channel board_pci_channels[] = {
-	{ &sh7751_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
+	{ &sh4_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
 	{ 0, }
 };
 
-static struct sh7751_pci_address_map sh7751_pci_map = {
+static struct sh4_pci_address_map sh7751_pci_map = {
 	.window0	= {
 		.base	= SH7751_CS2_BASE_ADDR,
 		.size	= SNAPGEAR_LSR0_SIZE,
@@ -62,11 +56,11 @@
 		.size	= SNAPGEAR_LSR1_SIZE,
 	},
 
-	.flags	= SH7751_PCIC_NO_RESET,
+	.flags	= SH4_PCIC_NO_RESET,
 };
 
 /*
- * Initialize the SnapGear PCI interface 
+ * Initialize the SnapGear PCI interface
  * Setup hardware to be Central Funtion
  * Copy the BSR regs to the PCI interface
  * Setup PCI windows into local RAM
@@ -76,7 +70,7 @@
 	return sh7751_pcic_init(&sh7751_pci_map);
 }
 
-int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
 {
 	int irq = -1;
 
@@ -99,4 +93,3 @@
 {
 	/* Nothing to fixup .. */
 }
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/ops-titan.c linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-titan.c
--- linux-2.6.17.8/arch/sh/drivers/pci/ops-titan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/ops-titan.c	2006-08-23 13:29:24.902277000 +0100
@@ -0,0 +1,83 @@
+/*
+ * arch/sh/drivers/pci/ops-titan.c
+ *
+ * Ported to new API by Paul Mundt <lethal@linux-sh.org>
+ *
+ * Modified from ops-snapgear.c written by  David McCullough
+ * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * PCI initialization for the Titan boards
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/titan.h>
+#include "pci-sh4.h"
+
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	switch (slot) {
+	case 0: irq = TITAN_IRQ_WAN;   break;	/* eth0 (WAN) */
+	case 1: irq = TITAN_IRQ_LAN;   break;	/* eth1 (LAN) */
+	case 2: irq = TITAN_IRQ_MPCIA; break;	/* mPCI A */
+	case 3: irq = TITAN_IRQ_MPCIB; break;	/* mPCI B */
+	case 4: irq = TITAN_IRQ_USB;   break;	/* USB */
+	default:
+		printk(KERN_INFO "PCI: Bad IRQ mapping "
+				 "request for slot %d\n", slot);
+		return -1;
+	}
+
+	printk("PCI: Mapping TITAN IRQ for slot %d, pin %c to irq %d\n",
+		slot, pin - 1 + 'A', irq);
+
+	return irq;
+}
+
+static struct resource sh7751_io_resource = {
+	.name	= "SH7751_IO",
+	.start	= SH7751_PCI_IO_BASE,
+	.end	= SH7751_PCI_IO_BASE + SH7751_PCI_IO_SIZE - 1,
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource sh7751_mem_resource = {
+	.name	= "SH7751_mem",
+	.start	= SH7751_PCI_MEMORY_BASE,
+	.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+struct pci_channel board_pci_channels[] = {
+	{ &sh4_pci_ops, &sh7751_io_resource, &sh7751_mem_resource, 0, 0xff },
+	{ NULL, NULL, NULL, 0, 0 },
+};
+EXPORT_SYMBOL(board_pci_channels);
+
+static struct sh4_pci_address_map sh7751_pci_map = {
+	.window0	= {
+		.base	= SH7751_CS2_BASE_ADDR,
+		.size	= SH7751_MEM_REGION_SIZE*2,	/* cs2 and cs3 */
+	},
+
+	.window1	= {
+		.base	= SH7751_CS2_BASE_ADDR,
+		.size	= SH7751_MEM_REGION_SIZE*2,
+	},
+
+	.flags	= SH4_PCIC_NO_RESET,
+};
+
+int __init pcibios_init_platform(void)
+{
+	return sh7751_pcic_init(&sh7751_pci_map);
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-auto.c linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-auto.c
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-auto.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-auto.c	2006-08-23 13:29:23.652255000 +0100
@@ -45,11 +45,11 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 
-#undef	DEBUG
-#ifdef 	DEBUG
+#define	DEBUG
+#ifdef	DEBUG
 #define	DBG(x...)	printk(x)
 #else
-#define	DBG(x...)	
+#define	DBG(x...)
 #endif
 
 /*
@@ -102,7 +102,7 @@
 static u32 pciauto_lower_memspc;
 static u32 pciauto_upper_memspc;
 
-static void __init 
+static void __init
 pciauto_setup_bars(struct pci_channel *hose,
 		   int top_bus,
 		   int current_bus,
@@ -116,7 +116,6 @@
 	int found_mem64 = 0;
 
 	for (bar = PCI_BASE_ADDRESS_0; bar <= bar_limit; bar+=4) {
-#if !defined(CONFIG_SH_HS7751RVOIP) && !defined(CONFIG_SH_RTS7751R2D)
 		u32 bar_addr;
 
 		/* Read the old BAR value */
@@ -125,7 +124,6 @@
 					pci_devfn,
 					bar,
 					&bar_addr);
-#endif
 
 		/* Tickle the BAR and get the response */
 		early_write_config_dword(hose, top_bus,
@@ -140,8 +138,7 @@
 					bar,
 					&bar_response);
 
-#if !defined(CONFIG_SH_HS7751RVOIP) && !defined(CONFIG_SH_RTS7751R2D)
-		/* 
+		/*
 		 * Write the old BAR value back out, only update the BAR
 		 * if we implicitly want resources to be updated, which
 		 * is done by the generic code further down. -- PFM.
@@ -151,7 +148,6 @@
 					 pci_devfn,
 					 bar,
 					 bar_addr);
-#endif
 
 		/* If BAR is not implemented go to the next BAR */
 		if (!bar_response)
@@ -177,7 +173,7 @@
 			    PCI_BASE_ADDRESS_MEM_TYPE_64)
 				found_mem64 = 1;
 
-			addr_mask = PCI_BASE_ADDRESS_MEM_MASK;		
+			addr_mask = PCI_BASE_ADDRESS_MEM_MASK;
 			upper_limit = &pciauto_upper_memspc;
 			lower_limit = &pciauto_lower_memspc;
 			DBG("        Mem");
@@ -193,22 +189,22 @@
 		if ((bar_value + bar_size) > *upper_limit) {
 			if (bar_response & PCI_BASE_ADDRESS_SPACE) {
 				if (io_resource_inuse->child) {
-					io_resource_inuse = 
+					io_resource_inuse =
 						io_resource_inuse->child;
-					pciauto_lower_iospc = 
+					pciauto_lower_iospc =
 						io_resource_inuse->start;
-					pciauto_upper_iospc = 
+					pciauto_upper_iospc =
 						io_resource_inuse->end + 1;
 					goto retry;
 				}
 
 			} else {
 				if (mem_resource_inuse->child) {
-					mem_resource_inuse = 
+					mem_resource_inuse =
 						mem_resource_inuse->child;
-					pciauto_lower_memspc = 
+					pciauto_lower_memspc =
 						mem_resource_inuse->start;
-					pciauto_upper_memspc = 
+					pciauto_upper_memspc =
 						mem_resource_inuse->end + 1;
 					goto retry;
 				}
@@ -230,7 +226,7 @@
 		 * If we are a 64-bit decoder then increment to the
 		 * upper 32 bits of the bar and force it to locate
 		 * in the lower 4GB of memory.
-		 */ 
+		 */
 		if (found_mem64) {
 			bar += 4;
 			early_write_config_dword(hose, top_bus,
@@ -362,7 +358,6 @@
 {
 	u32 temp;
 
-#if !defined(CONFIG_SH_HS7751RVOIP) && !defined(CONFIG_SH_RTS7751R2D)
 	/*
 	 * [jsun] we always bump up baselines a little, so that if there
 	 * nothing behind P2P bridge, we don't wind up overlapping IO/MEM
@@ -370,7 +365,6 @@
 	 */
 	pciauto_lower_memspc += 1;
 	pciauto_lower_iospc += 1;
-#endif
 
 	/*
 	 * Configure subordinate bus number.  The PCI subsystem
@@ -396,11 +390,6 @@
 	 * configured by this routine to happily live behind a
 	 * P2P bridge in a system.
 	 */
-#if defined(CONFIG_SH_HS7751RVOIP) || defined(CONFIG_SH_RTS7751R2D)
-	pciauto_lower_memspc += 0x00400000;
-	pciauto_lower_iospc += 0x00004000;
-#endif
-
 	/* Align memory and I/O to 4KB and 4 byte boundaries. */
 	pciauto_lower_memspc = (pciauto_lower_memspc + (0x1000 - 1))
 		& ~(0x1000 - 1);
@@ -433,12 +422,12 @@
 	int devfn_stop = 0xff;
 
 	sub_bus = current_bus;
-	
+
 	if (hose->first_devfn)
 		devfn_start = hose->first_devfn;
 	if (hose->last_devfn)
 		devfn_stop = hose->last_devfn;
-	
+
 	for (pci_devfn=devfn_start; pci_devfn<devfn_stop; pci_devfn++) {
 
 		if (PCI_FUNC(pci_devfn) && !found_multi)
@@ -471,9 +460,6 @@
 		if ((pci_class >> 16) == PCI_CLASS_BRIDGE_PCI) {
 			DBG("        Bridge: primary=%.2x, secondary=%.2x\n",
 				current_bus, sub_bus + 1);
-#if defined(CONFIG_SH_HS7751RVOIP) || defined(CONFIG_SH_RTS7751R2D)
-			pciauto_setup_bars(hose, top_bus, current_bus, pci_devfn, PCI_BASE_ADDRESS_1);
-#endif
 			pciauto_prescan_setup_bridge(hose, top_bus, current_bus,
 						     pci_devfn, sub_bus);
 			DBG("Scanning sub bus %.2x, I/O 0x%.8x, Mem 0x%.8x\n",
@@ -490,10 +476,10 @@
 			DBG("PCI Autoconfig: Found CardBus bridge, device %d function %d\n", PCI_SLOT(pci_devfn), PCI_FUNC(pci_devfn));
 			/* Place CardBus Socket/ExCA registers */
 			pciauto_setup_bars(hose, top_bus, current_bus, pci_devfn, PCI_BASE_ADDRESS_0);
- 
+
 			pciauto_prescan_setup_cardbus_bridge(hose, top_bus,
 					current_bus, pci_devfn, sub_bus);
- 
+
 			DBG("Scanning sub bus %.2x, I/O 0x%.8x, Mem 0x%.8x\n",
 				sub_bus + 1,
 				pciauto_lower_iospc, pciauto_lower_memspc);
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci.c linux-2.6.17.8-sh/arch/sh/drivers/pci/pci.c
--- linux-2.6.17.8/arch/sh/drivers/pci/pci.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci.c	2006-08-23 13:29:24.698277000 +0100
@@ -1,21 +1,45 @@
-/* arch/sh/kernel/pci.c
- * $Id: pci.c,v 1.1 2003/08/24 19:15:45 lethal Exp $
+/*
+ * arch/sh/drivers/pci/pci.c
  *
  * Copyright (c) 2002 M. R. Brown  <mrbrown@linux-sh.org>
- * 
- * 
+ * Copyright (c) 2004 - 2006 Paul Mundt  <lethal@linux-sh.org>
+ *
  * These functions are collected here to reduce duplication of common
  * code amongst the many platform-specific PCI support code files.
- * 
+ *
  * These routines require the following board-specific routines:
  * void pcibios_fixup_irqs();
  *
  * See include/asm-sh/pci.h for more information.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <asm/io.h>
+
+static inline u8 bridge_swizzle(u8 pin, u8 slot)
+{
+	return (((pin - 1) + slot) % 4) + 1;
+}
+
+static u8 __init simple_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	u8 pin = *pinp;
+
+	while (dev->bus->parent) {
+		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		/* Move up the chain of bridges. */
+		dev = dev->bus->self;
+	}
+	*pinp = pin;
+
+	/* The slot is the slot of the last bridge. */
+	return PCI_SLOT(dev->devfn);
+}
 
 static int __init pcibios_init(void)
 {
@@ -26,26 +50,32 @@
 #ifdef CONFIG_PCI_AUTO
 	/* assign resources */
 	busno = 0;
-	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
+	for (p = board_pci_channels; p->pci_ops != NULL; p++)
 		busno = pciauto_assign_resources(busno, p) + 1;
-	}
 #endif
 
 	/* scan the buses */
 	busno = 0;
-	for (p= board_pci_channels; p->pci_ops != NULL; p++) {
+	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
 		bus = pci_scan_bus(busno, p->pci_ops, p);
-		busno = bus->subordinate+1;
+		busno = bus->subordinate + 1;
 	}
 
-	/* board-specific fixups */
-	pcibios_fixup_irqs();
+	pci_fixup_irqs(simple_swizzle, pcibios_map_platform_irq);
 
 	return 0;
 }
-
 subsys_initcall(pcibios_init);
 
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+void __init pcibios_fixup_bus(struct pci_bus *bus)
+{
+	pci_read_bridge_bases(bus);
+}
+
 void
 pcibios_update_resource(struct pci_dev *dev, struct resource *root,
 			struct resource *res, int resource)
@@ -61,13 +91,17 @@
 		new |= PCI_ROM_ADDRESS_ENABLE;
 		reg = dev->rom_base_reg;
 	} else {
-		/* Somebody might have asked allocation of a non-standard resource */
+		/*
+		 * Somebody might have asked allocation of a non-standard
+		 * resource
+		 */
 		return;
 	}
-	
+
 	pci_write_config_dword(dev, reg, new);
 	pci_read_config_dword(dev, reg, &check);
-	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ? PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
+	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ?
+		PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
 		printk(KERN_ERR "PCI: Error while updating region "
 		       "%s/%d (%08x != %08x)\n", pci_name(dev), resource,
 		       new, check);
@@ -145,7 +179,8 @@
 		lat = pcibios_max_latency;
 	else
 		return;
-	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n", pci_name(dev), lat);
+	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
+	       pci_name(dev), lat);
 	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
 }
 
@@ -153,3 +188,39 @@
 {
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
+{
+	unsigned long start = pci_resource_start(dev, bar);
+	unsigned long len = pci_resource_len(dev, bar);
+	unsigned long flags = pci_resource_flags(dev, bar);
+
+	if (unlikely(!len || !start))
+		return NULL;
+	if (maxlen && len > maxlen)
+		len = maxlen;
+
+	/*
+	 * Presently the IORESOURCE_MEM case is a bit special, most
+	 * SH7751 style PCI controllers have PCI memory at a fixed
+	 * location in the address space where no remapping is desired
+	 * (typically at 0xfd000000, but is_pci_memaddr() will know
+	 * best). With the IORESOURCE_MEM case more care has to be taken
+	 * to inhibit page table mapping for legacy cores, but this is
+	 * punted off to __ioremap().
+	 *					-- PFM.
+	 */
+	if (flags & IORESOURCE_IO)
+		return ioport_map(start, len);
+	if (flags & IORESOURCE_MEM)
+		return ioremap(start, len);
+
+	return NULL;
+}
+EXPORT_SYMBOL(pci_iomap);
+
+void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
+{
+	iounmap(addr);
+}
+EXPORT_SYMBOL(pci_iounmap);
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-sh4.h linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh4.h
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-sh4.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh4.h	2006-08-23 13:29:24.255277000 +0100
@@ -0,0 +1,180 @@
+#ifndef __PCI_SH4_H
+#define __PCI_SH4_H
+
+#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#include "pci-sh7780.h"
+#else
+#include "pci-sh7751.h"
+#endif
+
+#include <asm/io.h>
+
+/* startup values */
+#define PCI_PROBE_BIOS		1
+#define PCI_PROBE_CONF1		2
+#define PCI_PROBE_CONF2		4
+#define PCI_NO_SORT		0x100
+#define PCI_BIOS_SORT		0x200
+#define PCI_NO_CHECKS		0x400
+#define PCI_ASSIGN_ROMS		0x1000
+#define PCI_BIOS_IRQ_SCAN	0x2000
+
+#define SH4_PCICR		0x100		/* PCI Control Register */
+  #define SH4_PCICR_PREFIX	  0xA5000000	/* CR prefix for write */
+  #define SH4_PCICR_FTO		  0x00000400	/* TRDY/IRDY Enable */
+  #define SH4_PCICR_TRSB	  0x00000200	/* Target Read Single */
+  #define SH4_PCICR_BSWP	  0x00000100	/* Target Byte Swap */
+  #define SH4_PCICR_PLUP	  0x00000080	/* Enable PCI Pullup */
+  #define SH4_PCICR_ARBM	  0x00000040	/* PCI Arbitration Mode */
+  #define SH4_PCICR_MD		  0x00000030	/* MD9 and MD10 status */
+  #define SH4_PCICR_SERR	  0x00000008	/* SERR output assert */
+  #define SH4_PCICR_INTA	  0x00000004	/* INTA output assert */
+  #define SH4_PCICR_PRST	  0x00000002	/* PCI Reset Assert */
+  #define SH4_PCICR_CFIN	  0x00000001	/* Central Fun. Init Done */
+#define SH4_PCILSR0		0x104		/* PCI Local Space Register0 */
+#define SH4_PCILSR1		0x108		/* PCI Local Space Register1 */
+#define SH4_PCILAR0		0x10C		/* PCI Local Addr Register1 */
+#define SH4_PCILAR1		0x110		/* PCI Local Addr Register1 */
+#define SH4_PCIINT		0x114		/* PCI Interrupt Register */
+  #define SH4_PCIINT_MLCK	  0x00008000	/* Master Lock Error */
+  #define SH4_PCIINT_TABT	  0x00004000	/* Target Abort Error */
+  #define SH4_PCIINT_TRET	  0x00000200	/* Target Retry Error */
+  #define SH4_PCIINT_MFDE	  0x00000100	/* Master Func. Disable Error */
+  #define SH4_PCIINT_PRTY	  0x00000080	/* Address Parity Error */
+  #define SH4_PCIINT_SERR	  0x00000040	/* SERR Detection Error */
+  #define SH4_PCIINT_TWDP	  0x00000020	/* Tgt. Write Parity Error */
+  #define SH4_PCIINT_TRDP	  0x00000010	/* Tgt. Read Parity Err Det. */
+  #define SH4_PCIINT_MTABT	  0x00000008	/* Master-Tgt. Abort Error */
+  #define SH4_PCIINT_MMABT	  0x00000004	/* Master-Master Abort Error */
+  #define SH4_PCIINT_MWPD	  0x00000002	/* Master Write PERR Detect */
+  #define SH4_PCIINT_MRPD	  0x00000001	/* Master Read PERR Detect */
+#define SH4_PCIINTM		0x118		/* PCI Interrupt Mask */
+#define SH4_PCIALR		0x11C		/* Error Address Register */
+#define SH4_PCICLR		0x120		/* Error Command/Data */
+  #define SH4_PCICLR_MPIO	  0x80000000
+  #define SH4_PCICLR_MDMA0	  0x40000000	/* DMA0 Transfer Error */
+  #define SH4_PCICLR_MDMA1	  0x20000000	/* DMA1 Transfer Error */
+  #define SH4_PCICLR_MDMA2	  0x10000000	/* DMA2 Transfer Error */
+  #define SH4_PCICLR_MDMA3	  0x08000000	/* DMA3 Transfer Error */
+  #define SH4_PCICLR_TGT	  0x04000000	/* Target Transfer Error */
+  #define SH4_PCICLR_CMDL	  0x0000000F	/* PCI Command at Error */
+#define SH4_PCIAINT		0x130		/* Arbiter Interrupt Register */
+  #define SH4_PCIAINT_MBKN	  0x00002000	/* Master Broken Interrupt */
+  #define SH4_PCIAINT_TBTO	  0x00001000	/* Target Bus Time Out */
+  #define SH4_PCIAINT_MBTO	  0x00001000	/* Master Bus Time Out */
+  #define SH4_PCIAINT_TABT	  0x00000008	/* Target Abort */
+  #define SH4_PCIAINT_MABT	  0x00000004	/* Master Abort */
+  #define SH4_PCIAINT_RDPE	  0x00000002	/* Read Data Parity Error */
+  #define SH4_PCIAINT_WDPE	  0x00000001	/* Write Data Parity Error */
+#define SH4_PCIAINTM            0x134		/* Arbiter Int. Mask Register */
+#define SH4_PCIBMLR		0x138		/* Error Bus Master Register */
+  #define SH4_PCIBMLR_REQ4	  0x00000010	/* REQ4 bus master at error */
+  #define SH4_PCIBMLR_REQ3	  0x00000008	/* REQ3 bus master at error */
+  #define SH4_PCIBMLR_REQ2	  0x00000004	/* REQ2 bus master at error */
+  #define SH4_PCIBMLR_REQ1	  0x00000002	/* REQ1 bus master at error */
+  #define SH4_PCIBMLR_REQ0	  0x00000001	/* REQ0 bus master at error */
+#define SH4_PCIDMABT		0x140		/* DMA Transfer Arb. Register */
+  #define SH4_PCIDMABT_RRBN	  0x00000001	/* DMA Arbitor Round-Robin */
+#define SH4_PCIDPA0		0x180		/* DMA0 Transfer Addr. */
+#define SH4_PCIDLA0		0x184		/* DMA0 Local Addr. */
+#define SH4_PCIDTC0		0x188		/* DMA0 Transfer Cnt. */
+#define SH4_PCIDCR0		0x18C		/* DMA0 Control Register */
+  #define SH4_PCIDCR_ALGN	  0x00000600	/* DMA Alignment Mode */
+  #define SH4_PCIDCR_MAST	  0x00000100	/* DMA Termination Type */
+  #define SH4_PCIDCR_INTM	  0x00000080	/* DMA Interrupt Done Mask*/
+  #define SH4_PCIDCR_INTS	  0x00000040	/* DMA Interrupt Done Status */
+  #define SH4_PCIDCR_LHLD	  0x00000020	/* Local Address Control */
+  #define SH4_PCIDCR_PHLD	  0x00000010	/* PCI Address Control*/
+  #define SH4_PCIDCR_IOSEL	  0x00000008	/* PCI Address Space Type */
+  #define SH4_PCIDCR_DIR	  0x00000004	/* DMA Transfer Direction */
+  #define SH4_PCIDCR_STOP	  0x00000002	/* Force DMA Stop */
+  #define SH4_PCIDCR_STRT	  0x00000001	/* DMA Start */
+#define SH4_PCIDPA1		0x190		/* DMA1 Transfer Addr. */
+#define SH4_PCIDLA1		0x194		/* DMA1 Local Addr. */
+#define SH4_PCIDTC1		0x198		/* DMA1 Transfer Cnt. */
+#define SH4_PCIDCR1		0x19C		/* DMA1 Control Register */
+#define SH4_PCIDPA2		0x1A0		/* DMA2 Transfer Addr. */
+#define SH4_PCIDLA2		0x1A4		/* DMA2 Local Addr. */
+#define SH4_PCIDTC2		0x1A8		/* DMA2 Transfer Cnt. */
+#define SH4_PCIDCR2		0x1AC		/* DMA2 Control Register */
+#define SH4_PCIDPA3		0x1B0		/* DMA3 Transfer Addr. */
+#define SH4_PCIDLA3		0x1B4		/* DMA3 Local Addr. */
+#define SH4_PCIDTC3		0x1B8		/* DMA3 Transfer Cnt. */
+#define SH4_PCIDCR3		0x1BC		/* DMA3 Control Register */
+#define SH4_PCIPAR		0x1C0		/* PIO Address Register */
+  #define SH4_PCIPAR_CFGEN	  0x80000000	/* Configuration Enable */
+  #define SH4_PCIPAR_BUSNO	  0x00FF0000	/* Config. Bus Number */
+  #define SH4_PCIPAR_DEVNO	  0x0000FF00	/* Config. Device Number */
+  #define SH4_PCIPAR_REGAD	  0x000000FC	/* Register Address Number */
+#define SH4_PCIMBR		0x1C4		/* Memory Base Address */
+  #define SH4_PCIMBR_MASK	  0xFF000000	/* Memory Space Mask */
+  #define SH4_PCIMBR_LOCK	  0x00000001	/* Lock Memory Space */
+#define SH4_PCIIOBR		0x1C8		/* I/O Base Address Register */
+  #define SH4_PCIIOBR_MASK	  0xFFFC0000	/* IO Space Mask */
+  #define SH4_PCIIOBR_LOCK	  0x00000001	/* Lock IO Space */
+#define SH4_PCIPINT		0x1CC		/* Power Mgmnt Int. Register */
+  #define SH4_PCIPINT_D3	  0x00000002	/* D3 Pwr Mgmt. Interrupt */
+  #define SH4_PCIPINT_D0	  0x00000001	/* D0 Pwr Mgmt. Interrupt */
+#define SH4_PCIPINTM		0x1D0		/* Power Mgmnt Mask Register */
+#define SH4_PCICLKR		0x1D4		/* Clock Ctrl. Register */
+  #define SH4_PCICLKR_PCSTP	  0x00000002	/* PCI Clock Stop */
+  #define SH4_PCICLKR_BCSTP	  0x00000001	/* BCLK Clock Stop */
+/* For definitions of BCR, MCR see ... */
+#define SH4_PCIBCR1		0x1E0		/* Memory BCR1 Register */
+  #define SH4_PCIMBR0		SH4_PCIBCR1
+#define SH4_PCIBCR2		0x1E4		/* Memory BCR2 Register */
+  #define SH4_PCIMBMR0		SH4_PCIBCR2
+#define SH4_PCIWCR1		0x1E8		/* Wait Control 1 Register */
+#define SH4_PCIWCR2		0x1EC		/* Wait Control 2 Register */
+#define SH4_PCIWCR3		0x1F0		/* Wait Control 3 Register */
+  #define SH4_PCIMBR2		SH4_PCIWCR3
+#define SH4_PCIMCR		0x1F4		/* Memory Control Register */
+#define SH4_PCIBCR3		0x1f8		/* Memory BCR3 Register */
+#define SH4_PCIPCTR             0x200		/* Port Control Register */
+  #define SH4_PCIPCTR_P2EN	  0x000400000	/* Port 2 Enable */
+  #define SH4_PCIPCTR_P1EN	  0x000200000	/* Port 1 Enable */
+  #define SH4_PCIPCTR_P0EN	  0x000100000	/* Port 0 Enable */
+  #define SH4_PCIPCTR_P2UP	  0x000000020	/* Port2 Pull Up Enable */
+  #define SH4_PCIPCTR_P2IO	  0x000000010	/* Port2 Output Enable */
+  #define SH4_PCIPCTR_P1UP	  0x000000008	/* Port1 Pull Up Enable */
+  #define SH4_PCIPCTR_P1IO	  0x000000004	/* Port1 Output Enable */
+  #define SH4_PCIPCTR_P0UP	  0x000000002	/* Port0 Pull Up Enable */
+  #define SH4_PCIPCTR_P0IO	  0x000000001	/* Port0 Output Enable */
+#define SH4_PCIPDTR		0x204		/* Port Data Register */
+  #define SH4_PCIPDTR_PB5	  0x000000020	/* Port 5 Enable */
+  #define SH4_PCIPDTR_PB4	  0x000000010	/* Port 4 Enable */
+  #define SH4_PCIPDTR_PB3	  0x000000008	/* Port 3 Enable */
+  #define SH4_PCIPDTR_PB2	  0x000000004	/* Port 2 Enable */
+  #define SH4_PCIPDTR_PB1	  0x000000002	/* Port 1 Enable */
+  #define SH4_PCIPDTR_PB0	  0x000000001	/* Port 0 Enable */
+#define SH4_PCIPDR		0x220		/* Port IO Data Register */
+
+/* Flags */
+#define SH4_PCIC_NO_RESET	0x0001
+
+/* arch/sh/kernel/drivers/pci/ops-sh4.c */
+extern struct pci_ops sh4_pci_ops;
+int sh4_pci_check_direct(void);
+int pci_fixup_pcic(void);
+
+struct sh4_pci_address_space {
+	unsigned long base;
+	unsigned long size;
+};
+
+struct sh4_pci_address_map {
+	struct sh4_pci_address_space window0;
+	struct sh4_pci_address_space window1;
+	unsigned long flags;
+};
+
+static inline void pci_write_reg(unsigned long val, unsigned long reg)
+{
+	outl(val, PCI_REG(reg));
+}
+
+static inline unsigned long pci_read_reg(unsigned long reg)
+{
+	return inl(PCI_REG(reg));
+}
+#endif /* __PCI_SH4_H */
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7751.c linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7751.c
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7751.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7751.c	2006-08-23 13:29:25.662300000 +0100
@@ -16,180 +16,14 @@
 #undef DEBUG
 
 #include <linux/config.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
+#include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/irq.h>
 #include <linux/delay.h>
-
-#include <asm/machvec.h>
+#include "pci-sh4.h"
+#include <asm/addrspace.h>
 #include <asm/io.h>
-#include "pci-sh7751.h"
-
-static unsigned int pci_probe = PCI_PROBE_CONF1;
-extern int pci_fixup_pcic(void);
-
-void pcibios_fixup_irqs(void) __attribute__ ((weak));
-
-/*
- * Direct access to PCI hardware...
- */
-
-#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-static int sh7751_pci_read(struct pci_bus *bus, unsigned int devfn,
-			   int where, int size, u32 *val)
-{
-	unsigned long flags;
-	u32 data;
-
-	/* 
-	 * PCIPDR may only be accessed as 32 bit words, 
-	 * so we must do byte alignment by hand 
-	 */
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
-	data = inl(PCI_REG(SH7751_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-		break;
-	case 2:
-		*val = (data >> ((where & 2) << 3)) & 0xffff;
-		break;
-	case 4:
-		*val = data;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* 
- * Since SH7751 only does 32bit access we'll have to do a read,
- * mask,write operation.
- * We'll allow an odd byte offset, though it should be illegal.
- */ 
-static int sh7751_pci_write(struct pci_bus *bus, unsigned int devfn,
-			    int where, int size, u32 val)
-{
-	unsigned long flags;
-	int shift;
-	u32 data;
-
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
-	data = inl(PCI_REG(SH7751_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-		break;
-	case 2:
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-		break;
-	case 4:
-		data = val;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	outl(data, PCI_REG(SH7751_PCIPDR));
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-#undef CONFIG_CMD
-
-struct pci_ops sh7751_pci_ops = {
-	.read 		= sh7751_pci_read,
-	.write		= sh7751_pci_write,
-};
-
-static int __init pci_check_direct(void)
-{
-	unsigned int tmp, id;
-
-	/* check for SH7751/SH7751R hardware */
-	id = inl(SH7751_PCIREG_BASE+SH7751_PCICONF0);
-	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
-	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
-		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
-		return -ENODEV;
-	}
-
-	/*
-	 * Check if configuration works.
-	 */
-	if (pci_probe & PCI_PROBE_CONF1) {
-		tmp = inl (PCI_REG(SH7751_PCIPAR));
-		outl (0x80000000, PCI_REG(SH7751_PCIPAR));
-		if (inl (PCI_REG(SH7751_PCIPAR)) == 0x80000000) {
-			outl (tmp, PCI_REG(SH7751_PCIPAR));
-			printk(KERN_INFO "PCI: Using configuration type 1\n");
-			request_region(PCI_REG(SH7751_PCIPAR), 8, "PCI conf1");
-			return 0;
-		}
-		outl (tmp, PCI_REG(SH7751_PCIPAR));
-	}
-
-	pr_debug("PCI: pci_check_direct failed\n");
-	return -EINVAL;
-}
-
-/***************************************************************************************/
-
-/*
- *  Handle bus scanning and fixups ....
- */
-
-static void __init pci_fixup_ide_bases(struct pci_dev *d)
-{
-	int i;
-
-	/*
-	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
-	 */
-	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
-		return;
-	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
-	for(i=0; i<4; i++) {
-		struct resource *r = &d->resource[i];
-		if ((r->start & ~0x80) == 0x374) {
-			r->start |= 2;
-			r->end = r->start;
-		}
-	}
-}
-
-DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
-
-/*
- *  Called after each bus is probed, but before its children
- *  are examined.
- */
-
-void __init pcibios_fixup_bus(struct pci_bus *b)
-{
-	pci_read_bridge_bases(b);
-}
 
 /*
  * Initialization. Try all known PCI access methods. Note that we support
@@ -197,25 +31,29 @@
  * to access config space.
  * 
  * Note that the platform specific initialization (BSC registers, and memory
- * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
- * exitst and via the platform defined function pcibios_init_platform().  
- * See pci_bigsur.c for implementation;
- * 
- * The BIOS version of the pci functions is not yet implemented but it is left
- * in for completeness.  Currently an error will be genereated at compile time. 
+ * space mapping) will be called via the platform defined function
+ * pcibios_init_platform().
  */
-
 static int __init sh7751_pci_init(void)
 {
+	unsigned int id;
 	int ret;
 
 	pr_debug("PCI: Starting intialization.\n");
-	if ((ret = pci_check_direct()) != 0)
+
+	/* check for SH7751/SH7751R hardware */
+	id = pci_read_reg(SH7751_PCICONF0);
+	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
+	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
+		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
+		return -ENODEV;
+	}
+
+	if ((ret = sh4_pci_check_direct()) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
-
 subsys_initcall(sh7751_pci_init);
 
 static int __init __area_sdram_check(unsigned int area)
@@ -224,26 +62,26 @@
 
 	word = inl(SH7751_BCR1);
 	/* check BCR for SDRAM in area */
-	if(((word >> area) & 1) == 0) {
+	if (((word >> area) & 1) == 0) {
 		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%x\n",
 		       area, word);
 		return 0;
 	}
-	outl(word, PCI_REG(SH7751_PCIBCR1));
+	pci_write_reg(word, SH4_PCIBCR1);
 
 	word = (u16)inw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
-	if(((word >> (area << 1)) & 0x3) != 0x3) {
+	if (((word >> (area << 1)) & 0x3) != 0x3) {
 		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%x\n",
 		       area, word);
 		return 0;
 	}
-	outl(word, PCI_REG(SH7751_PCIBCR2));
+	pci_write_reg(word, SH4_PCIBCR2);
 
 	return 1;
 }
 
-int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
+int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 {
 	u32 reg;
 	u32 word;
@@ -252,39 +90,39 @@
 	reg = inl(SH7751_BCR1);
 	reg |= 0x80000;
 	outl(reg, SH7751_BCR1);
-	
+
 	/* Turn the clocks back on (not done in reset)*/
-	outl(0, PCI_REG(SH7751_PCICLKR));
+	pci_write_reg(0, SH4_PCICLKR);
 	/* Clear Powerdown IRQ's (not done in reset) */
-	word = SH7751_PCIPINT_D3 | SH7751_PCIPINT_D0;
-	outl(word, PCI_REG(SH7751_PCIPINT));
+	word = SH4_PCIPINT_D3 | SH4_PCIPINT_D0;
+	pci_write_reg(word, SH4_PCIPINT);
 
 	/*
 	 * This code is unused for some boards as it is done in the
 	 * bootloader and doing it here means the MAC addresses loaded
 	 * by the bootloader get lost.
 	 */
-	if (!(map->flags & SH7751_PCIC_NO_RESET)) {
+	if (!(map->flags & SH4_PCIC_NO_RESET)) {
 		/* toggle PCI reset pin */
-		word = SH7751_PCICR_PREFIX | SH7751_PCICR_PRST;
-		outl(word,PCI_REG(SH7751_PCICR));
+		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
+		pci_write_reg(word, SH4_PCICR);
 		/* Wait for a long time... not 1 sec. but long enough */
 		mdelay(100);
-		word = SH7751_PCICR_PREFIX;
-		outl(word,PCI_REG(SH7751_PCICR));
+		word = SH4_PCICR_PREFIX;
+		pci_write_reg(word, SH4_PCICR);
 	}
-	
+
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
 	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER | 
 	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
-	outl(word, PCI_REG(SH7751_PCICONF1));
+	pci_write_reg(word, SH7751_PCICONF1);
 
 	/* define this host as the host bridge */
-	word = SH7751_PCI_HOST_BRIDGE << 24;
-	outl(word, PCI_REG(SH7751_PCICONF2));
+	word = PCI_BASE_CLASS_BRIDGE << 24;
+	pci_write_reg(word, SH7751_PCICONF2);
 
 	/* Set IO and Mem windows to local address 
 	 * Make PCI and local address the same for easy 1 to 1 mapping 
@@ -292,46 +130,49 @@
 	 * Window1 = map->window1.size @ cached area base = SDRAM 
 	 */
 	word = map->window0.size - 1;
-	outl(word, PCI_REG(SH7751_PCILSR0));
+	pci_write_reg(word, SH4_PCILSR0);
 	word = map->window1.size - 1;
-	outl(word, PCI_REG(SH7751_PCILSR1));
+	pci_write_reg(word, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
 	word = P2SEGADDR(map->window0.base);
-	outl(word, PCI_REG(SH7751_PCILAR0));
-	outl(word, PCI_REG(SH7751_PCICONF5));
+	pci_write_reg(word, SH4_PCILAR0);
+	pci_write_reg(word, SH7751_PCICONF5);
 	/* Set the values on window 1 PCI config registers */
 	word =  PHYSADDR(map->window1.base);
-	outl(word, PCI_REG(SH7751_PCILAR1));
-	outl(word, PCI_REG(SH7751_PCICONF6));
+	pci_write_reg(word, SH4_PCILAR1);
+	pci_write_reg(word, SH7751_PCICONF6);
 
-	/* Set the local 16MB PCI memory space window to 
+	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
 	 */
-	word = PCIBIOS_MIN_MEM & SH7751_PCIMBR_MASK;
-	PCIDBG(2,"PCI: Setting upper bits of Memory window to 0x%x\n", word);
-	outl(word , PCI_REG(SH7751_PCIMBR));
+	word = PCIBIOS_MIN_MEM & SH4_PCIMBR_MASK;
+	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
+	pci_write_reg(word , SH4_PCIMBR);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size
-	 * IO addresses will be translated to the 
+	 * IO addresses will be translated to the
 	 * PCI IO window base address
 	 */
-	PCIDBG(3,"PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n", PCIBIOS_MIN_IO,
-	    (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO);
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+		 PCIBIOS_MIN_IO, (64 << 10),
+		 SH4_PCI_IO_BASE + PCIBIOS_MIN_IO);
 
-	/* 
+	/*
 	 * XXX: For now, leave this board-specific. In the event we have other
 	 * boards that need to do similar work, this can be wrapped.
 	 */
 #ifdef CONFIG_SH_BIGSUR
-	bigsur_port_map(PCIBIOS_MIN_IO, (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO,0);
+	bigsur_port_map(PCIBIOS_MIN_IO, (64 << 10),
+			SH4_PCI_IO_BASE + PCIBIOS_MIN_IO, 0);
 #endif
 
-	/* Make sure the MSB's of IO window are set to access PCI space correctly */
-	word = PCIBIOS_MIN_IO & SH7751_PCIIOBR_MASK;
-	PCIDBG(2,"PCI: Setting upper bits of IO window to 0x%x\n", word);
-	outl(word, PCI_REG(SH7751_PCIIOBR));
-	
+	/* Make sure the MSB's of IO window are set to access PCI space
+	 * correctly */
+	word = PCIBIOS_MIN_IO & SH4_PCIIOBR_MASK;
+	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
+	pci_write_reg(word, SH4_PCIIOBR);
+
 	/* Set PCI WCRx, BCRx's, copy from BSC locations */
 
 	/* check BCR for SDRAM in specified area */
@@ -350,13 +191,13 @@
 
 	/* configure the wait control registers */
 	word = inl(SH7751_WCR1);
-	outl(word, PCI_REG(SH7751_PCIWCR1));
+	pci_write_reg(word, SH4_PCIWCR1);
 	word = inl(SH7751_WCR2);
-	outl(word, PCI_REG(SH7751_PCIWCR2));
+	pci_write_reg(word, SH4_PCIWCR2);
 	word = inl(SH7751_WCR3);
-	outl(word, PCI_REG(SH7751_PCIWCR3));
+	pci_write_reg(word, SH4_PCIWCR3);
 	word = inl(SH7751_MCR);
-	outl(word, PCI_REG(SH7751_PCIMCR));
+	pci_write_reg(word, SH4_PCIMCR);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and
@@ -369,49 +210,8 @@
 
 	/* SH7751 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
-	word = SH7751_PCICR_PREFIX | SH7751_PCICR_CFIN | SH7751_PCICR_ARBM;
-	outl(word,PCI_REG(SH7751_PCICR)); 
+	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
+	pci_write_reg(word, SH4_PCICR);
 
 	return 1;
 }
-
-char * __init pcibios_setup(char *str)
-{
-	if (!strcmp(str, "off")) {
-		pci_probe = 0;
-		return NULL;
-	}
-
-	return str;
-}
-
-/* 
- * 	IRQ functions 
- */
-static u8 __init sh7751_no_swizzle(struct pci_dev *dev, u8 *pin)
-{
-	/* no swizzling */
-	return PCI_SLOT(dev->devfn);
-}
-
-static int sh7751_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int irq = -1;
-
-	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
-	irq = pcibios_map_platform_irq(slot,pin);
-	if( irq < 0 ) {
-		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
-		return irq;
-	}
-
-	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
-
-	return irq;
-}
-
-void __init pcibios_fixup_irqs(void)
-{
-	pci_fixup_irqs(sh7751_no_swizzle, sh7751_pci_lookup_irq);
-}
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7751.h linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7751.h
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7751.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7751.h	2006-08-23 13:29:24.270277000 +0100
@@ -3,7 +3,7 @@
  *
  *  Dustin McIntire (dustin@sensoria.com) (c) 2001
  *  Paul Mundt (lethal@linux-sh.org) (c) 2003
- *	
+ *
  *  May be copied or modified under the terms of the GNU General Public
  *  License.  See linux/COPYING for more information.
  *
@@ -12,28 +12,6 @@
 #ifndef _PCI_SH7751_H_
 #define _PCI_SH7751_H_
 
-#include <linux/pci.h>
-
-/* set debug level 4=verbose...1=terse */
-//#define DEBUG_PCI 3
-#undef DEBUG_PCI
-
-#ifdef DEBUG_PCI
-#define PCIDBG(n, x...) { if(DEBUG_PCI>=n) printk(x); }
-#else
-#define PCIDBG(n, x...)
-#endif
-
-/* startup values */
-#define PCI_PROBE_BIOS 1
-#define PCI_PROBE_CONF1 2
-#define PCI_PROBE_CONF2 4
-#define PCI_NO_SORT 0x100
-#define PCI_BIOS_SORT 0x200
-#define PCI_NO_CHECKS 0x400
-#define PCI_ASSIGN_ROMS 0x1000
-#define PCI_BIOS_IRQ_SCAN 0x2000
-
 /* Platform Specific Values */
 #define SH7751_VENDOR_ID             0x1054
 #define SH7751_DEVICE_ID             0x3505
@@ -128,131 +106,6 @@
   #define SH7751_PCICONF17_PMEN      0x00010000  /* PME Enable */
   #define SH7751_PCICONF17_PWST      0x00000003  /* Power State */
 /* SH7715 Internal PCI Registers */
-#define SH7751_PCICR               0x100         /* PCI Control Register */
-  #define SH7751_PCICR_PREFIX        0xA5000000  /* CR prefix for write */
-  #define SH7751_PCICR_TRSB          0x00000200  /* Target Read Single */
-  #define SH7751_PCICR_BSWP          0x00000100  /* Target Byte Swap */
-  #define SH7751_PCICR_PLUP          0x00000080  /* Enable PCI Pullup */
-  #define SH7751_PCICR_ARBM          0x00000040  /* PCI Arbitration Mode */
-  #define SH7751_PCICR_MD            0x00000030  /* MD9 and MD10 status */
-  #define SH7751_PCICR_SERR          0x00000008  /* SERR output assert */
-  #define SH7751_PCICR_INTA          0x00000004  /* INTA output assert */
-  #define SH7751_PCICR_PRST          0x00000002  /* PCI Reset Assert */
-  #define SH7751_PCICR_CFIN          0x00000001  /* Central Fun. Init Done */
-#define SH7751_PCILSR0             0x104         /* PCI Local Space Register0 */
-#define SH7751_PCILSR1             0x108         /* PCI Local Space Register1 */
-#define SH7751_PCILAR0             0x10C         /* PCI Local Address Register1 */
-#define SH7751_PCILAR1             0x110         /* PCI Local Address Register1 */
-#define SH7751_PCIINT              0x114         /* PCI Interrupt Register */
-  #define SH7751_PCIINT_MLCK         0x00008000  /* Master Lock Error */
-  #define SH7751_PCIINT_TABT         0x00004000  /* Target Abort Error */
-  #define SH7751_PCIINT_TRET         0x00000200  /* Target Retry Error */
-  #define SH7751_PCIINT_MFDE         0x00000100  /* Master Func. Disable Error */
-  #define SH7751_PCIINT_PRTY         0x00000080  /* Address Parity Error */
-  #define SH7751_PCIINT_SERR         0x00000040  /* SERR Detection Error */
-  #define SH7751_PCIINT_TWDP         0x00000020  /* Tgt. Write Parity Error */
-  #define SH7751_PCIINT_TRDP         0x00000010  /* Tgt. Read Parity Error Det. */
-  #define SH7751_PCIINT_MTABT        0x00000008  /* Master-Tgt. Abort Error */
-  #define SH7751_PCIINT_MMABT        0x00000004  /* Master-Master Abort Error */
-  #define SH7751_PCIINT_MWPD         0x00000002  /* Master Write PERR Detect */
-  #define SH7751_PCIINT_MRPD         0x00000002  /* Master Read PERR Detect */
-#define SH7751_PCIINTM             0x118         /* PCI Interrupt Mask Register */
-#define SH7751_PCIALR              0x11C         /* Error Address Register */
-#define SH7751_PCICLR              0x120         /* Error Command/Data Register */
-  #define SH7751_PCICLR_MPIO         0x80000000  /* Error Command/Data Register */
-  #define SH7751_PCICLR_MDMA0        0x40000000  /* DMA0 Transfer Error */
-  #define SH7751_PCICLR_MDMA1        0x20000000  /* DMA1 Transfer Error */
-  #define SH7751_PCICLR_MDMA2        0x10000000  /* DMA2 Transfer Error */
-  #define SH7751_PCICLR_MDMA3        0x08000000  /* DMA3 Transfer Error */
-  #define SH7751_PCICLR_TGT          0x04000000  /* Target Transfer Error */
-  #define SH7751_PCICLR_CMDL         0x0000000F  /* PCI Command at Error */
-#define SH7751_PCIAINT             0x130         /* Arbiter Interrupt Register */
-  #define SH7751_PCIAINT_MBKN        0x00002000  /* Master Broken Interrupt */
-  #define SH7751_PCIAINT_TBTO        0x00001000  /* Target Bus Time Out */
-  #define SH7751_PCIAINT_MBTO        0x00001000  /* Master Bus Time Out */
-  #define SH7751_PCIAINT_TABT        0x00000008  /* Target Abort */
-  #define SH7751_PCIAINT_MABT        0x00000004  /* Master Abort */
-  #define SH7751_PCIAINT_RDPE        0x00000002  /* Read Data Parity Error */
-  #define SH7751_PCIAINT_WDPE        0x00000002  /* Write Data Parity Error */
-#define SH7751_PCIAINTM            0x134         /* Arbiter Int. Mask Register */
-#define SH7751_PCIBMLR             0x138         /* Error Bus Master Register */
-  #define SH7751_PCIBMLR_REQ4        0x00000010  /* REQ4 bus master at error */
-  #define SH7751_PCIBMLR_REQ3        0x00000008  /* REQ3 bus master at error */
-  #define SH7751_PCIBMLR_REQ2        0x00000004  /* REQ2 bus master at error */
-  #define SH7751_PCIBMLR_REQ1        0x00000002  /* REQ1 bus master at error */
-  #define SH7751_PCIBMLR_REQ0        0x00000001  /* REQ0 bus master at error */
-#define SH7751_PCIDMABT            0x140         /* DMA Transfer Arb. Register */
-  #define SH7751_PCIDMABT_RRBN       0x00000001  /* DMA Arbitor Round-Robin */
-#define SH7751_PCIDPA0             0x180         /* DMA0 Transfer Addr. Register */
-#define SH7751_PCIDLA0             0x184         /* DMA0 Local Addr. Register */
-#define SH7751_PCIDTC0             0x188         /* DMA0 Transfer Cnt. Register */
-#define SH7751_PCIDCR0             0x18C         /* DMA0 Control Register */
-  #define SH7751_PCIDCR_ALGN         0x00000600  /* DMA Alignment Mode */
-  #define SH7751_PCIDCR_MAST         0x00000100  /* DMA Termination Type */
-  #define SH7751_PCIDCR_INTM         0x00000080  /* DMA Interrupt Done Mask*/
-  #define SH7751_PCIDCR_INTS         0x00000040  /* DMA Interrupt Done Status */
-  #define SH7751_PCIDCR_LHLD         0x00000020  /* Local Address Control */
-  #define SH7751_PCIDCR_PHLD         0x00000010  /* PCI Address Control*/
-  #define SH7751_PCIDCR_IOSEL        0x00000008  /* PCI Address Space Type */
-  #define SH7751_PCIDCR_DIR          0x00000004  /* DMA Transfer Direction */
-  #define SH7751_PCIDCR_STOP         0x00000002  /* Force DMA Stop */
-  #define SH7751_PCIDCR_STRT         0x00000001  /* DMA Start */
-#define SH7751_PCIDPA1             0x190         /* DMA1 Transfer Addr. Register */
-#define SH7751_PCIDLA1             0x194         /* DMA1 Local Addr. Register */
-#define SH7751_PCIDTC1             0x198         /* DMA1 Transfer Cnt. Register */
-#define SH7751_PCIDCR1             0x19C         /* DMA1 Control Register */
-#define SH7751_PCIDPA2             0x1A0         /* DMA2 Transfer Addr. Register */
-#define SH7751_PCIDLA2             0x1A4         /* DMA2 Local Addr. Register */
-#define SH7751_PCIDTC2             0x1A8         /* DMA2 Transfer Cnt. Register */
-#define SH7751_PCIDCR2             0x1AC         /* DMA2 Control Register */
-#define SH7751_PCIDPA3             0x1B0         /* DMA3 Transfer Addr. Register */
-#define SH7751_PCIDLA3             0x1B4         /* DMA3 Local Addr. Register */
-#define SH7751_PCIDTC3             0x1B8         /* DMA3 Transfer Cnt. Register */
-#define SH7751_PCIDCR3             0x1BC         /* DMA3 Control Register */
-#define SH7751_PCIPAR              0x1C0         /* PIO Address Register */
-  #define SH7751_PCIPAR_CFGEN        0x80000000  /* Configuration Enable */
-  #define SH7751_PCIPAR_BUSNO        0x00FF0000  /* Config. Bus Number */
-  #define SH7751_PCIPAR_DEVNO        0x0000FF00  /* Config. Device Number */
-  #define SH7751_PCIPAR_REGAD        0x000000FC  /* Register Address Number */
-#define SH7751_PCIMBR              0x1C4         /* Memory Base Address Register */
-  #define SH7751_PCIMBR_MASK         0xFF000000  /* Memory Space Mask */
-  #define SH7751_PCIMBR_LOCK         0x00000001  /* Lock Memory Space */
-#define SH7751_PCIIOBR             0x1C8         /* I/O Base Address Register */
-  #define SH7751_PCIIOBR_MASK         0xFFFC0000 /* IO Space Mask */
-  #define SH7751_PCIIOBR_LOCK         0x00000001 /* Lock IO Space */
-#define SH7751_PCIPINT             0x1CC         /* Power Mgmnt Int. Register */
-  #define SH7751_PCIPINT_D3           0x00000002 /* D3 Pwr Mgmt. Interrupt */
-  #define SH7751_PCIPINT_D0           0x00000001 /* D0 Pwr Mgmt. Interrupt */  
-#define SH7751_PCIPINTM            0x1D0         /* Power Mgmnt Mask Register */
-#define SH7751_PCICLKR             0x1D4         /* Clock Ctrl. Register */
-  #define SH7751_PCICLKR_PCSTP        0x00000002 /* PCI Clock Stop */
-  #define SH7751_PCICLKR_BCSTP        0x00000002 /* BCLK Clock Stop */
-/* For definitions of BCR, MCR see ... */
-#define SH7751_PCIBCR1             0x1E0         /* Memory BCR1 Register */
-#define SH7751_PCIBCR2             0x1E4         /* Memory BCR2 Register */
-#define SH7751_PCIWCR1             0x1E8         /* Wait Control 1 Register */
-#define SH7751_PCIWCR2             0x1EC         /* Wait Control 2 Register */
-#define SH7751_PCIWCR3             0x1F0         /* Wait Control 3 Register */
-#define SH7751_PCIMCR              0x1F4         /* Memory Control Register */
-#define SH7751_PCIBCR3		   0x1f8	 /* Memory BCR3 Register */
-#define SH7751_PCIPCTR             0x200         /* Port Control Register */
-  #define SH7751_PCIPCTR_P2EN        0x000400000 /* Port 2 Enable */
-  #define SH7751_PCIPCTR_P1EN        0x000200000 /* Port 1 Enable */
-  #define SH7751_PCIPCTR_P0EN        0x000100000 /* Port 0 Enable */
-  #define SH7751_PCIPCTR_P2UP        0x000000020 /* Port2 Pull Up Enable */
-  #define SH7751_PCIPCTR_P2IO        0x000000010 /* Port2 Output Enable */
-  #define SH7751_PCIPCTR_P1UP        0x000000008 /* Port1 Pull Up Enable */
-  #define SH7751_PCIPCTR_P1IO        0x000000004 /* Port1 Output Enable */
-  #define SH7751_PCIPCTR_P0UP        0x000000002 /* Port0 Pull Up Enable */
-  #define SH7751_PCIPCTR_P0IO        0x000000001 /* Port0 Output Enable */
-#define SH7751_PCIPDTR             0x204         /* Port Data Register */
-  #define SH7751_PCIPDTR_PB5         0x000000020 /* Port 5 Enable */
-  #define SH7751_PCIPDTR_PB4         0x000000010 /* Port 4 Enable */
-  #define SH7751_PCIPDTR_PB3         0x000000008 /* Port 3 Enable */
-  #define SH7751_PCIPDTR_PB2         0x000000004 /* Port 2 Enable */
-  #define SH7751_PCIPDTR_PB1         0x000000002 /* Port 1 Enable */
-  #define SH7751_PCIPDTR_PB0         0x000000001 /* Port 0 Enable */
-#define SH7751_PCIPDR              0x220         /* Port IO Data Register */
 
 /* Memory Control Registers */
 #define SH7751_BCR1                0xFF800000    /* Memory BCR1 Register */
@@ -274,30 +127,9 @@
 #define SH7751_CS5_BASE_ADDR       (SH7751_CS4_BASE_ADDR + SH7751_MEM_REGION_SIZE)
 #define SH7751_CS6_BASE_ADDR       (SH7751_CS5_BASE_ADDR + SH7751_MEM_REGION_SIZE)
 
-/* General PCI values */
-#define SH7751_PCI_HOST_BRIDGE		0x6
-
-/* Flags */
-#define SH7751_PCIC_NO_RESET	0x0001
-
-/* External functions defined per platform i.e. Big Sur, SE... (these could be routed 
- * through the machine vectors... */
-extern int pcibios_init_platform(void);
-extern int pcibios_map_platform_irq(u8 slot, u8 pin);
-
-struct sh7751_pci_address_space {
-	unsigned long base;
-	unsigned long size;
-};
-
-struct sh7751_pci_address_map {
-	struct sh7751_pci_address_space window0;
-	struct sh7751_pci_address_space window1;
-	unsigned long flags;
-};
+struct sh4_pci_address_map;
 
 /* arch/sh/drivers/pci/pci-sh7751.c */
-extern int sh7751_pcic_init(struct sh7751_pci_address_map *map);
+int sh7751_pcic_init(struct sh4_pci_address_map *map);
 
 #endif /* _PCI_SH7751_H_ */
-
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7780.c linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7780.c
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7780.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7780.c	2006-08-23 13:29:24.395277000 +0100
@@ -0,0 +1,139 @@
+/*
+ *	Low-Level PCI Support for the SH7780
+ *
+ *  Dustin McIntire (dustin@sensoria.com)
+ *	Derived from arch/i386/kernel/pci-*.c which bore the message:
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *
+ *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
+ *  With cleanup by Paul van Gool <pvangool@mimotech.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#undef DEBUG
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include "pci-sh4.h"
+
+/*
+ * Initialization. Try all known PCI access methods. Note that we support
+ * using both PCI BIOS and direct access: in such cases, we use I/O ports
+ * to access config space.
+ *
+ * Note that the platform specific initialization (BSC registers, and memory
+ * space mapping) will be called via the platform defined function
+ * pcibios_init_platform().
+ */
+static int __init sh7780_pci_init(void)
+{
+	unsigned int id;
+	int ret;
+
+	pr_debug("PCI: Starting intialization.\n");
+
+	outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
+
+	/* check for SH7780/SH7780R hardware */
+	id = pci_read_reg(SH7780_PCIVID);
+	if ((id != ((SH7780_DEVICE_ID << 16) | SH7780_VENDOR_ID)) &&
+	    (id != ((SH7781_DEVICE_ID << 16) | SH7780_VENDOR_ID))) {
+		printk(KERN_ERR "PCI: This is not an SH7780 (%x)\n", id);
+		return -ENODEV;
+	}
+
+	/* Setup the INTC */
+	ctrl_outl(0x00200000, INTC_ICR0);	/* INTC SH-4 Mode */
+	ctrl_outl(0x00078000, INTC_INT2MSKCR);	/* enable PCIINTA - PCIINTD */
+	ctrl_outl(0x40000000, INTC_INTMSK1);	/* disable IRL4-7 Interrupt */
+	ctrl_outl(0x0000fffe, INTC_INTMSK2);	/* disable IRL4-7 Interrupt */
+	ctrl_outl(0x80000000, INTC_INTMSKCLR1);	/* enable IRL0-3 Interrupt */
+	ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);	/* enable IRL0-3 Interrupt */
+
+	if ((ret = sh4_pci_check_direct()) != 0)
+		return ret;
+
+	return pcibios_init_platform();
+}
+core_initcall(sh7780_pci_init);
+
+int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
+{
+	u32 word;
+
+	/*
+	 * This code is unused for some boards as it is done in the
+	 * bootloader and doing it here means the MAC addresses loaded
+	 * by the bootloader get lost.
+	 */
+	if (!(map->flags & SH4_PCIC_NO_RESET)) {
+		/* toggle PCI reset pin */
+		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
+		pci_write_reg(word, SH4_PCICR);
+		/* Wait for a long time... not 1 sec. but long enough */
+		mdelay(100);
+		word = SH4_PCICR_PREFIX;
+		pci_write_reg(word, SH4_PCICR);
+	}
+
+	/* set the command/status bits to:
+	 * Wait Cycle Control + Parity Enable + Bus Master +
+	 * Mem space enable
+	 */
+	pci_write_reg(0x00000046, SH7780_PCICMD);
+
+	/* define this host as the host bridge */
+	word = PCI_BASE_CLASS_BRIDGE << 24;
+	pci_write_reg(word, SH7780_PCIRID);
+
+	/* Set IO and Mem windows to local address
+	 * Make PCI and local address the same for easy 1 to 1 mapping
+	 * Window0 = map->window0.size @ non-cached area base = SDRAM
+	 * Window1 = map->window1.size @ cached area base = SDRAM
+	 */
+	word = ((map->window0.size - 1) & 0x1ff00001) | 0x01;
+	pci_write_reg(0x07f00001, SH4_PCILSR0);
+	word = ((map->window1.size - 1) & 0x1ff00001) | 0x01;
+	pci_write_reg(0x00000001, SH4_PCILSR1);
+	/* Set the values on window 0 PCI config registers */
+	word = P2SEGADDR(map->window0.base);
+	pci_write_reg(0xa8000000, SH4_PCILAR0);
+	pci_write_reg(0x08000000, SH7780_PCIMBAR0);
+	/* Set the values on window 1 PCI config registers */
+	word = P2SEGADDR(map->window1.base);
+	pci_write_reg(0x00000000, SH4_PCILAR1);
+	pci_write_reg(0x00000000, SH7780_PCIMBAR1);
+
+	/* Map IO space into PCI IO window
+	 * The IO window is 64K-PCIBIOS_MIN_IO in size
+	 * IO addresses will be translated to the
+	 * PCI IO window base address
+	 */
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+		 PCIBIOS_MIN_IO, (64 << 10),
+		 SH7780_PCI_IO_BASE + PCIBIOS_MIN_IO);
+
+	/* NOTE: I'm ignoring the PCI error IRQs for now..
+	 * TODO: add support for the internal error interrupts and
+	 * DMA interrupts...
+	 */
+
+#ifdef CONFIG_SH_R7780RP
+	pci_fixup_pcic();
+#endif
+
+	/* SH7780 init done, set central function init complete */
+	/* use round robin mode to stop a device starving/overruning */
+	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
+	pci_write_reg(word, SH4_PCICR);
+
+	return 1;
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7780.h linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7780.h
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-sh7780.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-sh7780.h	2006-08-23 13:29:24.512277000 +0100
@@ -0,0 +1,94 @@
+/*
+ *	Low-Level PCI Support for SH7780 targets
+ *
+ *  Dustin McIntire (dustin@sensoria.com) (c) 2001
+ *  Paul Mundt (lethal@linux-sh.org) (c) 2003
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#ifndef _PCI_SH7780_H_
+#define _PCI_SH7780_H_
+
+/* Platform Specific Values */
+#define SH7780_VENDOR_ID	0x1912
+#define SH7780_DEVICE_ID	0x0002
+#define SH7781_DEVICE_ID	0x0001
+
+/* SH7780 Control Registers */
+#define	SH7780_PCI_VCR0		0xFE000000
+#define	SH7780_PCI_VCR1		0xFE000004
+#define	SH7780_PCI_VCR2		0xFE000008
+
+/* SH7780 Specific Values */
+#define SH7780_PCI_CONFIG_BASE	0xFD000000	/* Config space base addr */
+#define SH7780_PCI_CONFIG_SIZE	0x01000000	/* Config space size */
+
+#define SH7780_PCI_MEMORY_BASE	0xFD000000	/* Memory space base addr */
+#define SH7780_PCI_MEM_SIZE	0x01000000	/* Size of Memory window */
+
+#define SH7780_PCI_IO_BASE	0xFE400000	/* IO space base address */
+#define SH7780_PCI_IO_SIZE	0x00400000	/* Size of IO window */
+
+#define SH7780_PCIREG_BASE	0xFE040000	/* PCI regs base address */
+#define PCI_REG(n)		(SH7780_PCIREG_BASE+n)
+
+/* SH7780 PCI Config Registers */
+#define SH7780_PCIVID		0x000		/* Vendor ID */
+#define SH7780_PCIDID		0x002		/* Device ID */
+#define SH7780_PCICMD		0x004		/* Command */
+#define SH7780_PCISTATUS	0x006		/* Status */
+#define SH7780_PCIRID		0x008		/* Revision ID */
+#define SH7780_PCIPIF		0x009		/* Program Interface */
+#define SH7780_PCISUB		0x00a		/* Sub class code */
+#define SH7780_PCIBCC		0x00b		/* Base class code */
+#define SH7780_PCICLS		0x00c		/* Cache line size */
+#define SH7780_PCILTM		0x00d		/* latency timer */
+#define SH7780_PCIHDR		0x00e		/* Header type */
+#define SH7780_PCIBIST		0x00f		/* BIST */
+#define SH7780_PCIIBAR		0x010		/* IO Base address */
+#define SH7780_PCIMBAR0		0x014		/* Memory base address0 */
+#define SH7780_PCIMBAR1		0x018		/* Memory base address1 */
+#define SH7780_PCISVID		0x02c		/* Sub system vendor ID */
+#define SH7780_PCISID		0x02e		/* Sub system ID */
+#define SH7780_PCICP		0x034
+#define SH7780_PCIINTLINE	0x03c		/* Interrupt line */
+#define SH7780_PCIINTPIN	0x03d		/* Interrupt pin */
+#define SH7780_PCIMINGNT	0x03e		/* Minumum grand */
+#define SH7780_PCIMAXLAT	0x03f		/* Maxmum latency */
+#define SH7780_PCICID		0x040
+#define SH7780_PCINIP		0x041
+#define SH7780_PCIPMC		0x042
+#define SH7780_PCIPMCSR		0x044
+#define SH7780_PCIPMCSR_BSE	0x046
+#define SH7780_PCICDD		0x047
+
+#define SH7780_PCIMBR0		0x1E0
+#define SH7780_PCIMBMR0		0x1E4
+#define SH7780_PCIMBR2		0x1F0
+#define SH7780_PCIMBMR2		0x1F4
+#define SH7780_PCIIOBR		0x1F8
+#define SH7780_PCIIOBMR		0x1FC
+#define SH7780_PCICSCR0		0x210		/* Cache Snoop1 Cnt. Register */
+#define SH7780_PCICSCR1		0x214		/* Cache Snoop2 Cnt. Register */
+#define SH7780_PCICSAR0		0x218	/* Cache Snoop1 Addr. Register */
+#define SH7780_PCICSAR1		0x21C	/* Cache Snoop2 Addr. Register */
+
+/* General Memory Config Addresses */
+#define SH7780_CS0_BASE_ADDR	0x0
+#define SH7780_MEM_REGION_SIZE	0x04000000
+#define SH7780_CS1_BASE_ADDR	(SH7780_CS0_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+#define SH7780_CS2_BASE_ADDR	(SH7780_CS1_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+#define SH7780_CS3_BASE_ADDR	(SH7780_CS2_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+#define SH7780_CS4_BASE_ADDR	(SH7780_CS3_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+#define SH7780_CS5_BASE_ADDR	(SH7780_CS4_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+#define SH7780_CS6_BASE_ADDR	(SH7780_CS5_BASE_ADDR + SH7780_MEM_REGION_SIZE)
+
+struct sh4_pci_address_map;
+
+/* arch/sh/drivers/pci/pci-sh7780.c */
+int sh7780_pcic_init(struct sh4_pci_address_map *map);
+
+#endif /* _PCI_SH7780_H_ */
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-st40.c linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-st40.c
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-st40.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-st40.c	2006-08-23 13:29:37.903577000 +0100
@@ -2,7 +2,7 @@
  * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
  *
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
+ * License.  See linux/COPYING for more information.
  *
  * Support functions for the ST40 PCI hardware.
  */
@@ -19,15 +19,11 @@
 #include <asm/pci.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>	/* irqreturn_t */
-
+#ifdef CONFIG_HD64465
+#include <asm/hd64465/io.h>
+#endif
 #include "pci-st40.h"
 
-/* This is in P2 of course */
-#define ST40PCI_BASE_ADDRESS     (0xb0000000)
-#define ST40PCI_MEM_ADDRESS      (ST40PCI_BASE_ADDRESS+0x0)
-#define ST40PCI_IO_ADDRESS       (ST40PCI_BASE_ADDRESS+0x06000000)
-#define ST40PCI_REG_ADDRESS      (ST40PCI_BASE_ADDRESS+0x07000000)
-
 #define ST40PCI_REG(x) (ST40PCI_REG_ADDRESS+(ST40PCI_##x))
 #define ST40PCI_REG_INDEXED(reg, index) 				\
 	(ST40PCI_REG(reg##0) +					\
@@ -43,66 +39,6 @@
 #define ST40PCI_READ_SHORT(reg) readw(ST40PCI_REG(reg))
 #define ST40PCI_READ_BYTE(reg) readb(ST40PCI_REG(reg))
 
-#define ST40PCI_SERR_IRQ	64
-#define ST40PCI_ERR_IRQ        	65
-
-
-/* Macros to extract PLL params */
-#define PLL_MDIV(reg)  ( ((unsigned)reg) & 0xff )
-#define PLL_NDIV(reg) ( (((unsigned)reg)>>8) & 0xff )
-#define PLL_PDIV(reg) ( (((unsigned)reg)>>16) & 0x3 )
-#define PLL_SETUP(reg) ( (((unsigned)reg)>>19) & 0x1ff )
-
-/* Build up the appropriate settings */
-#define PLL_SET(mdiv,ndiv,pdiv,setup) \
-( ((mdiv)&0xff) | (((ndiv)&0xff)<<8) | (((pdiv)&3)<<16)| (((setup)&0x1ff)<<19))
-
-#define PLLPCICR (0xbb040000+0x10)
-
-#define PLLPCICR_POWERON (1<<28)
-#define PLLPCICR_OUT_EN (1<<29)
-#define PLLPCICR_LOCKSELECT (1<<30)
-#define PLLPCICR_LOCK (1<<31)
-
-
-#define PLL_25MHZ 0x793c8512
-#define PLL_33MHZ PLL_SET(18,88,3,295)
-
-static void pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
-			 unsigned long pciOffset, unsigned long regionSize);
-
-/*
- * The pcibios_map_platform_irq function is defined in the appropriate
- * board specific code and referenced here
- */
-extern int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin);
-
-static __init void SetPCIPLL(void)
-{
-	{
-		/* Lets play with the PLL values */
-		unsigned long pll1cr1;
-		unsigned long mdiv, ndiv, pdiv;
-		unsigned long muxcr;
-		unsigned int muxcr_ratios[4] = { 8, 16, 21, 1 };
-		unsigned int freq;
-
-#define CLKGENA            0xbb040000
-#define CLKGENA_PLL2_MUXCR CLKGENA + 0x48
-		pll1cr1 = ctrl_inl(PLLPCICR);
-		printk("PLL1CR1 %08lx\n", pll1cr1);
-		mdiv = PLL_MDIV(pll1cr1);
-		ndiv = PLL_NDIV(pll1cr1);
-		pdiv = PLL_PDIV(pll1cr1);
-		printk("mdiv %02lx ndiv %02lx pdiv %02lx\n", mdiv, ndiv, pdiv);
-		freq = ((2*27*ndiv)/mdiv) / (1 << pdiv);
-		printk("PLL freq %dMHz\n", freq);
-		muxcr = ctrl_inl(CLKGENA_PLL2_MUXCR);
-		printk("PCI freq %dMhz\n", freq / muxcr_ratios[muxcr & 3]);
-	}
-}
-
-
 struct pci_err {
   unsigned mask;
   const char *error_string;
@@ -257,18 +193,31 @@
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
-int __init st40pci_init(unsigned memStart, unsigned memSize)
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1) || \
+    defined (CONFIG_CPU_SUBTYPE_ST40GX1)
+static void __init pci_fixup_cache_line(struct pci_dev *d)
 {
-	u32 lsr0;
+	/*
+	 * STB1 and GX1 have bugs which prevent them being the target
+	 * of memory-read-multiple (MRM) PCI commands. This prevents some
+	 * cards using this command, but it is not infallible.
+	 */
+	pci_write_config_byte(d,PCI_CACHE_LINE_SIZE,0);
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_cache_line);
+#endif
 
-	SetPCIPLL();
+static int __init st40pci_host_init(unsigned memStart, unsigned memSize)
+{
 
 	/* Initialises the ST40 pci subsystem, performing a reset, then programming
 	 * up the address space decoders appropriately
 	 */
 
-	/* Should reset core here as well methink */
+	request_mem_region(ST40PCI_REG_ADDRESS, 0x17c, "PCI local");
+	request_mem_region(ST40PCI_REG_ADDRESS+ST40PCI_CSR, 0x100, "PCI CSR");
 
+	/* Should reset core here as well methink */
 	ST40PCI_WRITE(CR, CR_LOCK_MASK | CR_SOFT_RESET);
 
 	/* Loop while core resets */
@@ -290,10 +239,6 @@
 	 */
 	mdelay(1000);
 
-	/* Switch off interrupts */
-	ST40PCI_WRITE(INTM, 0);
-	ST40PCI_WRITE(AINT, 0);
-
 	/* Allow it to be a master */
 
 	ST40PCI_WRITE_SHORT(CSR_CMD,
@@ -318,13 +263,18 @@
 	/* Set up the 64K window */
 	ST40PCI_WRITE(IOBMR, 0x0);
 
+#ifdef CONFIG_HD64465
+	hd64465_port_map(ST40_PCI_IO, (64 * 1024) - ST40_PCI_IO,
+			 ST40PCI_IO_ADDRESS + ST40_PCI_IO, 0);
+#endif
+
 	/* Now we set up the mbars so the PCI bus can see the local memory */
 	/* Expose a 256M window starting at PCI address 0... */
 	ST40PCI_WRITE(CSR_MBAR0, 0);
 	ST40PCI_WRITE(LSR0, 0x0fff0001);
 
 	/* ... and set up the initial incomming window to expose all of RAM */
-	pci_set_rbar_region(7, memStart, memStart, memSize);
+	st40pci_set_rbar_region(7, memStart, memStart, memSize);
 
 	/* Maximise timeout values */
 	ST40PCI_WRITE_BYTE(CSR_TRDY, 0xff);
@@ -333,6 +283,25 @@
 
 	ST40PCI_WRITE_BYTE(PERF,PERF_MASTER_WRITE_POSTING);
 
+	if (request_irq(ST40PCI_SERR_IRQ, st40_pci_irq,
+                        SA_INTERRUPT, "st40pci", NULL)) {
+		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
+		return 0;
+	}
+
+	if (request_irq(ST40PCI_ERR_IRQ, st40_pci_irq,
+                        SA_INTERRUPT, "st40pci", NULL)) {
+		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
+		return 0;
+	}
+
+	/* Reset state just in case any outstanding (usually SERR) */
+	ST40PCI_WRITE(INT, ~0); ST40PCI_WRITE(AINT, ~0);
+
+	/* Enable the PCI interrupts on the device */
+	ST40PCI_WRITE(INTM, ~0);
+	ST40PCI_WRITE(AINT, ~0);
+
 	return 1;
 }
 
@@ -347,6 +316,8 @@
 
 #define CONFIG_CMD(bus, devfn, where) SET_CONFIG_BITS(bus->number,devfn,where)
 
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1) || \
+    defined (CONFIG_CPU_SUBTYPE_ST40GX1)
 
 static int CheckForMasterAbort(void)
 {
@@ -360,19 +331,33 @@
 	return 0;
 }
 
-/* Write to config register */
-static int st40pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+static int st40pci_read_as_bytes(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 * val)
 {
+	volatile u8 part0,part1,part2,part3;
+
+	CheckForMasterAbort();
+
 	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 	switch (size) {
 		case 1:
 			*val = (u8)ST40PCI_READ_BYTE(PDR + (where & 3));
 			break;
 		case 2:
-			*val = (u16)ST40PCI_READ_SHORT(PDR + (where & 2));
+			part0 = ST40PCI_READ_BYTE(PDR + (where & 2));
+			udelay(2);
+			part1 = ST40PCI_READ_BYTE(PDR + (where & 2) + 1);
+			*val= (part0)| (part1<<8);
 			break;
 		case 4:
-			*val = ST40PCI_READ(PDR);
+			part0 = ST40PCI_READ_BYTE(PDR);
+			udelay(2);
+			part1 = ST40PCI_READ_BYTE(PDR+1);
+			udelay(2);
+			part2 = ST40PCI_READ_BYTE(PDR+2);
+			udelay(2);
+			part3 = ST40PCI_READ_BYTE(PDR+3);
+			*val = part0|(part1<<8)|(part2<<16)|(part3<<24);
 			break;
 	}
 
@@ -393,19 +378,32 @@
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int st40pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+static int st40pci_write_as_bytes(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 val)
 {
-	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 
+	CheckForMasterAbort();
+
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 	switch (size) {
 		case 1:
 			ST40PCI_WRITE_BYTE(PDR + (where & 3), (u8)val);
 			break;
 		case 2:
-			ST40PCI_WRITE_SHORT(PDR + (where & 2), (u16)val);
+			ST40PCI_WRITE_BYTE(PDR + (where & 2), (val & 0xff));
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR + (where & 2) + 1 , (val>>8) & 0xff);
+			udelay(2);
 			break;
 		case 4:
-			ST40PCI_WRITE(PDR, val);
+			ST40PCI_WRITE_BYTE(PDR, val & 0xff);
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+1, (val>>8) & 0xff );
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+2, (val>>16) & 0xff);
+			udelay(2);
+			ST40PCI_WRITE_BYTE(PDR+3, (val>>24) & 0xff);
+			udelay(2);
 			break;
 	}
 
@@ -415,74 +413,93 @@
 }
 
 struct pci_ops st40pci_config_ops = {
-	.read = 	st40pci_read,
-	.write = 	st40pci_write,
+	.read = 	st40pci_read_as_bytes,
+	.write = 	st40pci_write_as_bytes,
 };
 
+#else /* CONFIG_CPU_SUBTYPE_ST40STB1 || CONFIG_CPU_SUBTYPE_ST40GX1 */
 
-/* Everything hangs off this */
-static struct pci_bus *pci_root_bus;
-
-
-static u8 __init no_swizzle(struct pci_dev *dev, u8 * pin)
+static int st40pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
 {
-	return PCI_SLOT(dev->devfn);
-}
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
+	switch (size) {
+		case 1:
+			*val = (u8)ST40PCI_READ_BYTE(PDR + (where & 3));
+			break;
+		case 2:
+			*val = (u16)ST40PCI_READ_SHORT(PDR + (where & 2));
+			break;
+		case 4:
+			*val = ST40PCI_READ(PDR);
+			break;
+	}
 
+	return PCIBIOS_SUCCESSFUL;
+}
 
-static int __init pcibios_init(void)
+static int st40pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
 {
-	extern unsigned long memory_start, memory_end;
-
-	printk(KERN_ALERT "pci-st40.c: pcibios_init\n");
+	ST40PCI_WRITE(PAR, CONFIG_CMD(bus, devfn, where));
 
-	if (sh_mv.mv_init_pci != NULL) {
-		sh_mv.mv_init_pci();
+	switch (size) {
+		case 1:
+			ST40PCI_WRITE_BYTE(PDR + (where & 3), (u8)val);
+			break;
+		case 2:
+			ST40PCI_WRITE_SHORT(PDR + (where & 2), (u16)val);
+			break;
+		case 4:
+			ST40PCI_WRITE(PDR, val);
+			break;
 	}
 
-	/* The pci subsytem needs to know where memory is and how much 
-	 * of it there is. I've simply made these globals. A better mechanism
-	 * is probably needed.
-	 */
-	st40pci_init(PHYSADDR(memory_start),
-		     PHYSADDR(memory_end) - PHYSADDR(memory_start));
-
-	if (request_irq(ST40PCI_ERR_IRQ, st40_pci_irq, 
-                        SA_INTERRUPT, "st40pci", NULL)) {
-		printk(KERN_ERR "st40pci: Cannot hook interrupt\n");
-		return -EIO;
-	}
+	return PCIBIOS_SUCCESSFUL;
+}
 
-	/* Enable the PCI interrupts on the device */
-	ST40PCI_WRITE(INTM, ~0);
-	ST40PCI_WRITE(AINT, ~0);
+struct pci_ops st40pci_config_ops = {
+	.read = 	st40pci_read,
+	.write = 	st40pci_write,
+};
 
-	/* Map the io address apprioately */
-#ifdef CONFIG_HD64465
-	hd64465_port_map(PCIBIOS_MIN_IO, (64 * 1024) - PCIBIOS_MIN_IO + 1,
-			 ST40_IO_ADDR + PCIBIOS_MIN_IO, 0);
-#endif
+#endif /* CONFIG_CPU_SUBTYPE_ST40STB1 || CONFIG_CPU_SUBTYPE_ST40GX1 */
 
-	/* ok, do the scan man */
-	pci_root_bus = pci_scan_bus(0, &st40pci_config_ops, NULL);
-	pci_assign_unassigned_resources();
-	pci_fixup_irqs(no_swizzle, pcibios_map_platform_irq);
+static struct resource st40pci_io_resource = {
+	.name		= "ST40 PCI IO",
+	.start		= ST40_PCI_IO,
+	.end		= (64*1024) - 1,
+	.flags		= IORESOURCE_IO,
+};
 
-	return 0;
-}
+static struct resource st40pci_mem_resource = {
+	.name		= "ST40 PCI Mem",
+	.start		= ST40_PCI_MEM,
+	.end		= ST40_PCI_MEM + (96*1024*1024) - 1,
+	.flags		= IORESOURCE_MEM,
+};
 
-subsys_initcall(pcibios_init);
+struct pci_channel board_pci_channels[]={
+	{&st40pci_config_ops,&st40pci_io_resource,&st40pci_mem_resource,0,0},
+	{NULL,NULL,NULL,0,0}
+};
 
-void __init pcibios_fixup_bus(struct pci_bus *bus)
+static int __init st40pci_init(void)
 {
+	extern unsigned long memory_start, memory_end;
+
+	/* We could potentially do some checks here to make sure we can
+	 * access the host, eg checking for the host PAR and device ID */
+
+	return st40pci_host_init(memory_start, memory_end - memory_start);
 }
 
+arch_initcall(st40pci_init);
+
 /*
  * Publish a region of local address space over the PCI bus
  * to other devices.
  */
-static void pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
-			 unsigned long pciOffset, unsigned long regionSize)
+void st40pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
+			     unsigned long pciOffset, unsigned long regionSize)
 {
 	unsigned long mask;
 
@@ -507,3 +524,16 @@
 	ST40PCI_WRITE_INDEXED(RSR, region, mask | 1);
 }
 
+/*
+ * Make a previously published region of local address space
+ * inaccessible to other PCI devices.
+ */
+void st40pci_clear_rbar_region(unsigned int region)
+{
+	if (region > 7)
+		return;
+
+	ST40PCI_WRITE_INDEXED(RSR, region, 0);
+	ST40PCI_WRITE_INDEXED(RBAR, region, 0);
+	ST40PCI_WRITE_INDEXED(RLAR, region, 0);
+}
diff -Naur linux-2.6.17.8/arch/sh/drivers/pci/pci-st40.h linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-st40.h
--- linux-2.6.17.8/arch/sh/drivers/pci/pci-st40.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/drivers/pci/pci-st40.h	2006-08-23 13:29:29.638392000 +0100
@@ -2,7 +2,7 @@
  * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
  *
  * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
+ * License.  See linux/COPYING for more information.
  *
  * Defintions for the ST40 PCI hardware.
  */
@@ -10,6 +10,19 @@
 #ifndef __PCI_ST40_H__
 #define __PCI_ST40_H__
 
+#define ST40PCI_BASE_ADDRESS     (0xb0000000)
+#define ST40PCI_MEM_ADDRESS      (ST40PCI_BASE_ADDRESS+0x0)
+#define ST40PCI_IO_ADDRESS       (ST40PCI_BASE_ADDRESS+0x06000000)
+#define ST40PCI_REG_ADDRESS      (ST40PCI_BASE_ADDRESS+0x07000000)
+
+#define ST40_PCI_IO     0x2000
+#define ST40_PCI_MEM    0x10000000
+
+#define ST40PCI_SERR_IRQ	64
+#define ST40PCI_ERR_IRQ        	65
+#define ST40PCI_AD_IRQ		66
+#define ST40PCI_PWR_DWN_IRQ	67
+
 #define ST40PCI_VCR_STATUS    0x00
 
 #define ST40PCI_VCR_VERSION   0x08
@@ -121,16 +134,67 @@
 /* H8 specific registers end here */
 
 
+/* H8 specific registers start here */
+#define ST40PCI_WCBAR         0x7c
+#define ST40PCI_LOCCFG_UNLOCK 0x34
+
+#define ST40PCI_RBAR0         0x100
+#define ST40PCI_RSR0          0x104
+#define ST40PCI_RLAR0         0x108
+
+#define ST40PCI_RBAR1         0x110
+#define ST40PCI_RSR1          0x114
+#define ST40PCI_RLAR1         0x118
+
+
+#define ST40PCI_RBAR2         0x120
+#define ST40PCI_RSR2          0x124
+#define ST40PCI_RLAR2         0x128
+
+#define ST40PCI_RBAR3         0x130
+#define ST40PCI_RSR3          0x134
+#define ST40PCI_RLAR3         0x138
+
+#define ST40PCI_RBAR4         0x140
+#define ST40PCI_RSR4          0x144
+#define ST40PCI_RLAR4         0x148
+
+#define ST40PCI_RBAR5         0x150
+#define ST40PCI_RSR5          0x154
+#define ST40PCI_RLAR5         0x158
+
+#define ST40PCI_RBAR6         0x160
+#define ST40PCI_RSR6          0x164
+#define ST40PCI_RLAR6         0x168
+
+#define ST40PCI_RBAR7         0x170
+#define ST40PCI_RSR7          0x174
+#define ST40PCI_RLAR7         0x178
+
+
+#define ST40PCI_RBAR(n)      (0x100+(0x10*(n)))
+#define ST40PCI_RSR(n)       (0x104+(0x10*(n)))
+#define ST40PCI_RLAR(n)      (0x108+(0x10*(n)))
+
+#define ST40PCI_PERF               0x80
+#define PERF_MASTER_WRITE_POSTING  (1<<4)
+/* H8 specific registers end here */
+
 /* These are configs space registers */
-#define ST40PCI_CSR_VID               0x10000
-#define ST40PCI_CSR_DID               0x10002
-#define ST40PCI_CSR_CMD               0x10004
-#define ST40PCI_CSR_STATUS            0x10006
-#define ST40PCI_CSR_MBAR0             0x10010
-#define ST40PCI_CSR_TRDY              0x10040
-#define ST40PCI_CSR_RETRY             0x10041
-#define ST40PCI_CSR_MIT               0x1000d
+#define ST40PCI_CSR			0x10000
+#define ST40PCI_CSR_VID			(ST40PCI_CSR + 0x000)
+#define ST40PCI_CSR_DID			(ST40PCI_CSR + 0x002)
+#define ST40PCI_CSR_CMD			(ST40PCI_CSR + 0x004)
+#define ST40PCI_CSR_STATUS		(ST40PCI_CSR + 0x006)
+#define ST40PCI_CSR_MBAR0		(ST40PCI_CSR + 0x010)
+#define ST40PCI_CSR_TRDY		(ST40PCI_CSR + 0x040)
+#define ST40PCI_CSR_RETRY		(ST40PCI_CSR + 0x041)
+#define ST40PCI_CSR_MIT			(ST40PCI_CSR + 0x00d)
+
+/* Functions and data exported by pci-st40.c */
+void st40pci_set_rbar_region(unsigned int region,     unsigned long localAddr,
+			     unsigned long pciOffset, unsigned long regionSize);
+void st40pci_clear_rbar_region(unsigned int region);
 
-#define ST40_IO_ADDR 0xb6000000       
 
 #endif /* __PCI_ST40_H__ */
diff -Naur linux-2.6.17.8/arch/sh/Kconfig linux-2.6.17.8-sh/arch/sh/Kconfig
--- linux-2.6.17.8/arch/sh/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/Kconfig	2006-08-23 13:29:49.484852000 +0100
@@ -90,10 +90,135 @@
 	  7751R evaluation board.
 
 config SH_STB1_HARP
-	bool "STB1_Harp"
+	bool "STB1 Extended Harp"
+	select CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40STB1-ExtendedHarp if configuring for an
+	  STMicroelectronics Extended HARP (product code: ST40Harp+,
+	  ST board ID: mb350). More information at:
+	  <http://www.linuxsh.st.com/boards/mb350/>
 
 config SH_STB1_OVERDRIVE
-	bool "STB1_Overdrive"
+	bool "STB1 Overdrive"
+	select CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40STB1-Overdrive if configuring for an
+	  STMicroelectronics Overdrive  (product code: ST40STB1-ODrive,
+	  ST board ID: db457). More information at:
+	  <http://www.linuxsh.st.com/boards/db457/>
+
+config SH_ST40RA_EVAL
+	bool "ST40RA Eval"
+	select CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40RA-Eval if configuring for an
+	  STMicroelectronics ST40RA Eval Board (product code: ST40RA-Eval,
+	  ST board ID: mb360). More information at:
+	  <http://www.linuxsh.st.com/boards/mb360/>
+
+config SH_ST40RA_STARTER
+	bool "ST40RA Starter"
+	select CPU_SUBTYPE_ST40STB1
+	help
+	  Select ST40RA-Starter if configuring for an
+	  STMicroelectronics ST40RA Starter Board (also known as the
+	  ST40RA DDR Eval board) (product code: ST40RA-Starter,
+	  ST board ID: mb374). More information at:
+	  <http://www.linuxsh.st.com/boards/mb374/>
+
+config SH_ST40GX1_EVAL
+	bool "ST40GX1 Eval"
+	select CPU_SUBTYPE_ST40GX1
+	help
+	  Select ST40GX1-Demo if configuring for an
+	  STMicroelectronics GX1 Demo Board (product code: ST40GX1-Demo,
+	  ST board ID: mb317). More information at:
+	  <http://www.linuxsh.st.com/boards/mb317/>
+
+config SH_MEDIAREF_DEMO
+	bool "Mediaref"
+	select CPU_SUBTYPE_ST40GX1
+	help
+	  Select MediaRef if configuring for an
+	  STMicroelectronics/Futarque MediaRef Demo Board
+	  (ST product code: ST40Mediaref-Demo, Futarque board ID: 1070).
+	  More information at:
+	  <http://www.linuxsh.st.com/boards/1070/>
+
+config SH_MEDIAX_DEMO
+	bool "MediaX"
+	select CPU_SUBTYPE_ST40GX1
+	help
+	  Select MediaX if configuring for an
+	  STMicroelectronics/Futarque MediaX Demo Board
+	  (ST product code: ST40MediaX-Demo, Futarque board ID: 3700).
+	  More information at:
+	  <http://www.linuxsh.st.com/boards/1070/>
+
+config SH_STI5528_EVAL
+	bool "STi5528 Eval"
+	select CPU_SUBTYPE_STI5528
+	help
+	  Select STi5528 Eval if configuring for an
+	  STMicroelectronics STi5528 Eval Board (product code: STi5528-Eval,
+	  ST board ID: mb376). More information at:
+	  <http://www.linuxsh.st.com/boards/mb376/>
+
+config SH_STI5528_ESPRESSO
+	bool "STi5528 Espresso"
+	select CPU_SUBTYPE_STI5528
+	help
+	  Select STi5528 Espresso if configuring for an
+	  STMicroelectronics/CiaoLAB Espresso reference platform.
+	  (ST product code: Espresso).
+	  More information at:
+	  <http://www.linuxsh.st.com/boards/espresso/>
+
+config SH_STM8000_DEMO
+	bool "STm8000 Demo"
+	select CPU_SUBTYPE_STM8000
+	help
+	  Select STm8000 Demo if configuring for an
+	  STMicroelectronics STm8000 Demo Board (product code: STm8000-Demo,
+	  ST board ID: mb379). More information at:
+	  <http://www.linuxsh.st.com/boards/mb379/>
+
+config SH_ST220_EVAL
+	bool "ST220 Eval"
+	select CPU_SUBTYPE_STM8000
+	help
+	  Select ST220 Eval if configuring for an
+	  STMicroelectronics ST220 Eval Board (product code: ST220-Eval,
+	  ST board ID: mb392). More information at:
+	  <http://www.linuxsh.st.com/boards/mb392/>
+
+config SH_STB7100_MBOARD
+	bool "STB7100 Validation board"
+	select CPU_SUBTYPE_STB7100
+	help
+	  Select STB7100 Validation if configuring for an
+	  STMicroelectronics STB7100 Validation Board (product code: STB7100-MBOARD,
+	  ST board ID: mb411). More information at:
+	  <http://www.linuxsh.st.com/boards/mb411/>
+
+config SH_STB7100_REF
+	bool "STB7100 Reference board"
+	select CPU_SUBTYPE_STB7100
+	help
+	  Select STB7100 Reference if configuring for an
+	  STMicroelectronics STB7100 Reference Board (product code: STB7100-REF).
+	  This is sometimes referred to as the CoCo board.
+	  More information at:
+	  <http://www.linuxsh.st.com/boards/stb7100ref/>
+
+config SH_STB7109E_REF
+	bool "STB7109E Reference board"
+	select CPU_SUBTYPE_STB7100
+	help
+	  Select STB7109E Reference if configuring for an
+	  STMicroelectronics STB7109E Reference Board (product code: STB7109E-REF,
+	  ST board ID: mb448). More information at:
+	  <http://www.linuxsh.st.com/boards/mb448/>
 
 config SH_HP6XX
 	bool "HP6XX"
@@ -236,33 +361,35 @@
 
 endchoice
 
+config SH_MEDIAREF
+	bool
+	depends on SH_MEDIAREF_DEMO || SH_MEDIAX_DEMO
+	default y
+
 source "arch/sh/mm/Kconfig"
 
-config MEMORY_START
-	hex "Physical memory start address"
-	default "0x08000000"
+config BIGPHYS_AREA
+        bool "Big Physical Area"
+        ---help---
+          Enables kernel support for reserving large areas of physical
+          memory at boot-time for use by certain device drivers (such as
+          video framegrabbers, etc.) which require it. To use this
+          feature, boot the kernel with the boot-time option
+          'bigphysarea=nnn' where 'nnn' is the number of pages (a page
+          is usually 4K) to reserve.
+
+          See <file:Documentation/bigphysarea.txt> for more information.
+
+menu "STMicroelectronics Advanced Features"
+        depends on CPU_SUBTYPE_ST40 && EXPERIMENTAL
+
+config STM_GRB
+        bool "ST Atomic gRB (EXPERIMENTAL)"
+	default n
 	---help---
-	  Computers built with Hitachi SuperH processors always
-	  map the ROM starting at address zero.  But the processor
-	  does not specify the range that RAM takes.
-
-	  The physical memory (RAM) start address will be automatically
-	  set to 08000000. Other platforms, such as the Solution Engine
-	  boards typically map RAM at 0C000000.
-
-	  Tweak this only when porting to a new machine which does not
-	  already have a defconfig. Changing it from the known correct
-	  value on any of the known systems will only lead to disaster.
-
-config MEMORY_SIZE
-	hex "Physical memory size"
-	default "0x00400000"
-	help
-	  This sets the default memory size assumed by your SH kernel. It can
-	  be overridden as normal by the 'mem=' argument on the kernel command
-	  line. If unsure, consult your board specifications or just leave it
-	  as 0x00400000 which was the default value before this became
-	  configurable.
+          Enable this option to use atomic roll back support in the kernel
+
+endmenu
 
 config CF_ENABLER
 	bool "Compact Flash Enabler support"
@@ -321,7 +448,8 @@
 	bool
 	depends on !SH_DREAMCAST && !SH_SATURN && !SH_7300_SOLUTION_ENGINE && \
 		   !SH_73180_SOLUTION_ENGINE && !SH_LANDISK && \
-		   !SH_R7780RP
+		   !SH_R7780RP && !CPU_SUBTYPE_STI5528 && !CPU_SUBTYPE_STM8000 && \
+		   !CPU_SUBTYPE_STB7100
 	default y
 	help
 	  Selecting this option will allow the Linux kernel to emulate
@@ -329,6 +457,12 @@
 
 	  If unsure, say N.
 
+config SH_RTC_ST
+	bool
+	depends CPU_SUBTYPE_STI5528 || CPU_SUBTYPE_STM8000 || \
+		CPU_SUBTYPE_STB7100
+	default y
+
 config SH_FPU
 	bool "FPU support"
 	depends on !CPU_SH3
@@ -339,6 +473,15 @@
 
 	  This option must be set in order to enable the FPU.
 
+config SH_FPU_EMU
+	bool "FPU emulation support"
+	depends on !SH_FPU && EXPERIMENTAL
+	default n
+	help
+	  Selecting this option will enable support for software FPU emulation.
+	  Most SH-3 users will want to say Y here, whereas most SH-4 users will
+	  want to say N.
+
 config SH_DSP
 	bool "DSP support"
 	depends on !CPU_SH4
@@ -400,9 +543,11 @@
 
 endmenu
 
-#source "arch/sh/boards/renesas/hs7751rvoip/Kconfig"
+source "arch/sh/boards/renesas/hs7751rvoip/Kconfig"
+
+source "arch/sh/boards/renesas/rts7751r2d/Kconfig"
 
-#source "arch/sh/boards/renesas/rts7751r2d/Kconfig"
+source "arch/sh/boards/renesas/r7780rp/Kconfig"
 
 config SH_PCLK_FREQ
 	int "Peripheral clock frequency (in Hz)"
@@ -416,6 +561,30 @@
 	  This is necessary for determining the reference clock value on
 	  platforms lacking an RTC.
 
+config SH_EXTERNAL_CLOCK
+	int "External clock"
+	depends on CPU_SUBTYPE_STB7100
+	default "30000000" if SH_STB7100_REF
+	default "27000000"
+	help
+	  The kernel needs to know what the frequency of chip's external
+	  clock is, so that it can calculate what frequency the internal
+	  clocks are running at.
+
+	  The usual symptoms of getting this wrong are the serial port
+	  output being corrupted.
+
+config SH_FAST_HZ
+	bool "Fast kernel tick"
+	default n
+	help
+	  Enabling this option will increase the rate at which the kernel's
+	  internal timer ticks from 100Hz to 1000Hz. This will increase the
+	  accuracy of the kernel's internal time, at the expense of a higher
+	  interrupt load.
+
+	  This option needs to be set to use the SH watchdog.
+
 menu "CPU Frequency scaling"
 
 source "drivers/cpufreq/Kconfig"
@@ -440,11 +609,29 @@
 
 config HEARTBEAT
 	bool "Heartbeat LED"
-	depends on SH_MPC1211 || SH_SH03 || SH_CAT68701 || \
-		   SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || \
-		   SH_7751_SOLUTION_ENGINE || SH_7300_SOLUTION_ENGINE || \
-		   SH_73180_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || \
-		   SH_RTS7751R2D || SH_SH4202_MICRODEV || SH_LANDISK
+	depends on \
+		SH_SH03 || \
+		SH_7300_SOLUTION_ENGINE || \
+		SH_73180_SOLUTION_ENGINE || \
+		SH_7751_SOLUTION_ENGINE || \
+		SH_BIGSUR || \
+		SH_CAT68701 || \
+		SH_LANDISK || \
+		SH_MEDIAX_DEMO || \
+		SH_MPC1211 || \
+		SH_RTS7751R2D || \
+		SH_SH4202_MICRODEV || \
+		SH_SOLUTION_ENGINE || \
+		SH_ST220_EVAL || \
+		SH_ST40RA_STARTER || \
+		SH_ST40GX1_EVAL || \
+		SH_ST40RA_EVAL || \
+		SH_STB1_HARP || \
+		SH_STB1_OVERDRIVE || \
+		SH_STB7100_MBOARD || \
+		SH_STI5528_ESPRESSO || \
+		SH_STI5528_EVAL || \
+		SH_STM8000_DEMO
 	help
 	  Use the power-on LED on your machine as a load meter.  The exact
 	  behavior is platform-dependent, but normally the flash frequency is
@@ -543,6 +730,25 @@
 	help
 	  This sets the default offset of zero page.
 
+config ZIMAGE_ROM
+        bool "zImage address start"
+        help
+          This option allows you to choose the address where the compressed
+          kernel image will be built for. Normally this is used when booting
+          the kernel directly from ROM, and running the kernel decompression
+          code directly from the ROM (rather than moving it into RAM first).
+
+          This option is only usued when building a kernel with a built in
+          decompression header, for example when using 'make zImage'.
+
+config ZIMAGE_ROM_START
+        depends on ZIMAGE_ROM
+        hex "Compressed kernel image in ROM"
+        default "0x00040000"
+        help
+          Set this to the offset from the start of memory where the
+          compressed kernel image will reside.
+
 config BOOT_LINK_OFFSET
 	hex "Link address offset for booting"
 	default "0x00800000"
@@ -563,6 +769,10 @@
 
 config CMDLINE_BOOL
 	bool "Default bootloader kernel arguments"
+	help
+	  Setting this option allows the kernel command line arguments to
+	  be set. These will overwrite any arguments passed in by a
+	  bootloader.
 
 config CMDLINE
 	string "Initial kernel command string"
@@ -636,6 +846,16 @@
 
 endmenu
 
+menu "Power management options (EXPERIMENTAL)"
+depends on EXPERIMENTAL
+
+source kernel/power/Kconfig
+
+config APM
+	bool "Advanced Power Management Emulation"
+	depends on PM
+endmenu
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -Naur linux-2.6.17.8/arch/sh/Kconfig.debug linux-2.6.17.8-sh/arch/sh/Kconfig.debug
--- linux-2.6.17.8/arch/sh/Kconfig.debug	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/Kconfig.debug	2006-08-23 13:29:49.504852000 +0100
@@ -32,6 +32,7 @@
 
 config KGDB
 	bool "Include KGDB kernel debugger"
+	select FRAME_POINTER
 	help
 	  Include in-kernel hooks for kgdb, the Linux kernel source level
 	  debugger.  See <http://kgdb.sourceforge.net/> for more information.
@@ -110,15 +111,41 @@
 
 endchoice
 
-endmenu
-
-config FRAME_POINTER
-	bool "Compile the kernel with frame pointers"
-	default y if KGDB
+config DEBUG_STACK_USAGE
+	bool "Enable stack utilization instrumentation"
 	help
-	  If you say Y here the resulting kernel image will be slightly larger
-	  and slower, but it will give very useful debugging information.
-	  If you don't debug the kernel, you can say N, but we may not be able
-	  to solve problems without frame pointers.
+	  Enables the display of the minimum amount of free stack which each
+	  task has ever had available in the sysrq-T and sysrq-P debug output.
+
+	  This option will slow down process creation somewhat.
+
+config DEBUG_STACKOVERFLOW
+	bool "Stack Overflow Detection Support"
+
+config 4KSTACKS
+	depends on CPU_SH4 && EXPERIMENTAL
+        bool "Use 4Kb for kernel stacks instead of 8Kb (EXPERIMENTAL)"
+        help
+          If you say Y here the kernel will use a 4Kb stacksize for the
+          kernel stack attached to each process/thread. This facilitates
+          running more threads on a system and also reduces the pressure
+          on the VM subsystem for higher order allocations. This option
+          will also use IRQ stacks to compensate for the reduced stackspace.
+
+config HARDIRQ_STACK_SIZE
+        depends on 4KSTACKS
+        hex "Hard IRQ Stack size"
+        default "0x1000"
+        help
+          Set the Hard irq stack size when the 4K thread stack size is enabled
+
+config SOFTIRQ_STACK_SIZE
+        depends on 4KSTACKS
+        hex "Soft IRQ Stack size"
+        default "0x1000"
+        help
+	  Set the Soft irq stack size when the 4K thread stack size is enabled
+
+endmenu
 
 endmenu
diff -Naur linux-2.6.17.8/arch/sh/kernel/apm.c linux-2.6.17.8-sh/arch/sh/kernel/apm.c
--- linux-2.6.17.8/arch/sh/kernel/apm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/apm.c	2006-08-23 13:29:22.707233000 +0100
@@ -0,0 +1,539 @@
+/*
+ * bios-less APM driver for hp680
+ *
+ * Copyright 2005 (c) Andriy Skulysh <askulysh@gmail.com>
+ *
+ * based on ARM APM driver by
+ *  Jamey Hicks <jamey@crl.dec.com>
+ *
+ * adapted from the APM BIOS driver for Linux by
+ *  Stephen Rothwell (sfr@linuxcare.com)
+ *
+ * APM 1.2 Reference:
+ *   Intel Corporation, Microsoft Corporation. Advanced Power Management
+ *   (APM) BIOS Interface Specification, Revision 1.2, February 1996.
+ *
+ * [This document is available from Microsoft at:
+ *    http://www.microsoft.com/hwdev/busbios/amp_12.htm]
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/miscdevice.h>
+#include <linux/apm_bios.h>
+#include <linux/pm.h>
+#include <linux/pm_legacy.h>
+#include <asm/apm.h>
+
+#define MODNAME "apm"
+
+/*
+ * The apm_bios device is one of the misc char devices.
+ * This is its minor number.
+ */
+#define APM_MINOR_DEV			134
+
+/*
+ * Maximum number of events stored
+ */
+#define APM_MAX_EVENTS			16
+
+struct apm_queue {
+	unsigned int		event_head;
+	unsigned int		event_tail;
+	apm_event_t		events[APM_MAX_EVENTS];
+};
+
+/*
+ * The per-file APM data
+ */
+struct apm_user {
+	struct list_head	list;
+
+	unsigned int		suser: 1;
+	unsigned int		writer: 1;
+	unsigned int		reader: 1;
+
+	int			suspend_result;
+	unsigned int		suspend_state;
+#define SUSPEND_NONE	0		/* no suspend pending */
+#define SUSPEND_PENDING	1		/* suspend pending read */
+#define SUSPEND_READ	2		/* suspend read, pending ack */
+#define SUSPEND_ACKED	3		/* suspend acked */
+#define SUSPEND_DONE	4		/* suspend completed */
+
+	struct apm_queue	queue;
+};
+
+/*
+ * Local variables
+ */
+static int suspends_pending;
+
+static DECLARE_WAIT_QUEUE_HEAD(apm_waitqueue);
+static DECLARE_WAIT_QUEUE_HEAD(apm_suspend_waitqueue);
+
+/*
+ * This is a list of everyone who has opened /dev/apm_bios
+ */
+static DECLARE_RWSEM(user_list_lock);
+static LIST_HEAD(apm_user_list);
+
+/*
+ * kapmd info.  kapmd provides us a process context to handle
+ * "APM" events within - specifically necessary if we're going
+ * to be suspending the system.
+ */
+static DECLARE_WAIT_QUEUE_HEAD(kapmd_wait);
+static DECLARE_COMPLETION(kapmd_exit);
+static DEFINE_SPINLOCK(kapmd_queue_lock);
+static struct apm_queue kapmd_queue;
+
+int apm_suspended;
+EXPORT_SYMBOL(apm_suspended);
+
+/* Platform-specific apm_read_proc(). */
+int (*apm_get_info)(char *buf, char **start, off_t fpos, int length);
+EXPORT_SYMBOL(apm_get_info);
+
+/*
+ * APM event queue management.
+ */
+static inline int queue_empty(struct apm_queue *q)
+{
+	return q->event_head == q->event_tail;
+}
+
+static inline apm_event_t queue_get_event(struct apm_queue *q)
+{
+	q->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;
+	return q->events[q->event_tail];
+}
+
+static void queue_add_event(struct apm_queue *q, apm_event_t event)
+{
+	q->event_head = (q->event_head + 1) % APM_MAX_EVENTS;
+	if (q->event_head == q->event_tail) {
+		static int notified;
+
+		if (notified++ == 0)
+			printk(KERN_ERR "apm: an event queue overflowed\n");
+
+		q->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;
+	}
+	q->events[q->event_head] = event;
+}
+
+static void queue_event_one_user(struct apm_user *as, apm_event_t event)
+{
+	if (as->suser && as->writer) {
+		switch (event) {
+		case APM_SYS_SUSPEND:
+		case APM_USER_SUSPEND:
+			/*
+			 * If this user already has a suspend pending,
+			 * don't queue another one.
+			 */
+			if (as->suspend_state != SUSPEND_NONE)
+				return;
+
+			as->suspend_state = SUSPEND_PENDING;
+			suspends_pending++;
+			break;
+		}
+	}
+	queue_add_event(&as->queue, event);
+}
+
+static void queue_event(apm_event_t event, struct apm_user *sender)
+{
+	struct apm_user *as;
+
+	down_read(&user_list_lock);
+
+	list_for_each_entry(as, &apm_user_list, list)
+		if (as != sender && as->reader)
+			queue_event_one_user(as, event);
+
+	up_read(&user_list_lock);
+	wake_up_interruptible(&apm_waitqueue);
+}
+
+/**
+ * apm_queue_event - queue an APM event for kapmd
+ * @event: APM event
+ *
+ * Queue an APM event for kapmd to process and ultimately take the
+ * appropriate action.  Only a subset of events are handled:
+ *   %APM_LOW_BATTERY
+ *   %APM_POWER_STATUS_CHANGE
+ *   %APM_USER_SUSPEND
+ *   %APM_SYS_SUSPEND
+ *   %APM_CRITICAL_SUSPEND
+ */
+void apm_queue_event(apm_event_t event)
+{
+	spin_lock_irq(&kapmd_queue_lock);
+	queue_add_event(&kapmd_queue, event);
+	spin_unlock_irq(&kapmd_queue_lock);
+
+	wake_up_interruptible(&kapmd_wait);
+}
+EXPORT_SYMBOL(apm_queue_event);
+
+static void apm_suspend(void)
+{
+	struct apm_user *as;
+	int err;
+
+	apm_suspended = 1;
+	err = pm_suspend(PM_SUSPEND_MEM);
+
+	/*
+	 * Anyone on the APM queues will think we're still suspended.
+	 * Send a message so everyone knows we're now awake again.
+	 */
+	queue_event(APM_NORMAL_RESUME, NULL);
+
+	/*
+	 * Finally, wake up anyone who is sleeping on the suspend.
+	 */
+	down_read(&user_list_lock);
+	list_for_each_entry(as, &apm_user_list, list) {
+		as->suspend_result = err;
+		as->suspend_state = SUSPEND_DONE;
+	}
+	up_read(&user_list_lock);
+
+	wake_up(&apm_suspend_waitqueue);
+	apm_suspended = 0;
+}
+
+static ssize_t apm_read(struct file *fp, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	struct apm_user *as = fp->private_data;
+	apm_event_t event;
+	int i = count, ret = 0;
+
+	if (count < sizeof(apm_event_t))
+		return -EINVAL;
+
+	if (queue_empty(&as->queue) && fp->f_flags & O_NONBLOCK)
+		return -EAGAIN;
+
+	wait_event_interruptible(apm_waitqueue, !queue_empty(&as->queue));
+
+	while ((i >= sizeof(event)) && !queue_empty(&as->queue)) {
+		event = queue_get_event(&as->queue);
+
+		ret = -EFAULT;
+		if (copy_to_user(buf, &event, sizeof(event)))
+			break;
+
+		if (event == APM_SYS_SUSPEND || event == APM_USER_SUSPEND)
+			as->suspend_state = SUSPEND_READ;
+
+		buf += sizeof(event);
+		i -= sizeof(event);
+	}
+
+	if (i < count)
+		ret = count - i;
+
+	return ret;
+}
+
+static unsigned int apm_poll(struct file *fp, poll_table * wait)
+{
+	struct apm_user *as = fp->private_data;
+
+	poll_wait(fp, &apm_waitqueue, wait);
+	return queue_empty(&as->queue) ? 0 : POLLIN | POLLRDNORM;
+}
+
+/*
+ * apm_ioctl - handle APM ioctl
+ *
+ * APM_IOC_SUSPEND
+ *   This IOCTL is overloaded, and performs two functions.  It is used to:
+ *     - initiate a suspend
+ *     - acknowledge a suspend read from /dev/apm_bios.
+ *   Only when everyone who has opened /dev/apm_bios with write permission
+ *   has acknowledge does the actual suspend happen.
+ */
+static int
+apm_ioctl(struct inode * inode, struct file *filp, u_int cmd, u_long arg)
+{
+	struct apm_user *as = filp->private_data;
+	unsigned long flags;
+	int err = -EINVAL;
+
+	if (!as->suser || !as->writer)
+		return -EPERM;
+
+	switch (cmd) {
+	case APM_IOC_SUSPEND:
+		as->suspend_result = -EINTR;
+
+		if (as->suspend_state == SUSPEND_READ) {
+			/*
+			 * If we read a suspend command from /dev/apm_bios,
+			 * then the corresponding APM_IOC_SUSPEND ioctl is
+			 * interpreted as an acknowledge.
+			 */
+			as->suspend_state = SUSPEND_ACKED;
+			suspends_pending--;
+		} else {
+			/*
+			 * Otherwise it is a request to suspend the system.
+			 * Queue an event for all readers, and expect an
+			 * acknowledge from all writers who haven't already
+			 * acknowledged.
+			 */
+			queue_event(APM_USER_SUSPEND, as);
+		}
+
+		/*
+		 * If there are no further acknowledges required, suspend
+		 * the system.
+		 */
+		if (suspends_pending == 0)
+			apm_suspend();
+
+		/*
+		 * Wait for the suspend/resume to complete.  If there are
+		 * pending acknowledges, we wait here for them.
+		 *
+		 * Note that we need to ensure that the PM subsystem does
+		 * not kick us out of the wait when it suspends the threads.
+		 */
+		flags = current->flags;
+		current->flags |= PF_NOFREEZE;
+
+		/*
+		 * Note: do not allow a thread which is acking the suspend
+		 * to escape until the resume is complete.
+		 */
+		if (as->suspend_state == SUSPEND_ACKED)
+			wait_event(apm_suspend_waitqueue,
+					 as->suspend_state == SUSPEND_DONE);
+		else
+			wait_event_interruptible(apm_suspend_waitqueue,
+					 as->suspend_state == SUSPEND_DONE);
+
+		current->flags = flags;
+		err = as->suspend_result;
+		as->suspend_state = SUSPEND_NONE;
+		break;
+	}
+
+	return err;
+}
+
+static int apm_release(struct inode * inode, struct file * filp)
+{
+	struct apm_user *as = filp->private_data;
+	filp->private_data = NULL;
+
+	down_write(&user_list_lock);
+	list_del(&as->list);
+	up_write(&user_list_lock);
+
+	/*
+	 * We are now unhooked from the chain.  As far as new
+	 * events are concerned, we no longer exist.  However, we
+	 * need to balance suspends_pending, which means the
+	 * possibility of sleeping.
+	 */
+	if (as->suspend_state != SUSPEND_NONE) {
+		suspends_pending -= 1;
+		if (suspends_pending == 0)
+			apm_suspend();
+	}
+
+	kfree(as);
+	return 0;
+}
+
+static int apm_open(struct inode * inode, struct file * filp)
+{
+	struct apm_user *as;
+
+	as = kzalloc(sizeof(*as), GFP_KERNEL);
+	if (as) {
+		/*
+		 * XXX - this is a tiny bit broken, when we consider BSD
+		 * process accounting. If the device is opened by root, we
+		 * instantly flag that we used superuser privs. Who knows,
+		 * we might close the device immediately without doing a
+		 * privileged operation -- cevans
+		 */
+		as->suser = capable(CAP_SYS_ADMIN);
+		as->writer = (filp->f_mode & FMODE_WRITE) == FMODE_WRITE;
+		as->reader = (filp->f_mode & FMODE_READ) == FMODE_READ;
+
+		down_write(&user_list_lock);
+		list_add(&as->list, &apm_user_list);
+		up_write(&user_list_lock);
+
+		filp->private_data = as;
+	}
+
+	return as ? 0 : -ENOMEM;
+}
+
+static struct file_operations apm_bios_fops = {
+	.owner		= THIS_MODULE,
+	.read		= apm_read,
+	.poll		= apm_poll,
+	.ioctl		= apm_ioctl,
+	.open		= apm_open,
+	.release	= apm_release,
+};
+
+static struct miscdevice apm_device = {
+	.minor		= APM_MINOR_DEV,
+	.name		= "apm_bios",
+	.fops		= &apm_bios_fops
+};
+
+
+#ifdef CONFIG_PROC_FS
+/*
+ * Arguments, with symbols from linux/apm_bios.h.
+ *
+ *   0) Linux driver version (this will change if format changes)
+ *   1) APM BIOS Version.  Usually 1.0, 1.1 or 1.2.
+ *   2) APM flags from APM Installation Check (0x00):
+ *	bit 0: APM_16_BIT_SUPPORT
+ *	bit 1: APM_32_BIT_SUPPORT
+ *	bit 2: APM_IDLE_SLOWS_CLOCK
+ *	bit 3: APM_BIOS_DISABLED
+ *	bit 4: APM_BIOS_DISENGAGED
+ *   3) AC line status
+ *	0x00: Off-line
+ *	0x01: On-line
+ *	0x02: On backup power (BIOS >= 1.1 only)
+ *	0xff: Unknown
+ *   4) Battery status
+ *	0x00: High
+ *	0x01: Low
+ *	0x02: Critical
+ *	0x03: Charging
+ *	0x04: Selected battery not present (BIOS >= 1.2 only)
+ *	0xff: Unknown
+ *   5) Battery flag
+ *	bit 0: High
+ *	bit 1: Low
+ *	bit 2: Critical
+ *	bit 3: Charging
+ *	bit 7: No system battery
+ *	0xff: Unknown
+ *   6) Remaining battery life (percentage of charge):
+ *	0-100: valid
+ *	-1: Unknown
+ *   7) Remaining battery life (time units):
+ *	Number of remaining minutes or seconds
+ *	-1: Unknown
+ *   8) min = minutes; sec = seconds
+ */
+static int apm_read_proc(char *buf, char **start, off_t fpos, int length)
+{
+	if (likely(apm_get_info))
+		return apm_get_info(buf, start, fpos, length);
+
+	return -EINVAL;
+}
+#endif
+
+static int kapmd(void *arg)
+{
+	daemonize("kapmd");
+	current->flags |= PF_NOFREEZE;
+
+	do {
+		apm_event_t event;
+
+		wait_event_interruptible(kapmd_wait,
+				!queue_empty(&kapmd_queue) || !pm_active);
+
+		if (!pm_active)
+			break;
+
+		spin_lock_irq(&kapmd_queue_lock);
+		event = 0;
+		if (!queue_empty(&kapmd_queue))
+			event = queue_get_event(&kapmd_queue);
+		spin_unlock_irq(&kapmd_queue_lock);
+
+		switch (event) {
+		case 0:
+			break;
+
+		case APM_LOW_BATTERY:
+		case APM_POWER_STATUS_CHANGE:
+			queue_event(event, NULL);
+			break;
+
+		case APM_USER_SUSPEND:
+		case APM_SYS_SUSPEND:
+			queue_event(event, NULL);
+			if (suspends_pending == 0)
+				apm_suspend();
+			break;
+
+		case APM_CRITICAL_SUSPEND:
+			apm_suspend();
+			break;
+		}
+	} while (1);
+
+	complete_and_exit(&kapmd_exit, 0);
+}
+
+static int __init apm_init(void)
+{
+	int ret;
+
+	pm_active = 1;
+
+	ret = kernel_thread(kapmd, NULL, CLONE_KERNEL);
+	if (unlikely(ret < 0)) {
+		pm_active = 0;
+		return ret;
+	}
+
+	create_proc_info_entry("apm", 0, NULL, apm_read_proc);
+
+	ret = misc_register(&apm_device);
+	if (unlikely(ret != 0)) {
+		remove_proc_entry("apm", NULL);
+
+		pm_active = 0;
+		wake_up(&kapmd_wait);
+		wait_for_completion(&kapmd_exit);
+	}
+
+	return ret;
+}
+
+static void __exit apm_exit(void)
+{
+	misc_deregister(&apm_device);
+	remove_proc_entry("apm", NULL);
+
+	pm_active = 0;
+	wake_up(&kapmd_wait);
+	wait_for_completion(&kapmd_exit);
+}
+
+module_init(apm_init);
+module_exit(apm_exit);
+
+MODULE_AUTHOR("Stephen Rothwell, Andriy Skulysh");
+MODULE_DESCRIPTION("Advanced Power Management");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/arch/sh/kernel/cf-enabler.c linux-2.6.17.8-sh/arch/sh/kernel/cf-enabler.c
--- linux-2.6.17.8/arch/sh/kernel/cf-enabler.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cf-enabler.c	2006-08-23 13:29:18.646140000 +0100
@@ -11,7 +11,8 @@
 
 #include <linux/config.h>
 #include <linux/init.h>
-
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -33,8 +34,6 @@
 /* SH4 can't access PCMCIA interface through P2 area.
  * we must remap it with appropreate attribute bit of the page set.
  * this part is based on Greg Banks' hd64465_ss.c implementation - Masahiro Abe */
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
 
 #if defined(CONFIG_CF_AREA6)
 #define slot_no 0
@@ -42,9 +41,6 @@
 #define slot_no 1
 #endif
 
-/* defined in mm/ioremap.c */
-extern void * p3_ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags);
-
 /* use this pointer to access to directly connected compact flash io area*/
 void *cf_io_base;
 
@@ -63,7 +59,7 @@
 		return -ENOMEM;
 	}
 /*	printk("p3_ioremap(paddr=0x%08lx, psize=0x%08lx, prot=0x%08lx)=0x%08lx\n",
-	    	paddrbase, psize, prot.pgprot, cf_io_base);*/
+		paddrbase, psize, prot.pgprot, cf_io_base);*/
 
 	/* XXX : do we need attribute and common-memory area also? */
 
@@ -88,7 +84,7 @@
 }
 
 #if defined(CONFIG_SH_SOLUTION_ENGINE)
-#include <asm/se/se.h>
+#include <asm/se.h>
 
 /*
  * SolutionEngine
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/clock.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/clock.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/clock.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/clock.c	2006-08-23 13:29:30.903415000 +0100
@@ -26,49 +26,6 @@
 static DEFINE_SPINLOCK(clock_lock);
 static DECLARE_MUTEX(clock_list_sem);
 
-/*
- * Each subtype is expected to define the init routines for these clocks,
- * as each subtype (or processor family) will have these clocks at the
- * very least. These are all provided through the CPG, which even some of
- * the more quirky parts (such as ST40, SH4-202, etc.) still have.
- *
- * The processor-specific code is expected to register any additional
- * clock sources that are of interest.
- */
-static struct clk master_clk = {
-	.name		= "master_clk",
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-	.rate		= CONFIG_SH_PCLK_FREQ,
-};
-
-static struct clk module_clk = {
-	.name		= "module_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-};
-
-static struct clk bus_clk = {
-	.name		= "bus_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-};
-
-static struct clk cpu_clk = {
-	.name		= "cpu_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED,
-};
-
-/*
- * The ordering of these clocks matters, do not change it.
- */
-static struct clk *onchip_clocks[] = {
-	&master_clk,
-	&module_clk,
-	&bus_clk,
-	&cpu_clk,
-};
-
 static void propagate_rate(struct clk *clk)
 {
 	struct clk *clkp;
@@ -216,32 +173,6 @@
 		module_put(clk->owner);
 }
 
-void __init __attribute__ ((weak))
-arch_init_clk_ops(struct clk_ops **ops, int type)
-{
-}
-
-int __init clk_init(void)
-{
-	int i, ret = 0;
-
-	BUG_ON(unlikely(!master_clk.rate));
-
-	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
-		struct clk *clk = onchip_clocks[i];
-
-		arch_init_clk_ops(&clk->ops, i);
-		ret |= clk_register(clk);
-		clk_enable(clk);
-	}
-
-	/* Kick the child clocks.. */
-	propagate_rate(&master_clk);
-	propagate_rate(&bus_clk);
-
-	return ret;
-}
-
 int show_clocks(struct seq_file *m)
 {
 	struct clk *clk;
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/clock-cpg.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/clock-cpg.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/clock-cpg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/clock-cpg.c	2006-08-23 13:29:30.911415000 +0100
@@ -0,0 +1,92 @@
+/*
+ * arch/sh/kernel/cpu/clock-cpg.c - SuperH clock framework for CPG style clocks
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This clock framework is derived from the OMAP version by:
+ *
+ *	Copyright (C) 2004 Nokia Corporation
+ *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/kref.h>
+#include <linux/seq_file.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/timer.h>
+
+/*
+ * Each subtype is expected to define the init routines for these clocks,
+ * as each subtype (or processor family) will have these clocks at the
+ * very least. These are all provided through the CPG, which even some of
+ * the more quirky parts (such as ST40, SH4-202, etc.) still have.
+ *
+ * The processor-specific code is expected to register any additional
+ * clock sources that are of interest.
+ */
+static struct clk master_clk = {
+	.name		= "master_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.rate		= CONFIG_SH_PCLK_FREQ,
+};
+
+static struct clk module_clk = {
+	.name		= "module_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk bus_clk = {
+	.name		= "bus_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk cpu_clk = {
+	.name		= "cpu_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED,
+};
+
+/*
+ * The ordering of these clocks matters, do not change it.
+ */
+static struct clk *onchip_clocks[] = {
+	&master_clk,
+	&module_clk,
+	&bus_clk,
+	&cpu_clk,
+};
+
+void __init __attribute__ ((weak))
+arch_init_clk_ops(struct clk_ops **ops, int type)
+{
+}
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	BUG_ON(!master_clk.rate);
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		arch_init_clk_ops(&clk->ops, i);
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Kick the child clocks.. */
+	propagate_rate(&master_clk);
+	propagate_rate(&bus_clk);
+
+	return ret;
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/init.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/init.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/init.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/init.c	2006-08-23 13:29:12.850001000 +0100
@@ -4,6 +4,7 @@
  * CPU init code
  *
  * Copyright (C) 2002, 2003  Paul Mundt
+ * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -51,7 +52,15 @@
 	ccr = ctrl_inl(CCR);
 
 	/*
-	 * If the cache is already enabled .. flush it.
+	 * At this point we don't know whether the cache is enabled or not - a
+	 * bootloader may have enabled it.  There are at least 2 things that
+	 * could be dirty in the cache at this point:
+	 * 1. kernel command line set up by boot loader
+	 * 2. spilled registers from the prolog of this function
+	 * => before re-initialising the cache, we must do a purge of the whole
+	 * cache out to memory for safety.  As long as nothing is spilled
+	 * during the loop to lines that have already been done, this is safe.
+	 * - RPC
 	 */
 	if (ccr & CCR_CACHE_ENABLE) {
 		unsigned long ways, waysize, addrstart;
@@ -98,6 +107,8 @@
 	/* Force EMODE if possible */
 	if (cpu_data->dcache.ways > 1)
 		flags |= CCR_CACHE_EMODE;
+	else
+		flags &= ~CCR_CACHE_EMODE;
 #endif
 
 #ifdef CONFIG_SH_WRITETHROUGH
@@ -112,6 +123,9 @@
 	/* Turn on OCRAM -- halve the OC */
 	flags |= CCR_CACHE_ORA;
 	cpu_data->dcache.sets >>= 1;
+
+	cpu_data->dcache.way_size = cpu_data->dcache.sets *
+				    cpu_data->dcache.linesz;
 #endif
 
 	ctrl_outl(flags, CCR);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/intc2.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/intc2.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/intc2.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/intc2.c	2006-08-23 13:29:47.992809000 +0100
@@ -8,7 +8,7 @@
  * License.  See linux/COPYING for more information.
  *
  * These are the "new Hitachi style" interrupts, as present on the
- * Hitachi 7751, the STM ST40 STB1, SH7760, and SH7780.
+ * Hitachi 7751, the STM ST40 parts, SH7760, and SH7780.
  */
 
 #include <linux/kernel.h>
@@ -56,6 +56,7 @@
 {
 	int irq_offset = irq - INTC2_FIRST_IRQ;
 	int msk_shift, msk_offset;
+	unsigned long mask_addr;
 
 	/* Sanity check */
 	if (unlikely(irq_offset < 0 || irq_offset >= NR_INTC2_IRQS))
@@ -64,8 +65,11 @@
 	msk_shift = intc2_data[irq_offset].msk_shift;
 	msk_offset = intc2_data[irq_offset].msk_offset;
 
-	ctrl_outl(1 << msk_shift,
-		  INTC2_BASE + INTC2_INTMSK_OFFSET + msk_offset);
+	mask_addr = INTC2_BASE + INTC2_INTMSK_OFFSET + msk_offset;
+	ctrl_outl(1 << msk_shift, mask_addr);
+
+	/* Read back the value we just wrote to flush any write posting */
+	ctrl_inl(mask_addr);
 }
 
 static void enable_intc2_irq(unsigned int irq)
@@ -99,6 +103,25 @@
 }
 
 /*
+ * Set the priority of an INTC2 style interrupt.
+ */
+void set_intc2_irq_priority(unsigned int irq, unsigned int priority,
+                            unsigned int ipr_offset, unsigned int ipr_shift)
+{
+	unsigned long ipr;
+	unsigned int flags;
+
+	local_irq_save(flags);
+
+	ipr=ctrl_inl(INTC2_BASE+INTC2_INTPRI_OFFSET+ipr_offset);
+	ipr&=~(0xf<<ipr_shift);
+	ipr|=(priority)<<ipr_shift;
+	ctrl_outl(ipr, INTC2_BASE+INTC2_INTPRI_OFFSET+ipr_offset);
+
+	local_irq_restore(flags);
+}
+
+/*
  * Setup an INTC2 style interrupt.
  * NOTE: Unlike IPR interrupts, parameters are not shifted by this code,
  * allowing the use of the numbers straight out of the datasheet.
@@ -114,8 +137,6 @@
 		    unsigned int priority)
 {
 	int irq_offset = irq - INTC2_FIRST_IRQ;
-	unsigned int flags;
-	unsigned long ipr;
 
 	if (unlikely(irq_offset < 0 || irq_offset >= NR_INTC2_IRQS))
 		return;
@@ -127,15 +148,7 @@
 	intc2_data[irq_offset].msk_shift  = msk_shift;
 	intc2_data[irq_offset].clear_irq = NULL;
 
-	/* Set the priority level */
-	local_irq_save(flags);
-
-	ipr = ctrl_inl(INTC2_BASE + INTC2_INTPRI_OFFSET + ipr_offset);
-	ipr &= ~(0xf << ipr_shift);
-	ipr |= priority << ipr_shift;
-	ctrl_outl(ipr, INTC2_BASE + INTC2_INTPRI_OFFSET + ipr_offset);
-
-	local_irq_restore(flags);
+	set_intc2_irq_priority(irq_offset, priority, ipr_offset, ipr_shift);
 
 	irq_desc[irq].handler = &intc2_irq_type;
 
@@ -149,6 +162,8 @@
 	unsigned char priority;
 } intc2_init_data[]  __initdata = {
 #if defined(CONFIG_CPU_SUBTYPE_ST40)
+#if !defined(CONFIG_CPU_SUBTYPE_STM8000)
+	/* Standard 'legacy' peripherials */
 	{64,  0,  0, 0,  0, 13},	/* PCI serr */
 	{65,  0,  4, 0,  1, 13},	/* PCI err */
 	{66,  0,  4, 0,  2, 13},	/* PCI ad */
@@ -162,8 +177,11 @@
 	{80,  0, 12, 0, 12, 13},	/* PIO0 */
 	{84,  0, 16, 0, 13, 13},	/* PIO1 */
 	{88,  0, 20, 0, 14, 13},	/* PIO2 */
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+	{112, 4,  0, 4,  0, 13},	/* Mailbox */
+#elif defined(CONFIG_CPU_SUBTYPE_ST40GX1)
 	{112, 4,  0, 4,  0, 13},	/* Mailbox */
- #ifdef CONFIG_CPU_SUBTYPE_ST40GX1
 	{116, 4,  4, 4,  4, 13},	/* SSC0 */
 	{120, 4,  8, 4,  8, 13},	/* IR Blaster */
 	{124, 4, 12, 4, 12, 13},	/* USB host */
@@ -182,6 +200,159 @@
 	{172, 8, 28, 8, 28, 13},	/* VideoSync VTG */
 	{173, 8, 28, 8, 29, 13},	/* VideoSync DVP0 */
 	{174, 8, 28, 8, 30, 13},	/* VideoSync DVP1 */
+#elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+	{112, 4,  0, 4,  0, 13},	/* Group0:  Comms/PIO3 */
+	{113, 4,  0, 4,  1, 13},	/*            "   PIO4 */
+	{114, 4,  0, 4,  2, 13},	/*            "   PIO5 */
+	{115, 4,  0, 4,  3, 13},	/*            "   PIO6 */
+
+	{116, 4,  4, 4,  4, 13},	/* Group1:        PIO7 */
+	{117, 4,  4, 4,  5, 13},	/*                SSC0 */
+	{118, 4,  4, 4,  6, 13},	/*                SSC1 */
+	{119, 4,  4, 4,  7, 13},	/*                UART4 */
+
+	{120, 4,  8, 4,  8, 13},	/* Group2:  Comms/UART0 */
+	{121, 4,  8, 4,  9, 13},	/*                UART1 */
+	{122, 4,  8, 4, 10, 13},	/*                UART2 */
+	{123, 4,  8, 4, 11, 13},	/*                UART3 */
+
+	{124, 4, 12, 4, 12, 13},	/* Group3:  MAFE */
+	{125, 4, 12, 4, 13, 13},	/*          PWM  */
+
+	{128, 4, 16, 4, 16, 13},	/* Group4:  IR Blaster */
+
+	{132, 4, 20, 4, 20, 13},	/* Group5:  Teletext TXT0 */
+	{133, 4, 20, 4, 21, 13},	/* 	    Teletext TXT0 */
+
+	{136, 4, 24, 4, 24, 13},	/* Group6:  USB host 0 */
+	{137, 4, 24, 4, 25, 13},	/* 	    USB host 1 */
+
+	{140, 4, 28, 4, 28, 13},	/* Group7:  Mailbox ST40 */
+	{141, 4, 28, 4, 29, 13},	/*          wdST20 */
+	{142, 4, 28, 4, 30, 13},	/*          IRB wakeup */
+	{143, 4, 28, 4, 31, 13},	/*          LPA IRQ */
+
+	{144, 8,  0, 8,  0, 13},	/* Group8:  Aud_cd0 */
+	{145, 8,  0, 8,  1, 13},	/*          Aud_cd1 */
+	{146, 8,  0, 8,  2, 13},	/*          Aud_cd2 */
+	{147, 8,  0, 8,  3, 13},	/*          Aud_PCM */
+
+	{148, 8,  4, 8,  4, 13},	/* Group9:  Aud_adec */
+	{149, 8,  4, 8,  5, 13},	/*          Aud_spdif */
+
+	{152, 8,  8, 8,  8, 13},	/* Group10: Video 0 digital video port0 */
+	{153, 8,  8, 8,  9, 13},	/*          Video 1 digital video port1 */
+
+	{158, 8, 12, 8, 14, 13},	/* Group11: VTG Line */
+	{159, 8, 12, 8, 15, 13},	/*          VTG Vsync */
+
+	{160, 8, 16, 8, 16, 13},	/* Group12: bit IRQ video processor blitter */
+	{161, 8, 16, 8, 17, 13},	/*          dvp IRQ */
+
+	{164, 8, 20, 8, 20, 13},	/* Group13: PTI0 */
+	{165, 8, 20, 8, 21, 13},	/*          PTI1 */
+
+	{168, 8, 24, 8, 24, 13},	/* Group14: TSmerger Wrapper */
+
+	{172, 8, 28, 8, 28, 13},	/* Group15: PCP */
+	{173, 8, 28, 8, 29, 13} 	/*          HDDI */
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+	{112, 4,  0, 4,  0, 13},	/* ILC interrupt[0]  */
+	{116, 4,  4, 4,  4, 13},	/* ILC interrupt[1]  */
+	{120, 4,  8, 4,  8, 13},	/* ILC interrupt[2]  */
+	{124, 4, 12, 4, 12, 13},	/* ILC interrupt[3]  */
+	{128, 4, 16, 4, 16, 13},	/* ILC interrupt[4]  */
+	{132, 4, 20, 4, 20, 13},	/* ILC interrupt[5]  */
+	{136, 4, 24, 4, 24, 13},	/* ILC interrupt[6]  */
+	{140, 4, 28, 4, 28, 13},	/* ILC interrupt[7]  */
+	{144, 8,  0, 8,  0, 13},	/* ILC interrupt[8]  */
+	{148, 8,  4, 8,  4, 13},	/* ILC interrupt[9]  */
+	{152, 8,  8, 8,  8, 13},	/* ILC interrupt[10] */
+	{156, 8, 12, 8, 12, 13},	/* ILC interrupt[11] */
+	{160, 8, 16, 8, 16, 13},	/* ILC interrupt[12] */
+	{164, 8, 20, 8, 20, 13},	/* ILC interrupt[13] */
+	{168, 8, 24, 8, 24, 13},	/* ILC interrupt[14] */
+	{172, 8, 28, 8, 28, 13},	/* ILC interrupt[15] */
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+	{113, 4,  0, 4,  1, 13},	/* Group0:  pio5 */
+	{114, 4,  0, 4,  2, 13},	/*          pio4 */
+	{115, 4,  0, 4,  3, 13},	/*          pio3 */
+	{116, 4,  0, 4,  4, 13},	/*          mtp (7109) */
+
+	{117, 4,  4, 4,  5, 13},	/* Group1:  ssc2 */
+	{118, 4,  4, 4,  6, 13} ,	/*          ssc1 */
+	{119, 4,  4, 4,  7, 13},	/*          ssc0 */
+
+	{120, 4,  8, 4,  8, 13},	/* Group2:  uart3 */
+	{121, 4,  8, 4,  9, 13},	/*          uart2 */
+	{122, 4,  8, 4, 10, 13},	/*          uart1 */
+	{123, 4,  8, 4, 11, 13},	/*          uart0 */
+
+	{124, 4, 12, 4, 12, 13},	/* Group3:  irb_wakeup */
+	{125, 4, 12, 4, 13, 13},	/*          irb */
+	{126, 4, 12, 4, 14, 13},	/*          pwm */
+	{127, 4, 12, 4, 15, 13},	/*          mafe */
+
+	{129, 4, 16, 4, 17, 13},	/* Group4:  disqec */
+	{130, 4, 16, 4, 18, 13},	/*          daa */
+	{131, 4, 16, 4, 19, 13},	/*          ttxt */
+
+	{132, 4, 20, 4, 20, 13},	/* Group5:  empi (7109) */
+	{133, 4, 20, 4, 21, 13},	/*          eth_mac (7109) */
+	{134, 4, 20, 4, 22, 13},	/*          TS_Merger (7109) */
+	{135, 4, 20, 4, 23, 13},	/*          sbatm */
+
+	{136, 4, 24, 4, 24, 13},	/* Group6:  lx_delphi (lx_deltaMu 7109) */
+	{137, 4, 24, 4, 25, 13},	/*          lx_aud */
+	{138, 4, 24, 4, 26, 13},	/*          dcxo */
+	{139, 4, 24, 4, 27, 13},	/*          pti1 (7109) */
+
+	{140, 4, 28, 4, 28, 13},	/* Group7:  fdma_mbox */
+	{141, 4, 28, 4, 29, 13},	/*          fdma_gp0 */
+	{142, 4, 28, 4, 30, 13},	/*          i2s2spdif */
+	{143, 4, 28, 4, 31, 13},	/*          cpxm */
+
+	{144, 8,  0, 8,  0, 13},	/* Group8:  pcmplyr0 */
+	{145, 8,  0, 8,  1, 13},	/*          pcmplyr1 */
+	{146, 8,  0, 8,  2, 13},	/*          pcmrdr */
+	{147, 8,  0, 8,  3, 13},	/*          spdifplyr */
+
+	{148, 8,  4, 8,  4, 13},	/* Group9:  glh */
+	{149, 8,  4, 8,  5, 13},	/*          delphi_pre0 */
+	{150, 8,  4, 8,  6, 13},	/*          delphi_pre1 */
+	{151, 8,  4, 8,  7, 13},	/*          delphi_mbe */
+
+	{152, 8,  8, 8,  8, 13},	/* Group10:  vdp_fifo_empty (7109) */
+	{153, 8,  8, 8,  9, 13},	/*           lmu (vdp_end_processing 7109) */
+	{154, 8,  8, 8, 10, 13},	/*           vtg1 */
+	{155, 8,  8, 8, 11, 13},	/*           vtg2 */
+
+	{156, 8, 12, 8, 12, 13},	/* Group11:  blt (bdisp_aq1 7109) */
+	{157, 8, 12, 8, 13, 13},	/*           dvp */
+	{158, 8, 12, 8, 14, 13},	/*           hdmi */
+	{159, 8, 12, 8, 15, 13},	/*           hdcp */
+
+	{160, 8, 16, 8, 16, 13},	/* Group12:  pti */
+	{161, 8, 16, 8, 17, 13},	/*           pdes_esa0_select (7109) */
+	{162, 8, 16, 8, 18, 13},	/*           pdes */
+	{163, 8, 16, 8, 19, 13},	/*           pdes_read_cw (7109) */
+
+	{164, 8, 20, 8, 20, 13},	/* Group13:  sig_chk (tkdma_tkd 7109) */
+	{165, 8, 20, 8, 21, 13},	/*           dma_fin (tkdma_dma 7109) */
+	{166, 8, 20, 8, 22, 13},	/*           sec_cp (cripto_sig_dma 7109) */
+	{167, 8, 20, 8, 23, 13},	/*           cripto_sig_chk (7109) */
+
+	{168, 8, 24, 8, 24, 13},	/* Group14:  ohci */
+	{169, 8, 24, 8, 25, 13},	/*           ehci */
+	{170, 8, 24, 8, 26, 13},	/*           sata */
+	{171, 8, 28, 8, 27, 13},	/*           bdisp_cq1 (7109) */
+
+	{172, 8, 28, 8, 28, 13},	/* Group15:  icam3_kte (7109) */
+	{173, 8, 28, 8, 29, 13},	/*           icam3 (7109) */
+	{174, 8, 28, 8, 30, 13},	/*           mes_lmi_vid (7109) */
+	{175, 8, 28, 8, 31, 13},	/*           mes_lmi_sys (7109) */
+#else
+#error Unknown ST40 variant
 #endif
 #elif defined(CONFIG_CPU_SUBTYPE_SH7760)
 /*
@@ -241,9 +412,9 @@
 	/* 110-111 reserved/unused */
 #elif defined(CONFIG_CPU_SUBTYPE_SH7780)
 	{ TIMER_IRQ, 0, 24, 0, INTC_TMU0_MSK, 2},
-#ifdef CONFIG_SH_RTC
-	{ RTC_IRQ, 4, 0, 0, INTC_RTC_MSK, TIMER_PRIORITY },
-#endif
+	{ 21, 1, 0, 0, INTC_RTC_MSK, TIMER_PRIORITY },
+	{ 22, 1, 1, 0, INTC_RTC_MSK, TIMER_PRIORITY },
+	{ 23, 1, 2, 0, INTC_RTC_MSK, TIMER_PRIORITY },
 	{ SCIF0_ERI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
 	{ SCIF0_RXI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
 	{ SCIF0_BRI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/ipr.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/ipr.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/ipr.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/ipr.c	2006-08-23 13:29:47.980808000 +0100
@@ -67,6 +67,7 @@
 	val = ctrl_inw(addr);
 	val &= mask;
 	ctrl_outw(val, addr);
+	ctrl_inw(addr);	/* Read back to flush write posting */
 	local_irq_restore(flags);
 }
 
@@ -128,6 +129,11 @@
 	make_ipr_irq(RTC_IRQ, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY);
 #endif
 
+#if defined(CONFIG_STM_RTC)
+	make_ipr_irq(20, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY);
+	make_ipr_irq(21, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY);
+#endif
+
 #ifdef SCI_ERI_IRQ
 	make_ipr_irq(SCI_ERI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY);
 	make_ipr_irq(SCI_RXI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/Makefile linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/Makefile
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/Makefile	2006-08-23 13:29:32.501461000 +0100
@@ -5,3 +5,7 @@
 
 obj-$(CONFIG_CPU_HAS_PINT_IRQ)	+= pint.o
 obj-$(CONFIG_CPU_HAS_INTC2_IRQ)	+= intc2.o
+
+obj-$(CONFIG_CPU_SUBTYPE_STM8000)	+= st40_ilc_stm8000.o
+obj-$(CONFIG_CPU_SUBTYPE_STI5528)	+= st40_ilc_sti5528.o
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= st40_ilc_sti5528.o
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc.h linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc.h
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc.h	2006-08-23 13:29:32.534461000 +0100
@@ -0,0 +1,58 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ * Author: Henry Bell <henry.bell@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for ST40 Interrupt Level Controler (ILC).
+ */
+
+/*
+ * ILC register locations
+ */
+
+#if defined(CONFIG_CPU_SUBTYPE_STM8000)
+#define ILC_BASE_ADDR		0xb8300000
+#elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+#define ILC_BASE_ADDR		0xba000000
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define ILC_BASE_ADDR		0xb8000000
+#else
+#error "ILC has to be interfaced by ST40 on: STm8000 and STi5528!"
+#endif
+
+/*
+** The following set of macros is valid for both platforms:
+** STm8000 and STi5528
+*/
+#define _BIT(_int)		     (1 << (_int % 32))
+#define _REG_OFF(_int)		     (sizeof(int) * (_int / 32))
+
+#define ILC_INTERRUPT_REG(_int)      (ILC_BASE_ADDR + 0x080 + _REG_OFF(_int))
+#define ILC_STATUS_REG(_int)         (ILC_BASE_ADDR + 0x200 + _REG_OFF(_int))
+#define ILC_CLR_STATUS_REG(_int)     (ILC_BASE_ADDR + 0x280 + _REG_OFF(_int))
+#define ILC_ENABLE_REG(_int)         (ILC_BASE_ADDR + 0x400 + _REG_OFF(_int))
+#define ILC_CLR_ENABLE_REG(_int)     (ILC_BASE_ADDR + 0x480 + _REG_OFF(_int))
+#define ILC_SET_ENABLE_REG(_int)     (ILC_BASE_ADDR + 0x500 + _REG_OFF(_int))
+#define ILC_EXT_WAKEUP_EN_REG        (ILC_BASE_ADDR + 0x600)
+#define ILC_EXT_WAKPOL_EN_REG        (ILC_BASE_ADDR + 0x680)
+#define ILC_PRIORITY_REG(_int)       (ILC_BASE_ADDR + 0x800 + (8 * _int))
+#define ILC_TRIGMODE_REG(_int)       (ILC_BASE_ADDR + 0x804 + (8 * _int))
+
+/*
+ * Macros to get/set/clear ILC registers
+ */
+#define ILC_SET_ENABLE(_int)     ctrl_outl(_BIT(_int), ILC_SET_ENABLE_REG(_int))
+#define ILC_CLR_ENABLE(_int)     ctrl_outl(_BIT(_int), ILC_CLR_ENABLE_REG(_int))
+#define ILC_GET_ENABLE(_int)     (ctrl_inl(ILC_ENABLE_REG(_int)) & _BIT(_int))
+#define ILC_CLR_STATUS(_int)     ctrl_outl(_BIT(_int), ILC_CLR_STATUS_REG(_int))
+#define ILC_GET_STATUS(_int)     (ctrl_inl(ILC_STATUS_REG(_int)) & _BIT(_int))
+#define ILC_SET_PRI(_int, _pri)  ctrl_outl((_pri), ILC_PRIORITY_REG(_int))
+
+#define ILC_SET_TRIGMODE(_int, _mod) ctrl_outl((_mod), ILC_TRIGMODE_REG(_int))
+
+#define ILC_TRIGGERMODE_HIGH	1
+#define ILC_TRIGGERMODE_LOW	2
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c	2006-08-23 13:29:30.453416000 +0100
@@ -0,0 +1,62 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc_sti5528.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for Interrupt Level Controler (ILC) on the STi5528.
+ *
+ * This is simply used to route external interrupt pins to the ST40's
+ * interrupt controller, optionally inverting them.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "st40_ilc.h"
+
+/*
+ * STi5528 initialisation function to set up the ILC
+ * The ST40 external interrupt management has a dependency on the
+ * ST20 ILC interrupt controller.
+ * Briefly on STi5528 interrupts:
+ * - interrupts rising from on chip devices are delivered to both CPUs,
+ *   ST40 via INTC2, and ST20 via ILC.  It's matter of software coherency
+ *   to guarantee that a specific device is "owned" by a single CPU
+ * - external interrupts (from PCI, STEMs, STi4629,...) come cross three
+ *   stages before reaching the ST40 INTC (IRL pins):
+ *   1) an EPLD, which provides:
+ *       -  Eval board (MB376): masking/unmasking control registers (like
+ *      		        other harp architectures) and multiplexes
+ *      		        the independent IRQs signals into 4 encoded
+ *      		        lines (input pins of STi5528).
+ *       -  Espresso board    : does nothing (currently EPLD is a pass through)
+ *
+ *   2) the 4 external lines go first to the ILC device because their polarity
+ *      could require to be inverted before reaching the ST40 INTC (it triggers
+ *      the interrupts on High level).
+ *      Currently this doesn't happen ... and all seems to work!! at least the
+ *      Ethernet)
+ *   3) finally the INTC manages the external interrupt (IRLs) as:
+ *      - on Eval board (MB376): 16 different encoded level
+ *      - on Espresso          : 4 independent signals
+ *
+ * An issue: it's likely that in the future linux will be in charge of
+ *           dealing with PCI devices while the STi4629 will probably be
+ *           managed by ST20 code.... concerning the interrupts this will
+ *           generate conflict between differnt CPUs when accessing the
+ *           ILC
+ */
+
+void __init ilc_route_external(int ilc_irq, int ext_out, int invert)
+{
+	ILC_SET_PRI(ilc_irq, 0x8000 | ext_out);
+	ILC_SET_TRIGMODE(ilc_irq, invert ? ILC_TRIGGERMODE_LOW : ILC_TRIGGERMODE_HIGH);
+	ILC_SET_ENABLE(ilc_irq);
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc_stm8000.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc_stm8000.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/irq/st40_ilc_stm8000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/irq/st40_ilc_stm8000.c	2006-08-23 13:29:30.461415000 +0100
@@ -0,0 +1,315 @@
+/*
+ * linux/arch/sh/kernel/cpu/irq/st40_ilc_stm8000.c
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Henry Bell <henry.bell@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for Interrupt Level Controler (ILC) on the STm8000.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "st40_ilc.h"
+
+struct ilc_data {
+	unsigned int priority;
+	struct list_head list;
+	int (*clear_irq) (int);
+};
+
+static struct ilc_data ilc_data[NR_IRQS - ILC_FIRST_IRQ] =
+{
+	{  4 }, /*   0: PIO_INTERRUPT0 */
+	{  4 }, /*   1: PIO_INTERRUPT1 */
+	{  4 }, /*   2: PIO_INTERRUPT2 */
+	{  4 }, /*   3: PIO_INTERRUPT3 */
+	{  4 }, /*   4: PIO_INTERRUPT4 */
+	{  4 }, /*   5: PIO_INTERRUPT5 */
+	{  4 }, /*   6: PIO_INTERRUPT6 */
+	{  6 }, /*   7: SSC_PER_INTERRUPT0 */
+	{  6 }, /*   8: SSC_PER_INTERRUPT1 */
+	{  5 }, /*   9: UART_INTERRUPT0 */
+	{  5 }, /*  10: UART_INTERRUPT1 */
+	{  5 }, /*  11: UART_INTERRUPT2 */
+	{  3 }, /*  12: PWM_INTERRUPT */
+	{  3 }, /*  13: MAFE_INTERRUPTS */
+	{  2 }, /*  14: IRB_WAKEUP_INTERRUPT */
+	{  2 }, /*  15: IRB_INT_OUT */
+	{  2 }, /*  16: IRDA_CONTROL */
+	{  3 }, /*  17: TTXT0_INTERRUPT */
+	{ 13 }, /*  18: DISP_IRQ0 */
+	{ 13 }, /*  19: DISP_IRQ1 */
+	{ 13 }, /*  20: DV_INTERRUPT */
+	{ 13 }, /*  21: BLT_REQ_INT */
+	{  3 }, /*  22: O_CPXM_INTERRUPT */
+	{  3 }, /*  23: FEI_INTERRUPT */
+	{ 14 }, /*  24: DMA_INT0 */
+	{ 14 }, /*  25: DMA_INT1 */
+	{ 14 }, /*  26: DMA_INT2 */
+	{ 14 }, /*  27: DMA_INT3 */
+	{ 14 }, /*  28: DMA_INT4 */
+	{ 14 }, /*  29: DMA_ERROR */
+	{  8 }, /*  30: FROM_HDDI_TO_SY_INTR */
+	{  8 }, /*  31: PER_INTERRUPT */
+	{ 15 }, /*  32: MAILBOX1_0 */
+	{ 15 }, /*  33: MAILBOX1_1 */
+	{ 15 }, /*  34: MAILBOX2_0 */
+	{ 15 }, /*  35: MAILBOX2_1 */
+	{  9 }, /*  36: GO2_IRQ1 */
+	{  9 }, /*  37: GO2_IRQ2 */
+	{  7 }, /*  38: USB_INT */
+	{  7 }, /*  39: USBH_INT */
+	{ 10 }, /*  40: DVP_IRQ */
+	{ 10 }, /*  41: IFP_IRQ */
+	{ 10 }, /*  42: HVF_IRQ */
+	{ 10 }, /*  43: ILA_IRQ */
+	{ 10 }, /*  44: MVG_IRQ */
+	{ 10 }, /*  45: SDI_DIN_IRQ */
+	{ 10 }, /*  46: SDI_DOUT_IRQ */
+	{ 10 }, /*  47: SDI_BITS_IRQ */
+	{ 11 }, /*  48: PCMREADER1_IT_1 */
+	{ 12 }, /*  49: SPDIFPLAYER_IT_0 */
+	{ 12 }, /*  50: SPDIFPLAYER_IT_1 */
+	{ 12 }, /*  51: SPDIFPLAYER_IT_2 */
+	{ 12 }, /*  52: SPDIFPLAYER_IT_3 */
+	{ 12 }, /*  53: SPDIFPLAYER_IT_4 */
+	{ 11 }, /*  54: PCMPLAYER_IT_0 */
+	{ 11 }, /*  55: PCMPLAYER_IT_1 */
+	{ 11 }, /*  56: PCMREADER3_IT */
+	{ 11 }, /*  57: PCMREADER2_IT */
+	{ 11 }, /*  58: PCMREADER1_IT */
+	{ 12 }  /*  59: SPDIFPLAYER_IT_5 */
+};
+
+static struct list_head intc_data[NR_INTC2_IRQS/4];
+
+static spinlock_t ilc_data_lock;
+
+/*
+ * Debug printk macro
+ */
+
+/* #define ILC_DEBUG */
+/* #define ILC_DEBUG_DEMUX */
+
+#ifdef ILC_DEBUG
+#define DPRINTK(args...)   printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+
+/*
+ * Beware this one; the ASC has ILC ints too...
+ */
+
+#ifdef ILC_DEBUG_DEMUX
+#define DPRINTK2(args...)   printk(args)
+#else
+#define DPRINTK2(args...)
+#endif
+
+/*
+ * Prototypes
+ */
+
+static void enable_ilc_irq(unsigned int irq)
+{
+        int irq_offset = irq - ILC_FIRST_IRQ;
+
+        DPRINTK("ilc enable %d\n", irq_offset);
+
+        if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+                return;
+
+        ILC_SET_ENABLE(irq_offset);
+}
+
+static void disable_ilc_irq(unsigned int irq)
+{
+        int irq_offset = irq - ILC_FIRST_IRQ;
+
+        DPRINTK("ilc disable %d\n", irq_offset);
+
+        if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+                return;
+
+        ILC_CLR_ENABLE(irq_offset);
+}
+
+/*
+ * The interrupt demux function. Check if this was an ILC interrupt, and
+ * of so which device generated the interrupt.
+ */
+
+int stm8000_irq_demux(int irq)
+{
+        unsigned int priority = (irq - INTC2_FIRST_IRQ) / 4;
+        unsigned int irq_offset;
+        struct ilc_data *this;
+
+	if (irq < INTC2_FIRST_IRQ)
+		return irq;
+
+        DPRINTK2("ilc demux got irq %d\n", irq);
+
+	list_for_each_entry(this, &intc_data[priority], list) {
+
+                irq_offset = this - ilc_data;
+
+                if (ILC_GET_STATUS(irq_offset) && ILC_GET_ENABLE(irq_offset)) {
+
+                        DPRINTK2("ilc found ilc %d active\n", irq_offset);
+
+                        ILC_CLR_STATUS(irq_offset);
+
+                        return irq_offset + ILC_FIRST_IRQ;
+                }
+        }
+
+	printk(KERN_INFO "ILC: spurious interrupt demux %d\n", irq);
+
+	return irq;
+}
+
+/*
+ * For simplicity's sake we make the assigned priorities match the
+ * ordering, so the nth ILC 'slot' is assigned priority n.
+ */
+
+static unsigned int startup_ilc_irq(unsigned int irq)
+{
+        struct ilc_data *this;
+        unsigned int priority;
+        int irq_offset = irq - ILC_FIRST_IRQ;
+	unsigned long flags;
+
+        DPRINTK("ilc startup irq %d\n", irq);
+
+        if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+                return -ENODEV;
+
+	this = &ilc_data[irq_offset];
+        priority = this->priority;
+
+	spin_lock_irqsave(&ilc_data_lock, flags);
+	list_add(&this->list, &intc_data[priority]);
+	spin_unlock_irqrestore(&ilc_data_lock, flags);
+
+        ILC_SET_PRI(irq_offset, priority);
+        ILC_SET_ENABLE(irq_offset);
+
+        return 0;
+}
+
+static void shutdown_ilc_irq(unsigned int irq)
+{
+        struct ilc_data *this;
+        unsigned int priority;
+        int irq_offset = irq - ILC_FIRST_IRQ;
+	unsigned long flags;
+
+        DPRINTK("ilc shutdown irq %d\n", irq);
+
+        if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+                return;
+
+        this = &ilc_data[irq_offset];
+        priority = this->priority;
+
+        ILC_CLR_ENABLE(irq_offset);
+	ILC_SET_PRI(irq_offset, 0);
+
+	spin_lock_irqsave(&ilc_data_lock, flags);
+	list_del(&this->list);
+	spin_unlock_irqrestore(&ilc_data_lock, flags);
+}
+
+static void mask_and_ack_ilc(unsigned int irq)
+{
+        int irq_offset = irq - ILC_FIRST_IRQ;
+        ILC_CLR_ENABLE(irq_offset);
+}
+
+static void end_ilc_irq(unsigned int irq)
+{
+	int irq_offset = irq - ILC_FIRST_IRQ;
+
+        if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		ILC_SET_ENABLE(irq_offset);
+	}
+
+	if (ilc_data[irq_offset].clear_irq)
+		ilc_data[irq_offset].clear_irq(irq);
+}
+
+/*
+ * Table of fns to be set in irq_desc below.
+ */
+
+static struct hw_interrupt_type ilc_irq_type = {
+        "ILC-IRQ",
+        startup_ilc_irq,
+        shutdown_ilc_irq,
+        enable_ilc_irq,
+        disable_ilc_irq,
+        mask_and_ack_ilc,
+        end_ilc_irq
+};
+
+static irqreturn_t ilc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	printk(KERN_INFO "ILC: spurious interrupt %d\n", irq);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction intc2_irqs[NR_INTC2_IRQS/4]  = {
+	[0 ... (NR_INTC2_IRQS/4)-1] = {
+		.handler = ilc_interrupt,
+		.flags = SA_INTERRUPT,
+		.name = "ST40 ILC",
+	}
+};
+
+/*
+ * STm8000 initialisation function to set up the ILC
+ */
+
+void __init init_IRQ_STm8000_ilc(void)
+{
+	int irq;
+
+	DPRINTK("STm8000: Initialising ST40 ILC\n");
+
+	for (irq = ILC_FIRST_IRQ; irq < (ILC_FIRST_IRQ+ILC_NR_IRQS); irq++)
+		irq_desc[irq].handler = &ilc_irq_type;
+
+	/* All INTC2 interrupts are used by the ILC */
+	for (irq = 0; irq < NR_INTC2_IRQS/4; irq++) {
+		INIT_LIST_HEAD(&intc_data[irq]);
+		setup_irq(INTC2_FIRST_IRQ+(irq*4), &intc2_irqs[irq]);
+	}
+}
+
+/* Adds a termination callback to the interrupt */
+void ilc_add_clear_irq(int irq, int (*fn)(int))
+{
+	int irq_offset = irq - ILC_FIRST_IRQ;
+
+	if ((irq_offset < 0) || (irq_offset >= ILC_NR_IRQS))
+		return;
+
+	ilc_data[irq_offset].clear_irq = fn;
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/Makefile linux-2.6.17.8-sh/arch/sh/kernel/cpu/Makefile
--- linux-2.6.17.8/arch/sh/kernel/cpu/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/Makefile	2006-08-23 13:29:30.817415000 +0100
@@ -4,10 +4,18 @@
 
 obj-y	+= irq/ init.o clock.o
 
+# Most chips still use the Hitachi standard CPG which has a few standard
+# clocks. Those which do not can remove it here, and define a complete
+# new clock architecture in their own processor specific code.
+archclock-y					:= clock-cpg.o
+archclock-$(CONFIG_CPU_SUBTYPE_STB7100)	:=
+obj-y	+= $(archclock-y)
+
 obj-$(CONFIG_CPU_SH2)		+= sh2/
 obj-$(CONFIG_CPU_SH3)		+= sh3/
 obj-$(CONFIG_CPU_SH4)		+= sh4/
 
 obj-$(CONFIG_SH_RTC)		+= rtc.o
+obj-$(CONFIG_SH_RTC_ST)		+= rtc-st.o
 obj-$(CONFIG_UBC_WAKEUP)	+= ubc.o
 obj-$(CONFIG_SH_ADC)		+= adc.o
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/rtc-st.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/rtc-st.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/rtc-st.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/rtc-st.c	2006-08-23 13:29:32.490461000 +0100
@@ -0,0 +1,69 @@
+/*
+ * linux/arch/sh/kernel/cpu/rtc-st.c
+ *
+ * Support for the RTC in the comms block of ST40 based parts.
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+
+#include <asm/rtc.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+#define LPC_BASE		0xba008000
+#define LPCLK_HZ		32768
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+#define LPC_BASE		0xb8308000
+#define LPCLK_HZ		32768
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define LPC_BASE		0xb8008000
+#define LPCLK_HZ		46875
+#else
+#error Unknown CPU
+#endif
+
+#define LPC_LPT_LSB		(LPC_BASE + 0x400)
+#define LPC_LPT_MSB		(LPC_BASE + 0x404)
+#define LPC_LPTSTART		(LPC_BASE + 0x408)
+
+void st_rtc_gettimeofday(struct timespec *ts)
+{
+	unsigned long long lpt;
+	unsigned long lpt_lsb, lpt_msb;
+	unsigned long long rem;
+
+	do {
+		lpt_msb = ctrl_inl(LPC_LPT_MSB);
+		lpt_lsb = ctrl_inl(LPC_LPT_LSB);
+	} while (ctrl_inl(LPC_LPT_MSB) != lpt_msb);
+
+	lpt = ((unsigned long long)lpt_msb << 32) | lpt_lsb;
+	rem = do_div(lpt, LPCLK_HZ);
+	rem *= 1000000000;
+	do_div(rem, LPCLK_HZ);
+
+	ts->tv_nsec = rem;
+	ts->tv_sec  = lpt;
+}
+
+int st_rtc_settimeofday(const time_t secs)
+{
+	unsigned long long lpt;
+
+	lpt = (unsigned long long)secs * LPCLK_HZ;
+	ctrl_outl(lpt >> 32, LPC_LPT_MSB);
+	ctrl_outl(lpt, LPC_LPT_LSB);
+
+	ctrl_outl(1, LPC_LPTSTART);
+
+	return 0;
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-st40stb1.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-st40stb1.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-st40stb1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-st40stb1.c	2006-08-23 13:29:30.839415000 +0100
@@ -0,0 +1,198 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-st40stb1.c
+ *
+ * ST40STB1 and ST40GX1 support for the clock framework
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CLOCKGEN_MEMCLKCR 0xbb040038
+#define MEMCLKCR_RATIO_MASK 0x7
+
+struct frqcr_data {
+	unsigned short frqcr;
+
+	struct {
+		unsigned char multiplier;
+		unsigned char divisor;
+	} factor[3];
+};
+
+static struct frqcr_data st40_frqcr_table[] = {
+	{ 0x000, {{1,1}, {1,1}, {1,2}}},
+	{ 0x002, {{1,1}, {1,1}, {1,4}}},
+	{ 0x004, {{1,1}, {1,1}, {1,8}}},
+	{ 0x008, {{1,1}, {1,2}, {1,2}}},
+	{ 0x00A, {{1,1}, {1,2}, {1,4}}},
+	{ 0x00C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x011, {{1,1}, {2,3}, {1,6}}},
+	{ 0x013, {{1,1}, {2,3}, {1,3}}},
+	{ 0x01A, {{1,1}, {1,2}, {1,4}}},
+	{ 0x01C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x023, {{1,1}, {2,3}, {1,3}}},
+	{ 0x02C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x048, {{1,2}, {1,2}, {1,4}}},
+	{ 0x04A, {{1,2}, {1,2}, {1,6}}},
+	{ 0x04C, {{1,2}, {1,2}, {1,8}}},
+	{ 0x05A, {{1,2}, {1,3}, {1,6}}},
+	{ 0x05C, {{1,2}, {1,3}, {1,6}}},
+	{ 0x063, {{1,2}, {1,4}, {1,4}}},
+	{ 0x06C, {{1,2}, {1,4}, {1,8}}},
+	{ 0x091, {{1,3}, {1,3}, {1,6}}},
+	{ 0x093, {{1,3}, {1,3}, {1,6}}},
+	{ 0x0A3, {{1,3}, {1,6}, {1,6}}},
+	{ 0x0DA, {{1,4}, {1,4}, {1,8}}},
+	{ 0x0DC, {{1,4}, {1,4}, {1,8}}},
+	{ 0x0EC, {{1,4}, {1,8}, {1,8}}},
+	{ 0x123, {{1,4}, {1,4}, {1,8}}},
+	{ 0x16C, {{1,4}, {1,8}, {1,8}}},
+};
+
+struct memclk_data {
+	unsigned char multiplier;
+	unsigned char divisor;
+};
+
+static struct memclk_data st40_memclk_table[8] = {
+	{1,1},	// 000
+	{1,2},	// 001
+	{1,3},	// 010
+	{2,3},	// 011
+	{1,4},	// 100
+	{1,6},	// 101
+	{1,8},	// 110
+	{1,8}	// 111
+};
+
+static struct frqcr_data *frqcr_lookup(void)
+{
+	struct frqcr_data *d;
+	int a;
+	unsigned int frqcr = ctrl_inw(FRQCR);
+
+	for (a = 0; a < ARRAY_SIZE(st40_frqcr_table); a++) {
+		d = &st40_frqcr_table[a];
+
+		if (d->frqcr == (frqcr & 0x1ff))
+			return d;
+	}
+
+	printk("ERROR: Unrecognised FRQCR value (0x%x), "
+	       "using default multipliers\n", frqcr);
+
+	return &st40_frqcr_table[0];
+}
+
+/* rate is initialised to the peripherial bus clock frequency, work
+ * backwards to find the real value. */
+static void master_clk_init(struct clk *clk)
+{
+	struct frqcr_data *d = frqcr_lookup();
+	clk->rate = clk->rate * d->factor[2].divisor
+	                      / d->factor[2].multiplier;
+}
+
+static struct clk_ops stb1_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	struct frqcr_data *d = frqcr_lookup();
+	clk->rate = clk->parent->rate * d->factor[2].multiplier
+	                              / d->factor[2].divisor;
+}
+
+static struct clk_ops stb1_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	struct frqcr_data *d = frqcr_lookup();
+	clk->rate = clk->parent->rate * d->factor[1].multiplier
+	                              / d->factor[1].divisor;
+}
+
+static struct clk_ops stb1_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	struct frqcr_data *d = frqcr_lookup();
+	clk->rate = clk->parent->rate * d->factor[0].multiplier
+	                              / d->factor[0].divisor;
+}
+
+static struct clk_ops stb1_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh4_clk_ops[] = {
+	&stb1_master_clk_ops,
+	&stb1_module_clk_ops,
+	&stb1_bus_clk_ops,
+	&stb1_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh4_clk_ops))
+		*ops = sh4_clk_ops[idx];
+}
+
+static void memory_clk_recalc(struct clk *clk)
+{
+	struct memclk_data *e;
+	unsigned long memclkcr;
+
+	memclkcr = ctrl_inl(CLOCKGEN_MEMCLKCR);
+	e = &st40_memclk_table[memclkcr & MEMCLKCR_RATIO_MASK];
+
+	clk->rate = clk->parent->rate * e->multiplier
+	                              / e->divisor;
+}
+
+static struct clk_ops stb1_memory_clk_ops = {
+	.recalc		= memory_clk_recalc,
+};
+
+static struct clk stb1_memory_clk = {
+	.name		= "memory_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &stb1_memory_clk_ops,
+};
+
+static int __init stb1_clk_init(void)
+{
+	struct clk *master_clk = clk_get("master_clk");
+
+	stb1_memory_clk.parent = master_clk;
+	clk_register(&stb1_memory_clk);
+	clk_enable(&stb1_memory_clk);
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(master_clk, clk_get_rate(master_clk));
+
+	clk_put(master_clk);
+
+	return 0;
+}
+
+arch_initcall(stb1_clk_init);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-stb7100.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-stb7100.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-stb7100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-stb7100.c	2006-08-23 13:29:40.586645000 +0100
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2005 STMicroelectronics Limited
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Code to handle the clockgen hardware on the STb7100.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CLOCKGEN_BASE_ADDR	0xb9213000	/* Clockgen A */
+
+#define CLOCKGEN_PLL0_CFG	(CLOCKGEN_BASE_ADDR + 0x08)
+#define CLOCKGEN_PLL0_CLK1_CTRL	(CLOCKGEN_BASE_ADDR + 0x14)
+#define CLOCKGEN_PLL0_CLK2_CTRL	(CLOCKGEN_BASE_ADDR + 0x18)
+#define CLOCKGEN_PLL0_CLK3_CTRL	(CLOCKGEN_BASE_ADDR + 0x1c)
+#define CLOCKGEN_PLL0_CLK4_CTRL	(CLOCKGEN_BASE_ADDR + 0x20)
+#define CLOCKGEN_PLL1_CFG	(CLOCKGEN_BASE_ADDR + 0x24)
+
+                               /* 0  1  2  3  4  5  6  7  */
+static unsigned char ratio1[] = { 1, 2, 3, 4, 6, 8 };
+static unsigned char ratio2[] = { 1, 2, 3, 4, 6, 8 };
+static unsigned char ratio3[] = { 4, 2, 4, 4, 6, 8 };
+static unsigned char ratio4[] = { 1, 2, 3, 4, 6, 8 };
+
+static int pll_freq(unsigned long addr)
+{
+	unsigned long freq, data, ndiv, pdiv, mdiv;
+
+	data = ctrl_inl(addr);
+	mdiv = (data >>  0) & 0xff;
+	ndiv = (data >>  8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+	freq = (((2 * (CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) /
+		(1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+static void pll0_clk_init(struct clk *clk)
+{
+	clk->rate = pll_freq(CLOCKGEN_PLL0_CFG);
+}
+
+static struct clk_ops pll0_clk_ops = {
+	.init		= pll0_clk_init,
+};
+
+static struct clk pll0_clk = {
+	.name		= "pll0_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &pll0_clk_ops,
+};
+
+static void pll1_clk_init(struct clk *clk)
+{
+	clk->rate = pll_freq(CLOCKGEN_PLL1_CFG);
+}
+
+static struct clk_ops pll1_clk_ops = {
+	.init		= pll1_clk_init,
+};
+
+static struct clk pll1_clk = {
+	.name		= "pll1_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.ops		= &pll1_clk_ops,
+};
+
+#define DEFINE_CLKGEN_CLK(clock, pll, div_first, div)		\
+static void clock##_clk_recalc(struct clk *clk)			\
+{								\
+	div_first;						\
+	clk->rate = clk->parent->rate / (div);			\
+}								\
+								\
+static struct clk_ops clock##_clk_ops = {			\
+	.recalc		= clock##_clk_recalc,			\
+};								\
+								\
+static struct clk clock##_clk = {				\
+	.name		= #clock "_clk",				\
+	.parent		= &pll,					\
+	.flags		= CLK_ALWAYS_ENABLED,			\
+	.ops		= &clock##_clk_ops,			\
+};
+
+#define DEFINE_CLKGEN_RATIO_CLK(clock, pll, register, ratio)	\
+DEFINE_CLKGEN_CLK(clock, pll,					\
+		  unsigned long data = ctrl_inl(register) & 0x7, 2*ratio[data])
+
+DEFINE_CLKGEN_RATIO_CLK(sh4,    pll0_clk, CLOCKGEN_PLL0_CLK1_CTRL, ratio1)
+DEFINE_CLKGEN_RATIO_CLK(sh4_ic, pll0_clk, CLOCKGEN_PLL0_CLK2_CTRL, ratio2)
+DEFINE_CLKGEN_RATIO_CLK(module, pll0_clk, CLOCKGEN_PLL0_CLK3_CTRL, ratio3)
+DEFINE_CLKGEN_RATIO_CLK(slim,   pll0_clk, CLOCKGEN_PLL0_CLK4_CTRL, ratio4)
+
+DEFINE_CLKGEN_CLK(comms, pll1_clk, , 4)
+
+static struct clk *onchip_clocks[] = {
+	&pll0_clk,
+	&pll1_clk,
+	&sh4_clk,
+	&sh4_ic_clk,
+	&module_clk,
+	&slim_clk,
+	&comms_clk,
+};
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Propogate the PLL values down */
+        clk_set_rate(&pll0_clk, clk_get_rate(&pll0_clk));
+        clk_set_rate(&pll1_clk, clk_get_rate(&pll1_clk));
+
+	return ret;
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-sti5528.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-sti5528.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-sti5528.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-sti5528.c	2006-08-23 13:29:30.846415000 +0100
@@ -0,0 +1,138 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sti5528.c
+ *
+ * STi5528 support for the clock framework
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CLOCKGEN_BASE_ADDR     0xB9163000
+
+#define MD_STATUS		(CLOCKGEN_BASE_ADDR + 0x00) /* Mode Pin: EMIADDR */
+#define CLOCKGEN_PLL1_CTRL	(CLOCKGEN_BASE_ADDR + 0x04) /* PLL1 ctrl reg */
+#define PLL1_CLK1_CTRL		(CLOCKGEN_BASE_ADDR + 0x0C) /* ST40CORCLK */
+#define PLL1_CLK2_CTRL		(CLOCKGEN_BASE_ADDR + 0x10) /* ICCLK */
+#define PLL1_CLK3_CTRL		(CLOCKGEN_BASE_ADDR + 0x14) /* ST40PERCLK */
+#define CLOCKGEN_PLL2_CTRL	(CLOCKGEN_BASE_ADDR + 0x40) /* PLL2 ctrl reg */
+
+u_int _ratio[8][2] = { {1,1},{1,2},{1,3},{2,3},
+		        {1,4},{1,6},{1,8},{1,8} };
+
+static int pll_freq(unsigned long addr)
+{
+	unsigned long freq, data, ndiv, pdiv, mdiv;
+
+	data = ctrl_inl(addr);
+	mdiv = (data & 0xff) + 1;
+	ndiv = ((data >> 8) & 0xff) + 1;
+	pdiv = (data >> 16) & 0x7;
+	freq = (((2 * 27000 * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+/* Treat PLL1 as the 'master' clock */
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate = pll_freq(CLOCKGEN_PLL1_CTRL);
+}
+
+static struct clk_ops sti5528_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	unsigned long index = ctrl_inl(PLL1_CLK3_CTRL) & 7;
+
+	clk->rate = ((clk->parent->rate / 2) * _ratio[index][0])
+	                                     / _ratio[index][1];
+}
+
+static struct clk_ops sti5528_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	unsigned long index = ctrl_inl(PLL1_CLK2_CTRL) & 7;
+
+	clk->rate = ((clk->parent->rate / 2) * _ratio[index][0])
+	                                     / _ratio[index][1];
+}
+
+static struct clk_ops sti5528_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate / 2;
+}
+
+static struct clk_ops sti5528_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh4_clk_ops[] = {
+	&sti5528_master_clk_ops,
+	&sti5528_module_clk_ops,
+	&sti5528_bus_clk_ops,
+	&sti5528_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh4_clk_ops))
+		*ops = sh4_clk_ops[idx];
+}
+
+static void memory_clk_recalc(struct clk *clk)
+{
+	unsigned long pll = pll_freq(CLOCKGEN_PLL2_CTRL);
+
+	clk->rate = pll / 2;
+}
+
+static struct clk_ops sti5528_memory_clk_ops = {
+	.recalc		= memory_clk_recalc,
+};
+
+static struct clk sti5528_memory_clk = {
+	.name		= "memory_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sti5528_memory_clk_ops,
+};
+
+static int __init sti5528_clk_init(void)
+{
+	struct clk *master_clk = clk_get("master_clk");
+
+	sti5528_memory_clk.parent = master_clk;
+	clk_register(&sti5528_memory_clk);
+	clk_enable(&sti5528_memory_clk);
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(master_clk, clk_get_rate(master_clk));
+
+	clk_put(master_clk);
+
+	return 0;
+}
+
+arch_initcall(sti5528_clk_init);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-stm8000.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-stm8000.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/clock-stm8000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/clock-stm8000.c	2006-08-23 13:29:30.853415000 +0100
@@ -0,0 +1,211 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-stm8000.c
+ *
+ * STm8000 support for the clock framework
+ *
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+typedef struct _divisors_s
+{
+	unsigned int sh4_clk_divisor;
+	unsigned int bus_clk_divisor;
+	unsigned int per_clk_divisor;
+	unsigned int ves_clk_divisor;
+
+} _divisors_t;
+
+static _divisors_t divisors[8] =
+{
+	{1, 1,	1, 1},
+	{2, 3,	6, 1},
+	{4, 6, 12, 2},
+	{2, 2,	6, 1},
+	{4, 6, 12, 1},
+	{2, 4, 12, 2},
+	{4, 4, 12, 2},
+	{4, 6,	8, 2}
+};
+
+#define CLOCKGEN_BASE_ADDR	0xB0400000
+
+#define CLOCKGEN_PLL1CR1	(CLOCKGEN_BASE_ADDR + 0x00)
+#define CLOCKGEN_PLL2CR1	(CLOCKGEN_BASE_ADDR + 0x10)
+#define CLOCKGEN_STBREQCR	(CLOCKGEN_BASE_ADDR + 0x18)
+#define CLOCKGEN_STBREQCR_CLR	(CLOCKGEN_BASE_ADDR + 0x28)
+#define CLOCKGEN_STBACKCR	(CLOCKGEN_BASE_ADDR + 0x30)
+#define CLOCKGEN_CLK4CR	(CLOCKGEN_BASE_ADDR + 0x38)
+#define CLOCKGEN_CPG_BYPASS	(CLOCKGEN_BASE_ADDR + 0x40)
+#define CLOCKGEN_CLK_RATIO	(CLOCKGEN_BASE_ADDR + 0x48)
+#define CLOCKGEN_CLK1CR	(CLOCKGEN_BASE_ADDR + 0x50)
+#define CLOCKGEN_CLK2CR	(CLOCKGEN_BASE_ADDR + 0x58)
+#define CLOCKGEN_CLK3CR	(CLOCKGEN_BASE_ADDR + 0x60)
+#define CLOCKGEN_CLK_DDRCR	(CLOCKGEN_BASE_ADDR + 0x68)
+
+static int pll_freq(unsigned long addr)
+{
+	unsigned long freq, data, ndiv, pdiv, mdiv;
+
+	data = ctrl_inl(addr);
+	mdiv = (data & 0xff) + 1;
+	ndiv = ((data >> 8) & 0xff) + 1;
+	pdiv = (data >> 16) & 0x7;
+	freq = (((2 * 27000 * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+
+	return freq;
+}
+
+static void master_clk_init(struct clk *clk)
+{
+	unsigned long sel = ctrl_inl(CLOCKGEN_CLK_RATIO);
+
+	if (sel & 0x40) {
+		if (sel & 0x80)
+			clk->rate = pll_freq(CLOCKGEN_PLL2CR1);
+		else
+			clk->rate = pll_freq(CLOCKGEN_PLL1CR1);
+	} else {
+		clk->rate = 27000000;
+	}
+}
+
+static struct clk_ops stm8000_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	unsigned long ratio = ctrl_inl(CLOCKGEN_CLK_RATIO) & 7;
+
+	clk->rate = clk->parent->rate / divisors[ratio].per_clk_divisor;
+}
+
+static struct clk_ops stm8000_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	unsigned long ratio = ctrl_inl(CLOCKGEN_CLK_RATIO) & 7;
+
+	clk->rate = clk->parent->rate / divisors[ratio].bus_clk_divisor;
+}
+
+static struct clk_ops stm8000_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	unsigned long ratio = ctrl_inl(CLOCKGEN_CLK_RATIO) & 7;
+
+	clk->rate = clk->parent->rate / divisors[ratio].sh4_clk_divisor;
+}
+
+static struct clk_ops stm8000_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh4_clk_ops[] = {
+	&stm8000_master_clk_ops,
+	&stm8000_module_clk_ops,
+	&stm8000_bus_clk_ops,
+	&stm8000_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh4_clk_ops))
+		*ops = sh4_clk_ops[idx];
+}
+
+static void ves_clk_recalc(struct clk *clk)
+{
+	unsigned long ratio = ctrl_inl(CLOCKGEN_CLK_RATIO) & 7;
+
+	clk->rate = clk->parent->rate / divisors[ratio].ves_clk_divisor;
+}
+
+static struct clk_ops stm8000_ves_clk_ops = {
+	.recalc		= ves_clk_recalc,
+};
+
+static struct clk stm8000_ves_clk = {
+	.name		= "ves_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &stm8000_ves_clk_ops,
+};
+
+static void memory_clk_recalc(struct clk *clk)
+{
+	unsigned long ratio = ctrl_inl(CLOCKGEN_CLK_RATIO);
+
+	switch ((ratio & 0x38) >> 3)
+	{
+	case 0:
+		clk->rate = pll_freq(CLOCKGEN_PLL2CR1) / 2;
+		break;
+	case 1:
+		clk->rate = clk->parent->rate / divisors[ratio].ves_clk_divisor;
+		break;
+	case 2:
+		clk->rate = clk->parent->rate / divisors[ratio].sh4_clk_divisor;
+		break;
+	case 3:
+		clk->rate = clk->parent->rate / divisors[ratio].bus_clk_divisor;
+		break;
+	case 4:
+		clk->rate = clk->parent->rate / divisors[ratio].per_clk_divisor;
+		break;
+	default:
+		clk->rate = 0;
+		break;
+	}
+}
+
+static struct clk_ops stm8000_memory_clk_ops = {
+	.recalc		= memory_clk_recalc,
+};
+
+static struct clk stm8000_memory_clk = {
+	.name		= "memory_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &stm8000_memory_clk_ops,
+};
+
+static int __init stm8000_clk_init(void)
+{
+	struct clk *master_clk = clk_get("master_clk");
+
+	stm8000_ves_clk.parent = master_clk;
+	clk_register(&stm8000_ves_clk);
+	clk_enable(&stm8000_ves_clk);
+
+	stm8000_memory_clk.parent = master_clk;
+	clk_register(&stm8000_memory_clk);
+	clk_enable(&stm8000_memory_clk);
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(master_clk, clk_get_rate(master_clk));
+
+	clk_put(master_clk);
+
+	return 0;
+}
+
+arch_initcall(stm8000_clk_init);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/ex.S linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/ex.S
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/ex.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/ex.S	2006-08-23 13:29:47.766806000 +0100
@@ -73,6 +73,7 @@
 	.long	do_IRQ	! 1110
 	.long	exception_error		
 	! Internal hardware
+#ifndef CONFIG_CPU_SUBTYPE_SH7780
 	.long	do_IRQ	! TMU0 tuni0	/* 400 */
 	.long	do_IRQ	! TMU1 tuni1
 	.long	do_IRQ	! TMU2 tuni2
@@ -285,7 +286,9 @@
 	.long	do_IRQ	! 106 0xf40
 	.long	do_IRQ	! 107 0xf60
 	.long	do_IRQ	! 108 0xf80
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
+# if !defined(CONFIG_CPU_SUBTYPE_STM8000)
+	/* Standard 'legacy' peripherials */
 	.long	exception_error			!  50 0x840
 	.long	exception_error			!  51 0x860
 	.long	exception_error			!  52 0x880
@@ -300,31 +303,31 @@
 	.long	exception_error			!  61 0x9a0
 	.long	exception_error			!  62 0x9c0
 	.long	exception_error			!  63 0x9e0
-	.long	do_IRQ	!  64 0xa00 PCI serr
-	.long	do_IRQ	!  65 0xa20     err
-	.long	do_IRQ	!  66 0xa40     ad
-	.long	do_IRQ	!  67 0xa60     pwr_dwn
+	.long	do_IRQ				!  64 0xa00 PCI serr
+	.long	do_IRQ				!  65 0xa20     err
+	.long	do_IRQ				!  66 0xa40     ad
+	.long	do_IRQ				!  67 0xa60     pwr_dwn
 	.long	exception_error			!  68 0xa80
 	.long	exception_error			!  69 0xaa0
 	.long	exception_error			!  70 0xac0
 	.long	exception_error			!  71 0xae0
-	.long	do_IRQ	!  72 0xb00 DMA INT0
-	.long	do_IRQ	!  73 0xb20     INT1
-	.long	do_IRQ	!  74 0xb40     INT2
-	.long	do_IRQ	!  75 0xb60     INT3
-	.long	do_IRQ	!  76 0xb80     INT4
+	.long	do_IRQ				!  72 0xb00 DMA INT0
+	.long	do_IRQ				!  73 0xb20     INT1
+	.long	do_IRQ				!  74 0xb40     INT2
+	.long	do_IRQ				!  75 0xb60     INT3
+	.long	do_IRQ				!  76 0xb80     INT4
 	.long	exception_error			!  77 0xba0
-	.long	do_IRQ	!  78 0xbc0 DMA ERR
+	.long	do_IRQ				!  78 0xbc0 DMA ERR
 	.long	exception_error			!  79 0xbe0
-	.long	do_IRQ	!  80 0xc00 PIO0
-	.long	do_IRQ	!  81 0xc20 PIO1
-	.long	do_IRQ	!  82 0xc40 PIO2
+	.long	do_IRQ				!  80 0xc00 PIO0
+	.long	exception_error			!  81 0xc20
+	.long	exception_error			!  82 0xc40
 	.long	exception_error			!  83 0xc60
-	.long	exception_error			!  84 0xc80
+	.long	do_IRQ				!  84 0xc80 PIO1
 	.long	exception_error			!  85 0xca0
 	.long	exception_error			!  86 0xcc0
 	.long	exception_error			!  87 0xce0
-	.long	exception_error			!  88 0xd00
+	.long	do_IRQ				!  88 0xd00 PIO2
 	.long	exception_error			!  89 0xd20
 	.long	exception_error			!  90 0xd40
 	.long	exception_error			!  91 0xd60
@@ -348,7 +351,14 @@
 	.long	exception_error			! 109 0xfa0
 	.long	exception_error			! 110 0xfc0
 	.long	exception_error			! 111 0xfe0
-	.long	do_IRQ	! 112 0x1000 Mailbox
+# else /* CONFIG_CPU_SUBTYPE_STM8000 */
+	! No legacy peripherials, so fill a 'gap' from 50..111 inclusive
+	.rept 62
+		.long exception_error
+	.endr
+# endif
+# if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+	.long	do_IRQ				! 112 0x1000 Mailbox
 	.long	exception_error			! 113 0x1020
 	.long	exception_error			! 114 0x1040
 	.long	exception_error			! 115 0x1060
@@ -376,9 +386,435 @@
 	.long	exception_error			! 137 0x1320
 	.long	exception_error			! 138 0x1340
 	.long	exception_error			! 139 0x1360
-	.long	do_IRQ	! 140 0x1380 EMPI INV_ADDR
+	.long	do_IRQ				! 140 0x1380 EMPI INV_ADDR
 	.long	exception_error			! 141 0x13a0
 	.long	exception_error			! 142 0x13c0
 	.long	exception_error			! 143 0x13e0
+# elif defined(CONFIG_CPU_SUBTYPE_ST40GX1)
+	.long	do_IRQ				! 112 0x1000 Mailbox
+	.long	exception_error			! 113 0x1020
+	.long	exception_error			! 114 0x1040
+	.long	exception_error			! 115 0x1060
+	.long	do_IRQ				! 116 0x1080 SSC0
+	.long	exception_error			! 117 0x10a0
+	.long	exception_error			! 118 0x10c0
+	.long	exception_error			! 119 0x10e0
+	.long	do_IRQ				! 120 0x1100 IRBlaster IRB
+	.long	exception_error			! 121 0x1120
+	.long	exception_error			! 122 0x1140
+	.long	exception_error			! 123 0x1160
+	.long	do_IRQ				! 124 0x1180 USB host
+	.long	exception_error			! 125 0x11a0
+	.long	exception_error			! 126 0x11c0
+	.long	exception_error			! 127 0x11e0
+	.long	do_IRQ				! 128 0x1200 Video Processor BLITER
+	.long	exception_error			! 129 0x1220
+	.long	exception_error			! 130 0x1240
+	.long	exception_error			! 131 0x1260
+	.long	do_IRQ				! 132 0x1280 UART0 UART0
+	.long	exception_error			! 133 0x12a0
+	.long	do_IRQ				! 134 0x12c0       UART2
+	.long	exception_error			! 135 0x12e0
+	.long	do_IRQ				! 136 0x1300 Additional PIO IO_PIO0
+	.long	exception_error			! 137 0x1320
+	.long	exception_error			! 138 0x1340
+	.long	exception_error			! 139 0x1360
+	.long	do_IRQ				! 140 0x1380 EMPI INV_ADDR
+	.long	exception_error			! 141 0x13a0
+	.long	exception_error			! 142 0x13c0
+	.long	exception_error			! 143 0x13e0
+	.long	do_IRQ				! 144 0x1400 MAFE
+	.long	exception_error			! 145 0x1420
+	.long	exception_error			! 146 0x1440
+	.long	exception_error			! 147 0x1460
+	.long	do_IRQ				! 148 0x1480 PWM
+	.long	exception_error			! 149 0x14a0
+	.long	exception_error			! 150 0x14c0
+	.long	exception_error			! 151 0x14e0
+	.long	do_IRQ				! 152 0x1500 SSC1
+	.long	exception_error			! 153 0x1520
+	.long	exception_error			! 154 0x1540
+	.long	exception_error			! 155 0x1560
+	.long	do_IRQ				! 156 0x1580 Additional PIO IO_PIO1
+	.long	exception_error			! 157 0x15a0
+	.long	exception_error			! 158 0x15c0
+	.long	exception_error			! 159 0x15e0
+	.long	do_IRQ				! 160 0x1600 USB target
+	.long	exception_error			! 161 0x1620
+	.long	exception_error			! 162 0x1640
+	.long	exception_error			! 163 0x1660
+	.long	do_IRQ				! 164 0x1680 UART1 UART1
+	.long	exception_error			! 165 0x16a0
+	.long	exception_error			! 166 0x16c0
+	.long	exception_error			! 167 0x16e0
+	.long	do_IRQ				! 168 0x1700 Teletext TTXT
+	.long	exception_error			! 169 0x1720
+	.long	exception_error			! 170 0x1740
+	.long	exception_error			! 171 0x1760
+	.long	do_IRQ				! 172 0x1780 Video Sync VTG
+	.long	do_IRQ				! 173 0x17a0            DVP0
+	.long	do_IRQ				! 174 0x17c0            DVP1
+	.long	exception_error			! 175 0x17e0
+# elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+	.long	do_IRQ			! 112 0x1000 PIO3
+	.long	do_IRQ			! 113 0x1020 PIO4
+	.long	do_IRQ			! 114 0x1040 PIO5
+	.long	do_IRQ			! 115 0x1060 PIO6
+	.long	do_IRQ			! 116 0x1080 PIO7
+	.long	do_IRQ			! 117 0x10a0 SSC0
+	.long	do_IRQ			! 118 0x10c0 SSC1
+	.long	do_IRQ			! 119 0x10e0 UART4
+	.long	do_IRQ			! 120 0x1100 UART0
+	.long	do_IRQ			! 121 0x1120 UART1
+	.long	do_IRQ			! 122 0x1140 UART2
+	.long	do_IRQ			! 123 0x1160 UART3
+	.long	do_IRQ			! 124 0x1180 MAFE
+	.long	do_IRQ			! 125 0x11a0 PWM
+	.long	exception_error		! 126 0x11c0
+	.long	exception_error		! 127 0x11e0
+	.long	do_IRQ			! 128 0x1200 IRB
+	.long	exception_error		! 129 0x1220
+	.long	exception_error		! 130 0x1240
+	.long	exception_error		! 131 0x1260
+	.long	do_IRQ			! 132 0x1280 TTXT0
+	.long	do_IRQ			! 133 0x12a0 TTXT1
+	.long	exception_error		! 134 0x12c0
+	.long	exception_error		! 135 0x12e0
+	.long	do_IRQ			! 136 0x1300 HCI-USBH0
+	.long	do_IRQ			! 137 0x1320 HCI-USBH1
+	.long	exception_error		! 138 0x1340
+	.long	exception_error		! 139 0x1360
+	.long	do_IRQ			! 140 0x1380 Mailbox (ST40)
+	.long	do_IRQ			! 141 0x13a0 WDST20
+	.long	do_IRQ			! 142 0x13c0 IRB_wakeup
+	.long	do_IRQ			! 143 0x13e0 LPA_IRQ
+	.long	do_IRQ			! 144 0x1400 AUD_CD0
+	.long	do_IRQ			! 145 0x1420 AUD_CD1
+	.long	do_IRQ			! 146 0x1440 AUD_CD2
+	.long	do_IRQ			! 147 0x1460 AUD_PCM
+	.long	do_IRQ			! 148 0x1480 AUD_ADEC
+	.long	do_IRQ			! 149 0x14a0 AUD_SPDIF
+	.long	exception_error		! 150 0x14c0
+	.long	exception_error		! 151 0x14e0
+	.long	do_IRQ			! 152 0x1500 VID0
+	.long	do_IRQ			! 153 0x1520 VID1
+	.long	exception_error		! 154 0x1540
+	.long	exception_error		! 155 0x1560
+	.long	exception_error		! 156 0x1580
+	.long	exception_error		! 157 0x15a0
+	.long	do_IRQ			! 158 0x15c0 VTG_line
+	.long	do_IRQ			! 159 0x15e0 VTG_sync
+	.long	do_IRQ			! 160 0x1600 Blitter
+	.long	do_IRQ			! 161 0x1620 DVP
+	.long	exception_error		! 162 0x1640
+	.long	exception_error		! 163 0x1660
+	.long	do_IRQ			! 164 0x1680 PTI0
+	.long	do_IRQ			! 165 0x16a0 PTI1
+	.long	exception_error		! 166 0x16c0
+	.long	exception_error		! 167 0x16e0
+	.long	do_IRQ			! 168 0x1700 TSMW
+	.long	exception_error		! 169 0x1720
+	.long	exception_error		! 170 0x1740
+	.long	exception_error		! 171 0x1760
+	.long	do_IRQ			! 172 0x1780 PCP
+	.long	do_IRQ			! 173 0x17a0 HDDI
+	.long	exception_error		! 174 0x17c0
+	.long	exception_error		! 175 0x17e0
+# elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+	.long	do_IRQ			! 112 0x1000 ILC interrupt_out[0]
+	.long	exception_error		! 113 0x1020
+	.long	exception_error		! 114 0x1040
+	.long	exception_error		! 115 0x1060
+	.long	do_IRQ			! 116 0x1080 ILC interrupt_out[1]
+	.long	exception_error		! 117 0x10a0
+	.long	exception_error		! 118 0x10c0
+	.long	exception_error		! 119 0x10e0
+	.long	do_IRQ			! 120 0x1100 ILC interrupt_out[2]
+	.long	exception_error		! 121 0x1120
+	.long	exception_error		! 122 0x1140
+	.long	exception_error		! 123 0x1160
+	.long	do_IRQ			! 124 0x1180 ILC interrupt_out[3]
+	.long	exception_error		! 125 0x11a0
+	.long	exception_error		! 126 0x11c0
+	.long	exception_error		! 127 0x11e0
+	.long	do_IRQ			! 128 0x1200 ILC interrupt_out[4]
+	.long	exception_error		! 129 0x1220
+	.long	exception_error		! 130 0x1240
+	.long	exception_error		! 131 0x1260
+	.long	do_IRQ			! 132 0x1280 ILC interrupt_out[5]
+	.long	exception_error		! 133 0x12a0
+	.long	exception_error		! 134 0x12c0
+	.long	exception_error		! 135 0x12e0
+	.long	do_IRQ			! 136 0x1300 ILC interrupt_out[6]
+	.long	exception_error		! 137 0x1320
+	.long	exception_error		! 138 0x1340
+	.long	exception_error		! 139 0x1360
+	.long	do_IRQ			! 140 0x1380 ILC interrupt_out[7]
+	.long	exception_error		! 141 0x13a0
+	.long	exception_error		! 142 0x13c0
+	.long	exception_error		! 143 0x13e0
+	.long	do_IRQ			! 144 0x1400 ILC interrupt_out[8]
+	.long	exception_error		! 145 0x1420
+	.long	exception_error		! 146 0x1440
+	.long	exception_error		! 147 0x1460
+	.long	do_IRQ			! 148 0x1480 ILC interrupt_out[9]
+	.long	exception_error		! 149 0x14a0
+	.long	exception_error		! 150 0x14c0
+	.long	exception_error		! 151 0x14e0
+	.long	do_IRQ			! 152 0x1500 ILC interrupt_out[10]
+	.long	exception_error		! 153 0x1520
+	.long	exception_error		! 154 0x1540
+	.long	exception_error		! 155 0x1560
+	.long	do_IRQ			! 156 0x1580 ILC interrupt_out[11]
+	.long	exception_error		! 157 0x15a0
+	.long	exception_error		! 158 0x15c0
+	.long	exception_error		! 159 0x15e0
+	.long	do_IRQ			! 160 0x1600 ILC interrupt_out[12]
+	.long	exception_error		! 161 0x1620
+	.long	exception_error		! 162 0x1640
+	.long	exception_error		! 163 0x1660
+	.long	do_IRQ			! 164 0x1680 ILC interrupt_out[13]
+	.long	exception_error		! 165 0x16a0
+	.long	exception_error		! 166 0x16c0
+	.long	exception_error		! 167 0x16e0
+	.long	do_IRQ			! 168 0x1700 ILC interrupt_out[14]
+	.long	exception_error		! 169 0x1720
+	.long	exception_error		! 170 0x1740
+	.long	exception_error		! 171 0x1760
+	.long	do_IRQ			! 172 0x1780 ILC interrupt_out[15]
+	.long	exception_error		! 173 0x17a0
+	.long	exception_error		! 174 0x17c0
+	.long	exception_error		! 175 0x17e0
+# elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+	.long	exception_error		! 112 0x1000
+	.long	do_IRQ			! 113 0x1020 pio5
+	.long	do_IRQ			! 114 0x1040 pio4
+	.long	do_IRQ			! 115 0x1060 pio3
+	.long	do_IRQ			! 116 0x1080 mtp (7109)
+	.long	do_IRQ			! 117 0x10a0 ssc2
+	.long	do_IRQ			! 118 0x10c0 ssc1
+	.long	do_IRQ			! 119 0x10e0 ssc0
+	.long	do_IRQ			! 120 0x1100 uart3
+	.long	do_IRQ			! 121 0x1120 uart2
+	.long	do_IRQ			! 122 0x1140 uart1
+	.long	do_IRQ			! 123 0x1160 uart0
+	.long	do_IRQ			! 124 0x1180 irb_wakeup
+	.long	do_IRQ			! 125 0x11a0 irb
+	.long	do_IRQ			! 126 0x11c0 pwm
+	.long	do_IRQ			! 127 0x11e0 mafe
+	.long	exception_error		! 128 0x1200
+	.long	do_IRQ			! 129 0x1220 disqec
+	.long	do_IRQ			! 130 0x1240 daa
+	.long	do_IRQ			! 131 0x1260 ttxt
+	.long	do_IRQ			! 132 0x1280 empi (7109)
+	.long	do_IRQ			! 133 0x12a0 eth_mac (7109)
+	.long	do_IRQ			! 134 0x12c0 TS_Merger (7109)
+	.long	do_IRQ			! 135 0x12e0 sbatm
+	.long	do_IRQ			! 136 0x1300 lx_delphi (lx_deltaMu 7109)
+	.long	do_IRQ			! 137 0x1320 lx_aud
+	.long	do_IRQ			! 138 0x1340 dcxo
+	.long	do_IRQ			! 139 0x1360 pti1 (7109)
+	.long	do_IRQ			! 140 0x1380 fdma_mbox
+	.long	do_IRQ			! 141 0x13a0 fdma_gp0
+	.long	do_IRQ			! 142 0x13c0 i2s2spdif
+	.long	do_IRQ			! 143 0x13e0 cpxm
+	.long	do_IRQ			! 144 0x1400 pcmplyr0
+	.long	do_IRQ			! 145 0x1420 pcmplyr1
+	.long	do_IRQ			! 146 0x1440 pcmrdr
+	.long	do_IRQ			! 147 0x1460 spdifplyr
+	.long	do_IRQ			! 148 0x1480 glh
+	.long	do_IRQ			! 149 0x14a0 delphi_pre0
+	.long	do_IRQ			! 150 0x14c0 delphi_pre1
+	.long	do_IRQ			! 151 0x14e0 delphi_mbe
+	.long	do_IRQ			! 152 0x1500 vdp_fifo_empty (7109)
+	.long	do_IRQ			! 153 0x1520 lmu (vdp_end_processing 7109)
+	.long	do_IRQ			! 154 0x1540 vtg1
+	.long	do_IRQ			! 155 0x1560 vtg2
+	.long	do_IRQ			! 156 0x1580 blt (bdisp_aq1 7109)
+	.long	do_IRQ			! 157 0x15a0 dvp
+	.long	do_IRQ			! 158 0x15c0 hdmi
+	.long	do_IRQ			! 159 0x15e0 hdcp
+	.long	do_IRQ			! 160 0x1600 pti
+	.long	do_IRQ			! 161 0x1620 pdes_esa0_select (7109)
+	.long	do_IRQ			! 162 0x1640 pdes
+	.long	do_IRQ			! 163 0x1660 pdes_read_cw (7109)
+	.long	do_IRQ			! 164 0x1680 sig_chk (tkdma_tkd 7109)
+	.long	do_IRQ			! 165 0x16a0 dma_fin (tkdma_dma 7109)
+	.long	do_IRQ			! 166 0x16c0 sec_cp (cripto_sig_dma 7109)
+	.long	do_IRQ			! 167 0x16e0 (cripto_sig_chk 7109)
+	.long	do_IRQ			! 168 0x1700 ohci
+	.long	do_IRQ			! 169 0x1720 ehci
+	.long	do_IRQ			! 170 0x1740 sata
+	.long	do_IRQ			! 171 0x1760 bdisp_cq1 (7109)
+	.long	do_IRQ			! 172 0x1780 icam3_kte (7109)
+	.long	do_IRQ			! 173 0x17a0 icam3 (7109)
+	.long	do_IRQ			! 174 0x17c0 mes_lmi_vid (7109)
+	.long	do_IRQ			! 175 0x17e0 mes_lmi_sys (7109)
+# else
+#  error Unknown ST40 type
+# endif
+#elif defined(CONFIG_CPU_SUBTYPE_SH7770)
+	.long	do_IRQ	!  50 0x840
+	.long	do_IRQ	!  51 0x860
+	.long	do_IRQ	!  52 0x880
+	.long	do_IRQ	!  53 0x8a0
+	.long	do_IRQ	!  54 0x8c0
+	.long	do_IRQ	!  55 0x8e0
+	.long	do_IRQ	!  56 0x900
+	.long	do_IRQ	!  57 0x920
+	.long	do_IRQ	!  58 0x940
+	.long	do_IRQ	!  59 0x960
+	.long	do_IRQ	!  60 0x980
+	.long	do_IRQ	!  61 0x9a0
+	.long	do_IRQ	!  62 0x9c0
+	.long	do_IRQ	!  63 0x9e0
+	.long	do_IRQ	!  64 0xa00
+	.long	do_IRQ	!  65 0xa20
+	.long	do_IRQ	!  66 0xa4d
+	.long	do_IRQ	!  67 0xa60
+	.long	do_IRQ	!  68 0xa80
+	.long	do_IRQ	!  69 0xaa0
+	.long	do_IRQ	!  70 0xac0
+	.long	do_IRQ	!  71 0xae0
+	.long	do_IRQ	!  72 0xb00
+	.long	do_IRQ	!  73 0xb20
+	.long	do_IRQ	!  74 0xb40
+	.long	do_IRQ	!  75 0xb60
+	.long	do_IRQ	!  76 0xb80
+	.long	do_IRQ	!  77 0xba0
+	.long	do_IRQ	!  78 0xbc0
+	.long	do_IRQ	!  79 0xbe0
+	.long	do_IRQ	!  80 0xc00
+	.long	do_IRQ	!  81 0xc20
+	.long	do_IRQ	!  82 0xc40
+	.long	do_IRQ	!  83 0xc60
+	.long	do_IRQ	!  84 0xc80
+	.long	do_IRQ	!  85 0xca0
+	.long	do_IRQ	!  86 0xcc0
+	.long	do_IRQ	!  87 0xce0
+	.long	do_IRQ	!  88 0xd00
+	.long	do_IRQ	!  89 0xd20
+	.long	do_IRQ	!  90 0xd40
+	.long	do_IRQ	!  91 0xd60
+	.long	do_IRQ	!  92 0xd80
+	.long	do_IRQ	!  93 0xda0
+	.long	do_IRQ	!  94 0xdc0
+	.long	do_IRQ	!  95 0xde0
+	.long	do_IRQ	!  96 0xe00
+	.long	do_IRQ	!  97 0xe20
+	.long	do_IRQ	!  98 0xe40
+	.long	do_IRQ	!  99 0xe60
+	.long	do_IRQ	! 100 0xe80
+	.long	do_IRQ	! 101 0xea0
+	.long	do_IRQ	! 102 0xec0
+	.long	do_IRQ	! 103 0xee0
+	.long	do_IRQ	! 104 0xf00
+	.long	do_IRQ	! 105 0xf20
+	.long	do_IRQ	! 106 0xf40
+	.long	do_IRQ	! 107 0xf60
+	.long	do_IRQ	! 108 0xf80
+#endif
+#else
+	.long	exception_error		/* 400 */
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! RTC	ati
+	.long	do_IRQ	!	pri
+	.long	do_IRQ	!	cui
+	.long	exception_error
+	.long	exception_error		/* 500 */
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! WDT	iti	/* 560 */
+	.long	do_IRQ	! TMU-ch0
+	.long	do_IRQ	! TMU-ch1
+	.long	do_IRQ	! TMU-ch2
+	.long	do_IRQ	! ticpi2	/* 5E0 */
+	.long	do_IRQ	! 32 Hitachi UDI	/* 600 */
+	.long	exception_error
+	.long	do_IRQ	! 34 DMAC dmte0
+	.long	do_IRQ	! 35	  dmte1
+	.long	do_IRQ	! 36	  dmte2
+	.long	do_IRQ	! 37	  dmte3
+	.long	do_IRQ	! 38	  dmae
+	.long	exception_error			! 39	/* 6E0 */
+	.long	do_IRQ	! 40 SCIF-ch0 eri		/* 700 */
+	.long	do_IRQ	! 41	      rxi
+	.long	do_IRQ	! 42	      bri
+	.long	do_IRQ	! 43	      txi
+	.long	do_IRQ	! 44 DMAC dmte4		/* 780 */
+	.long	do_IRQ	! 45	  dmte5
+	.long	do_IRQ	! 46	  dmte6
+	.long	do_IRQ	! 47	  dmte7		/* 7E0 */
+#if defined(CONFIG_SH_FPU)
+	.long	do_fpu_state_restore	! 48	/* 800 */
+	.long	do_fpu_state_restore	! 49	/* 820 */
+#else
+	.long	exception_error
+	.long	exception_error
+#endif
+	.long	exception_error			/* 840 */
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! 56 CMT	/* 900 */
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! 60 HAC
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! PCI serr	/* A00 */
+	.long	do_IRQ	!     INTA
+	.long	do_IRQ	!     INTB
+	.long	do_IRQ	!     INTC
+	.long	do_IRQ	!     INTD
+	.long	do_IRQ	!     err
+	.long	do_IRQ	!     pwd3
+	.long	do_IRQ	!     pwd2
+	.long	do_IRQ	!     pwd1	/* B00 */
+	.long	do_IRQ	!     pwd0
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! SCIF-ch1 eri	/* B80 */
+	.long	do_IRQ	!	   rxi
+	.long	do_IRQ	!	   bri
+	.long	do_IRQ	!	   txi
+	.long	do_IRQ	! SIOF		/* C00 */
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! HSPI		/* C80 */
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! MMCIF	fatat	/* D00 */
+	.long	do_IRQ	!	tran
+	.long	do_IRQ	!	err
+	.long	do_IRQ	!	frdy
+	.long	do_IRQ	! DMAC dmint8	/* D80 */
+	.long	do_IRQ	!      dmint9
+	.long	do_IRQ	!      dmint10
+	.long	do_IRQ	!      dmint11
+	.long	do_IRQ	! TMU-ch3	/* E00 */
+	.long	do_IRQ	! TMU-ch4
+	.long	do_IRQ	! TMU-ch5
+	.long	exception_error
+	.long	do_IRQ	! SSI
+	.long	exception_error
+	.long	exception_error
+	.long	exception_error
+	.long	do_IRQ	! FLCTL	flste	/* F00 */
+	.long	do_IRQ	!	fltend
+	.long	do_IRQ	!	fltrq0
+	.long	do_IRQ	!	fltrq1
+	.long	do_IRQ	! GPIO gpioi0	/* F80 */
+	.long	do_IRQ	!      gpioi1
+	.long	do_IRQ	!      gpioi2
+	.long	do_IRQ	!      gpioi3
 #endif
 
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/fpu.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/fpu.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/fpu.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/fpu.c	2006-08-23 13:29:48.163807000 +0100
@@ -9,14 +9,16 @@
  * for more details.
  *
  * Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
+ * Copyright (C) 2006  ST Microelectronics Ltd. (denorm support)
  *
- * FIXME! These routines can be optimized in big endian case.
+ * FIXME! These routines have not been tested for big endian case.
  */
 
 #include <linux/sched.h>
 #include <linux/signal.h>
 #include <asm/processor.h>
 #include <asm/io.h>
+#include "sh4_fpu.h"
 
 /* The PR (precision) bit in the FP Status Register must be clear when
  * an frchg instruction is executed, otherwise the instruction is undefined.
@@ -24,113 +26,122 @@
  */
 
 #define FPSCR_RCHG 0x00000000
+extern unsigned long long float64_div(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_div(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_mul(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_mul(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_add(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_add(unsigned long int a, unsigned long int b);
+extern unsigned long long float64_sub(unsigned long long a,
+				      unsigned long long b);
+extern unsigned long int float32_sub(unsigned long int a, unsigned long int b);
 
+static unsigned int fpu_exception_flags;
 
 /*
  * Save FPU registers onto task structure.
  * Assume called with FPU enabled (SR.FD=0).
  */
-void
-save_fpu(struct task_struct *tsk, struct pt_regs *regs)
+void save_fpu(struct task_struct *tsk, struct pt_regs *regs)
 {
 	unsigned long dummy;
 
 	clear_tsk_thread_flag(tsk, TIF_USEDFPU);
 	enable_fpu();
-	asm volatile("sts.l	fpul, @-%0\n\t"
-		     "sts.l	fpscr, @-%0\n\t"
-		     "lds	%2, fpscr\n\t"
-		     "frchg\n\t"
-		     "fmov.s	fr15, @-%0\n\t"
-		     "fmov.s	fr14, @-%0\n\t"
-		     "fmov.s	fr13, @-%0\n\t"
-		     "fmov.s	fr12, @-%0\n\t"
-		     "fmov.s	fr11, @-%0\n\t"
-		     "fmov.s	fr10, @-%0\n\t"
-		     "fmov.s	fr9, @-%0\n\t"
-		     "fmov.s	fr8, @-%0\n\t"
-		     "fmov.s	fr7, @-%0\n\t"
-		     "fmov.s	fr6, @-%0\n\t"
-		     "fmov.s	fr5, @-%0\n\t"
-		     "fmov.s	fr4, @-%0\n\t"
-		     "fmov.s	fr3, @-%0\n\t"
-		     "fmov.s	fr2, @-%0\n\t"
-		     "fmov.s	fr1, @-%0\n\t"
-		     "fmov.s	fr0, @-%0\n\t"
-		     "frchg\n\t"
-		     "fmov.s	fr15, @-%0\n\t"
-		     "fmov.s	fr14, @-%0\n\t"
-		     "fmov.s	fr13, @-%0\n\t"
-		     "fmov.s	fr12, @-%0\n\t"
-		     "fmov.s	fr11, @-%0\n\t"
-		     "fmov.s	fr10, @-%0\n\t"
-		     "fmov.s	fr9, @-%0\n\t"
-		     "fmov.s	fr8, @-%0\n\t"
-		     "fmov.s	fr7, @-%0\n\t"
-		     "fmov.s	fr6, @-%0\n\t"
-		     "fmov.s	fr5, @-%0\n\t"
-		     "fmov.s	fr4, @-%0\n\t"
-		     "fmov.s	fr3, @-%0\n\t"
-		     "fmov.s	fr2, @-%0\n\t"
-		     "fmov.s	fr1, @-%0\n\t"
-		     "fmov.s	fr0, @-%0\n\t"
-		     "lds	%3, fpscr\n\t"
-		     : "=r" (dummy)
-		     : "0" ((char *)(&tsk->thread.fpu.hard.status)),
-		       "r" (FPSCR_RCHG),
-		       "r" (FPSCR_INIT)
-		     : "memory");
+	asm volatile ("sts.l	fpul, @-%0\n\t"
+		      "sts.l	fpscr, @-%0\n\t"
+		      "lds	%2, fpscr\n\t"
+		      "frchg\n\t"
+		      "fmov.s	fr15, @-%0\n\t"
+		      "fmov.s	fr14, @-%0\n\t"
+		      "fmov.s	fr13, @-%0\n\t"
+		      "fmov.s	fr12, @-%0\n\t"
+		      "fmov.s	fr11, @-%0\n\t"
+		      "fmov.s	fr10, @-%0\n\t"
+		      "fmov.s	fr9, @-%0\n\t"
+		      "fmov.s	fr8, @-%0\n\t"
+		      "fmov.s	fr7, @-%0\n\t"
+		      "fmov.s	fr6, @-%0\n\t"
+		      "fmov.s	fr5, @-%0\n\t"
+		      "fmov.s	fr4, @-%0\n\t"
+		      "fmov.s	fr3, @-%0\n\t"
+		      "fmov.s	fr2, @-%0\n\t"
+		      "fmov.s	fr1, @-%0\n\t"
+		      "fmov.s	fr0, @-%0\n\t"
+		      "frchg\n\t"
+		      "fmov.s	fr15, @-%0\n\t"
+		      "fmov.s	fr14, @-%0\n\t"
+		      "fmov.s	fr13, @-%0\n\t"
+		      "fmov.s	fr12, @-%0\n\t"
+		      "fmov.s	fr11, @-%0\n\t"
+		      "fmov.s	fr10, @-%0\n\t"
+		      "fmov.s	fr9, @-%0\n\t"
+		      "fmov.s	fr8, @-%0\n\t"
+		      "fmov.s	fr7, @-%0\n\t"
+		      "fmov.s	fr6, @-%0\n\t"
+		      "fmov.s	fr5, @-%0\n\t"
+		      "fmov.s	fr4, @-%0\n\t"
+		      "fmov.s	fr3, @-%0\n\t"
+		      "fmov.s	fr2, @-%0\n\t"
+		      "fmov.s	fr1, @-%0\n\t"
+		      "fmov.s	fr0, @-%0\n\t"
+		      "lds	%3, fpscr\n\t":"=r" (dummy)
+		      :"0"((char *)(&tsk->thread.fpu.hard.status)),
+		      "r"(FPSCR_RCHG), "r"(FPSCR_INIT)
+		      :"memory");
 
- 	disable_fpu();
- 	release_fpu(regs);
+	disable_fpu();
+	release_fpu(regs);
 }
 
-static void
-restore_fpu(struct task_struct *tsk)
+static void restore_fpu(struct task_struct *tsk)
 {
 	unsigned long dummy;
 
- 	enable_fpu();
-	asm volatile("lds	%2, fpscr\n\t"
-		     "fmov.s	@%0+, fr0\n\t"
-		     "fmov.s	@%0+, fr1\n\t"
-		     "fmov.s	@%0+, fr2\n\t"
-		     "fmov.s	@%0+, fr3\n\t"
-		     "fmov.s	@%0+, fr4\n\t"
-		     "fmov.s	@%0+, fr5\n\t"
-		     "fmov.s	@%0+, fr6\n\t"
-		     "fmov.s	@%0+, fr7\n\t"
-		     "fmov.s	@%0+, fr8\n\t"
-		     "fmov.s	@%0+, fr9\n\t"
-		     "fmov.s	@%0+, fr10\n\t"
-		     "fmov.s	@%0+, fr11\n\t"
-		     "fmov.s	@%0+, fr12\n\t"
-		     "fmov.s	@%0+, fr13\n\t"
-		     "fmov.s	@%0+, fr14\n\t"
-		     "fmov.s	@%0+, fr15\n\t"
-		     "frchg\n\t"
-		     "fmov.s	@%0+, fr0\n\t"
-		     "fmov.s	@%0+, fr1\n\t"
-		     "fmov.s	@%0+, fr2\n\t"
-		     "fmov.s	@%0+, fr3\n\t"
-		     "fmov.s	@%0+, fr4\n\t"
-		     "fmov.s	@%0+, fr5\n\t"
-		     "fmov.s	@%0+, fr6\n\t"
-		     "fmov.s	@%0+, fr7\n\t"
-		     "fmov.s	@%0+, fr8\n\t"
-		     "fmov.s	@%0+, fr9\n\t"
-		     "fmov.s	@%0+, fr10\n\t"
-		     "fmov.s	@%0+, fr11\n\t"
-		     "fmov.s	@%0+, fr12\n\t"
-		     "fmov.s	@%0+, fr13\n\t"
-		     "fmov.s	@%0+, fr14\n\t"
-		     "fmov.s	@%0+, fr15\n\t"
-		     "frchg\n\t"
-		     "lds.l	@%0+, fpscr\n\t"
-		     "lds.l	@%0+, fpul\n\t"
-		     : "=r" (dummy)
-		     : "0" (&tsk->thread.fpu), "r" (FPSCR_RCHG)
-		     : "memory");
+	enable_fpu();
+	asm volatile ("lds	%2, fpscr\n\t"
+		      "fmov.s	@%0+, fr0\n\t"
+		      "fmov.s	@%0+, fr1\n\t"
+		      "fmov.s	@%0+, fr2\n\t"
+		      "fmov.s	@%0+, fr3\n\t"
+		      "fmov.s	@%0+, fr4\n\t"
+		      "fmov.s	@%0+, fr5\n\t"
+		      "fmov.s	@%0+, fr6\n\t"
+		      "fmov.s	@%0+, fr7\n\t"
+		      "fmov.s	@%0+, fr8\n\t"
+		      "fmov.s	@%0+, fr9\n\t"
+		      "fmov.s	@%0+, fr10\n\t"
+		      "fmov.s	@%0+, fr11\n\t"
+		      "fmov.s	@%0+, fr12\n\t"
+		      "fmov.s	@%0+, fr13\n\t"
+		      "fmov.s	@%0+, fr14\n\t"
+		      "fmov.s	@%0+, fr15\n\t"
+		      "frchg\n\t"
+		      "fmov.s	@%0+, fr0\n\t"
+		      "fmov.s	@%0+, fr1\n\t"
+		      "fmov.s	@%0+, fr2\n\t"
+		      "fmov.s	@%0+, fr3\n\t"
+		      "fmov.s	@%0+, fr4\n\t"
+		      "fmov.s	@%0+, fr5\n\t"
+		      "fmov.s	@%0+, fr6\n\t"
+		      "fmov.s	@%0+, fr7\n\t"
+		      "fmov.s	@%0+, fr8\n\t"
+		      "fmov.s	@%0+, fr9\n\t"
+		      "fmov.s	@%0+, fr10\n\t"
+		      "fmov.s	@%0+, fr11\n\t"
+		      "fmov.s	@%0+, fr12\n\t"
+		      "fmov.s	@%0+, fr13\n\t"
+		      "fmov.s	@%0+, fr14\n\t"
+		      "fmov.s	@%0+, fr15\n\t"
+		      "frchg\n\t"
+		      "lds.l	@%0+, fpscr\n\t"
+		      "lds.l	@%0+, fpul\n\t"
+		      :"=r" (dummy)
+		      :"0"(&tsk->thread.fpu), "r"(FPSCR_RCHG)
+		      :"memory");
 	disable_fpu();
 }
 
@@ -140,61 +151,59 @@
  * double precission represents signaling NANS.  
  */
 
-static void
-fpu_init(void)
+static void fpu_init(void)
 {
 	enable_fpu();
-	asm volatile("lds	%0, fpul\n\t"
-		     "lds	%1, fpscr\n\t"
-		     "fsts	fpul, fr0\n\t"
-		     "fsts	fpul, fr1\n\t"
-		     "fsts	fpul, fr2\n\t"
-		     "fsts	fpul, fr3\n\t"
-		     "fsts	fpul, fr4\n\t"
-		     "fsts	fpul, fr5\n\t"
-		     "fsts	fpul, fr6\n\t"
-		     "fsts	fpul, fr7\n\t"
-		     "fsts	fpul, fr8\n\t"
-		     "fsts	fpul, fr9\n\t"
-		     "fsts	fpul, fr10\n\t"
-		     "fsts	fpul, fr11\n\t"
-		     "fsts	fpul, fr12\n\t"
-		     "fsts	fpul, fr13\n\t"
-		     "fsts	fpul, fr14\n\t"
-		     "fsts	fpul, fr15\n\t"
-		     "frchg\n\t"
-		     "fsts	fpul, fr0\n\t"
-		     "fsts	fpul, fr1\n\t"
-		     "fsts	fpul, fr2\n\t"
-		     "fsts	fpul, fr3\n\t"
-		     "fsts	fpul, fr4\n\t"
-		     "fsts	fpul, fr5\n\t"
-		     "fsts	fpul, fr6\n\t"
-		     "fsts	fpul, fr7\n\t"
-		     "fsts	fpul, fr8\n\t"
-		     "fsts	fpul, fr9\n\t"
-		     "fsts	fpul, fr10\n\t"
-		     "fsts	fpul, fr11\n\t"
-		     "fsts	fpul, fr12\n\t"
-		     "fsts	fpul, fr13\n\t"
-		     "fsts	fpul, fr14\n\t"
-		     "fsts	fpul, fr15\n\t"
-		     "frchg\n\t"
-		     "lds	%2, fpscr\n\t"
-		     : /* no output */
-		     : "r" (0), "r" (FPSCR_RCHG), "r" (FPSCR_INIT));
- 	disable_fpu();
+	asm volatile (	"lds	%0, fpul\n\t"
+			"lds	%1, fpscr\n\t"
+			"fsts	fpul, fr0\n\t"
+			"fsts	fpul, fr1\n\t"
+			"fsts	fpul, fr2\n\t"
+			"fsts	fpul, fr3\n\t"
+			"fsts	fpul, fr4\n\t"
+			"fsts	fpul, fr5\n\t"
+			"fsts	fpul, fr6\n\t"
+			"fsts	fpul, fr7\n\t"
+			"fsts	fpul, fr8\n\t"
+			"fsts	fpul, fr9\n\t"
+			"fsts	fpul, fr10\n\t"
+			"fsts	fpul, fr11\n\t"
+			"fsts	fpul, fr12\n\t"
+			"fsts	fpul, fr13\n\t"
+			"fsts	fpul, fr14\n\t"
+			"fsts	fpul, fr15\n\t"
+			"frchg\n\t"
+			"fsts	fpul, fr0\n\t"
+			"fsts	fpul, fr1\n\t"
+			"fsts	fpul, fr2\n\t"
+			"fsts	fpul, fr3\n\t"
+			"fsts	fpul, fr4\n\t"
+			"fsts	fpul, fr5\n\t"
+			"fsts	fpul, fr6\n\t"
+			"fsts	fpul, fr7\n\t"
+			"fsts	fpul, fr8\n\t"
+			"fsts	fpul, fr9\n\t"
+			"fsts	fpul, fr10\n\t"
+			"fsts	fpul, fr11\n\t"
+			"fsts	fpul, fr12\n\t"
+			"fsts	fpul, fr13\n\t"
+			"fsts	fpul, fr14\n\t"
+			"fsts	fpul, fr15\n\t"
+			"frchg\n\t"
+			"lds	%2, fpscr\n\t"
+			:	/* no output */
+		      	:"r" (0), "r"(FPSCR_RCHG), "r"(FPSCR_INIT));
+	disable_fpu();
 }
 
 /**
- *	denormal_to_double - Given denormalized float number,
- *	                     store double float
+ *      denormal_to_double - Given denormalized float number,
+ *                           store double float
  *
- *	@fpu: Pointer to sh_fpu_hard structure
- *	@n: Index to FP register
+ *      @fpu: Pointer to sh_fpu_hard structure
+ *      @n: Index to FP register
  */
-static void
-denormal_to_double (struct sh_fpu_hard_struct *fpu, int n)
+static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
 {
 	unsigned long du, dl;
 	unsigned long x = fpu->fpul;
@@ -211,7 +220,7 @@
 		dl = x << 29;
 
 		fpu->fp_regs[n] = du;
-		fpu->fp_regs[n+1] = dl;
+		fpu->fp_regs[n + 1] = dl;
 	}
 }
 
@@ -222,92 +231,233 @@
  *
  *	Returns 1 when it's handled (should not cause exception).
  */
-static int
-ieee_fpe_handler (struct pt_regs *regs)
+static int ieee_fpe_handler(struct pt_regs *regs)
 {
-	unsigned short insn = *(unsigned short *) regs->pc;
+	unsigned short insn = *(unsigned short *)regs->pc;
 	unsigned short finsn;
 	unsigned long nextpc;
 	int nib[4] = {
 		(insn >> 12) & 0xf,
 		(insn >> 8) & 0xf,
 		(insn >> 4) & 0xf,
-		insn & 0xf};
+		insn & 0xf
+	};
 
-	if (nib[0] == 0xb ||
-	    (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb)) /* bsr & jsr */
-		regs->pr = regs->pc + 4;
-  
-	if (nib[0] == 0xa || nib[0] == 0xb) { /* bra & bsr */
-		nextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xd) { /* bt/s */
+	if (nib[0] == 0xb || (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb))
+		regs->pr = regs->pc + 4;  /* bsr & jsr */
+
+	if (nib[0] == 0xa || nib[0] == 0xb) {
+		/* bra & bsr */
+		nextpc = regs->pc + 4 + ((short)((insn & 0xfff) << 4) >> 3);
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xd) {
+		/* bt/s */
 		if (regs->sr & 1)
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
 		else
 			nextpc = regs->pc + 4;
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xf) { /* bf/s */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xf) {
+		/* bf/s */
 		if (regs->sr & 1)
 			nextpc = regs->pc + 4;
 		else
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* jmp & jsr */
+			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x4 && nib[3] == 0xb && (nib[2] == 0x0 || nib[2] == 0x2)) {
+		/* jmp & jsr */
 		nextpc = regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* braf & bsrf */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (nib[0] == 0x0 && nib[3] == 0x3 && (nib[2] == 0x0 || nib[2] == 0x2)) {
+		/* braf & bsrf */
 		nextpc = regs->pc + 4 + regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (insn == 0x000b) { /* rts */
+		finsn = *(unsigned short *)(regs->pc + 2);
+	} else if (insn == 0x000b) {
+		/* rts */
 		nextpc = regs->pr;
-		finsn = *(unsigned short *) (regs->pc + 2);
+		finsn = *(unsigned short *)(regs->pc + 2);
 	} else {
 		nextpc = regs->pc + 2;
 		finsn = insn;
 	}
 
-	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
+	if ((finsn & 0xf1ff) == 0xf0ad) {
+		/* fcnvsd */
 		struct task_struct *tsk = current;
 
-		save_fpu(tsk, regs);
-		if ((tsk->thread.fpu.hard.fpscr & (1 << 17))) {
+		if ((tsk->thread.fpu.hard.fpscr & FPSCR_CAUSE_ERROR)) {
 			/* FPU error */
-			denormal_to_double (&tsk->thread.fpu.hard,
-					    (finsn >> 8) & 0xf);
-			tsk->thread.fpu.hard.fpscr &=
-				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
-			grab_fpu(regs);
-			restore_fpu(tsk);
-			set_tsk_thread_flag(tsk, TIF_USEDFPU);
-		} else {
-			tsk->thread.trap_no = 11;
-			tsk->thread.error_code = 0;
-			force_sig(SIGFPE, tsk);
-		}
+			denormal_to_double(&tsk->thread.fpu.hard,
+					   (finsn >> 8) & 0xf);
+		} else
+			return 0;
 
 		regs->pc = nextpc;
 		return 1;
-	}
+	} else if ((finsn & 0xf00f) == 0xf002) {
+		/* fmul */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+			llx = float64_mul(llx, lly);
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			hx = float32_mul(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
+
+		regs->pc = nextpc;
+		return 1;
+	} else if ((finsn & 0xf00e) == 0xf000) {
+		/* fadd, fsub */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+			if ((finsn & 0xf00f) == 0xf000)
+				llx = float64_add(llx, lly);
+			else
+				llx = float64_sub(llx, lly);
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			if ((finsn & 0xf00f) == 0xf000)
+				hx = float32_add(hx, hy);
+			else
+				hx = float32_sub(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
+
+		regs->pc = nextpc;
+		return 1;
+
+	} else if ((finsn & 0xf003) == 0xf003) {
+		/* fdiv */
+		struct task_struct *tsk = current;
+		int fpscr;
+		int n, m, prec;
+		unsigned int hx, hy;
+
+		n = (finsn >> 8) & 0xf;
+		m = (finsn >> 4) & 0xf;
+		hx = tsk->thread.fpu.hard.fp_regs[n];
+		hy = tsk->thread.fpu.hard.fp_regs[m];
+		fpscr = tsk->thread.fpu.hard.fpscr;
+		prec = fpscr & FPSCR_DBL_PRECISION;
+
+		if ((fpscr & FPSCR_CAUSE_ERROR)
+		    && (prec && ((hx & 0x7fffffff) < 0x00100000
+				 || (hy & 0x7fffffff) < 0x00100000))) {
+			long long llx, lly;
+
+			/* FPU error because of denormal (doubles) */
+			llx = ((long long)hx << 32)
+			    | tsk->thread.fpu.hard.fp_regs[n + 1];
+			lly = ((long long)hy << 32)
+			    | tsk->thread.fpu.hard.fp_regs[m + 1];
+
+			llx = float64_div(llx, lly);
+
+			tsk->thread.fpu.hard.fp_regs[n] = llx >> 32;
+			tsk->thread.fpu.hard.fp_regs[n + 1] = llx & 0xffffffff;
+		} else if ((fpscr & FPSCR_CAUSE_ERROR)
+			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
+					 || (hy & 0x7fffffff) < 0x00800000))) {
+			/* FPU error because of denormal (floats) */
+			hx = float32_div(hx, hy);
+			tsk->thread.fpu.hard.fp_regs[n] = hx;
+		} else
+			return 0;
+
+		regs->pc = nextpc;
+		return 1;
+
+	} else
 
-	return 0;
+		return 0;
 }
 
-asmlinkage void
-do_fpu_error(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7,
-	     struct pt_regs regs)
+void float_raise(unsigned int flags)
+{
+	fpu_exception_flags |= flags;
+}
+
+int float_rounding_mode(void)
 {
 	struct task_struct *tsk = current;
+	int roundingMode = FPSCR_ROUNDING_MODE(tsk->thread.fpu.hard.fpscr);
+	return roundingMode;
+}
 
-	if (ieee_fpe_handler (&regs))
-		return;
+asmlinkage void
+do_fpu_error(unsigned long r4, unsigned long r5, unsigned long r6,
+	     unsigned long r7, struct pt_regs regs)
+{
+	struct task_struct *tsk = current;
 
-	regs.pc += 2;
 	save_fpu(tsk, &regs);
-	tsk->thread.trap_no = 11;
-	tsk->thread.error_code = 0;
+	fpu_exception_flags = 0;
+	if (ieee_fpe_handler(&regs)) {
+		tsk->thread.fpu.hard.fpscr &=
+		    ~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
+		tsk->thread.fpu.hard.fpscr |= fpu_exception_flags;
+		/* Set the FPSCR flag as well as cause bits - simply replicate the cause */
+		tsk->thread.fpu.hard.fpscr |= (fpu_exception_flags >> 10);
+		grab_fpu(&regs);
+		restore_fpu(tsk);
+		set_tsk_thread_flag(tsk, TIF_USEDFPU);
+		if ((((tsk->thread.fpu.hard.fpscr & FPSCR_ENABLE_MASK) >> 7) &
+		     (fpu_exception_flags >> 2)) == 0) {
+			return;
+		}
+	}
+
 	force_sig(SIGFPE, tsk);
 }
 
@@ -326,7 +476,7 @@
 	if (used_math()) {
 		/* Using the FPU again.  */
 		restore_fpu(tsk);
-	} else	{
+	} else {
 		/* First time FPU user.  */
 		fpu_init();
 		set_used_math();
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/Makefile linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/Makefile
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/Makefile	2006-08-23 13:29:48.179821000 +0100
@@ -5,13 +5,22 @@
 obj-y	:= ex.o probe.o
 
 obj-$(CONFIG_SH_FPU)                    += fpu.o
+obj-$(CONFIG_SH_FPU)                    += softfloat.o
 obj-$(CONFIG_SH_STORE_QUEUES)		+= sq.o
 
+# CPU subtype setup
+obj-$(CONFIG_CPU_SUBTYPE_SH7780)	+= setup-sh7780.o
+
 # Primary on-chip clocks (common)
 clock-$(CONFIG_CPU_SH4)			:= clock-sh4.o
 clock-$(CONFIG_CPU_SUBTYPE_SH73180)	:= clock-sh73180.o
 clock-$(CONFIG_CPU_SUBTYPE_SH7770)	:= clock-sh7770.o
 clock-$(CONFIG_CPU_SUBTYPE_SH7780)	:= clock-sh7780.o
+clock-$(CONFIG_CPU_SUBTYPE_ST40STB1)	:= clock-st40stb1.o
+clock-$(CONFIG_CPU_SUBTYPE_ST40GX1)	:= clock-st40stb1.o
+clock-$(CONFIG_CPU_SUBTYPE_STI5528)	:= clock-sti5528.o
+clock-$(CONFIG_CPU_SUBTYPE_STM8000)	:= clock-stm8000.o
+clock-$(CONFIG_CPU_SUBTYPE_STB7100)	:= clock-stb7100.o
 
 # Additional clocks by subtype
 clock-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= clock-sh4-202.o
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/probe.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/probe.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/probe.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/probe.c	2006-08-23 13:29:40.629645000 +0100
@@ -3,7 +3,7 @@
  *
  * CPU Subtype Probing for SH-4.
  *
- * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2001 - 2005  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -53,9 +53,6 @@
 	cpu_data->dcache.ways		= 1;
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
 
-	/* Set the FPU flag, virtually all SH-4's have one */
-	cpu_data->flags |= CPU_HAS_FPU;
-
 	/*
 	 * Probe the underlying processor version/revision and
 	 * adjust cpu_data setup accordingly.
@@ -63,56 +60,112 @@
 	switch (pvr) {
 	case 0x205:
 		cpu_data->type = CPU_SH7750;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
 		break;
 	case 0x206:
 		cpu_data->type = CPU_SH7750S;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
 		break;
 	case 0x1100:
 		cpu_data->type = CPU_SH7751;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x2000:
 		cpu_data->type = CPU_SH73180;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
-		cpu_data->flags &= ~CPU_HAS_FPU;
+
+		/*
+		 * XXX: Double check this, none of the SH-4A/SH-4AL processors
+		 * should have this, as it's essentially a legacy thing.
+		 */
+		cpu_data->flags |= CPU_HAS_PTEA;
+		break;
+	case 0x2001:
+	case 0x2004:
+		cpu_data->type = CPU_SH7770;
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+
+		/* Same note as above applies here for PTEA */
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		break;
+	case 0x2006:
+	case 0x200A:
+		if (prr == 0x61)
+			cpu_data->type = CPU_SH7781;
+		else
+			cpu_data->type = CPU_SH7780;
+
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		break;
+	case 0x8001 ... 0x8004:
+		/* 0x8003: cut 4 */
+		/* 0x8004: cut 5 */
+		cpu_data->type = CPU_STM8000;
 		break;
 	case 0x8100:
+		/* Some bright spark used this same ID for the STi5528 */
 		cpu_data->type = CPU_ST40GX1;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x700:
 		cpu_data->type = CPU_SH4_501;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
-
-		/* No FPU on the SH4-500 series.. */
-		cpu_data->flags &= ~CPU_HAS_FPU;
+		cpu_data->flags |= CPU_HAS_PTEA;
 		break;
 	case 0x600:
 		cpu_data->type = CPU_SH4_202;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		break;
+	case 0x610 ... 0x611:
+		/* 0x0610 cut 1.x */
+		/* 0x0611 cut 2.x */
+		cpu_data->type = CPU_STB7100;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
-		    case 0x10: cpu_data->type = CPU_SH7750R; break;
-		    case 0x11: cpu_data->type = CPU_SH7751R; break;
-		    case 0x50: cpu_data->type = CPU_SH7760;  break;
+		case 0x10:
+			cpu_data->type = CPU_SH7750R;
+			break;
+		case 0x11:
+			cpu_data->type = CPU_SH7751R;
+			break;
+		case 0x50 ... 0x5f:
+			cpu_data->type = CPU_SH7760;
+			break;
 		}
 
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
 
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+
 		break;
 	default:
 		cpu_data->type = CPU_SH_NONE;
 		break;
 	}
 
+#ifdef CONFIG_SH_DIRECT_MAPPED
+	cpu_data->icache.ways = 1;
+	cpu_data->dcache.ways = 1;
+#endif
+
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.
@@ -125,6 +178,9 @@
 			(cpu_data->icache.way_incr - (1 << 5));
 	}
 
+	cpu_data->icache.way_size = cpu_data->icache.sets *
+				    cpu_data->icache.linesz;
+
 	if (cpu_data->dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
 		cpu_data->dcache.way_incr	= (size >> 1);
@@ -133,6 +189,9 @@
 			(cpu_data->dcache.way_incr - (1 << 5));
 	}
 
+	cpu_data->dcache.way_size = cpu_data->dcache.sets *
+				    cpu_data->dcache.linesz;
+
 	return 0;
 }
 
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/setup-sh7780.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/setup-sh7780.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/setup-sh7780.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/setup-sh7780.c	2006-08-23 13:29:27.628346000 +0100
@@ -0,0 +1,52 @@
+/*
+ * SH7780 Setup
+ *
+ *  Copyright (C) 2006  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+
+static struct resource rtc_resources[] = {
+	[0] = {
+		.start	= 0xffe80000,
+		.end	= 0xffe80000 + 0x58 - 1,
+		.flags	= IORESOURCE_IO,
+	},
+	[1] = {
+		/* Period IRQ */
+		.start	= 21,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* Carry IRQ */
+		.start	= 22,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[3] = {
+		/* Alarm IRQ */
+		.start	= 23,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rtc_device = {
+	.name		= "sh-rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(rtc_resources),
+	.resource	= rtc_resources,
+};
+
+static struct platform_device *sh7780_devices[] __initdata = {
+	&rtc_device,
+};
+
+static int __init sh7780_devices_setup(void)
+{
+	return platform_add_devices(sh7780_devices,
+				    ARRAY_SIZE(sh7780_devices));
+}
+__initcall(sh7780_devices_setup);
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/sh4_fpu.h linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/sh4_fpu.h
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/sh4_fpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/sh4_fpu.h	2006-08-23 13:29:48.185827000 +0100
@@ -0,0 +1,32 @@
+/*
+ * linux/arch/sh/kernel/cpu/sh4/sh4_fpu.h
+ *
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Carl Shaw <carl.shaw@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License Version 2.  See linux/COPYING for more information.
+ *
+ * Definitions for SH4 FPU operations
+ */
+
+#ifndef __CPU_SH4_FPU_H
+#define __CPU_SH4_FPU_H
+
+#define FPSCR_ENABLE_MASK	0x00000f80UL
+
+#define FPSCR_FMOV_DOUBLE	(1<<1)
+
+#define FPSCR_CAUSE_INEXACT	(1<<12)
+#define FPSCR_CAUSE_UNDERFLOW	(1<<13)
+#define FPSCR_CAUSE_OVERFLOW	(1<<14)
+#define FPSCR_CAUSE_DIVZERO	(1<<15)
+#define FPSCR_CAUSE_INVALID	(1<<16)
+#define FPSCR_CAUSE_ERROR 	(1<<17)
+
+#define FPSCR_DBL_PRECISION	(1<<19)
+#define FPSCR_ROUNDING_MODE(x)	((x >> 20) & 3)
+#define FPSCR_RM_NEAREST	(0)
+#define FPSCR_RM_ZERO		(1)
+
+#endif
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/softfloat.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/softfloat.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/softfloat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/softfloat.c	2006-08-23 13:29:48.194829000 +0100
@@ -0,0 +1,892 @@
+/*
+ * Floating point emulation support for subnormalised numbers on SH4 architecture
+ * This file is derived from the SoftFloat IEC/IEEE Floating-point Arithmetic
+ * Package, Release 2 the original license of which is reproduced below.
+ *
+ * ===============================================================================
+ *
+ * This C source file is part of the SoftFloat IEC/IEEE Floating-point
+ * Arithmetic Package, Release 2.
+ *
+ * Written by John R. Hauser.  This work was made possible in part by the
+ * International Computer Science Institute, located at Suite 600, 1947 Center
+ * Street, Berkeley, California 94704.  Funding was partially provided by the
+ * National Science Foundation under grant MIP-9311980.  The original version
+ * of this code was written as part of a project to build a fixed-point vector
+ * processor in collaboration with the University of California at Berkeley,
+ * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+ * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/
+ * arithmetic/softfloat.html'.
+ *
+ * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+ * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+ * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+ * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+ * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+ *
+ * Derivative works are acceptable, even for commercial purposes, so long as
+ * (1) they include prominent notice that the work is derivative, and (2) they
+ * include prominent notice akin to these three paragraphs for those parts of
+ * this code that are retained.
+ *
+ * ===============================================================================
+ *
+ * SH4 modifications by Ismail Dhaoui <ismail.dhaoui@st.com>
+ * and Kamel Khelifi <kamel.khelifi@st.com>
+ * */
+
+#include <linux/kernel.h>
+#include "sh4_fpu.h"
+
+#define LIT64( a ) a##LL
+
+typedef char flag;
+typedef unsigned char uint8;
+typedef signed char int8;
+typedef int uint16;
+typedef int int16;
+typedef unsigned int uint32;
+typedef signed int int32;
+
+typedef unsigned long long int bits64;
+typedef signed long long int sbits64;
+
+typedef unsigned char bits8;
+typedef signed char sbits8;
+typedef unsigned short int bits16;
+typedef signed short int sbits16;
+typedef unsigned int bits32;
+typedef signed int sbits32;
+
+typedef unsigned long long int uint64;
+typedef signed long long int int64;
+
+typedef unsigned long int float32;
+typedef unsigned long long float64;
+
+extern void float_raise(unsigned int flags);	/* in fpu.c */
+extern int float_rounding_mode(void);	/* in fpu.c */
+
+inline bits64 extractFloat64Frac(float64 a);
+inline flag extractFloat64Sign(float64 a);
+inline int16 extractFloat64Exp(float64 a);
+inline int16 extractFloat32Exp(float32 a);
+inline flag extractFloat32Sign(float32 a);
+inline bits32 extractFloat32Frac(float32 a);
+inline float64 packFloat64(flag zSign, int16 zExp, bits64 zSig);
+inline void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr);
+inline float32 packFloat32(flag zSign, int16 zExp, bits32 zSig);
+inline void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr);
+float64 float64_sub(float64 a, float64 b);
+float32 float32_sub(float32 a, float32 b);
+float32 float32_add(float32 a, float32 b);
+float64 float64_add(float64 a, float64 b);
+float64 float64_div(float64 a, float64 b);
+float32 float32_div(float32 a, float32 b);
+float32 float32_mul(float32 a, float32 b);
+float64 float64_mul(float64 a, float64 b);
+inline void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr);
+inline void sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr);
+inline void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr);
+
+static int8 countLeadingZeros32(bits32 a);
+static int8 countLeadingZeros64(bits64 a);
+static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp,
+					    bits64 zSig);
+static float64 subFloat64Sigs(float64 a, float64 b, flag zSign);
+static float64 addFloat64Sigs(float64 a, float64 b, flag zSign);
+static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig);
+static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp,
+					    bits32 zSig);
+static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig);
+static float32 subFloat32Sigs(float32 a, float32 b, flag zSign);
+static float32 addFloat32Sigs(float32 a, float32 b, flag zSign);
+static void normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr,
+				      bits64 * zSigPtr);
+static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b);
+static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
+				      bits32 * zSigPtr);
+
+inline bits64 extractFloat64Frac(float64 a)
+{
+	return a & LIT64(0x000FFFFFFFFFFFFF);
+}
+
+inline flag extractFloat64Sign(float64 a)
+{
+	return a >> 63;
+}
+
+inline int16 extractFloat64Exp(float64 a)
+{
+	return (a >> 52) & 0x7FF;
+}
+
+inline int16 extractFloat32Exp(float32 a)
+{
+	return (a >> 23) & 0xFF;
+}
+
+inline flag extractFloat32Sign(float32 a)
+{
+	return a >> 31;
+}
+
+inline bits32 extractFloat32Frac(float32 a)
+{
+	return a & 0x007FFFFF;
+}
+
+inline float64 packFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;
+}
+
+inline void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr)
+{
+	bits64 z;
+
+	if (count == 0) {
+		z = a;
+	} else if (count < 64) {
+		z = (a >> count) | ((a << ((-count) & 63)) != 0);
+	} else {
+		z = (a != 0);
+	}
+	*zPtr = z;
+}
+
+static int8 countLeadingZeros32(bits32 a)
+{
+	static const int8 countLeadingZerosHigh[] = {
+		8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+		3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+	};
+	int8 shiftCount;
+
+	shiftCount = 0;
+	if (a < 0x10000) {
+		shiftCount += 16;
+		a <<= 16;
+	}
+	if (a < 0x1000000) {
+		shiftCount += 8;
+		a <<= 8;
+	}
+	shiftCount += countLeadingZerosHigh[a >> 24];
+	return shiftCount;
+
+}
+
+static int8 countLeadingZeros64(bits64 a)
+{
+	int8 shiftCount;
+
+	shiftCount = 0;
+	if (a < ((bits64) 1) << 32) {
+		shiftCount += 32;
+	} else {
+		a >>= 32;
+	}
+	shiftCount += countLeadingZeros32(a);
+	return shiftCount;
+
+}
+
+static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros64(zSig) - 1;
+	return roundAndPackFloat64(zSign, zExp - shiftCount,
+				   zSig << shiftCount);
+
+}
+
+static float64 subFloat64Sigs(float64 a, float64 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 10;
+	bSig <<= 10;
+	if (0 < expDiff)
+		goto aExpBigger;
+	if (expDiff < 0)
+		goto bExpBigger;
+	if (aExp == 0) {
+		aExp = 1;
+		bExp = 1;
+	}
+	if (bSig < aSig)
+		goto aBigger;
+	if (aSig < bSig)
+		goto bBigger;
+	return packFloat64(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
+      bExpBigger:
+	if (bExp == 0x7FF) {
+		return packFloat64(zSign ^ 1, 0x7FF, 0);
+	}
+	if (aExp == 0) {
+		++expDiff;
+	} else {
+		aSig |= LIT64(0x4000000000000000);
+	}
+	shift64RightJamming(aSig, -expDiff, &aSig);
+	bSig |= LIT64(0x4000000000000000);
+      bBigger:
+	zSig = bSig - aSig;
+	zExp = bExp;
+	zSign ^= 1;
+	goto normalizeRoundAndPack;
+      aExpBigger:
+	if (aExp == 0x7FF) {
+		return a;
+	}
+	if (bExp == 0) {
+		--expDiff;
+	} else {
+		bSig |= LIT64(0x4000000000000000);
+	}
+	shift64RightJamming(bSig, expDiff, &bSig);
+	aSig |= LIT64(0x4000000000000000);
+      aBigger:
+	zSig = aSig - bSig;
+	zExp = aExp;
+      normalizeRoundAndPack:
+	--zExp;
+	return normalizeRoundAndPackFloat64(zSign, zExp, zSig);
+
+}
+static float64 addFloat64Sigs(float64 a, float64 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 9;
+	bSig <<= 9;
+	if (0 < expDiff) {
+		if (aExp == 0x7FF) {
+			return a;
+		}
+		if (bExp == 0) {
+			--expDiff;
+		} else {
+			bSig |= LIT64(0x2000000000000000);
+		}
+		shift64RightJamming(bSig, expDiff, &bSig);
+		zExp = aExp;
+	} else if (expDiff < 0) {
+		if (bExp == 0x7FF) {
+			return packFloat64(zSign, 0x7FF, 0);
+		}
+		if (aExp == 0) {
+			++expDiff;
+		} else {
+			aSig |= LIT64(0x2000000000000000);
+		}
+		shift64RightJamming(aSig, -expDiff, &aSig);
+		zExp = bExp;
+	} else {
+		if (aExp == 0x7FF) {
+			return a;
+		}
+		if (aExp == 0)
+			return packFloat64(zSign, 0, (aSig + bSig) >> 9);
+		zSig = LIT64(0x4000000000000000) + aSig + bSig;
+		zExp = aExp;
+		goto roundAndPack;
+	}
+	aSig |= LIT64(0x2000000000000000);
+	zSig = (aSig + bSig) << 1;
+	--zExp;
+	if ((sbits64) zSig < 0) {
+		zSig = aSig + bSig;
+		++zExp;
+	}
+      roundAndPack:
+	return roundAndPackFloat64(zSign, zExp, zSig);
+
+}
+
+inline float32 packFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	return (((bits32) zSign) << 31) + (((bits32) zExp) << 23) + zSig;
+}
+
+inline void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr)
+{
+	bits32 z;
+	if (count == 0) {
+		z = a;
+	} else if (count < 32) {
+		z = (a >> count) | ((a << ((-count) & 31)) != 0);
+	} else {
+		z = (a != 0);
+	}
+	*zPtr = z;
+}
+
+static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	flag roundNearestEven;
+	int8 roundIncrement, roundBits;
+	flag isTiny;
+
+	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
+	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
+	roundIncrement = 0x40;
+	if (!roundNearestEven) {
+		roundIncrement = 0;
+	}
+	roundBits = zSig & 0x7F;
+	if (0xFD <= (bits16) zExp) {
+		if ((0xFD < zExp)
+		    || ((zExp == 0xFD)
+			&& ((sbits32) (zSig + roundIncrement) < 0))
+		    ) {
+			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
+			return packFloat32(zSign, 0xFF,
+					   0) - (roundIncrement == 0);
+		}
+		if (zExp < 0) {
+			isTiny = (zExp < -1)
+			    || (zSig + roundIncrement < 0x80000000);
+			shift32RightJamming(zSig, -zExp, &zSig);
+			zExp = 0;
+			roundBits = zSig & 0x7F;
+			if (isTiny && roundBits)
+				float_raise(FPSCR_CAUSE_UNDERFLOW);
+		}
+	}
+	if (roundBits)
+		float_raise(FPSCR_CAUSE_INEXACT);
+	zSig = (zSig + roundIncrement) >> 7;
+	zSig &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);
+	if (zSig == 0)
+		zExp = 0;
+	return packFloat32(zSign, zExp, zSig);
+
+}
+
+static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros32(zSig) - 1;
+	return roundAndPackFloat32(zSign, zExp - shiftCount,
+				   zSig << shiftCount);
+}
+
+static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
+{
+	flag roundNearestEven;
+	int16 roundIncrement, roundBits;
+	flag isTiny;
+
+	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
+	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
+	roundIncrement = 0x200;
+	if (!roundNearestEven) {
+		roundIncrement = 0;
+	}
+	roundBits = zSig & 0x3FF;
+	if (0x7FD <= (bits16) zExp) {
+		if ((0x7FD < zExp)
+		    || ((zExp == 0x7FD)
+			&& ((sbits64) (zSig + roundIncrement) < 0))
+		    ) {
+			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
+			return packFloat64(zSign, 0x7FF,
+					   0) - (roundIncrement == 0);
+		}
+		if (zExp < 0) {
+			isTiny = (zExp < -1)
+			    || (zSig + roundIncrement <
+				LIT64(0x8000000000000000));
+			shift64RightJamming(zSig, -zExp, &zSig);
+			zExp = 0;
+			roundBits = zSig & 0x3FF;
+			if (isTiny && roundBits)
+				float_raise(FPSCR_CAUSE_UNDERFLOW);
+		}
+	}
+	if (roundBits)
+		float_raise(FPSCR_CAUSE_INEXACT);
+	zSig = (zSig + roundIncrement) >> 10;
+	zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);
+	if (zSig == 0)
+		zExp = 0;
+	return packFloat64(zSign, zExp, zSig);
+
+}
+
+static float32 subFloat32Sigs(float32 a, float32 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 7;
+	bSig <<= 7;
+	if (0 < expDiff)
+		goto aExpBigger;
+	if (expDiff < 0)
+		goto bExpBigger;
+	if (aExp == 0) {
+		aExp = 1;
+		bExp = 1;
+	}
+	if (bSig < aSig)
+		goto aBigger;
+	if (aSig < bSig)
+		goto bBigger;
+	return packFloat32(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
+      bExpBigger:
+	if (bExp == 0xFF) {
+		return packFloat32(zSign ^ 1, 0xFF, 0);
+	}
+	if (aExp == 0) {
+		++expDiff;
+	} else {
+		aSig |= 0x40000000;
+	}
+	shift32RightJamming(aSig, -expDiff, &aSig);
+	bSig |= 0x40000000;
+      bBigger:
+	zSig = bSig - aSig;
+	zExp = bExp;
+	zSign ^= 1;
+	goto normalizeRoundAndPack;
+      aExpBigger:
+	if (aExp == 0xFF) {
+		return a;
+	}
+	if (bExp == 0) {
+		--expDiff;
+	} else {
+		bSig |= 0x40000000;
+	}
+	shift32RightJamming(bSig, expDiff, &bSig);
+	aSig |= 0x40000000;
+      aBigger:
+	zSig = aSig - bSig;
+	zExp = aExp;
+      normalizeRoundAndPack:
+	--zExp;
+	return normalizeRoundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+static float32 addFloat32Sigs(float32 a, float32 b, flag zSign)
+{
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+	int16 expDiff;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	expDiff = aExp - bExp;
+	aSig <<= 6;
+	bSig <<= 6;
+	if (0 < expDiff) {
+		if (aExp == 0xFF) {
+			return a;
+		}
+		if (bExp == 0) {
+			--expDiff;
+		} else {
+			bSig |= 0x20000000;
+		}
+		shift32RightJamming(bSig, expDiff, &bSig);
+		zExp = aExp;
+	} else if (expDiff < 0) {
+		if (bExp == 0xFF) {
+			return packFloat32(zSign, 0xFF, 0);
+		}
+		if (aExp == 0) {
+			++expDiff;
+		} else {
+			aSig |= 0x20000000;
+		}
+		shift32RightJamming(aSig, -expDiff, &aSig);
+		zExp = bExp;
+	} else {
+		if (aExp == 0xFF) {
+			return a;
+		}
+		if (aExp == 0)
+			return packFloat32(zSign, 0, (aSig + bSig) >> 6);
+		zSig = 0x40000000 + aSig + bSig;
+		zExp = aExp;
+		goto roundAndPack;
+	}
+	aSig |= 0x20000000;
+	zSig = (aSig + bSig) << 1;
+	--zExp;
+	if ((sbits32) zSig < 0) {
+		zSig = aSig + bSig;
+		++zExp;
+	}
+      roundAndPack:
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float64 float64_sub(float64 a, float64 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat64Sign(a);
+	bSign = extractFloat64Sign(b);
+	if (aSign == bSign) {
+		return subFloat64Sigs(a, b, aSign);
+	} else {
+		return addFloat64Sigs(a, b, aSign);
+	}
+
+}
+
+float32 float32_sub(float32 a, float32 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat32Sign(a);
+	bSign = extractFloat32Sign(b);
+	if (aSign == bSign) {
+		return subFloat32Sigs(a, b, aSign);
+	} else {
+		return addFloat32Sigs(a, b, aSign);
+	}
+
+}
+
+float32 float32_add(float32 a, float32 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat32Sign(a);
+	bSign = extractFloat32Sign(b);
+	if (aSign == bSign) {
+		return addFloat32Sigs(a, b, aSign);
+	} else {
+		return subFloat32Sigs(a, b, aSign);
+	}
+
+}
+
+float64 float64_add(float64 a, float64 b)
+{
+	flag aSign, bSign;
+
+	aSign = extractFloat64Sign(a);
+	bSign = extractFloat64Sign(b);
+	if (aSign == bSign) {
+		return addFloat64Sigs(a, b, aSign);
+	} else {
+		return subFloat64Sigs(a, b, aSign);
+	}
+}
+
+static void
+normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr, bits64 * zSigPtr)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros64(aSig) - 11;
+	*zSigPtr = aSig << shiftCount;
+	*zExpPtr = 1 - shiftCount;
+}
+
+inline void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+		   bits64 * z1Ptr)
+{
+	bits64 z1;
+
+	z1 = a1 + b1;
+	*z1Ptr = z1;
+	*z0Ptr = a0 + b0 + (z1 < a1);
+}
+
+inline void
+sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
+       bits64 * z1Ptr)
+{
+	*z1Ptr = a1 - b1;
+	*z0Ptr = a0 - b0 - (a1 < b1);
+}
+
+static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b)
+{
+	bits64 b0, b1;
+	bits64 rem0, rem1, term0, term1;
+	bits64 z;
+	if (b <= a0)
+		return LIT64(0xFFFFFFFFFFFFFFFF);
+	b0 = b >> 32;
+	z = (b0 << 32 <= a0) ? LIT64(0xFFFFFFFF00000000) : (a0 / b0) << 32;
+	mul64To128(b, z, &term0, &term1);
+	sub128(a0, a1, term0, term1, &rem0, &rem1);
+	while (((sbits64) rem0) < 0) {
+		z -= LIT64(0x100000000);
+		b1 = b << 32;
+		add128(rem0, rem1, b0, b1, &rem0, &rem1);
+	}
+	rem0 = (rem0 << 32) | (rem1 >> 32);
+	z |= (b0 << 32 <= rem0) ? 0xFFFFFFFF : rem0 / b0;
+	return z;
+}
+
+inline void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr)
+{
+	bits32 aHigh, aLow, bHigh, bLow;
+	bits64 z0, zMiddleA, zMiddleB, z1;
+
+	aLow = a;
+	aHigh = a >> 32;
+	bLow = b;
+	bHigh = b >> 32;
+	z1 = ((bits64) aLow) * bLow;
+	zMiddleA = ((bits64) aLow) * bHigh;
+	zMiddleB = ((bits64) aHigh) * bLow;
+	z0 = ((bits64) aHigh) * bHigh;
+	zMiddleA += zMiddleB;
+	z0 += (((bits64) (zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);
+	zMiddleA <<= 32;
+	z1 += zMiddleA;
+	z0 += (z1 < zMiddleA);
+	*z1Ptr = z1;
+	*z0Ptr = z0;
+
+}
+
+static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
+				      bits32 * zSigPtr)
+{
+	int8 shiftCount;
+
+	shiftCount = countLeadingZeros32(aSig) - 8;
+	*zSigPtr = aSig << shiftCount;
+	*zExpPtr = 1 - shiftCount;
+
+}
+
+float64 float64_div(float64 a, float64 b)
+{
+	flag aSign, bSign, zSign;
+	int16 aExp, bExp, zExp;
+	bits64 aSig, bSig, zSig;
+	bits64 rem0, rem1;
+	bits64 term0, term1;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	aSign = extractFloat64Sign(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	bSign = extractFloat64Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0x7FF) {
+		if (bExp == 0x7FF) {
+		}
+		return packFloat64(zSign, 0x7FF, 0);
+	}
+	if (bExp == 0x7FF) {
+		return packFloat64(zSign, 0, 0);
+	}
+	if (bExp == 0) {
+		if (bSig == 0) {
+			if ((aExp | aSig) == 0) {
+				float_raise(FPSCR_CAUSE_INVALID);
+			}
+			return packFloat64(zSign, 0x7FF, 0);
+		}
+		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
+	}
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
+	}
+	zExp = aExp - bExp + 0x3FD;
+	aSig = (aSig | LIT64(0x0010000000000000)) << 10;
+	bSig = (bSig | LIT64(0x0010000000000000)) << 11;
+	if (bSig <= (aSig + aSig)) {
+		aSig >>= 1;
+		++zExp;
+	}
+	zSig = estimateDiv128To64(aSig, 0, bSig);
+	if ((zSig & 0x1FF) <= 2) {
+		mul64To128(bSig, zSig, &term0, &term1);
+		sub128(aSig, 0, term0, term1, &rem0, &rem1);
+		while ((sbits64) rem0 < 0) {
+			--zSig;
+			add128(rem0, rem1, 0, bSig, &rem0, &rem1);
+		}
+		zSig |= (rem1 != 0);
+	}
+	return roundAndPackFloat64(zSign, zExp, zSig);
+
+}
+
+float32 float32_div(float32 a, float32 b)
+{
+	flag aSign, bSign, zSign;
+	int16 aExp, bExp, zExp;
+	bits32 aSig, bSig, zSig;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	aSign = extractFloat32Sign(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	bSign = extractFloat32Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0xFF) {
+		if (bExp == 0xFF) {
+		}
+		return packFloat32(zSign, 0xFF, 0);
+	}
+	if (bExp == 0xFF) {
+		return packFloat32(zSign, 0, 0);
+	}
+	if (bExp == 0) {
+		if (bSig == 0) {
+			return packFloat32(zSign, 0xFF, 0);
+		}
+		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
+	}
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
+	}
+	zExp = aExp - bExp + 0x7D;
+	aSig = (aSig | 0x00800000) << 7;
+	bSig = (bSig | 0x00800000) << 8;
+	if (bSig <= (aSig + aSig)) {
+		aSig >>= 1;
+		++zExp;
+	}
+	zSig = (((bits64) aSig) << 32) / bSig;
+	if ((zSig & 0x3F) == 0) {
+		zSig |= (((bits64) bSig) * zSig != ((bits64) aSig) << 32);
+	}
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float32 float32_mul(float32 a, float32 b)
+{
+	char aSign, bSign, zSign;
+	int aExp, bExp, zExp;
+	unsigned int aSig, bSig;
+	unsigned long long zSig64;
+	unsigned int zSig;
+
+	aSig = extractFloat32Frac(a);
+	aExp = extractFloat32Exp(a);
+	aSign = extractFloat32Sign(a);
+	bSig = extractFloat32Frac(b);
+	bExp = extractFloat32Exp(b);
+	bSign = extractFloat32Sign(b);
+	zSign = aSign ^ bSign;
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
+	}
+	if (bExp == 0) {
+		if (bSig == 0)
+			return packFloat32(zSign, 0, 0);
+		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
+	}
+	if ((bExp == 0xff && bSig == 0) || (aExp == 0xff && aSig == 0))
+		return roundAndPackFloat32(zSign, 0xff, 0);
+
+	zExp = aExp + bExp - 0x7F;
+	aSig = (aSig | 0x00800000) << 7;
+	bSig = (bSig | 0x00800000) << 8;
+	shift64RightJamming(((unsigned long long)aSig) * bSig, 32, &zSig64);
+	zSig = zSig64;
+	if (0 <= (signed int)(zSig << 1)) {
+		zSig <<= 1;
+		--zExp;
+	}
+	return roundAndPackFloat32(zSign, zExp, zSig);
+
+}
+
+float64 float64_mul(float64 a, float64 b)
+{
+	char aSign, bSign, zSign;
+	int aExp, bExp, zExp;
+	unsigned long long int aSig, bSig, zSig0, zSig1;
+
+	aSig = extractFloat64Frac(a);
+	aExp = extractFloat64Exp(a);
+	aSign = extractFloat64Sign(a);
+	bSig = extractFloat64Frac(b);
+	bExp = extractFloat64Exp(b);
+	bSign = extractFloat64Sign(b);
+	zSign = aSign ^ bSign;
+
+	if (aExp == 0) {
+		if (aSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
+	}
+	if (bExp == 0) {
+		if (bSig == 0)
+			return packFloat64(zSign, 0, 0);
+		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
+	}
+	if ((aExp == 0x7ff && aSig == 0) || (bExp == 0x7ff && bSig == 0))
+		return roundAndPackFloat64(zSign, 0x7ff, 0);
+
+	zExp = aExp + bExp - 0x3FF;
+	aSig = (aSig | 0x0010000000000000LL) << 10;
+	bSig = (bSig | 0x0010000000000000LL) << 11;
+	mul64To128(aSig, bSig, &zSig0, &zSig1);
+	zSig0 |= (zSig1 != 0);
+	if (0 <= (signed long long int)(zSig0 << 1)) {
+		zSig0 <<= 1;
+		--zExp;
+	}
+	return roundAndPackFloat64(zSign, zExp, zSig0);
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/cpu/sh4/sq.c linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/sq.c
--- linux-2.6.17.8/arch/sh/kernel/cpu/sh4/sq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/cpu/sh4/sq.c	2006-08-23 13:29:19.523163000 +0100
@@ -1,50 +1,53 @@
 /*
- * arch/sh/kernel/cpu/sq.c
+ * arch/sh/kernel/cpu/sh4/sq.c
  *
  * General management API for SH-4 integrated Store Queues
  *
- * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2001 - 2006  Paul Mundt
  * Copyright (C) 2001, 2002  M. R. Brown
  *
- * Some of this code has been adopted directly from the old arch/sh/mm/sq.c
- * hack that was part of the LinuxDC project. For all intents and purposes,
- * this is a completely new interface that really doesn't have much in common
- * with the old zone-based approach at all. In fact, it's only listed here for
- * general completeness.
- *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
 #include <linux/init.h>
+#include <linux/cpu.h>
+#include <linux/bitmap.h>
+#include <linux/sysdev.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/config.h>
 #include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/proc_fs.h>
-#include <linux/miscdevice.h>
 #include <linux/vmalloc.h>
-
+#include <linux/mm.h>
 #include <asm/io.h>
 #include <asm/page.h>
-#include <asm/mmu_context.h>
+#include <asm/cacheflush.h>
 #include <asm/cpu/sq.h>
 
-static LIST_HEAD(sq_mapping_list);
+struct sq_mapping;
+
+struct sq_mapping {
+	const char *name;
+
+	unsigned long sq_addr;
+	unsigned long addr;
+	unsigned int size;
+
+	struct sq_mapping *next;
+};
+
+static struct sq_mapping *sq_mapping_list;
 static DEFINE_SPINLOCK(sq_mapping_lock);
+static kmem_cache_t *sq_cache;
+static unsigned long *sq_bitmap;
 
-/**
- * sq_flush - Flush (prefetch) the store queue cache
- * @addr: the store queue address to flush
- *
- * Executes a prefetch instruction on the specified store queue cache,
- * so that the cached data is written to physical memory.
- */
-inline void sq_flush(void *addr)
-{
-	__asm__ __volatile__ ("pref @%0" : : "r" (addr) : "memory");
-}
+#define store_queue_barrier()			\
+do {						\
+	(void)ctrl_inl(P4SEG_STORE_QUE);	\
+	ctrl_outl(0, P4SEG_STORE_QUE + 0);	\
+	ctrl_outl(0, P4SEG_STORE_QUE + 8);	\
+} while (0);
 
 /**
  * sq_flush_range - Flush (prefetch) a specific SQ range
@@ -57,152 +60,73 @@
 void sq_flush_range(unsigned long start, unsigned int len)
 {
 	volatile unsigned long *sq = (unsigned long *)start;
-	unsigned long dummy;
 
 	/* Flush the queues */
 	for (len >>= 5; len--; sq += 8)
-		sq_flush((void *)sq);
+		prefetchw((void *)sq);
 
 	/* Wait for completion */
-	dummy = ctrl_inl(P4SEG_STORE_QUE);
-
-	ctrl_outl(0, P4SEG_STORE_QUE + 0);
-	ctrl_outl(0, P4SEG_STORE_QUE + 8);
+	store_queue_barrier();
 }
 
-static struct sq_mapping *__sq_alloc_mapping(unsigned long virt, unsigned long phys, unsigned long size, const char *name)
+static inline void sq_mapping_list_add(struct sq_mapping *map)
 {
-	struct sq_mapping *map;
-
-	if (virt + size > SQ_ADDRMAX)
-		return ERR_PTR(-ENOSPC);
+	struct sq_mapping **p, *tmp;
 
-	map = kmalloc(sizeof(struct sq_mapping), GFP_KERNEL);
-	if (!map)
-		return ERR_PTR(-ENOMEM);
+	spin_lock_irq(&sq_mapping_lock);
 
-	INIT_LIST_HEAD(&map->list);
+	p = &sq_mapping_list;
+	while ((tmp = *p) != NULL)
+		p = &tmp->next;
 
-	map->sq_addr	= virt;
-	map->addr	= phys;
-	map->size	= size + 1;
-	map->name	= name;
+	map->next = tmp;
+	*p = map;
 
-	list_add(&map->list, &sq_mapping_list);
-
-	return map;
+	spin_unlock_irq(&sq_mapping_lock);
 }
 
-static unsigned long __sq_get_next_addr(void)
+static inline void sq_mapping_list_del(struct sq_mapping *map)
 {
-	if (!list_empty(&sq_mapping_list)) {
-		struct list_head *pos, *tmp;
-
-		/*
-		 * Read one off the list head, as it will have the highest
-		 * mapped allocation. Set the next one up right above it.
-		 *
-		 * This is somewhat sub-optimal, as we don't look at
-		 * gaps between allocations or anything lower then the
-		 * highest-level allocation.
-		 *
-		 * However, in the interest of performance and the general
-		 * lack of desire to do constant list rebalancing, we don't
-		 * worry about it.
-		 */
-		list_for_each_safe(pos, tmp, &sq_mapping_list) {
-			struct sq_mapping *entry;
+	struct sq_mapping **p, *tmp;
 
-			entry = list_entry(pos, typeof(*entry), list);
+	spin_lock_irq(&sq_mapping_lock);
 
-			return entry->sq_addr + entry->size;
+	for (p = &sq_mapping_list; (tmp = *p); p = &tmp->next)
+		if (tmp == map) {
+			*p = tmp->next;
+			break;
 		}
-	}
 
-	return P4SEG_STORE_QUE;
+	spin_unlock_irq(&sq_mapping_lock);
 }
 
-/**
- * __sq_remap - Perform a translation from the SQ to a phys addr
- * @map: sq mapping containing phys and store queue addresses.
- *
- * Maps the store queue address specified in the mapping to the physical
- * address specified in the mapping.
- */
-static struct sq_mapping *__sq_remap(struct sq_mapping *map)
+static int __sq_remap(struct sq_mapping *map, unsigned long flags)
 {
-	unsigned long flags, pteh, ptel;
+#if defined(CONFIG_MMU)
 	struct vm_struct *vma;
-	pgprot_t pgprot;
-
-	/*
-	 * Without an MMU (or with it turned off), this is much more
-	 * straightforward, as we can just load up each queue's QACR with
-	 * the physical address appropriately masked.
-	 */
-
-	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR0);
-	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR1);
-
-#ifdef CONFIG_MMU
-	/*
-	 * With an MMU on the other hand, things are slightly more involved.
-	 * Namely, we have to have a direct mapping between the SQ addr and
-	 * the associated physical address in the UTLB by way of setting up
-	 * a virt<->phys translation by hand. We do this by simply specifying
-	 * the SQ addr in UTLB.VPN and the associated physical address in
-	 * UTLB.PPN.
-	 *
-	 * Notably, even though this is a special case translation, and some
-	 * of the configuration bits are meaningless, we're still required
-	 * to have a valid ASID context in PTEH.
-	 *
-	 * We could also probably get by without explicitly setting PTEA, but
-	 * we do it here just for good measure.
-	 */
-	spin_lock_irqsave(&sq_mapping_lock, flags);
-
-	pteh = map->sq_addr;
-	ctrl_outl((pteh & MMU_VPN_MASK) | get_asid(), MMU_PTEH);
-
-	ptel = map->addr & PAGE_MASK;
-	ctrl_outl(((ptel >> 28) & 0xe) | (ptel & 0x1), MMU_PTEA);
-
-	pgprot = pgprot_noncached(PAGE_KERNEL);
-
-	ptel &= _PAGE_FLAGS_HARDWARE_MASK;
-	ptel |= pgprot_val(pgprot);
-	ctrl_outl(ptel, MMU_PTEL);
 
-	__asm__ __volatile__ ("ldtlb" : : : "memory");
-
-	spin_unlock_irqrestore(&sq_mapping_lock, flags);
-
-	/*
-	 * Next, we need to map ourselves in the kernel page table, so that
-	 * future accesses after a TLB flush will be handled when we take a
-	 * page fault.
-	 *
-	 * Theoretically we could just do this directly and not worry about
-	 * setting up the translation by hand ahead of time, but for the
-	 * cases where we want a one-shot SQ mapping followed by a quick
-	 * writeout before we hit the TLB flush, we do it anyways. This way
-	 * we at least save ourselves the initial page fault overhead.
-	 */
 	vma = __get_vm_area(map->size, VM_ALLOC, map->sq_addr, SQ_ADDRMAX);
 	if (!vma)
-		return ERR_PTR(-ENOMEM);
+		return -ENOMEM;
 
 	vma->phys_addr = map->addr;
 
 	if (remap_area_pages((unsigned long)vma->addr, vma->phys_addr,
-			     map->size, pgprot_val(pgprot))) {
+			     map->size, flags)) {
 		vunmap(vma->addr);
-		return NULL;
+		return -EAGAIN;
 	}
-#endif /* CONFIG_MMU */
+#else
+	/*
+	 * Without an MMU (or with it turned off), this is much more
+	 * straightforward, as we can just load up each queue's QACR with
+	 * the physical address appropriately masked.
+	 */
+	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR0);
+	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR1);
+#endif
 
-	return map;
+	return 0;
 }
 
 /**
@@ -210,42 +134,65 @@
  * @phys: Physical address of mapping.
  * @size: Length of mapping.
  * @name: User invoking mapping.
+ * @flags: Protection flags.
  *
  * Remaps the physical address @phys through the next available store queue
  * address of @size length. @name is logged at boot time as well as through
- * the procfs interface.
- *
- * A pre-allocated and filled sq_mapping pointer is returned, and must be
- * cleaned up with a call to sq_unmap() when the user is done with the
- * mapping.
+ * the sysfs interface.
  */
-struct sq_mapping *sq_remap(unsigned long phys, unsigned int size, const char *name)
+unsigned long sq_remap(unsigned long phys, unsigned int size,
+		       const char *name, unsigned long flags)
 {
 	struct sq_mapping *map;
-	unsigned long virt, end;
+	unsigned long end;
 	unsigned int psz;
+	int ret, page;
 
 	/* Don't allow wraparound or zero size */
 	end = phys + size - 1;
-	if (!size || end < phys)
-		return NULL;
+	if (unlikely(!size || end < phys))
+		return -EINVAL;
 	/* Don't allow anyone to remap normal memory.. */
-	if (phys < virt_to_phys(high_memory))
-		return NULL;
+	if (unlikely(phys < virt_to_phys(high_memory)))
+		return -EINVAL;
 
 	phys &= PAGE_MASK;
+	size = PAGE_ALIGN(end + 1) - phys;
+
+	map = kmem_cache_alloc(sq_cache, GFP_KERNEL);
+	if (unlikely(!map))
+		return -ENOMEM;
+
+	map->addr = phys;
+	map->size = size;
+	map->name = name;
+
+	page = bitmap_find_free_region(sq_bitmap, 0x04000000,
+				       get_order(map->size));
+	if (unlikely(page < 0)) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	map->sq_addr = P4SEG_STORE_QUE + (page << PAGE_SHIFT);
+
+	ret = __sq_remap(map, flags);
+	if (unlikely(ret != 0))
+		goto out;
+
+	psz = (size + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+	pr_info("sqremap: %15s  [%4d page%s]  va 0x%08lx   pa 0x%08lx\n",
+		likely(map->name) ? map->name : "???",
+		psz, psz == 1 ? " " : "s",
+		map->sq_addr, map->addr);
+
+	sq_mapping_list_add(map);
 
-	size  = PAGE_ALIGN(end + 1) - phys;
-	virt  = __sq_get_next_addr();
-	psz   = (size + (PAGE_SIZE - 1)) / PAGE_SIZE;
-	map   = __sq_alloc_mapping(virt, phys, size, name);
-
-	printk("sqremap: %15s  [%4d page%s]  va 0x%08lx   pa 0x%08lx\n",
-	       map->name ? map->name : "???",
-	       psz, psz == 1 ? " " : "s",
-	       map->sq_addr, map->addr);
+	return map->sq_addr;
 
-	return __sq_remap(map);
+out:
+	kmem_cache_free(sq_cache, map);
+	return ret;
 }
 
 /**
@@ -256,185 +203,196 @@
  * sq_remap(). Also frees up the pte that was previously inserted into
  * the kernel page table and discards the UTLB translation.
  */
-void sq_unmap(struct sq_mapping *map)
+void sq_unmap(unsigned long vaddr)
 {
-	if (map->sq_addr > (unsigned long)high_memory)
-		vfree((void *)(map->sq_addr & PAGE_MASK));
+	struct sq_mapping **p, *map;
+	struct vm_struct *vma;
+	int page;
 
-	list_del(&map->list);
-	kfree(map);
-}
+	for (p = &sq_mapping_list; (map = *p); p = &map->next)
+		if (map->sq_addr == vaddr)
+			break;
+
+	if (unlikely(!map)) {
+		printk("%s: bad store queue address 0x%08lx\n",
+		       __FUNCTION__, vaddr);
+		return;
+	}
 
-/**
- * sq_clear - Clear a store queue range
- * @addr: Address to start clearing from.
- * @len: Length to clear.
- *
- * A quick zero-fill implementation for clearing out memory that has been
- * remapped through the store queues.
- */
-void sq_clear(unsigned long addr, unsigned int len)
-{
-	int i;
+	page = (map->sq_addr - P4SEG_STORE_QUE) >> PAGE_SHIFT;
+	bitmap_release_region(sq_bitmap, page, get_order(map->size));
 
-	/* Clear out both queues linearly */
-	for (i = 0; i < 8; i++) {
-		ctrl_outl(0, addr + i + 0);
-		ctrl_outl(0, addr + i + 8);
+	vma = remove_vm_area((void *)(map->sq_addr & PAGE_MASK));
+	if (!vma) {
+		printk(KERN_ERR "%s: bad address 0x%08lx\n",
+		       __FUNCTION__, map->sq_addr);
+		return;
 	}
 
-	sq_flush_range(addr, len);
+	sq_mapping_list_del(map);
+
+	kmem_cache_free(sq_cache, map);
 }
 
-/**
- * sq_vma_unmap - Unmap a VMA range
- * @area: VMA containing range.
- * @addr: Start of range.
- * @len: Length of range.
- *
- * Searches the sq_mapping_list for a mapping matching the sq addr @addr,
- * and subsequently frees up the entry. Further cleanup is done by generic
- * code.
+/*
+ * Needlessly complex sysfs interface. Unfortunately it doesn't seem like
+ * there is any other easy way to add things on a per-cpu basis without
+ * putting the directory entries somewhere stupid and having to create
+ * links in sysfs by hand back in to the per-cpu directories.
+ *
+ * Some day we may want to have an additional abstraction per store
+ * queue, but considering the kobject hell we already have to deal with,
+ * it's simply not worth the trouble.
  */
-static void sq_vma_unmap(struct vm_area_struct *area,
-			 unsigned long addr, size_t len)
-{
-	struct list_head *pos, *tmp;
+static struct kobject *sq_kobject[NR_CPUS];
 
-	list_for_each_safe(pos, tmp, &sq_mapping_list) {
-		struct sq_mapping *entry;
+struct sq_sysfs_attr {
+	struct attribute attr;
+	ssize_t (*show)(char *buf);
+	ssize_t (*store)(const char *buf, size_t count);
+};
 
-		entry = list_entry(pos, typeof(*entry), list);
+#define to_sq_sysfs_attr(attr)	container_of(attr, struct sq_sysfs_attr, attr)
 
-		if (entry->sq_addr == addr) {
-			/*
-			 * We could probably get away without doing the tlb flush
-			 * here, as generic code should take care of most of this
-			 * when unmapping the rest of the VMA range for us. Leave
-			 * it in for added sanity for the time being..
-			 */
-			__flush_tlb_page(get_asid(), entry->sq_addr & PAGE_MASK);
+static ssize_t sq_sysfs_show(struct kobject *kobj, struct attribute *attr,
+			     char *buf)
+{
+	struct sq_sysfs_attr *sattr = to_sq_sysfs_attr(attr);
 
-			list_del(&entry->list);
-			kfree(entry);
+	if (likely(sattr->show))
+		return sattr->show(buf);
 
-			return;
-		}
-	}
+	return -EIO;
 }
 
-/**
- * sq_vma_sync - Sync a VMA range
- * @area: VMA containing range.
- * @start: Start of range.
- * @len: Length of range.
- * @flags: Additional flags.
- *
- * Synchronizes an sq mapped range by flushing the store queue cache for
- * the duration of the mapping.
- *
- * Used internally for user mappings, which must use msync() to prefetch
- * the store queue cache.
- */
-static int sq_vma_sync(struct vm_area_struct *area,
-		       unsigned long start, size_t len, unsigned int flags)
+static ssize_t sq_sysfs_store(struct kobject *kobj, struct attribute *attr,
+			      const char *buf, size_t count)
 {
-	sq_flush_range(start, len);
+	struct sq_sysfs_attr *sattr = to_sq_sysfs_attr(attr);
 
-	return 0;
+	if (likely(sattr->store))
+		return sattr->store(buf, count);
+
+	return -EIO;
 }
 
-static struct vm_operations_struct sq_vma_ops = {
-	.unmap	= sq_vma_unmap,
-	.sync	= sq_vma_sync,
-};
+static ssize_t mapping_show(char *buf)
+{
+	struct sq_mapping **list, *entry;
+	char *p = buf;
 
-/**
- * sq_mmap - mmap() for /dev/cpu/sq
- * @file: unused.
- * @vma: VMA to remap.
- *
- * Remap the specified vma @vma through the store queues, and setup associated
- * information for the new mapping. Also build up the page tables for the new
- * area.
- */
-static int sq_mmap(struct file *file, struct vm_area_struct *vma)
+	for (list = &sq_mapping_list; (entry = *list); list = &entry->next)
+		p += sprintf(p, "%08lx-%08lx [%08lx]: %s\n",
+			     entry->sq_addr, entry->sq_addr + entry->size,
+			     entry->addr, entry->name);
+
+	return p - buf;
+}
+
+static ssize_t mapping_store(const char *buf, size_t count)
 {
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long size = vma->vm_end - vma->vm_start;
-	struct sq_mapping *map;
+	unsigned long base = 0, len = 0;
 
-	/*
-	 * We're not interested in any arbitrary virtual address that has
-	 * been stuck in the VMA, as we already know what addresses we
-	 * want. Save off the size, and reposition the VMA to begin at
-	 * the next available sq address.
-	 */
-	vma->vm_start = __sq_get_next_addr();
-	vma->vm_end   = vma->vm_start + size;
+	sscanf(buf, "%lx %lx", &base, &len);
+	if (!base)
+		return -EIO;
 
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (likely(len)) {
+		int ret = sq_remap(base, len, "Userspace",
+				   pgprot_val(PAGE_SHARED));
+		if (ret < 0)
+			return ret;
+	} else
+		sq_unmap(base);
 
-	vma->vm_flags |= VM_IO | VM_RESERVED;
+	return count;
+}
 
-	map = __sq_alloc_mapping(vma->vm_start, offset, size, "Userspace");
+static struct sq_sysfs_attr mapping_attr =
+	__ATTR(mapping, 0644, mapping_show, mapping_store);
 
-	if (io_remap_pfn_range(vma, map->sq_addr, map->addr >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		return -EAGAIN;
+static struct attribute *sq_sysfs_attrs[] = {
+	&mapping_attr.attr,
+	NULL,
+};
 
-	vma->vm_ops = &sq_vma_ops;
+static struct sysfs_ops sq_sysfs_ops = {
+	.show	= sq_sysfs_show,
+	.store	= sq_sysfs_store,
+};
 
-	return 0;
-}
+static struct kobj_type ktype_percpu_entry = {
+	.sysfs_ops	= &sq_sysfs_ops,
+	.default_attrs	= sq_sysfs_attrs,
+};
 
-#ifdef CONFIG_PROC_FS
-static int sq_mapping_read_proc(char *buf, char **start, off_t off,
-				int len, int *eof, void *data)
+static int __devinit sq_sysdev_add(struct sys_device *sysdev)
 {
-	struct list_head *pos;
-	char *p = buf;
+	unsigned int cpu = sysdev->id;
+	struct kobject *kobj;
 
-	list_for_each_prev(pos, &sq_mapping_list) {
-		struct sq_mapping *entry;
+	sq_kobject[cpu] = kzalloc(sizeof(struct kobject), GFP_KERNEL);
+	if (unlikely(!sq_kobject[cpu]))
+		return -ENOMEM;
 
-		entry = list_entry(pos, typeof(*entry), list);
+	kobj = sq_kobject[cpu];
+	kobj->parent = &sysdev->kobj;
+	kobject_set_name(kobj, "%s", "sq");
+	kobj->ktype = &ktype_percpu_entry;
 
-		p += sprintf(p, "%08lx-%08lx [%08lx]: %s\n", entry->sq_addr,
-			     entry->sq_addr + entry->size - 1, entry->addr,
-			     entry->name);
-	}
-
-	return p - buf;
+	return kobject_register(kobj);
 }
-#endif
 
-static struct file_operations sq_fops = {
-	.owner		= THIS_MODULE,
-	.mmap		= sq_mmap,
-};
+static int __devexit sq_sysdev_remove(struct sys_device *sysdev)
+{
+	unsigned int cpu = sysdev->id;
+	struct kobject *kobj = sq_kobject[cpu];
+
+	kobject_unregister(kobj);
+	return 0;
+}
 
-static struct miscdevice sq_dev = {
-	.minor		= STORE_QUEUE_MINOR,
-	.name		= "sq",
-	.devfs_name	= "cpu/sq",
-	.fops		= &sq_fops,
+static struct sysdev_driver sq_sysdev_driver = {
+	.add		= sq_sysdev_add,
+	.remove		= __devexit_p(sq_sysdev_remove),
 };
 
 static int __init sq_api_init(void)
 {
+	unsigned int nr_pages = 0x04000000 >> PAGE_SHIFT;
+	unsigned int size = (nr_pages + (BITS_PER_LONG - 1)) / BITS_PER_LONG;
+	int ret = -ENOMEM;
+
 	printk(KERN_NOTICE "sq: Registering store queue API.\n");
 
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry("sq_mapping", 0, 0, sq_mapping_read_proc, 0);
-#endif
+	sq_cache = kmem_cache_create("store_queue_cache",
+				sizeof(struct sq_mapping), 0, 0,
+				NULL, NULL);
+	if (unlikely(!sq_cache))
+		return ret;
+
+	sq_bitmap = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!sq_bitmap))
+		goto out;
+
+	ret = sysdev_driver_register(&cpu_sysdev_class, &sq_sysdev_driver);
+	if (unlikely(ret != 0))
+		goto out;
 
-	return misc_register(&sq_dev);
+	return 0;
+
+out:
+	kfree(sq_bitmap);
+	kmem_cache_destroy(sq_cache);
+
+	return ret;
 }
 
 static void __exit sq_api_exit(void)
 {
-	misc_deregister(&sq_dev);
+	sysdev_driver_unregister(&cpu_sysdev_class, &sq_sysdev_driver);
+	kfree(sq_bitmap);
+	kmem_cache_destroy(sq_cache);
 }
 
 module_init(sq_api_init);
@@ -443,11 +401,7 @@
 MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>, M. R. Brown <mrbrown@0xd6.org>");
 MODULE_DESCRIPTION("Simple API for SH-4 integrated Store Queues");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS_MISCDEV(STORE_QUEUE_MINOR);
 
 EXPORT_SYMBOL(sq_remap);
 EXPORT_SYMBOL(sq_unmap);
-EXPORT_SYMBOL(sq_clear);
-EXPORT_SYMBOL(sq_flush);
 EXPORT_SYMBOL(sq_flush_range);
-
diff -Naur linux-2.6.17.8/arch/sh/kernel/early_printk.c linux-2.6.17.8-sh/arch/sh/kernel/early_printk.c
--- linux-2.6.17.8/arch/sh/kernel/early_printk.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/early_printk.c	2006-08-23 13:29:13.408024000 +0100
@@ -59,34 +59,42 @@
 #endif
 
 #ifdef CONFIG_EARLY_SCIF_CONSOLE
+#include <linux/serial_core.h>
+#include "../../../drivers/serial/sh-sci.h"
+
+#ifdef CONFIG_CPU_SH4
 #define SCIF_REG	0xffe80000
+#elif defined(CONFIG_CPU_SUBTYPE_SH72060)
+#define SCIF_REG	0xfffe9800
+#else
+#error "Undefined SCIF for this subtype"
+#endif
+
+static struct uart_port scif_port = {
+	.mapbase	= SCIF_REG,
+	.membase	= (char *)SCIF_REG,
+};
 
 static void scif_sercon_putc(int c)
 {
-	while (!(ctrl_inw(SCIF_REG + 0x10) & 0x20)) ;
+	while (((sci_in(&scif_port, SCFDR) & 0x1f00 >> 8) == 16))
+		;
+
+	sci_out(&scif_port, SCxTDR, c);
+	sci_in(&scif_port, SCxSR);
+	sci_out(&scif_port, SCxSR, 0xf3 & ~(0x20 | 0x40));
 
-	ctrl_outb(c, SCIF_REG + 12);
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0x9f), SCIF_REG + 0x10);
+	while ((sci_in(&scif_port, SCxSR) & 0x40) == 0);
+		;
 
 	if (c == '\n')
 		scif_sercon_putc('\r');
 }
 
-static void scif_sercon_flush(void)
-{
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0xbf), SCIF_REG + 0x10);
-
-	while (!(ctrl_inw(SCIF_REG + 0x10) & 0x40)) ;
-
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0xbf), SCIF_REG + 0x10);
-}
-
 static void scif_sercon_write(struct console *con, const char *s, unsigned count)
 {
 	while (count-- > 0)
 		scif_sercon_putc(*s++);
-
-	scif_sercon_flush();
 }
 
 static int __init scif_sercon_setup(struct console *con, char *options)
@@ -124,7 +132,7 @@
 
 void __init enable_early_printk(void)
 {
-#ifdef CONFIG_EARLY_SCIF_CONSOLE
+#if defined(CONFIG_EARLY_SCIF_CONSOLE) && defined(CONFIG_CPU_SH4)
 	scif_sercon_init(115200);
 #endif
 	register_console(&early_console);
diff -Naur linux-2.6.17.8/arch/sh/kernel/entry.S linux-2.6.17.8-sh/arch/sh/kernel/entry.S
--- linux-2.6.17.8/arch/sh/kernel/entry.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/entry.S	2006-08-23 13:29:49.521852000 +0100
@@ -19,24 +19,6 @@
 #include <asm/cpu/mmu_context.h>
 #include <asm/unistd.h>
 
-#if !defined(CONFIG_NFSD) && !defined(CONFIG_NFSD_MODULE)
-#define sys_nfsservctl		sys_ni_syscall
-#endif
-
-#if !defined(CONFIG_MMU)
-#define sys_madvise		sys_ni_syscall
-#define sys_readahead		sys_ni_syscall
-#define sys_mprotect		sys_ni_syscall
-#define sys_msync		sys_ni_syscall
-#define sys_mlock		sys_ni_syscall
-#define sys_munlock		sys_ni_syscall
-#define sys_mlockall		sys_ni_syscall
-#define sys_munlockall		sys_ni_syscall
-#define sys_mremap		sys_ni_syscall
-#define sys_mincore		sys_ni_syscall
-#define sys_remap_file_pages	sys_ni_syscall
-#endif
-
 ! NOTE:
 ! GNU as (as of 2.9.1) changes bf/s into bt/s and bra, when the address
 ! to be jumped is too far, but it causes illegal slot exception.
@@ -91,6 +73,7 @@
 OFF_R7  =  28     	/* New ABI: arg3 */
 OFF_SP	=  (15*4)
 OFF_PC  =  (16*4)
+OFF_PR  =  (17*4)
 OFF_SR	=  (16*4+8)
 OFF_TRA	=  (16*4+6*4)
 
@@ -327,7 +310,7 @@
 	.align	2
 ret_from_exception:
 	preempt_stop()
-ret_from_irq:
+ENTRY(ret_from_irq)
 	!
 	mov	#OFF_SR, r0
 	mov.l	@(r0,r15), r0	! get status register
@@ -395,30 +378,12 @@
 	bt/s	restore_all
 	 mov	r15, r4
 	mov	#0, r5
+	mov	r12, r6		! set arg2(save_r0)
 	mov.l	2f, r1
 	mova	restore_all, r0
 	jmp	@r1
 	 lds	r0, pr
 work_resched:
-#ifndef CONFIG_PREEMPT
-	! gUSA handling
-	mov.l	@(OFF_SP,r15), r0	! get user space stack pointer
-	mov	r0, r1
-	shll	r0
-	bf/s	1f
-	 shll	r0
-	bf/s	1f
-	 mov	#OFF_PC, r0
-	! 				  SP >= 0xc0000000 : gUSA mark
-	mov.l	@(r0,r15), r2		! get user space PC (program counter)
-	mov.l	@(OFF_R0,r15), r3	! end point
-	cmp/hs	r3, r2			! r2 >= r3? 
-	bt	1f
-	add	r3, r1			! rewind point #2
-	mov.l	r1, @(r0,r15)		! reset PC to rewind point #2
-	!
-1:
-#endif
 	mov.l	1f, r1
 	jsr	@r1				! schedule
 	 nop
@@ -438,7 +403,7 @@
 syscall_exit_work:
 	! r0: current_thread_info->flags
 	! r8: current_thread_info
-	tst	#_TIF_SYSCALL_TRACE, r0
+	tst	#_TIF_SYSCALL_TRACE | _TIF_SINGLESTEP, r0
 	bt/s	work_pending
 	 tst	#_TIF_NEED_RESCHED, r0
 	STI()
@@ -553,6 +518,7 @@
 	mov.l	@r9, r8
 	jsr	@r8	    	! jump to specific syscall handler
 	 nop
+	mov.l	@(OFF_R0,r15), r12		! save r0
 	mov.l	r0, @(OFF_R0,r15)		! save the return value
 	!
 syscall_exit:
@@ -645,7 +611,7 @@
 	!
 #if defined(CONFIG_KGDB_NMI)
 	! Clear in_nmi
-	mov.l	4f, k0
+	mov.l	6f, k0
 	mov	#0, k1
 	mov.b	k1, @k0
 #endif
@@ -653,6 +619,7 @@
 	mov	k4, r15
 	rte
 	 nop
+ret_from_exception_end:
 
 	.align	2
 1:	.long	TRA
@@ -665,6 +632,76 @@
 __INV_IMASK:
 	.long	0xffffff0f	! ~(IMASK)
 
+	.section	.debug_frame,"",@progbits
+.LCIE:
+	.ualong	.LCIE_end - .LCIE_start
+.LCIE_start:
+	.ualong	0xffffffff	/* CIE ID */
+	.byte	0x1		/* Version number */
+	.string	""		/* NUL-terminated augmentation string */
+	.uleb128 0x1		/* Code alignment factor */
+	.sleb128 -4		/* Data alignment factor */
+	.byte	0x11		/* Return address register column */
+				/* Augmentation length and data (none) */
+	.byte	0xc		/* DW_CFA_def_cfa */
+	.uleb128 0xf		/* r15 */
+	.uleb128 0x0		/* offset 0 */
+
+	.align 2
+.LCIE_end:
+
+	.ualong	.LFDE_end-.LFDE_start	/* Length FDE */
+.LFDE_start:
+	.ualong	.LCIE			/* CIE pointer */
+	.ualong	ret_from_exception-4	/* absolute start address */
+	.ualong	ret_from_exception_end-(ret_from_exception-4)
+					/* length */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.ualong	0			/*   by */
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.uleb128 OFF_TRA+4		/*   advance CFA by sizeof(ptregs)+4 */
+
+	.byte	0x80+0			/* DW_CFA_offset r0 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(0*4)))>>2
+	.byte	0x80+1			/* DW_CFA_offset r1 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(1*4)))>>2
+	.byte	0x80+2			/* DW_CFA_offset r2 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(2*4)))>>2
+	.byte	0x80+3			/* DW_CFA_offset r3 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(3*4)))>>2
+	.byte	0x80+4			/* DW_CFA_offset r4 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(4*4)))>>2
+	.byte	0x80+5			/* DW_CFA_offset r5 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(5*4)))>>2
+	.byte	0x80+6			/* DW_CFA_offset r6 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(6*4)))>>2
+	.byte	0x80+7			/* DW_CFA_offset r7 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(7*4)))>>2
+	.byte	0x80+8			/* DW_CFA_offset r8 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(8*4)))>>2
+	.byte	0x80+9			/* DW_CFA_offset r9 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(9*4)))>>2
+	.byte	0x80+10			/* DW_CFA_offset r10 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(10*4)))>>2
+	.byte	0x80+11			/* DW_CFA_offset r11 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(11*4)))>>2
+	.byte	0x80+12			/* DW_CFA_offset r12 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(12*4)))>>2
+	.byte	0x80+13			/* DW_CFA_offset r13 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(13*4)))>>2
+	.byte	0x80+14			/* DW_CFA_offset r14 */
+	.uleb128 ((OFF_TRA+4)-(OFF_R0+(14*4)))>>2
+	.byte	0x80+15			/* DW_CFA_offset r15 */
+	.uleb128 ((OFF_TRA+4)-OFF_SP)>>2
+	.byte	0x80+16			/* DW_CFA_offset r16=pc */
+	.uleb128 ((OFF_TRA+4)-OFF_PC)>>2
+	.byte	0x80+17			/* DW_CFA_offset r17=pr */
+	.uleb128 ((OFF_TRA+4)-OFF_PR)>>2
+	.align 2
+.LFDE_end:
+
+	.text
+
 ! Exception Vector Base
 !
 !	Should be aligned page boundary.
@@ -723,18 +760,37 @@
 !
 !
 	.align	2
-handle_exception:
+ENTRY(handle_exception)
 	! Using k0, k1 for scratch registers (r0_bank1, r1_bank),
 	! save all registers onto stack.
 	!
+
+	! Check for roll back gRB (User and Kernel)
+	mov	r15, k0
+	shll	k0
+	bf/s	1f
+	 shll	k0
+	bf/s	1f
+	 stc	spc, k1
+	stc	r0_bank, k0
+	cmp/hs	k0, k1		! test k1 (saved PC) >= k0 (saved r0)
+	bt/s	2f
+	 stc	r1_bank, k1
+
+	add	#-2, k0
+	add	r15, k0
+	ldc	k0, spc		! PC = saved r0 + r15 - 2
+2:	mov	k1, r15		! SP = r1
+1:
+
 	stc	ssr, k0		! Is it from kernel space?
 	shll	k0		! Check MD bit (bit30) by shifting it into...
 	shll	k0		!       ...the T bit
 	bt/s	1f		! It's a kernel to kernel transition.
 	 mov	r15, k0		! save original stack to k0
 	/* User space to kernel */
-	mov	#0x20, k1
-	shll8	k1		! k1 := 8192 (== THREAD_SIZE)
+	mov     #(THREAD_SIZE >> 8), r1
+	shll8	k1		! k1 := (8192 or 4096) (== THREAD_SIZE)
 	add	current, k1
 	mov	k1, r15		! change to kernel stack
 	!
@@ -818,6 +874,7 @@
 	mov.l	r2, @-r15
 	mov.l	r1, @-r15
 	mov.l	r0, @-r15
+
 	! Then, dispatch to the handler, according to the exception code.
 	stc	k_ex_code, r8
 	shlr2	r8
@@ -839,300 +896,3 @@
 	rts
 	 nop
 
-	.data
-ENTRY(sys_call_table)
-	.long sys_ni_syscall	/* 0  -  old "setup()" system call*/
-	.long sys_exit
-	.long sys_fork
-	.long sys_read
-	.long sys_write
-	.long sys_open		/* 5 */
-	.long sys_close
-	.long sys_waitpid
-	.long sys_creat
-	.long sys_link
-	.long sys_unlink		/* 10 */
-	.long sys_execve
-	.long sys_chdir
-	.long sys_time
-	.long sys_mknod
-	.long sys_chmod		/* 15 */
-	.long sys_lchown16
-	.long sys_ni_syscall	/* old break syscall holder */
-	.long sys_stat
-	.long sys_lseek
-	.long sys_getpid		/* 20 */
-	.long sys_mount
-	.long sys_oldumount
-	.long sys_setuid16
-	.long sys_getuid16
-	.long sys_stime		/* 25 */
-	.long sys_ptrace
-	.long sys_alarm
-	.long sys_fstat
-	.long sys_pause
-	.long sys_utime		/* 30 */
-	.long sys_ni_syscall	/* old stty syscall holder */
-	.long sys_ni_syscall	/* old gtty syscall holder */
-	.long sys_access
-	.long sys_nice
-	.long sys_ni_syscall	/* 35 */		/* old ftime syscall holder */
-	.long sys_sync
-	.long sys_kill
-	.long sys_rename
-	.long sys_mkdir
-	.long sys_rmdir		/* 40 */
-	.long sys_dup
-	.long sys_pipe
-	.long sys_times
-	.long sys_ni_syscall	/* old prof syscall holder */
-	.long sys_brk		/* 45 */
-	.long sys_setgid16
-	.long sys_getgid16
-	.long sys_signal
-	.long sys_geteuid16
-	.long sys_getegid16	/* 50 */
-	.long sys_acct
-	.long sys_umount		/* recycled never used phys() */
-	.long sys_ni_syscall	/* old lock syscall holder */
-	.long sys_ioctl
-	.long sys_fcntl		/* 55 */
-	.long sys_ni_syscall	/* old mpx syscall holder */
-	.long sys_setpgid
-	.long sys_ni_syscall	/* old ulimit syscall holder */
-	.long sys_ni_syscall	/* sys_olduname */
-	.long sys_umask		/* 60 */
-	.long sys_chroot
-	.long sys_ustat
-	.long sys_dup2
-	.long sys_getppid
-	.long sys_getpgrp		/* 65 */
-	.long sys_setsid
-	.long sys_sigaction
-	.long sys_sgetmask
-	.long sys_ssetmask
-	.long sys_setreuid16	/* 70 */
-	.long sys_setregid16
-	.long sys_sigsuspend
-	.long sys_sigpending
-	.long sys_sethostname
-	.long sys_setrlimit	/* 75 */
-	.long sys_old_getrlimit
-	.long sys_getrusage
-	.long sys_gettimeofday
-	.long sys_settimeofday
-	.long sys_getgroups16	/* 80 */
-	.long sys_setgroups16
-	.long sys_ni_syscall	/* sys_oldselect */
-	.long sys_symlink
-	.long sys_lstat
-	.long sys_readlink		/* 85 */
-	.long sys_uselib
-	.long sys_swapon
-	.long sys_reboot
-	.long old_readdir
-	.long old_mmap		/* 90 */
-	.long sys_munmap
-	.long sys_truncate
-	.long sys_ftruncate
-	.long sys_fchmod
-	.long sys_fchown16		/* 95 */
-	.long sys_getpriority
-	.long sys_setpriority
-	.long sys_ni_syscall	/* old profil syscall holder */
-	.long sys_statfs
-	.long sys_fstatfs		/* 100 */
-	.long sys_ni_syscall	/* ioperm */
-	.long sys_socketcall
-	.long sys_syslog
-	.long sys_setitimer
-	.long sys_getitimer	/* 105 */
-	.long sys_newstat
-	.long sys_newlstat
-	.long sys_newfstat
-	.long sys_uname
-	.long sys_ni_syscall	/* 110 */ /* iopl */
-	.long sys_vhangup
-	.long sys_ni_syscall	/* idle */
-	.long sys_ni_syscall	/* vm86old */
-	.long sys_wait4
-	.long sys_swapoff		/* 115 */
-	.long sys_sysinfo
-	.long sys_ipc
-	.long sys_fsync
-	.long sys_sigreturn
-	.long sys_clone		/* 120 */
-	.long sys_setdomainname
-	.long sys_newuname
-	.long sys_ni_syscall	/* sys_modify_ldt */
-	.long sys_adjtimex
-	.long sys_mprotect		/* 125 */
-	.long sys_sigprocmask
-	.long sys_ni_syscall	/* old "create_module" */
-	.long sys_init_module
-	.long sys_delete_module
-	.long sys_ni_syscall	/* 130: old "get_kernel_syms" */
-	.long sys_quotactl
-	.long sys_getpgid
-	.long sys_fchdir
-	.long sys_bdflush
-	.long sys_sysfs		/* 135 */
-	.long sys_personality
-	.long sys_ni_syscall	/* for afs_syscall */
-	.long sys_setfsuid16
-	.long sys_setfsgid16
-	.long sys_llseek		/* 140 */
-	.long sys_getdents
-	.long sys_select
-	.long sys_flock
-	.long sys_msync
-	.long sys_readv		/* 145 */
-	.long sys_writev
-	.long sys_getsid
-	.long sys_fdatasync
-	.long sys_sysctl
-	.long sys_mlock		/* 150 */
-	.long sys_munlock
-	.long sys_mlockall
-	.long sys_munlockall
-	.long sys_sched_setparam
-	.long sys_sched_getparam   /* 155 */
-	.long sys_sched_setscheduler
-	.long sys_sched_getscheduler
-	.long sys_sched_yield
-	.long sys_sched_get_priority_max
-	.long sys_sched_get_priority_min  /* 160 */
-	.long sys_sched_rr_get_interval
-	.long sys_nanosleep
-	.long sys_mremap
-	.long sys_setresuid16
-	.long sys_getresuid16	/* 165 */
-	.long sys_ni_syscall	/* vm86 */
-	.long sys_ni_syscall	/* old "query_module" */
-	.long sys_poll
-	.long sys_nfsservctl
-	.long sys_setresgid16	/* 170 */
-	.long sys_getresgid16
-	.long sys_prctl
-	.long sys_rt_sigreturn
-	.long sys_rt_sigaction
-	.long sys_rt_sigprocmask	/* 175 */
-	.long sys_rt_sigpending
-	.long sys_rt_sigtimedwait
-	.long sys_rt_sigqueueinfo
-	.long sys_rt_sigsuspend
-	.long sys_pread_wrapper	   /* 180 */
-	.long sys_pwrite_wrapper
-	.long sys_chown16
-	.long sys_getcwd
-	.long sys_capget
-	.long sys_capset           /* 185 */
-	.long sys_sigaltstack
-	.long sys_sendfile
-	.long sys_ni_syscall	/* streams1 */
-	.long sys_ni_syscall	/* streams2 */
-	.long sys_vfork            /* 190 */
-	.long sys_getrlimit
-	.long sys_mmap2
-	.long sys_truncate64
-	.long sys_ftruncate64
-	.long sys_stat64		/* 195 */
-	.long sys_lstat64
-	.long sys_fstat64
-	.long sys_lchown
-	.long sys_getuid
-	.long sys_getgid		/* 200 */
-	.long sys_geteuid
-	.long sys_getegid
-	.long sys_setreuid
-	.long sys_setregid
-	.long sys_getgroups	/* 205 */
-	.long sys_setgroups
-	.long sys_fchown
-	.long sys_setresuid
-	.long sys_getresuid
-	.long sys_setresgid	/* 210 */
-	.long sys_getresgid
-	.long sys_chown
-	.long sys_setuid
-	.long sys_setgid
-	.long sys_setfsuid		/* 215 */
-	.long sys_setfsgid
-	.long sys_pivot_root
-	.long sys_mincore
-	.long sys_madvise
-	.long sys_getdents64	/* 220 */
-	.long sys_fcntl64
-	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall	/* Reserved for Security */
-	.long sys_gettid
-	.long sys_readahead	/* 225 */
-	.long sys_setxattr
-	.long sys_lsetxattr
-	.long sys_fsetxattr
-	.long sys_getxattr
-	.long sys_lgetxattr	/* 230 */
-	.long sys_fgetxattr
-	.long sys_listxattr
-	.long sys_llistxattr
-	.long sys_flistxattr
-	.long sys_removexattr	/* 235 */
-	.long sys_lremovexattr
-	.long sys_fremovexattr
-	.long sys_tkill
-	.long sys_sendfile64
-	.long sys_futex		/* 240 */
-	.long sys_sched_setaffinity
-	.long sys_sched_getaffinity
-	.long sys_ni_syscall
-	.long sys_ni_syscall
-	.long sys_io_setup	/* 245 */
-	.long sys_io_destroy
-	.long sys_io_getevents
-	.long sys_io_submit
-	.long sys_io_cancel
-	.long sys_fadvise64	/* 250 */
-	.long sys_ni_syscall
-	.long sys_exit_group
-	.long sys_lookup_dcookie
-	.long sys_epoll_create
-	.long sys_epoll_ctl	/* 255 */
-	.long sys_epoll_wait
- 	.long sys_remap_file_pages
- 	.long sys_set_tid_address
- 	.long sys_timer_create
- 	.long sys_timer_settime		/* 260 */
- 	.long sys_timer_gettime
- 	.long sys_timer_getoverrun
- 	.long sys_timer_delete
- 	.long sys_clock_settime
- 	.long sys_clock_gettime		/* 265 */
- 	.long sys_clock_getres
- 	.long sys_clock_nanosleep
-	.long sys_statfs64
-	.long sys_fstatfs64     
-	.long sys_tgkill		/* 270 */
-	.long sys_utimes
- 	.long sys_fadvise64_64_wrapper
-	.long sys_ni_syscall	/* Reserved for vserver */
-	.long sys_ni_syscall	/* Reserved for mbind */
-	.long sys_ni_syscall	/* 275 - get_mempolicy */
-	.long sys_ni_syscall	/* set_mempolicy */
-	.long sys_mq_open
-	.long sys_mq_unlink
-	.long sys_mq_timedsend
-	.long sys_mq_timedreceive       /* 280 */
-	.long sys_mq_notify
-	.long sys_mq_getsetattr
-	.long sys_ni_syscall	/* Reserved for kexec */
-	.long sys_waitid
-	.long sys_add_key		/* 285 */
-	.long sys_request_key
-	.long sys_keyctl
-	.long sys_ioprio_set
-	.long sys_ioprio_get
-	.long sys_inotify_init		/* 290 */
-	.long sys_inotify_add_watch
-	.long sys_inotify_rm_watch
-
-/* End of entry.S */
diff -Naur linux-2.6.17.8/arch/sh/kernel/head.S linux-2.6.17.8-sh/arch/sh/kernel/head.S
--- linux-2.6.17.8/arch/sh/kernel/head.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/head.S	2006-08-23 13:29:49.529852000 +0100
@@ -11,6 +11,18 @@
  * Head.S contains the SH exception handlers and startup code.
  */
 #include <linux/linkage.h>
+#include <asm/thread_info.h>
+
+#ifdef CONFIG_CPU_SH4A
+#define SYNCO()		synco
+
+#define PREFI(label, reg)	\
+	mov.l	label, reg;	\
+	prefi	@reg
+#else
+#define SYNCO()
+#define PREFI(label, reg)
+#endif
 
 	.section	.empty_zero_page, "aw"
 ENTRY(empty_zero_page)
@@ -42,18 +54,25 @@
 	!			Initialize global interrupt mask
 	mov	#0, r0
 	ldc	r0, r6_bank
+
+	/*
+	 * Prefetch if possible to reduce cache miss penalty.
+	 *
+	 * We do this early on for SH-4A as a micro-optimization,
+	 * as later on we will have speculative execution enabled
+	 * and this will become less of an issue.
+	 */
+	PREFI(5f, r0)
+	PREFI(6f, r0)
+
 	!
 	mov.l	2f, r0
-	mov	r0, r15		! Set initial r15 (stack pointer)
-	mov	#0x20, r1	!
-	shll8	r1		! r1 = 8192
-	sub	r1, r0		!
-	ldc	r0, r7_bank	! ... and initial thread_info
-	!
-	!			Additional CPU initialization
-	mov.l	6f, r0
-	jsr	@r0
-	 nop
+	ldc	r0, r7_bank	! Set the initial thread_info
+	mov	#(THREAD_SIZE >> 8), r1
+	shll8	r1	! r1 = 8192 or 4096 ( based on CONFIG_4KSTACKS )
+	add	r1, r0	!
+	mov	r0, r15	! ... and set initial r15 (stack pointer)
+
 	!			Clear BSS area
 	mov.l	3f, r1
 	add	#4, r1
@@ -62,14 +81,23 @@
 9:	cmp/hs	r2, r1
 	bf/s	9b		! while (r1 < r2)
 	 mov.l	r0,@-r2
+
+	!			Additional CPU initialization
+	mov.l	6f, r0
+	jsr	@r0
+	 nop
+
+	SYNCO()			! Wait for pending instructions..
+
 	!			Start kernel
+	mov	#0, r1
 	mov.l	5f, r0
 	jmp	@r0
-	 nop
+	 lds	r1, pr
 
 	.balign 4
 1:	.long	0x400080F0		! MD=1, RB=0, BL=0, FD=1, IMASK=0xF
-2:	.long	stack
+2:	.long	init_thread_union
 3:	.long	__bss_start
 4:	.long	_end
 5:	.long	start_kernel
diff -Naur linux-2.6.17.8/arch/sh/kernel/io.c linux-2.6.17.8-sh/arch/sh/kernel/io.c
--- linux-2.6.17.8/arch/sh/kernel/io.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/io.c	2006-08-23 13:29:37.329576000 +0100
@@ -4,7 +4,6 @@
  * Copyright (C) 2000  Stuart Menefy
  * Copyright (C) 2005  Paul Mundt
  *
- * Provide real functions which expand to whatever the header file defined.
  * Also definitions of machine independent IO functions.
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -17,33 +16,87 @@
 
 /*
  * Copy data from IO memory space to "real" memory space.
- * This needs to be optimized.
  */
 void memcpy_fromio(void *to, volatile void __iomem *from, unsigned long count)
 {
-	char *p = to;
-        while (count) {
-                count--;
-                *p = readb((void __iomem *)from);
-                p++;
-                from++;
-        }
+	/*
+	 * Would it be worthwhile doing byte and long transfers first
+	 * to try and get aligned?
+	 */
+#ifdef CONFIG_CPU_SH4
+	if ( (count >= 0x20) &&
+	     (((u32)to & 0x1f) == 0) && (((u32)from & 0x3) == 0) ) {
+		int tmp2, tmp3, tmp4, tmp5, tmp6;
+
+		__asm__ __volatile__(
+			"1:			\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	@%7+, %2	\n\t"
+			"movca.l r0, @%0	\n\t"
+			"mov.l	@%7+, %3	\n\t"
+			"mov.l	@%7+, %4	\n\t"
+			"mov.l	@%7+, %5	\n\t"
+			"mov.l	@%7+, %6	\n\t"
+			"mov.l	@%7+, r7	\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	%2, @(0x04,%0)	\n\t"
+			"mov	#0x20, %2	\n\t"
+			"mov.l	%3, @(0x08,%0)	\n\t"
+			"sub	%2, %1		\n\t"
+			"mov.l	%4, @(0x0c,%0)	\n\t"
+			"cmp/hi	%1, %2		! T if 32 > count	\n\t"
+			"mov.l	%5, @(0x10,%0)	\n\t"
+			"mov.l	%6, @(0x14,%0)	\n\t"
+			"mov.l	r7, @(0x18,%0)	\n\t"
+			"mov.l	r0, @(0x1c,%0)	\n\t"
+			"bf.s	1b		\n\t"
+			" add	#0x20, %0	\n\t"
+			: "=&r" (to), "=&r" (count),
+			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
+			  "=&r" (tmp5), "=&r" (tmp6), "=&r" (from)
+			: "7"(from), "0" (to), "1" (count)
+			: "r0", "r7", "t", "memory");
+	}
+#endif
+
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for ( ; count > 3; count -= 4) {
+			*(u32*)to = *(volatile u32*)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for ( ; count > 0; count--) {
+		*(u8*)to = *(volatile u8*)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_fromio);
 
 /*
  * Copy data from "real" memory space to IO memory space.
- * This needs to be optimized.
  */
 void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
-	const char *p = from;
-        while (count) {
-                count--;
-                writeb(*p, (void __iomem *)to);
-                p++;
-                to++;
-        }
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for ( ; count > 3; count -= 4) {
+			*(volatile u32*)to = *(u32*)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for ( ; count > 0; count--) {
+		*(volatile u8*)to = *(u8*)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_toio);
 
@@ -61,6 +114,73 @@
 }
 EXPORT_SYMBOL(memset_io);
 
+void __raw_readsl(const void __iomem *addr, void *datap, int len)
+{
+	u32* data = datap;
+
+	for( ; (len != 0) && (((u32)data & 0x1f) != 0); len--) {
+		*data++ = *(volatile u32*)addr;
+	}
+
+#ifdef CONFIG_CPU_SH4
+	if (likely(len >= (0x20 >> 2))) {
+		int tmp2, tmp3, tmp4, tmp5, tmp6;
+
+		__asm__ __volatile__(
+			"1:			\n\t"
+			"mov.l	@%7, r0		\n\t"
+			"mov.l	@%7, %2		\n\t"
+			"movca.l r0, @%0	\n\t"
+			"mov.l	@%7, %3		\n\t"
+			"mov.l	@%7, %4		\n\t"
+			"mov.l	@%7, %5		\n\t"
+			"mov.l	@%7, %6		\n\t"
+			"mov.l	@%7, r7		\n\t"
+			"mov.l	@%7, r0		\n\t"
+			"mov.l	%2, @(0x04,%0)	\n\t"
+			"mov	#0x20>>2, %2	\n\t"
+			"mov.l	%3, @(0x08,%0)	\n\t"
+			"sub	%2, %1		\n\t"
+			"mov.l	%4, @(0x0c,%0)	\n\t"
+			"cmp/hi	%1, %2		! T if 32 > len	\n\t"
+			"mov.l	%5, @(0x10,%0)	\n\t"
+			"mov.l	%6, @(0x14,%0)	\n\t"
+			"mov.l	r7, @(0x18,%0)	\n\t"
+			"mov.l	r0, @(0x1c,%0)	\n\t"
+			"bf.s	1b		\n\t"
+			" add	#0x20, %0	\n\t"
+			: "=&r" (data), "=&r" (len),
+			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
+			  "=&r" (tmp5), "=&r" (tmp6)
+			: "r"(addr), "0" (data), "1" (len)
+			: "r0", "r7", "t", "memory");
+	}
+#endif
+
+	for( ; len != 0; len--) {
+		*data++ = *(volatile u32*)addr;
+	}
+}
+EXPORT_SYMBOL(__raw_readsl);
+
+void __raw_writesl(void __iomem *addr, const void *data, int len)
+{
+	if (likely(len != 0)) {
+		int tmp1;
+
+		__asm__ __volatile__ (
+			"1:				\n\t"
+			"mov.l	@%0+, %1	\n\t"
+			"dt		%3		\n\t"
+			"bf.s		1b		\n\t"
+			" mov.l	%1, @%4		\n\t"
+			: "=&r" (data), "=&r" (tmp1)
+			: "0" (data), "r" (len), "r"(addr)
+			: "t", "memory");
+	}
+}
+EXPORT_SYMBOL(__raw_writesl);
+
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
 	return sh_mv.mv_ioport_map(port, nr);
diff -Naur linux-2.6.17.8/arch/sh/kernel/io_generic.c linux-2.6.17.8-sh/arch/sh/kernel/io_generic.c
--- linux-2.6.17.8/arch/sh/kernel/io_generic.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/io_generic.c	2006-08-23 13:29:37.252576000 +0100
@@ -29,7 +29,7 @@
 
 static inline void delay(void)
 {
-	ctrl_inw(0xa0000000);
+	ctrl_inw(CCN_PVR);
 }
 
 u8 generic_inb(unsigned long port)
@@ -105,8 +105,23 @@
 	u32 *buf = dst;
 
 	port_addr = (volatile u32 *)ioport_map(port, 4);
-	while (count--)
-		*buf++ = *port_addr;
+
+	/* The ne2k-pci driver uses this, sometimes with 16 bit alignment */
+	/* We could rely on the unaligned trap handler, but this is faster */
+	if ((int)dst & 3) {
+		u8 *char_buf=(u8*)buf;
+		u32 tmp;
+		while (count--) {
+			tmp = *port_addr;
+			char_buf[0] = tmp & 0xff;
+			char_buf[1] = (tmp >> 8) & 0xff;
+			char_buf[2] = (tmp >> 16) & 0xff;
+			char_buf[3] = (tmp >> 24) & 0xff;
+			char_buf += 4;
+		}
+	} else {
+		__raw_readsl((void __iomem*)port, buf, count);
+	}
 
 	dummy_read();
 }
@@ -179,8 +194,22 @@
 	const u32 *buf = src;
 
 	port_addr = (volatile u32 __force *)ioport_map(port, 4);
-	while (count--)
-		*port_addr = *buf++;
+	/* The ne2k-pci driver uses this, sometimes with 16 bit alignment */
+	/* We could rely on the unaligned trap handler, but this is faster */
+	if ((int)buf & 3) {
+		const u8 *char_buf=(const u8*)buf;
+		u32 tmp;
+		while (count--) {
+			tmp = (char_buf[0]) |
+				(char_buf[1] << 8) |
+				(char_buf[2] << 16) |
+				(char_buf[3] << 24);
+			*port_addr=tmp;
+			char_buf += 4;
+		}
+	} else {
+		__raw_writesl((void __iomem*)port, buf, count);
+	}
 
 	dummy_read();
 }
diff -Naur linux-2.6.17.8/arch/sh/kernel/irq.c linux-2.6.17.8-sh/arch/sh/kernel/irq.c
--- linux-2.6.17.8/arch/sh/kernel/irq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/irq.c	2006-08-23 13:29:49.535852000 +0100
@@ -15,6 +15,7 @@
 #include <asm/irq.h>
 #include <asm/processor.h>
 #include <asm/cpu/mmu_context.h>
+#include <asm/thread_info.h>
 
 /*
  * 'what should we do if we get a hw irq event on an illegal vector'.
@@ -60,6 +61,25 @@
 }
 #endif
 
+#ifdef CONFIG_4KSTACKS
+/*
+ * The interrupt stack support
+ * for sh4 platform is written
+ * to manage only _1_ CPU !!!
+ */
+#define HARDIRQ_STACK_SIZE    CONFIG_HARDIRQ_STACK_SIZE
+
+static unsigned long hardirq_stack[HARDIRQ_STACK_SIZE/sizeof(long)]
+                __attribute__((__aligned__(HARDIRQ_STACK_SIZE)));
+
+inline unsigned long current_stack_pointer(void)
+{
+    unsigned long tmp;
+    asm volatile ("mov  r15,    %0      \t\n"
+                : "=r" (tmp) );
+    return tmp;
+}
+#endif
 
 asmlinkage int do_IRQ(unsigned long r4, unsigned long r5,
 		      unsigned long r6, unsigned long r7,
@@ -69,6 +89,18 @@
 
 	irq_enter();
 
+#ifdef CONFIG_DEBUG_STACKOVERFLOW
+	long sp;
+
+	/* Debugging check for stack overflow: is there less than 1KB free? */
+	__asm__ __volatile__("and r15,%0" : "=r" (sp) : "0" (THREAD_SIZE-1));
+	if (unlikely(sp < (sizeof(struct task_struct) + 1024))) {
+		printk("do_IRQ: stack overflow: %ld\n",
+                       sp - sizeof(struct task_struct));
+		dump_stack();
+	}
+#endif
+
 #ifdef CONFIG_CPU_HAS_INTEVT
 	__asm__ __volatile__ (
 #ifdef CONFIG_CPU_HAS_SR_RB
@@ -86,8 +118,72 @@
 	);
 #endif
 
+
 	irq = irq_demux(irq);
-	__do_IRQ(irq, &regs);
+
+#if defined(CONFIG_4KSTACKS)
+/*
+ * Check if the CPU is running inside an ISR...
+ */
+       if (((current_stack_pointer() & (~(HARDIRQ_STACK_SIZE-1))) )
+          !=(unsigned long)hardirq_stack){
+
+        asm volatile ("mov       %0,    r4   \n"
+		      "mov	 %1,	r5   \n"
+		      "mov      r15,    r8   \n"
+		      "jsr	@%2	     \n"
+		      "  mov     %3,    r15  \n"// swith to the irq stack
+		      "mov       r8,    r15  \n"// restore the stack (ring zero)
+		  : : "r" (irq),
+		      "r" (&regs),
+		      "r" (__do_IRQ),
+		      "r" (hardirq_stack+(HARDIRQ_STACK_SIZE/sizeof(long)))
+                  : "memory", "r0", "r1", "r2", "r3", "r4",
+			      "r5","r6", "r7","r8", "t","pr" );
+        }
+	else
+#endif
+	__do_IRQ(irq,&regs);
+
 	irq_exit();
+
 	return 1;
 }
+
+#if defined(CONFIG_4KSTACKS)
+/*
+ * Dedicated stack for softirq
+ */
+extern asmlinkage void __do_softirq(void);
+
+#define SOFTIRQ_STACK_SIZE         (CONFIG_SOFTIRQ_STACK_SIZE)
+
+static unsigned long softirq_stack[SOFTIRQ_STACK_SIZE/sizeof(long)]
+                __attribute__((__aligned__(SOFTIRQ_STACK_SIZE)));
+
+asmlinkage void do_softirq(void)
+{
+        unsigned long flags;
+
+        if (in_interrupt())
+                return;
+
+        local_irq_save(flags);
+
+        if (local_softirq_pending()) {
+
+             asm volatile ("mov	     r15,   r9\n"
+			   "jsr      @%0      \n"
+			   " mov     %1,   r15\n"// switch to the softirq stack
+                           "mov      r9,   r15\n"// restore the thread stack
+			:: "r" (__do_softirq),
+			   "r" (softirq_stack+(SOFTIRQ_STACK_SIZE/sizeof(long)))
+                       : "memory","r0", "r1", "r2", "r3", "r4",
+			          "r5","r6", "r7","r8", "r9", "r15","t","pr" );
+        }
+
+        local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(do_softirq);
+#endif
diff -Naur linux-2.6.17.8/arch/sh/kernel/kgdb_stub.c linux-2.6.17.8-sh/arch/sh/kernel/kgdb_stub.c
--- linux-2.6.17.8/arch/sh/kernel/kgdb_stub.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/kgdb_stub.c	2006-08-23 13:29:23.033231000 +0100
@@ -101,16 +101,17 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 
+#ifdef CONFIG_SH_KGDB_CONSOLE
+#include <linux/console.h>
+#endif
+
 #include <asm/system.h>
 #include <asm/current.h>
 #include <asm/signal.h>
 #include <asm/pgtable.h>
 #include <asm/ptrace.h>
 #include <asm/kgdb.h>
-
-#ifdef CONFIG_SH_KGDB_CONSOLE
-#include <linux/console.h>
-#endif
+#include <asm/io.h>
 
 /* Function pointers for linkage */
 kgdb_debug_hook_t *kgdb_debug_hook;
@@ -240,7 +241,6 @@
 /* Misc static */
 static int stepped_address;
 static short stepped_opcode;
-static const char hexchars[] = "0123456789abcdef";
 static char in_buffer[BUFMAX];
 static char out_buffer[OUTBUFMAX];
 
@@ -253,29 +253,6 @@
 #define BUF_THREAD_ID_SIZE 16
 #endif
 
-/* Return addr as a real volatile address */
-static inline unsigned int ctrl_inl(const unsigned long addr)
-{
-	return *(volatile unsigned long *) addr;
-}
-
-/* Correctly set *addr using volatile */
-static inline void ctrl_outl(const unsigned int b, unsigned long addr)
-{
-	*(volatile unsigned long *) addr = b;
-}
-
-/* Get high hex bits */
-static char highhex(const int x)
-{
-	return hexchars[(x >> 4) & 0xf];
-}
-
-/* Get low hex bits */
-static char lowhex(const int x)
-{
-	return hexchars[x & 0xf];
-}
 
 /* Convert ch to hex */
 static int hex(const char ch)
diff -Naur linux-2.6.17.8/arch/sh/kernel/Makefile linux-2.6.17.8-sh/arch/sh/kernel/Makefile
--- linux-2.6.17.8/arch/sh/kernel/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/Makefile	2006-08-23 13:29:21.942208000 +0100
@@ -6,7 +6,7 @@
 
 obj-y	:= process.o signal.o entry.o traps.o irq.o \
 	ptrace.o setup.o time.o sys_sh.o semaphore.o \
-	io.o io_generic.o sh_ksyms.o
+	io.o io_generic.o sh_ksyms.o syscalls.o
 
 obj-y				+= cpu/ timers/
 
@@ -18,3 +18,5 @@
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
+obj-$(CONFIG_APM)		+= apm.o
+obj-$(CONFIG_PM)		+= pm.o
diff -Naur linux-2.6.17.8/arch/sh/kernel/pm.c linux-2.6.17.8-sh/arch/sh/kernel/pm.c
--- linux-2.6.17.8/arch/sh/kernel/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/pm.c	2006-08-23 13:29:22.717231000 +0100
@@ -0,0 +1,88 @@
+/*
+ * Generic Power Management Routine
+ *
+ * Copyright (c) 2006 Andriy Skulysh <askulsyh@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License.
+ */
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/gfp.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+#include <asm/watchdog.h>
+#include <asm/pm.h>
+
+#define INTR_OFFSET	0x600
+
+#define STBCR		0xffffff82
+#define STBCR2		0xffffff88
+
+#define STBCR_STBY	0x80
+#define STBCR_MSTP2	0x04
+
+#define MCR		0xffffff68
+#define RTCNT		0xffffff70
+
+#define MCR_RMODE	2
+#define MCR_RFSH	4
+
+void pm_enter(void)
+{
+	u8 stbcr, csr;
+	u16 frqcr, mcr;
+	u32 vbr_new, vbr_old;
+
+	set_bl_bit();
+
+	/* set wdt */
+	csr = sh_wdt_read_csr();
+	csr &= ~WTCSR_TME;
+	csr |= WTCSR_CKS_4096;
+	sh_wdt_write_csr(csr);
+	csr = sh_wdt_read_csr();
+	sh_wdt_write_cnt(0);
+
+	/* disable PLL1 */
+	frqcr = ctrl_inw(FRQCR);
+	frqcr &= ~(FRQCR_PLLEN | FRQCR_PSTBY);
+	ctrl_outw(frqcr, FRQCR);
+
+	/* enable standby */
+	stbcr = ctrl_inb(STBCR);
+	ctrl_outb(stbcr | STBCR_STBY | STBCR_MSTP2, STBCR);
+
+	/* set self-refresh */
+	mcr = ctrl_inw(MCR);
+	ctrl_outw(mcr & ~MCR_RFSH, MCR);
+
+	/* set interrupt handler */
+	asm volatile("stc vbr, %0" : "=r" (vbr_old));
+	vbr_new = get_zeroed_page(GFP_ATOMIC);
+	udelay(50);
+	memcpy((void*)(vbr_new + INTR_OFFSET),
+	       &wakeup_start, &wakeup_end - &wakeup_start);
+	asm volatile("ldc %0, vbr" : : "r" (vbr_new));
+
+	ctrl_outw(0, RTCNT);
+	ctrl_outw(mcr | MCR_RFSH | MCR_RMODE, MCR);
+
+	cpu_sleep();
+
+	asm volatile("ldc %0, vbr" : : "r" (vbr_old));
+
+	free_page(vbr_new);
+
+	/* enable PLL1 */
+	frqcr = ctrl_inw(FRQCR);
+	frqcr |= FRQCR_PSTBY;
+	ctrl_outw(frqcr, FRQCR);
+	udelay(50);
+	frqcr |= FRQCR_PLLEN;
+	ctrl_outw(frqcr, FRQCR);
+
+	ctrl_outb(stbcr, STBCR);
+
+	clear_bl_bit();
+}
diff -Naur linux-2.6.17.8/arch/sh/kernel/process.c linux-2.6.17.8-sh/arch/sh/kernel/process.c
--- linux-2.6.17.8/arch/sh/kernel/process.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/process.c	2006-08-23 13:29:47.857806000 +0100
@@ -262,6 +262,7 @@
 		unsigned long unused,
 		struct task_struct *p, struct pt_regs *regs)
 {
+	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs;
 #if defined(CONFIG_SH_FPU)
 	struct task_struct *tsk = current;
@@ -276,8 +277,10 @@
 
 	if (user_mode(regs)) {
 		childregs->regs[15] = usp;
+		ti->addr_limit = USER_DS;
 	} else {
 		childregs->regs[15] = (unsigned long)task_stack_page(p) + THREAD_SIZE;
+		ti->addr_limit = KERNEL_DS;
 	}
         if (clone_flags & CLONE_SETTLS) {
 		childregs->gbr = childregs->regs[0];
@@ -323,26 +326,6 @@
 	unlazy_fpu(prev, task_pt_regs(prev));
 #endif
 
-#ifdef CONFIG_PREEMPT
-	{
-		unsigned long flags;
-		struct pt_regs *regs;
-
-		local_irq_save(flags);
-		regs = task_pt_regs(prev);
-		if (user_mode(regs) && regs->regs[15] >= 0xc0000000) {
-			int offset = (int)regs->regs[15];
-
-			/* Reset stack pointer: clear critical region mark */
-			regs->regs[15] = regs->regs[1];
-			if (regs->pc < regs->regs[0])
-				/* Go to rewind point */
-				regs->pc = regs->regs[0] + offset;
-		}
-		local_irq_restore(flags);
-	}
-#endif
-
 	/*
 	 * Restore the kernel mode register
 	 *   	k7 (r7_bank1)
diff -Naur linux-2.6.17.8/arch/sh/kernel/ptrace.c linux-2.6.17.8-sh/arch/sh/kernel/ptrace.c
--- linux-2.6.17.8/arch/sh/kernel/ptrace.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/ptrace.c	2006-08-23 13:29:32.942461000 +0100
@@ -28,6 +28,7 @@
 #include <asm/system.h>
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
+#include <asm/cacheflush.h>
 
 /*
  * does not yet catch signals sent when the child dies.
@@ -60,6 +61,21 @@
 	return 0;
 }
 
+static void ptrace_disable_singlestep(struct task_struct *child)
+{
+	clear_tsk_thread_flag(child, TIF_SINGLESTEP);
+
+	/* ensure the UBC is not programmed at the next context switch.
+	 * normally this is not needed by there are sequences such as
+	 * singlestep, signal delivery, continue that leave the ubc_pc
+	 * non-zero leading to spurious SIGTRAPs.
+	 */
+	if (child->thread.ubc_pc != 0) {
+		ubc_usercnt -= 1;
+		child->thread.ubc_pc = 0;
+	}
+}
+
 /*
  * Called by kernel/ptrace.c when detaching..
  *
@@ -67,7 +83,7 @@
  */
 void ptrace_disable(struct task_struct *child)
 {
-	/* nothing to do.. */
+	ptrace_disable_singlestep(child);
 }
 
 long arch_ptrace(struct task_struct *child, long request, long addr, long data)
@@ -82,7 +98,12 @@
 		unsigned long tmp;
 		int copied;
 
+		/* this is a somewhat over-zealous approach to solving
+		 * access_process_vm's dcache aliasing issues.
+		 */
+		flush_cache_all();
 		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
+		flush_cache_all();
 		ret = -EIO;
 		if (copied != sizeof(tmp))
 			break;
@@ -123,8 +144,14 @@
 	case PTRACE_POKETEXT: /* write the word at location addr. */
 	case PTRACE_POKEDATA:
 		ret = 0;
-		if (access_process_vm(child, addr, &data, sizeof(data), 1) == sizeof(data))
+		/* this is a somewhat over-zealous approach to solving
+		 * access_process_vm's dcache aliasing issues.
+		 */
+		flush_cache_all();
+		if (access_process_vm(child, addr, &data, sizeof(data), 1) == sizeof(data)) {
+			flush_cache_all();
 			break;
+		}
 		ret = -EIO;
 		break;
 
@@ -157,6 +184,9 @@
 			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
 		else
 			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+
+		ptrace_disable_singlestep(child);
+
 		child->exit_code = data;
 		wake_up_process(child);
 		ret = 0;
@@ -172,6 +202,7 @@
 		ret = 0;
 		if (child->exit_state == EXIT_ZOMBIE)	/* already dead */
 			break;
+		ptrace_disable_singlestep(child);
 		child->exit_code = SIGKILL;
 		wake_up_process(child);
 		break;
@@ -197,6 +228,7 @@
 			ubc_usercnt += 1;
 		child->thread.ubc_pc = pc;
 
+		set_tsk_thread_flag(child, TIF_SINGLESTEP);
 		child->exit_code = data;
 		/* give it a chance to run. */
 		wake_up_process(child);
@@ -225,7 +257,6 @@
 
 	case PTRACE_SETDSPREGS: {
 		unsigned long dp;
-		int i;
 
 		ret = -EIO;
 		dp = ((unsigned long) child) + THREAD_SIZE -
@@ -250,14 +281,15 @@
 {
 	struct task_struct *tsk = current;
 
-	if (!test_thread_flag(TIF_SYSCALL_TRACE))
+	if (!test_thread_flag(TIF_SYSCALL_TRACE) &&
+	    !test_thread_flag(TIF_SINGLESTEP))
 		return;
 	if (!(tsk->ptrace & PT_PTRACED))
 		return;
 	/* the 0x80 provides a way for the tracing parent to distinguish
 	   between a syscall stop and SIGTRAP delivery */
-	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
-				 ? 0x80 : 0));
+	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD) &&
+				 !test_thread_flag(TIF_SINGLESTEP) ? 0x80 : 0));
 
 	/*
 	 * this isn't the same as continuing with a signal, but it will do
diff -Naur linux-2.6.17.8/arch/sh/kernel/semaphore.c linux-2.6.17.8-sh/arch/sh/kernel/semaphore.c
--- linux-2.6.17.8/arch/sh/kernel/semaphore.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/semaphore.c	2006-08-23 13:29:09.314932000 +0100
@@ -14,7 +14,7 @@
 #include <asm/semaphore.h>
 #include <asm/semaphore-helper.h>
 
-spinlock_t semaphore_wake_lock;
+DEFINE_SPINLOCK(semaphore_wake_lock);
 
 /*
  * Semaphores are implemented using a two-way counter:
diff -Naur linux-2.6.17.8/arch/sh/kernel/setup.c linux-2.6.17.8-sh/arch/sh/kernel/setup.c
--- linux-2.6.17.8/arch/sh/kernel/setup.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/setup.c	2006-08-23 13:29:42.214691000 +0100
@@ -424,6 +424,9 @@
 	[CPU_SH73180]	= "SH73180",
 	[CPU_ST40RA]	= "ST40RA",
 	[CPU_ST40GX1]	= "ST40GX1",
+	[CPU_STI5528]	= "STi5528",
+	[CPU_STM8000]	= "STm8000",
+	[CPU_STB7100]	= "STb710x",
 	[CPU_SH4_202]	= "SH4-202",
 	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",
@@ -493,7 +496,7 @@
 	 * unified cache on the SH-2 and SH-3, as well as the harvard
 	 * style cache on the SH-4.
 	 */
-	if (test_bit(SH_CACHE_COMBINED, &(boot_cpu_data.icache.flags))) {
+	if (boot_cpu_data.icache.flags & SH_CACHE_COMBINED) {
 		seq_printf(m, "unified\n");
 		show_cacheinfo(m, "cache", boot_cpu_data.icache);
 	} else {
diff -Naur linux-2.6.17.8/arch/sh/kernel/sh_ksyms.c linux-2.6.17.8-sh/arch/sh/kernel/sh_ksyms.c
--- linux-2.6.17.8/arch/sh/kernel/sh_ksyms.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/sh_ksyms.c	2006-08-23 13:29:44.615737000 +0100
@@ -28,21 +28,11 @@
 
 /* platform dependent support */
 EXPORT_SYMBOL(dump_fpu);
-EXPORT_SYMBOL(iounmap);
-EXPORT_SYMBOL(enable_irq);
-EXPORT_SYMBOL(disable_irq);
-EXPORT_SYMBOL(probe_irq_mask);
 EXPORT_SYMBOL(kernel_thread);
-EXPORT_SYMBOL(disable_irq_nosync);
 EXPORT_SYMBOL(irq_desc);
 EXPORT_SYMBOL(no_irq_type);
 
-EXPORT_SYMBOL(strstr);
 EXPORT_SYMBOL(strlen);
-EXPORT_SYMBOL(strnlen);
-EXPORT_SYMBOL(strchr);
-EXPORT_SYMBOL(strcat);
-EXPORT_SYMBOL(strncat);
 
 /* PCI exports */
 #ifdef CONFIG_PCI
@@ -53,13 +43,8 @@
 /* mem exports */
 EXPORT_SYMBOL(memchr);
 EXPORT_SYMBOL(memcpy);
-EXPORT_SYMBOL(memcpy_fromio);
-EXPORT_SYMBOL(memcpy_toio);
 EXPORT_SYMBOL(memset);
-EXPORT_SYMBOL(memset_io);
 EXPORT_SYMBOL(memmove);
-EXPORT_SYMBOL(memcmp);
-EXPORT_SYMBOL(memscan);
 EXPORT_SYMBOL(__copy_user);
 EXPORT_SYMBOL(boot_cpu_data);
 
@@ -84,6 +69,7 @@
 DECLARE_EXPORT(__udivsi3);
 DECLARE_EXPORT(__udivdi3);
 DECLARE_EXPORT(__sdivsi3);
+DECLARE_EXPORT(__divdi3);
 DECLARE_EXPORT(__ashrdi3);
 DECLARE_EXPORT(__ashldi3);
 DECLARE_EXPORT(__lshrdi3);
@@ -101,13 +87,18 @@
 EXPORT_SYMBOL(flush_cache_range);
 EXPORT_SYMBOL(flush_dcache_page);
 EXPORT_SYMBOL(__flush_purge_region);
+EXPORT_SYMBOL(clear_user_page);
+EXPORT_SYMBOL(copy_user_page);
 #endif
 
 #if defined(CONFIG_SH7705_CACHE_32KB)
 EXPORT_SYMBOL(flush_cache_all);
 EXPORT_SYMBOL(flush_cache_range);
+EXPORT_SYMBOL(flush_cache_page);
 EXPORT_SYMBOL(flush_dcache_page);
+EXPORT_SYMBOL(__flush_wback_region);
 EXPORT_SYMBOL(__flush_purge_region);
+EXPORT_SYMBOL(__flush_invalidate_region);
 #endif
 
 EXPORT_SYMBOL(flush_tlb_page);
@@ -117,7 +108,12 @@
 EXPORT_SYMBOL(synchronize_irq);
 #endif
 
+#ifdef CONFIG_PM
+EXPORT_SYMBOL(pm_suspend);
+#endif
+
 EXPORT_SYMBOL(csum_partial);
+#ifdef CONFIG_IPV6
 EXPORT_SYMBOL(csum_ipv6_magic);
-EXPORT_SYMBOL(consistent_sync);
+#endif
 EXPORT_SYMBOL(clear_page);
diff -Naur linux-2.6.17.8/arch/sh/kernel/signal.c linux-2.6.17.8-sh/arch/sh/kernel/signal.c
--- linux-2.6.17.8/arch/sh/kernel/signal.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/signal.c	2006-08-23 13:29:47.887807000 +0100
@@ -33,7 +33,8 @@
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-asmlinkage int do_signal(struct pt_regs *regs, sigset_t *oldset);
+asmlinkage int do_signal(struct pt_regs *regs, sigset_t *oldset,
+			 unsigned int save_r0);
 
 /*
  * Atomically swap in the new signal mask, and wait for a signal.
@@ -56,7 +57,7 @@
 	while (1) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule();
-		if (do_signal(&regs, &saveset))
+		if (do_signal(&regs, &saveset, regs.regs[0]))
 			return -EINTR;
 	}
 }
@@ -85,7 +86,7 @@
 	while (1) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule();
-		if (do_signal(&regs, &saveset))
+		if (do_signal(&regs, &saveset, regs.regs[0]))
 			return -EINTR;
 	}
 }
@@ -516,25 +517,6 @@
 			case -ERESTARTNOINTR:
 				regs->pc -= 2;
 		}
-	} else {
-		/* gUSA handling */
-#ifdef CONFIG_PREEMPT
-		unsigned long flags;
-
-		local_irq_save(flags);
-#endif
-		if (regs->regs[15] >= 0xc0000000) {
-			int offset = (int)regs->regs[15];
-
-			/* Reset stack pointer: clear critical region mark */
-			regs->regs[15] = regs->regs[1];
-			if (regs->pc < regs->regs[0])
-				/* Go to rewind point #1 */
-				regs->pc = regs->regs[0] + offset - 2;
-		}
-#ifdef CONFIG_PREEMPT
-		local_irq_restore(flags);
-#endif
 	}
 
 	/* Set up the stack frame */
@@ -563,7 +545,7 @@
  * the kernel can handle, and then we build all the user-level signal handling
  * stack-frames in one go after that.
  */
-int do_signal(struct pt_regs *regs, sigset_t *oldset)
+int do_signal(struct pt_regs *regs, sigset_t *oldset, unsigned int save_r0)
 {
 	siginfo_t info;
 	int signr;
@@ -597,9 +579,12 @@
 		/* Restart the system call - no handlers present */
 		if (regs->regs[0] == -ERESTARTNOHAND ||
 		    regs->regs[0] == -ERESTARTSYS ||
-		    regs->regs[0] == -ERESTARTNOINTR ||
-		    regs->regs[0] == -ERESTART_RESTARTBLOCK) {
+		    regs->regs[0] == -ERESTARTNOINTR) {
+		    	regs->regs[0] = save_r0;
+			regs->pc -= 2;
+		} else if (regs->regs[0] == -ERESTART_RESTARTBLOCK) {
 			regs->pc -= 2;
+			regs->regs[3] = __NR_restart_syscall;
 		}
 	}
 	return 0;
diff -Naur linux-2.6.17.8/arch/sh/kernel/syscalls.S linux-2.6.17.8-sh/arch/sh/kernel/syscalls.S
--- linux-2.6.17.8/arch/sh/kernel/syscalls.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/syscalls.S	2006-08-23 13:29:44.757737000 +0100
@@ -0,0 +1,354 @@
+/*
+ * arch/sh/kernel/syscalls.S
+ *
+ * System call table for SuperH
+ *
+ *  Copyright (C) 1999, 2000, 2002  Niibe Yutaka
+ *  Copyright (C) 2003  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <linux/sys.h>
+#include <linux/linkage.h>
+#include <linux/config.h>
+
+#if !defined(CONFIG_NFSD) && !defined(CONFIG_NFSD_MODULE)
+#define sys_nfsservctl		sys_ni_syscall
+#endif
+
+#if !defined(CONFIG_MMU)
+#define sys_madvise		sys_ni_syscall
+#define sys_readahead		sys_ni_syscall
+#define sys_mprotect		sys_ni_syscall
+#define sys_msync		sys_ni_syscall
+#define sys_mlock		sys_ni_syscall
+#define sys_munlock		sys_ni_syscall
+#define sys_mlockall		sys_ni_syscall
+#define sys_munlockall		sys_ni_syscall
+#define sys_mremap		sys_ni_syscall
+#define sys_mincore		sys_ni_syscall
+#define sys_remap_file_pages	sys_ni_syscall
+#endif
+
+	.data
+ENTRY(sys_call_table)
+	.long sys_restart_syscall	/* 0  -  old "setup()" system call*/
+	.long sys_exit
+	.long sys_fork
+	.long sys_read
+	.long sys_write
+	.long sys_open		/* 5 */
+	.long sys_close
+	.long sys_waitpid
+	.long sys_creat
+	.long sys_link
+	.long sys_unlink		/* 10 */
+	.long sys_execve
+	.long sys_chdir
+	.long sys_time
+	.long sys_mknod
+	.long sys_chmod		/* 15 */
+	.long sys_lchown16
+	.long sys_ni_syscall	/* old break syscall holder */
+	.long sys_stat
+	.long sys_lseek
+	.long sys_getpid		/* 20 */
+	.long sys_mount
+	.long sys_oldumount
+	.long sys_setuid16
+	.long sys_getuid16
+	.long sys_stime		/* 25 */
+	.long sys_ptrace
+	.long sys_alarm
+	.long sys_fstat
+	.long sys_pause
+	.long sys_utime		/* 30 */
+	.long sys_ni_syscall	/* old stty syscall holder */
+	.long sys_ni_syscall	/* old gtty syscall holder */
+	.long sys_access
+	.long sys_nice
+	.long sys_ni_syscall	/* 35 */		/* old ftime syscall holder */
+	.long sys_sync
+	.long sys_kill
+	.long sys_rename
+	.long sys_mkdir
+	.long sys_rmdir		/* 40 */
+	.long sys_dup
+	.long sys_pipe
+	.long sys_times
+	.long sys_ni_syscall	/* old prof syscall holder */
+	.long sys_brk		/* 45 */
+	.long sys_setgid16
+	.long sys_getgid16
+	.long sys_signal
+	.long sys_geteuid16
+	.long sys_getegid16	/* 50 */
+	.long sys_acct
+	.long sys_umount		/* recycled never used phys() */
+	.long sys_ni_syscall	/* old lock syscall holder */
+	.long sys_ioctl
+	.long sys_fcntl		/* 55 */
+	.long sys_ni_syscall	/* old mpx syscall holder */
+	.long sys_setpgid
+	.long sys_ni_syscall	/* old ulimit syscall holder */
+	.long sys_ni_syscall	/* sys_olduname */
+	.long sys_umask		/* 60 */
+	.long sys_chroot
+	.long sys_ustat
+	.long sys_dup2
+	.long sys_getppid
+	.long sys_getpgrp		/* 65 */
+	.long sys_setsid
+	.long sys_sigaction
+	.long sys_sgetmask
+	.long sys_ssetmask
+	.long sys_setreuid16	/* 70 */
+	.long sys_setregid16
+	.long sys_sigsuspend
+	.long sys_sigpending
+	.long sys_sethostname
+	.long sys_setrlimit	/* 75 */
+	.long sys_old_getrlimit
+	.long sys_getrusage
+	.long sys_gettimeofday
+	.long sys_settimeofday
+	.long sys_getgroups16	/* 80 */
+	.long sys_setgroups16
+	.long sys_ni_syscall	/* sys_oldselect */
+	.long sys_symlink
+	.long sys_lstat
+	.long sys_readlink		/* 85 */
+	.long sys_uselib
+	.long sys_swapon
+	.long sys_reboot
+	.long old_readdir
+	.long old_mmap		/* 90 */
+	.long sys_munmap
+	.long sys_truncate
+	.long sys_ftruncate
+	.long sys_fchmod
+	.long sys_fchown16		/* 95 */
+	.long sys_getpriority
+	.long sys_setpriority
+	.long sys_ni_syscall	/* old profil syscall holder */
+	.long sys_statfs
+	.long sys_fstatfs		/* 100 */
+	.long sys_ni_syscall	/* ioperm */
+	.long sys_socketcall
+	.long sys_syslog
+	.long sys_setitimer
+	.long sys_getitimer	/* 105 */
+	.long sys_newstat
+	.long sys_newlstat
+	.long sys_newfstat
+	.long sys_uname
+	.long sys_ni_syscall	/* 110 */ /* iopl */
+	.long sys_vhangup
+	.long sys_ni_syscall	/* idle */
+	.long sys_ni_syscall	/* vm86old */
+	.long sys_wait4
+	.long sys_swapoff		/* 115 */
+	.long sys_sysinfo
+	.long sys_ipc
+	.long sys_fsync
+	.long sys_sigreturn
+	.long sys_clone		/* 120 */
+	.long sys_setdomainname
+	.long sys_newuname
+	.long sys_cacheflush	/* x86: sys_modify_ldt */
+	.long sys_adjtimex
+	.long sys_mprotect		/* 125 */
+	.long sys_sigprocmask
+	.long sys_ni_syscall	/* old "create_module" */
+	.long sys_init_module
+	.long sys_delete_module
+	.long sys_ni_syscall	/* 130: old "get_kernel_syms" */
+	.long sys_quotactl
+	.long sys_getpgid
+	.long sys_fchdir
+	.long sys_bdflush
+	.long sys_sysfs		/* 135 */
+	.long sys_personality
+	.long sys_ni_syscall	/* for afs_syscall */
+	.long sys_setfsuid16
+	.long sys_setfsgid16
+	.long sys_llseek		/* 140 */
+	.long sys_getdents
+	.long sys_select
+	.long sys_flock
+	.long sys_msync
+	.long sys_readv		/* 145 */
+	.long sys_writev
+	.long sys_getsid
+	.long sys_fdatasync
+	.long sys_sysctl
+	.long sys_mlock		/* 150 */
+	.long sys_munlock
+	.long sys_mlockall
+	.long sys_munlockall
+	.long sys_sched_setparam
+	.long sys_sched_getparam   /* 155 */
+	.long sys_sched_setscheduler
+	.long sys_sched_getscheduler
+	.long sys_sched_yield
+	.long sys_sched_get_priority_max
+	.long sys_sched_get_priority_min  /* 160 */
+	.long sys_sched_rr_get_interval
+	.long sys_nanosleep
+	.long sys_mremap
+	.long sys_setresuid16
+	.long sys_getresuid16	/* 165 */
+	.long sys_ni_syscall	/* vm86 */
+	.long sys_ni_syscall	/* old "query_module" */
+	.long sys_poll
+	.long sys_nfsservctl
+	.long sys_setresgid16	/* 170 */
+	.long sys_getresgid16
+	.long sys_prctl
+	.long sys_rt_sigreturn
+	.long sys_rt_sigaction
+	.long sys_rt_sigprocmask	/* 175 */
+	.long sys_rt_sigpending
+	.long sys_rt_sigtimedwait
+	.long sys_rt_sigqueueinfo
+	.long sys_rt_sigsuspend
+	.long sys_pread_wrapper	   /* 180 */
+	.long sys_pwrite_wrapper
+	.long sys_chown16
+	.long sys_getcwd
+	.long sys_capget
+	.long sys_capset           /* 185 */
+	.long sys_sigaltstack
+	.long sys_sendfile
+	.long sys_ni_syscall	/* streams1 */
+	.long sys_ni_syscall	/* streams2 */
+	.long sys_vfork            /* 190 */
+	.long sys_getrlimit
+	.long sys_mmap2
+	.long sys_truncate64
+	.long sys_ftruncate64
+	.long sys_stat64		/* 195 */
+	.long sys_lstat64
+	.long sys_fstat64
+	.long sys_lchown
+	.long sys_getuid
+	.long sys_getgid		/* 200 */
+	.long sys_geteuid
+	.long sys_getegid
+	.long sys_setreuid
+	.long sys_setregid
+	.long sys_getgroups	/* 205 */
+	.long sys_setgroups
+	.long sys_fchown
+	.long sys_setresuid
+	.long sys_getresuid
+	.long sys_setresgid	/* 210 */
+	.long sys_getresgid
+	.long sys_chown
+	.long sys_setuid
+	.long sys_setgid
+	.long sys_setfsuid		/* 215 */
+	.long sys_setfsgid
+	.long sys_pivot_root
+	.long sys_mincore
+	.long sys_madvise
+	.long sys_getdents64	/* 220 */
+	.long sys_fcntl64
+	.long sys_ni_syscall	/* reserved for TUX */
+	.long sys_ni_syscall	/* Reserved for Security */
+	.long sys_gettid
+	.long sys_readahead	/* 225 */
+	.long sys_setxattr
+	.long sys_lsetxattr
+	.long sys_fsetxattr
+	.long sys_getxattr
+	.long sys_lgetxattr	/* 230 */
+	.long sys_fgetxattr
+	.long sys_listxattr
+	.long sys_llistxattr
+	.long sys_flistxattr
+	.long sys_removexattr	/* 235 */
+	.long sys_lremovexattr
+	.long sys_fremovexattr
+	.long sys_tkill
+	.long sys_sendfile64
+	.long sys_futex		/* 240 */
+	.long sys_sched_setaffinity
+	.long sys_sched_getaffinity
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_io_setup	/* 245 */
+	.long sys_io_destroy
+	.long sys_io_getevents
+	.long sys_io_submit
+	.long sys_io_cancel
+	.long sys_fadvise64	/* 250 */
+	.long sys_ni_syscall
+	.long sys_exit_group
+	.long sys_lookup_dcookie
+	.long sys_epoll_create
+	.long sys_epoll_ctl	/* 255 */
+	.long sys_epoll_wait
+ 	.long sys_remap_file_pages
+ 	.long sys_set_tid_address
+ 	.long sys_timer_create
+ 	.long sys_timer_settime		/* 260 */
+ 	.long sys_timer_gettime
+ 	.long sys_timer_getoverrun
+ 	.long sys_timer_delete
+ 	.long sys_clock_settime
+ 	.long sys_clock_gettime		/* 265 */
+ 	.long sys_clock_getres
+ 	.long sys_clock_nanosleep
+	.long sys_statfs64
+	.long sys_fstatfs64
+	.long sys_tgkill		/* 270 */
+	.long sys_utimes
+ 	.long sys_fadvise64_64_wrapper
+	.long sys_ni_syscall	/* Reserved for vserver */
+	.long sys_ni_syscall	/* Reserved for mbind */
+	.long sys_ni_syscall	/* 275 - get_mempolicy */
+	.long sys_ni_syscall	/* set_mempolicy */
+	.long sys_mq_open
+	.long sys_mq_unlink
+	.long sys_mq_timedsend
+	.long sys_mq_timedreceive       /* 280 */
+	.long sys_mq_notify
+	.long sys_mq_getsetattr
+	.long sys_kexec_load
+	.long sys_waitid
+	.long sys_add_key		/* 285 */
+	.long sys_request_key
+	.long sys_keyctl
+	.long sys_ioprio_set
+	.long sys_ioprio_get
+	.long sys_inotify_init		/* 290 */
+	.long sys_inotify_add_watch
+	.long sys_inotify_rm_watch
+	.long sys_migrate_pages
+	.long sys_openat
+	.long sys_mkdirat		/* 295 */
+	.long sys_mknodat
+	.long sys_fchownat
+	.long sys_futimesat
+	.long sys_fstatat64
+	.long sys_unlinkat		/* 300 */
+	.long sys_renameat
+	.long sys_linkat
+	.long sys_symlinkat
+	.long sys_readlinkat
+	.long sys_fchmodat		/* 305 */
+	.long sys_faccessat
+	.long sys_ni_syscall		/* Reserved for pselect6 */
+	.long sys_ni_syscall		/* Reserved for ppoll */
+	.long sys_unshare
+	.long sys_set_robust_list	/* 310 */
+	.long sys_get_robust_list
+	.long sys_splice
+	.long sys_sync_file_range
+	.long sys_tee
+	.long sys_vmsplice		/* 315 */
diff -Naur linux-2.6.17.8/arch/sh/kernel/sys_sh.c linux-2.6.17.8-sh/arch/sh/kernel/sys_sh.c
--- linux-2.6.17.8/arch/sh/kernel/sys_sh.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/sys_sh.c	2006-08-23 13:29:44.807737000 +0100
@@ -21,9 +21,10 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
-
+#include <asm/cacheflush.h>
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
+#include <asm/cachectl.h>
 
 /*
  * sys_pipe() is the normal C calling standard for creating
@@ -261,6 +262,52 @@
 	return -EINVAL;
 }
 
+/* sys_cacheflush -- flush (part of) the processor cache.  */
+asmlinkage int
+sys_cacheflush (unsigned long addr, unsigned long len, int op)
+{
+	struct vm_area_struct *vma;
+
+	if ((op < 0) || (op > (CACHEFLUSH_D_PURGE|CACHEFLUSH_I)))
+		return -EINVAL;
+
+	/*
+	 * Verify that the specified address region actually belongs
+	 * to this process.
+	 */
+	if (addr + len < addr)
+		return -EFAULT;
+
+	down_read(&current->mm->mmap_sem);
+	vma = find_vma (current->mm, addr);
+	if (vma == NULL || addr < vma->vm_start || addr + len > vma->vm_end) {
+		up_read(&current->mm->mmap_sem);
+		return -EFAULT;
+	}
+
+#if !defined(CONFIG_SH_CACHE_DISABLE)
+
+	switch (op & CACHEFLUSH_D_PURGE) {
+		case CACHEFLUSH_D_INVAL:
+			__flush_invalidate_region((void*)addr, len);
+			break;
+		case CACHEFLUSH_D_WB:
+			__flush_wback_region((void*)addr, len);
+			break;
+		case CACHEFLUSH_D_PURGE:
+			__flush_purge_region((void*)addr, len);
+			break;
+	}
+	if (op & CACHEFLUSH_I) {
+		flush_cache_all();
+	}
+
+#endif
+
+	up_read(&current->mm->mmap_sem);
+	return 0;
+}
+
 asmlinkage int sys_uname(struct old_utsname * name)
 {
 	int err;
diff -Naur linux-2.6.17.8/arch/sh/kernel/time.c linux-2.6.17.8-sh/arch/sh/kernel/time.c
--- linux-2.6.17.8/arch/sh/kernel/time.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/time.c	2006-08-23 13:29:30.868415000 +0100
@@ -30,11 +30,14 @@
 /* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
  * these routines anywhere... */
 #ifdef CONFIG_SH_RTC
-void (*rtc_get_time)(struct timespec *) = sh_rtc_gettimeofday;
-int (*rtc_set_time)(const time_t) = sh_rtc_settimeofday;
+void (*rtc_sh_get_time)(struct timespec *) = sh_rtc_gettimeofday;
+int (*rtc_sh_set_time)(const time_t) = sh_rtc_settimeofday;
+#elif defined(CONFIG_SH_RTC_ST)
+void (*rtc_sh_get_time)(struct timespec *) = st_rtc_gettimeofday;
+int (*rtc_sh_set_time)(const time_t) = st_rtc_settimeofday;
 #else
-void (*rtc_get_time)(struct timespec *);
-int (*rtc_set_time)(const time_t);
+void (*rtc_sh_get_time)(struct timespec *);
+int (*rtc_sh_set_time)(const time_t);
 #endif
 
 /*
@@ -136,7 +139,7 @@
 	    xtime.tv_sec > last_rtc_update + 660 &&
 	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
 	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
-		if (rtc_set_time(xtime.tv_sec) == 0)
+		if (rtc_sh_set_time(xtime.tv_sec) == 0)
 			last_rtc_update = xtime.tv_sec;
 		else
 			/* do it again in 60s */
@@ -144,8 +147,33 @@
 	}
 }
 
+#ifdef CONFIG_PM
+int timer_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->stop();
+
+	return 0;
+}
+
+int timer_resume(struct sys_device *dev)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->start();
+
+	return 0;
+}
+#else
+#define timer_suspend NULL
+#define timer_resume NULL
+#endif
+
 static struct sysdev_class timer_sysclass = {
 	set_kset_name("timer"),
+	.suspend = timer_suspend,
+	.resume	 = timer_resume,
 };
 
 static int __init timer_init_sysfs(void)
@@ -169,8 +197,8 @@
 
 	clk_init();
 
-	if (rtc_get_time) {
-		rtc_get_time(&xtime);
+	if (rtc_sh_get_time) {
+		rtc_sh_get_time(&xtime);
 	} else {
 		xtime.tv_sec = mktime(2000, 1, 1, 0, 0, 0);
 		xtime.tv_nsec = 0;
diff -Naur linux-2.6.17.8/arch/sh/kernel/timers/timer-tmu.c linux-2.6.17.8-sh/arch/sh/kernel/timers/timer-tmu.c
--- linux-2.6.17.8/arch/sh/kernel/timers/timer-tmu.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/timers/timer-tmu.c	2006-08-23 13:29:47.132783000 +0100
@@ -31,26 +31,26 @@
 
 #define TMU0_TCR_CALIB	0x0000
 
+/* LATCH, which is derived from CLOCK_TICK_RATE is an approximation
+ * of the number of ticks per HZ and can be pre-computed by the
+ * compiler. However it does not actually represent the number of
+ * ticks programmed into the TMU. Within the file we prefer the use
+ * of actual_latch since this reflects the actual TMU settings.
+ */
+static unsigned long actual_latch = LATCH;
+
 static DEFINE_SPINLOCK(tmu0_lock);
 
 static unsigned long tmu_timer_get_offset(void)
 {
 	int count;
+	long long usecs;
 	unsigned long flags;
 
-	static int count_p = 0x7fffffff;    /* for the first call after boot */
-	static unsigned long jiffies_p = 0;
-
-	/*
-	 * cache volatile jiffies temporarily; we have IRQs turned off.
-	 */
-	unsigned long jiffies_t;
-
 	spin_lock_irqsave(&tmu0_lock, flags);
-	/* timer count may underflow right here */
-	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
 
-	jiffies_t = jiffies;
+	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
+	/* timer count may underflow right here */
 
 	/*
 	 * avoiding timer inconsistencies (they are rare, but they happen)...
@@ -58,26 +58,30 @@
 	 *  1. the timer counter underflows
 	 */
 
-	if (jiffies_t == jiffies_p) {
-		if (count > count_p) {
-			/* the nutcase */
-			if (ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
-				count -= LATCH;
-			} else {
-				printk("%s (): hardware timer problem?\n",
-				       __FUNCTION__);
-			}
-		}
-	} else
-		jiffies_p = jiffies_t;
+	if(ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
+		/*
+		 * Using only TMU0 we cannot detect lost timer interrupts ...
+		 * well, that's why we call them lost, don't we? :)
+		 * [hmm, on the Pentium and Alpha we can ... sort of]
+		 *
+		 * The best we can do it to re-read count now we know
+		 * that there has been an underflow to ensure that count
+		 * really has wrapped to TMU0_TCOR (and adjust count
+		 * by the latch interval). This will give the correct
+		 * result until we are only a few cycles away from
+		 * dropping a timer interrupt anyway.
+		 */
+
+		count = ctrl_inl(TMU0_TCNT) - actual_latch;
+	}
 
-	count_p = count;
 	spin_unlock_irqrestore(&tmu0_lock, flags);
 
-	count = ((LATCH-1) - count) * TICK_SIZE;
-	count = (count + LATCH/2) / LATCH;
+	usecs = (long long) (actual_latch - count) * (long long) TICK_SIZE;
+	usecs = (usecs + actual_latch/2) / (actual_latch+1);
+	BUG_ON(usecs < 0);
 
-	return count;
+	return (unsigned long) usecs;
 }
 
 static irqreturn_t tmu_timer_interrupt(int irq, void *dev_id,
@@ -132,17 +136,17 @@
 	ctrl_outl(0xffffffff, TMU0_TCOR);
 	ctrl_outl(0xffffffff, TMU0_TCNT);
 
-	rtc_get_time(&ts2);
+	rtc_sh_get_time(&ts2);
 
 	do {
-		rtc_get_time(&ts1);
+		rtc_sh_get_time(&ts1);
 	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
 
 	/* actually start the timer */
 	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
 
 	do {
-		rtc_get_time(&ts2);
+		rtc_sh_get_time(&ts2);
 	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
 
 	freq = 0xffffffff - ctrl_inl(TMU0_TCNT);
@@ -188,16 +192,26 @@
 	.ops		= &tmu_clk_ops,
 };
 
-static int tmu_timer_init(void)
+static int tmu_timer_start(void)
 {
-	unsigned long interval;
+	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+	return 0;
+}
+
+static int tmu_timer_stop(void)
+{
+	ctrl_outb(0, TMU_TSTR);
+	return 0;
+}
 
+static int tmu_timer_init(void)
+{
 	setup_irq(TIMER_IRQ, &tmu_irq);
 
 	tmu0_clk.parent = clk_get("module_clk");
 
 	/* Start TMU0 */
-	ctrl_outb(0, TMU_TSTR);
+	tmu_timer_stop();
 #if !defined(CONFIG_CPU_SUBTYPE_SH7300) && !defined(CONFIG_CPU_SUBTYPE_SH7760)
 	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
 #endif
@@ -205,19 +219,21 @@
 	clk_register(&tmu0_clk);
 	clk_enable(&tmu0_clk);
 
-	interval = (clk_get_rate(&tmu0_clk) + HZ / 2) / HZ;
-	printk(KERN_INFO "Interval = %ld\n", interval);
+	actual_latch = (clk_get_rate(&tmu0_clk) + HZ / 2) / HZ;
+	printk(KERN_DEBUG "TMU0: ticks per jiffy = %ld\n", actual_latch);
 
-	ctrl_outl(interval, TMU0_TCOR);
-	ctrl_outl(interval, TMU0_TCNT);
+	ctrl_outl(actual_latch, TMU0_TCOR);
+	ctrl_outl(actual_latch, TMU0_TCNT);
 
-	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+	tmu_timer_start();
 
 	return 0;
 }
 
 struct sys_timer_ops tmu_timer_ops = {
 	.init		= tmu_timer_init,
+	.start		= tmu_timer_start,
+	.stop		= tmu_timer_stop,
 	.get_frequency	= tmu_timer_get_frequency,
 	.get_offset	= tmu_timer_get_offset,
 };
diff -Naur linux-2.6.17.8/arch/sh/kernel/traps.c linux-2.6.17.8-sh/arch/sh/kernel/traps.c
--- linux-2.6.17.8/arch/sh/kernel/traps.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/traps.c	2006-08-23 13:29:37.403576000 +0100
@@ -37,40 +37,15 @@
 
 #ifdef CONFIG_SH_KGDB
 #include <asm/kgdb.h>
-#define CHK_REMOTE_DEBUG(regs)                                               \
-{                                                                            \
-  if ((kgdb_debug_hook != (kgdb_debug_hook_t *) NULL) && (!user_mode(regs))) \
-  {                                                                          \
-    (*kgdb_debug_hook)(regs);                                                \
-  }                                                                          \
+#define CHK_REMOTE_DEBUG(regs)                 	\
+{       					\
+	if (kgdb_debug_hook && !user_mode(regs))\
+		(*kgdb_debug_hook)(regs);       \
 }
 #else
 #define CHK_REMOTE_DEBUG(regs)
 #endif
 
-#define DO_ERROR(trapnr, signr, str, name, tsk)				\
-asmlinkage void do_##name(unsigned long r4, unsigned long r5,		\
-			  unsigned long r6, unsigned long r7,		\
-			  struct pt_regs regs)				\
-{									\
-	unsigned long error_code;					\
- 									\
-	/* Check if it's a DSP instruction */				\
- 	if (is_dsp_inst(&regs)) {					\
-		/* Enable DSP mode, and restart instruction. */		\
-		regs.sr |= SR_DSP;					\
-		return;							\
-	}								\
-									\
-	asm volatile("stc	r2_bank, %0": "=r" (error_code));	\
-	local_irq_enable();						\
-	tsk->thread.error_code = error_code;				\
-	tsk->thread.trap_no = trapnr;					\
-        CHK_REMOTE_DEBUG(&regs);					\
-	force_sig(signr, tsk);						\
-	die_if_no_fixup(str,&regs,error_code);				\
-}
-
 #ifdef CONFIG_CPU_SH2
 #define TRAP_RESERVED_INST	4
 #define TRAP_ILLEGAL_SLOT_INST	6
@@ -87,7 +62,7 @@
 #define VMALLOC_OFFSET (8*1024*1024)
 #define MODULE_RANGE (8*1024*1024)
 
-spinlock_t die_lock;
+DEFINE_SPINLOCK(die_lock);
 
 void die(const char * str, struct pt_regs * regs, long err)
 {
@@ -576,8 +551,117 @@
 #define is_dsp_inst(regs)	(0)
 #endif /* CONFIG_SH_DSP */
 
-DO_ERROR(TRAP_RESERVED_INST, SIGILL, "reserved instruction", reserved_inst, current)
-DO_ERROR(TRAP_ILLEGAL_SLOT_INST, SIGILL, "illegal slot instruction", illegal_slot_inst, current)
+extern int do_fpu_inst(unsigned short, struct pt_regs*);
+
+asmlinkage void do_reserved_inst(unsigned long r4, unsigned long r5,
+				unsigned long r6, unsigned long r7,
+				struct pt_regs regs)
+{
+	unsigned long error_code;
+	struct task_struct *tsk = current;
+
+#ifdef CONFIG_SH_FPU_EMU
+	unsigned short inst;
+	int err;
+
+	get_user(inst, (unsigned short*)regs.pc);
+
+	err = do_fpu_inst(inst, &regs);
+	if (!err) {
+		regs.pc += 2;
+		return;
+	}
+	/* not a FPU inst. */
+#endif
+
+#ifdef CONFIG_SH_DSP
+	/* Check if it's a DSP instruction */
+ 	if (is_dsp_inst(&regs)) {
+		/* Enable DSP mode, and restart instruction. */
+		regs.sr |= SR_DSP;
+		return;
+	}
+#endif
+
+	asm volatile("stc	r2_bank, %0": "=r" (error_code));
+	local_irq_enable();
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = TRAP_RESERVED_INST;
+	CHK_REMOTE_DEBUG(&regs);
+	force_sig(SIGILL, tsk);
+	die_if_no_fixup("reserved instruction", &regs, error_code);
+}
+
+#ifdef CONFIG_SH_FPU_EMU
+static int emulate_branch(unsigned short inst, struct pt_regs* regs)
+{
+	/*
+	 * bfs: 8fxx: PC+=d*2+4;
+	 * bts: 8dxx: PC+=d*2+4;
+	 * bra: axxx: PC+=D*2+4;
+	 * bsr: bxxx: PC+=D*2+4  after PR=PC+4;
+	 * braf:0x23: PC+=Rn*2+4;
+	 * bsrf:0x03: PC+=Rn*2+4 after PR=PC+4;
+	 * jmp: 4x2b: PC=Rn;
+	 * jsr: 4x0b: PC=Rn      after PR=PC+4;
+	 * rts: 000b: PC=PR;
+	 */
+	if ((inst & 0xfd00) == 0x8d00) {
+		regs->pc += SH_PC_8BIT_OFFSET(inst);
+		return 0;
+	}
+
+	if ((inst & 0xe000) == 0xa000) {
+		regs->pc += SH_PC_12BIT_OFFSET(inst);
+		return 0;
+	}
+
+	if ((inst & 0xf0df) == 0x0003) {
+		regs->pc += regs->regs[(inst & 0x0f00) >> 8] + 4;
+		return 0;
+	}
+
+	if ((inst & 0xf0df) == 0x400b) {
+		regs->pc = regs->regs[(inst & 0x0f00) >> 8];
+		return 0;
+	}
+
+	if ((inst & 0xffff) == 0x000b) {
+		regs->pc = regs->pr;
+		return 0;
+	}
+
+	return 1;
+}
+#endif
+
+asmlinkage void do_illegal_slot_inst(unsigned long r4, unsigned long r5,
+				unsigned long r6, unsigned long r7,
+				struct pt_regs regs)
+{
+	unsigned long error_code;
+	struct task_struct *tsk = current;
+#ifdef CONFIG_SH_FPU_EMU
+	unsigned short inst;
+
+	get_user(inst, (unsigned short *)regs.pc + 1);
+	if (!do_fpu_inst(inst, &regs)) {
+		get_user(inst, (unsigned short *)regs.pc);
+		if (!emulate_branch(inst, &regs))
+			return;
+		/* fault in branch.*/
+	}
+	/* not a FPU inst. */
+#endif
+
+	asm volatile("stc	r2_bank, %0": "=r" (error_code));
+	local_irq_enable();
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = TRAP_RESERVED_INST;
+	CHK_REMOTE_DEBUG(&regs);
+	force_sig(SIGILL, tsk);
+	die_if_no_fixup("illegal slot instruction", &regs, error_code);
+}
 
 asmlinkage void do_exception_error(unsigned long r4, unsigned long r5,
 				   unsigned long r6, unsigned long r7,
@@ -635,14 +719,16 @@
 	exception_handling_table[TRAP_ILLEGAL_SLOT_INST]
 		= (void *)do_illegal_slot_inst;
 
-#ifdef CONFIG_CPU_SH4
-	if (!(cpu_data->flags & CPU_HAS_FPU)) {
-		/* For SH-4 lacking an FPU, treat floating point instructions
-		   as reserved. */
-		/* entry 64 corresponds to EXPEVT=0x800 */
-		exception_handling_table[64] = (void *)do_reserved_inst;
-		exception_handling_table[65] = (void *)do_illegal_slot_inst;
-	}
+#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SH_FPU) || \
+    defined(CONFIG_SH_FPU_EMU)
+	/*
+	 * For SH-4 lacking an FPU, treat floating point instructions as
+	 * reserved. They'll be handled in the math-emu case, or faulted on
+	 * otherwise.
+	 */
+	/* entry 64 corresponds to EXPEVT=0x800 */
+	exception_handling_table[64] = (void *)do_reserved_inst;
+	exception_handling_table[65] = (void *)do_illegal_slot_inst;
 #endif
 		
 	/* Setup VBR for boot cpu */
@@ -661,14 +747,8 @@
 	}
 
 	if (!sp) {
-		__asm__ __volatile__ (
-			"mov r15, %0\n\t"
-			"stc r7_bank, %1\n\t"
-			: "=r" (module_start),
-			  "=r" (module_end)
-		);
-		
-		sp = (unsigned long *)module_start;
+		register long* r15 __asm__ ("r15");
+		sp = r15;
 	}
 
 	stack = sp;
diff -Naur linux-2.6.17.8/arch/sh/kernel/vmlinux.lds.S linux-2.6.17.8-sh/arch/sh/kernel/vmlinux.lds.S
--- linux-2.6.17.8/arch/sh/kernel/vmlinux.lds.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/kernel/vmlinux.lds.S	2006-08-23 13:29:28.281370000 +0100
@@ -14,7 +14,7 @@
 ENTRY(_start)
 SECTIONS
 {
-  . = 0x80000000 + CONFIG_MEMORY_START + CONFIG_ZERO_PAGE_OFFSET;
+  . = CONFIG_PAGE_OFFSET + CONFIG_MEMORY_START + CONFIG_ZERO_PAGE_OFFSET;
   _text = .;			/* Text and read-only data */
   text = .;			/* Text and read-only data */
   .empty_zero_page : {
@@ -63,8 +63,6 @@
 
   . = ALIGN(8192);		/* init_task */
   .data.init_task : { *(.data.init_task) }
-  /* stack */
-  .stack : { stack = .;  _stack = .; }
 
   . = ALIGN(4096);		/* Init code and data */
   __init_begin = .;
diff -Naur linux-2.6.17.8/arch/sh/lib/checksum.S linux-2.6.17.8-sh/arch/sh/lib/checksum.S
--- linux-2.6.17.8/arch/sh/lib/checksum.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/checksum.S	2006-08-23 13:29:14.384047000 +0100
@@ -202,8 +202,9 @@
 	cmp/pz	r6		! Jump if we had at least two bytes.
 	bt/s	1f
 	 clrt
+	add	#2,r6		! r6 was < 2.	Deal with it.
 	bra	4f
-	 add	#2,r6		! r6 was < 2.	Deal with it.
+	 mov	r6,r2
 
 3:	! Handle different src and dest alignments.
 	! This is not common, so simple byte by byte copy will do.
diff -Naur linux-2.6.17.8/arch/sh/lib/delay.c linux-2.6.17.8-sh/arch/sh/lib/delay.c
--- linux-2.6.17.8/arch/sh/lib/delay.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/delay.c	2006-08-23 13:29:46.576783000 +0100
@@ -21,12 +21,13 @@
 
 inline void __const_udelay(unsigned long xloops)
 {
+	xloops *= 4;
 	__asm__("dmulu.l	%0, %2\n\t"
 		"sts	mach, %0"
 		: "=r" (xloops)
-		: "0" (xloops), "r" (cpu_data[raw_smp_processor_id()].loops_per_jiffy)
+		: "0" (xloops), "r" (cpu_data[raw_smp_processor_id()].loops_per_jiffy * (HZ/4))
 		: "macl", "mach");
-	__delay(xloops * HZ);
+	__delay(++xloops);
 }
 
 void __udelay(unsigned long usecs)
diff -Naur linux-2.6.17.8/arch/sh/lib/divdi3.c linux-2.6.17.8-sh/arch/sh/lib/divdi3.c
--- linux-2.6.17.8/arch/sh/lib/divdi3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/divdi3.c	2006-08-23 13:29:42.332691000 +0100
@@ -0,0 +1,32 @@
+/*
+ * Simple __divdi3 function which doesn't use FPU.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+extern u64 __xdiv64_32(u64 n, u32 d);
+
+s64 __divdi3(s64 n, s64 d)
+{
+	int c = 0;
+	s64 res;
+
+	if (n < 0LL) {
+		c = ~c;
+		n = -n;
+	}
+	if (d < 0LL) {
+		c = ~c;
+		d = -d;
+	}
+
+	if (unlikely(d & 0xffffffff00000000LL))
+		panic("Need true 64-bit/64-bit division");
+
+	res = __xdiv64_32(n, (u32)d);
+	if (c) {
+		res = -res;
+	}
+	return res;
+}
diff -Naur linux-2.6.17.8/arch/sh/lib/Makefile linux-2.6.17.8-sh/arch/sh/lib/Makefile
--- linux-2.6.17.8/arch/sh/lib/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/Makefile	2006-08-23 13:29:42.313694000 +0100
@@ -3,7 +3,7 @@
 #
 
 lib-y  = delay.o memset.o memmove.o memchr.o \
-	 checksum.o strcasecmp.o strlen.o div64.o udivdi3.o \
+	 checksum.o strcasecmp.o strlen.o div64.o udivdi3.o divdi3.o \
 	 div64-generic.o
 
 memcpy-y			:= memcpy.o
diff -Naur linux-2.6.17.8/arch/sh/lib/memset.S linux-2.6.17.8-sh/arch/sh/lib/memset.S
--- linux-2.6.17.8/arch/sh/lib/memset.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/memset.S	2006-08-23 13:29:13.065001000 +0100
@@ -29,6 +29,7 @@
 	bf/s	1b
 	 mov.b	r5,@-r4
 2:				! make VVVV
+	extu.b	r5,r5
 	swap.b	r5,r0		!   V0
 	or	r0,r5		!   VV
 	swap.w	r5,r0		! VV00
diff -Naur linux-2.6.17.8/arch/sh/lib/udivdi3.c linux-2.6.17.8-sh/arch/sh/lib/udivdi3.c
--- linux-2.6.17.8/arch/sh/lib/udivdi3.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/lib/udivdi3.c	2006-08-23 13:29:42.342694000 +0100
@@ -3,13 +3,13 @@
  */
 
 #include <linux/types.h>
+#include <linux/kernel.h>
 
 extern u64 __xdiv64_32(u64 n, u32 d);
-extern void panic(const char * fmt, ...);
 
 u64 __udivdi3(u64 n, u64 d)
 {
-	if (d & ~0xffffffff)
+	if (unlikely(d & 0xffffffff00000000ULL))
 		panic("Need true 64-bit/64-bit division");
 	return __xdiv64_32(n, (u32)d);
 }
diff -Naur linux-2.6.17.8/arch/sh/Makefile linux-2.6.17.8-sh/arch/sh/Makefile
--- linux-2.6.17.8/arch/sh/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/Makefile	2006-08-23 13:29:42.999691000 +0100
@@ -79,14 +79,26 @@
 LIBGCC := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
 
 core-y				+= arch/sh/kernel/ arch/sh/mm/
+core-$(CONFIG_SH_FPU_EMU)	+= arch/sh/math-emu/
 
 # Boards
 machdir-$(CONFIG_SH_SOLUTION_ENGINE)		:= se/770x
 machdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se/7751
 machdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)	:= se/7300
 machdir-$(CONFIG_SH_73180_SOLUTION_ENGINE)	:= se/73180
-machdir-$(CONFIG_SH_STB1_HARP)			:= harp
-machdir-$(CONFIG_SH_STB1_OVERDRIVE)		:= overdrive
+machdir-$(CONFIG_SH_ST40RA_EVAL)		:= st/st40raeval    st/harp-common
+machdir-$(CONFIG_SH_ST40RA_STARTER)		:= st/st40rastarter st/harp-common
+machdir-$(CONFIG_SH_ST40GX1_EVAL)		:= st/st40gx1eval   st/harp-common
+machdir-$(CONFIG_SH_STB1_HARP)			:= st/stb1harp      st/harp-common
+machdir-$(CONFIG_SH_STB1_OVERDRIVE)		:= st/stb1overdrive st/harp-common
+machdir-$(CONFIG_SH_STB7100_MBOARD)		:= st/stb7100mboard st/harp-common
+machdir-$(CONFIG_SH_STB7100_REF)		:= st/stb7100ref
+machdir-$(CONFIG_SH_STB7109E_REF)		:= st/stb7109eref
+machdir-$(CONFIG_SH_MEDIAREF)			:= st/mediaref
+machdir-$(CONFIG_SH_STI5528_EVAL)		:= st/sti5528eval   st/harp-common
+machdir-$(CONFIG_SH_STI5528_ESPRESSO)		:= st/sti5528espresso
+machdir-$(CONFIG_SH_STM8000_DEMO)		:= st/stm8000demo   st/harp-common
+machdir-$(CONFIG_SH_ST220_EVAL)			:= st/st220eval
 machdir-$(CONFIG_SH_HP6XX)			:= hp6xx
 machdir-$(CONFIG_SH_CQREEK)			:= cqreek
 machdir-$(CONFIG_SH_DMIDA)			:= dmida
@@ -104,19 +116,17 @@
 machdir-$(CONFIG_SH_RTS7751R2D)			:= renesas/rts7751r2d
 machdir-$(CONFIG_SH_7751_SYSTEMH)		:= renesas/systemh
 machdir-$(CONFIG_SH_EDOSK7705)			:= renesas/edosk7705
+machdir-$(CONFIG_SH_R7780RP)			:= renesas/r7780rp
 machdir-$(CONFIG_SH_SH4202_MICRODEV)		:= superh/microdev
+machdir-$(CONFIG_SH_LANDISK)			:= landisk
+machdir-$(CONFIG_SH_TITAN)			:= titan
 machdir-$(CONFIG_SH_UNKNOWN)			:= unknown
 
-incdir-y			:= $(notdir $(machdir-y))
-
-incdir-$(CONFIG_SH_SOLUTION_ENGINE)		:= se
-incdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se7751
-incdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)        := se7300
-incdir-$(CONFIG_SH_73180_SOLUTION_ENGINE)	:= se73180
-incdir-$(CONFIG_SH_HP600)			:= hp6xx
+incdir-y			:= $(notdir $(firstword $(machdir-y)))
+incdir-$(CONFIG_SH_HP6XX)			:= hp6xx
 
 ifneq ($(machdir-y),)
-core-y				+= arch/sh/boards/$(machdir-y)/
+core-y		+= $(addprefix arch/sh/boards/,$(addsuffix /,$(machdir-y)))
 endif
 
 # Companion chips
@@ -137,17 +147,14 @@
 
 CPPFLAGS_vmlinux.lds := -traditional
 
-ifneq ($(KBUILD_SRC),)
 incdir-prefix	:= $(srctree)/include/asm-sh/
-else
-incdir-prefix	:=
-endif
 
 #	Update machine arch and proc symlinks if something which affects
 #	them changed.  We use .arch and .mach to indicate when they were
 #	updated last, otherwise make uses the target directory mtime.
 
-include/asm-sh/.cpu: $(wildcard include/config/cpu/*.h) include/config/MARKER
+include/asm-sh/.cpu: $(wildcard include/config/cpu/*.h) \
+		     include/config/MARKER FORCE
 	@echo '  SYMLINK include/asm-sh/cpu -> include/asm-sh/$(cpuincdir-y)'
 	$(Q)if [ ! -d include/asm-sh ]; then mkdir -p include/asm-sh; fi
 	$(Q)ln -fsn $(incdir-prefix)$(cpuincdir-y) include/asm-sh/cpu
@@ -157,7 +164,8 @@
 #	don't, just reference the parent directory so the semantics are
 #	kept roughly the same.
 
-include/asm-sh/.mach: $(wildcard include/config/sh/*.h) include/config/MARKER
+include/asm-sh/.mach: $(wildcard include/config/sh/*.h) \
+		      include/config/MARKER FORCE
 	@echo -n '  SYMLINK include/asm-sh/mach -> '
 	$(Q)if [ ! -d include/asm-sh ]; then mkdir -p include/asm-sh; fi
 	$(Q)if [ -d $(incdir-prefix)$(incdir-y) ]; then \
@@ -170,7 +178,7 @@
 	fi
 	@touch $@
 
-archprepare: maketools include/asm-sh/.cpu include/asm-sh/.mach
+archprepare: include/asm-sh/.cpu include/asm-sh/.mach maketools
 
 PHONY += maketools FORCE
 maketools:  include/linux/version.h FORCE
@@ -178,7 +186,7 @@
 
 all: zImage
 
-zImage: vmlinux
+zImage uImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
 
 compressed: zImage
@@ -189,6 +197,7 @@
 CLEAN_FILES += include/asm-sh/machtypes.h
 
 define archhelp
-	@echo '  zImage 	           - Compressed kernel image (arch/sh/boot/zImage)'
+	@echo '  zImage                   - Compressed kernel image (arch/sh/boot/zImage)'
+	@echo '  uImage                   - Create a bootable image for U-Boot'
 endef
 
diff -Naur linux-2.6.17.8/arch/sh/math-emu/Makefile linux-2.6.17.8-sh/arch/sh/math-emu/Makefile
--- linux-2.6.17.8/arch/sh/math-emu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/math-emu/Makefile	2006-08-23 13:29:27.815346000 +0100
@@ -0,0 +1 @@
+obj-y	:= math.o
diff -Naur linux-2.6.17.8/arch/sh/math-emu/math.c linux-2.6.17.8-sh/arch/sh/math-emu/math.c
--- linux-2.6.17.8/arch/sh/math-emu/math.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/math-emu/math.c	2006-08-23 13:29:27.833346000 +0100
@@ -0,0 +1,624 @@
+/*
+ * arch/sh/math-emu/math.c
+ *
+ * Copyright (C) 2006 Takashi YOSHII <takasi-y@ops.dti.ne.jp>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+
+#include "sfp-util.h"
+#include <math-emu/soft-fp.h>
+#include <math-emu/single.h>
+#include <math-emu/double.h>
+
+#define	FPUL		(fregs->fpul)
+#define FPSCR		(fregs->fpscr)
+#define FPSCR_RM	(FPSCR&3)
+#define FPSCR_DN	((FPSCR>>18)&1)
+#define FPSCR_PR	((FPSCR>>19)&1)
+#define FPSCR_SZ	((FPSCR>>20)&1)
+#define FPSCR_FR	((FPSCR>>21)&1)
+#define FPSCR_MASK	0x003fffffUL
+
+#define BANK(n)	(n^(FPSCR_FR?16:0))
+#define FR	((unsigned long*)(fregs->fp_regs))
+#define FR0	(FR[BANK(0)])
+#define FRn	(FR[BANK(n)])
+#define FRm	(FR[BANK(m)])
+#define DR	((unsigned long long*)(fregs->fp_regs))
+#define DRn	(DR[BANK(n)/2])
+#define DRm	(DR[BANK(m)/2])
+
+#define XREG(n)	(n^16)
+#define XFn	(FR[BANK(XREG(n))])
+#define XFm	(FR[BANK(XREG(m))])
+#define XDn	(DR[BANK(XREG(n))/2])
+#define XDm	(DR[BANK(XREG(m))/2])
+
+#define R0	(regs->regs[0])
+#define Rn	(regs->regs[n])
+#define Rm	(regs->regs[m])
+
+#define WRITE(d,a)	({if(put_user(d, (typeof (d)*)a)) return -EFAULT;})
+#define READ(d,a)	({if(get_user(d, (typeof (d)*)a)) return -EFAULT;})
+
+#define PACK_S(r,f)	FP_PACK_SP(&r,f)
+#define UNPACK_S(f,r)	FP_UNPACK_SP(f,&r)
+#define PACK_D(r,f) \
+	{u32 t[2]; FP_PACK_DP(t,f); ((u32*)&r)[0]=t[1]; ((u32*)&r)[1]=t[0];}
+#define UNPACK_D(f,r) \
+	{u32 t[2]; t[0]=((u32*)&r)[1]; t[1]=((u32*)&r)[0]; FP_UNPACK_DP(f,t);}
+
+// 2 args instructions.
+#define BOTH_PRmn(op,x) \
+	FP_DECL_EX; if(FPSCR_PR) op(D,x,DRm,DRn); else op(S,x,FRm,FRn);
+
+#define CMP_X(SZ,R,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_CMP_##SZ(R, Fn, Fm, 2); }while(0)
+#define EQ_X(SZ,R,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_CMP_EQ_##SZ(R, Fn, Fm); }while(0)
+#define CMP(OP) ({ int r; BOTH_PRmn(OP##_X,r); r; })
+
+static int
+fcmp_gt(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	if (CMP(CMP) > 0)
+		regs->sr |= 1;
+	else
+		regs->sr &= ~1;
+
+	return 0;
+}
+
+static int
+fcmp_eq(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	if (CMP(CMP /*EQ*/) == 0)
+		regs->sr |= 1;
+	else
+		regs->sr &= ~1;
+	return 0;
+}
+
+#define ARITH_X(SZ,OP,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); FP_DECL_##SZ(Fr); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_##OP##_##SZ(Fr, Fn, Fm); \
+	PACK_##SZ(N, Fr); }while(0)
+
+static int
+fadd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, ADD);
+	return 0;
+}
+
+static int
+fsub(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, SUB);
+	return 0;
+}
+
+static int
+fmul(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, MUL);
+	return 0;
+}
+
+static int
+fdiv(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, DIV);
+	return 0;
+}
+
+static int
+fmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_S(Fr);
+	FP_DECL_S(Ft);
+	FP_DECL_S(F0);
+	FP_DECL_S(Fm);
+	FP_DECL_S(Fn);
+	UNPACK_S(F0, FR0);
+	UNPACK_S(Fm, FRm);
+	UNPACK_S(Fn, FRn);
+	FP_MUL_S(Ft, Fm, F0);
+	FP_ADD_S(Fr, Fn, Ft);
+	PACK_S(FRn, Fr);
+	return 0;
+}
+
+// to process fmov's extention (odd n for DR access XD).
+#define FMOV_EXT(x) if(x&1) x+=16-1
+
+static int
+fmov_idx_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + R0 + 4);
+		n++;
+		READ(FRn, Rm + R0);
+	} else {
+		READ(FRn, Rm + R0);
+	}
+
+	return 0;
+}
+
+static int
+fmov_mem_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + 4);
+		n++;
+		READ(FRn, Rm);
+	} else {
+		READ(FRn, Rm);
+	}
+
+	return 0;
+}
+
+static int
+fmov_inc_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + 4);
+		n++;
+		READ(FRn, Rm);
+		Rm += 8;
+	} else {
+		READ(FRn, Rm);
+		Rm += 4;
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_idx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		WRITE(FRm, Rn + R0 + 4);
+		m++;
+		WRITE(FRm, Rn + R0);
+	} else {
+		WRITE(FRm, Rn + R0);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_mem(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		WRITE(FRm, Rn + 4);
+		m++;
+		WRITE(FRm, Rn);
+	} else {
+		WRITE(FRm, Rn);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		Rn -= 8;
+		WRITE(FRm, Rn + 4);
+		m++;
+		WRITE(FRm, Rn);
+	} else {
+		Rn -= 4;
+		WRITE(FRm, Rn);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		FMOV_EXT(n);
+		DRn = DRm;
+	} else {
+		FRn = FRm;
+	}
+
+	return 0;
+}
+
+static int
+fnop_mn(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	return -EINVAL;
+}
+
+// 1 arg instructions.
+#define NOTYETn(i) static int i(struct sh_fpu_soft_struct *fregs, int n) \
+	{ printk( #i " not yet done.\n"); return 0; }
+
+NOTYETn(ftrv)
+NOTYETn(fsqrt)
+NOTYETn(fipr)
+NOTYETn(fsca)
+NOTYETn(fsrra)
+
+#define EMU_FLOAT_X(SZ,N) do { \
+	FP_DECL_##SZ(Fn); \
+	FP_FROM_INT_##SZ(Fn, FPUL, 32, int); \
+	PACK_##SZ(N, Fn); }while(0)
+static int ffloat(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+
+	if (FPSCR_PR)
+		EMU_FLOAT_X(D, DRn);
+	else
+		EMU_FLOAT_X(S, FRn);
+
+	return 0;
+}
+
+#define EMU_FTRC_X(SZ,N) do { \
+	FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fn, N); \
+	FP_TO_INT_##SZ(FPUL, Fn, 32, 1); }while(0)
+static int ftrc(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+
+	if (FPSCR_PR)
+		EMU_FTRC_X(D, DRn);
+	else
+		EMU_FTRC_X(S, FRn);
+
+	return 0;
+}
+
+static int fcnvsd(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_S(Fn);
+	FP_DECL_D(Fr);
+	UNPACK_S(Fn, FPUL);
+	FP_CONV(D, S, 2, 1, Fr, Fn);
+	PACK_D(DRn, Fr);
+	return 0;
+}
+
+static int fcnvds(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_D(Fn);
+	FP_DECL_S(Fr);
+	UNPACK_D(Fn, DRn);
+	FP_CONV(S, D, 1, 2, Fr, Fn);
+	PACK_S(FPUL, Fr);
+	return 0;
+}
+
+static int fxchg(struct sh_fpu_soft_struct *fregs, int flag)
+{
+	FPSCR ^= flag;
+	return 0;
+}
+
+static int fsts(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = FPUL;
+	return 0;
+}
+
+static int flds(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FPUL = FRn;
+	return 0;
+}
+
+static int fneg(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn ^= (1 << (_FP_W_TYPE_SIZE - 1));
+	return 0;
+}
+
+static int fabs(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn &= ~(1 << (_FP_W_TYPE_SIZE - 1));
+	return 0;
+}
+
+static int fld0(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = 0;
+	return 0;
+}
+
+static int fld1(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = (_FP_EXPBIAS_S << (_FP_FRACBITS_S - 1));
+	return 0;
+}
+
+static int fnop_n(struct sh_fpu_soft_struct *fregs, int n)
+{
+	return -EINVAL;
+}
+
+/// Instruction decoders.
+
+static int id_fxfd(struct sh_fpu_soft_struct *, int);
+static int id_fnxd(struct sh_fpu_soft_struct *, struct pt_regs *, int, int);
+
+static int (*fnxd[])(struct sh_fpu_soft_struct *, int) = {
+	fsts, flds, ffloat, ftrc, fneg, fabs, fsqrt, fsrra,
+	fld0, fld1, fcnvsd, fcnvds, fnop_n, fnop_n, fipr, id_fxfd
+};
+
+static int (*fnmx[])(struct sh_fpu_soft_struct *, struct pt_regs *, int, int) = {
+	fadd, fsub, fmul, fdiv, fcmp_eq, fcmp_gt, fmov_idx_reg, fmov_reg_idx,
+	fmov_mem_reg, fmov_inc_reg, fmov_reg_mem, fmov_reg_dec,
+	fmov_reg_reg, id_fnxd, fmac, fnop_mn};
+
+static int id_fxfd(struct sh_fpu_soft_struct *fregs, int x)
+{
+	const int flag[] = { FPSCR_SZ, FPSCR_PR, FPSCR_FR, 0 };
+	switch (x & 3) {
+	case 3:
+		fxchg(fregs, flag[x >> 2]);
+		break;
+	case 1:
+		ftrv(fregs, x - 1);
+		break;
+	default:
+		fsca(fregs, x);
+	}
+	return 0;
+}
+
+static int
+id_fnxd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int x, int n)
+{
+	return (fnxd[x])(fregs, n);
+}
+
+static int
+id_fnmx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
+{
+	int n = (code >> 8) & 0xf, m = (code >> 4) & 0xf, x = code & 0xf;
+	return (fnmx[x])(fregs, regs, m, n);
+}
+
+static int
+id_sys(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
+{
+	int n = ((code >> 8) & 0xf);
+	unsigned long *reg = (code & 0x0010) ? &FPUL : &FPSCR;
+
+	switch (code & 0xf0ff) {
+	case 0x005a:
+	case 0x006a:
+		Rn = *reg;
+		break;
+	case 0x405a:
+	case 0x406a:
+		*reg = Rn;
+		break;
+	case 0x4052:
+	case 0x4062:
+		Rn -= 4;
+		WRITE(*reg, Rn);
+		break;
+	case 0x4056:
+	case 0x4066:
+		READ(*reg, Rn);
+		Rn += 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_regs *regs)
+{
+	if ((code & 0xf000) == 0xf000)
+		return id_fnmx(fregs, regs, code);
+	else
+		return id_sys(fregs, regs, code);
+}
+
+/**
+ *	denormal_to_double - Given denormalized float number,
+ *	                     store double float
+ *
+ *	@fpu: Pointer to sh_fpu_hard structure
+ *	@n: Index to FP register
+ */
+static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
+{
+	unsigned long du, dl;
+	unsigned long x = fpu->fpul;
+	int exp = 1023 - 126;
+
+	if (x != 0 && (x & 0x7f800000) == 0) {
+		du = (x & 0x80000000);
+		while ((x & 0x00800000) == 0) {
+			x <<= 1;
+			exp--;
+		}
+		x &= 0x007fffff;
+		du |= (exp << 20) | (x >> 3);
+		dl = x << 29;
+
+		fpu->fp_regs[n] = du;
+		fpu->fp_regs[n+1] = dl;
+	}
+}
+
+/**
+ *	ieee_fpe_handler - Handle denormalized number exception
+ *
+ *	@regs: Pointer to register structure
+ *
+ *	Returns 1 when it's handled (should not cause exception).
+ */
+static int ieee_fpe_handler(struct pt_regs *regs)
+{
+	unsigned short insn = *(unsigned short *)regs->pc;
+	unsigned short finsn;
+	unsigned long nextpc;
+	int nib[4] = {
+		(insn >> 12) & 0xf,
+		(insn >> 8) & 0xf,
+		(insn >> 4) & 0xf,
+		insn & 0xf};
+
+	if (nib[0] == 0xb ||
+	    (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb)) /* bsr & jsr */
+		regs->pr = regs->pc + 4;
+  
+	if (nib[0] == 0xa || nib[0] == 0xb) { /* bra & bsr */
+		nextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xd) { /* bt/s */
+		if (regs->sr & 1)
+			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+		else
+			nextpc = regs->pc + 4;
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xf) { /* bf/s */
+		if (regs->sr & 1)
+			nextpc = regs->pc + 4;
+		else
+			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
+		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* jmp & jsr */
+		nextpc = regs->regs[nib[1]];
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
+		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* braf & bsrf */
+		nextpc = regs->pc + 4 + regs->regs[nib[1]];
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (insn == 0x000b) { /* rts */
+		nextpc = regs->pr;
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else {
+		nextpc = regs->pc + 2;
+		finsn = insn;
+	}
+
+	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
+		struct task_struct *tsk = current;
+
+		if ((tsk->thread.fpu.hard.fpscr & (1 << 17))) {
+			/* FPU error */
+			denormal_to_double (&tsk->thread.fpu.hard,
+					    (finsn >> 8) & 0xf);
+			tsk->thread.fpu.hard.fpscr &=
+				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
+			set_tsk_thread_flag(tsk, TIF_USEDFPU);
+		} else {
+			tsk->thread.trap_no = 11;
+			tsk->thread.error_code = 0;
+			force_sig(SIGFPE, tsk);
+		}
+
+		regs->pc = nextpc;
+		return 1;
+	}
+
+	return 0;
+}
+
+asmlinkage void do_fpu_error(unsigned long r4, unsigned long r5,
+			     unsigned long r6, unsigned long r7,
+			     struct pt_regs regs)
+{
+	struct task_struct *tsk = current;
+
+	if (ieee_fpe_handler (&regs))
+		return;
+
+	regs.pc += 2;
+	tsk->thread.trap_no = 11;
+	tsk->thread.error_code = 0;
+	force_sig(SIGFPE, tsk);
+}
+
+/**
+ * fpu_init - Initialize FPU registers
+ * @fpu: Pointer to software emulated FPU registers.
+ */
+static void fpu_init(struct sh_fpu_soft_struct *fpu)
+{
+	int i;
+
+	fpu->fpscr = FPSCR_INIT;
+	fpu->fpul = 0;
+
+	for (i = 0; i < 16; i++) {
+		fpu->fp_regs[i] = 0;
+		fpu->xfp_regs[i]= 0;
+	}
+}
+
+/**
+ * do_fpu_inst - Handle reserved instructions for FPU emulation
+ * @inst: instruction code.
+ * @regs: registers on stack.
+ */
+int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
+{
+	struct task_struct *tsk = current;
+	struct sh_fpu_soft_struct *fpu = &(tsk->thread.fpu.soft);
+
+	if (!test_tsk_thread_flag(tsk, TIF_USEDFPU)) {
+		/* initialize once. */
+		fpu_init(fpu);
+		set_tsk_thread_flag(tsk, TIF_USEDFPU);
+	}
+
+	return fpu_emulate(inst, fpu, regs);
+}
diff -Naur linux-2.6.17.8/arch/sh/math-emu/sfp-util.h linux-2.6.17.8-sh/arch/sh/math-emu/sfp-util.h
--- linux-2.6.17.8/arch/sh/math-emu/sfp-util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/math-emu/sfp-util.h	2006-08-23 13:29:27.861346000 +0100
@@ -0,0 +1,72 @@
+/*
+ * These are copied from glibc/stdlib/longlong.h
+ */
+
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {                                                                  \
+    UWtype __x;                                                         \
+    __x = (al) + (bl);                                                  \
+    (sh) = (ah) + (bh) + (__x < (al));                                  \
+    (sl) = __x;                                                         \
+  } while (0)
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {                                                                  \
+    UWtype __x;                                                         \
+    __x = (al) - (bl);                                                  \
+    (sh) = (ah) - (bh) - (__x > (al));                                  \
+    (sl) = __x;                                                         \
+  } while (0)
+
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("dmulu.l %2,%3\n\tsts    macl,%1\n\tsts  mach,%0"	\
+	: "=r" ((u32)(w1)), "=r" ((u32)(w0))	\
+	:  "r" ((u32)(u)),   "r" ((u32)(v))	\
+	: "macl", "mach")
+
+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
+
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    UWtype __d1, __d0, __q1, __q0;					\
+    UWtype __r1, __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __r1 = (n1) % __d1;							\
+    __q1 = (n1) / __d1;							\
+    __m = (UWtype) __q1 * __d0;						\
+    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\
+    if (__r1 < __m)							\
+      {									\
+	__q1--, __r1 += (d);						\
+	if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
+	  if (__r1 < __m)						\
+	    __q1--, __r1 += (d);					\
+      }									\
+    __r1 -= __m;							\
+									\
+    __r0 = __r1 % __d1;							\
+    __q0 = __r1 / __d1;							\
+    __m = (UWtype) __q0 * __d0;						\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (UWtype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+
+#define abort()	return 0
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+
diff -Naur linux-2.6.17.8/arch/sh/mm/cache-sh4.c linux-2.6.17.8-sh/arch/sh/mm/cache-sh4.c
--- linux-2.6.17.8/arch/sh/mm/cache-sh4.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/cache-sh4.c	2006-08-23 13:29:43.370714000 +0100
@@ -2,7 +2,7 @@
  * arch/sh/mm/cache-sh4.c
  *
  * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2001, 2002, 2003, 2004, 2005  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -26,26 +26,95 @@
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 
-extern void __flush_cache_4096_all(unsigned long start);
-static void __flush_cache_4096_all_ex(unsigned long start);
-extern void __flush_dcache_all(void);
-static void __flush_dcache_all_ex(void);
+static void __flush_dcache_segment_1way(unsigned long start,
+					unsigned long extent);
+static void __flush_dcache_segment_2way(unsigned long start,
+					unsigned long extent);
+static void __flush_dcache_segment_4way(unsigned long start,
+					unsigned long extent);
+
+static void __flush_cache_4096(unsigned long addr, unsigned long phys,
+			       unsigned long exec_offset);
+
+/*
+ * This is initialised here to ensure that it is not placed in the BSS.  If
+ * that were to happen, note that cache_init gets called before the BSS is
+ * cleared, so this would get nulled out which would be hopeless.
+ */
+static void (*__flush_dcache_segment_fn)(unsigned long, unsigned long) =
+	(void (*)(unsigned long, unsigned long))0xdeadbeef;
+
+static void compute_alias(struct cache_info *c)
+{
+	c->alias_mask = ((c->sets - 1) << c->entry_shift) & ~(PAGE_SIZE - 1);
+	c->n_aliases = (c->alias_mask >> PAGE_SHIFT) + 1;
+}
+
+static void __init emit_cache_params(void)
+{
+	printk("PVR=%08x CVR=%08x PRR=%08x\n",
+		ctrl_inl(CCN_PVR),
+		ctrl_inl(CCN_CVR),
+		ctrl_inl(CCN_PRR));
+	printk("I-cache : n_ways=%d n_sets=%d way_incr=%d\n",
+		cpu_data->icache.ways,
+		cpu_data->icache.sets,
+		cpu_data->icache.way_incr);
+	printk("I-cache : entry_mask=0x%08x alias_mask=0x%08x n_aliases=%d\n",
+		cpu_data->icache.entry_mask,
+		cpu_data->icache.alias_mask,
+		cpu_data->icache.n_aliases);
+	printk("D-cache : n_ways=%d n_sets=%d way_incr=%d\n",
+		cpu_data->dcache.ways,
+		cpu_data->dcache.sets,
+		cpu_data->dcache.way_incr);
+	printk("D-cache : entry_mask=0x%08x alias_mask=0x%08x n_aliases=%d\n",
+		cpu_data->dcache.entry_mask,
+		cpu_data->dcache.alias_mask,
+		cpu_data->dcache.n_aliases);
+
+	if (!__flush_dcache_segment_fn)
+		panic("unknown number of cache ways\n");
+}
 
 /*
  * SH-4 has virtually indexed and physically tagged cache.
  */
 
-struct semaphore p3map_sem[4];
+/* Worst case assumed to be 64k cache, direct-mapped i.e. 4 synonym bits. */
+#define MAX_P3_SEMAPHORES 16
+
+struct semaphore p3map_sem[MAX_P3_SEMAPHORES];
 
 void __init p3_cache_init(void)
 {
-	if (remap_area_pages(P3SEG, 0, PAGE_SIZE*4, _PAGE_CACHABLE))
+	int i;
+
+	compute_alias(&cpu_data->icache);
+	compute_alias(&cpu_data->dcache);
+
+	switch (cpu_data->dcache.ways) {
+	case 1:
+		__flush_dcache_segment_fn = __flush_dcache_segment_1way;
+		break;
+	case 2:
+		__flush_dcache_segment_fn = __flush_dcache_segment_2way;
+		break;
+	case 4:
+		__flush_dcache_segment_fn = __flush_dcache_segment_4way;
+		break;
+	default:
+		__flush_dcache_segment_fn = NULL;
+		break;
+	}
+
+	emit_cache_params();
+
+	if (remap_area_pages(P3SEG, 0, PAGE_SIZE * 4, _PAGE_CACHABLE))
 		panic("%s failed.", __FUNCTION__);
 
-	sema_init (&p3map_sem[0], 1);
-	sema_init (&p3map_sem[1], 1);
-	sema_init (&p3map_sem[2], 1);
-	sema_init (&p3map_sem[3], 1);
+	for (i = 0; i < cpu_data->dcache.n_aliases; i++)
+		sema_init(&p3map_sem[i], 1);
 }
 
 /*
@@ -90,7 +159,6 @@
 	}
 }
 
-
 /*
  * No write back please
  */
@@ -109,40 +177,6 @@
 	}
 }
 
-static void __flush_dcache_all_ex(void)
-{
-	unsigned long addr, end_addr, entry_offset;
-
-	end_addr = CACHE_OC_ADDRESS_ARRAY + (cpu_data->dcache.sets << cpu_data->dcache.entry_shift) * cpu_data->dcache.ways;
-	entry_offset = 1 << cpu_data->dcache.entry_shift;
-	for (addr = CACHE_OC_ADDRESS_ARRAY; addr < end_addr; addr += entry_offset) {
-		ctrl_outl(0, addr);
-	}
-}
-
-static void __flush_cache_4096_all_ex(unsigned long start)
-{
-	unsigned long addr, entry_offset;
-	int i;
-
-	entry_offset = 1 << cpu_data->dcache.entry_shift;
-	for (i = 0; i < cpu_data->dcache.ways; i++, start += cpu_data->dcache.way_incr) {
-		for (addr = CACHE_OC_ADDRESS_ARRAY + start;
-		     addr < CACHE_OC_ADDRESS_ARRAY + 4096 + start;
-		     addr += entry_offset) {
-			ctrl_outl(0, addr);
-		}
-	}
-}
-
-void flush_cache_4096_all(unsigned long start)
-{
-	if (cpu_data->dcache.ways == 1)
-		__flush_cache_4096_all(start);
-	else
-		__flush_cache_4096_all_ex(start);
-}
-
 /*
  * Write back the range of D-cache, and purge the I-cache.
  *
@@ -154,14 +188,14 @@
 }
 
 /*
- * Write back the D-cache and purge the I-cache for signal trampoline. 
+ * Write back the D-cache and purge the I-cache for signal trampoline.
  * .. which happens to be the same behavior as flush_icache_range().
  * So, we simply flush out a line.
  */
 void flush_cache_sigtramp(unsigned long addr)
 {
 	unsigned long v, index;
-	unsigned long flags; 
+	unsigned long flags;
 	int i;
 
 	v = addr & ~(L1_CACHE_BYTES-1);
@@ -173,29 +207,34 @@
 
 	local_irq_save(flags);
 	jump_to_P2();
-	for(i = 0; i < cpu_data->icache.ways; i++, index += cpu_data->icache.way_incr)
+
+	for (i = 0; i < cpu_data->icache.ways;
+	     i++, index += cpu_data->icache.way_incr)
 		ctrl_outl(0, index);	/* Clear out Valid-bit */
+
 	back_to_P1();
+	wmb();
 	local_irq_restore(flags);
 }
 
 static inline void flush_cache_4096(unsigned long start,
 				    unsigned long phys)
 {
-	unsigned long flags; 
-	extern void __flush_cache_4096(unsigned long addr, unsigned long phys, unsigned long exec_offset);
+	unsigned long flags;
 
 	/*
-	 * SH7751, SH7751R, and ST40 have no restriction to handle cache.
-	 * (While SH7750 must do that at P2 area.)
+	 * All types of SH-4 require PC to be in P2 to operate on the I-cache.
+	 * Some types of SH-4 require PC to be in P2 to operate on the D-cache.
 	 */
 	if ((cpu_data->flags & CPU_HAS_P2_FLUSH_BUG)
 	   || start < CACHE_OC_ADDRESS_ARRAY) {
 		local_irq_save(flags);
-		__flush_cache_4096(start | SH_CACHE_ASSOC, P1SEGADDR(phys), 0x20000000);
+		__flush_cache_4096(start | SH_CACHE_ASSOC,
+				   P1SEGADDR(phys), 0x20000000);
 		local_irq_restore(flags);
 	} else {
-		__flush_cache_4096(start | SH_CACHE_ASSOC, P1SEGADDR(phys), 0);
+		__flush_cache_4096(start | SH_CACHE_ASSOC,
+				   P1SEGADDR(phys), 0);
 	}
 }
 
@@ -207,13 +246,16 @@
 {
 	if (test_bit(PG_mapped, &page->flags)) {
 		unsigned long phys = PHYSADDR(page_address(page));
+		unsigned long addr = CACHE_OC_ADDRESS_ARRAY;
+		int i, n;
 
 		/* Loop all the D-cache */
-		flush_cache_4096(CACHE_OC_ADDRESS_ARRAY,          phys);
-		flush_cache_4096(CACHE_OC_ADDRESS_ARRAY | 0x1000, phys);
-		flush_cache_4096(CACHE_OC_ADDRESS_ARRAY | 0x2000, phys);
-		flush_cache_4096(CACHE_OC_ADDRESS_ARRAY | 0x3000, phys);
+		n = cpu_data->dcache.n_aliases;
+		for (i = 0; i < n; i++, addr += PAGE_SIZE)
+			flush_cache_4096(addr, phys);
 	}
+
+	wmb();
 }
 
 static inline void flush_icache_all(void)
@@ -228,32 +270,38 @@
 	ccr |= CCR_CACHE_ICI;
 	ctrl_outl(ccr, CCR);
 
+	/*
+	 * back_to_P1() will take care of the barrier for us, don't add
+	 * another one!
+	 */
+
 	back_to_P1();
 	local_irq_restore(flags);
 }
 
+void flush_dcache_all(void)
+{
+	(*__flush_dcache_segment_fn)(0UL, cpu_data->dcache.way_size);
+	wmb();
+}
+
 void flush_cache_all(void)
 {
-	if (cpu_data->dcache.ways == 1)
-		__flush_dcache_all();
-	else
-		__flush_dcache_all_ex();
+	flush_dcache_all();
 	flush_icache_all();
 }
 
 void flush_cache_mm(struct mm_struct *mm)
 {
-	/* Is there any good way? */
-	/* XXX: possibly call flush_cache_range for each vm area */
-	/* 
-	 * FIXME: Really, the optimal solution here would be able to flush out
-	 * individual lines created by the specified context, but this isn't
-	 * feasible for a number of architectures (such as MIPS, and some
-	 * SPARC) .. is this possible for SuperH?
-	 *
-	 * In the meantime, we'll just flush all of the caches.. this
-	 * seems to be the simplest way to avoid at least a few wasted
-	 * cache flushes. -Lethal
+	/*
+	 * Note : (RPC) since the caches are physically tagged, the only point
+	 * of flush_cache_mm for SH-4 is to get rid of aliases from the
+	 * D-cache.  The assumption elsewhere, e.g. flush_cache_range, is that
+	 * lines can stay resident so long as the virtual address they were
+	 * accessed with (hence cache set) is in accord with the physical
+	 * address (i.e. tag).  It's no different here.  So I reckon we don't
+	 * need to flush the I-cache, since aliases don't matter for that.  We
+	 * should try that.
 	 */
 	flush_cache_all();
 }
@@ -267,24 +315,36 @@
 void flush_cache_page(struct vm_area_struct *vma, unsigned long address, unsigned long pfn)
 {
 	unsigned long phys = pfn << PAGE_SHIFT;
+	unsigned int alias_mask;
+
+	alias_mask = cpu_data->dcache.alias_mask;
 
 	/* We only need to flush D-cache when we have alias */
-	if ((address^phys) & CACHE_ALIAS) {
+	if ((address^phys) & alias_mask) {
 		/* Loop 4K of the D-cache */
 		flush_cache_4096(
-			CACHE_OC_ADDRESS_ARRAY | (address & CACHE_ALIAS),
+			CACHE_OC_ADDRESS_ARRAY | (address & alias_mask),
 			phys);
 		/* Loop another 4K of the D-cache */
 		flush_cache_4096(
-			CACHE_OC_ADDRESS_ARRAY | (phys & CACHE_ALIAS),
+			CACHE_OC_ADDRESS_ARRAY | (phys & alias_mask),
 			phys);
 	}
 
-	if (vma->vm_flags & VM_EXEC)
-		/* Loop 4K (half) of the I-cache */
+	alias_mask = cpu_data->icache.alias_mask;
+	if (vma->vm_flags & VM_EXEC) {
+		/*
+		 * Evict entries from the portion of the cache from which code
+		 * may have been executed at this address (virtual).  There's
+		 * no need to evict from the portion corresponding to the
+		 * physical address as for the D-cache, because we know the
+		 * kernel has never executed the code through its identity
+		 * translation.
+		 */
 		flush_cache_4096(
-			CACHE_IC_ADDRESS_ARRAY | (address & 0x1000),
+			CACHE_IC_ADDRESS_ARRAY | (address & alias_mask),
 			phys);
+	}
 }
 
 /*
@@ -299,52 +359,96 @@
 void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
 		       unsigned long end)
 {
-	unsigned long p = start & PAGE_MASK;
+	unsigned long d = 0, p = start & PAGE_MASK;
+	unsigned long alias_mask = cpu_data->dcache.alias_mask;
+	unsigned long n_aliases = cpu_data->dcache.n_aliases;
+	unsigned long select_bit;
+	unsigned long all_aliases_mask;
+	unsigned long addr_offset;
+	unsigned long phys;
 	pgd_t *dir;
 	pmd_t *pmd;
+	pud_t *pud;
 	pte_t *pte;
 	pte_t entry;
-	unsigned long phys;
-	unsigned long d = 0;
+	int i;
+
+	/*
+	 * If cache is only 4k-per-way, there are never any 'aliases'.  Since
+	 * the cache is physically tagged, the data can just be left in there.
+	 */
+	if (n_aliases == 0)
+		return;
+
+	all_aliases_mask = (1 << n_aliases) - 1;
+
+	/*
+	 * Don't bother with the lookup and alias check if we have a
+	 * wide range to cover, just blow away the dcache in its
+	 * entirety instead. -- PFM.
+	 */
+	if (((end - start) >> PAGE_SHIFT) >= 64) {
+		flush_dcache_all();
+
+		if (vma->vm_flags & VM_EXEC)
+			flush_icache_all();
+
+		return;
+	}
 
 	dir = pgd_offset(vma->vm_mm, p);
-	pmd = pmd_offset(dir, p);
+	pud = pud_offset(dir, p);
+	pmd = pmd_offset(pud, p);
+	end = PAGE_ALIGN(end);
 
 	do {
 		if (pmd_none(*pmd) || pmd_bad(*pmd)) {
-			p &= ~((1 << PMD_SHIFT) -1);
+			p &= ~((1 << PMD_SHIFT) - 1);
 			p += (1 << PMD_SHIFT);
 			pmd++;
+
 			continue;
 		}
+
 		pte = pte_offset_kernel(pmd, p);
+
 		do {
 			entry = *pte;
+
 			if ((pte_val(entry) & _PAGE_PRESENT)) {
-				phys = pte_val(entry)&PTE_PHYS_MASK;
-				if ((p^phys) & CACHE_ALIAS) {
-					d |= 1 << ((p & CACHE_ALIAS)>>12); 
-					d |= 1 << ((phys & CACHE_ALIAS)>>12);
-					if (d == 0x0f)
+				phys = pte_val(entry) & PTE_PHYS_MASK;
+
+				if ((p ^ phys) & alias_mask) {
+					d |= 1 << ((p & alias_mask) >> PAGE_SHIFT);
+					d |= 1 << ((phys & alias_mask) >> PAGE_SHIFT);
+
+					if (d == all_aliases_mask)
 						goto loop_exit;
 				}
 			}
+
 			pte++;
 			p += PAGE_SIZE;
 		} while (p < end && ((unsigned long)pte & ~PAGE_MASK));
 		pmd++;
 	} while (p < end);
- loop_exit:
-	if (d & 1)
-		flush_cache_4096_all(0);
-	if (d & 2)
-		flush_cache_4096_all(0x1000);
-	if (d & 4)
-		flush_cache_4096_all(0x2000);
-	if (d & 8)
-		flush_cache_4096_all(0x3000);
-	if (vma->vm_flags & VM_EXEC)
+
+loop_exit:
+	for (i = 0, select_bit = 0x1, addr_offset = 0x0; i < n_aliases;
+	     i++, select_bit <<= 1, addr_offset += PAGE_SIZE)
+		if (d & select_bit) {
+			(*__flush_dcache_segment_fn)(addr_offset, PAGE_SIZE);
+			wmb();
+		}
+
+	if (vma->vm_flags & VM_EXEC) {
+		/*
+		 * TODO: Is this required???  Need to look at how I-cache
+		 * coherency is assured when new programs are loaded to see if
+		 * this matters.
+		 */
 		flush_icache_all();
+	}
 }
 
 /*
@@ -358,5 +462,285 @@
 			     struct page *page, unsigned long addr, int len)
 {
 	flush_cache_page(vma, addr, page_to_pfn(page));
+	mb();
+}
+
+/**
+ * __flush_cache_4096
+ *
+ * @addr:  address in memory mapped cache array
+ * @phys:  P1 address to flush (has to match tags if addr has 'A' bit
+ *         set i.e. associative write)
+ * @exec_offset: set to 0x20000000 if flush has to be executed from P2
+ *               region else 0x0
+ *
+ * The offset into the cache array implied by 'addr' selects the
+ * 'colour' of the virtual address range that will be flushed.  The
+ * operation (purge/write-back) is selected by the lower 2 bits of
+ * 'phys'.
+ */
+static void __flush_cache_4096(unsigned long addr, unsigned long phys,
+			       unsigned long exec_offset)
+{
+	int way_count;
+	unsigned long base_addr = addr;
+	struct cache_info *dcache;
+	unsigned long way_incr;
+	unsigned long a, ea, p;
+	unsigned long temp_pc;
+
+	dcache = &cpu_data->dcache;
+	/* Write this way for better assembly. */
+	way_count = dcache->ways;
+	way_incr = dcache->way_incr;
+
+	/*
+	 * Apply exec_offset (i.e. branch to P2 if required.).
+	 *
+	 * FIXME:
+	 *
+	 *	If I write "=r" for the (temp_pc), it puts this in r6 hence
+	 *	trashing exec_offset before it's been added on - why?  Hence
+	 *	"=&r" as a 'workaround'
+	 */
+	asm volatile("mov.l 1f, %0\n\t"
+		     "add   %1, %0\n\t"
+		     "jmp   @%0\n\t"
+		     "nop\n\t"
+		     ".balign 4\n\t"
+		     "1:  .long 2f\n\t"
+		     "2:\n" : "=&r" (temp_pc) : "r" (exec_offset));
+
+	/*
+	 * We know there will be >=1 iteration, so write as do-while to avoid
+	 * pointless nead-of-loop check for 0 iterations.
+	 */
+	do {
+		ea = base_addr + PAGE_SIZE;
+		a = base_addr;
+		p = phys;
+
+		do {
+			*(volatile unsigned long *)a = p;
+			/*
+			 * Next line: intentionally not p+32, saves an add, p
+			 * will do since only the cache tag bits need to
+			 * match.
+			 */
+			*(volatile unsigned long *)(a+32) = p;
+			a += 64;
+			p += 64;
+		} while (a < ea);
+
+		base_addr += way_incr;
+	} while (--way_count != 0);
+}
+
+/*
+ * Break the 1, 2 and 4 way variants of this out into separate functions to
+ * avoid nearly all the overhead of having the conditional stuff in the function
+ * bodies (+ the 1 and 2 way cases avoid saving any registers too).
+ *
+ * We want to eliminate unnecessary bus transactions, so this code uses
+ * a non-obvious technique.
+ *
+ * Loop over a cache way sized block of, one cache line at a time. For each
+ * line, use movca.a to cause the current cache line contents to be written
+ * back, but without reading anything from main memory. However this has the
+ * side effect that the cache is now caching that memory location. So follow
+ * this with a cache invalidate to mark the cache line invalid. And do all
+ * this with interrupts disabled, to avoid the cache line being accidently
+ * evicted while it is holding garbage.
+ */
+static void __flush_dcache_segment_1way(unsigned long start,
+					unsigned long extent_per_way)
+{
+	unsigned long orig_sr, sr_with_bl;
+	unsigned long base_addr;
+	unsigned long way_incr, linesz, way_size;
+	struct cache_info *dcache;
+	register unsigned long a0, a0e;
+
+	asm volatile("stc sr, %0" : "=r" (orig_sr));
+	sr_with_bl = orig_sr | (1<<28);
+	base_addr = ((unsigned long)&empty_zero_page[0]);
+
+	/*
+	 * The previous code aligned base_addr to 16k, i.e. the way_size of all
+	 * existing SH-4 D-caches.  Whilst I don't see a need to have this
+	 * aligned to any better than the cache line size (which it will be
+	 * anyway by construction), let's align it to at least the way_size of
+	 * any existing or conceivable SH-4 D-cache.  -- RPC
+	 */
+	base_addr = ((base_addr >> 16) << 16);
+	base_addr |= start;
+
+	dcache = &cpu_data->dcache;
+	linesz = dcache->linesz;
+	way_incr = dcache->way_incr;
+	way_size = dcache->way_size;
+
+	a0 = base_addr;
+	a0e = base_addr + extent_per_way;
+	do {
+		asm volatile("ldc %0, sr" : : "r" (sr_with_bl));
+		asm volatile("movca.l r0, @%0\n\t"
+			     "ocbi @%0" : : "r" (a0));
+		a0 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "ocbi @%0" : : "r" (a0));
+		a0 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "ocbi @%0" : : "r" (a0));
+		a0 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "ocbi @%0" : : "r" (a0));
+		asm volatile("ldc %0, sr" : : "r" (orig_sr));
+		a0 += linesz;
+	} while (a0 < a0e);
+}
+
+static void __flush_dcache_segment_2way(unsigned long start,
+					unsigned long extent_per_way)
+{
+	unsigned long orig_sr, sr_with_bl;
+	unsigned long base_addr;
+	unsigned long way_incr, linesz, way_size;
+	struct cache_info *dcache;
+	register unsigned long a0, a1, a0e;
+
+	asm volatile("stc sr, %0" : "=r" (orig_sr));
+	sr_with_bl = orig_sr | (1<<28);
+	base_addr = ((unsigned long)&empty_zero_page[0]);
+
+	/* See comment under 1-way above */
+	base_addr = ((base_addr >> 16) << 16);
+	base_addr |= start;
+
+	dcache = &cpu_data->dcache;
+	linesz = dcache->linesz;
+	way_incr = dcache->way_incr;
+	way_size = dcache->way_size;
+
+	a0 = base_addr;
+	a1 = a0 + way_incr;
+	a0e = base_addr + extent_per_way;
+	do {
+		asm volatile("ldc %0, sr" : : "r" (sr_with_bl));
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1" : :
+			     "r" (a0), "r" (a1));
+		a0 += linesz;
+		a1 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1" : :
+			     "r" (a0), "r" (a1));
+		a0 += linesz;
+		a1 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1" : :
+			     "r" (a0), "r" (a1));
+		a0 += linesz;
+		a1 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1" : :
+			     "r" (a0), "r" (a1));
+		asm volatile("ldc %0, sr" : : "r" (orig_sr));
+		a0 += linesz;
+		a1 += linesz;
+	} while (a0 < a0e);
+}
+
+static void __flush_dcache_segment_4way(unsigned long start,
+					unsigned long extent_per_way)
+{
+	unsigned long orig_sr, sr_with_bl;
+	unsigned long base_addr;
+	unsigned long way_incr, linesz, way_size;
+	struct cache_info *dcache;
+	register unsigned long a0, a1, a2, a3, a0e;
+
+	asm volatile("stc sr, %0" : "=r" (orig_sr));
+	sr_with_bl = orig_sr | (1<<28);
+	base_addr = ((unsigned long)&empty_zero_page[0]);
+
+	/* See comment under 1-way above */
+	base_addr = ((base_addr >> 16) << 16);
+	base_addr |= start;
+
+	dcache = &cpu_data->dcache;
+	linesz = dcache->linesz;
+	way_incr = dcache->way_incr;
+	way_size = dcache->way_size;
+
+	a0 = base_addr;
+	a1 = a0 + way_incr;
+	a2 = a1 + way_incr;
+	a3 = a2 + way_incr;
+	a0e = base_addr + extent_per_way;
+	do {
+		asm volatile("ldc %0, sr" : : "r" (sr_with_bl));
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "movca.l r0, @%2\n\t"
+			     "movca.l r0, @%3\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1\n\t"
+			     "ocbi @%2\n\t"
+			     "ocbi @%3\n\t" : :
+			     "r" (a0), "r" (a1), "r" (a2), "r" (a3));
+		a0 += linesz;
+		a1 += linesz;
+		a2 += linesz;
+		a3 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "movca.l r0, @%2\n\t"
+			     "movca.l r0, @%3\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1\n\t"
+			     "ocbi @%2\n\t"
+			     "ocbi @%3\n\t" : :
+			     "r" (a0), "r" (a1), "r" (a2), "r" (a3));
+		a0 += linesz;
+		a1 += linesz;
+		a2 += linesz;
+		a3 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "movca.l r0, @%2\n\t"
+			     "movca.l r0, @%3\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1\n\t"
+			     "ocbi @%2\n\t"
+			     "ocbi @%3\n\t" : :
+			     "r" (a0), "r" (a1), "r" (a2), "r" (a3));
+		a0 += linesz;
+		a1 += linesz;
+		a2 += linesz;
+		a3 += linesz;
+		asm volatile("movca.l r0, @%0\n\t"
+			     "movca.l r0, @%1\n\t"
+			     "movca.l r0, @%2\n\t"
+			     "movca.l r0, @%3\n\t"
+			     "ocbi @%0\n\t"
+			     "ocbi @%1\n\t"
+			     "ocbi @%2\n\t"
+			     "ocbi @%3\n\t" : :
+			     "r" (a0), "r" (a1), "r" (a2), "r" (a3));
+		asm volatile("ldc %0, sr" : : "r" (orig_sr));
+		a0 += linesz;
+		a1 += linesz;
+		a2 += linesz;
+		a3 += linesz;
+	} while (a0 < a0e);
 }
 
diff -Naur linux-2.6.17.8/arch/sh/mm/clear_page.S linux-2.6.17.8-sh/arch/sh/mm/clear_page.S
--- linux-2.6.17.8/arch/sh/mm/clear_page.S	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/clear_page.S	2006-08-23 13:29:12.944001000 +0100
@@ -194,102 +194,5 @@
 	 nop
 .L4096:	.word	4096
 
-ENTRY(__flush_cache_4096)
-	mov.l	1f,r3
-	add	r6,r3
-	mov	r4,r0
-	mov	#64,r2
-	shll	r2
-	mov	#64,r6
-	jmp	@r3
-	 mov	#96,r7
-	.align	2
-1:	.long	2f
-2:
-	.rept	32
-	mov.l	r5,@r0
-	mov.l	r5,@(32,r0)
-	mov.l	r5,@(r0,r6)
-	mov.l	r5,@(r0,r7)
-	add	r2,r5
-	add	r2,r0
-	.endr
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	rts
-	 nop
-
-ENTRY(__flush_dcache_all)
-	mov.l	2f,r0
-	mov.l	3f,r4
-	and	r0,r4		! r4 = (unsigned long)&empty_zero_page[0] & ~0xffffc000
-	stc	sr,r1		! save SR
-	mov.l	4f,r2
-	or	r1,r2
-	mov	#32,r3
-	shll2	r3
-1:
-	ldc	r2,sr		! set BL bit
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	ldc	r1,sr		! restore SR
-	dt	r3
-	bf/s	1b
-	 add	#32,r4
-
-	rts
-	 nop
-	.align	2
-2:	.long	0xffffc000
-3:	.long	empty_zero_page
-4:	.long	0x10000000	! BL bit
-
-/* __flush_cache_4096_all(unsigned long addr) */
-ENTRY(__flush_cache_4096_all)
-	mov.l	2f,r0
-	mov.l	3f,r2
-	and	r0,r2
-	or	r2,r4		! r4 = addr | (unsigned long)&empty_zero_page[0] & ~0x3fff
-	stc	sr,r1		! save SR
-	mov.l	4f,r2
-	or	r1,r2
-	mov	#32,r3
-1:
-	ldc	r2,sr		! set BL bit
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	add	#32,r4
-	movca.l	r0,@r4
-	ocbi	@r4
-	ldc	r1,sr		! restore SR
-	dt	r3
-	bf/s	1b
-	 add	#32,r4
-
-	rts
-	 nop
-	.align	2
-2:	.long	0xffffc000
-3:	.long	empty_zero_page
-4:	.long	0x10000000	! BL bit
 #endif
+
diff -Naur linux-2.6.17.8/arch/sh/mm/consistent.c linux-2.6.17.8-sh/arch/sh/mm/consistent.c
--- linux-2.6.17.8/arch/sh/mm/consistent.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/consistent.c	2006-08-23 13:29:17.061094000 +0100
@@ -9,6 +9,8 @@
  */
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#include <asm/cacheflush.h>
+#include <asm/addrspace.h>
 #include <asm/io.h>
 
 void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *handle)
diff -Naur linux-2.6.17.8/arch/sh/mm/fault.c linux-2.6.17.8-sh/arch/sh/mm/fault.c
--- linux-2.6.17.8/arch/sh/mm/fault.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/fault.c	2006-08-23 13:29:25.721302000 +0100
@@ -1,33 +1,21 @@
-/* $Id: fault.c,v 1.14 2004/01/13 05:52:11 kkojima Exp $
+/*
+ * Page fault handler for SH with an MMU.
  *
- *  linux/arch/sh/mm/fault.c
  *  Copyright (C) 1999  Niibe Yutaka
  *  Copyright (C) 2003  Paul Mundt
  *
  *  Based on linux/arch/i386/mm/fault.c:
  *   Copyright (C) 1995  Linus Torvalds
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
-#include <linux/signal.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/ptrace.h>
-#include <linux/mman.h>
 #include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/smp_lock.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-
+#include <linux/hardirq.h>
 #include <asm/system.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
 #include <asm/kgdb.h>
 
 extern void die(const char *,struct pt_regs *,long);
@@ -187,14 +175,25 @@
 		goto no_context;
 }
 
+#ifdef CONFIG_SH_STORE_QUEUES
+/*
+ * This is a special case for the SH-4 store queues, as pages for this
+ * space still need to be faulted in before it's possible to flush the
+ * store queue cache for writeout to the remapped region.
+ */
+#define P3_ADDR_MAX		(P4SEG_STORE_QUE + 0x04000000)
+#else
+#define P3_ADDR_MAX		P4SEG
+#endif
+
 /*
- * Called with interrupt disabled.
+ * Called with interrupts disabled.
  */
 asmlinkage int __do_page_fault(struct pt_regs *regs, unsigned long writeaccess,
 			       unsigned long address)
 {
-	unsigned long addrmax = P4SEG;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	pte_t entry;
@@ -207,31 +206,37 @@
 		kgdb_bus_err_hook();
 #endif
 
-#ifdef CONFIG_SH_STORE_QUEUES
-	addrmax = P4SEG_STORE_QUE + 0x04000000;
-#endif
-
-	if (address >= P3SEG && address < addrmax) {
+	/*
+	 * We don't take page faults for P1, P2, and parts of P4, these
+	 * are always mapped, whether it be due to legacy behaviour in
+	 * 29-bit mode, or due to PMB configuration in 32-bit mode.
+	 */
+	if (address >= P3SEG && address < P3_ADDR_MAX) {
 		pgd = pgd_offset_k(address);
 		mm = NULL;
-	} else if (address >= TASK_SIZE)
-		return 1;
-	else if (!(mm = current->mm))
-		return 1;
-	else
-		pgd = pgd_offset(mm, address);
+	} else {
+		if (unlikely(address >= TASK_SIZE || !(mm = current->mm)))
+			return 1;
 
-	pmd = pmd_offset(pgd, address);
+		pgd = pgd_offset(current->mm, address);
+	}
+
+	pud = pud_offset(pgd, address);
+	if (pud_none_or_clear_bad(pud))
+		return 1;
+	pmd = pmd_offset(pud, address);
 	if (pmd_none_or_clear_bad(pmd))
 		return 1;
+
 	if (mm)
 		pte = pte_offset_map_lock(mm, pmd, address, &ptl);
 	else
 		pte = pte_offset_kernel(pmd, address);
 
 	entry = *pte;
-	if (pte_none(entry) || pte_not_present(entry)
-	    || (writeaccess && !pte_write(entry)))
+	if (unlikely(pte_none(entry) || pte_not_present(entry)))
+		goto unlock;
+	if (unlikely(writeaccess && !pte_write(entry)))
 		goto unlock;
 
 	if (writeaccess)
@@ -243,13 +248,7 @@
 	 * ITLB is not affected by "ldtlb" instruction.
 	 * So, we need to flush the entry by ourselves.
 	 */
-
-	{
-		unsigned long flags;
-		local_irq_save(flags);
-		__flush_tlb_page(get_asid(), address&PAGE_MASK);
-		local_irq_restore(flags);
-	}
+	__flush_tlb_page(get_asid(), address & PAGE_MASK);
 #endif
 
 	set_pte(pte, entry);
@@ -260,121 +259,3 @@
 		pte_unmap_unlock(pte, ptl);
 	return ret;
 }
-
-void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-	if (vma->vm_mm && vma->vm_mm->context != NO_CONTEXT) {
-		unsigned long flags;
-		unsigned long asid;
-		unsigned long saved_asid = MMU_NO_ASID;
-
-		asid = vma->vm_mm->context & MMU_CONTEXT_ASID_MASK;
-		page &= PAGE_MASK;
-
-		local_irq_save(flags);
-		if (vma->vm_mm != current->mm) {
-			saved_asid = get_asid();
-			set_asid(asid);
-		}
-		__flush_tlb_page(asid, page);
-		if (saved_asid != MMU_NO_ASID)
-			set_asid(saved_asid);
-		local_irq_restore(flags);
-	}
-}
-
-void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-		     unsigned long end)
-{
-	struct mm_struct *mm = vma->vm_mm;
-
-	if (mm->context != NO_CONTEXT) {
-		unsigned long flags;
-		int size;
-
-		local_irq_save(flags);
-		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-		if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
-			mm->context = NO_CONTEXT;
-			if (mm == current->mm)
-				activate_context(mm);
-		} else {
-			unsigned long asid = mm->context&MMU_CONTEXT_ASID_MASK;
-			unsigned long saved_asid = MMU_NO_ASID;
-
-			start &= PAGE_MASK;
-			end += (PAGE_SIZE - 1);
-			end &= PAGE_MASK;
-			if (mm != current->mm) {
-				saved_asid = get_asid();
-				set_asid(asid);
-			}
-			while (start < end) {
-				__flush_tlb_page(asid, start);
-				start += PAGE_SIZE;
-			}
-			if (saved_asid != MMU_NO_ASID)
-				set_asid(saved_asid);
-		}
-		local_irq_restore(flags);
-	}
-}
-
-void flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	unsigned long flags;
-	int size;
-
-	local_irq_save(flags);
-	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-	if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
-		flush_tlb_all();
-	} else {
-		unsigned long asid = init_mm.context&MMU_CONTEXT_ASID_MASK;
-		unsigned long saved_asid = get_asid();
-
-		start &= PAGE_MASK;
-		end += (PAGE_SIZE - 1);
-		end &= PAGE_MASK;
-		set_asid(asid);
-		while (start < end) {
-			__flush_tlb_page(asid, start);
-			start += PAGE_SIZE;
-		}
-		set_asid(saved_asid);
-	}
-	local_irq_restore(flags);
-}
-
-void flush_tlb_mm(struct mm_struct *mm)
-{
-	/* Invalidate all TLB of this process. */
-	/* Instead of invalidating each TLB, we get new MMU context. */
-	if (mm->context != NO_CONTEXT) {
-		unsigned long flags;
-
-		local_irq_save(flags);
-		mm->context = NO_CONTEXT;
-		if (mm == current->mm)
-			activate_context(mm);
-		local_irq_restore(flags);
-	}
-}
-
-void flush_tlb_all(void)
-{
-	unsigned long flags, status;
-
-	/*
-	 * Flush all the TLB.
-	 *
-	 * Write to the MMU control register's bit:
-	 * 	TF-bit for SH-3, TI-bit for SH-4.
-	 *      It's same position, bit #2.
-	 */
-	local_irq_save(flags);
-	status = ctrl_inl(MMUCR);
-	status |= 0x04;		
-	ctrl_outl(status, MMUCR);
-	local_irq_restore(flags);
-}
diff -Naur linux-2.6.17.8/arch/sh/mm/hugetlbpage.c linux-2.6.17.8-sh/arch/sh/mm/hugetlbpage.c
--- linux-2.6.17.8/arch/sh/mm/hugetlbpage.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/hugetlbpage.c	2006-08-23 13:29:13.226024000 +0100
@@ -27,61 +27,41 @@
 pte_t *huge_pte_alloc(struct mm_struct *mm, unsigned long addr)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte = NULL;
 
 	pgd = pgd_offset(mm, addr);
 	if (pgd) {
-		pmd = pmd_alloc(mm, pgd, addr);
-		if (pmd)
-			pte = pte_alloc_map(mm, pmd, addr);
+		pud = pud_alloc(mm, pgd, addr);
+		if (pud) {
+			pmd = pmd_alloc(mm, pud, addr);
+			if (pmd)
+				pte = pte_alloc_map(mm, pmd, addr);
+		}
 	}
+
 	return pte;
 }
 
 pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte = NULL;
 
 	pgd = pgd_offset(mm, addr);
 	if (pgd) {
-		pmd = pmd_offset(pgd, addr);
-		if (pmd)
-			pte = pte_offset_map(pmd, addr);
-	}
-	return pte;
-}
-
-void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,
-		     pte_t *ptep, pte_t entry)
-{
-	int i;
-
-	for (i = 0; i < (1 << HUGETLB_PAGE_ORDER); i++) {
-		set_pte_at(mm, addr, ptep, entry);
-		ptep++;
-		addr += PAGE_SIZE;
-		pte_val(entry) += PAGE_SIZE;
+		pud = pud_offset(pgd, addr);
+		if (pud) {
+			pmd = pmd_offset(pud, addr);
+			if (pmd)
+				pte = pte_offset_map(pmd, addr);
+		}
 	}
-}
-
-pte_t huge_ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,
-			      pte_t *ptep)
-{
-	pte_t entry;
-	int i;
-
-	entry = *ptep;
 
-	for (i = 0; i < (1 << HUGETLB_PAGE_ORDER); i++) {
-		pte_clear(mm, addr, ptep);
-		addr += PAGE_SIZE;
-		ptep++;
-	}
-
-	return entry;
+	return pte;
 }
 
 struct page *follow_huge_addr(struct mm_struct *mm,
diff -Naur linux-2.6.17.8/arch/sh/mm/init.c linux-2.6.17.8-sh/arch/sh/mm/init.c
--- linux-2.6.17.8/arch/sh/mm/init.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/init.c	2006-08-23 13:29:28.655369000 +0100
@@ -81,6 +81,7 @@
 static void set_pte_phys(unsigned long addr, unsigned long phys, pgprot_t prot)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 
@@ -90,7 +91,17 @@
 		return;
 	}
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	if (pud_none(*pud)) {
+		pmd = (pmd_t *)get_zeroed_page(GFP_ATOMIC);
+		set_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE | _PAGE_USER));
+		if (pmd != pmd_offset(pud, 0)) {
+			pud_ERROR(*pud);
+			return;
+		}
+	}
+
+	pmd = pmd_offset(pud, addr);
 	if (pmd_none(*pmd)) {
 		pte = (pte_t *)get_zeroed_page(GFP_ATOMIC);
 		set_pmd(pmd, __pmd(__pa(pte) | _KERNPG_TABLE | _PAGE_USER));
@@ -238,8 +249,13 @@
 	 * Setup wrappers for copy/clear_page(), these will get overridden
 	 * later in the boot process if a better method is available.
 	 */
+#ifdef CONFIG_MMU
 	copy_page = copy_page_slow;
 	clear_page = clear_page_slow;
+#else
+	copy_page = copy_page_nommu;
+	clear_page = clear_page_nommu;
+#endif
 
 	/* this will put all low memory onto the freelists */
 	totalram_pages += free_all_bootmem_node(NODE_DATA(0));
diff -Naur linux-2.6.17.8/arch/sh/mm/ioremap.c linux-2.6.17.8-sh/arch/sh/mm/ioremap.c
--- linux-2.6.17.8/arch/sh/mm/ioremap.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/ioremap.c	2006-08-23 13:29:51.565900000 +0100
@@ -15,6 +15,7 @@
 #include <linux/vmalloc.h>
 #include <linux/module.h>
 #include <linux/mm.h>
+#include <linux/pci.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #include <asm/pgalloc.h>
@@ -128,17 +129,46 @@
 	if (!size || last_addr < phys_addr)
 		return NULL;
 
+#if 0
+	/* SIM: I don't know which SH platforms have this arrangement,
+	 * but none of the ST40 based ones do.
+	 * Its also irreleant, as ioremap() will already have remapped it
+	 * (incorrectly!)
+	 */
+
 	/*
 	 * Don't remap the low PCI/ISA area, it's always mapped..
 	 */
 	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
 		return (void __iomem *)phys_to_virt(phys_addr);
+#endif
+
+	/*
+	 * If we're on an SH7751 or SH7780 PCI controller, PCI memory is
+	 * mapped at the end of the address space (typically 0xfd000000)
+	 * in a non-translatable area, so mapping through page tables for
+	 * this area is not only pointless, but also fundamentally
+	 * broken. Just return the physical address instead.
+	 *
+	 * For boards that map a small PCI memory aperture somewhere in
+	 * P1/P2 space, ioremap() will already do the right thing,
+	 * and we'll never get this far.
+	 */
+	if (is_pci_memaddr(phys_addr) && is_pci_memaddr(last_addr))
+		return (void __iomem *)phys_addr;
+
+#if 0
+	/*
+	 * SIM: This check will never fail, as ioremap() will already have
+	 * remapped this this using P1 or P2.
+	 */
 
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
 	 */
 	if (phys_addr < virt_to_phys(high_memory))
 		return NULL;
+#endif
 
 	/*
 	 * Mappings have to be page-aligned
@@ -192,7 +222,7 @@
 	unsigned long vaddr = (unsigned long __force)addr;
 	struct vm_struct *p;
 
-	if (PXSEG(vaddr) < P3SEG)
+	if (PXSEG(vaddr) < P3SEG || is_pci_memaddr(vaddr))
 		return;
 
 #ifdef CONFIG_32BIT
diff -Naur linux-2.6.17.8/arch/sh/mm/Kconfig linux-2.6.17.8-sh/arch/sh/mm/Kconfig
--- linux-2.6.17.8/arch/sh/mm/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/Kconfig	2006-08-23 13:29:42.146668000 +0100
@@ -20,7 +20,6 @@
 config CPU_SH4A
 	bool
 	select CPU_SH4
-	select CPU_HAS_INTC2_IRQ
 
 config CPU_SUBTYPE_ST40
 	bool
@@ -131,6 +130,24 @@
 	help
 	  Select ST40GX1 if you have a ST40GX1 CPU.
 
+config CPU_SUBTYPE_STI5528
+	bool "Support STi5528 processor"
+	select CPU_SUBTYPE_ST40
+	help
+	  Select STI5528 if you have an STi5528 CPU.
+
+config CPU_SUBTYPE_STM8000
+	bool "Support STm8000 processor"
+	select CPU_SUBTYPE_ST40
+	help
+	  Select STM8000 if you have an STm8000 CPU.
+
+config CPU_SUBTYPE_STB7100
+	bool "STb710x"
+	select CPU_SUBTYPE_ST40
+	help
+	  Select STB7100 if you have an STb7100 CPU.
+
 comment "SH-4A Processor Support"
 
 config CPU_SUBTYPE_SH73180
@@ -144,6 +161,7 @@
 config CPU_SUBTYPE_SH7780
 	bool "Support SH7780 processor"
 	select CPU_SH4A
+	select CPU_HAS_INTC2_IRQ
 
 endmenu
 
@@ -161,6 +179,37 @@
 	  turning this off will boot the kernel on these machines with the
 	  MMU implicitly switched off.
 
+config PAGE_OFFSET
+	hex
+	default "0x80000000" if MMU
+	default "0x00000000"
+
+config MEMORY_START
+	hex "Physical memory start address"
+	default "0x08000000"
+	---help---
+	  Computers built with Hitachi SuperH processors always
+	  map the ROM starting at address zero.  But the processor
+	  does not specify the range that RAM takes.
+
+	  The physical memory (RAM) start address will be automatically
+	  set to 08000000. Other platforms, such as the Solution Engine
+	  boards typically map RAM at 0C000000.
+
+	  Tweak this only when porting to a new machine which does not
+	  already have a defconfig. Changing it from the known correct
+	  value on any of the known systems will only lead to disaster.
+
+config MEMORY_SIZE
+	hex "Physical memory size" 
+	default "0x00400000"
+	help
+	  This sets the default memory size assumed by your SH kernel. It can
+	  be overridden as normal by the 'mem=' argument on the kernel command
+	  line. If unsure, consult your board specifications or just leave it
+	  as 0x00400000 which was the default value before this became
+	  configurable.
+
 config 32BIT
 	bool "Support 32-bit physical addressing through PMB"
 	depends on CPU_SH4A
diff -Naur linux-2.6.17.8/arch/sh/mm/Makefile linux-2.6.17.8-sh/arch/sh/mm/Makefile
--- linux-2.6.17.8/arch/sh/mm/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/Makefile	2006-08-23 13:29:17.665116000 +0100
@@ -12,14 +12,16 @@
 obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
 
 mmu-y			:= fault-nommu.o tlb-nommu.o pg-nommu.o
-mmu-$(CONFIG_MMU)	:= fault.o clear_page.o copy_page.o
+mmu-$(CONFIG_MMU)	:= fault.o clear_page.o copy_page.o tlb-flush.o	\
+			   ioremap.o
 
 obj-y			+= $(mmu-y)
 
 ifdef CONFIG_MMU
-obj-$(CONFIG_CPU_SH3)	+= tlb-sh3.o
-obj-$(CONFIG_CPU_SH4)	+= tlb-sh4.o ioremap.o
+obj-$(CONFIG_CPU_SH3)		+= tlb-sh3.o
+obj-$(CONFIG_CPU_SH4)		+= tlb-sh4.o
 obj-$(CONFIG_SH7705_CACHE_32KB) += pg-sh7705.o
 endif
 
-obj-$(CONFIG_SH7705_CACHE_32KB) += cache-sh7705.o
+obj-$(CONFIG_SH7705_CACHE_32KB)	+= cache-sh7705.o
+obj-$(CONFIG_32BIT)		+= pmb.o
diff -Naur linux-2.6.17.8/arch/sh/mm/pg-nommu.c linux-2.6.17.8-sh/arch/sh/mm/pg-nommu.c
--- linux-2.6.17.8/arch/sh/mm/pg-nommu.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/pg-nommu.c	2006-08-23 13:29:28.683369000 +0100
@@ -14,23 +14,24 @@
 #include <linux/string.h>
 #include <asm/page.h>
 
-static void copy_page_nommu(void *to, void *from)
+void copy_page_nommu(void *to, void *from)
 {
 	memcpy(to, from, PAGE_SIZE);
 }
 
-static void clear_page_nommu(void *to)
+void clear_page_nommu(void *to)
 {
 	memset(to, 0, PAGE_SIZE);
 }
 
-static int __init pg_nommu_init(void)
+__kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n)
 {
-	copy_page = copy_page_nommu;
-	clear_page = clear_page_nommu;
-
+	memcpy(to, from, n);
 	return 0;
 }
 
-subsys_initcall(pg_nommu_init);
-
+__kernel_size_t __clear_user(void *to, __kernel_size_t n)
+{
+	memset(to, 0, n);
+	return 0;
+}
diff -Naur linux-2.6.17.8/arch/sh/mm/pg-sh4.c linux-2.6.17.8-sh/arch/sh/mm/pg-sh4.c
--- linux-2.6.17.8/arch/sh/mm/pg-sh4.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/pg-sh4.c	2006-08-23 13:29:14.259047000 +0100
@@ -2,7 +2,7 @@
  * arch/sh/mm/pg-sh4.c
  *
  * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2002  Paul Mundt
+ * Copyright (C) 2002 - 2005  Paul Mundt
  *
  * Released under the terms of the GNU GPL v2.0.
  */
@@ -24,6 +24,8 @@
 
 extern struct semaphore p3map_sem[];
 
+#define CACHE_ALIAS (cpu_data->dcache.alias_mask)
+
 /*
  * clear_user_page
  * @to: P1 address
@@ -36,14 +38,15 @@
 	if (((address ^ (unsigned long)to) & CACHE_ALIAS) == 0)
 		clear_page(to);
 	else {
-		pgprot_t pgprot = __pgprot(_PAGE_PRESENT | 
+		pgprot_t pgprot = __pgprot(_PAGE_PRESENT |
 					   _PAGE_RW | _PAGE_CACHABLE |
-					   _PAGE_DIRTY | _PAGE_ACCESSED | 
+					   _PAGE_DIRTY | _PAGE_ACCESSED |
 					   _PAGE_HW_SHARED | _PAGE_FLAGS_HARD);
 		unsigned long phys_addr = PHYSADDR(to);
 		unsigned long p3_addr = P3SEG + (address & CACHE_ALIAS);
-		pgd_t *dir = pgd_offset_k(p3_addr);
-		pmd_t *pmd = pmd_offset(dir, p3_addr);
+		pgd_t *pgd = pgd_offset_k(p3_addr);
+		pud_t *pud = pud_offset(pgd, p3_addr);
+		pmd_t *pmd = pmd_offset(pud, p3_addr);
 		pte_t *pte = pte_offset_kernel(pmd, p3_addr);
 		pte_t entry;
 		unsigned long flags;
@@ -68,21 +71,22 @@
  * @address: U0 address to be mapped
  * @page: page (virt_to_page(to))
  */
-void copy_user_page(void *to, void *from, unsigned long address, 
+void copy_user_page(void *to, void *from, unsigned long address,
 		    struct page *page)
 {
 	__set_bit(PG_mapped, &page->flags);
 	if (((address ^ (unsigned long)to) & CACHE_ALIAS) == 0)
 		copy_page(to, from);
 	else {
-		pgprot_t pgprot = __pgprot(_PAGE_PRESENT | 
+		pgprot_t pgprot = __pgprot(_PAGE_PRESENT |
 					   _PAGE_RW | _PAGE_CACHABLE |
-					   _PAGE_DIRTY | _PAGE_ACCESSED | 
+					   _PAGE_DIRTY | _PAGE_ACCESSED |
 					   _PAGE_HW_SHARED | _PAGE_FLAGS_HARD);
 		unsigned long phys_addr = PHYSADDR(to);
 		unsigned long p3_addr = P3SEG + (address & CACHE_ALIAS);
-		pgd_t *dir = pgd_offset_k(p3_addr);
-		pmd_t *pmd = pmd_offset(dir, p3_addr);
+		pgd_t *pgd = pgd_offset_k(p3_addr);
+		pud_t *pud = pud_offset(pgd, p3_addr);
+		pmd_t *pmd = pmd_offset(pud, p3_addr);
 		pte_t *pte = pte_offset_kernel(pmd, p3_addr);
 		pte_t entry;
 		unsigned long flags;
diff -Naur linux-2.6.17.8/arch/sh/mm/pmb.c linux-2.6.17.8-sh/arch/sh/mm/pmb.c
--- linux-2.6.17.8/arch/sh/mm/pmb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/pmb.c	2006-08-23 13:29:17.387116000 +0100
@@ -0,0 +1,404 @@
+/*
+ * arch/sh/mm/pmb.c
+ *
+ * Privileged Space Mapping Buffer (PMB) Support.
+ *
+ * Copyright (C) 2005, 2006 Paul Mundt
+ *
+ * P1/P2 Section mapping definitions from map32.h, which was:
+ *
+ *	Copyright 2003 (c) Lineo Solutions,Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/err.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/mmu.h>
+#include <asm/io.h>
+
+#define NR_PMB_ENTRIES	16
+
+static kmem_cache_t *pmb_cache;
+static unsigned long pmb_map;
+
+static struct pmb_entry pmb_init_map[] = {
+	/* vpn         ppn         flags (ub/sz/c/wt) */
+
+	/* P1 Section Mappings */
+	{ 0x80000000, 0x00000000, PMB_SZ_64M  | PMB_C, },
+	{ 0x84000000, 0x04000000, PMB_SZ_64M  | PMB_C, },
+	{ 0x88000000, 0x08000000, PMB_SZ_128M | PMB_C, },
+	{ 0x90000000, 0x10000000, PMB_SZ_64M  | PMB_C, },
+	{ 0x94000000, 0x14000000, PMB_SZ_64M  | PMB_C, },
+	{ 0x98000000, 0x18000000, PMB_SZ_64M  | PMB_C, },
+
+	/* P2 Section Mappings */
+	{ 0xa0000000, 0x00000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+	{ 0xa4000000, 0x04000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+	{ 0xa8000000, 0x08000000, PMB_UB | PMB_SZ_128M | PMB_WT, },
+	{ 0xb0000000, 0x10000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+	{ 0xb4000000, 0x14000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+	{ 0xb8000000, 0x18000000, PMB_UB | PMB_SZ_64M  | PMB_WT, },
+};
+
+static inline unsigned long mk_pmb_entry(unsigned int entry)
+{
+	return (entry & PMB_E_MASK) << PMB_E_SHIFT;
+}
+
+static inline unsigned long mk_pmb_addr(unsigned int entry)
+{
+	return mk_pmb_entry(entry) | PMB_ADDR;
+}
+
+static inline unsigned long mk_pmb_data(unsigned int entry)
+{
+	return mk_pmb_entry(entry) | PMB_DATA;
+}
+
+struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
+			    unsigned long flags)
+{
+	struct pmb_entry *pmbe;
+
+	pmbe = kmem_cache_alloc(pmb_cache, GFP_KERNEL);
+	if (!pmbe)
+		return ERR_PTR(-ENOMEM);
+
+	pmbe->vpn	= vpn;
+	pmbe->ppn	= ppn;
+	pmbe->flags	= flags;
+
+	return pmbe;
+}
+
+void pmb_free(struct pmb_entry *pmbe)
+{
+	kmem_cache_free(pmb_cache, pmbe);
+}
+
+/*
+ * Must be in P2 for __set_pmb_entry()
+ */
+int __set_pmb_entry(unsigned long vpn, unsigned long ppn,
+		    unsigned long flags, int *entry)
+{
+	unsigned int pos = *entry;
+
+	if (unlikely(pos == PMB_NO_ENTRY))
+		pos = find_first_zero_bit(&pmb_map, NR_PMB_ENTRIES);
+
+repeat:
+	if (unlikely(pos > NR_PMB_ENTRIES))
+		return -ENOSPC;
+
+	if (test_and_set_bit(pos, &pmb_map)) {
+		pos = find_first_zero_bit(&pmb_map, NR_PMB_ENTRIES);
+		goto repeat;
+	}
+
+	ctrl_outl(vpn | PMB_V, mk_pmb_addr(pos));
+
+#ifdef CONFIG_SH_WRITETHROUGH
+	/*
+	 * When we are in 32-bit address extended mode, CCR.CB becomes
+	 * invalid, so care must be taken to manually adjust cacheable
+	 * translations.
+	 */
+	if (likely(flags & PMB_C))
+		flags |= PMB_WT;
+#endif
+
+	ctrl_outl(ppn | flags | PMB_V, mk_pmb_data(pos));
+
+	*entry = pos;
+
+	return 0;
+}
+
+int set_pmb_entry(struct pmb_entry *pmbe)
+{
+	int ret;
+
+	jump_to_P2();
+	ret = __set_pmb_entry(pmbe->vpn, pmbe->ppn, pmbe->flags, &pmbe->entry);
+	back_to_P1();
+
+	return ret;
+}
+
+void clear_pmb_entry(struct pmb_entry *pmbe)
+{
+	unsigned int entry = pmbe->entry;
+	unsigned long addr;
+
+	/*
+	 * Don't allow clearing of wired init entries, P1 or P2 access
+	 * without a corresponding mapping in the PMB will lead to reset
+	 * by the TLB.
+	 */
+	if (unlikely(entry < ARRAY_SIZE(pmb_init_map) ||
+		     entry >= NR_PMB_ENTRIES))
+		return;
+
+	jump_to_P2();
+
+	/* Clear V-bit */
+	addr = mk_pmb_addr(entry);
+	ctrl_outl(ctrl_inl(addr) & ~PMB_V, addr);
+
+	addr = mk_pmb_data(entry);
+	ctrl_outl(ctrl_inl(addr) & ~PMB_V, addr);
+
+	back_to_P1();
+
+	clear_bit(entry, &pmb_map);
+}
+
+static DEFINE_SPINLOCK(pmb_list_lock);
+static struct pmb_entry *pmb_list;
+
+static inline void pmb_list_add(struct pmb_entry *pmbe)
+{
+	struct pmb_entry **p, *tmp;
+
+	p = &pmb_list;
+	while ((tmp = *p) != NULL)
+		p = &tmp->next;
+
+	pmbe->next = tmp;
+	*p = pmbe;
+}
+
+static inline void pmb_list_del(struct pmb_entry *pmbe)
+{
+	struct pmb_entry **p, *tmp;
+
+	for (p = &pmb_list; (tmp = *p); p = &tmp->next)
+		if (tmp == pmbe) {
+			*p = tmp->next;
+			return;
+		}
+}
+
+static struct {
+	unsigned long size;
+	int flag;
+} pmb_sizes[] = {
+	{ .size	= 0x20000000, .flag = PMB_SZ_512M, },
+	{ .size = 0x08000000, .flag = PMB_SZ_128M, },
+	{ .size = 0x04000000, .flag = PMB_SZ_64M,  },
+	{ .size = 0x01000000, .flag = PMB_SZ_16M,  },
+};
+
+long pmb_remap(unsigned long vaddr, unsigned long phys,
+	       unsigned long size, unsigned long flags)
+{
+	struct pmb_entry *pmbp;
+	unsigned long wanted;
+	int pmb_flags, i;
+
+	/* Convert typical pgprot value to the PMB equivalent */
+	if (flags & _PAGE_CACHABLE) {
+		if (flags & _PAGE_WT)
+			pmb_flags = PMB_WT;
+		else
+			pmb_flags = PMB_C;
+	} else
+		pmb_flags = PMB_WT | PMB_UB;
+
+	pmbp = NULL;
+	wanted = size;
+
+again:
+	for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++) {
+		struct pmb_entry *pmbe;
+		int ret;
+
+		if (size < pmb_sizes[i].size)
+			continue;
+
+		pmbe = pmb_alloc(vaddr, phys, pmb_flags | pmb_sizes[i].flag);
+		if (IS_ERR(pmbe))
+			return PTR_ERR(pmbe);
+
+		ret = set_pmb_entry(pmbe);
+		if (ret != 0) {
+			pmb_free(pmbe);
+			return -EBUSY;
+		}
+
+		phys	+= pmb_sizes[i].size;
+		vaddr	+= pmb_sizes[i].size;
+		size	-= pmb_sizes[i].size;
+
+		/*
+		 * Link adjacent entries that span multiple PMB entries
+		 * for easier tear-down.
+		 */
+		if (likely(pmbp))
+			pmbp->link = pmbe;
+
+		pmbp = pmbe;
+	}
+
+	if (size >= 0x1000000)
+		goto again;
+
+	return wanted - size;
+}
+
+void pmb_unmap(unsigned long addr)
+{
+	struct pmb_entry **p, *pmbe;
+
+	for (p = &pmb_list; (pmbe = *p); p = &pmbe->next)
+		if (pmbe->vpn == addr)
+			break;
+
+	if (unlikely(!pmbe))
+		return;
+
+	WARN_ON(!test_bit(pmbe->entry, &pmb_map));
+
+	do {
+		struct pmb_entry *pmblink = pmbe;
+
+		clear_pmb_entry(pmbe);
+		pmbe = pmblink->link;
+
+		pmb_free(pmblink);
+	} while (pmbe);
+}
+
+static void pmb_cache_ctor(void *pmb, kmem_cache_t *cachep, unsigned long flags)
+{
+	struct pmb_entry *pmbe = pmb;
+
+	memset(pmb, 0, sizeof(struct pmb_entry));
+
+	spin_lock_irq(&pmb_list_lock);
+
+	pmbe->entry = PMB_NO_ENTRY;
+	pmb_list_add(pmbe);
+
+	spin_unlock_irq(&pmb_list_lock);
+}
+
+static void pmb_cache_dtor(void *pmb, kmem_cache_t *cachep, unsigned long flags)
+{
+	spin_lock_irq(&pmb_list_lock);
+	pmb_list_del(pmb);
+	spin_unlock_irq(&pmb_list_lock);
+}
+
+static int __init pmb_init(void)
+{
+	unsigned int nr_entries = ARRAY_SIZE(pmb_init_map);
+	unsigned int entry;
+
+	BUG_ON(unlikely(nr_entries >= NR_PMB_ENTRIES));
+
+	pmb_cache = kmem_cache_create("pmb", sizeof(struct pmb_entry),
+				      0, 0, pmb_cache_ctor, pmb_cache_dtor);
+	BUG_ON(!pmb_cache);
+
+	jump_to_P2();
+
+	/*
+	 * Ordering is important, P2 must be mapped in the PMB before we
+	 * can set PMB.SE, and P1 must be mapped before we jump back to
+	 * P1 space.
+	 */
+	for (entry = 0; entry < nr_entries; entry++) {
+		struct pmb_entry *pmbe = pmb_init_map + entry;
+
+		__set_pmb_entry(pmbe->vpn, pmbe->ppn, pmbe->flags, &entry);
+	}
+
+	ctrl_outl(0, PMB_IRMCR);
+
+	/* PMB.SE and UB[7] */
+	ctrl_outl((1 << 31) | (1 << 7), PMB_PASCR);
+
+	back_to_P1();
+
+	return 0;
+}
+
+arch_initcall(pmb_init);
+
+#ifdef CONFIG_DEBUG_FS
+static int pmb_seq_show(struct seq_file *file, void *iter)
+{
+	int i;
+
+	seq_printf(file, "V: Valid, C: Cacheable, WT: Write-Through\n"
+			 "CB: Copy-Back, B: Buffered, UB: Unbuffered\n");
+	seq_printf(file, "ety   vpn  ppn  size   flags\n");
+
+	for (i = 0; i < NR_PMB_ENTRIES; i++) {
+		unsigned long addr, data;
+		unsigned int size;
+		char *sz_str = NULL;
+
+		addr = ctrl_inl(mk_pmb_addr(i));
+		data = ctrl_inl(mk_pmb_data(i));
+
+		size = data & PMB_SZ_MASK;
+		sz_str = (size == PMB_SZ_16M)  ? " 16MB":
+			 (size == PMB_SZ_64M)  ? " 64MB":
+			 (size == PMB_SZ_128M) ? "128MB":
+					         "512MB";
+
+		/* 02: V 0x88 0x08 128MB C CB  B */
+		seq_printf(file, "%02d: %c 0x%02lx 0x%02lx %s %c %s %s\n",
+			   i, ((addr & PMB_V) && (data & PMB_V)) ? 'V' : ' ',
+			   (addr >> 24) & 0xff, (data >> 24) & 0xff,
+			   sz_str, (data & PMB_C) ? 'C' : ' ',
+			   (data & PMB_WT) ? "WT" : "CB",
+			   (data & PMB_UB) ? "UB" : " B");
+	}
+
+	return 0;
+}
+
+static int pmb_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmb_seq_show, NULL);
+}
+
+static struct file_operations pmb_debugfs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= pmb_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static int __init pmb_debugfs_init(void)
+{
+	struct dentry *dentry;
+
+	dentry = debugfs_create_file("pmb", S_IFREG | S_IRUGO,
+				     NULL, NULL, &pmb_debugfs_fops);
+	if (IS_ERR(dentry))
+		return PTR_ERR(dentry);
+
+	return 0;
+}
+
+postcore_initcall(pmb_debugfs_init);
+#endif
diff -Naur linux-2.6.17.8/arch/sh/mm/tlb-flush.c linux-2.6.17.8-sh/arch/sh/mm/tlb-flush.c
--- linux-2.6.17.8/arch/sh/mm/tlb-flush.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/tlb-flush.c	2006-08-23 13:29:17.083094000 +0100
@@ -0,0 +1,132 @@
+/*
+ * TLB flushing operations for SH with an MMU.
+ *
+ *  Copyright (C) 1999  Niibe Yutaka
+ *  Copyright (C) 2003  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/mm.h>
+#include <asm/mmu_context.h>
+#include <asm/tlbflush.h>
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
+{
+	if (vma->vm_mm && vma->vm_mm->context != NO_CONTEXT) {
+		unsigned long flags;
+		unsigned long asid;
+		unsigned long saved_asid = MMU_NO_ASID;
+
+		asid = vma->vm_mm->context & MMU_CONTEXT_ASID_MASK;
+		page &= PAGE_MASK;
+
+		local_irq_save(flags);
+		if (vma->vm_mm != current->mm) {
+			saved_asid = get_asid();
+			set_asid(asid);
+		}
+		__flush_tlb_page(asid, page);
+		if (saved_asid != MMU_NO_ASID)
+			set_asid(saved_asid);
+		local_irq_restore(flags);
+	}
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end)
+{
+	struct mm_struct *mm = vma->vm_mm;
+
+	if (mm->context != NO_CONTEXT) {
+		unsigned long flags;
+		int size;
+
+		local_irq_save(flags);
+		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
+			mm->context = NO_CONTEXT;
+			if (mm == current->mm)
+				activate_context(mm);
+		} else {
+			unsigned long asid = mm->context&MMU_CONTEXT_ASID_MASK;
+			unsigned long saved_asid = MMU_NO_ASID;
+
+			start &= PAGE_MASK;
+			end += (PAGE_SIZE - 1);
+			end &= PAGE_MASK;
+			if (mm != current->mm) {
+				saved_asid = get_asid();
+				set_asid(asid);
+			}
+			while (start < end) {
+				__flush_tlb_page(asid, start);
+				start += PAGE_SIZE;
+			}
+			if (saved_asid != MMU_NO_ASID)
+				set_asid(saved_asid);
+		}
+		local_irq_restore(flags);
+	}
+}
+
+void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	unsigned long flags;
+	int size;
+
+	local_irq_save(flags);
+	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+	if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
+		flush_tlb_all();
+	} else {
+		unsigned long asid = init_mm.context&MMU_CONTEXT_ASID_MASK;
+		unsigned long saved_asid = get_asid();
+
+		start &= PAGE_MASK;
+		end += (PAGE_SIZE - 1);
+		end &= PAGE_MASK;
+		set_asid(asid);
+		while (start < end) {
+			__flush_tlb_page(asid, start);
+			start += PAGE_SIZE;
+		}
+		set_asid(saved_asid);
+	}
+	local_irq_restore(flags);
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	/* Invalidate all TLB of this process. */
+	/* Instead of invalidating each TLB, we get new MMU context. */
+	if (mm->context != NO_CONTEXT) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		mm->context = NO_CONTEXT;
+		if (mm == current->mm)
+			activate_context(mm);
+		local_irq_restore(flags);
+	}
+}
+
+void flush_tlb_all(void)
+{
+	unsigned long flags, status;
+
+	/*
+	 * Flush all the TLB.
+	 *
+	 * Write to the MMU control register's bit:
+	 *	TF-bit for SH-3, TI-bit for SH-4.
+	 *      It's same position, bit #2.
+	 */
+	local_irq_save(flags);
+	status = ctrl_inl(MMUCR);
+	status |= 0x04;
+	ctrl_outl(status, MMUCR);
+	ctrl_barrier();
+	local_irq_restore(flags);
+}
diff -Naur linux-2.6.17.8/arch/sh/mm/tlb-sh4.c linux-2.6.17.8-sh/arch/sh/mm/tlb-sh4.c
--- linux-2.6.17.8/arch/sh/mm/tlb-sh4.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/mm/tlb-sh4.c	2006-08-23 13:29:15.322070000 +0100
@@ -36,7 +36,6 @@
 	unsigned long vpn;
 	struct page *page;
 	unsigned long pfn;
-	unsigned long ptea;
 
 	/* Ptrace may call this routine. */
 	if (vma && current->active_mm != vma->vm_mm)
@@ -59,10 +58,11 @@
 	ctrl_outl(vpn, MMU_PTEH);
 
 	pteval = pte_val(pte);
+
 	/* Set PTEA register */
-	/* TODO: make this look less hacky */
-	ptea = ((pteval >> 28) & 0xe) | (pteval & 0x1);
-	ctrl_outl(ptea, MMU_PTEA);
+	if (cpu_data->flags & CPU_HAS_PTEA)
+		/* TODO: make this look less hacky */
+		ctrl_outl(((pteval >> 28) & 0xe) | (pteval & 0x1), MMU_PTEA);
 
 	/* Set PTEL register */
 	pteval &= _PAGE_FLAGS_HARDWARE_MASK; /* drop software flags */
diff -Naur linux-2.6.17.8/arch/sh/oprofile/Makefile linux-2.6.17.8-sh/arch/sh/oprofile/Makefile
--- linux-2.6.17.8/arch/sh/oprofile/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/oprofile/Makefile	2006-08-23 13:29:13.481026000 +0100
@@ -7,7 +7,11 @@
 		timer_int.o )
 
 profdrvr-y				:= op_model_null.o
+
+# SH7750-style performance counters exist across 7750/7750S and 7091.
+profdrvr-$(CONFIG_CPU_SUBTYPE_SH7750S)	:= op_model_sh7750.o
 profdrvr-$(CONFIG_CPU_SUBTYPE_SH7750)	:= op_model_sh7750.o
+profdrvr-$(CONFIG_CPU_SUBTYPE_SH7091)	:= op_model_sh7750.o
 
 oprofile-y				:= $(DRIVER_OBJS) $(profdrvr-y)
 
diff -Naur linux-2.6.17.8/arch/sh/tools/mach-types linux-2.6.17.8-sh/arch/sh/tools/mach-types
--- linux-2.6.17.8/arch/sh/tools/mach-types	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/arch/sh/tools/mach-types	2006-08-23 13:29:26.405325000 +0100
@@ -25,4 +25,7 @@
 EDOSK7705		SH_EDOSK7705
 SH4202_MICRODEV		SH_SH4202_MICRODEV
 SH03			SH_SH03
-
+LANDISK			SH_LANDISK
+R7780RP			SH_R7780RP
+R7780MP			SH_R7780MP
+TITAN			SH_TITAN
diff -Naur linux-2.6.17.8/Documentation/bigphysarea.txt linux-2.6.17.8-sh/Documentation/bigphysarea.txt
--- linux-2.6.17.8/Documentation/bigphysarea.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/Documentation/bigphysarea.txt	2006-08-23 13:29:32.040439000 +0100
@@ -0,0 +1,64 @@
+Bigphysarea
+===========
+
+This set of functions give you the ability to allocate big
+contineous (DMAable) memory for the entire runtime of Linux.
+Big meaning here more than 128KB, the maximum allocation
+limit of kmalloc(). Due to fragmentation reasons kmalloc()
+is unable to garantee allocs of this order during a prolonged
+run of the kernel. This new pool of memory blob can be used
+during the initialization or use of soundcards of framegrabbers
+which are designed without DMA scatter-gatter capabilities.
+
+For a sample use, see the zoran driver in drivers/char/zr36120_mem.c
+
+Enjoy,
+  Pauline Middelink
+
+How to start
+============
+First add bigphysarea=<number of pages to alloc> to the
+commandline of your kernel. Either do this by adding an
+append= line to your /etc/lilo/conf setup or use some
+magic marker...
+After booting the new kernel there should be a /proc/bigphysarea
+file telling your how many blocks/bytes are available.
+
+The interface description
+=========================
+The big physical area is mainly managed by two functions. The first one,
+
+caddr_t bigphysarea_alloc_pages(int count, int align, int priority)
+
+allocates 'count' pages. The pages are aligned so that there base
+address is a multiple of 'PAGE_SIZE * align'. If you don't need more
+than page alignment, set 'align' to 0 or 1. 'priority' has the same
+meaning as in kmalloc, it can be GFP_ATOMIC (for calls from interrupt
+handlers) or GFP_KERNEL (for usual calls). The base address of the
+allocated area is returned.
+
+Allocation can fail for two reasons, in both cases NULL is
+returned. First, the physical area is scattered too much or there is
+not enough memory, second it is not possible to allocate some memory
+with kmalloc for administration of the physical area (very unlikely).
+
+To free an allocated area, just call
+
+void bigphysarea_free_pages(caddr_t base)
+
+with 'base' set to the value returned by 'bigphysarea_alloc_pages'.
+
+An example how to use this functions can be found in 'module.c'.
+
+There is still the old interface introduced by M. Welsh:
+
+caddr_t bigphysarea_alloc(int size)
+void bigphysarea_free(caddr_t addr, int size)
+
+The first function allocates 'size' bytes physically continous
+memory. To free the area, bigphysarea_free with a pointer to the area
+and its size has to be called. Due to a new allocation algorithm, the
+size parameter is no longer really needed when freeing an area.
+
+In the current version it is not safe to call any of the functions
+from an interrupt handler.
diff -Naur linux-2.6.17.8/Documentation/sh/new-machine.txt linux-2.6.17.8-sh/Documentation/sh/new-machine.txt
--- linux-2.6.17.8/Documentation/sh/new-machine.txt	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/Documentation/sh/new-machine.txt	2006-08-23 13:29:21.082188000 +0100
@@ -41,11 +41,6 @@
         |
 	.. more boards here ...
 
-It should also be noted that each board is required to have some certain
-headers. At the time of this writing, io.h is the only thing that needs
-to be provided for each board, and can generally just reference generic
-functions (with the exception of isa_port2addr).
-
 Next, for companion chips:
 .
 `-- arch
@@ -104,12 +99,13 @@
 Both the Solution Engine and the hp6xx boards are an example of this.
 
 After you have setup your new arch/sh/boards/ directory, remember that you
-also must add a directory in include/asm-sh for headers localized to this
-board. In order to interoperate seamlessly with the build system, it's best
-to have this directory the same as the arch/sh/boards/ directory name,
-though if your board is again part of a family, the build system has ways
-of dealing with this, and you can feel free to name the directory after
-the family member itself.
+should also add a directory in include/asm-sh for headers localized to this
+board (if there are going to be more than one). In order to interoperate
+seamlessly with the build system, it's best to have this directory the same
+as the arch/sh/boards/ directory name, though if your board is again part of
+a family, the build system has ways of dealing with this (via incdir-y
+overloading), and you can feel free to name the directory after the family
+member itself.
 
 There are a few things that each board is required to have, both in the
 arch/sh/boards and the include/asm-sh/ heirarchy. In order to better
@@ -122,6 +118,7 @@
  * arch/sh/boards/vapor/setup.c - Setup code for imaginary board
  */
 #include <linux/init.h>
+#include <asm/rtc.h> /* for board_time_init() */
 
 const char *get_system_type(void)
 {
@@ -152,79 +149,57 @@
 }
 
 Our new imaginary board will also have to tie into the machvec in order for it
-to be of any use. Currently the machvec is slowly on its way out, but is still
-required for the time being. As such, let us take a look at what needs to be
-done for the machvec assignment.
+to be of any use.
 
 machvec functions fall into a number of categories:
 
  - I/O functions to IO memory (inb etc) and PCI/main memory (readb etc).
- - I/O remapping functions (ioremap etc)
- - some initialisation functions
- - a 'heartbeat' function
- - some miscellaneous flags
-
-The tree can be built in two ways:
- - as a fully generic build. All drivers are linked in, and all functions
-   go through the machvec
- - as a machine specific build. In this case only the required drivers
-   will be linked in, and some macros may be redefined to not go through
-   the machvec where performance is important (in particular IO functions).
-
-There are three ways in which IO can be performed:
- - none at all. This is really only useful for the 'unknown' machine type,
-   which us designed to run on a machine about which we know nothing, and
-   so all all IO instructions do nothing.
- - fully custom. In this case all IO functions go to a machine specific
-   set of functions which can do what they like
- - a generic set of functions. These will cope with most situations,
-   and rely on a single function, mv_port2addr, which is called through the
-   machine vector, and converts an IO address into a memory address, which
-   can be read from/written to directly.
-
-Thus adding a new machine involves the following steps (I will assume I am
-adding a machine called vapor):
+ - I/O mapping functions (ioport_map, ioport_unmap, etc).
+ - a 'heartbeat' function.
+ - PCI and IRQ initialization routines.
+ - Consistent allocators (for boards that need special allocators,
+   particularly for allocating out of some board-specific SRAM for DMA
+   handles).
+
+There are machvec functions added and removed over time, so always be sure to
+consult include/asm-sh/machvec.h for the current state of the machvec.
+
+The kernel will automatically wrap in generic routines for undefined function
+pointers in the machvec at boot time, as machvec functions are referenced
+unconditionally throughout most of the tree. Some boards have incredibly
+sparse machvecs (such as the dreamcast and sh03), whereas others must define
+virtually everything (rts7751r2d).
+
+Adding a new machine is relatively trivial (using vapor as an example):
+
+If the board-specific definitions are quite minimalistic, as is the case for
+the vast majority of boards, simply having a single board-specific header is
+sufficient.
 
- - add a new file include/asm-sh/vapor/io.h which contains prototypes for
+ - add a new file include/asm-sh/vapor.h which contains prototypes for
    any machine specific IO functions prefixed with the machine name, for
    example vapor_inb. These will be needed when filling out the machine
    vector.
 
-   This is the minimum that is required, however there are ample
-   opportunities to optimise this. In particular, by making the prototypes
-   inline function definitions, it is possible to inline the function when
-   building machine specific versions. Note that the machine vector
-   functions will still be needed, so that a module built for a generic
-   setup can be loaded.
-
- - add a new file arch/sh/boards/vapor/mach.c. This contains the definition
-   of the machine vector. When building the machine specific version, this
-   will be the real machine vector (via an alias), while in the generic
-   version is used to initialise the machine vector, and then freed, by
-   making it initdata. This should be defined as:
-
-     struct sh_machine_vector mv_vapor __initmv = {
-       .mv_name = "vapor",
-     }
-     ALIAS_MV(vapor)
-
- - finally add a file arch/sh/boards/vapor/io.c, which contains
-   definitions of the machine specific io functions.
-
-A note about initialisation functions. Three initialisation functions are
-provided in the machine vector:
- - mv_arch_init - called very early on from setup_arch
- - mv_init_irq - called from init_IRQ, after the generic SH interrupt
-   initialisation
- - mv_init_pci - currently not used
-
-Any other remaining functions which need to be called at start up can be
-added to the list using the __initcalls macro (or module_init if the code
-can be built as a module). Many generic drivers probe to see if the device
-they are targeting is present, however this may not always be appropriate,
-so a flag can be added to the machine vector which will be set on those
-machines which have the hardware in question, reducing the probe to a
-single conditional.
+   Note that these prototypes are generated automatically by setting
+   __IO_PREFIX to something sensible. A typical example would be:
+
+	#define __IO_PREFIX vapor
+   	#include <asm/io_generic.h>
+
+   somewhere in the board-specific header. Any boards being ported that still
+   have a legacy io.h should remove it entirely and switch to the new model.
+
+ - Add machine vector definitions to the board's setup.c. At a bare minimum,
+   this must be defined as something like:
+
+	struct sh_machine_vector mv_vapor __initmv = {
+		.mv_name = "vapor",
+	};
+	ALIAS_MV(vapor)
+
+ - finally add a file arch/sh/boards/vapor/io.c, which contains definitions of
+   the machine specific io functions (if there are enough to warrant it).
 
 3. Hooking into the Build System
 ================================
@@ -303,4 +278,3 @@
 oldconfig (prompting you for any new options since the time of creation),
 and start you on your way to having a functional kernel for your new
 board.
-
diff -Naur linux-2.6.17.8/Documentation/sh/register-banks.txt linux-2.6.17.8-sh/Documentation/sh/register-banks.txt
--- linux-2.6.17.8/Documentation/sh/register-banks.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/Documentation/sh/register-banks.txt	2006-08-23 13:29:20.411188000 +0100
@@ -0,0 +1,33 @@
+	Notes on register bank usage in the kernel
+	==========================================
+
+Introduction
+------------
+
+The SH-3 and SH-4 CPU families traditionally include a single partial register
+bank (selected by SR.RB, only r0 ... r7 are banked), whereas other families
+may have more full-featured banking or simply no such capabilities at all.
+
+SR.RB banking
+-------------
+
+In the case of this type of banking, banked registers are mapped directly to
+r0 ... r7 if SR.RB is set to the bank we are interested in, otherwise ldc/stc
+can still be used to reference the banked registers (as r0_bank ... r7_bank)
+when in the context of another bank. The developer must keep the SR.RB value
+in mind when writing code that utilizes these banked registers, for obvious
+reasons. Userspace is also not able to poke at the bank1 values, so these can
+be used rather effectively as scratch registers by the kernel.
+
+Presently the kernel uses several of these registers.
+
+	- r0_bank, r1_bank (referenced as k0 and k1, used for scratch
+	  registers when doing exception handling).
+	- r2_bank (used to track the EXPEVT/INTEVT code)
+		- Used by do_IRQ() and friends for doing irq mapping based off
+		  of the interrupt exception vector jump table offset
+	- r6_bank (global interrupt mask)
+		- The SR.IMASK interrupt handler makes use of this to set the
+		  interrupt priority level (used by local_irq_enable())
+	- r7_bank (current)
+
diff -Naur linux-2.6.17.8/drivers/char/Kconfig linux-2.6.17.8-sh/drivers/char/Kconfig
--- linux-2.6.17.8/drivers/char/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/Kconfig	2006-08-23 13:29:42.723691000 +0100
@@ -603,6 +603,8 @@
 	  which will also be compiled when this driver is built as a
 	  module.
 
+source "drivers/char/lirc/Kconfig"
+
 source "drivers/char/ipmi/Kconfig"
 
 source "drivers/char/watchdog/Kconfig"
@@ -737,6 +739,22 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rtc.
 
+config SH03_RTC
+	tristate "Enhanced Real Time Clock (SH03) Support"
+	depends on SH_SH03
+
+config RS5C313_RTC
+	tristate "RICHO RS5C313 RTC Support for LANDISK"
+	depends on SH_LANDISK
+	help
+	  Selecting this option will support RICHO RS5C313 RTC for LANDISK.
+
+config RTC_9701JE
+	tristate "EPSON RTC-9701JE support"
+	depends on SH_RTS7751R2D
+	help
+	  Selecting this option will support EPSON RTC-9701JE.
+
 config SGI_DS1286
 	tristate "SGI DS1286 RTC support"
 	depends on SGI_IP22
@@ -953,6 +971,43 @@
 	tristate "NEC VR4100 series General-purpose I/O Unit support"
 	depends on CPU_VR41XX
 
+config ST_PIO
+	tristate "STMicroelectronics PIO Support"
+	depends on CPU_SUBTYPE_ST40
+	default y
+	help
+	  Driver for the PIO pins on STMicroelectronics ST40 and ST200
+	  based parts.
+
+config  STM_RTC
+        depends on CPU_SUBTYPE_ST40
+        bool "STMicroelectronics Real Time Clock Support"
+        default n
+        help
+          Enable this entry to support the SH4 Real Time Clock on the
+          STMicroelectronics SOCs
+
+          On the Espresso board, the RTC source is an external 32.768 kHz
+          oscillator.
+          For the 710x SoCs, the RTC is configured to run from the internal
+          clock B generator so needs no external clock.
+
+          For other ST boards and SoCs you will need to check that the
+          necessary external clock has been connected.  A 32.768 kHz clock must be
+          connected to the RTCCLOCK pin for this driver to work in those
+          systems.
+
+          Note that the time is not persistent between reboots with this driver.
+          You will need an external IC if you want this.
+
+config  STM_RTC_DEBUG
+        bool "STMicroelectronics Real Time Clock debug"
+        depends on STM_RTC
+        default n
+        help
+          Enable this option to print out information about
+          the STMicroelectronics Real Time Clock
+
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN) (OBSOLETE)"
 	help
diff -Naur linux-2.6.17.8/drivers/char/lirc/kcompat.h linux-2.6.17.8-sh/drivers/char/lirc/kcompat.h
--- linux-2.6.17.8/drivers/char/lirc/kcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/kcompat.h	2006-08-23 13:29:38.389599000 +0100
@@ -0,0 +1,202 @@
+/*      $Id: kcompat.h,v 5.11 2005/02/19 15:12:58 lirc Exp $      */
+
+#ifndef _KCOMPAT_H
+#define _KCOMPAT_H
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LIRC_HAVE_DEVFS
+#define LIRC_HAVE_DEVFS_26
+#define LIRC_HAVE_SYSFS
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#define LIRC_HAVE_DEVFS
+#define LIRC_HAVE_DEVFS_24
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+static inline void del_timer_sync(struct timer_list * timerlist)
+{
+	start_bh_atomic();
+	del_timer(timerlist);
+	end_bh_atomic();
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#ifdef daemonize
+#undef daemonize
+#endif
+#define daemonize(name) do {                                           \
+                                                                       \
+	lock_kernel();                                                 \
+	                                                               \
+	exit_mm(current);                                              \
+	exit_files(current);                                           \
+	exit_fs(current);                                              \
+	current->session = 1;                                          \
+	current->pgrp = 1;                                             \
+	current->euid = 0;                                             \
+	current->tty = NULL;                                           \
+	sigfillset(&current->blocked);                                 \
+	                                                               \
+	strcpy(current->comm, name);                                   \
+	                                                               \
+	unlock_kernel();                                               \
+                                                                       \
+} while (0)
+
+/* Not sure when this was introduced, sometime during 2.5.X */
+#define MODULE_PARM_int(x) MODULE_PARM(x, "i")
+#define MODULE_PARM_bool(x) MODULE_PARM(x, "i")
+#define MODULE_PARM_long(x) MODULE_PARM(x, "l")
+#define module_param(x,y,z) MODULE_PARM_##y(x)
+#else
+#include <linux/moduleparam.h>
+#endif /* Linux < 2.6.0 */
+
+#ifdef LIRC_HAVE_DEVFS_24
+#ifdef register_chrdev
+#undef register_chrdev
+#endif
+#define register_chrdev devfs_register_chrdev
+#ifdef unregister_chrdev
+#undef unregister_chrdev
+#endif
+#define unregister_chrdev devfs_unregister_chrdev
+#endif /* DEVFS 2.4 */
+
+#ifndef LIRC_HAVE_SYSFS
+#define class_simple_destroy(x) do { } while(0)
+#define class_simple_create(x,y) NULL
+#define class_simple_device_remove(x) do { } while(0)
+#define class_simple_device_add(x, y, z, xx, yy) 0
+#define IS_ERR(x) 0
+struct class_simple
+{
+	int notused;
+};
+#endif /* No SYSFS */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+#define KERNEL_2_5
+
+/*
+ * We still are using MOD_INC_USE_COUNT/MOD_DEC_USE_COUNT in the set_use_inc
+ * function of all modules for 2.4 kernel compatibility.
+ *
+ * For 2.6 kernels reference counting is done in lirc_dev by
+ * try_module_get()/module_put() because the old approach is racy.
+ *
+ */
+#ifdef MOD_INC_USE_COUNT
+#undef MOD_INC_USE_COUNT
+#endif
+#define MOD_INC_USE_COUNT
+
+#ifdef MOD_DEC_USE_COUNT
+#undef MOD_DEC_USE_COUNT
+#endif
+#define MOD_DEC_USE_COUNT
+
+#ifdef EXPORT_NO_SYMBOLS
+#undef EXPORT_NO_SYMBOLS
+#endif
+#define EXPORT_NO_SYMBOLS
+
+#else  /* Kernel < 2.5.0 */
+
+static inline int try_module_get(struct module *module)
+{
+	return 1;
+}
+
+static inline void module_put(struct module *module)
+{
+}
+
+#endif /* Kernel >= 2.5.0 */
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(x)
+#endif
+
+#ifndef MODULE_PARM_DESC
+#define MODULE_PARM_DESC(x,y)
+#endif
+
+#ifndef MODULE_ALIAS_CHARDEV_MAJOR
+#define MODULE_ALIAS_CHARDEV_MAJOR(x)
+#endif
+
+#ifndef MODULE_DEVICE_TABLE
+#define MODULE_DEVICE_TABLE(x,y)
+#endif
+
+#ifndef IRQ_RETVAL
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef MOD_IN_USE
+#ifdef CONFIG_MODULE_UNLOAD
+#define MOD_IN_USE module_refcount(THIS_MODULE)
+#else
+#error "LIRC modules currently require"
+#error "  'Loadable module support  --->  Module unloading'"
+#error "to be enabled in the kernel"
+#endif
+#endif
+
+#if !defined(local_irq_save)
+#define local_irq_save(flags) do{ save_flags(flags);cli(); } while(0)
+#endif
+#if !defined(local_irq_restore)
+#define local_irq_restore(flags) do{ restore_flags(flags); } while(0)
+#endif
+
+#if !defined(pci_pretty_name)
+#define pci_pretty_name(dev) ((dev)->name)
+#endif
+
+/*************************** I2C specific *****************************/
+#include <linux/i2c.h>
+
+#ifndef I2C_CLIENT_END
+#error "********************************************************"
+#error " Sorry, this driver needs the new I2C stack.            "
+#error " You can get it at http://www2.lm-sensors.nu/~lm78/.    "
+#error "********************************************************"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+
+#undef i2c_use_client
+#define i2c_use_client(client_ptr) do { \
+	if ((client_ptr)->adapter->inc_use) \
+		(client_ptr)->adapter->inc_use((client_ptr)->adapter); \
+} while (0)
+
+#undef i2c_release_client
+#define i2c_release_client(client_ptr) do { \
+	if ((client_ptr)->adapter->dec_use) \
+		(client_ptr)->adapter->dec_use((client_ptr)->adapter); \
+} while (0)
+
+#undef i2c_get_clientdata
+#define i2c_get_clientdata(client) ((client)->data)
+
+
+#undef i2c_set_clientdata
+#define i2c_set_clientdata(client_ptr, new_data) do { \
+	(client_ptr)->data = new_data; \
+} while (0)
+
+
+#endif
+
+#endif /* _KCOMPAT_H */
diff -Naur linux-2.6.17.8/drivers/char/lirc/Kconfig linux-2.6.17.8-sh/drivers/char/lirc/Kconfig
--- linux-2.6.17.8/drivers/char/lirc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/Kconfig	2006-08-23 13:29:43.129692000 +0100
@@ -0,0 +1,229 @@
+# LIRC http://lirc.sf.net/
+# Kernel patch by Flameeyes <dgp85@users.sf.net>
+# Check for new patch at http://flameeyes.web.ctonet.it
+#
+# Thanks to Koos Vriezen <koos.vriezen@xs4all.nl> for the Homebrew support.
+# Thanks to Jeff Clark <jeff@tmtrading.com> for support when I wasn't able
+# to update it and for his patch (found at http://www.clarkmania.com/~jclark/
+# Thanks to Bernhard Rosenkraenzer <bero@arklinux.org> for SMP patch.
+# Thanks to Vince <fuzzy77@free.fr> for the temporary lirc_atiusb driver.
+# Thanks to Paul Miller <pmiller9@users.sourceforge.net> for the new working
+# lirc_atiusb driver.
+
+menu "Linux InfraRed Controller"
+
+config LIRC_SUPPORT
+	tristate "Linux InfraRed Controller"
+
+	config LIRC_MAX_DEV
+		int "Maximum LIRC devices"
+		default "2"
+		depends on LIRC_SUPPORT
+
+	config LIRC_I2C
+		tristate "I2C Driver"
+		depends on LIRC_SUPPORT && VIDEO_BT848 && I2C && I2C_ALGOBIT
+		help
+		  Say Y here if you need support for the following cards:
+
+		  Pixelview IR
+		  Hauppauage IR
+		  PV951 IR
+		  TV-Box IR
+		  KNC ONE IR
+
+		  If these dont make sense to you, then dont use the module.
+
+	config LIRC_GPIO
+		tristate "GPIO Driver"
+		depends on LIRC_SUPPORT && VIDEO_BT848
+
+	config LIRC_BT829
+		tristate "BT829 Driver"
+		depends on LIRC_SUPPORT
+
+	config LIRC_IT87
+		tristate "IT87 Driver"
+		depends on LIRC_SUPPORT
+
+	config LIRC_ATIUSB
+		tristate "ATI USB Driver"
+		depends on LIRC_SUPPORT && USB
+
+	config LIRC_MCEUSB
+		tristate "MCE USB Driver"
+		depends on LIRC_SUPPORT && USB
+
+	config LIRC_PARALLEL
+		tristate "Parallel Driver"
+		depends on LIRC_SUPPORT && !SMP && PARPORT
+
+		choice
+			prompt "Parallel Port"
+			depends on LIRC_PARALLEL
+			config LIRC_PARALLEL_LPT1
+				bool "LPT1 (0x378, 7)"
+			config LIRC_PARALLEL_LPT2
+				bool "LPT2 (0x278, 5)"
+			config LIRC_PARALLEL_LPT3
+				bool "COM3 (0x3bc, none)"
+			config LIRC_PARALLEL_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_PARALLEL
+			hex "I/O Port"
+				default "0x378" if LIRC_PARALLEL_LPT1
+				default "0x278" if LIRC_PARALLEL_LPT2
+				default "0x3bc" if LIRC_PARALLEL_LPT3
+			depends on LIRC_PARALLEL
+
+		config LIRC_IRQ_PARALLEL
+			hex "IRQ"
+				default "7" if LIRC_PARALLEL_LPT1
+				default "5" if LIRC_PARALLEL_LPT2
+			depends on LIRC_PARALLEL
+
+		config LIRC_TIMER
+			int "Timer"
+			default "65535"
+			depends on LIRC_PARALLEL
+
+	config LIRC_SERIAL
+		tristate "Serial Driver"
+		depends on LIRC_SUPPORT && SERIAL_8250
+
+		choice
+			prompt "Serial Receiver Type"
+			depends on LIRC_SERIAL
+
+			config LIRC_HOMEBREW
+				bool "Homebrew"
+
+			config LIRC_SERIAL_ANIMAX
+				bool "Animax"
+
+			config LIRC_SERIAL_IRDEO
+				bool "IRdeo"
+
+			config LIRC_SERIAL_IRDEO_REMOTE
+				bool "IRdeo Remote"
+
+		endchoice
+
+		config LIRC_SERIAL_TRANSMITTER
+			bool "With transmitter diode"
+			depends on LIRC_SERIAL && !LIRC_SERIAL_ANIMAX
+
+		config LIRC_SERIAL_SOFTCARRIER
+			bool "With software carrier"
+			depends on LIRC_SERIAL_TRANSMITTER
+
+		config LIRC_SERIAL_IGOR
+			bool "Igor Ceska's variation"
+			depends on LIRC_SERIAL
+
+		choice
+			prompt "Serial Port"
+			depends on LIRC_SERIAL
+			config LIRC_SERIAL_COM1
+				bool "COM1 (0x3f8, 4)"
+			config LIRC_SERIAL_COM2
+				bool "COM2 (0x2f8, 3)"
+			config LIRC_SERIAL_COM3
+				bool "COM3 (0x3e8, 4)"
+			config LIRC_SERIAL_COM4
+				bool "COM4 (0x2e8, 3)"
+			config LIRC_SERIAL_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_SERIAL
+			hex "I/O Port"
+				default "0x3f8" if LIRC_SERIAL_COM1
+				default "0x2f8" if LIRC_SERIAL_COM2
+				default "0x3e8" if LIRC_SERIAL_COM3
+				default "0x2e8" if LIRC_SERIAL_COM4
+			depends on LIRC_SERIAL
+
+		config LIRC_IRQ_SERIAL
+			hex "IRQ"
+				default "4" if LIRC_SERIAL_COM1 || LIRC_SERIAL_COM3
+				default "3" if LIRC_SERIAL_COM2 || LIRC_SERIAL_COM4
+			depends on LIRC_SERIAL
+
+	config LIRC_SIR
+		tristate "SIR Driver"
+		depends on LIRC_SUPPORT
+
+		config LIRC_ON_SA1100
+			bool "LIRC driver for StrongARM SA1100 embedded microprocessor"
+			depends on LIRC_SIR
+
+		choice
+			prompt "SIR Type"
+			depends on LIRC_SIR && !LIRC_ON_SA1100
+
+			config LIRC_SIR_IRDA
+				bool "SIR IrDA (built-in IR ports)"
+
+			config LIRC_SIR_TEKRAM
+				bool "Tekram Irmate 210 (16x50 UART compatible serial port)"
+
+			config LIRC_SIR_ACTISYS_ACT200L
+				bool "Actisys Act200L SIR driver support"
+
+		endchoice
+
+		choice
+			prompt "Serial Port"
+			depends on LIRC_SIR
+			config LIRC_SIR_COM1
+				bool "COM1 (0x3f8, 4)"
+			config LIRC_SIR_COM2
+				bool "COM2 (0x2f8, 3)"
+			config LIRC_SIR_COM3
+				bool "COM3 (0x3e8, 4)"
+			config LIRC_SIR_COM4
+				bool "COM4 (0x2e8, 3)"
+			config LIRC_SIR_OTHER
+				bool "Other (custom values)"
+		endchoice
+
+		config LIRC_PORT_SIR
+			hex "I/O Port"
+				default "0x3f8" if LIRC_SIR_COM1
+				default "0x2f8" if LIRC_SIR_COM2
+				default "0x3e8" if LIRC_SIR_COM3
+				default "0x2e8" if LIRC_SIR_COM4
+			depends on LIRC_SIR
+
+		config LIRC_IRQ_SIR
+			hex "IRQ"
+				default "4" if LIRC_SIR_COM1 || LIRC_SIR_COM3
+				default "3" if LIRC_SIR_COM2 || LIRC_SIR_COM4
+			depends on LIRC_SIR
+        config ST_LIRC
+                tristate "STM Lirc support"
+                depends on LIRC_SUPPORT && (SH_STM8000_DEMO || SH_ST220_EVAL || SH_STI5528_EVAL || SH_STI5528_ESPRESSO || SH_STB7100_MBOARD || SH_STB7100_REF || SH_STB7109E_REF)
+
+                choice
+                        prompt "Receiver type"
+                        depends on ST_LIRC
+			help
+			  The IRB and UHF are identical and indipendent, except
+			  that the IRB receiver does not use the noise filter.
+			  Not all the ST platforms support both type of receivers.
+
+                        config IRB_RECEIVER
+                        bool "IRB Receiver"
+			depends on ST_LIRC && (SH_STM8000_DEMO || SH_ST220_EVAL || SH_STI5528_EVAL || SH_STB7100_MBOARD || SH_STB7100_REF || SH_STB7109E_REF)
+
+                        config UHF_RECEIVER
+                        bool "UHF Receiver"
+			depends on ST_LIRC && (SH_STI5528_ESPRESSO || SH_STI5528_EVAL || SH_STB7100_MBOARD)
+
+                endchoice
+
+endmenu
+
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_atiusb.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_atiusb.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_atiusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_atiusb.c	2006-08-23 13:29:33.868484000 +0100
@@ -0,0 +1,629 @@
+/* lirc_atiusb - USB remote support for LIRC
+ * (currently only supports X10 USB remotes)
+ * Version 0.3  [beta status]
+ *
+ * Copyright (C) 2003-2004 Paul Miller <pmiller9@users.sourceforge.net>
+ *
+ * This driver was derived from:
+ *   Vladimir Dergachev <volodya@minspring.com>'s 2002
+ *      "USB ATI Remote support" (input device)
+ *   Adrian Dewhurst <sailor-lk@sailorfrag.net>'s 2002
+ *      "USB StreamZap remote driver" (LIRC)
+ *   Artur Lipowski <alipowski@kki.net.pl>'s 2002
+ *      "lirc_dev" and "lirc_gpio" LIRC modules
+ *
+ * $Id: lirc_atiusb.c,v 1.21 2004/01/31 03:38:58 pmiller9 Exp $
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 4)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.2.4 or higher"
+#error "*******************************************************"
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#define KERNEL26		1
+#else
+#define KERNEL26		0
+#endif
+
+#include <linux/config.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+
+#if KERNEL26
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+#else
+#include "drivers/lirc.h"
+#include "drivers/lirc_dev/lirc_dev.h"
+#endif
+
+#define DRIVER_VERSION		"0.3"
+#define DRIVER_AUTHOR		"Paul Miller <pmiller9@users.sourceforge.net>"
+#define DRIVER_DESC		"USB remote driver for LIRC"
+#define DRIVER_NAME		"lirc_atiusb"
+
+#define CODE_LENGTH		5
+#define CODE_MIN_LENGTH		4
+#define USB_BUFLEN		(CODE_LENGTH*4)
+
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+#define dprintk			if (debug) printk
+
+/* get hi and low bytes of a 16-bits int */
+#define HI(a)			((unsigned char)((a) >> 8))
+#define LO(a)			((unsigned char)((a) & 0xff))
+
+/* lock irctl structure */
+#define IRLOCK			down_interruptible(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* general constants */
+#define SUCCESS			0
+#define SEND_FLAG_IN_PROGRESS	1
+#define SEND_FLAG_COMPLETE	2
+
+
+/* data structure for each usb remote */
+struct irctl {
+
+	/* usb */
+	struct usb_device *usbdev;
+	struct urb *urb_in;
+	struct urb *urb_out;
+	int devnum;
+
+	/* buffers and dma */
+	unsigned char *buf_in;
+	unsigned char *buf_out;
+	unsigned int len_in;
+#if KERNEL26
+	dma_addr_t dma_in;
+	dma_addr_t dma_out;
+#endif
+
+	/* lirc */
+	struct lirc_plugin *p;
+	int connected;
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait_out;
+
+	struct semaphore lock;
+};
+
+/* init strings */
+static char init1[] = {0x01, 0x00, 0x20, 0x14};
+static char init2[] = {0x01, 0x00, 0x20, 0x14, 0x20, 0x20, 0x20};
+
+/* send packet - used to initialize remote */
+static void send_packet(struct irctl *ir, u16 cmd, unsigned char *data)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int timeout = HZ; /* 1 second */
+	unsigned char buf[USB_BUFLEN];
+
+	dprintk(DRIVER_NAME "[%d]: send called (%#x)\n", ir->devnum, cmd);
+
+	IRLOCK;
+	ir->urb_out->transfer_buffer_length = LO(cmd) + 1;
+	ir->urb_out->dev = ir->usbdev;
+	ir->send_flags = SEND_FLAG_IN_PROGRESS;
+
+	memcpy(buf+1, data, LO(cmd));
+	buf[0] = HI(cmd);
+	memcpy(ir->buf_out, buf, LO(cmd)+1);
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&ir->wait_out, &wait);
+
+#if KERNEL26
+	if (usb_submit_urb(ir->urb_out, SLAB_ATOMIC)) {
+#else
+	if (usb_submit_urb(ir->urb_out)) {
+#endif
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&ir->wait_out, &wait);
+		IRUNLOCK;
+		return;
+	}
+	IRUNLOCK;
+
+	while (timeout && (ir->urb_out->status == -EINPROGRESS)
+		&& !(ir->send_flags & SEND_FLAG_COMPLETE)) {
+		timeout = schedule_timeout(timeout);
+		rmb();
+	}
+
+	dprintk(DRIVER_NAME "[%d]: send complete (%#x)\n", ir->devnum, cmd);
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&ir->wait_out, &wait);
+	usb_unlink_urb(ir->urb_out);
+}
+
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+	int rtn;
+
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
+
+	if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+		printk(DRIVER_NAME "[%d]: error in lirc_unregister minor: %d\n"
+			"Trying again...\n", devnum, p->minor);
+		if (rtn == -EBUSY) {
+			printk(DRIVER_NAME
+				"[%d]: device is opened, will unregister"
+				" on close\n", devnum);
+			return -EAGAIN;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+			printk(DRIVER_NAME "[%d]: lirc_unregister failed\n",
+			devnum);
+		}
+	}
+
+	if (rtn != SUCCESS) {
+		printk(DRIVER_NAME "[%d]: didn't free resources\n", devnum);
+		return -EAGAIN;
+	}
+
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+
+	lirc_buffer_free(p->rbuf);
+	kfree(p->rbuf);
+	kfree(p);
+	kfree(ir);
+	return SUCCESS;
+}
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
+
+	if (!ir->connected) {
+		if (!ir->usbdev)
+			return -ENOENT;
+		ir->urb_in->dev = ir->usbdev;
+#if KERNEL26
+		if (usb_submit_urb(ir->urb_in, SLAB_ATOMIC)) {
+#else
+		if (usb_submit_urb(ir->urb_in)) {
+#endif
+			printk(DRIVER_NAME "[%d]: open result = -EIO error "
+				"submitting urb\n", ir->devnum);
+			return -EIO;
+		}
+		ir->connected = 1;
+	}
+
+	return SUCCESS;
+}
+
+static void set_use_dec(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
+		return;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
+
+	if (ir->connected) {
+		IRLOCK;
+		usb_unlink_urb(ir->urb_in);
+		ir->connected = 0;
+		IRUNLOCK;
+	}
+}
+
+
+#if KERNEL26
+static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_remote_recv(struct urb *urb)
+#endif
+{
+	struct irctl *ir;
+	char buf[CODE_LENGTH];
+	int i, len;
+
+	if (!urb)
+		return;
+
+	if (!(ir = urb->context)) {
+		usb_unlink_urb(urb);
+		return;
+	}
+
+	dprintk(DRIVER_NAME "[%d]: data received (length %d)\n",
+		ir->devnum, urb->actual_length);
+
+	switch (urb->status) {
+
+	/* success */
+	case SUCCESS:
+		/* some remotes emit both 4 and 5 byte length codes. */
+		len = urb->actual_length;
+		if (len < CODE_MIN_LENGTH || len > CODE_LENGTH) return;
+
+		memcpy(buf,urb->transfer_buffer,len);
+		for (i = len; i < CODE_LENGTH; i++) buf[i] = 0;
+
+		lirc_buffer_write_1(ir->p->rbuf, buf);
+		wake_up(&ir->p->rbuf->wait_poll);
+		break;
+
+	/* unlink */
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		usb_unlink_urb(urb);
+		return;
+	}
+
+	/* resubmit urb */
+#if KERNEL26
+	usb_submit_urb(urb, SLAB_ATOMIC);
+#else
+	usb_submit_urb(urb);
+#endif
+}
+
+#if KERNEL26
+static void usb_remote_send(struct urb *urb, struct pt_regs *regs)
+#else
+static void usb_remote_send(struct urb *urb)
+#endif
+{
+	struct irctl *ir;
+
+	if (!urb)
+		return;
+
+	if (!(ir = urb->context)) {
+		usb_unlink_urb(urb);
+		return;
+	}
+
+	dprintk(DRIVER_NAME "[%d]: usb out called\n", ir->devnum);
+
+	if (urb->status)
+		return;
+
+	ir->send_flags |= SEND_FLAG_COMPLETE;
+	wmb();
+	if (waitqueue_active(&ir->wait_out))
+		wake_up(&ir->wait_out);
+}
+
+#if KERNEL26
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = NULL;
+	struct usb_host_interface *idesc = NULL;
+#else
+static void *usb_remote_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	struct usb_interface *intf;
+	struct usb_interface_descriptor *idesc;
+#endif
+	struct usb_endpoint_descriptor *ep_in, *ep_out;
+	struct irctl *ir = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int devnum, pipe, maxp, len, buf_len, bytes_in_key;
+	int minor = 0;
+	char buf[63], name[128]="";
+	int mem_failure = 0;
+
+	dprintk(DRIVER_NAME ": usb probe called\n");
+
+#if KERNEL26
+	dev = interface_to_usbdev(intf);
+	idesc = intf->cur_altsetting;
+	if (idesc->desc.bNumEndpoints != 2)
+		return -ENODEV;
+	ep_in = &idesc->endpoint[0].desc;
+	ep_out = &idesc->endpoint[1].desc;
+	if (((ep_in->bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
+		|| (ep_in->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+		!= USB_ENDPOINT_XFER_INT)
+		return -ENODEV;
+#else
+	intf = &dev->actconfig->interface[ifnum];
+	idesc = &intf->altsetting[intf->act_altsetting];
+	if (idesc->bNumEndpoints != 2)
+		return NULL;
+	ep_in = idesc->endpoint + 0;
+	ep_out = idesc->endpoint + 1;
+	if (((ep_in->bEndpointAddress & USB_ENDPOINT_DIR_MASK) != USB_DIR_IN)
+		|| (ep_in->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+		!= USB_ENDPOINT_XFER_INT)
+		return NULL;
+#endif
+	devnum = dev->devnum;
+	pipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	bytes_in_key = CODE_LENGTH;
+	len = (maxp > USB_BUFLEN) ? USB_BUFLEN : maxp;
+	buf_len = len - (len % bytes_in_key);
+
+	dprintk(DRIVER_NAME "[%d]: bytes_in_key=%d len=%d maxp=%d buf_len=%d\n",
+		devnum, bytes_in_key, len, maxp, buf_len);
+
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+		mem_failure = 1;
+	} else {
+		memset(ir, 0, sizeof(struct irctl));
+
+		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, bytes_in_key, USB_BUFLEN/bytes_in_key)) {
+			mem_failure = 4;
+#if KERNEL26
+		} else if (!(ir->buf_in = usb_buffer_alloc(dev, buf_len, SLAB_ATOMIC, &ir->dma_in))) {
+			mem_failure = 5;
+		} else if (!(ir->buf_out = usb_buffer_alloc(dev, USB_BUFLEN, SLAB_ATOMIC, &ir->dma_out))) {
+			mem_failure = 6;
+		} else if (!(ir->urb_in = usb_alloc_urb(0, GFP_KERNEL))) {
+			mem_failure = 7;
+		} else if (!(ir->urb_out = usb_alloc_urb(0, GFP_KERNEL))) {
+			mem_failure = 8;
+#else
+		} else if (!(ir->buf_in = kmalloc(buf_len, GFP_KERNEL))) {
+			mem_failure = 5;
+		} else if (!(ir->buf_out = kmalloc(USB_BUFLEN, GFP_KERNEL))) {
+			mem_failure = 6;
+		} else if (!(ir->urb_in = usb_alloc_urb(0))) {
+			mem_failure = 7;
+		} else if (!(ir->urb_out = usb_alloc_urb(0))) {
+			mem_failure = 8;
+#endif
+		} else {
+
+			memset(plugin, 0, sizeof(struct lirc_plugin));
+
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->code_length = bytes_in_key*8;
+			plugin->features = LIRC_CAN_REC_LIRCCODE;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+
+			init_MUTEX(&ir->lock);
+			init_waitqueue_head(&ir->wait_out);
+
+			if ((minor = lirc_register_plugin(plugin)) < 0) {
+				mem_failure = 9;
+			}
+		}
+	}
+
+	/* free allocated memory incase of failure */
+	switch (mem_failure) {
+	case 9:
+		lirc_buffer_free(rbuf);
+	case 8:
+		usb_free_urb(ir->urb_out);
+	case 7:
+		usb_free_urb(ir->urb_in);
+#if KERNEL26
+	case 6:
+		usb_buffer_free(dev, USB_BUFLEN, ir->buf_out, ir->dma_out);
+	case 5:
+		usb_buffer_free(dev, buf_len, ir->buf_in, ir->dma_in);
+#else
+	case 6:
+		kfree(ir->buf_out);
+	case 5:
+		kfree(ir->buf_in);
+#endif
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(ir);
+	case 1:
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+			devnum, mem_failure);
+#if KERNEL26
+		return -ENOMEM;
+#else
+		return NULL;
+#endif
+	}
+
+	plugin->minor = minor;
+	ir->p = plugin;
+	ir->devnum = devnum;
+	ir->usbdev = dev;
+	ir->len_in = buf_len;
+	ir->connected = 0;
+
+	usb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in,
+		buf_len, usb_remote_recv, ir, ep_in->bInterval);
+	usb_fill_int_urb(ir->urb_out, dev,
+		usb_sndintpipe(dev, ep_out->bEndpointAddress), ir->buf_out,
+		USB_BUFLEN, usb_remote_send, ir, ep_out->bInterval);
+
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", devnum, name,
+	       dev->bus->busnum, devnum);
+
+	send_packet(ir, 0x8004, init1);
+	send_packet(ir, 0x8007, init2);
+
+#if KERNEL26
+	usb_set_intfdata(intf, ir);
+	return SUCCESS;
+#else
+	return ir;
+#endif
+}
+
+
+#if KERNEL26
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+#else
+static void usb_remote_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct irctl *ir = ptr;
+#endif
+
+	if (!ir || !ir->p)
+		return;
+
+	ir->usbdev = NULL;
+	wake_up_all(&ir->wait_out);
+
+	IRLOCK;
+	usb_unlink_urb(ir->urb_in);
+	usb_unlink_urb(ir->urb_out);
+	usb_free_urb(ir->urb_in);
+	usb_free_urb(ir->urb_out);
+#if KERNEL26
+	usb_buffer_free(dev, ir->len_in, ir->buf_in, ir->dma_in);
+	usb_buffer_free(dev, USB_BUFLEN, ir->buf_out, ir->dma_out);
+#else
+	kfree(ir->buf_in);
+	kfree(ir->buf_out);
+#endif
+	IRUNLOCK;
+
+	unregister_from_lirc(ir);
+}
+
+static struct usb_device_id usb_remote_id_table [] = {
+	{ USB_DEVICE(0x0bc7, 0x0002) },		/* X10 USB Firecracker Interface */
+	{ USB_DEVICE(0x0bc7, 0x0003) },		/* X10 VGA Video Sender */
+	{ USB_DEVICE(0x0bc7, 0x0004) },		/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(0x0bc7, 0x0005) },		/* NVIDIA Wireless Remote Receiver */
+	{ USB_DEVICE(0x0bc7, 0x0006) },		/* ATI Wireless Remote Receiver */
+	{ USB_DEVICE(0x0bc7, 0x0007) },		/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x0008) },		/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x0009) },		/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000A) },		/* X10 USB Wireless Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000B) },		/* X10 USB Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000C) },		/* X10 USB Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000D) },		/* X10 USB Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000E) },		/* X10 USB Transceiver */
+	{ USB_DEVICE(0x0bc7, 0x000F) },		/* X10 USB Transceiver */
+
+	{ }					/* Terminating entry */
+};
+
+static struct usb_driver usb_remote_driver = {
+	.owner =	THIS_MODULE,
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+	.id_table =	usb_remote_id_table
+};
+
+static int __init usb_remote_init(void)
+{
+	int i;
+
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled\n");
+
+	request_module("lirc_dev");
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void __exit usb_remote_exit(void)
+{
+	usb_deregister(&usb_remote_driver);
+}
+
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_LICENSE ("GPL");
+MODULE_DEVICE_TABLE (usb, usb_remote_id_table);
+
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "enable driver debug mode");
+
+#if !KERNEL26
+EXPORT_NO_SYMBOLS;
+#endif
+
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_bt829.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_bt829.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_bt829.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_bt829.c	2006-08-23 13:29:33.874485000 +0100
@@ -0,0 +1,368 @@
+/*
+ * Remote control driver for the TV-card based on bt829
+ *
+ *  by Leonid Froenchenko <lfroen@galileo.co.il>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/threads.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include "lirc_dev.h"
+
+int poll_main(void);
+int atir_init_start(void);
+
+void write_index(unsigned char index,unsigned int value);
+unsigned int read_index(unsigned char index);
+
+void do_i2c_start(void);
+void do_i2c_stop(void);
+
+void seems_wr_byte(unsigned char al);
+unsigned char seems_rd_byte(void);
+
+unsigned int read_index(unsigned char al);
+void write_index(unsigned char ah,unsigned int edx);
+
+void cycle_delay(int cycle);
+
+void do_set_bits(unsigned char bl);
+unsigned char do_get_bits(void);
+
+#define DATA_PCI_OFF 0x7FFC00
+#define WAIT_CYCLE   20
+
+
+int atir_minor;
+unsigned long pci_addr_phys, pci_addr_lin;
+
+struct lirc_plugin atir_plugin;
+
+int do_pci_probe(void)
+{
+	struct pci_dev *my_dev;
+	my_dev = (struct pci_dev *)pci_find_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_264VT,NULL);
+	if ( my_dev ) {
+		printk(KERN_ERR "ATIR: Using device: %s\n",my_dev->slot_name);
+		pci_addr_phys = 0;
+		if ( my_dev->resource[0].flags & IORESOURCE_MEM ) {
+			pci_addr_phys = my_dev->resource[0].start;
+			printk(KERN_INFO "ATIR memory at 0x%08X \n",(unsigned int)pci_addr_phys);
+		}
+		if ( pci_addr_phys == 0 ) {
+			printk(KERN_ERR "ATIR no memory resource ?\n");
+			return 0;
+		}
+	} else {
+		printk(KERN_ERR "ATIR: pci_prob failed\n");
+		return 0;
+	}
+	return 1;
+}
+
+
+int atir_add_to_buf (void* data, struct lirc_buffer* buf)
+{
+	unsigned char key;
+	int status;
+	status = poll_main();
+	key = (status >> 8) & 0xFF;
+	if( status & 0xFF )
+	{
+	//    printk(KERN_INFO "ATIR reading key %02X\n",*key);
+		lirc_buffer_write_1( buf, &key );
+		return 0;
+	}
+	return -ENODATA;
+}
+
+int atir_set_use_inc(void* data)
+{
+	printk(KERN_DEBUG "ATIR driver is opened\n");
+	return 0;
+}
+
+void atir_set_use_dec(void* data)
+{
+	printk(KERN_DEBUG "ATIR driver is closed\n");
+}
+
+static int __init lirc_bt829_init(void)
+{
+	if ( !do_pci_probe() ) {
+		return 1;
+	}
+
+	if ( !atir_init_start() ) {
+		return 1;
+	}
+
+	strcpy(atir_plugin.name,"ATIR");
+	atir_plugin.minor       = -1;
+	atir_plugin.code_length = 8;
+	atir_plugin.sample_rate = 10;
+	atir_plugin.data        = 0;
+	atir_plugin.add_to_buf  = atir_add_to_buf;
+	atir_plugin.set_use_inc = atir_set_use_inc;
+	atir_plugin.set_use_dec = atir_set_use_dec;
+
+	atir_minor = lirc_register_plugin(&atir_plugin);
+	printk(KERN_DEBUG "ATIR driver is registered on minor %d\n",atir_minor);
+
+	return 0;
+}
+
+
+static void __exit lirc_bt829_exit(void)
+{
+	lirc_unregister_plugin(atir_minor);
+}
+
+
+int atir_init_start(void)
+{
+	pci_addr_lin = (unsigned long)ioremap(pci_addr_phys + DATA_PCI_OFF,0x400);
+	if ( pci_addr_lin == 0 ) {
+		printk(KERN_INFO "atir: pci mem must be mapped\n");
+		return 0;
+	}
+	return 1;
+}
+
+void cycle_delay(int cycle)
+{
+	udelay(WAIT_CYCLE*cycle);
+}
+
+
+int poll_main()
+{
+	unsigned char status_high, status_low;
+
+	do_i2c_start();
+
+	seems_wr_byte(0xAA);
+	seems_wr_byte(0x01);
+
+	do_i2c_start();
+
+	seems_wr_byte(0xAB);
+
+	status_low = seems_rd_byte();
+	status_high = seems_rd_byte();
+
+	do_i2c_stop();
+
+	return (status_high << 8) | status_low;
+}
+
+void do_i2c_start(void)
+{
+	do_set_bits(3);
+	cycle_delay(4);
+
+	do_set_bits(1);
+	cycle_delay(7);
+
+	do_set_bits(0);
+	cycle_delay(2);
+}
+
+void do_i2c_stop(void)
+{
+	unsigned char bits;
+	bits =  do_get_bits() & 0xFD;
+	do_set_bits(bits);
+	cycle_delay(1);
+
+	bits |= 1;
+	do_set_bits(bits);
+	cycle_delay(2);
+
+	bits |= 2;
+	do_set_bits(bits);
+	bits = 3;
+	do_set_bits(bits);
+	cycle_delay(2);
+}
+
+
+void seems_wr_byte(unsigned char value)
+{
+	int i;
+	unsigned char reg;
+
+	reg = do_get_bits();
+	for(i = 0;i < 8;i++) {
+		if ( value & 0x80 ) {
+			reg |= 0x02;
+		} else {
+			reg &= 0xFD;
+		}
+		do_set_bits(reg);
+		cycle_delay(1);
+
+		reg |= 1;
+		do_set_bits(reg);
+		cycle_delay(1);
+
+		reg &= 0xFE;
+		do_set_bits(reg);
+		cycle_delay(1);
+		value <<= 1;
+	}
+	cycle_delay(2);
+
+	reg |= 2;
+	do_set_bits(reg);
+
+	reg |= 1;
+	do_set_bits(reg);
+
+	cycle_delay(1);
+	do_get_bits();
+
+	reg &= 0xFE;
+	do_set_bits(reg);
+	cycle_delay(3);
+}
+
+unsigned char seems_rd_byte(void)
+{
+	int i;
+	int rd_byte;
+	unsigned char bits_2, bits_1;
+
+	bits_1 = do_get_bits() | 2;
+	do_set_bits(bits_1);
+
+	rd_byte = 0;
+	for(i = 0;i < 8;i++) {
+		bits_1 &= 0xFE;
+		do_set_bits(bits_1);
+		cycle_delay(2);
+
+		bits_1 |= 1;
+		do_set_bits(bits_1);
+		cycle_delay(1);
+
+		if ( (bits_2 = do_get_bits()) & 2 ) {
+			rd_byte |= 1;
+		}
+		rd_byte <<= 1;
+	}
+
+	bits_1 = 0;
+	if ( bits_2 == 0 ) {
+		bits_1 |= 2;
+	}
+	do_set_bits(bits_1);
+	cycle_delay(2);
+
+	bits_1 |= 1;
+	do_set_bits(bits_1);
+	cycle_delay(3);
+
+	bits_1 &= 0xFE;
+	do_set_bits(bits_1);
+	cycle_delay(2);
+
+	rd_byte >>= 1;
+	rd_byte &= 0xFF;
+	return rd_byte;
+}
+
+void do_set_bits(unsigned char new_bits)
+{
+	int reg_val;
+	reg_val = read_index(0x34);
+	if ( new_bits & 2 ) {
+		reg_val &= 0xFFFFFFDF;
+		reg_val |= 1;
+	} else {
+		reg_val &= 0xFFFFFFFE;
+		reg_val |= 0x20;
+	}
+	reg_val |= 0x10;
+	write_index(0x34,reg_val);
+
+	reg_val = read_index(0x31);
+	if ( new_bits & 1 ) {
+		reg_val |= 0x1000000;
+	} else {
+		reg_val &= 0xFEFFFFFF;
+	}
+	reg_val |= 0x8000000;
+	write_index(0x31,reg_val);
+}
+
+unsigned char do_get_bits(void)
+{
+	unsigned char bits;
+	int reg_val;
+
+	reg_val = read_index(0x34);
+	reg_val |= 0x10;
+	reg_val &= 0xFFFFFFDF;
+	write_index(0x34,reg_val);
+
+	reg_val = read_index(0x34);
+	bits = 0;
+	if ( reg_val & 8 ) {
+		bits |= 2;
+	} else {
+		bits &= 0xFD;
+	}
+	reg_val = read_index(0x31);
+	if ( reg_val & 0x1000000 ) {
+		bits |= 1;
+	} else {
+		bits &= 0xFE;
+	}
+	return bits;
+}
+
+unsigned int read_index(unsigned char index)
+{
+	unsigned int addr, value;
+	//  addr = pci_addr_lin + DATA_PCI_OFF + ((index & 0xFF) << 2);
+	addr = pci_addr_lin + ((index & 0xFF) << 2);
+	value = readl(addr);
+	return value;
+}
+
+void write_index(unsigned char index,unsigned int reg_val)
+{
+	unsigned int addr;
+	addr = pci_addr_lin + ((index & 0xFF) << 2);
+	writel(reg_val,addr);
+}
+
+MODULE_AUTHOR("Froenchenko Leonid");
+MODULE_DESCRIPTION("IR remote driver for bt829 based TV cards");
+MODULE_LICENSE("GPL");
+
+module_init(lirc_bt829_init);
+module_exit(lirc_bt829_exit);
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_dev.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_dev.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_dev.c	2006-08-23 13:29:38.412599000 +0100
@@ -0,0 +1,946 @@
+/*
+ * LIRC base driver
+ *
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: lirc_dev.c,v 1.41 2005/03/12 11:15:34 lirc Exp $
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
+#endif
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <asm/errno.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/wrapper.h>
+#endif
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+/* DevFS header */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/devfs_fs_kernel.h>
+#endif
+/* SysFS header */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/device.h>
+#endif
+
+#include <linux/st_soc.h>
+
+#include "kcompat.h"
+#include "lirc.h"
+#include "lirc_dev.h"
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+static struct platform_device *lirc_device_data;
+#endif
+
+static int debug = 0;
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+#define IRCTL_DEV_NAME    "BaseRemoteCtl"
+#define SUCCESS           0
+#define NOPLUG            -1
+#define LOGHEAD           "lirc_dev (%s[%d]): "
+
+struct irctl
+{
+	struct lirc_plugin p;
+	int attached;
+	int open;
+
+	struct semaphore buffer_sem;
+	struct lirc_buffer *buf;
+	unsigned int chunk_size;
+
+	int tpid;
+	struct semaphore *t_notify;
+	struct semaphore *t_notify2;
+	int shutdown;
+	long jiffies_to_wait;
+
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_handle_t devfs_handle;
+#endif
+};
+
+DECLARE_MUTEX(plugin_lock);
+
+static struct irctl irctls[MAX_IRCTL_DEVICES];
+static struct file_operations fops;
+
+/* Only used for sysfs but defined to void otherwise */
+static struct class_simple *lirc_class;
+
+/*  helper function
+ *  initializes the irctl structure
+ */
+static inline void init_irctl(struct irctl *ir)
+{
+	memset(&ir->p, 0, sizeof(struct lirc_plugin));
+	sema_init(&ir->buffer_sem, 1);
+	ir->p.minor = NOPLUG;
+
+	ir->tpid = -1;
+	ir->t_notify = NULL;
+	ir->t_notify2 = NULL;
+	ir->shutdown = 0;
+	ir->jiffies_to_wait = 0;
+
+	ir->open = 0;
+	ir->attached = 0;
+}
+
+static void cleanup(struct irctl *ir)
+{
+	dprintk(LOGHEAD "cleaning up\n", ir->p.name, ir->p.minor);
+
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_unregister(ir->devfs_handle);
+#endif
+#ifdef LIRC_HAVE_DEVFS_26
+	devfs_remove(DEV_LIRC "/%u", ir->p.minor);
+#endif
+	class_simple_device_remove(MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+
+	if (ir->buf != ir->p.rbuf){
+		lirc_buffer_free(ir->buf);
+		kfree(ir->buf);
+	}
+	ir->buf = NULL;
+
+	init_irctl(ir);
+}
+
+/*  helper function
+ *  reads key codes from plugin and puts them into buffer
+ *  buffer free space is checked and locking performed
+ *  returns 0 on success
+ */
+static inline int add_to_buf(struct irctl *ir)
+{
+	if (lirc_buffer_full(ir->buf)) {
+		dprintk(LOGHEAD "buffer overflow\n",
+			ir->p.name, ir->p.minor);
+		return -EOVERFLOW;
+	}
+
+	if(ir->p.add_to_buf) {
+		int res = -ENODATA;
+		int got_data = 0;
+
+		/* service the device as long as it is returning
+		 * data and we have space
+		 */
+		while( !lirc_buffer_full(ir->buf) )
+		{
+			res = ir->p.add_to_buf( ir->p.data, ir->buf );
+			if( res == SUCCESS )
+				got_data++;
+			else
+				break;
+		}
+
+		if( res == -ENODEV )
+		{
+			ir->shutdown = 1;
+		}
+		return (got_data ? SUCCESS : res);
+	}
+
+	return SUCCESS;
+}
+
+/* main function of the polling thread
+ */
+static int lirc_thread(void *irctl)
+{
+	struct irctl *ir = irctl;
+
+	/* This thread doesn't need any user-level access,
+	 * so get rid of all our resources
+	 */
+	daemonize("lirc_dev");
+
+	if (ir->t_notify != NULL) {
+		up(ir->t_notify);
+	}
+
+	dprintk(LOGHEAD "poll thread started\n", ir->p.name, ir->p.minor);
+
+	do {
+		if (ir->open) {
+			if (ir->jiffies_to_wait) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(ir->jiffies_to_wait);
+			} else {
+				interruptible_sleep_on(ir->p.get_queue(ir->p.data));
+			}
+			if (ir->shutdown) {
+				break;
+			}
+			if (!add_to_buf(ir)) {
+				wake_up_interruptible(&ir->buf->wait_poll);
+			}
+		} else {
+			/* if device not opened so we can sleep half a second */
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/2);
+		}
+	} while (!ir->shutdown);
+
+	if (ir->t_notify2 != NULL) {
+		down(ir->t_notify2);
+	}
+
+	ir->tpid = -1;
+	if (ir->t_notify != NULL) {
+		up(ir->t_notify);
+	}
+
+	dprintk(LOGHEAD "poll thread ended\n", ir->p.name, ir->p.minor);
+
+	return 0;
+}
+
+/*
+ *
+ */
+int lirc_register_plugin(struct lirc_plugin *p)
+{
+	struct irctl *ir;
+	int minor;
+	int bytes_in_key;
+	int err;
+#ifdef LIRC_HAVE_DEVFS_24
+	char name[16];
+#endif
+	DECLARE_MUTEX_LOCKED(tn);
+
+	if (!p) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "plugin pointer must be not NULL!\n");
+		err = -EBADRQC;
+		goto out;
+	}
+
+	if (MAX_IRCTL_DEVICES <= p->minor) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "\"minor\" must be between 0 and %d (%d)!\n",
+		       MAX_IRCTL_DEVICES-1, p->minor);
+		err = -EBADRQC;
+		goto out;
+	}
+
+	if (1 > p->code_length || (BUFLEN*8) < p->code_length) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "code length in bits for minor (%d) "
+		       "must be less than %d!\n",
+		       p->minor, BUFLEN*8);
+		err = -EBADRQC;
+		goto out;
+	}
+
+	printk("lirc_dev: lirc_register_plugin: "
+	       "sample_rate: %d\n",p->sample_rate);
+	if (p->sample_rate) {
+		if (2 > p->sample_rate || HZ < p->sample_rate) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "sample_rate must be between 2 and %d!\n", HZ);
+			err = -EBADRQC;
+			goto out;
+		}
+		if (!p->add_to_buf) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "add_to_buf cannot be NULL when "
+			       "sample_rate is set\n");
+			err = -EBADRQC;
+			goto out;
+		}
+	} else if (!(p->fops && p->fops->read)
+		   && !p->get_queue && !p->rbuf) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "fops->read, get_queue and rbuf "
+		       "cannot all be NULL!\n");
+		err = -EBADRQC;
+		goto out;
+	} else if (!p->get_queue && !p->rbuf) {
+		if (!(p->fops && p->fops->read && p->fops->poll)
+		    || (!p->fops->ioctl && !p->ioctl)) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "neither read, poll nor ioctl can be NULL!\n");
+			err = -EBADRQC;
+			goto out;
+		}
+	}
+
+	down(&plugin_lock);
+
+	minor = p->minor;
+
+	if (0 > minor) {
+		/* find first free slot for plugin */
+		for (minor=0; minor<MAX_IRCTL_DEVICES; minor++)
+			if (irctls[minor].p.minor == NOPLUG)
+				break;
+		if (MAX_IRCTL_DEVICES == minor) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "no free slots for plugins!\n");
+			err = -ENOMEM;
+			goto out_lock;
+		}
+	} else if (irctls[minor].p.minor != NOPLUG) {
+		printk("lirc_dev: lirc_register_plugin: "
+		       "minor (%d) already registered!\n", minor);
+		err = -EBUSY;
+		goto out_lock;
+	}
+
+	ir = &irctls[minor];
+
+	if (p->sample_rate) {
+		ir->jiffies_to_wait = HZ / p->sample_rate;
+	} else {
+                /* it means - wait for externeal event in task queue */
+		ir->jiffies_to_wait = 0;
+	}
+
+	/* some safety check 8-) */
+	p->name[sizeof(p->name)-1] = '\0';
+
+	bytes_in_key = p->code_length/8 + (p->code_length%8 ? 1 : 0);
+
+	if (p->rbuf) {
+		ir->buf = p->rbuf;
+	} else {
+		ir->buf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);
+		if(!ir->buf) {
+			err = -ENOMEM;
+			goto out_lock;
+		}
+		if(lirc_buffer_init
+		   (ir->buf, bytes_in_key, BUFLEN/bytes_in_key) != 0) {
+			kfree(ir->buf);
+			err = -ENOMEM;
+			goto out_lock;
+		}
+	}
+	ir->chunk_size = ir->buf->chunk_size;
+
+	if (p->features==0)
+		p->features = (p->code_length > 8) ?
+			LIRC_CAN_REC_LIRCCODE : LIRC_CAN_REC_CODE;
+
+	ir->p = *p;
+	ir->p.minor = minor;
+
+#if defined(LIRC_HAVE_DEVFS_24)
+	sprintf (name, DEV_LIRC "/%d", ir->p.minor);
+	ir->devfs_handle = devfs_register(NULL, name, DEVFS_FL_DEFAULT,
+					  IRCTL_DEV_MAJOR, ir->p.minor,
+					  S_IFCHR | S_IRUSR | S_IWUSR,
+					  &fops, NULL);
+#elif defined(LIRC_HAVE_DEVFS_26)
+	devfs_mk_cdev(MKDEV(IRCTL_DEV_MAJOR, ir->p.minor),
+			S_IFCHR|S_IRUSR|S_IWUSR,
+			DEV_LIRC "/%u", ir->p.minor);
+#endif
+	(void) class_simple_device_add(lirc_class, MKDEV(IRCTL_DEV_MAJOR, ir->p.minor),
+				       NULL, "lirc%u", ir->p.minor);
+
+	if(p->sample_rate || p->get_queue) {
+		/* try to fire up polling thread */
+		ir->t_notify = &tn;
+		ir->tpid = kernel_thread(lirc_thread, (void*)ir, 0);
+		if (ir->tpid < 0) {
+			printk("lirc_dev: lirc_register_plugin: "
+			       "cannot run poll thread for minor = %d\n",
+			       p->minor);
+			err = -ECHILD;
+			goto out_sysfs;
+		}
+		down(&tn);
+		ir->t_notify = NULL;
+	}
+	ir->attached = 1;
+	up(&plugin_lock);
+
+/*
+ * Recent kernels should handle this autmatically by increasing/decreasing
+ * use count when a dependant module is loaded/unloaded.
+ */
+#ifndef KERNEL_2_5
+	MOD_INC_USE_COUNT;
+#endif
+	dprintk("lirc_dev: plugin %s registered at minor number = %d\n",
+		ir->p.name, ir->p.minor);
+	p->minor = minor;
+	return minor;
+
+out_sysfs:
+	class_simple_device_remove(MKDEV(IRCTL_DEV_MAJOR, ir->p.minor));
+#ifdef LIRC_HAVE_DEVFS_24
+	devfs_unregister(ir->devfs_handle);
+#endif
+#ifdef LIRC_HAVE_DEVFS_26
+	devfs_remove(DEV_LIRC "/%i", ir->p.minor);
+#endif
+out_lock:
+	up(&plugin_lock);
+out:
+	return err;
+}
+
+/*
+ *
+ */
+int lirc_unregister_plugin(int minor)
+{
+	struct irctl *ir;
+	DECLARE_MUTEX_LOCKED(tn);
+	DECLARE_MUTEX_LOCKED(tn2);
+
+	if (minor < 0 || minor >= MAX_IRCTL_DEVICES) {
+		printk("lirc_dev: lirc_unregister_plugin: "
+		       "\"minor\" must be between 0 and %d!\n",
+		       MAX_IRCTL_DEVICES-1);
+		return -EBADRQC;
+	}
+
+	ir = &irctls[minor];
+
+	down(&plugin_lock);
+
+	if (ir->p.minor != minor) {
+		printk("lirc_dev: lirc_unregister_plugin: "
+		       "minor (%d) device not registered!", minor);
+		up(&plugin_lock);
+		return -ENOENT;
+	}
+
+	/* end up polling thread */
+	if (ir->tpid >= 0) {
+		ir->t_notify = &tn;
+		ir->t_notify2 = &tn2;
+		ir->shutdown = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		{
+			struct task_struct *p;
+
+			p = find_task_by_pid(ir->tpid);
+			wake_up_process(p);
+		}
+#else
+		/* 2.2.x does not export wake_up_process() */
+		wake_up_interruptible(ir->p.get_queue(ir->p.data));
+#endif
+		up(&tn2);
+		down(&tn);
+		ir->t_notify = NULL;
+		ir->t_notify2 = NULL;
+	}
+
+	dprintk("lirc_dev: plugin %s unregistered from minor number = %d\n",
+		ir->p.name, ir->p.minor);
+
+	ir->attached = 0;
+	if (ir->open) {
+		dprintk(LOGHEAD "releasing opened plugin\n",
+			ir->p.name, ir->p.minor);
+		wake_up_interruptible(&ir->buf->wait_poll);
+		down(&ir->buffer_sem);
+		ir->p.set_use_dec(ir->p.data);
+		module_put(ir->p.owner);
+		up(&ir->buffer_sem);
+	}
+	else
+	{
+		cleanup(ir);
+	}
+	up(&plugin_lock);
+
+/*
+ * Recent kernels should handle this autmatically by increasing/decreasing
+ * use count when a dependant module is loaded/unloaded.
+ */
+#ifndef KERNEL_2_5
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return SUCCESS;
+}
+
+/*
+ *
+ */
+static int irctl_open(struct inode *inode, struct file *file)
+{
+	struct irctl *ir;
+	int retval;
+
+	if (MINOR(inode->i_rdev) >= MAX_IRCTL_DEVICES) {
+		dprintk("lirc_dev [%d]: open result = -ENODEV\n",
+			MINOR(inode->i_rdev));
+		return -ENODEV;
+	}
+
+	ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "open called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has an open function use it instead */
+	if(ir->p.fops && ir->p.fops->open)
+		return ir->p.fops->open(inode, file);
+
+	down_interruptible(&plugin_lock);
+
+	if (ir->p.minor == NOPLUG) {
+		up(&plugin_lock);
+		dprintk(LOGHEAD "open result = -ENODEV\n",
+			ir->p.name, ir->p.minor);
+		return -ENODEV;
+	}
+
+	if (ir->open) {
+		up(&plugin_lock);
+		dprintk(LOGHEAD "open result = -EBUSY\n",
+			ir->p.name, ir->p.minor);
+		return -EBUSY;
+	}
+
+	/* there is no need for locking here because ir->open is 0
+         * and lirc_thread isn't using buffer
+	 * plugins which use irq's should allocate them on set_use_inc,
+	 * so there should be no problem with those either.
+         */
+	ir->buf->head = ir->buf->tail;
+	ir->buf->fill = 0;
+
+#ifdef MODULE
+	if(ir->p.owner!=NULL && try_module_get(ir->p.owner))
+	{
+#endif
+		++ir->open;
+		retval = ir->p.set_use_inc(ir->p.data);
+
+		up(&plugin_lock);
+
+		if (retval != SUCCESS) {
+			module_put(ir->p.owner);
+			--ir->open;
+			return retval;
+		}
+#ifdef MODULE
+	}
+	else
+	{
+		if(ir->p.owner==NULL)
+		{
+			dprintk(LOGHEAD "no module owner!!!\n", ir->p.name, ir->p.minor);
+		}
+		retval = -ENODEV;
+	}
+#endif
+
+	dprintk(LOGHEAD "open result = %d\n", ir->p.name, ir->p.minor, SUCCESS);
+
+	return SUCCESS;
+}
+
+/*
+ *
+ */
+static int irctl_close(struct inode *inode, struct file *file)
+{
+	struct irctl *ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "close called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a close function use it instead */
+	if(ir->p.fops && ir->p.fops->release)
+		return ir->p.fops->release(inode, file);
+
+	down_interruptible(&plugin_lock);
+
+	--ir->open;
+	if(ir->attached)
+	{
+		ir->p.set_use_dec(ir->p.data);
+		module_put(ir->p.owner);
+	}
+	else
+	{
+		cleanup(ir);
+	}
+
+	up(&plugin_lock);
+
+	return SUCCESS;
+}
+
+/*
+ *
+ */
+static unsigned int irctl_poll(struct file *file, poll_table *wait)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	unsigned int ret;
+
+	dprintk(LOGHEAD "poll called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a poll function use it instead */
+	if(ir->p.fops && ir->p.fops->poll)
+		return ir->p.fops->poll(file, wait);
+
+	down(&ir->buffer_sem);
+	if(!ir->attached)
+	{
+		up(&ir->buffer_sem);
+		return POLLERR;
+	}
+
+	poll_wait(file, &ir->buf->wait_poll, wait);
+
+	dprintk(LOGHEAD "poll result = %s\n",
+		ir->p.name, ir->p.minor,
+		lirc_buffer_empty(ir->buf) ? "0" : "POLLIN|POLLRDNORM");
+
+	ret = lirc_buffer_empty(ir->buf) ? 0 : (POLLIN|POLLRDNORM);
+
+	up(&ir->buffer_sem);
+	return ret;
+}
+
+/*
+ *
+ */
+static int irctl_ioctl(struct inode *inode, struct file *file,
+                       unsigned int cmd, unsigned long arg)
+{
+	unsigned long mode;
+	int result;
+	struct irctl *ir = &irctls[MINOR(inode->i_rdev)];
+
+	dprintk(LOGHEAD "ioctl called (0x%x)\n",
+		ir->p.name, ir->p.minor, cmd);
+
+	/* if the plugin has a ioctl function use it instead */
+	if(ir->p.fops && ir->p.fops->ioctl)
+		return ir->p.fops->ioctl(inode, file, cmd, arg);
+
+	if (ir->p.minor == NOPLUG || !ir->attached) {
+		dprintk(LOGHEAD "ioctl result = -ENODEV\n",
+			ir->p.name, ir->p.minor);
+		return -ENODEV;
+	}
+
+	/* Give the plugin a chance to handle the ioctl */
+	if(ir->p.ioctl){
+		result = ir->p.ioctl(inode, file, cmd, arg);
+		if (result != -ENOIOCTLCMD)
+			return result;
+	}
+	/* The plugin can't handle cmd */
+	result = SUCCESS;
+
+	switch(cmd)
+	{
+	case LIRC_GET_FEATURES:
+		result = put_user(ir->p.features, (unsigned long*)arg);
+		break;
+	case LIRC_GET_REC_MODE:
+		if(!(ir->p.features&LIRC_CAN_REC_MASK))
+			return(-ENOSYS);
+
+		result = put_user(LIRC_REC2MODE
+				  (ir->p.features&LIRC_CAN_REC_MASK),
+				  (unsigned long*)arg);
+		break;
+	case LIRC_SET_REC_MODE:
+		if(!(ir->p.features&LIRC_CAN_REC_MASK))
+			return(-ENOSYS);
+
+		result = get_user(mode, (unsigned long*)arg);
+		if(!result && !(LIRC_MODE2REC(mode) & ir->p.features)) {
+			result = -EINVAL;
+		}
+		/* FIXME: We should actually set the mode somehow
+		 * but for now, lirc_serial doesn't support mode changin
+		 * eighter */
+		break;
+	case LIRC_GET_LENGTH:
+		result = put_user((unsigned long)ir->p.code_length,
+				  (unsigned long *)arg);
+		break;
+	default:
+		result = -ENOIOCTLCMD;
+	}
+
+	dprintk(LOGHEAD "ioctl result = %d\n",
+		ir->p.name, ir->p.minor, result);
+
+	return result;
+}
+
+/*
+ *
+ */
+static ssize_t irctl_read(struct file *file,
+			  char *buffer,
+			  size_t length,
+			  loff_t *ppos)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	unsigned char buf[ir->chunk_size];
+	int ret=0, written=0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->read)
+		return ir->p.fops->read(file, buffer, length, ppos);
+
+	if(down_interruptible(&ir->buffer_sem))
+	{
+		return -ERESTARTSYS;
+	}
+	if(!ir->attached)
+	{
+		up(&ir->buffer_sem);
+		return -ENODEV;
+	}
+
+	if (length % ir->buf->chunk_size) {
+		dprintk(LOGHEAD "read result = -EINVAL\n",
+			ir->p.name, ir->p.minor);
+		up(&ir->buffer_sem);
+		return -EINVAL;
+	}
+
+	/* we add ourselves to the task queue before buffer check
+         * to avoid losing scan code (in case when queue is awaken somewhere
+	 * beetwen while condition checking and scheduling)
+	 */
+	add_wait_queue(&ir->buf->wait_poll, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	/* while we did't provide 'length' bytes, device is opened in blocking
+	 * mode and 'copy_to_user' is happy, wait for data.
+	 */
+	while (written < length && ret == 0) {
+		if (lirc_buffer_empty(ir->buf)) {
+			/* According to the read(2) man page, 'written' can be
+			 * returned as less than 'length', instead of blocking
+			 * again, returning -EWOULDBLOCK, or returning
+			 * -ERESTARTSYS */
+			if (written) break;
+			if (file->f_flags & O_NONBLOCK) {
+				ret = -EWOULDBLOCK;
+				break;
+			}
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+			set_current_state(TASK_INTERRUPTIBLE);
+			if(!ir->attached)
+			{
+				ret = -ENODEV;
+				break;
+			}
+		} else {
+			lirc_buffer_read_1(ir->buf, buf);
+			ret = copy_to_user((void *)buffer+written, buf,
+					   ir->buf->chunk_size);
+			written += ir->buf->chunk_size;
+		}
+	}
+
+	remove_wait_queue(&ir->buf->wait_poll, &wait);
+	set_current_state(TASK_RUNNING);
+	up(&ir->buffer_sem);
+
+	dprintk(LOGHEAD "read result = %s (%d)\n",
+		ir->p.name, ir->p.minor, ret ? "-EFAULT" : "OK", ret);
+
+	return ret ? ret : written;
+}
+
+static ssize_t irctl_write(struct file *file, const char *buffer,
+			   size_t length, loff_t * ppos)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+
+	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->write)
+		return ir->p.fops->write(file, buffer, length, ppos);
+
+	if(!ir->attached)
+	{
+		return -ENODEV;
+	}
+
+	return -EINVAL;
+}
+
+
+static struct file_operations fops = {
+	read:    irctl_read,
+	write:   irctl_write,
+	poll:    irctl_poll,
+	ioctl:   irctl_ioctl,
+	open:    irctl_open,
+	release: irctl_close
+};
+
+EXPORT_SYMBOL(lirc_register_plugin);
+EXPORT_SYMBOL(lirc_unregister_plugin);
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+static int __init lirc_probe(struct device *dev)
+{
+	struct plat_lirc_data *lirc_private_info;
+	lirc_device_data=to_platform_device(dev);
+
+	lirc_private_info = lirc_device_data->dev.platform_data;
+
+	if (lirc_device_data->name != NULL)
+		printk(KERN_INFO "Device probe found data for platform device %s\n", lirc_device_data->name);
+	else
+		printk(KERN_ERR "Device probe failed.  Check your kernel SoC config!!\n");
+
+        return 0;
+}
+
+static struct device_driver lirc_driver = {
+        .name           = "lirc",
+        .bus            = &platform_bus_type,
+        .probe          = lirc_probe,
+};
+
+void* lirc_get_config()
+{
+	return (void*)lirc_device_data;
+}
+
+EXPORT_SYMBOL(lirc_get_config);
+
+#endif
+
+/*
+ *  Device initialisation
+ */
+static int __init lirc_dev_init(void)
+{
+	int i;
+
+	for (i=0; i < MAX_IRCTL_DEVICES; ++i) {
+		init_irctl(&irctls[i]);
+	}
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+	driver_register(&lirc_driver);
+#endif
+	if(register_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME, &fops)) {
+		printk(KERN_ERR "lirc_dev: register_chrdev failed\n");
+		goto out;
+	}
+
+	lirc_class = class_simple_create(THIS_MODULE, "lirc");
+	if(IS_ERR(lirc_class)) {
+		printk(KERN_ERR "lirc_dev: class_simple_create failed\n");
+		goto out_unregister;
+	}
+
+	printk("lirc_dev: IR Remote Control driver registered, at major %d \n",
+	       IRCTL_DEV_MAJOR);
+
+	return SUCCESS;
+
+out_unregister:
+	if(unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME))
+		printk(KERN_ERR "lirc_dev: unregister_chrdev failed!\n");
+out:
+	return -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ *
+ */
+void __exit lirc_dev_exit(void)
+{
+	int ret;
+
+#if defined(CONFIG_ST_LIRC) || defined(MODULE)
+	driver_unregister(&lirc_driver);
+#endif
+	ret = unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+	class_simple_destroy(lirc_class);
+
+	if(ret)
+		printk("lirc_dev: error in module_unregister_chrdev: %d\n", ret);
+	else
+		dprintk("lirc_dev: module successfully unloaded\n");
+}
+
+MODULE_DESCRIPTION("LIRC base driver module");
+MODULE_AUTHOR("Artur Lipowski");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(IRCTL_DEV_MAJOR);
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Enable debugging messages");
+
+module_init(lirc_dev_init);
+module_exit(lirc_dev_exit);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_dev.h linux-2.6.17.8-sh/drivers/char/lirc/lirc_dev.h
--- linux-2.6.17.8/drivers/char/lirc/lirc_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_dev.h	2006-08-23 13:29:38.419599000 +0100
@@ -0,0 +1,245 @@
+/*
+ * LIRC base driver
+ *
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *        This code is licensed under GNU GPL
+ *
+ * $Id: lirc_dev.h,v 1.16 2005/02/19 15:30:20 lirc Exp $
+ *
+ */
+
+#ifndef _LINUX_LIRC_DEV_H
+#define _LINUX_LIRC_DEV_H
+
+#define MAX_IRCTL_DEVICES 4
+#define BUFLEN            16
+
+//#define LIRC_BUFF_POWER_OF_2
+#ifdef LIRC_BUFF_POWER_OF_2
+#define mod(n, div) ((n) & ((div) -1))
+#else
+#define mod(n, div) ((n) % (div))
+#endif
+#include <linux/slab.h>
+#include <linux/fs.h>
+struct lirc_buffer
+{
+        wait_queue_head_t wait_poll;
+	spinlock_t lock;
+
+	unsigned char *data;
+	unsigned int chunk_size;
+	unsigned int size; /* in chunks */
+	unsigned int fill; /* in chunks */
+	int head, tail;    /* in chunks */
+	/* Using chunks instead of bytes pretends to simplify boundary checking
+	 * And should allow for some performance fine tunning later */
+};
+static inline int lirc_buffer_init(struct lirc_buffer *buf,
+				    unsigned int chunk_size,
+				    unsigned int size)
+{
+	/* Adjusting size to the next power of 2 would allow for
+	 * inconditional LIRC_BUFF_POWER_OF_2 optimization */
+	init_waitqueue_head(&buf->wait_poll);
+	spin_lock_init(&buf->lock);
+	buf->head = buf->tail = buf->fill = 0;
+	buf->chunk_size = chunk_size;
+	buf->size = size;
+	buf->data = kmalloc(size*chunk_size, GFP_KERNEL);
+	if (buf->data == NULL)
+		return -1;
+	memset(buf->data, 0, size*chunk_size);
+	return 0;
+}
+static inline void lirc_buffer_free(struct lirc_buffer *buf)
+{
+	kfree(buf->data);
+	buf->data = NULL;
+	buf->head = buf->tail = buf->fill = 0;
+	buf->chunk_size = 0;
+	buf->size = 0;
+}
+static inline int  lirc_buffer_full(struct lirc_buffer *buf)
+{
+	return (buf->fill >= buf->size);
+}
+static inline int  lirc_buffer_empty(struct lirc_buffer *buf)
+{
+	return !(buf->fill);
+}
+static inline int  lirc_buffer_available(struct lirc_buffer *buf)
+{
+    return (buf->size - buf->fill);
+}
+static inline void lirc_buffer_lock(struct lirc_buffer *buf, unsigned long *flags)
+{
+	spin_lock_irqsave(&buf->lock, *flags);
+}
+static inline void lirc_buffer_unlock(struct lirc_buffer *buf, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&buf->lock, *flags);
+}
+static inline void _lirc_buffer_remove_1(struct lirc_buffer *buf)
+{
+	buf->head = mod(buf->head+1, buf->size);
+	buf->fill -= 1;
+}
+static inline void lirc_buffer_remove_1(struct lirc_buffer *buf)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_remove_1(buf);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_read_1(struct lirc_buffer *buf,
+				     unsigned char *dest)
+{
+	memcpy(dest, &buf->data[buf->head*buf->chunk_size], buf->chunk_size);
+	buf->head = mod(buf->head+1, buf->size);
+	buf->fill -= 1;
+}
+static inline void lirc_buffer_read_1(struct lirc_buffer *buf,
+				      unsigned char *dest)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_read_1(buf, dest);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_write_1(struct lirc_buffer *buf,
+				      unsigned char *orig)
+{
+	memcpy(&buf->data[buf->tail*buf->chunk_size], orig, buf->chunk_size);
+	buf->tail = mod(buf->tail+1, buf->size);
+	buf->fill++;
+}
+static inline void lirc_buffer_write_1(struct lirc_buffer *buf,
+				       unsigned char *orig)
+{
+	unsigned long flags;
+	lirc_buffer_lock(buf, &flags);
+	_lirc_buffer_write_1(buf, orig);
+	lirc_buffer_unlock(buf, &flags);
+}
+static inline void _lirc_buffer_write_n(struct lirc_buffer *buf,
+					unsigned char* orig, int count)
+{
+	memcpy(&buf->data[buf->tail*buf->chunk_size], orig,
+	       count*buf->chunk_size);
+	buf->tail = mod(buf->tail+count, buf->size);
+	buf->fill += count;
+}
+static inline void lirc_buffer_write_n(struct lirc_buffer *buf,
+				       unsigned char* orig, int count)
+{
+	unsigned long flags;
+	int space1;
+	lirc_buffer_lock(buf,&flags);
+	if( buf->head > buf->tail ) space1 = buf->head - buf->tail;
+	else space1 = buf->size - buf->tail;
+
+	if( count > space1 )
+	{
+		_lirc_buffer_write_n(buf, orig, space1);
+		_lirc_buffer_write_n(buf, orig+(space1*buf->chunk_size),
+				     count-space1);
+	}
+	else
+	{
+		_lirc_buffer_write_n(buf, orig, count);
+	}
+	lirc_buffer_unlock(buf, &flags);
+}
+
+struct lirc_plugin
+{
+	char name[40];
+	int minor;
+	int code_length;
+	int sample_rate;
+	unsigned long features;
+	void* data;
+	int (*add_to_buf) (void* data, struct lirc_buffer* buf);
+	wait_queue_head_t* (*get_queue) (void* data);
+	struct lirc_buffer *rbuf;
+	int (*set_use_inc) (void* data);
+	void (*set_use_dec) (void* data);
+	int (*ioctl) (struct inode *,struct file *,unsigned int,
+		      unsigned long);
+	struct file_operations *fops;
+	struct module *owner;
+};
+/* name:
+ * this string will be used for logs
+ *
+ * minor:
+ * indicates minor device (/dev/lirc) number for registered plugin
+ * if caller fills it with negative value, then the first free minor
+ * number will be used (if available)
+ *
+ * code_length:
+ * length of the remote control key code expressed in bits
+ *
+ * sample_rate:
+ * sample_rate equal to 0 means that no polling will be performed and
+ * add_to_buf will be triggered by external events (through task queue
+ * returned by get_queue)
+ *
+ * data:
+ * it may point to any plugin data and this pointer will be passed to
+ * all callback functions
+ *
+ * add_to_buf:
+ * add_to_buf will be called after specified period of the time or
+ * triggered by the external event, this behavior depends on value of
+ * the sample_rate this function will be called in user context. This
+ * routine should return 0 if data was added to the buffer and
+ * -ENODATA if none was available. This should add some number of bits
+ * evenly divisible by code_length to the buffer
+ *
+ * get_queue:
+ * this callback should return a pointer to the task queue which will
+ * be used for external event waiting
+ *
+ * rbuf:
+ * if not NULL, it will be used as a read buffer, you will have to
+ * write to the buffer by other means, like irq's (see also
+ * lirc_serial.c).
+ *
+ * set_use_inc:
+ * set_use_inc will be called after device is opened
+ *
+ * set_use_dec:
+ * set_use_dec will be called after device is closed
+ *
+ * ioctl:
+ * Some ioctl's can be directly handled by lirc_dev but will be
+ * forwared here if not NULL and only handled if it returns
+ * -ENOIOCTLCMD (see also lirc_serial.c).
+ *
+ * fops:
+ * file_operations for drivers which don't fit the current plugin model.
+ *
+ * owner:
+ * the module owning this struct
+ *
+ */
+
+
+/* following functions can be called ONLY from user context
+ *
+ * returns negative value on error or minor number
+ * of the registered device if success
+ * contens of the structure pointed by p is copied
+ */
+extern int lirc_register_plugin(struct lirc_plugin *p);
+
+/* returns negative value on error or 0 if success
+*/
+extern int lirc_unregister_plugin(int minor);
+
+/* ST extension to device module */
+extern void* lirc_get_config(void);
+
+#endif
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_gpio.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_gpio.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_gpio.c	2006-08-23 13:29:33.895484000 +0100
@@ -0,0 +1,546 @@
+/*
+ * Remote control driver for the TV-card
+ * key codes are obtained from GPIO port
+ *
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *     patch for the AverMedia by Santiago Garcia Mantinan <manty@i.am>
+ *                            and Christoph Bartelmus <lirc@bartelmus.de>
+ *     patch for the BestBuy by Miguel Angel Alvarez <maacruz@navegalia.com>
+ *     patch for the Winfast TV2000 by Juan Toledo
+ *     <toledo@users.sourceforge.net>
+ *     patch for the I-O Data GV-BCTV5/PCI by Jens C. Rasmussen
+ *     <jens.rasmussen@ieee.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: lirc_gpio.c,v 1.34 2003/11/02 15:38:34 lirc Exp $
+ *
+ */
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+
+#include "../../media/video/bttv.h"
+#include "../../media/video/bttvp.h"
+
+#include "lirc_dev.h"
+
+static int debug = 0;
+static int card = 0;
+static int minor = -1;
+static int bttv_id = BTTV_UNKNOWN;
+static unsigned long gpio_mask = 0;
+static unsigned long gpio_enable = 0;
+static unsigned long gpio_lock_mask = 0;
+static unsigned long gpio_xor_mask = 0;
+static unsigned int soft_gap = 0;
+static unsigned char sample_rate = 10;
+
+MODULE_PARM(debug,"i");
+MODULE_PARM(card,"i");
+MODULE_PARM(minor,"i");
+MODULE_PARM(gpio_mask,"l");
+MODULE_PARM(gpio_lock_mask,"l");
+MODULE_PARM(gpio_xor_mask,"l");
+MODULE_PARM(soft_gap,"i");
+MODULE_PARM(sample_rate,"b");
+MODULE_PARM(bttv_id,"i");
+
+#undef dprintk
+#define dprintk  if (debug) printk
+
+struct rcv_info {
+	int bttv_id;
+	int card_id;
+	unsigned long gpio_mask;
+	unsigned long gpio_enable;
+	unsigned long gpio_lock_mask;
+	unsigned long gpio_xor_mask;
+	unsigned int soft_gap;
+	unsigned char sample_rate;
+	unsigned char code_length;
+};
+
+static struct rcv_info rcv_infos[] = {
+	{BTTV_UNKNOWN,                0,          0,          0,         0,          0,   0,  1,  0},
+	{BTTV_PXELVWPLTVPAK,          0, 0x00003e00,          0, 0x0010000,          0,   0, 15, 32},
+	{BTTV_PXELVWPLTVPRO,          0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_PV_BT878P_9B,           0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_PV_BT878P_PLUS,         0, 0x00001f00,          0, 0x0008000,          0, 500, 12, 32},
+	{BTTV_AVERMEDIA,              0, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32},
+	{BTTV_AVPHONE98,     0x00011461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
+	{BTTV_AVERMEDIA98,   0x00021461, 0x003b8000, 0x00004000, 0x0800000, 0x00800000,   0, 10,  0}, /*mapped to Capture98*/
+	{BTTV_AVPHONE98,     0x00031461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* is this one correct? */
+	{BTTV_AVERMEDIA98,   0x00041461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* work-around for VDOMATE */
+	{BTTV_AVERMEDIA98,   0x03001461, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	/* reported by Danijel Korzinek, AVerTV GOw/FM */
+	{BTTV_AVERMEDIA98,   0x00000000, 0x00f88000,          0, 0x0010000, 0x00010000,   0, 10, 32}, /*mapped to Phone98*/
+	{BTTV_CHRONOS_VS2,            0, 0x000000f8,          0, 0x0000100,          0,   0, 20,  0},
+	/* CPH031 and CPH033 cards (?) */
+	/* MIRO was just a work-around */
+	{BTTV_MIRO,                   0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+	{BTTV_DYNALINK,               0, 0x00001f00,          0, 0x0004000,          0,   0, 10, 32},
+	{BTTV_WINVIEW_601,            0, 0x00001f00,          0, 0x0004000,          0,   0,  0, 32},
+#ifdef BTTV_KWORLD
+	{BTTV_KWORLD,                 0, 0x00007f00,          0, 0x0004000,          0,   0, 12, 32},
+#endif
+	/* just a guess */
+	{BTTV_MAGICTVIEW061,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+ 	{BTTV_MAGICTVIEW063,          0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+ 	{BTTV_PHOEBE_TVMAS,           0, 0x0028e000,          0, 0x0020000,          0,   0, 20, 32},
+#ifdef BTTV_BESTBUY_EASYTV2
+        {BTTV_BESTBUY_EASYTV,         0, 0x00007F00,          0, 0x0004000,          0,   0, 10,  8},
+        {BTTV_BESTBUY_EASYTV2,        0, 0x00007F00,          0, 0x0008000,          0,   0, 10,  8},
+#endif
+	/* lock_mask probably also 0x100, or maybe it is 0x0 for all others !?! */
+	{BTTV_FLYVIDEO,               0, 0x000000f8,          0,         0,          0,   0,  0, 42},
+ 	{BTTV_FLYVIDEO_98,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+ 	{BTTV_TYPHOON_TVIEW,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+#ifdef BTTV_FLYVIDEO_98FM
+	/* smorar@alfonzo.smuts.uct.ac.za */
+	{BTTV_FLYVIDEO_98FM,          0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 42},
+#endif
+	/* The Leadtek WinFast TV 2000 XP card (id 0x6606107d) uses an
+	 * extra gpio bit compared to the original TV 2000 card (id
+	 * 0x217d6606); as the bttv-0.7.100 driver does not
+	 * distinguish between the two cards, we enable the extra bit
+	 * based on the card id: */
+	{BTTV_WINFAST2000,   0x6606107d, 0x000008f8,          0, 0x0000100,          0,   0,  0, 32},
+	/* default: */
+	{BTTV_WINFAST2000,            0, 0x000000f8,          0, 0x0000100,          0,   0,  0, 32},
+#ifdef BTTV_GVBCTV5PCI
+	{BTTV_GVBCTV5PCI,             0, 0x00f0b000,          0,         0,          0,   0, 20,  8},
+#endif
+};
+
+static unsigned char code_length = 0;
+static unsigned char code_bytes = 1;
+
+#define MAX_BYTES 8
+
+#define SUCCESS 0
+#define LOGHEAD "lirc_gpio (%d): "
+
+/* how many bits GPIO value can be shifted right before processing
+ * it is computed from the value of gpio_mask_parameter
+ */
+static unsigned char gpio_pre_shift = 0;
+
+
+static inline int reverse(int data, int bits)
+{
+	int i;
+	int c;
+
+	for (c=0,i=0; i<bits; i++) {
+		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
+	}
+
+	return c;
+}
+
+static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
+{
+	unsigned long mask = gpio_mask;
+	unsigned char shift = 0;
+
+	dprintk(LOGHEAD "gpio_val is %lx\n",card,(unsigned long) gpio_val);
+
+	gpio_val ^= gpio_xor_mask;
+
+	if (gpio_lock_mask && (gpio_val & gpio_lock_mask)) {
+		return -EBUSY;
+	}
+
+	switch (bttv_id)
+	{
+	case BTTV_AVERMEDIA98:
+		if (bttv_write_gpio(card, gpio_enable, gpio_enable)) {
+			dprintk(LOGHEAD "cannot write to GPIO\n", card);
+			return -EIO;
+		}
+		if (bttv_read_gpio(card, &gpio_val)) {
+			dprintk(LOGHEAD "cannot read GPIO\n", card);
+			return -EIO;
+		}
+		if (bttv_write_gpio(card, gpio_enable, 0)) {
+			dprintk(LOGHEAD "cannot write to GPIO\n", card);
+			return -EIO;
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* extract bits from "raw" GPIO value using gpio_mask */
+	codes[0] = 0;
+	gpio_val >>= gpio_pre_shift;
+	while (mask) {
+		if (mask & 1u) {
+			codes[0] |= (gpio_val & 1u) << shift++;
+		}
+		mask >>= 1;
+		gpio_val >>= 1;
+	}
+
+	dprintk(LOGHEAD "code is %lx\n",card,(unsigned long) codes[0]);
+	switch (bttv_id)
+	{
+	case BTTV_AVERMEDIA:
+		codes[2] = (codes[0]<<2)&0xff;
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0x02;
+		codes[1] = 0xFD;
+		break;
+	case BTTV_AVPHONE98:
+		codes[2] = ((codes[0]&(~0x1))<<2)&0xff;
+		codes[3] = (~codes[2])&0xff;
+		if (codes[0]&0x1) {
+			codes[0] = 0xc0;
+			codes[1] = 0x3f;
+		} else {
+			codes[0] = 0x40;
+			codes[1] = 0xbf;
+		}
+		break;
+	case BTTV_AVERMEDIA98:
+		break;
+	case BTTV_FLYVIDEO:
+	case BTTV_FLYVIDEO_98:
+	case BTTV_TYPHOON_TVIEW:
+#ifdef BTTV_FLYVIDEO_98FM
+	case BTTV_FLYVIDEO_98FM:
+#endif
+		codes[4]=codes[0]<<3;
+		codes[5]=((~codes[4])&0xff);
+
+		codes[0]=0x00;
+		codes[1]=0x1A;
+		codes[2]=0x1F;
+		codes[3]=0x2F;
+		break;
+        case BTTV_MAGICTVIEW061:
+        case BTTV_MAGICTVIEW063:
+	case BTTV_PHOEBE_TVMAS:
+		codes[0] = (codes[0]&0x01)
+			|((codes[0]&0x02)<<1)
+			|((codes[0]&0x04)<<2)
+			|((codes[0]&0x08)>>2)
+			|((codes[0]&0x10)>>1);
+		/* FALLTHROUGH */
+	case BTTV_MIRO:
+	case BTTV_DYNALINK:
+	case BTTV_PXELVWPLTVPAK:
+	case BTTV_PXELVWPLTVPRO:
+	case BTTV_PV_BT878P_9B:
+	case BTTV_PV_BT878P_PLUS:
+#ifdef BTTV_KWORLD
+	case BTTV_KWORLD:
+#endif
+		codes[2] = reverse(codes[0],8);
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0x61;
+		codes[1] = 0xD6;
+		break;
+#if 0
+		/* derived from e-tech config file */
+		/* 26 + 16 bits */
+		/* won't apply it until it's confirmed with a fly98 */
+ 	case BTTV_FLYVIDEO_98:
+	case BTTV_FLYVIDEO_98FM:
+		codes[4]=codes[0]<<3;
+		codes[5]=(~codes[4])&0xff;
+
+		codes[0]=0x00;
+		codes[1]=0x1A;
+		codes[2]=0x1F;
+		codes[3]=0x2F;
+		break;
+#endif
+	case BTTV_WINFAST2000:
+		/* shift extra bit */
+		codes[0] = (codes[0]&0x1f) | ((codes[0]&0x20) << 1);
+	case BTTV_WINVIEW_601:
+		codes[2] = reverse(codes[0],8);
+		codes[3] = (~codes[2])&0xff;
+		codes[0] = 0xC0;
+		codes[1] = 0x3F;
+		break;
+	default:
+		break;
+	}
+
+	return SUCCESS;
+}
+
+/* add_to_buf - copy a code to the buffer */
+static int add_to_buf(void* data, struct lirc_buffer* buf)
+{
+	static unsigned long next_time = 0;
+	static unsigned char prev_codes[MAX_BYTES];
+	unsigned long code = 0;
+	unsigned char cur_codes[MAX_BYTES];
+
+	if (bttv_read_gpio(card, &code)) {
+		dprintk(LOGHEAD "cannot read GPIO\n", card);
+		return -EIO;
+	}
+
+	if (build_key(code, cur_codes)) {
+		return -EFAULT;
+	}
+
+
+	/* XXX this should be double checked; i think the soft_gap
+	 * here is supposed to track repeats, which is why i save off
+	 * the prev_codes, but i'm not certain this is correct
+	 */
+	if (soft_gap) {
+		if (!memcmp(prev_codes, cur_codes, code_bytes) &&
+			jiffies < next_time) {
+			return -EAGAIN;
+		}
+		next_time = jiffies + soft_gap;
+	}
+	memcpy( prev_codes, cur_codes, code_bytes );
+
+	lirc_buffer_write_1( buf, cur_codes );
+
+	return SUCCESS;
+}
+
+static int set_use_inc(void* data)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	module_put(THIS_MODULE);
+}
+
+static wait_queue_head_t* get_queue(void* data)
+{
+	return bttv_get_gpio_queue(card);
+}
+
+static struct lirc_plugin plugin = {
+	.name		= "lirc_gpio  ",
+	.add_to_buf	= add_to_buf,
+	.get_queue	= get_queue,
+	.set_use_inc	= set_use_inc,
+	.set_use_dec	= set_use_dec,
+};
+
+/*
+ *
+ */
+int gpio_remote_init(void)
+{
+	int ret;
+	unsigned int mask;
+
+	/* "normalize" gpio_mask
+	 * this means shift it right until first bit is set
+	 */
+	while (!(gpio_mask & 1u)) {
+		gpio_pre_shift++;
+		gpio_mask >>= 1;
+	}
+
+	if (code_length) {
+		plugin.code_length = code_length;
+	} else {
+		/* calculate scan code length in bits if needed */
+		plugin.code_length = 1;
+		mask = gpio_mask >> 1;
+		while (mask) {
+			if (mask & 1u) {
+				plugin.code_length++;
+			}
+			mask >>= 1;
+		}
+	}
+
+	code_bytes = (plugin.code_length/8) + (plugin.code_length%8 ? 1 : 0);
+	if (MAX_BYTES < code_bytes) {
+		printk (LOGHEAD "scan code too long (%d bytes)\n",
+			minor, code_bytes);
+		return -EBADRQC;
+	}
+
+	if (gpio_enable) {
+		if(bttv_gpio_enable(card, gpio_enable, gpio_enable)) {
+			printk(LOGHEAD "gpio_enable failure\n", minor);
+			return -EIO;
+		}
+	}
+
+
+	/* translate ms to jiffies */
+	soft_gap = (soft_gap*HZ) / 1000;
+
+	plugin.minor = minor;
+	plugin.sample_rate = sample_rate;
+
+	ret = lirc_register_plugin(&plugin);
+
+	if (0 > ret) {
+		printk (LOGHEAD "device registration failed with %d\n",
+			minor, ret);
+		return ret;
+	}
+
+	minor = ret;
+	printk(LOGHEAD "driver registered\n", minor);
+
+	return SUCCESS;
+}
+
+static int __init lirc_gpio_init(void)
+{
+	int type,cardid,card_type;
+
+	if (CONFIG_LIRC_MAX_DEV < minor) {
+		printk("lirc_gpio: parameter minor (%d) must be less than %d!\n",
+		       minor, CONFIG_LIRC_MAX_DEV-1);
+		return -EBADRQC;
+	}
+
+	request_module("bttv");
+
+	/* if gpio_mask not zero then use module parameters
+	 * instead of autodetecting TV card
+	 */
+	if (gpio_mask) {
+		if (sample_rate!=0 && (2 > sample_rate || 50 < sample_rate)) {
+			printk(LOGHEAD "parameter sample_rate "
+			       "must be beetween 2 and 50!\n", minor);
+			return -EBADRQC;
+		}
+
+		if (sample_rate!=0 && soft_gap &&
+		    ((2000/sample_rate) > soft_gap || 1000 < soft_gap)) {
+			printk(LOGHEAD "parameter soft_gap "
+			       "must be beetween %d and 1000!\n",
+			       minor, 2000/sample_rate);
+			return -EBADRQC;
+		}
+	} else {
+		if(bttv_get_cardinfo(card,&type,&cardid)==-1) {
+			printk(LOGHEAD "could not get card type\n", minor);
+		}
+		printk(LOGHEAD "card type 0x%x, id 0x%x\n",minor,
+		       type,cardid);
+
+		if (type == BTTV_UNKNOWN) {
+			printk(LOGHEAD "cannot detect TV card nr %d!\n",
+			       minor, card);
+			return -EBADRQC;
+		}
+		for (card_type = 1;
+		     card_type < sizeof(rcv_infos)/sizeof(struct rcv_info);
+		     card_type++) {
+			if (rcv_infos[card_type].bttv_id == type &&
+			    (rcv_infos[card_type].card_id == 0 ||
+			     rcv_infos[card_type].card_id == cardid)) {
+				bttv_id = rcv_infos[card_type].bttv_id;
+				gpio_mask = rcv_infos[card_type].gpio_mask;
+				gpio_enable = rcv_infos[card_type].gpio_enable;
+				gpio_lock_mask = rcv_infos[card_type].gpio_lock_mask;
+				gpio_xor_mask = rcv_infos[card_type].gpio_xor_mask;
+				soft_gap = rcv_infos[card_type].soft_gap;
+				sample_rate = rcv_infos[card_type].sample_rate;
+				code_length = rcv_infos[card_type].code_length;
+				break;
+			}
+		}
+		if (type==BTTV_AVPHONE98 && cardid==0x00011461)	{
+			bttv_id = BTTV_AVERMEDIA98;
+		}
+		if (type==BTTV_AVERMEDIA98 && cardid==0x00041461) {
+			bttv_id = BTTV_AVPHONE98;
+		}
+		if (type==BTTV_AVERMEDIA98 && cardid==0x03001461) {
+			bttv_id = BTTV_AVPHONE98;
+		}
+		if (type==BTTV_AVERMEDIA98 && cardid==0x00000000) {
+			bttv_id = BTTV_AVPHONE98;
+		}
+		if (card_type == sizeof(rcv_infos)/sizeof(struct rcv_info)) {
+			printk(LOGHEAD "TV card type 0x%x not supported!\n",
+			       minor, type);
+			return -EBADRQC;
+		}
+	}
+
+	request_module("lirc_dev");
+
+	return gpio_remote_init();
+}
+
+void __exit lirc_gpio_exit(void)
+{
+	int ret;
+
+	ret = lirc_unregister_plugin(minor);
+
+	if (0 > ret) {
+		printk(LOGHEAD "error in lirc_unregister_minor: %d\n"
+		       "Trying again...\n",
+		       minor, ret);
+
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ);
+
+		ret = lirc_unregister_plugin(minor);
+
+		if (0 > ret) {
+			printk(LOGHEAD "error in lirc_unregister_minor: %d!!!\n",
+			       minor, ret);
+			return;
+		}
+	}
+
+	dprintk(LOGHEAD "module successfully unloaded\n", minor);
+}
+
+MODULE_DESCRIPTION("Driver module for remote control (data from bt848 GPIO port)");
+MODULE_AUTHOR("Artur Lipowski");
+MODULE_LICENSE("GPL");
+
+#ifdef MODULE
+	module_init(lirc_gpio_init);
+#else
+	late_initcall(lirc_gpio_init);
+#endif
+module_exit(lirc_gpio_exit);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc.h linux-2.6.17.8-sh/drivers/char/lirc/lirc.h
--- linux-2.6.17.8/drivers/char/lirc/lirc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc.h	2006-08-23 13:29:38.425599000 +0100
@@ -0,0 +1,105 @@
+/*      $Id: lirc.h,v 5.9 2005/02/27 15:05:39 lirc Exp $      */
+
+#ifndef _LINUX_LIRC_H
+#define _LINUX_LIRC_H
+
+#if defined (__linux__)
+#include <asm/types.h>
+#include <linux/ioctl.h>
+#else
+#include <sys/types.h>
+typedef u_int32_t __u32;
+#endif
+
+#define PULSE_BIT  0x01000000
+#define PULSE_MASK 0x00FFFFFF
+
+typedef int lirc_t;
+
+#define DEV_LIRC        		"lirc"
+#define LIRC_MAJOR              	61
+#define IRCTL_DEV_MAJOR              	61
+
+/*
+ * lirc compatible hardware features
+ */
+
+
+#define LIRC_MODE2SEND(x) (x)
+#define LIRC_SEND2MODE(x) (x)
+#define LIRC_MODE2REC(x) ((x) << 16)
+#define LIRC_REC2MODE(x) ((x) >> 16)
+
+#define LIRC_MODE_RAW                  0x00000001
+#define LIRC_MODE_PULSE                0x00000002
+#define LIRC_MODE_MODE2                0x00000004
+#define LIRC_MODE_CODE                 0x00000008
+#define LIRC_MODE_LIRCCODE             0x00000010
+#define LIRC_MODE_STRING               0x00000020
+
+
+#define LIRC_CAN_SEND_RAW              LIRC_MODE2SEND(LIRC_MODE_RAW)
+#define LIRC_CAN_SEND_PULSE            LIRC_MODE2SEND(LIRC_MODE_PULSE)
+#define LIRC_CAN_SEND_MODE2            LIRC_MODE2SEND(LIRC_MODE_MODE2)
+#define LIRC_CAN_SEND_CODE             LIRC_MODE2SEND(LIRC_MODE_CODE)
+#define LIRC_CAN_SEND_LIRCCODE         LIRC_MODE2SEND(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_SEND_STRING           LIRC_MODE2SEND(LIRC_MODE_STRING)
+
+#define LIRC_CAN_SEND_MASK             0x0000003f
+
+#define LIRC_CAN_SET_SEND_CARRIER      0x00000100
+#define LIRC_CAN_SET_SEND_DUTY_CYCLE   0x00000200
+
+#define LIRC_CAN_REC_RAW               LIRC_MODE2REC(LIRC_MODE_RAW)
+#define LIRC_CAN_REC_PULSE             LIRC_MODE2REC(LIRC_MODE_PULSE)
+#define LIRC_CAN_REC_MODE2             LIRC_MODE2REC(LIRC_MODE_MODE2)
+#define LIRC_CAN_REC_CODE              LIRC_MODE2REC(LIRC_MODE_CODE)
+#define LIRC_CAN_REC_LIRCCODE          LIRC_MODE2REC(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_REC_STRING            LIRC_MODE2REC(LIRC_MODE_STRING)
+
+#define LIRC_CAN_REC_MASK              LIRC_MODE2REC(LIRC_CAN_SEND_MASK)
+
+#define LIRC_CAN_SET_REC_CARRIER       (LIRC_CAN_SET_SEND_CARRIER << 16)
+#define LIRC_CAN_SET_REC_DUTY_CYCLE    (LIRC_CAN_SET_SEND_DUTY_CYCLE << 16)
+
+#define LIRC_CAN_SET_REC_DUTY_CYCLE_RANGE 0x40000000
+#define LIRC_CAN_SET_REC_CARRIER_RANGE    0x80000000
+
+
+#define LIRC_CAN_SEND(x) ((x)&LIRC_CAN_SEND_MASK)
+#define LIRC_CAN_REC(x) ((x)&LIRC_CAN_REC_MASK)
+
+/*
+ * IOCTL commands for lirc driver
+ */
+
+#define LIRC_GET_FEATURES              _IOR('i', 0x00000000, __u32)
+
+#define LIRC_GET_SEND_MODE             _IOR('i', 0x00000001, __u32)
+#define LIRC_GET_REC_MODE              _IOR('i', 0x00000002, __u32)
+#define LIRC_GET_SEND_CARRIER          _IOR('i', 0x00000003, __u32)
+#define LIRC_GET_REC_CARRIER           _IOR('i', 0x00000004, __u32)
+#define LIRC_GET_SEND_DUTY_CYCLE       _IOR('i', 0x00000005, __u32)
+#define LIRC_GET_REC_DUTY_CYCLE        _IOR('i', 0x00000006, __u32)
+#define LIRC_GET_REC_RESOLUTION        _IOR('i', 0x00000007, __u32)
+
+/* code length in bits, currently only for LIRC_MODE_LIRCCODE */
+#define LIRC_GET_LENGTH                _IOR('i', 0x0000000f, __u32)
+
+#define LIRC_SET_SEND_MODE             _IOW('i', 0x00000011, __u32)
+#define LIRC_SET_REC_MODE              _IOW('i', 0x00000012, __u32)
+/* Note: these can reset the according pulse_width */
+#define LIRC_SET_SEND_CARRIER          _IOW('i', 0x00000013, __u32)
+#define LIRC_SET_REC_CARRIER           _IOW('i', 0x00000014, __u32)
+#define LIRC_SET_SEND_DUTY_CYCLE       _IOW('i', 0x00000015, __u32)
+#define LIRC_SET_REC_DUTY_CYCLE        _IOW('i', 0x00000016, __u32)
+
+/* to set a range use
+   LIRC_SET_REC_DUTY_CYCLE_RANGE/LIRC_SET_REC_CARRIER_RANGE with the
+   lower bound first and later
+   LIRC_SET_REC_DUTY_CYCLE/LIRC_SET_REC_CARRIER with the upper bound */
+
+#define LIRC_SET_REC_DUTY_CYCLE_RANGE  _IOW('i', 0x0000001e, __u32)
+#define LIRC_SET_REC_CARRIER_RANGE     _IOW('i', 0x0000001f, __u32)
+
+#endif
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_i2c.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_i2c.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_i2c.c	2006-08-23 13:29:33.907484000 +0100
@@ -0,0 +1,440 @@
+/*      $Id: lirc_i2c.c,v 1.22 2004/03/02 19:34:21 lirc Exp $      */
+
+/*
+ * i2c IR lirc plugin for Hauppauge and Pixelview cards - new 2.8.x i2c stack
+ *
+ * Copyright (c) 2000 Gerd Knorr <kraxel@goldbach.in-berlin.de>
+ * modified for PixelView (BT878P+W/FM) by
+ *      Michal Kochanowicz <mkochano@pld.org.pl>
+ *      Christoph Bartelmus <lirc@bartelmus.de>
+ * modified for KNC ONE TV Station/Anubis Typhoon TView Tuner by
+ *      Ulrich Mueller <ulrich.mueller42@web.de>
+ * modified for Asus TV-Box and Creative/VisionTek BreakOut-Box by
+ *      Stefan Jahn <stefan@lkcc.org>
+ * modified for Linux 2.6 by
+ * 	Jeffrey Clark <jeff@clarkmania.com>
+ *
+ * parts are cut&pasted from the old lirc_haup.c driver
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <asm/semaphore.h>
+
+#include "../../media/video/bttv.h"
+
+#include "lirc_dev.h"
+
+static unsigned short normal_i2c[] = { 0x1a, 0x18, 0x4b, 0x64, 0x30, 0x21, 0x23, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+static unsigned short probe[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c             = normal_i2c,
+	.normal_i2c_range       = normal_i2c_range,
+	.probe                  = probe,
+	.probe_range            = probe_range,
+	.ignore                 = ignore,
+	.ignore_range           = ignore_range,
+	.force                  = force
+};
+
+struct i2c_ir {
+	struct lirc_plugin lirc;
+	struct i2c_client client;
+	int nextkey;
+	unsigned char b[3];
+	unsigned char bits;
+	unsigned char flag;
+};
+
+/* ----------------------------------------------------------------------- */
+/* insmod parameters                                                       */
+
+static int debug   = 0;    /* debug output */
+static int minor   = -1;   /* minor number */
+
+MODULE_PARM(debug,"i");
+MODULE_PARM(minor,"i");
+
+MODULE_DESCRIPTION("Infrared receiver driver for Hauppauge and Pixelview cards (i2c stack)");
+MODULE_AUTHOR("Gerd Knorr, Michal Kochanowicz, Christoph Bartelmus, Ulrich Mueller, Stefan Jahn, Jeffrey Clark");
+MODULE_LICENSE("GPL");
+
+#define dprintk if (debug) printk
+
+/* ----------------------------------------------------------------------- */
+
+#define DRIVER_NAME "lirc_i2c"
+#define DEVICE_NAME DRIVER_NAME
+
+/* ----------------------------------------------------------------------- */
+
+static inline int reverse(int data, int bits)
+{
+	int i;
+	int c;
+
+	for (c=0,i=0; i<bits; i++) {
+		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
+	}
+
+	return c;
+}
+
+static int add_to_buf_pcf8574(void* data, struct lirc_buffer* buf)
+{
+	struct i2c_ir *ir = data;
+	int rc;
+	unsigned char all, mask;
+	unsigned char key;
+
+	/* compute all valid bits (key code + pressed/release flag) */
+	all = ir->bits | ir->flag;
+
+	/* save IR writable mask bits */
+	mask = i2c_smbus_read_byte(&ir->client) & ~all;
+
+	/* send bit mask */
+	rc = i2c_smbus_write_byte(&ir->client, (0xff & all) | mask);
+
+	/* receive scan code */
+	rc = i2c_smbus_read_byte(&ir->client);
+
+	if (rc == -1) {
+		/* should this return -EIO? */
+		dprintk(DEVICE_NAME ": %s read error\n", ir->client.name);
+		return -ENODATA;
+	}
+
+	/* drop duplicate polls */
+	if (ir->b[0] == (rc & all)) {
+		return -ENODATA;
+	}
+	ir->b[0] = rc & all;
+
+	dprintk(DRIVER_NAME ": %s key 0x%02X %s\n",
+		ir->client.name, rc & ir->bits,
+		(rc & ir->flag) ? "released" : "pressed");
+
+	if (rc & ir->flag) {
+		/* ignore released buttons */
+		return -ENODATA;
+	}
+
+	/* set valid key code */
+	key  = rc & ir->bits;
+	lirc_buffer_write_1( buf, &key );
+	return 0;
+}
+
+static int add_to_buf_haup(void* data, struct lirc_buffer* buf)
+{
+	struct i2c_ir *ir = data;
+        unsigned char keybuf[3];
+	__u16 code;
+	unsigned char codes[2];
+
+	/* poll IR chip */
+	if (3 == i2c_master_recv(&ir->client,keybuf,3)) {
+		ir->b[0] = keybuf[0];
+		ir->b[1] = keybuf[1];
+		ir->b[2] = keybuf[2];
+	} else {
+		dprintk(DRIVER_NAME ": read error\n");
+		/* keep last successfull read buffer */
+	}
+
+	/* key pressed ? */
+	if ((ir->b[0] & 0x80) == 0)
+		return -ENODATA;
+
+	dprintk(DRIVER_NAME ": key (0x%02x/0x%02x)\n",
+	ir->b[0], ir->b[1]);
+
+	/* look what we have */
+	code = (((__u16)ir->b[0]&0x7f)<<6) | (ir->b[1]>>2);
+
+	codes[0] = (code >> 8) & 0xff;
+	codes[1] = code & 0xff;
+
+	/* return it */
+	lirc_buffer_write_1( buf, codes );
+	return 0;
+}
+
+static int add_to_buf_pixelview(void* data, struct lirc_buffer* buf)
+{
+	struct i2c_ir *ir = data;
+	unsigned char key;
+
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->client,&key,1)) {
+		dprintk(DRIVER_NAME ": read error\n");
+		return -1;
+	}
+
+	dprintk(KERN_DEBUG DEVICE_NAME ": key %02x\n", key);
+
+	/* return it */
+	lirc_buffer_write_1( buf, &key );
+/* not sure where b came from
+ 	*key = b;
+*/
+	return 0;
+}
+
+static int add_to_buf_pv951(void* data, struct lirc_buffer* buf)
+{
+	struct i2c_ir *ir = data;
+	unsigned char key;
+	unsigned char codes[4];
+
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->client,&key,1)) {
+		dprintk(DRIVER_NAME ": read error\n");
+		return -ENODATA;
+	}
+	/* ignore 0xaa */
+	if (key==0xaa)
+		return -ENODATA;
+	dprintk(KERN_DEBUG DEVICE_NAME ": key %02x\n", key);
+
+	codes[3] = 0x61;
+	codes[2] = 0xD6;
+	codes[1] = reverse(key,8);
+	codes[0] = (~codes[2])&0xff;
+
+	lirc_buffer_write_1( buf, codes );
+	return 0;
+}
+
+static int add_to_buf_knc1(void *data, struct lirc_buffer* buf)
+{
+	static unsigned char last_key = 0xFF;
+	struct i2c_ir *ir = data;
+	unsigned char key;
+
+	/* poll IR chip */
+	if (1 != i2c_master_recv(&ir->client,&key,1)) {
+		dprintk(DRIVER_NAME ": read error\n");
+		return -ENODATA;
+	}
+
+	/* it seems that 0xFE indicates that a button is still hold
+	   down, while 0xFF indicates that no button is hold
+	   down. 0xFE sequences are sometimes interrupted by 0xFF */
+
+	dprintk(KERN_DEBUG DEVICE_NAME ": key %02x\n", key);
+
+	if( key == 0xFF )
+		return -ENODATA;
+
+	if ( key == 0xFE )
+		key = last_key;
+
+	last_key = key;
+	lirc_buffer_write_1( buf, &key );
+
+	return 0;
+}
+
+static int set_use_inc(void* data)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	module_put(THIS_MODULE);
+}
+
+static struct lirc_plugin lirc_template = {
+	.name =        "lirc_i2c",
+	.set_use_inc = set_use_inc,
+	.set_use_dec = set_use_dec
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int lirc_i2c_attach(struct i2c_adapter *adap, int addr, int kind);
+static int lirc_i2c_detach(struct i2c_client *client);
+static int lirc_i2c_probe(struct i2c_adapter *adap);
+
+static struct i2c_driver driver = {
+	.owner          = THIS_MODULE,
+        .name           = DRIVER_NAME,
+        .id             = I2C_DRIVERID_EXP3, /* FIXME */
+        .flags          = I2C_DF_NOTIFY,
+        .attach_adapter = lirc_i2c_probe,
+        .detach_client  = lirc_i2c_detach,
+};
+
+static struct i2c_client client_template =
+{
+        I2C_DEVNAME("(unset)"),
+	.flags  = I2C_CLIENT_ALLOW_USE,
+        .driver = &driver
+};
+
+static int lirc_i2c_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+        struct i2c_ir *ir;
+	int ret;
+
+        client_template.adapter = adap;
+        client_template.addr = addr;
+
+	if (NULL == (ir = kmalloc(sizeof(struct i2c_ir),GFP_KERNEL)))
+                return -ENOMEM;
+	memset(ir,0,sizeof(struct i2c_ir));
+	memcpy(&ir->client,&client_template,sizeof(struct i2c_client));
+        memcpy(&ir->lirc,&lirc_template,sizeof(struct lirc_plugin));
+
+	ir->lirc.data		= ir;
+	ir->lirc.minor		= minor;
+	ir->nextkey		= -1;
+
+	i2c_set_clientdata(&ir->client,ir);
+
+	switch(addr)
+	{
+	case 0x64:
+		strncpy(ir->client.name, "Pixelview IR", I2C_NAME_SIZE);
+		ir->lirc.code_length = 8;
+		ir->lirc.sample_rate = 10;
+		ir->lirc.add_to_buf = add_to_buf_pixelview;
+		break;
+	case 0x4b:
+		strncpy(ir->client.name,"PV951 IR", I2C_NAME_SIZE);
+		ir->lirc.code_length = 32;
+		ir->lirc.sample_rate = 10;
+		ir->lirc.add_to_buf = add_to_buf_pv951;
+		break;
+	case 0x18:
+	case 0x1a:
+		strncpy(ir->client.name,"Hauppauge IR", I2C_NAME_SIZE);
+		ir->lirc.code_length = 13;
+		ir->lirc.sample_rate = 6;
+		ir->lirc.add_to_buf = add_to_buf_haup;
+		break;
+	case 0x30:
+		strncpy(ir->client.name,"KNC ONE IR", I2C_NAME_SIZE);
+		ir->lirc.code_length = 8;
+		ir->lirc.sample_rate = 10;
+		ir->lirc.add_to_buf = add_to_buf_knc1;
+		break;
+	case 0x21:
+	case 0x23:
+		strncpy(ir->client.name,"TV-Box IR", I2C_NAME_SIZE);
+		ir->lirc.code_length = 8;
+		ir->lirc.sample_rate = 10;
+		ir->lirc.add_to_buf = add_to_buf_pcf8574;
+		ir->bits = ir->client.flags & 0xff;
+		ir->flag = (ir->client.flags >> 8) & 0xff;
+		break;
+
+	default:
+		/* shouldn't happen */
+		dprintk(DRIVER_NAME ": unknown i2c address (0x%02x)?\n",addr);
+		kfree(ir);
+		return -1;
+	}
+	dprintk(DRIVER_NAME ": chip found @ 0x%02x (%s)\n",addr,
+			ir->client.name);
+
+	/* register device */
+	i2c_attach_client(&ir->client);
+
+	if((ret = lirc_register_plugin(&ir->lirc))) {
+		dprintk(DRIVER_NAME ": device registration failed with %d\n",
+				ret);
+		kfree(ir);
+		return -1;
+	}
+
+	ir->lirc.minor = ret;
+	dprintk(DRIVER_NAME ": driver registered\n");
+
+	return 0;
+}
+
+static int lirc_i2c_detach(struct i2c_client *client)
+{
+        struct i2c_ir *ir = i2c_get_clientdata(client);
+	int err;
+
+	/* unregister device */
+	if ((err = lirc_unregister_plugin(ir->lirc.minor))) {
+		dprintk(DRIVER_NAME ": lirc unregister failed\n");
+		return err;
+	} else {
+		dprintk(DRIVER_NAME ": lirc unregister successful\n");
+	}
+
+	if ((err = i2c_detach_client(&ir->client))) {
+		dprintk(DRIVER_NAME ": i2c detach failed\n");
+		return err;
+	} else {
+		dprintk(DRIVER_NAME ": i2c detach successful\n");
+	}
+
+	/* free memory */
+	kfree(ir);
+	return 0;
+}
+
+static int lirc_i2c_probe(struct i2c_adapter *adap) {
+	dprintk(DRIVER_NAME ": starting probe for adapter %s (0x%x)\n",
+			adap->name, adap->id);
+	return i2c_probe(adap, &addr_data, lirc_i2c_attach);
+}
+
+static int __init lirc_i2c_init(void)
+{
+	dprintk(DRIVER_NAME ": init\n");
+	request_module("bttv");
+	request_module("lirc_dev");
+	return i2c_add_driver(&driver);
+}
+
+static void __exit lirc_i2c_exit(void)
+{
+	dprintk(DRIVER_NAME ": exit\n");
+	i2c_del_driver(&driver);
+}
+
+module_init(lirc_i2c_init);
+module_exit(lirc_i2c_exit);
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_it87.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_it87.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_it87.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_it87.c	2006-08-23 13:29:33.921485000 +0100
@@ -0,0 +1,957 @@
+/*
+ * LIRC driver for ITE IT8712/IT8705 CIR port
+ *
+ * Copyright (C) 2001 Hans-Gnter Ltke Uphues <hg_lu@web.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ * ITE IT8705 and IT8712(not tested) CIR-port support for lirc based
+ * via cut and paste from lirc_sir.c (C) 2000 Milan Pikula
+ *
+ * Attention: Sendmode only tested with debugging logs
+ *
+ * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
+ *   reimplemented read function
+ */
+
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/config.h>
+
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+
+#include <linux/timer.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+#include "lirc_it87.h"
+
+static unsigned long it87_bits_in_byte_out = 0;
+static unsigned long it87_send_counter = 0;
+static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
+
+#define RBUF_LEN 1024
+#define WBUF_LEN 1024
+
+#define LIRC_DRIVER_NAME "lirc_it87"
+
+/* timeout for sequences in jiffies (=5/100s) */
+/* must be longer than TIME_CONST */
+#define IT87_TIMEOUT	(HZ*5/100)
+
+static int io = IT87_CIR_DEFAULT_IOBASE;
+static int irq = IT87_CIR_DEFAULT_IRQ;
+static unsigned char it87_freq = 38; /* kHz */
+/* receiver demodulator default: off */
+static unsigned char it87_enable_demodulator = 0;
+
+static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static struct timer_list timerlist;
+/* time of last signal change detected */
+static struct timeval last_tv = {0, 0};
+/* time of last UART data ready interrupt */
+static struct timeval last_intr_tv = {0, 0};
+static int last_value = 0;
+
+static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
+
+static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+
+static lirc_t rx_buf[RBUF_LEN]; unsigned int rx_tail = 0, rx_head = 0;
+static lirc_t tx_buf[WBUF_LEN];
+
+/* SECTION: Prototypes */
+
+/* Communication with user-space */
+static int lirc_open(struct inode * inode,
+		     struct file * file);
+static int lirc_close(struct inode * inode,
+		      struct file *file);
+static unsigned int lirc_poll(struct file * file,
+			      poll_table * wait);
+static ssize_t lirc_read(struct file * file,
+			 char * buf,
+			 size_t count,
+			 loff_t * ppos);
+static ssize_t lirc_write(struct file * file,
+			  const char * buf,
+			  size_t n,
+			  loff_t * pos);
+static int lirc_ioctl(struct inode *node,
+		      struct file *filep,
+		      unsigned int cmd,
+		      unsigned long arg);
+static void add_read_queue(int flag,
+			   unsigned long val);
+static int init_chrdev(void);
+static void drop_chrdev(void);
+	/* Hardware */
+static irqreturn_t it87_interrupt(int irq,
+			   void * dev_id,
+			   struct pt_regs * regs);
+static void send_space(unsigned long len);
+static void send_pulse(unsigned long len);
+static void init_send(void);
+static void terminate_send(unsigned long len);
+static int init_hardware(void);
+static void drop_hardware(void);
+	/* Initialisation */
+static int init_port(void);
+static void drop_port(void);
+int init_module(void);
+void cleanup_module(void);
+
+
+/* SECTION: Communication with user-space */
+
+static int lirc_open(struct inode * inode,
+		     struct file * file)
+{
+	spin_lock(&dev_lock);
+#ifdef CONFIG_MODULE_UNLOAD
+	if (module_refcount(THIS_MODULE))
+	{
+		spin_unlock(&dev_lock);
+		return -EBUSY;
+	}
+#endif
+	try_module_get(THIS_MODULE);
+	spin_unlock(&dev_lock);
+	return 0;
+}
+
+
+static int lirc_close(struct inode * inode,
+		      struct file *file)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+
+static unsigned int lirc_poll(struct file * file,
+			      poll_table * wait)
+{
+	poll_wait(file, &lirc_read_queue, wait);
+	if (rx_head != rx_tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+
+static ssize_t lirc_read(struct file * file,
+			 char * buf,
+			 size_t count,
+			 loff_t * ppos)
+{
+	int n=0;
+	int retval=0;
+
+	while(n<count)
+	{
+		if(file->f_flags & O_NONBLOCK &&
+		   rx_head==rx_tail)
+		{
+			retval = -EAGAIN;
+			break;
+		}
+		retval=wait_event_interruptible(lirc_read_queue,
+						rx_head!=rx_tail);
+		if(retval)
+		{
+			break;
+		}
+
+		retval=verify_area(VERIFY_WRITE,(void *) buf+n,
+				   sizeof(lirc_t));
+		if (retval)
+		{
+			return retval;
+		}
+		copy_to_user((void *) buf+n,(void *) (rx_buf+rx_head),
+			     sizeof(lirc_t));
+		rx_head=(rx_head+1)&(RBUF_LEN-1);
+		n+=sizeof(lirc_t);
+	}
+	if(n)
+	{
+		return n;
+	}
+	return retval;
+}
+
+
+static ssize_t lirc_write(struct file * file,
+			  const char * buf,
+			  size_t n,
+			  loff_t * pos)
+{
+	int i;
+	int retval;
+
+        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
+		return(-EINVAL);
+	retval = verify_area(VERIFY_READ, buf, n);
+	if (retval)
+		return retval;
+	copy_from_user(tx_buf, buf, n);
+	i = 0;
+	n/=sizeof(lirc_t);
+	init_send();
+	while (1) {
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_pulse(tx_buf[i]);
+		i++;
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_space(tx_buf[i]);
+		i++;
+	}
+	terminate_send(tx_buf[i-1]);
+	return n;
+}
+
+
+static int lirc_ioctl(struct inode *node,
+		      struct file *filep,
+		      unsigned int cmd,
+		      unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+	unsigned int ivalue;
+
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE |
+			LIRC_CAN_SET_SEND_CARRIER |
+			LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+	case LIRC_GET_SEND_MODE:
+	case LIRC_GET_REC_MODE:
+		retval = put_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_CARRIER:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		ivalue /= 1000;
+		if (ivalue > IT87_CIR_FREQ_MAX ||
+		    ivalue < IT87_CIR_FREQ_MIN) return(-EINVAL);
+
+		it87_freq = ivalue;
+		{
+			unsigned long hw_flags;
+
+			spin_lock_irqsave(&hardware_lock, hw_flags);
+			outb(((inb(io + IT87_CIR_TCR2) & IT87_CIR_TCR2_TXMPW) |
+			      (it87_freq - IT87_CIR_FREQ_MIN) << 3),
+			     io + IT87_CIR_TCR2);
+			spin_unlock_irqrestore(&hardware_lock, hw_flags);
+#ifdef DEBUG
+			printk(KERN_DEBUG LIRC_DRIVER_NAME
+			       " demodulation frequency: %d kHz\n", it87_freq);
+#endif
+		}
+
+		break;
+
+	default:
+		retval = -ENOIOCTLCMD;
+	}
+
+	if (retval)
+		return retval;
+
+	if (cmd == LIRC_SET_REC_MODE) {
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+	} else if (cmd == LIRC_SET_SEND_MODE) {
+		if (value != LIRC_MODE_PULSE)
+			retval = -ENOSYS;
+	}
+	return retval;
+}
+
+static void add_read_queue(int flag,
+			   unsigned long val)
+{
+	unsigned int new_rx_tail;
+	lirc_t newval;
+
+#ifdef DEBUG_SIGNAL
+	printk(KERN_DEBUG LIRC_DRIVER_NAME
+	       ": add flag %d with val %lu\n",
+	       flag,val);
+#endif
+
+	newval = val & PULSE_MASK;
+
+	/* statistically pulses are ~TIME_CONST/2 too long: we could
+	   maybe make this more exactly but this is good enough */
+	if(flag) /* pulse */ {
+		if(newval>TIME_CONST/2) {
+			newval-=TIME_CONST/2;
+		}
+		else /* should not ever happen */ {
+			newval=1;
+		}
+		newval|=PULSE_BIT;
+	}
+	else {
+		newval+=TIME_CONST/2;
+	}
+	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
+	if (new_rx_tail == rx_head) {
+#ifdef DEBUG
+		printk(KERN_WARNING LIRC_DRIVER_NAME ": Buffer overrun.\n");
+#endif
+		return;
+	}
+	rx_buf[rx_tail] = newval;
+	rx_tail = new_rx_tail;
+	wake_up_interruptible(&lirc_read_queue);
+}
+
+
+static struct file_operations lirc_fops = {
+	read:    lirc_read,
+	write:   lirc_write,
+	poll:    lirc_poll,
+	ioctl:   lirc_ioctl,
+	open:    lirc_open,
+	release: lirc_close,
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       try_module_get(THIS_MODULE);
+#endif
+       return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       module_put(THIS_MODULE);
+#endif
+}
+static struct lirc_plugin plugin = {
+       name:           LIRC_DRIVER_NAME,
+       minor:          -1,
+       code_length:    1,
+       sample_rate:    0,
+       data:           NULL,
+       add_to_buf:     NULL,
+       get_queue:      NULL,
+       set_use_inc:    set_use_inc,
+       set_use_dec:    set_use_dec,
+       fops:           &lirc_fops,
+};
+
+
+int init_chrdev(void)
+{
+	plugin.minor = lirc_register_plugin(&plugin);
+
+	if (plugin.minor < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+
+static void drop_chrdev(void)
+{
+	lirc_unregister_plugin(plugin.minor);
+}
+
+/* SECTION: Hardware */
+static long delta(struct timeval * tv1,
+		  struct timeval * tv2)
+{
+	unsigned long deltv;
+
+	deltv = tv2->tv_sec - tv1->tv_sec;
+	if (deltv > 15)
+		deltv = 0xFFFFFF;
+	else
+		deltv = deltv*1000000 +
+			tv2->tv_usec -
+			tv1->tv_usec;
+	return deltv;
+}
+
+
+static void it87_timeout(unsigned long data)
+{
+	/* if last received signal was a pulse, but receiving stopped
+	   within the 9 bit frame, we need to finish this pulse and
+	   simulate a signal change to from pulse to space. Otherwise
+	   upper layers will receive two sequences next time. */
+
+	unsigned long flags;
+	unsigned long pulse_end;
+
+	/* avoid interference with interrupt */
+ 	spin_lock_irqsave(&timer_lock, flags);
+	if (last_value) {
+		/* determine 'virtual' pulse end: */
+	 	pulse_end = delta(&last_tv, &last_intr_tv);
+#ifdef DEBUG_SIGNAL
+		printk(KERN_DEBUG LIRC_DRIVER_NAME
+		       ": timeout add %d for %lu usec\n",
+		       last_value,
+		       pulse_end);
+#endif
+		add_read_queue(last_value,
+			       pulse_end);
+		last_value = 0;
+		last_tv=last_intr_tv;
+	}
+	spin_unlock_irqrestore(&timer_lock, flags);
+}
+
+
+static irqreturn_t it87_interrupt(int irq,
+			   void * dev_id,
+			   struct pt_regs * regs)
+{
+	unsigned char data;
+	struct timeval curr_tv;
+	static unsigned long deltv;
+	unsigned long deltintrtv;
+	unsigned long flags, hw_flags;
+	int iir, lsr;
+	int fifo = 0;
+
+	iir = inb(io + IT87_CIR_IIR);
+
+	switch (iir & IT87_CIR_IIR_IID) {
+	case 0x4:
+	case 0x6:
+		lsr = inb(io + IT87_CIR_RSR) & (IT87_CIR_RSR_RXFTO |
+						    IT87_CIR_RSR_RXFBC);
+		fifo = lsr & IT87_CIR_RSR_RXFBC;
+#ifdef DEBUG_SIGNAL
+		printk(KERN_DEBUG LIRC_DRIVER_NAME
+		       "iir: 0x%x fifo: 0x%x\n", iir, lsr);
+#endif
+
+		/* avoid interference with timer */
+		spin_lock_irqsave(&timer_lock, flags);
+		spin_lock_irqsave(&hardware_lock, hw_flags);
+		do {
+			del_timer(&timerlist);
+			data = inb(io + IT87_CIR_DR);
+#ifdef DEBUG_SIGNAL
+			printk(KERN_DEBUG LIRC_DRIVER_NAME
+			       ": data=%.2x\n",
+			       data);
+#endif
+			do_gettimeofday(&curr_tv);
+			deltv = delta(&last_tv, &curr_tv);
+			deltintrtv = delta(&last_intr_tv, &curr_tv);
+#ifdef DEBUG_SIGNAL
+			printk(KERN_DEBUG LIRC_DRIVER_NAME
+			       ": t %lu , d %d\n",
+			       deltintrtv,
+			       (int)data);
+#endif
+			/* if nothing came in last 2 cycles,
+			   it was gap */
+			if (deltintrtv > TIME_CONST * 2) {
+				if (last_value) {
+#ifdef DEBUG_SIGNAL
+					printk(KERN_DEBUG LIRC_DRIVER_NAME ": GAP\n");
+#endif
+					/* simulate signal change */
+					add_read_queue(last_value,
+						       deltv-
+						       deltintrtv);
+					last_value = 0;
+					last_tv.tv_sec = last_intr_tv.tv_sec;
+					last_tv.tv_usec = last_intr_tv.tv_usec;
+					deltv = deltintrtv;
+				}
+			}
+			data = 1;
+			if (data ^ last_value) {
+				/* deltintrtv > 2*TIME_CONST,
+				   remember ? */
+				/* the other case is timeout */
+				add_read_queue(last_value,
+					       deltv-TIME_CONST);
+				last_value = data;
+				last_tv = curr_tv;
+				if(last_tv.tv_usec>=TIME_CONST) {
+					last_tv.tv_usec-=TIME_CONST;
+				}
+				else {
+					last_tv.tv_sec--;
+					last_tv.tv_usec+=1000000-
+						TIME_CONST;
+				}
+			}
+			last_intr_tv = curr_tv;
+			if (data) {
+				/* start timer for end of sequence detection */
+				timerlist.expires = jiffies + IT87_TIMEOUT;
+				add_timer(&timerlist);
+			}
+			outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+			     IT87_CIR_RCR_RXACT,
+			     io + IT87_CIR_RCR);
+			if (it87_RXEN_mask) {
+				outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
+				     io + IT87_CIR_RCR);
+			}
+			fifo--;
+		}
+		while (fifo != 0);
+		spin_unlock_irqrestore(&hardware_lock, hw_flags);
+		spin_unlock_irqrestore(&timer_lock, flags);
+		break;
+
+	default:
+		/* not our irq */
+#ifdef DEBUG_SIGNAL
+		printk(KERN_DEBUG LIRC_DRIVER_NAME
+		       "unknown IRQ (shouldn't happen) !!\n");
+#endif
+		break;
+	}
+	return IRQ_HANDLED; //FIXME true status should be returned (include/linux/interrupt.h)
+}
+
+
+static void send_it87(unsigned long len,
+		      unsigned long stime,
+		      unsigned char send_byte,
+		      unsigned int count_bits)
+{
+        long count = len / stime;
+	long time_left = 0;
+	static unsigned char byte_out = 0;
+
+#ifdef DEBUG_SIGNAL
+	printk(KERN_DEBUG LIRC_DRIVER_NAME
+	       "send_it87: len=%ld, sb=%d\n",
+	       len,
+	       send_byte);
+#endif
+	time_left = (long)len - (long)count * (long)stime;
+	count += ((2 * time_left) / stime);
+	while (count) {
+		long i=0;
+		for (i=0; i<count_bits; i++) {
+			byte_out = (byte_out << 1) | (send_byte & 1);
+			it87_bits_in_byte_out++;
+		}
+		if (it87_bits_in_byte_out == 8) {
+#ifdef DEBUG_SIGNAL
+			printk(KERN_DEBUG LIRC_DRIVER_NAME
+			       "out=0x%x, tsr_txfbc: 0x%x\n",
+			       byte_out,
+			       inb(io + IT87_CIR_TSR) &
+			       IT87_CIR_TSR_TXFBC);
+#endif
+			while ((inb(io + IT87_CIR_TSR) &
+				IT87_CIR_TSR_TXFBC) >= IT87_CIR_FIFO_SIZE);
+			{
+				unsigned long hw_flags;
+
+				spin_lock_irqsave(&hardware_lock, hw_flags);
+				outb(byte_out, io + IT87_CIR_DR);
+				spin_unlock_irqrestore(&hardware_lock, hw_flags);
+			}
+			it87_bits_in_byte_out = 0;
+			it87_send_counter++;
+			byte_out = 0;
+		}
+		count--;
+	}
+}
+
+
+/*
+maybe: exchange space and pulse because
+it8705 only modulates 0-bits
+*/
+
+
+static void send_space(unsigned long len)
+{
+	send_it87(len,
+		  TIME_CONST,
+		  IT87_CIR_SPACE,
+		  IT87_CIR_BAUDRATE_DIVISOR);
+}
+
+static void send_pulse(unsigned long len)
+{
+	send_it87(len,
+		  TIME_CONST,
+		  IT87_CIR_PULSE,
+		  IT87_CIR_BAUDRATE_DIVISOR);
+}
+
+
+static void init_send()
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* RXEN=0: receiver disable */
+	it87_RXEN_mask = 0;
+	outb(inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN,
+	     io + IT87_CIR_RCR);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	it87_bits_in_byte_out = 0;
+	it87_send_counter = 0;
+}
+
+
+static void terminate_send(unsigned long len)
+{
+	unsigned long flags;
+	unsigned long last = 0;
+
+	last = it87_send_counter;
+	/* make sure all necessary data has been sent */
+	while (last == it87_send_counter)
+		send_space(len);
+	/* wait until all data sent */
+	while ((inb(io + IT87_CIR_TSR) & IT87_CIR_TSR_TXFBC) != 0);
+	/* then reenable receiver */
+	spin_lock_irqsave(&hardware_lock, flags);
+	it87_RXEN_mask = IT87_CIR_RCR_RXEN;
+	outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
+	     io + IT87_CIR_RCR);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+
+static int init_hardware(void)
+{
+	unsigned long flags;
+	unsigned char it87_rcr = 0;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* init cir-port */
+	/* enable r/w-access to Baudrate-Register */
+	outb(IT87_CIR_IER_BR, io + IT87_CIR_IER);
+	outb(IT87_CIR_BAUDRATE_DIVISOR % 0x100, io+IT87_CIR_BDLR);
+	outb(IT87_CIR_BAUDRATE_DIVISOR / 0x100, io+IT87_CIR_BDHR);
+	/* Baudrate Register off, define IRQs: Input only */
+	outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
+	/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
+	it87_rcr = (IT87_CIR_RCR_RXEN & it87_RXEN_mask) | 0x1;
+	if (it87_enable_demodulator)
+		it87_rcr |= IT87_CIR_RCR_RXEND;
+	outb(it87_rcr, io + IT87_CIR_RCR);
+	/* TX: 38kHz, 13,3us (pulse-width */
+	outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
+	     io + IT87_CIR_TCR2);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	return 0;
+}
+
+
+static void drop_hardware(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+	disable_irq(irq);
+	/* receiver disable */
+	it87_RXEN_mask = 0;
+	outb(0x1, io + IT87_CIR_RCR);
+	/* turn off irqs */
+	outb(0, io + IT87_CIR_IER);
+	/* fifo clear */
+        outb(IT87_CIR_TCR1_FIFOCLR, io+IT87_CIR_TCR1);
+        /* reset */
+        outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
+	enable_irq(irq);
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+
+static unsigned char it87_read(unsigned char port)
+{
+	outb(port, IT87_ADRPORT);
+	return inb(IT87_DATAPORT);
+}
+
+
+static void it87_write(unsigned char port,
+		       unsigned char data)
+{
+	outb(port, IT87_ADRPORT);
+	outb(data, IT87_DATAPORT);
+}
+
+
+/* SECTION: Initialisation */
+
+static int init_port(void)
+{
+	int retval = 0;
+
+	unsigned char init_bytes[4] = {IT87_INIT};
+	unsigned char it87_chipid = 0;
+	unsigned char ldn = 0;
+	unsigned int  it87_io = 0;
+	unsigned int  it87_irq = 0;
+
+	/* Enter MB PnP Mode */
+	outb(init_bytes[0], IT87_ADRPORT);
+	outb(init_bytes[1], IT87_ADRPORT);
+	outb(init_bytes[2], IT87_ADRPORT);
+	outb(init_bytes[3], IT87_ADRPORT);
+
+	/* 8712 or 8705 ? */
+	it87_chipid = it87_read(IT87_CHIP_ID1);
+	if (it87_chipid != 0x87) {
+		retval = -ENXIO;
+		return retval;
+	}
+	it87_chipid = it87_read(IT87_CHIP_ID2);
+	if ((it87_chipid != 0x12) && (it87_chipid != 0x05)) {
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": no IT8705/12 found, exiting..\n");
+		retval = -ENXIO;
+		return retval;
+	}
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": found IT87%.2x.\n",
+	       it87_chipid);
+
+	/* get I/O-Port and IRQ */
+	if (it87_chipid == 0x12)
+		ldn = IT8712_CIR_LDN;
+	else
+		ldn = IT8705_CIR_LDN;
+	it87_write(IT87_LDN, ldn);
+
+	it87_io = it87_read(IT87_CIR_BASE_MSB) * 256 +
+		it87_read(IT87_CIR_BASE_LSB);
+	if (it87_io == 0) {
+		if (io == 0)
+			io = IT87_CIR_DEFAULT_IOBASE;
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": set default io 0x%x\n",
+		       io);
+		it87_write(IT87_CIR_BASE_MSB, io / 0x100);
+		it87_write(IT87_CIR_BASE_LSB, io % 0x100);
+	}
+	else
+		io = it87_io;
+
+	it87_irq = it87_read(IT87_CIR_IRQ);
+	if (it87_irq == 0) {
+		if (irq == 0)
+			irq = IT87_CIR_DEFAULT_IRQ;
+		printk(KERN_INFO LIRC_DRIVER_NAME
+		       ": set default irq 0x%x\n",
+		       irq);
+		it87_write(IT87_CIR_IRQ, irq);
+	}
+	else
+		irq = it87_irq;
+
+	{
+		unsigned long hw_flags;
+
+		spin_lock_irqsave(&hardware_lock, hw_flags);
+		/* reset */
+		outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
+		/* fifo clear */
+		outb(IT87_CIR_TCR1_FIFOCLR |
+		     /*	     IT87_CIR_TCR1_ILE | */
+		     IT87_CIR_TCR1_TXRLE |
+		     IT87_CIR_TCR1_TXENDF, io+IT87_CIR_TCR1);
+		spin_unlock_irqrestore(&hardware_lock, hw_flags);
+	}
+
+	/* get I/O port access and IRQ line */
+	retval = request_region(io, 8, LIRC_DRIVER_NAME);
+
+	if (!retval) {
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": Unable to reserve IO region for LIRC IT87. Port 0x%.4x already in use.\n",
+		       io);
+		/* Leaving MB PnP Mode */
+		it87_write(IT87_CFGCTRL, 0x2);
+		return retval;
+	}
+
+	/* activate CIR-Device */
+	it87_write(IT87_CIR_ACT, 0x1);
+
+	/* Leaving MB PnP Mode */
+	it87_write(IT87_CFGCTRL, 0x2);
+
+	retval = request_irq(irq, it87_interrupt, 0 /*SA_INTERRUPT*/,
+			     LIRC_DRIVER_NAME, NULL);
+	if (retval < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": IRQ %d already in use.\n",
+		       irq);
+		return retval;
+	}
+
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": I/O port 0x%.4x, IRQ %d.\n",
+	       io,
+	       irq);
+
+	request_region(io, 8, LIRC_DRIVER_NAME);
+	init_timer(&timerlist);
+	timerlist.function = it87_timeout;
+	timerlist.data = 0xabadcafe;
+
+	return 0;
+}
+
+
+static void drop_port(void)
+{
+/*
+        unsigned char init_bytes[4] = {IT87_INIT};
+
+        / * Enter MB PnP Mode * /
+        outb(init_bytes[0], IT87_ADRPORT);
+        outb(init_bytes[1], IT87_ADRPORT);
+        outb(init_bytes[2], IT87_ADRPORT);
+        outb(init_bytes[3], IT87_ADRPORT);
+
+        / * deactivate CIR-Device * /
+        it87_write(IT87_CIR_ACT, 0x0);
+
+        / * Leaving MB PnP Mode * /
+        it87_write(IT87_CFGCTRL, 0x2);
+*/
+
+	del_timer_sync(&timerlist);
+	free_irq(irq, NULL);
+	release_region(io, 8);
+}
+
+
+int init_lirc_it87(void)
+{
+	int retval;
+
+	init_waitqueue_head(&lirc_read_queue);
+	retval = init_port();
+	if (retval < 0)
+		return retval;
+	init_hardware();
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": Installed.\n");
+	return 0;
+}
+
+
+MODULE_AUTHOR("Hans-Gnter Ltke Uphues");
+MODULE_DESCRIPTION("LIRC driver for ITE IT8712/IT8705 CIR port");
+MODULE_PARM(io, "i");
+MODULE_PARM_DESC(io,
+		 "I/O base address (default: 0x310)");
+MODULE_PARM(irq, "i");
+MODULE_PARM_DESC(irq,
+		 "Interrupt (1,3-12) (default: 7)");
+MODULE_PARM(it87_enable_demodulator, "i");
+MODULE_PARM_DESC(it87_enable_demodulator,
+		 "Receiver demodulator enable/disable (1/0), default: 0");
+MODULE_LICENSE("GPL");
+
+static int __init lirc_it87_init(void)
+{
+	int retval;
+
+	retval=init_chrdev();
+	if(retval < 0)
+		return retval;
+	retval = init_lirc_it87();
+	if (retval) {
+		drop_chrdev();
+		return retval;
+	}
+	return 0;
+}
+
+
+static void __exit lirc_it87_exit(void)
+{
+	drop_hardware();
+	drop_chrdev();
+	drop_port();
+	printk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");
+}
+
+module_init(lirc_it87_init);
+module_exit(lirc_it87_exit);
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_it87.h linux-2.6.17.8-sh/drivers/char/lirc/lirc_it87.h
--- linux-2.6.17.8/drivers/char/lirc/lirc_it87.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_it87.h	2006-08-23 13:29:33.926485000 +0100
@@ -0,0 +1,116 @@
+/* lirc_it87.h */
+/* SECTION: Definitions */
+
+/********************************* ITE IT87xx ************************/
+
+/* based on the following documentation from ITE:
+   a) IT8712F Preliminary CIR Programming Guide V0.1
+   b) IT8705F Simple LPC I/O Preliminary Specifiction V0.3
+   c) IT8712F EC-LPC I/O Preliminary Specification V0.5
+*/
+
+/* IT8712/05 Ports: */
+#define IT87_ADRPORT      0x2e
+#define IT87_DATAPORT     0x2f
+#define IT87_INIT         0x87, 0x01, 0x55, 0x55
+
+/* alternate Ports: */
+/*
+#define IT87_ADRPORT      0x4e
+#define IT87_DATAPORT     0x4f
+#define IT87_INIT         0x87, 0x01, 0x55, 0xaa
+ */
+
+/* IT8712/05 Registers */
+#define IT87_CFGCTRL      0x2
+#define IT87_LDN          0x7
+#define IT87_CHIP_ID1     0x20
+#define IT87_CHIP_ID2     0x21
+#define IT87_CFG_VERSION  0x22
+#define IT87_SWSUSPEND    0x23
+
+#define IT8712_CIR_LDN    0xa
+#define IT8705_CIR_LDN    0x7
+
+/* CIR Configuration Registers: */
+#define IT87_CIR_ACT      0x30
+#define IT87_CIR_BASE_MSB 0x60
+#define IT87_CIR_BASE_LSB 0x61
+#define IT87_CIR_IRQ      0x70
+#define IT87_CIR_CONFIG   0xf0
+
+/* List of IT87_CIR registers: offset to BaseAddr */
+#define IT87_CIR_DR   0
+#define IT87_CIR_IER  1
+#define IT87_CIR_RCR  2
+#define IT87_CIR_TCR1 3
+#define IT87_CIR_TCR2 4
+#define IT87_CIR_TSR  5
+#define IT87_CIR_RSR  6
+#define IT87_CIR_BDLR 5
+#define IT87_CIR_BDHR 6
+#define IT87_CIR_IIR  7
+
+/* Bit Definitionen */
+/* IER: */
+#define IT87_CIR_IER_TM_EN   0x80
+#define IT87_CIR_IER_RESEVED 0x40
+#define IT87_CIR_IER_RESET   0x20
+#define IT87_CIR_IER_BR      0x10
+#define IT87_CIR_IER_IEC     0x8
+#define IT87_CIR_IER_RFOIE   0x4
+#define IT87_CIR_IER_RDAIE   0x2
+#define IT87_CIR_IER_TLDLIE  0x1
+
+/* RCR: */
+#define IT87_CIR_RCR_RDWOS  0x80
+#define IT87_CIR_RCR_HCFS   0x40
+#define IT87_CIR_RCR_RXEN   0x20
+#define IT87_CIR_RCR_RXEND  0x10
+#define IT87_CIR_RCR_RXACT  0x8
+#define IT87_CIR_RCR_RXDCR  0x7
+
+/* TCR1: */
+#define IT87_CIR_TCR1_FIFOCLR 0x80
+#define IT87_CIR_TCR1_ILE     0x40
+#define IT87_CIR_TCR1_FIFOTL  0x30
+#define IT87_CIR_TCR1_TXRLE   0x8
+#define IT87_CIR_TCR1_TXENDF  0x4
+#define IT87_CIR_TCR1_TXMPM   0x3
+
+/* TCR2: */
+#define IT87_CIR_TCR2_CFQ   0xf8
+#define IT87_CIR_TCR2_TXMPW 0x7
+
+/* TSR: */
+#define IT87_CIR_TSR_RESERVED 0xc0
+#define IT87_CIR_TSR_TXFBC    0x3f
+
+/* RSR: */
+#define IT87_CIR_RSR_RXFTO    0x80
+#define IT87_CIR_RSR_RESERVED 0x40
+#define IT87_CIR_RSR_RXFBC    0x3f
+
+/* IIR: */
+#define IT87_CIR_IIR_RESERVED 0xf8
+#define IT87_CIR_IIR_IID      0x6
+#define IT87_CIR_IIR_IIP      0x1
+
+/* TM: */
+#define IT87_CIR_TM_IL_SEL    0x80
+#define IT87_CIR_TM_RESERVED  0x40
+#define IT87_CIR_TM_TM_REG    0x3f
+
+#define IT87_CIR_FIFO_SIZE 32
+
+/* Baudratedivisor for IT87: power of 2: only 1,2,4 or 8) */
+#define IT87_CIR_BAUDRATE_DIVISOR 0x1
+#define IT87_CIR_DEFAULT_IOBASE 0x310
+#define IT87_CIR_DEFAULT_IRQ    0x7
+#define IT87_CIR_SPACE 0x00
+#define IT87_CIR_PULSE 0xff
+#define IT87_CIR_FREQ_MIN 27
+#define IT87_CIR_FREQ_MAX 58
+#define TIME_CONST (IT87_CIR_BAUDRATE_DIVISOR * 8000000ul / 115200ul)
+
+/********************************* ITE IT87xx ************************/
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_mceusb.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_mceusb.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_mceusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_mceusb.c	2006-08-23 13:29:33.937487000 +0100
@@ -0,0 +1,1542 @@
+/*
+ * USB Microsoft IR Transceiver driver - 0.1
+ *
+ * Copyright (c) 2003-2004 Dan Conti (dconti@acm.wwu.edu)
+ *
+ * This driver is based on the USB skeleton driver packaged with the
+ * kernel, and the notice from that package has been retained below.
+ *
+ * The Microsoft IR Transceiver is a neat little IR receiver with two
+ * emitters on it designed for Windows Media Center. This driver might
+ * work for all media center remotes, but I have only tested it with
+ * the philips model. The first revision of this driver only supports
+ * the receive function - the transmit function will be much more
+ * tricky due to the nature of the hardware. Microsoft chose to build
+ * this device inexpensively, therefore making it extra dumb.  There
+ * is no interrupt endpoint on this device; all usb traffic happens
+ * over two bulk endpoints. As a result of this, poll() for this
+ * device is an actual hardware poll (instead of a receive queue
+ * check) and is rather expensive.
+ *
+ * This driver is structured in three basic layers
+ *  - lower  - interface with the usb device and manage usb data
+ *  - middle - api to convert usb data into mode2 and provide this in
+ *    _read calls
+ *  - mceusb_* - linux driver interface
+ *
+ * The key routines are as follows:
+ *  msir_fetch_more_data - this reads incoming data, strips off the
+ *                         start codes the ir receiver places on them,
+ *                         and dumps it in an * internal buffer
+ *  msir_generate_mode2  - this takes the above data, depacketizes it,
+ *                         and generates mode2 data to feed out
+ *                         through read calls
+ *
+ *
+ * All trademarks property of their respective owners.
+ *
+ * 2003_11_11 - Restructured to minimalize code interpretation in the
+ *              driver. The normal use case will be with lirc.
+ *
+ * 2004_01_01 - Removed all code interpretation. Generate mode2 data
+ *              for passing off to lirc. Cleanup
+ *
+ * 2004_01_04 - Removed devfs handle. Put in a temporary workaround
+ *              for a known issue where repeats generate two
+ *              sequential spaces * (last_was_repeat_gap)
+ *
+ * TODO
+ *   - Fix up minor number, registration of major/minor with usb subsystem
+ *   - Fix up random EINTR being sent
+ *   - Fix problem where third key in a repeat sequence is randomly truncated
+ *
+ */
+/*
+ * USB Skeleton driver - 0.6
+ *
+ * Copyright (c) 2001 Greg Kroah-Hartman (greg@kroah.com)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ *
+ *
+ * This driver is to be used as a skeleton driver to be able to create a
+ * USB driver quickly.  The design of it is based on the usb-serial and
+ * dc2xx drivers.
+ *
+ * Thanks to Oliver Neukum and David Brownell for their help in debugging
+ * this driver.
+ *
+ * TODO:
+ *	- fix urb->status race condition in write sequence
+ *	- move minor_table to a dynamic list.
+ *
+ * History:
+ *
+ * 2001_11_05 - 0.6 - fix minor locking problem in skel_disconnect.
+ *			Thanks to Pete Zaitcev for the fix.
+ * 2001_09_04 - 0.5 - fix devfs bug in skel_disconnect. Thanks to wim delvaux
+ * 2001_08_21 - 0.4 - more small bug fixes.
+ * 2001_05_29 - 0.3 - more bug fixes based on review from linux-usb-devel
+ * 2001_05_24 - 0.2 - bug fixes based on review from linux-usb-devel people
+ * 2001_05_01 - 0.1 - first version
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#include <linux/usb.h>
+
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 1;
+#endif
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+/* Version Information */
+#define DRIVER_VERSION "v0.1"
+#define DRIVER_AUTHOR "Dan Conti, dconti@acm.wwu.edu"
+#define DRIVER_DESC "USB Microsoft IR Transceiver Driver"
+
+/* Module paramaters */
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+/* Define these values to match your device */
+#define USB_MCEUSB_VENDOR_ID	0x045e
+#define USB_MCEUSB_PRODUCT_ID	0x006d
+
+/* table of devices that work with this driver */
+static struct usb_device_id mceusb_table [] = {
+	{ USB_DEVICE(USB_MCEUSB_VENDOR_ID, USB_MCEUSB_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, mceusb_table);
+
+/* XXX TODO, 244 is likely unused but not reserved */
+/* Get a minor range for your devices from the usb maintainer */
+#define USB_MCEUSB_MINOR_BASE	244
+
+
+/* we can have up to this number of device plugged in at once */
+#define MAX_DEVICES		16
+
+/* Structure to hold all of our device specific stuff */
+struct usb_skel	     {
+	/* save off the usb device pointer */
+	struct usb_device *	    udev;
+	/* the interface for this device */
+	struct usb_interface *	interface;
+	/* the starting minor number for this device */
+	unsigned char   minor;
+	/* the number of ports this device has */
+	unsigned char   num_ports;
+	/* number of interrupt in endpoints we have */
+	char            num_interrupt_in;
+	/* number of bulk in endpoints we have */
+	char            num_bulk_in;
+	/* number of bulk out endpoints we have */
+	char            num_bulk_out;
+
+	/* the buffer to receive data */
+	unsigned char *    bulk_in_buffer;
+	/* the size of the receive buffer */
+	int                bulk_in_size;
+	/* the address of the bulk in endpoint */
+	__u8               bulk_in_endpointAddr;
+
+	/* the buffer to send data */
+	unsigned char *    bulk_out_buffer;
+	/* the size of the send buffer */
+	int	           bulk_out_size;
+	/* the urb used to send data */
+	struct urb *       write_urb;
+	/* the address of the bulk out endpoint */
+	__u8               bulk_out_endpointAddr;
+
+	wait_queue_head_t  wait_q;      /* for timeouts */
+	int                open_count;	/* number of times this port
+					 * has been opened */
+	struct semaphore   sem;		/* locks this structure */
+
+	struct lirc_plugin* plugin;
+
+	/* Used in converting to mode2 and storing */
+        /* buffer for the mode2 data, since lirc reads 4bytes */
+	int    mode2_data[256];
+	int    mode2_idx;               /* read index */
+	int    mode2_count;             /* words available (i.e. write
+					 * index) */
+	int    mode2_partial_pkt_size;
+	int    mode2_once;
+
+	/* Used for storing preprocessed usb data before converting to mode2*/
+	char   usb_dbuffer[1024];
+	int    usb_dstart;
+	int    usb_dcount;
+	int    usb_valid_bytes_in_bulk_buffer;
+
+	/* Set to 1 if the last value we adjusted was a repeat gap; we
+	 * need to hold this value around until we process a lead
+	 * space on the repeat code, otherwise we pass off two
+	 * sequential spaces */
+	int    last_was_repeat_gap;
+};
+
+/* driver api */
+static ssize_t mceusb_read	(struct file *file, char *buffer,
+				 size_t count, loff_t *ppos);
+static ssize_t mceusb_write	(struct file *file, const char *buffer,
+				 size_t count, loff_t *ppos);
+static unsigned int mceusb_poll (struct file* file, poll_table* wait);
+
+static int mceusb_open		(struct inode *inode, struct file *file);
+static int mceusb_release	(struct inode *inode, struct file *file);
+
+static int mceusb_probe	(struct usb_interface *intf,
+				 const struct usb_device_id *id);
+static void mceusb_disconnect	(struct usb_interface *intf);
+
+static void mceusb_write_bulk_callback	(struct urb *, struct pt_regs *);
+
+/* lower level api */
+static int msir_fetch_more_data( struct usb_skel* dev, int dont_block );
+static int msir_read_from_buffer( struct usb_skel* dev, char* buffer, int len );
+static int msir_mark_as_read( struct usb_skel* dev, int count );
+static int msir_available_data( struct usb_skel* dev );
+
+/* middle */
+static int msir_generate_mode2( struct usb_skel* dev, signed char* usb_data,
+				int bytecount );
+static int msir_copy_mode2( struct usb_skel* dev, int* mode2_data, int count );
+static int msir_available_mode2( struct usb_skel* dev );
+
+/* helper functions */
+static void msir_cleanup( struct usb_skel* dev );
+static int set_use_inc(void* data);
+static void set_use_dec(void* data);
+
+/* array of pointers to our devices that are currently connected */
+static struct usb_skel		*minor_table[MAX_DEVICES];
+
+/* lock to protect the minor_table structure */
+static DECLARE_MUTEX (minor_table_mutex);
+
+/*
+ * File operations needed when we register this driver.
+ * This assumes that this driver NEEDS file operations,
+ * of course, which means that the driver is expected
+ * to have a node in the /dev directory. If the USB
+ * device were for a network interface then the driver
+ * would use "struct net_driver" instead, and a serial
+ * device would use "struct tty_driver".
+ */
+static struct file_operations mceusb_fops = {
+	/*
+	 * The owner field is part of the module-locking
+	 * mechanism. The idea is that the kernel knows
+	 * which module to increment the use-counter of
+	 * BEFORE it calls the device's open() function.
+	 * This also means that the kernel can decrement
+	 * the use-counter again before calling release()
+	 * or should the open() function fail.
+	 *
+	 * Not all device structures have an "owner" field
+	 * yet. "struct file_operations" and "struct net_device"
+	 * do, while "struct tty_driver" does not. If the struct
+	 * has an "owner" field, then initialize it to the value
+	 * THIS_MODULE and the kernel will handle all module
+	 * locking for you automatically. Otherwise, you must
+	 * increment the use-counter in the open() function
+	 * and decrement it again in the release() function
+	 * yourself.
+	 */
+	owner:		THIS_MODULE,
+
+	read:		mceusb_read,
+	write:		mceusb_write,
+	poll:           mceusb_poll,
+	ioctl:          NULL,
+	open:		mceusb_open,
+	release:	mceusb_release,
+};
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_class_driver mceusb_class_driver = {
+	name:		"ir_transceiver",
+	fops:		&mceusb_fops,
+	mode:		0666,
+	minor_base:	USB_MCEUSB_MINOR_BASE,
+};
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver mceusb_driver = {
+	name:		"ir_transceiver",
+	probe:		mceusb_probe,
+	disconnect:	mceusb_disconnect,
+	id_table:	mceusb_table,
+};
+
+
+/**
+ *	usb_mceusb_debug_data
+ */
+static inline void usb_mceusb_debug_data (const char *function, int size,
+					  const unsigned char *data)
+{
+	int i;
+
+	if (!debug)
+		return;
+
+	printk (KERN_DEBUG __FILE__": %s - length = %d, data = ",
+		function, size);
+	for (i = 0; i < size; ++i) {
+		printk ("%.2x ", data[i]);
+	}
+	printk ("\n");
+}
+
+
+/**
+ *	mceusb_delete
+ */
+static inline void mceusb_delete (struct usb_skel *dev)
+{
+	minor_table[dev->minor] = NULL;
+	if (dev->bulk_in_buffer != NULL)
+		kfree (dev->bulk_in_buffer);
+	if (dev->bulk_out_buffer != NULL)
+		kfree (dev->bulk_out_buffer);
+	if (dev->write_urb != NULL)
+		usb_free_urb (dev->write_urb);
+	kfree (dev);
+}
+
+static void mceusb_setup( struct usb_device *udev )
+{
+	char data[8];
+	int res;
+	memset( data, 0, 8 );
+
+	/* Get Status */
+	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+			      USB_REQ_GET_STATUS, USB_DIR_IN,
+			      0, 0, data, 2, HZ * 3);
+
+	/*    res = usb_get_status( udev, 0, 0, data ); */
+	dbg(__FUNCTION__ " res = %d status = 0x%x 0x%x",
+	    res, data[0], data[1] );
+
+	/* This is a strange one. They issue a set address to the
+	 * device on the receive control pipe and expect a certain
+	 * value pair back
+	 */
+	memset( data, 0, 8 );
+
+	res = usb_control_msg( udev, usb_rcvctrlpipe(udev, 0),
+			       5, USB_TYPE_VENDOR, 0, 0,
+			       data, 2, HZ * 3 );
+	dbg(__FUNCTION__ " res = %d, devnum = %d", res, udev->devnum);
+	dbg(__FUNCTION__ " data[0] = %d, data[1] = %d", data[0], data[1] );
+
+	/* set feature */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+			       0xc04e, 0x0000, NULL, 0, HZ * 3 );
+
+	dbg(__FUNCTION__ " res = %d", res);
+
+	/* These two are sent by the windows driver, but stall for
+	 * me. I dont have an analyzer on the linux side so i can't
+	 * see what is actually different and why * the device takes
+	 * issue with them
+	 */
+#if 0
+	/* this is some custom control message they send */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       0x04, USB_TYPE_VENDOR,
+			       0x0808, 0x0000, NULL, 0, HZ * 3 );
+
+	dbg(__FUNCTION__ " res = %d", res);
+
+	/* this is another custom control message they send */
+	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
+			       0x02, USB_TYPE_VENDOR,
+			       0x0000, 0x0100, NULL, 0, HZ * 3 );
+
+	dbg(__FUNCTION__ " res = %d", res);
+#endif
+}
+
+/**
+ *	mceusb_open
+ */
+static int mceusb_open (struct inode *inode, struct file *file)
+{
+	struct usb_skel *dev = NULL;
+	struct usb_device* udev = NULL;
+	int subminor;
+	int retval = 0;
+
+	dbg(__FUNCTION__);
+
+	/* This is a very sucky point. On lirc, we get passed the
+	 * minor number of the lirc device, which is totally
+	 * retarded. We want to support people opening /dev/usb/msir0
+	 * directly though, so try and determine who the hell is
+	 * calling us here
+	 */
+	if( MAJOR( inode->i_rdev ) != USB_MAJOR )
+	{
+		/* This is the lirc device just passing on the
+		 * request. We probably mismatch minor numbers here,
+		 * but the lucky fact is that nobody will ever use two
+		 * of the exact same remotes with two recievers on one
+		 * machine
+		 */
+		subminor = 0;
+	} else {
+		subminor = MINOR (inode->i_rdev) - USB_MCEUSB_MINOR_BASE;
+	}
+	if ((subminor < 0) ||
+	    (subminor >= MAX_DEVICES)) {
+		dbg("subminor %d", subminor);
+		return -ENODEV;
+	}
+
+	/* Increment our usage count for the module.
+	 * This is redundant here, because "struct file_operations"
+	 * has an "owner" field. This line is included here soley as
+	 * a reference for drivers using lesser structures... ;-)
+	 */
+	try_module_get(THIS_MODULE);
+
+	/* lock our minor table and get our local data for this minor */
+	down (&minor_table_mutex);
+	dev = minor_table[subminor];
+	if (dev == NULL) {
+		dbg("dev == NULL");
+		up (&minor_table_mutex);
+		module_put(THIS_MODULE);
+		return -ENODEV;
+	}
+	udev = dev->udev;
+
+	/* lock this device */
+	down (&dev->sem);
+
+	/* unlock the minor table */
+	up (&minor_table_mutex);
+
+	/* increment our usage count for the driver */
+	++dev->open_count;
+
+	/* save our object in the file's private structure */
+	file->private_data = dev;
+
+	/* init the waitq */
+	init_waitqueue_head( &dev->wait_q );
+
+	/* clear off the first few messages. these look like
+	 * calibration or test data, i can't really tell
+	 * this also flushes in case we have random ir data queued up
+	 */
+	{
+		char junk[64];
+		int partial = 0, retval, i;
+		for( i = 0; i < 40; i++ )
+		{
+			retval = usb_bulk_msg (udev,
+					       usb_rcvbulkpipe
+					       (udev,
+						dev->bulk_in_endpointAddr),
+					       junk, 64,
+					       &partial, HZ*10);
+		}
+	}
+
+	msir_cleanup( dev );
+
+	/* unlock this device */
+	up (&dev->sem);
+
+	return retval;
+}
+
+
+/**
+ *	mceusb_release
+ */
+static int mceusb_release (struct inode *inode, struct file *file)
+{
+	struct usb_skel *dev;
+	int retval = 0;
+
+	dev = (struct usb_skel *)file->private_data;
+	if (dev == NULL) {
+		dbg (__FUNCTION__ " - object is NULL");
+		return -ENODEV;
+	}
+
+	dbg(__FUNCTION__ " - minor %d", dev->minor);
+
+	/* lock our minor table */
+	down (&minor_table_mutex);
+
+	/* lock our device */
+	down (&dev->sem);
+
+	if (dev->open_count <= 0) {
+		dbg (__FUNCTION__ " - device not opened");
+		retval = -ENODEV;
+		goto exit_not_opened;
+	}
+
+	if (dev->udev == NULL) {
+		/* the device was unplugged before the file was released */
+		up (&dev->sem);
+		mceusb_delete (dev);
+		up (&minor_table_mutex);
+		module_put(THIS_MODULE);
+		return 0;
+	}
+
+	/* decrement our usage count for the device */
+	--dev->open_count;
+	if (dev->open_count <= 0) {
+		/* shutdown any bulk writes that might be going on */
+		usb_unlink_urb (dev->write_urb);
+		dev->open_count = 0;
+	}
+
+	/* decrement our usage count for the module */
+	module_put(THIS_MODULE);
+
+  exit_not_opened:
+	up (&dev->sem);
+	up (&minor_table_mutex);
+
+	return retval;
+}
+
+static void msir_cleanup( struct usb_skel* dev )
+{
+	memset( dev->bulk_in_buffer, 0, dev->bulk_in_size );
+
+	memset( dev->usb_dbuffer, 0, sizeof(dev->usb_dbuffer) );
+	dev->usb_dstart = 0;
+	dev->usb_dcount = 0;
+	dev->usb_valid_bytes_in_bulk_buffer = 0;
+
+	memset( dev->mode2_data, 0, sizeof(dev->mode2_data) );
+	dev->mode2_partial_pkt_size = 0;
+	dev->mode2_count = 0;
+	dev->mode2_idx = 0;
+	dev->mode2_once = 0;
+	dev->last_was_repeat_gap = 0;
+}
+
+static int set_use_inc(void* data)
+{
+	/*    struct usb_skel* skel = (struct usb_skel*)data; */
+
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	/* check for unplug here */
+	struct usb_skel* dev = (struct usb_skel*) data;
+	if( !dev->udev )
+	{
+		lirc_unregister_plugin( dev->minor );
+		lirc_buffer_free( dev->plugin->rbuf );
+		kfree( dev->plugin->rbuf );
+		kfree( dev->plugin );
+	}
+
+	module_put(THIS_MODULE);
+}
+
+static int msir_available_mode2( struct usb_skel* dev )
+{
+	return dev->mode2_count - dev->last_was_repeat_gap;
+}
+
+static int msir_available_data( struct usb_skel* dev )
+{
+	return dev->usb_dcount;
+}
+
+static int msir_copy_mode2( struct usb_skel* dev, int* mode2_data, int count )
+{
+	int words_to_read = count;
+	//    int words_avail   = dev->mode2_count;
+	int words_avail = msir_available_mode2( dev );
+
+	if( !dev->mode2_once && words_avail )
+	{
+		int space = PULSE_MASK;
+		count--;
+		copy_to_user( mode2_data, &space, 4 );
+		dev->mode2_once = 1;
+
+		if( count )
+		{
+			mode2_data++;
+		}
+		else
+		{
+			return 1;
+		}
+	}
+
+	if( !words_avail )
+	{
+		return 0;
+	}
+
+	if( words_to_read > words_avail )
+	{
+		words_to_read = words_avail;
+	}
+
+	dbg(__FUNCTION__ " dev->mode2_count %d, dev->mode2_idx %d",
+	    dev->mode2_count, dev->mode2_idx);
+	dbg(__FUNCTION__ " words_avail %d words_to_read %d",
+	    words_avail, words_to_read);
+	copy_to_user( mode2_data, &( dev->mode2_data[dev->mode2_idx] ),
+		      words_to_read<<2 );
+	dbg(__FUNCTION__ " would copy_to_user() %d w", words_to_read);
+
+	dev->mode2_idx += words_to_read;
+	dev->mode2_count -= words_to_read;
+
+	if( dev->mode2_count == 0 )
+	{
+		dev->mode2_idx = 0;
+	}
+	else if( dev->mode2_count == 1 && dev->last_was_repeat_gap )
+	{
+		// shift down the repeat gap and map it up to a
+		// lirc-acceptable value
+		dev->mode2_data[0] = dev->mode2_data[dev->mode2_idx];
+		if( dev->mode2_data[0] >= 60000 &&
+		    dev->mode2_data[0] <= 70000 )
+			dev->mode2_data[0] = 95000;
+		//printk(__FUNCTION__ " shifting value %d down from %d prev %d\n", dev->mode2_data[0], dev->mode2_idx,
+		//    dev->mode2_data[dev->mode2_idx-1]);
+		dev->mode2_idx = 0;
+	}
+
+	return words_to_read;
+}
+
+static int msir_read_from_buffer( struct usb_skel* dev, char* buffer, int len )
+{
+	if( len > dev->usb_dcount )
+	{
+		len = dev->usb_dcount;
+	}
+	memcpy( buffer, dev->usb_dbuffer + dev->usb_dstart, len );
+	return len;
+}
+
+static int msir_mark_as_read( struct usb_skel* dev, int count )
+{
+	//    if( count != dev->usb_dcount )
+	//        printk(KERN_INFO __FUNCTION__ " count %d dev->usb_dcount %d dev->usb_dstart %d", count, dev->usb_dcount, dev->usb_dstart );
+	if( count > dev->usb_dcount )
+		count = dev->usb_dcount;
+	dev->usb_dcount -= count;
+	dev->usb_dstart += count;
+
+	if( !dev->usb_dcount )
+		dev->usb_dstart = 0;
+
+	return 0;
+}
+
+
+/*
+ * msir_fetch_more_data
+ *
+ * The goal here is to read in more remote codes from the remote. In
+ * the event that the remote isn't sending us anything, the caller
+ * will block until a key is pressed (i.e. this performs phys read,
+ * filtering, and queueing of data) unless dont_block is set to 1; in
+ * this situation, it will perform a few reads and will exit out if it
+ * does not see any appropriate data
+ *
+ * dev->sem should be locked when this function is called - fine grain
+ * locking isn't really important here anyways
+ *
+ * TODO change this to do partials based on term codes, or not always fill
+ */
+
+static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
+{
+	int retries = 0;
+	int count, this_read, partial;
+	int retval;
+	int writeindex, terminators = 0;
+	int bytes_to_read = sizeof(dev->usb_dbuffer) - dev->usb_dcount;
+	signed char* ibuf;
+	int sequential_empty_reads = 0;
+
+	/* special case where we are already full */
+	if( bytes_to_read == 0 )
+		return dev->usb_dcount;
+
+	/* shift down */
+	if( dev->usb_dcount && dev->usb_dstart != 0 )
+	{
+		printk("%s shifting %d bytes from %d\n", __FUNCTION__,
+			dev->usb_dcount, dev->usb_dstart );
+		memcpy( dev->usb_dbuffer, dev->usb_dbuffer + dev->usb_dstart,
+			dev->usb_dcount );
+	}
+
+	dev->usb_dstart = 0;
+
+	writeindex = dev->usb_dcount;
+
+	count = bytes_to_read;
+
+	ibuf = (signed char*)dev->bulk_in_buffer;
+	if( !dev->usb_valid_bytes_in_bulk_buffer )
+	{
+		memset( ibuf, 0, dev->bulk_in_size );
+	}
+
+#if 0
+	printk( __FUNCTION__ " going to read, dev->usb_dcount %d, bytes_to_read %d vbb %d\n", dev->usb_dcount, bytes_to_read,
+		dev->usb_valid_bytes_in_bulk_buffer );
+#endif
+	/* 8 is the minimum read size */
+	while( count > 8 )
+	{
+		int i, goodbytes = 0;
+
+		/* break out if we were interrupted */
+		if( signal_pending(current) )
+		{
+			printk("%s got signal %ld\n", __FUNCTION__,
+				current->pending.signal.sig[0]);
+			return dev->usb_dcount ? dev->usb_dcount : -EINTR;
+		}
+
+		/* or if we were unplugged */
+		if( !dev->udev )
+		{
+			return -ENODEV;
+		}
+
+		/* or on data issues */
+		if( writeindex == sizeof(dev->usb_dbuffer) )
+		{
+			printk("%s buffer full, returning\n", __FUNCTION__);
+			return dev->usb_dcount;
+		}
+
+		// always read the maximum
+		this_read = dev->bulk_in_size;
+
+		partial = 0;
+
+		if( dev->usb_valid_bytes_in_bulk_buffer ) {
+			retval = 0;
+			this_read = partial = dev->usb_valid_bytes_in_bulk_buffer;
+			dev->usb_valid_bytes_in_bulk_buffer = 0;
+		} else {
+			// This call always returns almost immediately
+			// with data, since this device will always
+			// provide a 2 byte response on a bulk
+			// read. Not exactly friendly to the usb bus
+			// or our load avg. We attempt to compensate
+			// for this on 2 byte reads below
+
+			memset( ibuf, 0, dev->bulk_in_size );
+			retval = usb_bulk_msg (dev->udev,
+					       usb_rcvbulkpipe
+					       (dev->udev,
+						dev->bulk_in_endpointAddr),
+					       (unsigned char*)ibuf, this_read,
+					       &partial, HZ*10);
+		}
+
+		if( retval )
+		{
+			/* break out on errors */
+			printk("%s got retval %d %d %d", __FUNCTION__,
+			       retval, this_read, partial );
+			if( retval == -EOVERFLOW && retries < 5 )
+			{
+				retries++;
+				interruptible_sleep_on_timeout
+					( &dev->wait_q, HZ );
+				continue;
+			}
+			else
+			{
+				return -EIO;
+			}
+		} else {
+			retries = 0;
+		}
+
+		if( partial )
+		{
+			this_read = partial;
+		}
+
+		/* All packets i've seen start with b1 60. If no data
+		 * was actually available, the transceiver still gives
+		 * this byte pair back. We only care about actual
+		 * codes, so we can safely ignore these 2 byte reads
+		 */
+		if( this_read > 2 )
+		{
+#if 0
+			printk( __FUNCTION__ " read %d bytes partial %d goodbytes %d writeidx %d\n",
+				this_read, partial, goodbytes, writeindex );
+#endif
+			sequential_empty_reads = 0;
+			/* copy from the input buffer to the capture buffer */
+			for( i = 0; i < this_read; i++ )
+			{
+				if( (((unsigned char*)ibuf)[i] == 0xb1) ||
+				    (ibuf[i] == 0x60) )
+					;
+				else
+				{
+					if( writeindex == sizeof(dev->usb_dbuffer) )
+					{
+						/* this can happen in
+						 * repeats, where
+						 * basically the bulk
+						 * buffer is getting
+						 * spammed and we
+						 * aren't processing
+						 * data fast enough
+						 */
+#if 1
+						dev->usb_valid_bytes_in_bulk_buffer = this_read - i;
+						memcpy( ibuf, &( ibuf[i] ),
+							dev->usb_valid_bytes_in_bulk_buffer );
+#endif
+						break;
+					}
+					dev->usb_dbuffer[writeindex++] = ibuf[i];
+					goodbytes++;
+
+					if( ibuf[i] == 0x7f )
+					{
+						terminators++;
+
+						/* This is a bug - we should either get 10 or 15 */
+						if( terminators > 15 )
+						{
+							dbg("bugbug - terminators %d at %d gb %d", terminators, i, goodbytes );
+						} else
+							dbg("terminator %d at %d gb %d", terminators, i, goodbytes );
+						dbg("writeindex %d", writeindex);
+					}
+					else if( terminators )
+					{
+						if( ((unsigned char*)ibuf)[i] == 128 )
+						{
+							/* copy back any remainder and break out */
+							dev->usb_valid_bytes_in_bulk_buffer = this_read - (i + 1);
+							if( dev->usb_valid_bytes_in_bulk_buffer )
+							{
+								memcpy( ibuf, &( ibuf[i+1] ), dev->usb_valid_bytes_in_bulk_buffer );
+							}
+
+							count = 0;
+							break;
+						}
+						if( terminators == 10 ||
+						    terminators == 15 )
+							dbg("post-termination data %d idx %d %d", ibuf[i], dev->usb_dcount, i);
+					}
+				}
+			}
+			dev->usb_dcount += goodbytes;
+			count -= goodbytes;
+		} else {
+			sequential_empty_reads++;
+
+			// assume no data
+			if( dont_block && sequential_empty_reads == 5 )
+				break;
+
+			// Try to be nice to the usb bus by sleeping
+			// for a bit here before going in to the next
+			// read
+			interruptible_sleep_on_timeout( &dev->wait_q, 1 );
+		}
+
+	}
+	/* return the number of bytes available now */
+	return dev->usb_dcount;
+}
+
+// layout of data, per Christoph Bartelmus
+// The protocol is:
+// 1 byte: -length of following packet
+// the following bytes of the packet are:
+// negative value:
+//   -(number of time units) of pulse
+// positive value:
+//   (number of time units) of space
+// one time unit is 50us
+
+#define MCE_TIME_UNIT 50
+
+// returns the number of bytes processed from the 'usb_data' array
+static int msir_generate_mode2( struct usb_skel* dev, signed char* usb_data,
+				int bytecount )
+{
+	int bytes_left_in_packet = 0;
+	int pos = 0;
+	int mode2count = 0;
+	int last_was_pulse = 1;
+	int last_pkt = 0;
+	int split_pkt_size = 0;
+	// XXX no bounds checking here
+	int* mode2_data;
+	int mode2_limit = sizeof( dev->mode2_data ) - dev->mode2_count;
+
+	// If data exists in the buffer, we have to point to the last
+	// item there so we can append consecutive pulse/space
+	// ops. Otherwise, set last_was_pulse 1 (since the first byte
+	// is a pulse, and we want to store in the first array
+	// location
+	if( dev->mode2_count == 0 )
+	{
+		mode2_data = &( dev->mode2_data[0] );
+		last_was_pulse = (dev->mode2_once ? 1 : 0);
+		mode2_data[0] = 0;
+	}
+	else
+	{
+		mode2_data = &( dev->mode2_data[dev->mode2_idx +
+						dev->mode2_count - 1] );
+		last_was_pulse = (mode2_data[0] & PULSE_BIT) ? 1 : 0;
+	}
+
+	while( pos < bytecount && !last_pkt &&
+	       (mode2_limit > (dev->mode2_count + mode2count)) )
+	{
+		if( dev->mode2_partial_pkt_size )
+		{
+			bytes_left_in_packet = dev->mode2_partial_pkt_size;
+			dev->mode2_partial_pkt_size = 0;
+		}
+		else {
+			bytes_left_in_packet = 128 + usb_data[pos];
+
+			// XXX out of sync? find the next packet
+			// header, establish a distance, and fix the
+			// packet size
+			if( bytes_left_in_packet > 4 )
+			{
+				int i;
+				for( i = pos + 1; i < pos + 4; i++ )
+				{
+					if( (int)(128 + usb_data[i]) <= 4 )
+					{
+						bytes_left_in_packet = i - pos;
+						break;
+					}
+				}
+			}
+			else
+			{
+				// otherwise, increment past the header
+				pos++;
+			}
+		}
+
+		// special case where we have a terminator at the
+		// start but not at the end of this packet, indicating
+		// potential repeat, or the packet is less than 4
+		// bytes, indicating end also special case a split
+		// starting packet
+		if( pos > 1 && bytes_left_in_packet < 4 )
+		{
+			// end
+			last_pkt = 1;
+		}
+		else if( usb_data[pos] == 127 &&
+			 usb_data[pos+bytes_left_in_packet-1] != 127 )
+		{
+			// the genius ir transciever is blending data
+			// from the repeat events into a single
+			// packet. how we handle this is by splitting
+			// the packet (and truncating the packet size
+			// value we read), then rewriting a new packet
+			// header onto the outbound data.  it's
+			// ultraghetto.
+			while( usb_data[pos+bytes_left_in_packet-1] != 127 )
+			{
+				bytes_left_in_packet--;
+				split_pkt_size++;
+			}
+			// repeat code
+			last_pkt = 2;
+		}
+		while( bytes_left_in_packet && pos < bytecount )
+		{
+			int keycode = usb_data[pos];
+			int pulse = 0;
+
+			pos++;
+			if( keycode < 0 )
+			{
+				pulse = 1;
+				keycode += 128;
+			}
+			keycode *= MCE_TIME_UNIT;
+
+			// on a state change, increment the position
+			// for the output buffer and initialize the
+			// current spot to 0; otherwise we need to
+			// concatenate pulse/gap values for lirc to be
+			// happy
+			if( pulse != last_was_pulse &&
+			    (mode2count || mode2_data[mode2count]))
+			{
+				if( dev->last_was_repeat_gap )
+				{
+					//printk( __FUNCTION__ " transition with lwrg set lastval %d idx1 %d idx2 %d\n",
+					//  mode2_data[mode2count],mode2count, dev->mode2_count+dev->mode2_idx-1 );
+				}
+				mode2count++;
+				mode2_data[mode2count] = 0;
+			}
+
+			mode2_data[mode2count] += keycode;
+
+			// Or in the pulse bit, and map all gap
+			// lengths to a fixed value; this makes lirc
+			// happy, sort of.
+			if( pulse ) {
+				mode2_data[mode2count] |= PULSE_BIT;
+				dev->last_was_repeat_gap = 0;
+			}
+
+			last_was_pulse = pulse;
+			bytes_left_in_packet--;
+		}
+	}
+
+	// If the last value in the data array is a repeat gap, set
+	// the last_was_repeat_gap flag
+	if( mode2_data[mode2count] > 20000 && mode2_data[mode2count] < 70000 )
+	{
+		// printk(__FUNCTION__ " setting lwrg for val %d idx1 %d idx2 %d\n",
+		//    mode2_data[mode2count], mode2count, dev->mode2_count+dev->mode2_idx-1 );
+		dev->last_was_repeat_gap = 1;
+	} else {
+		dev->last_was_repeat_gap = 0;
+	}
+
+	// this is a bit tricky; we need to change to a counter, but
+	// if we already had data in dev->mode2_data, then byte 0
+	// actually was pre-existing data and shouldn't be counted
+	if( mode2count && !dev->mode2_count )
+	{
+		mode2count++;
+		//        printk(__FUNCTION__ " mode2count++ to %d\n", mode2count);
+	}
+
+	// never lie about how much output we have
+	dev->mode2_count += mode2count;
+
+	if( last_pkt == 1 )
+	{
+		return bytecount;
+	}
+	else
+	{
+		//  note the partial pkt size, and make sure we only claim
+		//  the bytes we processed
+		if( last_pkt == 2 )
+		{
+			dev->mode2_partial_pkt_size = split_pkt_size;
+		}
+#if 1
+		// XXX this i am not sure about; it seems like this should be required, but it
+		// isn't, and seems to cause problems
+		else
+		{
+			dev->mode2_partial_pkt_size = bytes_left_in_packet;
+		}
+#endif
+		return pos;
+	}
+}
+
+static ssize_t mceusb_read( struct file* file, char* buffer,
+			    size_t count, loff_t* ppos)
+{
+	char _data_buffer[128];
+	struct usb_skel* dev;
+	int read_count;
+	int bytes_copied = 0;
+
+	dev = (struct usb_skel*) file->private_data;
+
+	if( (count % 4) != 0 )
+	{
+		return -EINVAL;
+	}
+
+	down( &dev->sem );
+
+	/* verify that the device wasn't unplugged */
+	if (dev->udev == NULL) {
+		up( &dev->sem );
+		return -ENODEV;
+	}
+
+	dbg(__FUNCTION__ " (1) calling msir_copy_mode2 with %d", count);
+	bytes_copied = 4 * msir_copy_mode2( dev, (int*)buffer, count >> 2 );
+	if( bytes_copied == count )
+	{
+		up( &dev->sem );
+		return count;
+	}
+
+	/* we didn't get enough mode2 data. the process now is a bit complex
+	 * 1. see if we have data read from the usb device that hasn't
+	 *    been converted to mode2; if so, convert that, and try to
+	 *    copy that out
+	 * 2. otherwise, go ahead and read more, then convert that, then copy
+	 */
+
+	if( dev->usb_dcount )
+	{
+		read_count = msir_read_from_buffer( dev, _data_buffer, 128 );
+		read_count = msir_generate_mode2
+			( dev, (signed char*)_data_buffer, read_count );
+		msir_mark_as_read( dev, read_count );
+		bytes_copied += (4 * msir_copy_mode2
+				 ( dev, (int*)(buffer + bytes_copied),
+				   (count-bytes_copied) >> 2 ));
+	}
+
+	if( bytes_copied == count )
+	{
+		up( &dev->sem );
+		return count;
+	}
+
+	/* read more data in a loop until we get enough */
+	while( bytes_copied < count )
+	{
+		read_count = msir_fetch_more_data
+			( dev, (file->f_flags & O_NONBLOCK ? 1 : 0) );
+
+		if( read_count <= 0 )
+		{
+			up( &dev->sem );
+			return (read_count ? read_count : -EWOULDBLOCK);
+		}
+
+		read_count = msir_read_from_buffer( dev, _data_buffer, 128 );
+		read_count = msir_generate_mode2
+			( dev, (signed char*)_data_buffer, read_count );
+		msir_mark_as_read( dev, read_count );
+
+		bytes_copied += (4 * msir_copy_mode2
+				 ( dev, (int*)(buffer + bytes_copied),
+				   (count-bytes_copied) >> 2 ));
+	}
+
+	up( &dev->sem );
+	return bytes_copied;
+}
+
+/**
+ * mceusb_poll
+ */
+static unsigned int mceusb_poll(struct file* file, poll_table* wait)
+{
+	struct usb_skel* dev;
+	int data;
+	dev = (struct usb_skel*)file->private_data;
+
+	// So this is a crummy poll. Unfortunately all the lirc tools
+	// assume your hardware is interrupt driven. Instead, we have
+	// to actually read here to see whether or not there is data
+	// (unless we have a key saved up - unlikely )
+
+	//    if( dev->usb_dcount || dev->mode2_count )
+	if( msir_available_data( dev ) || msir_available_mode2( dev ) )
+	{
+		return POLLIN | POLLRDNORM;
+	}
+	else {
+		down( &dev->sem );
+		data = msir_fetch_more_data( dev, 1 );
+		up( &dev->sem );
+
+		if( data )
+			return POLLIN | POLLRDNORM;
+	}
+
+	return 0;
+}
+
+/**
+ *	mceusb_write
+ */
+static ssize_t mceusb_write (struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+	struct usb_skel *dev;
+	ssize_t bytes_written = 0;
+	int retval = 0;
+
+	dev = (struct usb_skel *)file->private_data;
+
+	dbg(__FUNCTION__ " - minor %d, count = %d", dev->minor, count);
+
+	/* lock this object */
+	down (&dev->sem);
+
+	/* verify that the device wasn't unplugged */
+	if (dev->udev == NULL) {
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	/* verify that we actually have some data to write */
+	if (count == 0) {
+		dbg(__FUNCTION__ " - write request of 0 bytes");
+		goto exit;
+	}
+
+	/* see if we are already in the middle of a write */
+	if (dev->write_urb->status == -EINPROGRESS) {
+		dbg (__FUNCTION__ " - already writing");
+		goto exit;
+	}
+
+	/* we can only write as much as 1 urb will hold */
+	bytes_written = (count > dev->bulk_out_size) ?
+		dev->bulk_out_size : count;
+
+	/* copy the data from userspace into our urb */
+	if (copy_from_user(dev->write_urb->transfer_buffer, buffer,
+			   bytes_written)) {
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	usb_mceusb_debug_data (__FUNCTION__, bytes_written,
+			       dev->write_urb->transfer_buffer);
+
+	/* set up our urb */
+	usb_fill_bulk_urb(dev->write_urb, dev->udev,
+		      usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+		      dev->write_urb->transfer_buffer, bytes_written,
+		      mceusb_write_bulk_callback, dev);
+
+	/* send the data out the bulk port */
+	//FIXME what mem_flags should be used?
+	retval = usb_submit_urb(dev->write_urb, 0);
+	if (retval) {
+		err("%s - failed submitting write urb, error %d",
+		    __FUNCTION__, retval);
+	} else {
+		retval = bytes_written;
+	}
+
+  exit:
+	/* unlock the device */
+	up (&dev->sem);
+
+	return retval;
+}
+
+/*
+ *	mceusb_write_bulk_callback
+ */
+
+//static void mceusb_write_bulk_callback (struct urb *urb)
+static void mceusb_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_skel *dev = (struct usb_skel *)urb->context;
+
+	dbg(__FUNCTION__ " - minor %d", dev->minor);
+
+	if ((urb->status != -ENOENT) &&
+	    (urb->status != -ECONNRESET)) {
+		dbg(__FUNCTION__ " - nonzero write bulk status received: %d",
+		    urb->status);
+		return;
+	}
+
+	return;
+}
+
+/**
+ *	mceusb_probe
+ *
+ *	Called by the usb core when a new device is connected that it
+ *	thinks this driver might be interested in.
+ */
+//static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
+//			   const struct usb_device_id *id)
+static int mceusb_probe(struct usb_interface *intf,
+			   const struct usb_device_id *id)
+{
+	struct usb_skel *dev = NULL;
+	struct usb_interface_descriptor *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	struct lirc_plugin* plugin;
+	struct lirc_buffer* rbuf;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int minor;
+	int buffer_size;
+	int i;
+	char name[10];
+
+	//FIXME what to return?
+	/* See if the device offered us matches what we can accept */
+	if ((udev->descriptor.idVendor != USB_MCEUSB_VENDOR_ID) ||
+	    (udev->descriptor.idProduct != USB_MCEUSB_PRODUCT_ID)) {
+		return -ENODEV;
+	}
+
+	/* select a "subminor" number (part of a minor number) */
+	down (&minor_table_mutex);
+	for (minor = 0; minor < MAX_DEVICES; ++minor) {
+		if (minor_table[minor] == NULL)
+			break;
+	}
+	if (minor >= MAX_DEVICES) {
+		info ("Too many devices plugged in, can not handle this device.");
+		goto exit;
+	}
+
+	/* allocate memory for our device state and intialize it */
+	dev = kmalloc (sizeof(struct usb_skel), GFP_KERNEL);
+	if (dev == NULL) {
+		err ("Out of memory");
+		goto exit;
+	}
+	minor_table[minor] = dev;
+
+	init_MUTEX (&dev->sem);
+	dev->udev = udev;
+	dev->interface = intf;
+	dev->minor = minor;
+
+	//FIXME not sure if it is properly done
+	/* set up the endpoint information */
+	/* check out the endpoints */
+	iface_desc = &intf->altsetting[0].desc;
+	for (i = 0; i < iface_desc->bNumEndpoints; ++i) {
+		endpoint = &intf->altsetting[0].endpoint[i].desc;
+
+		if ((endpoint->bEndpointAddress & 0x80) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_in_size = buffer_size;
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_in_buffer = kmalloc (buffer_size, GFP_KERNEL);
+			if (!dev->bulk_in_buffer) {
+				err("Couldn't allocate bulk_in_buffer");
+				goto error;
+			}
+		}
+
+		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			// FIXME what mem_flags?
+			dev->write_urb = usb_alloc_urb(0, 0);
+			if (!dev->write_urb) {
+				err("No free urbs available");
+				goto error;
+			}
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulk_out_size = buffer_size;
+			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
+			if (!dev->bulk_out_buffer) {
+				err("Couldn't allocate bulk_out_buffer");
+				goto error;
+			}
+			usb_fill_bulk_urb(dev->write_urb, udev,
+				      usb_sndbulkpipe
+				      (udev, endpoint->bEndpointAddress),
+				      dev->bulk_out_buffer, buffer_size,
+				      mceusb_write_bulk_callback, dev);
+		}
+	}
+
+	memset( dev->mode2_data, 0, sizeof( dev->mode2_data ) );
+	dev->mode2_idx = 0;
+	dev->mode2_count = 0;
+	dev->mode2_partial_pkt_size = 0;
+	dev->mode2_once = 0;
+	dev->last_was_repeat_gap = 0;
+
+	/* Set up our lirc plugin */
+	if(!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+		err("out of memory");
+		goto error;
+	}
+	memset( plugin, 0, sizeof(struct lirc_plugin) );
+
+	if(!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+		err("out of memory");
+		kfree( plugin );
+		goto error;
+	}
+	/* the lirc_atiusb module doesn't memset rbuf here ... ? */
+	if( lirc_buffer_init( rbuf, sizeof(lirc_t),
+			      sizeof(struct lirc_buffer))) {
+		err("out of memory");
+		kfree( plugin );
+		kfree( rbuf );
+		goto error;
+	}
+	strcpy(plugin->name, "lirc_mce ");
+	plugin->minor       = minor;
+	plugin->code_length = sizeof(lirc_t);
+	plugin->features    = LIRC_CAN_REC_MODE2; // | LIRC_CAN_SEND_MODE2;
+	plugin->data        = dev;
+	plugin->rbuf        = rbuf;
+	plugin->ioctl       = NULL;
+	plugin->set_use_inc = &set_use_inc;
+	plugin->set_use_dec = &set_use_dec;
+	plugin->fops        = &mceusb_fops;
+	if( lirc_register_plugin( plugin ) < 0 )
+	{
+		kfree( plugin );
+		lirc_buffer_free( rbuf );
+		kfree( rbuf );
+		goto error;
+	}
+	dev->plugin = plugin;
+
+	mceusb_setup( udev );
+
+	/* let the user know what node this device is now attached to */
+	info ("USB Microsoft IR Transceiver device now attached to msir%d",
+	      dev->minor);
+	goto exit;
+
+  error:
+	mceusb_delete (dev);
+	dev = NULL;
+
+  exit:
+	up (&minor_table_mutex);
+	//FIXME should return status
+	return 0;
+}
+
+/**
+ *	mceusb_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ */
+//FIXME currently broken
+//static void mceusb_disconnect(struct usb_device *udev, void *ptr)
+static void mceusb_disconnect(struct usb_interface *intf)
+{
+	int minor;
+
+	down (&minor_table_mutex);
+	down (&dev->sem);
+
+	minor = dev->minor;
+
+	/* unhook lirc things */
+	lirc_unregister_plugin( intf->minor );
+	lirc_buffer_free( dev->plugin->rbuf );
+	kfree( dev->plugin->rbuf );
+	kfree( dev->plugin );
+
+	/* if the device is not opened, then we clean up right now */
+	if (!dev->open_count) {
+		up (&dev->sem);
+		mceusb_delete (dev);
+	} else {
+		dev->udev = NULL;
+		up (&dev->sem);
+	}
+
+	info("USB Skeleton #%d now disconnected", minor);
+	up (&minor_table_mutex);
+	return NULL;
+}
+
+
+
+/**
+ *	usb_mceusb_init
+ */
+static int __init usb_mceusb_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&mceusb_driver);
+	if (result < 0) {
+		err("usb_register failed for the "__FILE__" driver. Error number %d",
+		    result);
+		return -1;
+	}
+
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+}
+
+
+/**
+ *	usb_mceusb_exit
+ */
+static void __exit usb_mceusb_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&mceusb_driver);
+}
+
+
+module_init (usb_mceusb_init);
+module_exit (usb_mceusb_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_parallel.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_parallel.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_parallel.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_parallel.c	2006-08-23 13:29:33.956484000 +0100
@@ -0,0 +1,749 @@
+/*      $Id: lirc_parallel.c,v 5.18 2002/11/19 20:22:07 ranty Exp $      */
+
+/****************************************************************************
+ ** lirc_parallel.c *********************************************************
+ ****************************************************************************
+ *
+ * lirc_parallel - device driver for infra-red signal receiving and
+ *                 transmitting unit built by the author
+ *
+ * Copyright (C) 1998 Christoph Bartelmus <lirc@bartelmus.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/***********************************************************************
+ *************************       Includes        ***********************
+ ***********************************************************************/
+
+#include <linux/version.h>
+
+#include <linux/config.h>
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/time.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/signal.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/parport.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+#include "lirc_parallel.h"
+
+#define LIRC_DRIVER_NAME "lirc_parallel"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#define KERNEL26                1
+#else
+#define KERNEL26                0
+#endif
+
+/***********************************************************************
+ *************************   Globale Variablen   ***********************
+ ***********************************************************************/
+
+unsigned int irq = CONFIG_LIRC_IRQ_PARALLEL;
+unsigned int io = CONFIG_LIRC_PORT_PARALLEL;
+#ifdef CONFIG_LIRC_TIMER
+unsigned int timer = 0;
+unsigned int default_timer = CONFIG_LIRC_TIMER;
+#endif
+
+#define WBUF_SIZE (256)
+#define RBUF_SIZE (256) /* this must be a power of 2 larger than 1 */
+
+static lirc_t wbuf[WBUF_SIZE];
+static lirc_t rbuf[RBUF_SIZE];
+
+DECLARE_WAIT_QUEUE_HEAD(lirc_wait);
+
+unsigned int rptr=0,wptr=0;
+unsigned int lost_irqs=0;
+int is_open=0;
+
+struct parport *pport;
+struct pardevice *ppdevice;
+int is_claimed=0;
+
+int pf(void *handle);
+void kf(void *handle);
+
+/***********************************************************************
+ *************************   Interne Funktionen  ***********************
+ ***********************************************************************/
+
+unsigned int __inline__ in(int offset)
+{
+	switch(offset)
+	{
+	case LIRC_LP_BASE:
+		return(parport_read_data(pport));
+	case LIRC_LP_STATUS:
+		return(parport_read_status(pport));
+	case LIRC_LP_CONTROL:
+		return(parport_read_control(pport));
+	}
+	return(0); /* make compiler happy */
+}
+
+void __inline__ out(int offset, int value)
+{
+	switch(offset)
+	{
+	case LIRC_LP_BASE:
+		parport_write_data(pport,value);
+		break;
+	case LIRC_LP_CONTROL:
+		parport_write_control(pport,value);
+		break;
+	case LIRC_LP_STATUS:
+		printk(KERN_INFO "%s: attempt to write to status register\n",
+		       LIRC_DRIVER_NAME);
+		break;
+	}
+}
+
+unsigned int __inline__ lirc_get_timer(void)
+{
+	return(in(LIRC_PORT_TIMER)&LIRC_PORT_TIMER_BIT);
+}
+
+unsigned int __inline__  lirc_get_signal(void)
+{
+	return(in(LIRC_PORT_SIGNAL)&LIRC_PORT_SIGNAL_BIT);
+}
+
+void __inline__ lirc_on(void)
+{
+	out(LIRC_PORT_DATA,LIRC_PORT_DATA_BIT);
+}
+
+void __inline__ lirc_off(void)
+{
+	out(LIRC_PORT_DATA,0);
+}
+
+unsigned int init_CONFIG_LIRC_TIMER(void)
+{
+	struct timeval tv,now;
+	unsigned int level,newlevel,timeelapsed,newtimer;
+	int count=0;
+
+	do_gettimeofday(&tv);
+	tv.tv_sec++;                     /* wait max. 1 sec. */
+	level=lirc_get_timer();
+	do
+	{
+		newlevel=lirc_get_timer();
+		if(level==0 && newlevel!=0) count++;
+		level=newlevel;
+		do_gettimeofday(&now);
+	}
+	while(count<1000 && (now.tv_sec<tv.tv_sec
+			     || (now.tv_sec==tv.tv_sec
+				 && now.tv_usec<tv.tv_usec)));
+
+	timeelapsed=((now.tv_sec+1-tv.tv_sec)*1000000
+		     +(now.tv_usec-tv.tv_usec));
+	if(count>=1000 && timeelapsed>0)
+	{
+		if(default_timer==0)                    /* autodetect timer */
+		{
+			newtimer=(1000000*count)/timeelapsed;
+			printk(KERN_INFO "%s: %u Hz timer detected\n",
+			       LIRC_DRIVER_NAME,newtimer);
+			return(newtimer);
+		}
+		else
+		{
+			newtimer=(1000000*count)/timeelapsed;
+			if(abs(newtimer-default_timer)>
+			   default_timer/10) /* bad timer */
+			{
+				printk(KERN_NOTICE "%s: bad timer: %u Hz\n",
+				       LIRC_DRIVER_NAME,newtimer);
+				printk(KERN_NOTICE "%s: using default timer: "
+				       "%u Hz\n",
+				       LIRC_DRIVER_NAME,default_timer);
+				return(default_timer);
+			}
+			else
+			{
+				printk(KERN_INFO "%s: %u Hz timer detected\n",
+				       LIRC_DRIVER_NAME,newtimer);
+				return(newtimer); /* use detected value */
+			}
+		}
+	}
+	else
+	{
+		printk(KERN_NOTICE "%s: no timer detected\n",LIRC_DRIVER_NAME);
+		return(0);
+	}
+}
+
+int lirc_claim(void)
+{
+	if(parport_claim(ppdevice)!=0)
+	{
+		printk(KERN_WARNING "%s: could not claim port\n",
+		       LIRC_DRIVER_NAME);
+		printk(KERN_WARNING "%s: waiting for port becoming available"
+		       "\n",LIRC_DRIVER_NAME);
+		if(parport_claim_or_block(ppdevice)<0)
+		{
+			printk(KERN_NOTICE "%s: could not claim port, giving"
+			       " up\n",LIRC_DRIVER_NAME);
+			return(0);
+		}
+	}
+	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
+	is_claimed=1;
+	return(1);
+}
+
+/***********************************************************************
+ *************************   interrupt handler  ************************
+ ***********************************************************************/
+
+static inline void rbuf_write(lirc_t signal)
+{
+	unsigned int nwptr;
+
+	nwptr=(wptr+1) & (RBUF_SIZE-1);
+	if(nwptr==rptr) /* no new signals will be accepted */
+	{
+		lost_irqs++;
+		printk(KERN_NOTICE "%s: buffer overrun\n",LIRC_DRIVER_NAME);
+		return;
+	}
+	rbuf[wptr]=signal;
+	wptr=nwptr;
+}
+
+void irq_handler(int i,void *blah,struct pt_regs * regs)
+{
+	struct timeval tv;
+	static struct timeval lasttv;
+	static int init=0;
+	long signal;
+	lirc_t data;
+	unsigned int level,newlevel;
+	unsigned int timeout;
+
+#ifdef CONFIG_MODULE_UNLOAD
+	if(!module_refcount(THIS_MODULE))
+		return;
+#endif
+
+	if(!is_claimed)
+	{
+		return;
+	}
+
+	/* disable interrupt */
+	/*
+	  disable_irq(irq);
+	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)&(~LP_PINTEN));
+	*/
+	if(in(1)&LP_PSELECD)
+	{
+		return;
+	}
+
+#ifdef CONFIG_LIRC_TIMER
+	if(init)
+	{
+		do_gettimeofday(&tv);
+
+	        signal=tv.tv_sec-lasttv.tv_sec;
+		if(signal>15)
+		{
+			data=PULSE_MASK;  /* really long time */
+		}
+		else
+		{
+			data=(lirc_t) (signal*1000000+
+				       tv.tv_usec-lasttv.tv_usec+
+				       LIRC_SFH506_DELAY);
+		};
+
+		rbuf_write(data); /* space */
+	}
+	else
+	{
+		if(timer==0) /* wake up; we'll lose this signal
+				but it will be garbage if the device
+				is turned on anyway
+			      */
+		{
+			timer=init_CONFIG_LIRC_TIMER();
+			/* enable_irq(irq); */
+			return;
+		}
+		init=1;
+	}
+
+	timeout=timer/10;           /* timeout after 1/10 sec. */
+	signal=1;
+	level=lirc_get_timer();
+	do{
+		newlevel=lirc_get_timer();
+		if(level==0 && newlevel!=0) signal++;
+		level=newlevel;
+
+		/* giving up */
+		if(signal>timeout || (in(1)&LP_PSELECD))
+		{
+			signal=0;
+			printk(KERN_NOTICE "%s: timeout\n",LIRC_DRIVER_NAME);
+			break;
+		}
+	}
+	while(lirc_get_signal());
+	if(signal!=0)
+	{
+		/* ajust value to usecs */
+		signal=(long) (((unsigned long long) signal)*1000000)/timer;
+
+		if(signal>LIRC_SFH506_DELAY)
+		{
+			data=signal-LIRC_SFH506_DELAY;
+		}
+		else
+		{
+			data=1;
+		}
+		rbuf_write(PULSE_BIT|data); /* pulse */
+	}
+	do_gettimeofday(&lasttv);
+#else
+	/* add your code here */
+#endif
+
+	wake_up_interruptible(&lirc_wait);
+
+	/* enable interrupt */
+	/*
+	  enable_irq(irq);
+	  out(LIRC_PORT_IRQ,in(LIRC_PORT_IRQ)|LP_PINTEN);
+	*/
+}
+
+/***********************************************************************
+ **************************   file_operations   ************************
+ ***********************************************************************/
+
+static loff_t lirc_lseek(struct file *filep,loff_t offset,int orig)
+{
+	return(-ESPIPE);
+}
+
+static ssize_t lirc_read(struct file *filep,char *buf,size_t n,loff_t *ppos)
+{
+	int result;
+	int count=0;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+
+	result=verify_area(VERIFY_WRITE,buf,n);
+	if(result) return(result);
+
+	add_wait_queue(&lirc_wait,&wait);
+	current->state=TASK_INTERRUPTIBLE;
+	while(count<n)
+	{
+		if(rptr!=wptr)
+		{
+			copy_to_user(buf+count,(char *) &rbuf[rptr],
+				     sizeof(lirc_t));
+			rptr=(rptr+1)&(RBUF_SIZE-1);
+			count+=sizeof(lirc_t);
+		}
+		else
+		{
+			if(filep->f_flags & O_NONBLOCK)
+			{
+				result=-EAGAIN;
+				break;
+			}
+			if (signal_pending(current))
+			{
+				result=-ERESTARTSYS;
+				break;
+			}
+			schedule();
+			current->state=TASK_INTERRUPTIBLE;
+		}
+	}
+	remove_wait_queue(&lirc_wait,&wait);
+	current->state=TASK_RUNNING;
+	return(count ? count:result);
+}
+
+static ssize_t lirc_write(struct file *filep,const char *buf,size_t n,
+			  loff_t *ppos)
+{
+	int result,count;
+	unsigned int i;
+	unsigned int level,newlevel;
+	unsigned long flags;
+	lirc_t counttimer;
+
+	if(!is_claimed)
+	{
+		return(-EBUSY);
+	}
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	result=verify_area(VERIFY_READ,buf,n);
+	if(result) return(result);
+
+	count=n/sizeof(lirc_t);
+
+	if(count>WBUF_SIZE || count%2==0) return(-EINVAL);
+
+	copy_from_user(wbuf,buf,n);
+
+#ifdef CONFIG_LIRC_TIMER
+	if(timer==0) /* try again if device is ready */
+	{
+		timer=init_CONFIG_LIRC_TIMER();
+		if(timer==0) return(-EIO);
+	}
+
+	/* ajust values from usecs */
+	for(i=0;i<count;i++)
+	{
+		wbuf[i]=(lirc_t) (((double) wbuf[i])*timer/1000000);
+	}
+
+	local_save_flags(flags);local_irq_disable();
+	i=0;
+	while(i<count)
+	{
+		level=lirc_get_timer();
+		counttimer=0;
+		lirc_on();
+		do
+		{
+			newlevel=lirc_get_timer();
+			if(level==0 && newlevel!=0) counttimer++;
+			level=newlevel;
+			if(in(1)&LP_PSELECD)
+			{
+				lirc_off();
+				local_irq_restore(flags); /* sti(); */
+				return(-EIO);
+			}
+		}
+		while(counttimer<wbuf[i]);i++;
+
+		lirc_off();
+		if(i==count) break;
+		counttimer=0;
+		do
+		{
+			newlevel=lirc_get_timer();
+			if(level==0 && newlevel!=0) counttimer++;
+			level=newlevel;
+			if(in(1)&LP_PSELECD)
+			{
+				local_irq_restore(flags); /* sti(); */
+				return(-EIO);
+			}
+		}
+		while(counttimer<wbuf[i]);i++;
+	}
+	local_irq_restore(flags); /* sti(); */
+#else
+	/*
+	   place code that handles write
+	   without extarnal timer here
+	*/
+#endif
+	return(n);
+}
+
+static unsigned int lirc_poll(struct file *file, poll_table * wait)
+{
+	poll_wait(file, &lirc_wait,wait);
+	if (rptr!=wptr)
+		return(POLLIN|POLLRDNORM);
+	return(0);
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		      unsigned long arg)
+{
+        int result;
+	unsigned long features=LIRC_CAN_SEND_PULSE|LIRC_CAN_REC_MODE2,mode;
+
+	switch(cmd)
+	{
+	case LIRC_GET_FEATURES:
+		result=put_user(features,(unsigned long *) arg);
+		if(result) return(result);
+		break;
+	case LIRC_GET_SEND_MODE:
+		result=put_user(LIRC_MODE_PULSE,(unsigned long *) arg);
+		if(result) return(result);
+		break;
+	case LIRC_GET_REC_MODE:
+		result=put_user(LIRC_MODE_MODE2,(unsigned long *) arg);
+		if(result) return(result);
+		break;
+	case LIRC_SET_SEND_MODE:
+		result=get_user(mode,(unsigned long *) arg);
+		if(result) return(result);
+		if(mode!=LIRC_MODE_PULSE) return(-EINVAL);
+		break;
+	case LIRC_SET_REC_MODE:
+		result=get_user(mode,(unsigned long *) arg);
+		if(result) return(result);
+		if(mode!=LIRC_MODE_MODE2) return(-ENOSYS);
+		break;
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+static int lirc_open(struct inode* node,struct file* filep)
+{
+#ifdef CONFIG_MODULE_UNLOAD
+	if(module_refcount(THIS_MODULE))
+	{
+		return(-EBUSY);
+	}
+#endif
+	if(!lirc_claim())
+	{
+		return(-EBUSY);
+	}
+	pport->ops->enable_irq(pport);
+
+	/* init read ptr */
+	rptr=wptr=0;
+	lost_irqs=0;
+
+	try_module_get(THIS_MODULE);
+	is_open=1;
+	return(0);
+}
+
+static int lirc_close(struct inode* node,struct file* filep)
+{
+	if(is_claimed)
+	{
+		is_claimed=0;
+		parport_release(ppdevice);
+	}
+	is_open=0;
+	module_put(THIS_MODULE);
+	return(0);
+}
+
+static struct file_operations lirc_fops =
+{
+	llseek:  lirc_lseek,
+	read:    lirc_read,
+	write:   lirc_write,
+	poll:    lirc_poll,
+	ioctl:   lirc_ioctl,
+	open:    lirc_open,
+	release: lirc_close
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       try_module_get(THIS_MODULE);
+#endif
+       return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       module_put(THIS_MODULE);
+#endif
+}
+static struct lirc_plugin plugin = {
+       name:           LIRC_DRIVER_NAME,
+       minor:          -1,
+       code_length:    1,
+       sample_rate:    0,
+       data:           NULL,
+       add_to_buf:     NULL,
+       get_queue:      NULL,
+       set_use_inc:    set_use_inc,
+       set_use_dec:    set_use_dec,
+       fops:           &lirc_fops,
+};
+
+static int __init lirc_parallel_init (void)
+{
+#ifndef KERNEL26
+	pport=parport_enumerate();
+	while(pport!=NULL)
+	{
+		if(pport->base==io)
+		{
+			break;
+		}
+		pport=pport->next;
+	}
+#else
+	pport=parport_find_base(io);
+#endif
+	if(pport==NULL)
+	{
+		printk(KERN_NOTICE "%s: no port at %x found\n",
+		       LIRC_DRIVER_NAME,io);
+		return(-ENXIO);
+	}
+	ppdevice=parport_register_device(pport,LIRC_DRIVER_NAME,
+					 pf,kf,irq_handler,0,NULL);
+	if(ppdevice==NULL)
+	{
+		printk(KERN_NOTICE "%s: parport_register_device() failed\n",
+		       LIRC_DRIVER_NAME);
+		return(-ENXIO);
+	}
+	if(parport_claim(ppdevice)!=0)
+		goto skip_init;
+	is_claimed=1;
+	out(LIRC_LP_CONTROL,LP_PSELECP|LP_PINITP);
+
+#ifdef CONFIG_LIRC_TIMER
+#       ifdef DEBUG
+	out(LIRC_PORT_DATA,LIRC_PORT_DATA_BIT);
+#       endif
+
+	timer=init_CONFIG_LIRC_TIMER();
+
+#       if 0 	/* continue even if device is offline */
+	if(timer==0)
+	{
+		is_claimed=0;
+		parport_release(pport);
+		parport_unregister_device(ppdevice);
+		return(-EIO);
+	}
+
+#       endif
+#       ifdef DEBUG
+	out(LIRC_PORT_DATA,0);
+#       endif
+#endif
+
+	is_claimed=0;
+	parport_release(ppdevice);
+ skip_init:
+	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0)
+	{
+		printk(KERN_NOTICE "%s: register_chrdev() failed\n",LIRC_DRIVER_NAME);
+		parport_unregister_device(ppdevice);
+		return(-EIO);
+	}
+	printk(KERN_INFO "%s: installed using port 0x%04x irq %d\n",LIRC_DRIVER_NAME,io,irq);
+	return(0);
+}
+
+static void __exit lirc_parallel_exit(void)
+{
+#ifdef CONFIG_MODULE_UNLOAD
+	if(module_refcount(THIS_MODULE)) return;
+#endif
+	parport_unregister_device(ppdevice);
+	lirc_unregister_plugin(plugin.minor);
+}
+
+static struct timer_list poll_timer;
+static void poll_state(unsigned long ignored);
+
+static void poll_state(unsigned long ignored)
+{
+	printk(KERN_NOTICE "%s: time\n",
+	       LIRC_DRIVER_NAME);
+	del_timer(&poll_timer);
+	if(is_claimed)
+		return;
+	kf(NULL);
+	if(!is_claimed)
+	{
+		printk(KERN_NOTICE "%s: could not claim port, giving up\n",
+		       LIRC_DRIVER_NAME);
+		init_timer(&poll_timer);
+		poll_timer.expires=jiffies+HZ;
+		poll_timer.data=(unsigned long) current;
+		poll_timer.function=poll_state;
+		add_timer(&poll_timer);
+	}
+}
+
+int pf(void *handle)
+{
+	pport->ops->disable_irq(pport);
+	is_claimed=0;
+	return(0);
+}
+
+
+void kf(void *handle)
+{
+	if(!is_open)
+		return;
+	if(!lirc_claim())
+		return;
+	pport->ops->enable_irq(pport);
+	/* this is a bit annoying when you actually print...*/
+	/*
+	printk(KERN_INFO "%s: reclaimed port\n",LIRC_DRIVER_NAME);
+	*/
+}
+
+MODULE_AUTHOR("Christoph Bartelmus");
+MODULE_DESCRIPTION("Infrared receiver driver for parallel ports.");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(io, "i");
+MODULE_PARM_DESC(io, "I/O address base (0x3bc, 0x378 or 0x278)");
+
+MODULE_PARM(irq, "i");
+MODULE_PARM_DESC(irq, "Interrupt (7 or 5)");
+
+module_init(lirc_parallel_init);
+module_exit(lirc_parallel_exit);
+
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_parallel.h linux-2.6.17.8-sh/drivers/char/lirc/lirc_parallel.h
--- linux-2.6.17.8/drivers/char/lirc/lirc_parallel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_parallel.h	2006-08-23 13:29:33.962485000 +0100
@@ -0,0 +1,24 @@
+/*      $Id: lirc_parallel.h,v 5.1 1999/07/21 18:23:37 columbus Exp $      */
+
+#ifndef _LIRC_PARALLEL_H
+#define _LIRC_PARALLEL_H
+
+#include <linux/lp.h>
+
+#define LIRC_PORT_LEN 3
+
+#define LIRC_LP_BASE    0
+#define LIRC_LP_STATUS  1
+#define LIRC_LP_CONTROL 2
+
+#define LIRC_PORT_DATA           LIRC_LP_BASE    /* base */
+#define LIRC_PORT_DATA_BIT               0x01    /* 1st bit */
+#define LIRC_PORT_TIMER        LIRC_LP_STATUS    /* status port */
+#define LIRC_PORT_TIMER_BIT          LP_PBUSY    /* busy signal */
+#define LIRC_PORT_SIGNAL       LIRC_LP_STATUS    /* status port */
+#define LIRC_PORT_SIGNAL_BIT          LP_PACK    /* ack signal */
+#define LIRC_PORT_IRQ         LIRC_LP_CONTROL    /* control port */
+
+#define LIRC_SFH506_DELAY 0             /* delay t_phl in usecs */
+
+#endif
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_serial.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_serial.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_serial.c	2006-08-23 13:29:33.971484000 +0100
@@ -0,0 +1,1056 @@
+/*      $Id: lirc_serial.c,v 5.49 2004/01/12 10:21:12 lirc Exp $      */
+
+/****************************************************************************
+ ** lirc_serial.c ***********************************************************
+ ****************************************************************************
+ *
+ * lirc_serial - Device driver that records pulse- and pause-lengths
+ *               (space-lengths) between DDCD event on a serial port.
+ *
+ * Copyright (C) 1996,97 Ralph Metzler <rjkm@thp.uni-koeln.de>
+ * Copyright (C) 1998 Trent Piepho <xyzzy@u.washington.edu>
+ * Copyright (C) 1998 Ben Pfaff <blp@gnu.org>
+ * Copyright (C) 1999 Christoph Bartelmus <lirc@bartelmus.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* Steve's changes to improve transmission fidelity:
+     - for systems with the rdtsc instruction and the clock counter, a
+       send_pule that times the pulses directly using the counter.
+       This means that the CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY fudge is
+       not needed. Measurement shows very stable waveform, even where
+       PCI activity slows the access to the UART, which trips up other
+       versions.
+     - For other system, non-integer-microsecond pulse/space lengths,
+       done using fixed point binary. So, much more accurate carrier
+       frequency.
+     - fine tuned transmitter latency, taking advantage of fractional
+       microseconds in previous change
+     - Fixed bug in the way transmitter latency was accounted for by
+       tuning the pulse lengths down - the send_pulse routine ignored
+       this overhead as it timed the overall pulse length - so the
+       pulse frequency was right but overall pulse length was too
+       long. Fixed by accounting for latency on each pulse/space
+       iteration.
+
+   Steve Davies <steve@daviesfam.org>  July 2001
+
+   Flameeyes Patches Contribution
+    - Ronald Wahl <ronald.wahl@informatik.tu-chemnitz.de> sent a patch to
+      eliminate a deadlock on SMP systems.
+    - Florian Steinel <Florian.Steinel@t-online.de> sent a patch to fix irq
+      disabling by kernel.
+    - Jindrich Makovicka <makovick@kmlinux.fjfi.cvut.cz> sent a patch fixing
+      one-shot use of lirc_serial.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+#if defined(rdtsc)
+
+#define USE_RDTSC
+#warning "Note: using rdtsc instruction"
+#endif
+
+struct lirc_serial
+{
+	int type;
+	int signal_pin;
+	int signal_pin_change;
+	int on;
+	int off;
+	long (*send_pulse)(unsigned long length);
+	void (*send_space)(long length);
+	int features;
+};
+
+#define LIRC_HOMEBREW        0
+#define LIRC_IRDEO           1
+#define LIRC_IRDEO_REMOTE    2
+#define LIRC_ANIMAX          3
+#define LIRC_IGOR            4
+
+#ifdef CONFIG_LIRC_SERIAL_IRDEO
+int type=LIRC_IRDEO;
+#elif defined(CONFIG_LIRC_SERIAL_IRDEO_REMOTE)
+int type=LIRC_IRDEO_REMOTE;
+#elif defined(CONFIG_LIRC_SERIAL_ANIMAX)
+int type=LIRC_ANIMAX;
+#elif defined(CONFIG_LIRC_SERIAL_IGOR)
+int type=LIRC_IGOR;
+#else
+int type=LIRC_HOMEBREW;
+#endif
+
+#ifdef CONFIG_LIRC_SERIAL_SOFTCARRIER
+int softcarrier=1;
+#else
+int softcarrier=0;
+#endif
+
+static int sense = -1;   /* -1 = auto, 0 = active high, 1 = active low */
+
+static int io = CONFIG_LIRC_PORT_SERIAL;
+
+static int irq = CONFIG_LIRC_IRQ_SERIAL;
+
+static int debug = 0;
+
+MODULE_PARM(type, "i");
+MODULE_PARM_DESC(type, "Hardware type (0 = home-brew, 1 = IRdeo,"
+		 " 2 = IRdeo Remote, 3 = AnimaX");
+
+MODULE_PARM(io, "i");
+MODULE_PARM_DESC(io, "I/O address base (0x3f8 or 0x2f8)");
+
+MODULE_PARM(irq, "i");
+MODULE_PARM_DESC(irq, "Interrupt (4 or 3)");
+
+MODULE_PARM(sense, "i");
+MODULE_PARM_DESC(sense, "Override autodetection of IR receiver circuit"
+		 " (0 = active high, 1 = active low )");
+
+MODULE_PARM(softcarrier, "i");
+MODULE_PARM_DESC(softcarrier, "Software carrier (0 = off, 1 = on)");
+
+MODULE_PARM(debug,"i");
+
+#define dprintk           if (debug) printk
+
+#define LOGHEAD           "lirc_serial: "
+
+/* forward declarations */
+long send_pulse_irdeo(unsigned long length);
+long send_pulse_homebrew(unsigned long length);
+void send_space_irdeo(long length);
+void send_space_homebrew(long length);
+
+struct lirc_serial hardware[]=
+{
+	/* home-brew receiver/transmitter */
+	{
+		LIRC_HOMEBREW,
+		UART_MSR_DCD,
+		UART_MSR_DDCD,
+		UART_MCR_RTS|UART_MCR_OUT2|UART_MCR_DTR,
+		UART_MCR_RTS|UART_MCR_OUT2,
+		send_pulse_homebrew,
+		send_space_homebrew,
+		(
+#ifdef CONFIG_LIRC_SERIAL_TRANSMITTER
+		 LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SET_SEND_CARRIER|
+		 LIRC_CAN_SEND_PULSE|
+#endif
+		 LIRC_CAN_REC_MODE2)
+	},
+
+	/* IRdeo classic */
+	{
+		LIRC_IRDEO,
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_OUT2,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		send_pulse_irdeo,
+		send_space_irdeo,
+		(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SEND_PULSE|
+		 LIRC_CAN_REC_MODE2)
+	},
+
+	/* IRdeo remote */
+	{
+		LIRC_IRDEO_REMOTE,
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		send_pulse_irdeo,
+		send_space_irdeo,
+		(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SEND_PULSE|
+		 LIRC_CAN_REC_MODE2)
+	},
+
+	/* AnimaX */
+	{
+		LIRC_ANIMAX,
+		UART_MSR_DCD,
+		UART_MSR_DDCD,
+		0,
+		UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2,
+		NULL,
+		NULL,
+		LIRC_CAN_REC_MODE2
+	},
+
+	/* home-brew receiver/transmitter (Igor Cesko's variation) */
+	{
+		LIRC_HOMEBREW,
+		UART_MSR_DSR,
+		UART_MSR_DDSR,
+		UART_MCR_RTS|UART_MCR_OUT2|UART_MCR_DTR,
+		UART_MCR_RTS|UART_MCR_OUT2,
+		send_pulse_homebrew,
+		send_space_homebrew,
+		(
+#ifdef CONFIG_LIRC_SERIAL_TRANSMITTER
+		 LIRC_CAN_SET_SEND_DUTY_CYCLE|
+		 LIRC_CAN_SET_SEND_CARRIER|
+		 LIRC_CAN_SEND_PULSE|
+#endif
+		 LIRC_CAN_REC_MODE2)
+	}
+
+};
+
+#define LIRC_DRIVER_NAME "lirc_serial"
+
+#define RS_ISR_PASS_LIMIT 256
+
+/* A long pulse code from a remote might take upto 300 bytes.  The
+   daemon should read the bytes as soon as they are generated, so take
+   the number of keys you think you can push before the daemon runs
+   and multiply by 300.  The driver will warn you if you overrun this
+   buffer.  If you have a slow computer or non-busmastering IDE disks,
+   maybe you will need to increase this.  */
+
+/* This MUST be a power of two!  It has to be larger than 1 as well. */
+
+#define RBUF_LEN 256
+#define WBUF_LEN 256
+
+static struct timeval lasttv = {0, 0};
+
+static spinlock_t lirc_lock = SPIN_LOCK_UNLOCKED;
+
+static struct lirc_buffer rbuf;
+
+static lirc_t wbuf[WBUF_LEN];
+
+unsigned int freq = 38000;
+unsigned int duty_cycle = 50;
+
+/* Initialized in init_timing_params() */
+unsigned long period = 0;
+unsigned long pulse_width = 0;
+unsigned long space_width = 0;
+
+#if defined(__i386__)
+/*
+  From:
+  Linux I/O port programming mini-HOWTO
+  Author: Riku Saikkonen <Riku.Saikkonen@hut.fi>
+  v, 28 December 1997
+
+  [...]
+  Actually, a port I/O instruction on most ports in the 0-0x3ff range
+  takes almost exactly 1 microsecond, so if you're, for example, using
+  the parallel port directly, just do additional inb()s from that port
+  to delay.
+  [...]
+*/
+/* transmitter latency 1.5625us 0x1.90 - this figure arrived at from
+ * comment above plus trimming to match actual measured frequency.
+ * This will be sensitive to cpu speed, though hopefully most of the 1.5us
+ * is spent in the uart access.  Still - for reference test machine was a
+ * 1.13GHz Athlon system - Steve
+ */
+
+/* changed from 400 to 450 as this works better on slower machines;
+   faster machines will use the rdtsc code anyway */
+
+#define CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY 450
+
+#else
+
+/* does anybody have information on other platforms ? */
+/* 256 = 1<<8 */
+#define CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY 256
+
+#endif  /* __i386__ */
+
+static inline unsigned int sinp(int offset)
+{
+	return inb(io + offset);
+}
+
+static inline void soutp(int offset, int value)
+{
+	outb(value, io + offset);
+}
+
+static inline void on(void)
+{
+	soutp(UART_MCR,hardware[type].on);
+}
+
+static inline void off(void)
+{
+	soutp(UART_MCR,hardware[type].off);
+}
+
+#ifndef MAX_UDELAY_MS
+#define MAX_UDELAY_US 5000
+#else
+#define MAX_UDELAY_US (MAX_UDELAY_MS*1000)
+#endif
+
+static inline void safe_udelay(unsigned long usecs)
+{
+	while(usecs>MAX_UDELAY_US)
+	{
+		udelay(MAX_UDELAY_US);
+		usecs-=MAX_UDELAY_US;
+	}
+	udelay(usecs);
+}
+
+#ifdef USE_RDTSC
+/* This is an overflow/precision juggle, complicated in that we can't
+   do long long divide in the kernel */
+
+/* When we use the rdtsc instruction to measure clocks, we keep the
+ * pulse and space widths as clock cycles.  As this is CPU speed
+ * dependent, the widths must be calculated in init_port and ioctl
+ * time
+ */
+
+/* So send_pulse can quickly convert microseconds to clocks */
+unsigned long conv_us_to_clocks = 0;
+
+static inline int init_timing_params(unsigned int new_duty_cycle,
+		unsigned int new_freq)
+{
+	unsigned long long loops_per_sec,work;
+
+	duty_cycle=new_duty_cycle;
+	freq=new_freq;
+
+	loops_per_sec=current_cpu_data.loops_per_jiffy;
+	loops_per_sec*=HZ;
+
+	/* How many clocks in a microsecond?, avoiding long long divide */
+	work=loops_per_sec;
+	work*=4295;  /* 4295 = 2^32 / 1e6 */
+	conv_us_to_clocks=(work>>32);
+
+	/* Carrier period in clocks, approach good up to 32GHz clock,
+           gets carrier frequency within 8Hz */
+	period=loops_per_sec>>3;
+	period/=(freq>>3);
+
+	/* Derive pulse and space from the period */
+
+	pulse_width = period*duty_cycle/100;
+	space_width = period - pulse_width;
+	dprintk(LOGHEAD
+	       ": in init_timing_params, freq=%d, duty_cycle=%d, "
+	       "clk/jiffy=%ld, pulse=%ld, space=%ld, conv_us_to_clocks=%ld\n",
+	       freq, duty_cycle, current_cpu_data.loops_per_jiffy,
+	       pulse_width, space_width, conv_us_to_clocks);
+	return 0;
+}
+#else /* ! USE_RDTSC */
+static inline int init_timing_params(unsigned int new_duty_cycle,
+		unsigned int new_freq)
+{
+/* period, pulse/space width are kept with 8 binary places -
+ * IE multiplied by 256. */
+	if(256*1000000L/new_freq*new_duty_cycle/100<=
+	   CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
+	if(256*1000000L/new_freq*(100-new_duty_cycle)/100<=
+	   CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY) return(-EINVAL);
+	duty_cycle=new_duty_cycle;
+	freq=new_freq;
+	period=256*1000000L/freq;
+	pulse_width=period*duty_cycle/100;
+	space_width=period-pulse_width;
+	dprintk(LOGHEAD
+	       ": in init_timing_params, freq=%d pulse=%ld, "
+	       "space=%ld\n", freq, pulse_width, space_width);
+	return 0;
+}
+#endif /* USE_RDTSC */
+
+
+/* return value: space length delta */
+
+long send_pulse_irdeo(unsigned long length)
+{
+	long rawbits;
+	int i;
+	unsigned char output;
+	unsigned char chunk,shifted;
+
+	/* how many bits have to be sent ? */
+	rawbits=length*1152/10000;
+	if(duty_cycle>50) chunk=3;
+	else chunk=1;
+	for(i=0,output=0x7f;rawbits>0;rawbits-=3)
+	{
+		shifted=chunk<<(i*3);
+		shifted>>=1;
+		output&=(~shifted);
+		i++;
+		if(i==3)
+		{
+			soutp(UART_TX,output);
+			while(!(sinp(UART_LSR) & UART_LSR_THRE));
+			output=0x7f;
+			i=0;
+		}
+	}
+	if(i!=0)
+	{
+		soutp(UART_TX,output);
+		while(!(sinp(UART_LSR) & UART_LSR_TEMT));
+	}
+
+	if(i==0)
+	{
+		return((-rawbits)*10000/1152);
+	}
+	else
+	{
+		return((3-i)*3*10000/1152+(-rawbits)*10000/1152);
+	}
+}
+
+#ifdef USE_RDTSC
+/* Version that uses Pentium rdtsc instruction to measure clocks */
+
+/* This version does sub-microsecond timing using rdtsc instruction,
+ * and does away with the fudged CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY
+ * Implicitly i586 architecture...  - Steve
+ */
+
+static inline long send_pulse_homebrew_softcarrier(unsigned long length)
+{
+	int flag;
+	unsigned long target, start, now;
+
+	/* Get going quick as we can */
+	rdtscl(start);on();
+	/* Convert length from microseconds to clocks */
+	length*=conv_us_to_clocks;
+	/* And loop till time is up - flipping at right intervals */
+	now=start;
+	target=pulse_width;
+	flag=1;
+	while((now-start)<length)
+	{
+		/* Delay till flip time */
+		do
+		{
+			rdtscl(now);
+		}
+		while ((now-start)<target);
+		/* flip */
+		if(flag)
+		{
+			rdtscl(now);off();
+			target+=space_width;
+		}
+		else
+		{
+			rdtscl(now);on();
+			target+=pulse_width;
+		}
+		flag=!flag;
+	}
+	rdtscl(now);
+	return(((now-start)-length)/conv_us_to_clocks);
+}
+#else /* ! USE_RDTSC */
+/* Version using udelay() */
+
+/* here we use fixed point arithmetic, with 8
+   fractional bits.  that gets us within 0.1% or so of the right average
+   frequency, albeit with some jitter in pulse length - Steve */
+
+/* To match 8 fractional bits used for pulse/space length */
+
+static inline long send_pulse_homebrew_softcarrier(unsigned long length)
+{
+	int flag;
+	unsigned long actual, target, d;
+	length<<=8;
+
+	actual=target=0; flag=0;
+	while(actual<length)
+	{
+		if(flag)
+		{
+			off();
+			target+=space_width;
+		}
+		else
+		{
+			on();
+			target+=pulse_width;
+		}
+		d=(target-actual-CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY+128)>>8;
+		/* Note - we've checked in ioctl that the pulse/space
+		   widths are big enough so that d is > 0 */
+		udelay(d);
+		actual+=(d<<8)+CONFIG_LIRC_SERIAL_TRANSMITTER_LATENCY;
+		flag=!flag;
+	}
+	return((actual-length)>>8);
+}
+#endif /* USE_RDTSC */
+
+long send_pulse_homebrew(unsigned long length)
+{
+	if(length<=0) return 0;
+	if(softcarrier)
+	{
+		return send_pulse_homebrew_softcarrier(length);
+	}
+	else
+	{
+		on();
+		safe_udelay(length);
+		return(0);
+	}
+}
+
+void send_space_irdeo(long length)
+{
+	if(length<=0) return;
+	safe_udelay(length);
+}
+
+void send_space_homebrew(long length)
+{
+        off();
+	if(length<=0) return;
+	safe_udelay(length);
+}
+
+static void inline rbwrite(lirc_t l)
+{
+	if(lirc_buffer_full(&rbuf))    /* no new signals will be accepted */
+	{
+		dprintk(LOGHEAD ": Buffer overrun\n");
+		return;
+	}
+	_lirc_buffer_write_1(&rbuf, (void *)&l);
+}
+
+static void inline frbwrite(lirc_t l)
+{
+	/* simple noise filter */
+	static lirc_t pulse=0L,space=0L;
+	static unsigned int ptr=0;
+
+	if(ptr>0 && (l&PULSE_BIT))
+	{
+		pulse+=l&PULSE_MASK;
+		if(pulse>250)
+		{
+			rbwrite(space);
+			rbwrite(pulse|PULSE_BIT);
+			ptr=0;
+			pulse=0;
+		}
+		return;
+	}
+	if(!(l&PULSE_BIT))
+	{
+		if(ptr==0)
+		{
+			if(l>20000)
+			{
+				space=l;
+				ptr++;
+				return;
+			}
+		}
+		else
+		{
+			if(l>20000)
+			{
+				space+=pulse;
+				if(space>PULSE_MASK) space=PULSE_MASK;
+				space+=l;
+				if(space>PULSE_MASK) space=PULSE_MASK;
+				pulse=0;
+				return;
+			}
+			rbwrite(space);
+			rbwrite(pulse|PULSE_BIT);
+			ptr=0;
+			pulse=0;
+		}
+	}
+	rbwrite(l);
+}
+
+irqreturn_t irq_handler(int i, void *blah, struct pt_regs *regs)
+{
+	struct timeval tv;
+	int status,counter,dcd;
+	long deltv;
+	lirc_t data;
+
+	counter=0;
+	do{
+		counter++;
+		status=sinp(UART_MSR);
+		if(counter>RS_ISR_PASS_LIMIT)
+		{
+			printk(KERN_WARNING LIRC_DRIVER_NAME ": AIEEEE: "
+			       "We're caught!\n");
+			break;
+		}
+		if((status&hardware[type].signal_pin_change) && sense!=-1)
+		{
+			/* get current time */
+			do_gettimeofday(&tv);
+
+			/* New mode, written by Trent Piepho
+			   <xyzzy@u.washington.edu>. */
+
+			/* The old format was not very portable.
+			   We now use the type lirc_t to pass pulses
+			   and spaces to user space.
+
+			   If PULSE_BIT is set a pulse has been
+			   received, otherwise a space has been
+			   received.  The driver needs to know if your
+			   receiver is active high or active low, or
+			   the space/pulse sense could be
+			   inverted. The bits denoted by PULSE_MASK are
+			   the length in microseconds. Lengths greater
+			   than or equal to 16 seconds are clamped to
+			   PULSE_MASK.  All other bits are unused.
+			   This is a much simpler interface for user
+			   programs, as well as eliminating "out of
+			   phase" errors with space/pulse
+			   autodetection. */
+
+			/* calculate time since last interrupt in
+			   microseconds */
+			dcd=(status & hardware[type].signal_pin) ? 1:0;
+
+			deltv=tv.tv_sec-lasttv.tv_sec;
+			if(deltv>15)
+			{
+				dprintk(LOGHEAD
+				       ": AIEEEE: %d %d %lx %lx %lx %lx\n",
+				       dcd,sense,
+				       tv.tv_sec,lasttv.tv_sec,
+				       tv.tv_usec,lasttv.tv_usec);
+				data=PULSE_MASK; /* really long time */
+				if(!(dcd^sense)) /* sanity check */
+				{
+				        /* detecting pulse while this
+					   MUST be a space! */
+				        sense=sense ? 0:1;
+				}
+			}
+			else
+			{
+				data=(lirc_t) (deltv*1000000+
+					       tv.tv_usec-
+					       lasttv.tv_usec);
+			};
+			if(tv.tv_sec<lasttv.tv_sec ||
+			   (tv.tv_sec==lasttv.tv_sec &&
+			    tv.tv_usec<lasttv.tv_usec))
+			{
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				       ": AIEEEE: your clock just jumped "
+				       "backwards\n");
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				       ": %d %d %lx %lx %lx %lx\n",
+				       dcd,sense,
+				       tv.tv_sec,lasttv.tv_sec,
+				       tv.tv_usec,lasttv.tv_usec);
+				data=PULSE_MASK;
+			}
+			frbwrite(dcd^sense ? data : (data|PULSE_BIT));
+			lasttv=tv;
+			wake_up_interruptible(&rbuf.wait_poll);
+		}
+	} while(!(sinp(UART_IIR) & UART_IIR_NO_INT)); /* still pending ? */
+
+	return IRQ_HANDLED;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(power_supply_queue);
+static spinlock_t lirc_lock;
+
+static int init_port(void)
+{
+	unsigned long flags;
+
+	/* Reserve io region. */
+	if(!request_region(io, 8, LIRC_DRIVER_NAME))
+	{
+		printk(KERN_ERR  LIRC_DRIVER_NAME
+		       ": port %04x already in use\n", io);
+		printk(KERN_WARNING LIRC_DRIVER_NAME
+		       ": use 'setserial /dev/ttySX uart none'\n");
+		printk(KERN_WARNING LIRC_DRIVER_NAME
+		       ": or compile the serial port driver as module and\n");
+		printk(KERN_WARNING LIRC_DRIVER_NAME
+		       ": make sure this module is loaded first\n");
+		return(-EBUSY);
+	}
+
+	lock_kernel();
+
+	spin_lock_irqsave(&lirc_lock, flags);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+
+	/* Clear registers. */
+	sinp(UART_LSR);
+	sinp(UART_RX);
+	sinp(UART_IIR);
+	sinp(UART_MSR);
+
+	/* Set line for power source */
+	soutp(UART_MCR, hardware[type].off);
+
+	/* Clear registers again to be sure. */
+	sinp(UART_LSR);
+	sinp(UART_RX);
+	sinp(UART_IIR);
+	sinp(UART_MSR);
+
+	switch(hardware[type].type)
+	{
+	case LIRC_IRDEO:
+	case LIRC_IRDEO_REMOTE:
+		/* setup port to 7N1 @ 115200 Baud */
+		/* 7N1+start = 9 bits at 115200 ~ 3 bits at 38kHz */
+
+		/* Set DLAB 1. */
+		soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+		/* Set divisor to 1 => 115200 Baud */
+		soutp(UART_DLM,0);
+		soutp(UART_DLL,1);
+		/* Set DLAB 0 +  7N1 */
+		soutp(UART_LCR,UART_LCR_WLEN7);
+		/* THR interrupt already disabled at this point */
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&lirc_lock, flags);
+
+	/* Initialize pulse/space widths */
+	init_timing_params(duty_cycle, freq);
+
+	/* If pin is high, then this must be an active low receiver. */
+	if(sense==-1)
+	{
+		/* wait 1 sec for the power supply */
+
+		sleep_on_timeout(&power_supply_queue,HZ);
+
+		sense=(sinp(UART_MSR) & hardware[type].signal_pin) ? 1:0;
+		printk(KERN_INFO  LIRC_DRIVER_NAME  ": auto-detected active "
+		       "%s receiver\n",sense ? "low":"high");
+	}
+	else
+	{
+		printk(KERN_INFO  LIRC_DRIVER_NAME  ": Manually using active "
+		       "%s receiver\n",sense ? "low":"high");
+	};
+
+	unlock_kernel();
+
+	return 0;
+}
+
+static int set_use_inc(void* data)
+{
+	int result;
+	unsigned long flags;
+
+	spin_lock(&lirc_lock);
+#ifdef CONFIG_MODULE_UNLOAD
+	if(module_refcount(THIS_MODULE))
+	{
+		spin_unlock(&lirc_lock);
+		return -EBUSY;
+	}
+#endif
+
+	/* initialize timestamp */
+	do_gettimeofday(&lasttv);
+
+	result=request_irq(irq,irq_handler,SA_INTERRUPT,LIRC_DRIVER_NAME,NULL);
+	switch(result)
+	{
+	case -EBUSY:
+		printk(KERN_ERR LIRC_DRIVER_NAME ": IRQ %d busy\n", irq);
+		spin_unlock(&lirc_lock);
+		return -EBUSY;
+	case -EINVAL:
+		printk(KERN_ERR LIRC_DRIVER_NAME
+		       ": Bad irq number or handler\n");
+		spin_unlock(&lirc_lock);
+		return -EINVAL;
+	default:
+		dprintk(LOGHEAD
+		       ": Interrupt %d, port %04x obtained\n", irq, io);
+		break;
+	};
+
+	local_irq_save(flags);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);
+
+	local_irq_restore(flags);
+
+	try_module_get(THIS_MODULE);
+	spin_unlock(&lirc_lock);
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{	unsigned long flags;
+
+	spin_lock_irqsave(&lirc_lock, flags);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+	spin_unlock_irqrestore(&lirc_lock, flags);
+
+	free_irq(irq, NULL);
+	dprintk(LOGHEAD ": freed IRQ %d\n", irq);
+
+	module_put(THIS_MODULE);
+}
+
+static ssize_t lirc_write(struct file *file, const char *buf,
+			 size_t n, loff_t * ppos)
+{
+	int retval,i,count;
+	unsigned long flags;
+	long delta=0;
+
+	if(!(hardware[type].features&LIRC_CAN_SEND_PULSE))
+	{
+		return(-EBADF);
+	}
+
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+	retval=verify_area(VERIFY_READ,buf,n);
+	if(retval) return(retval);
+	count=n/sizeof(lirc_t);
+	if(count>WBUF_LEN || count%2==0) return(-EINVAL);
+	copy_from_user(wbuf,buf,n);
+	spin_lock_irqsave(&lirc_lock, flags);
+	if(hardware[type].type==LIRC_IRDEO)
+	{
+		/* DTR, RTS down */
+		on();
+	}
+	for(i=0;i<count;i++)
+	{
+		if(i%2) hardware[type].send_space(wbuf[i]-delta);
+		else delta=hardware[type].send_pulse(wbuf[i]);
+	}
+	off();
+	spin_unlock_irqrestore(&lirc_lock, flags);
+	return(n);
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		      unsigned long arg)
+{
+        int result;
+	unsigned long value;
+	unsigned int ivalue;
+
+	switch(cmd)
+	{
+	case LIRC_GET_SEND_MODE:
+		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+
+		result=put_user(LIRC_SEND2MODE
+				(hardware[type].features&LIRC_CAN_SEND_MASK),
+				(unsigned long *) arg);
+		if(result) return(result);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+		if(!(hardware[type].features&LIRC_CAN_SEND_MASK))
+		{
+			return(-ENOIOCTLCMD);
+		}
+
+		result=get_user(value,(unsigned long *) arg);
+		if(result) return(result);
+		/* only LIRC_MODE_PULSE supported */
+		if(value!=LIRC_MODE_PULSE) return(-ENOSYS);
+		break;
+
+	case LIRC_GET_LENGTH:
+		return(-ENOSYS);
+		break;
+
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		dprintk(LOGHEAD ": SET_SEND_DUTY_CYCLE\n");
+		if(!(hardware[type].features&LIRC_CAN_SET_SEND_DUTY_CYCLE))
+		{
+			return(-ENOIOCTLCMD);
+		}
+
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		return init_timing_params(ivalue, freq);
+		break;
+
+	case LIRC_SET_SEND_CARRIER:
+		dprintk(LOGHEAD ": SET_SEND_CARRIER\n");
+		if(!(hardware[type].features&LIRC_CAN_SET_SEND_CARRIER))
+		{
+			return(-ENOIOCTLCMD);
+		}
+
+		result=get_user(ivalue,(unsigned int *) arg);
+		if(result) return(result);
+		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
+		return init_timing_params(duty_cycle, ivalue);
+		break;
+
+	default:
+		return(-ENOIOCTLCMD);
+	}
+	return(0);
+}
+
+static struct file_operations lirc_fops =
+{
+	write:   lirc_write,
+};
+
+static struct lirc_plugin plugin = {
+	name:		LIRC_DRIVER_NAME,
+	minor:		-1,
+	code_length:	1,
+	sample_rate:	0,
+	data:		NULL,
+	add_to_buf:	NULL,
+	get_queue:	NULL,
+	rbuf:		&rbuf,
+	set_use_inc:	set_use_inc,
+	set_use_dec:	set_use_dec,
+	ioctl:		lirc_ioctl,
+	fops:		&lirc_fops,
+};
+
+MODULE_AUTHOR("Ralph Metzler, Trent Piepho, Ben Pfaff, Christoph Bartelmus");
+MODULE_DESCRIPTION("Infra-red receiver driver for serial ports.");
+MODULE_LICENSE("GPL");
+
+static int __init lirc_serial_init(void)
+{
+	int result;
+
+	switch(type)
+	{
+	case LIRC_HOMEBREW:
+	case LIRC_IRDEO:
+	case LIRC_IRDEO_REMOTE:
+	case LIRC_ANIMAX:
+	case LIRC_IGOR:
+		break;
+	default:
+		return(-EINVAL);
+	}
+	if(!softcarrier && hardware[type].type==LIRC_HOMEBREW)
+	{
+		hardware[type].features&=~(LIRC_CAN_SET_SEND_DUTY_CYCLE|
+					   LIRC_CAN_SET_SEND_CARRIER);
+	}
+	if ((result = init_port()) < 0)
+		return result;
+	plugin.features = hardware[type].features;
+	lirc_buffer_init(&rbuf, sizeof(lirc_t), RBUF_LEN);
+	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) {
+		printk(KERN_ERR  LIRC_DRIVER_NAME
+		       ": register_chrdev failed!\n");
+		release_region(io, 8);
+		return -EIO;
+	}
+	return 0;
+}
+
+static void __exit lirc_serial_exit(void)
+{
+	release_region(io, 8);
+	lirc_buffer_free(&rbuf);
+	lirc_unregister_plugin(plugin.minor);
+	dprintk(LOGHEAD ": cleaned up module\n");
+}
+
+module_init(lirc_serial_init);
+module_exit(lirc_serial_exit);
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_sir.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_sir.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_sir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_sir.c	2006-08-23 13:29:33.981485000 +0100
@@ -0,0 +1,1309 @@
+/*
+ * LIRC SIR driver, (C) 2000 Milan Pikula <www@fornax.sk>
+ *
+ * lirc_sir - Device driver for use with SIR (serial infra red)
+ * mode of IrDA on many notebooks.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * 2000/09/16 Frank Przybylski <mail@frankprzybylski.de> :
+ *  added timeout and relaxed pulse detection, removed gap bug
+ *
+ * 2000/12/15 Christoph Bartelmus <lirc@bartelmus.de> :
+ *   added support for Tekram Irmate 210 (sending does not work yet,
+ *   kind of disappointing that nobody was able to implement that
+ *   before),
+ *   major clean-up
+ *
+ * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
+ *   added support for StrongARM SA1100 embedded microprocessor
+ *   parts cut'n'pasted from sa1100_ir.c (C) 2000 Russell King
+ */
+
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/config.h>
+
+#if !defined(CONFIG_LIRC_ON_SA1100) && !defined(CONFIG_SERIAL_MODULE)
+#warning "******************************************"
+#warning " Your serial port driver is compiled into "
+#warning " the kernel. You will have to release the "
+#warning " port you want to use for LIRC with:      "
+#warning "    setserial /dev/ttySx uart none        "
+#warning "******************************************"
+#endif
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/serial_reg.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/fcntl.h>
+#ifdef CONFIG_LIRC_ON_SA1100
+#include <asm/hardware.h>
+#ifdef CONFIG_SA1100_COLLIE
+#include <asm/arch/tc35143.h>
+#include <asm/ucb1200.h>
+#endif
+#endif
+
+#include <linux/timer.h>
+
+#include <linux/lirc.h>
+#include "lirc_dev.h"
+
+/* SECTION: Definitions */
+
+/**************************** Tekram dongle ***************************/
+#ifdef CONFIG_LIRC_SIR_TEKRAM
+/* stolen from kernel source */
+/* definitions for Tekram dongle */
+#define TEKRAM_115200 0x00
+#define TEKRAM_57600  0x01
+#define TEKRAM_38400  0x02
+#define TEKRAM_19200  0x03
+#define TEKRAM_9600   0x04
+#define TEKRAM_2400   0x08
+
+#define TEKRAM_PW 0x10 /* Pulse select bit */
+
+/* 10bit * 1s/115200bit in milli seconds = 87ms*/
+#define TIME_CONST (10000000ul/115200ul)
+
+#endif
+
+#ifdef CONFIG_LIRC_SIR_ACTISYS_ACT200L
+static void init_act200(void);
+#endif
+
+/******************************* SA1100 ********************************/
+#ifdef CONFIG_LIRC_ON_SA1100
+struct sa1100_ser2_registers
+{
+	/* HSSP control register */
+	unsigned char hscr0;
+	/* UART registers */
+	unsigned char utcr0;
+	unsigned char utcr1;
+	unsigned char utcr2;
+	unsigned char utcr3;
+	unsigned char utcr4;
+	unsigned char utdr;
+	unsigned char utsr0;
+	unsigned char utsr1;
+} sr;
+
+static int irq=IRQ_Ser2ICP;
+
+#define LIRC_ON_SA1100_TRANSMITTER_LATENCY 0
+
+/* pulse/space ratio of 50/50 */
+unsigned long pulse_width = (13-LIRC_ON_SA1100_TRANSMITTER_LATENCY);
+/* 1000000/freq-pulse_width */
+unsigned long space_width = (13-LIRC_ON_SA1100_TRANSMITTER_LATENCY);
+unsigned int freq = 38000;      /* modulation frequency */
+unsigned int duty_cycle = 50;   /* duty cycle of 50% */
+
+#endif
+
+#define RBUF_LEN 1024
+#define WBUF_LEN 1024
+
+#define LIRC_DRIVER_NAME "lirc_sir"
+
+#ifndef CONFIG_LIRC_SIR_TEKRAM
+#define PULSE '['
+
+/* 9bit * 1s/115200bit in milli seconds = 78.125ms*/
+#define TIME_CONST (9000000ul/115200ul)
+#endif
+
+
+/* timeout for sequences in jiffies (=5/100s) */
+/* must be longer than TIME_CONST */
+#define SIR_TIMEOUT	(HZ*5/100)
+
+#ifndef CONFIG_LIRC_ON_SA1100
+static int io = CONFIG_LIRC_PORT_SIR;
+static int irq = CONFIG_LIRC_IRQ_SIR;
+static int threshold = 3;
+#endif
+
+static spinlock_t timer_lock = SPIN_LOCK_UNLOCKED;
+static struct timer_list timerlist;
+/* time of last signal change detected */
+static struct timeval last_tv = {0, 0};
+/* time of last UART data ready interrupt */
+static struct timeval last_intr_tv = {0, 0};
+static int last_value = 0;
+static spinlock_t lirc_lock;
+
+static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
+
+static spinlock_t hardware_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t dev_lock = SPIN_LOCK_UNLOCKED;
+
+static lirc_t rx_buf[RBUF_LEN]; unsigned int rx_tail = 0, rx_head = 0;
+#ifndef CONFIG_LIRC_SIR_TEKRAM
+static lirc_t tx_buf[WBUF_LEN];
+#endif
+
+/* SECTION: Prototypes */
+
+/* Communication with user-space */
+static int lirc_open(struct inode * inode, struct file * file);
+static int lirc_close(struct inode * inode, struct file *file);
+static unsigned int lirc_poll(struct file * file, poll_table * wait);
+static ssize_t lirc_read(struct file * file, char * buf, size_t count,
+		loff_t * ppos);
+static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos);
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		unsigned long arg);
+static void add_read_queue(int flag, unsigned long val);
+#ifdef MODULE
+static int init_chrdev(void);
+static void drop_chrdev(void);
+#endif
+	/* Hardware */
+static irqreturn_t sir_interrupt(int irq, void * dev_id, struct pt_regs * regs);
+#ifndef CONFIG_LIRC_SIR_TEKRAM
+static void send_space(unsigned long len);
+static void send_pulse(unsigned long len);
+#endif
+static int init_hardware(void);
+static void drop_hardware(void);
+	/* Initialisation */
+static int init_port(void);
+static void drop_port(void);
+int init_module(void);
+void cleanup_module(void);
+
+#ifdef CONFIG_LIRC_ON_SA1100
+void inline on(void)
+{
+	PPSR|=PPC_TXD2;
+}
+
+void inline off(void)
+{
+	PPSR&=~PPC_TXD2;
+}
+#else
+static inline unsigned int sinp(int offset)
+{
+	return inb(io + offset);
+}
+
+static inline void soutp(int offset, int value)
+{
+	outb(value, io + offset);
+}
+#endif
+
+#ifndef MAX_UDELAY_MS
+#define MAX_UDELAY_US 5000
+#else
+#define MAX_UDELAY_US (MAX_UDELAY_MS*1000)
+#endif
+
+static inline void safe_udelay(unsigned long usecs)
+{
+	while(usecs>MAX_UDELAY_US)
+	{
+		udelay(MAX_UDELAY_US);
+		usecs-=MAX_UDELAY_US;
+	}
+	udelay(usecs);
+}
+
+/* SECTION: Communication with user-space */
+
+static int lirc_open(struct inode * inode, struct file * file)
+{
+	spin_lock(&dev_lock);
+#ifdef CONFIG_MODULE_UNLOAD
+	if (module_refcount(THIS_MODULE))
+	{
+		spin_unlock(&dev_lock);
+		return -EBUSY;
+	}
+#endif
+	if (!try_module_get(THIS_MODULE))
+	{
+		spin_unlock(&dev_lock);
+		return -EINVAL;
+	}
+	spin_unlock(&dev_lock);
+	return 0;
+}
+
+static int lirc_close(struct inode * inode, struct file *file)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static unsigned int lirc_poll(struct file * file, poll_table * wait)
+{
+	poll_wait(file, &lirc_read_queue, wait);
+	if (rx_head != rx_tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t lirc_read(struct file * file, char * buf, size_t count,
+		loff_t * ppos)
+{
+	int n=0;
+	int retval = 0;
+	DECLARE_WAITQUEUE(wait,current);
+
+	if(n%sizeof(lirc_t)) return(-EINVAL);
+
+	add_wait_queue(&lirc_read_queue,&wait);
+	current->state=TASK_INTERRUPTIBLE;
+	while(n<count)
+	{
+		if(rx_head!=rx_tail)
+		{
+			retval=verify_area(VERIFY_WRITE,
+					   (void *) buf+n,sizeof(lirc_t));
+			if (retval)
+			{
+				return retval;
+			}
+			copy_to_user((void *) buf+n,(void *) (rx_buf+rx_head),
+				     sizeof(lirc_t));
+			rx_head=(rx_head+1)&(RBUF_LEN-1);
+			n+=sizeof(lirc_t);
+		}
+		else
+		{
+			if(file->f_flags & O_NONBLOCK)
+			{
+				retval=-EAGAIN;
+				break;
+			}
+			if(signal_pending(current))
+			{
+				retval=-ERESTARTSYS;
+				break;
+			}
+			schedule();
+			current->state=TASK_INTERRUPTIBLE;
+		}
+	}
+	remove_wait_queue(&lirc_read_queue,&wait);
+	current->state=TASK_RUNNING;
+	return (n ? n : retval);
+}
+static ssize_t lirc_write(struct file * file, const char * buf, size_t n, loff_t * pos)
+{
+	unsigned long flags;
+#ifdef CONFIG_LIRC_SIR_TEKRAM
+	return(-EBADF);
+#else
+	int i;
+	int retval;
+
+        if(n%sizeof(lirc_t) || (n/sizeof(lirc_t)) > WBUF_LEN)
+		return(-EINVAL);
+	retval = verify_area(VERIFY_READ, buf, n);
+	if (retval)
+		return retval;
+	copy_from_user(tx_buf, buf, n);
+	i = 0;
+	n/=sizeof(lirc_t);
+#ifdef CONFIG_LIRC_ON_SA1100
+	/* disable receiver */
+	Ser2UTCR3=0;
+#endif
+	spin_lock_irqsave(&lirc_lock, flags);
+	while (1) {
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_pulse(tx_buf[i]);
+		i++;
+		if (i >= n)
+			break;
+		if (tx_buf[i])
+			send_space(tx_buf[i]);
+		i++;
+	}
+	spin_unlock_irqrestore(&lirc_lock, flags);
+#ifdef CONFIG_LIRC_ON_SA1100
+	off();
+	udelay(1000); /* wait 1ms for IR diode to recover */
+	Ser2UTCR3=0;
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	/* enable receiver */
+	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
+#endif
+	return n;
+#endif
+}
+
+static int lirc_ioctl(struct inode *node,struct file *filep,unsigned int cmd,
+		unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+#ifdef CONFIG_LIRC_ON_SA1100
+	unsigned int ivalue;
+#endif
+
+#ifdef CONFIG_LIRC_SIR_TEKRAM
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = 0;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+#elif defined(CONFIG_LIRC_ON_SA1100)
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE |
+			LIRC_CAN_SET_SEND_DUTY_CYCLE |
+			LIRC_CAN_SET_SEND_CARRIER |
+			LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+#else
+	if (cmd == LIRC_GET_FEATURES)
+		value = LIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;
+	else if (cmd == LIRC_GET_SEND_MODE)
+		value = LIRC_MODE_PULSE;
+	else if (cmd == LIRC_GET_REC_MODE)
+		value = LIRC_MODE_MODE2;
+#endif
+
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+	case LIRC_GET_SEND_MODE:
+	case LIRC_GET_REC_MODE:
+		retval = put_user(value, (unsigned long *) arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *) arg);
+		break;
+#ifdef CONFIG_LIRC_ON_SA1100
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		if(ivalue<=0 || ivalue>100) return(-EINVAL);
+		/* (ivalue/100)*(1000000/freq) */
+		duty_cycle=ivalue;
+		pulse_width=(unsigned long) duty_cycle*10000/freq;
+		space_width=(unsigned long) 1000000L/freq-pulse_width;
+		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		break;
+	case LIRC_SET_SEND_CARRIER:
+		retval=get_user(ivalue,(unsigned int *) arg);
+		if(retval) return(retval);
+		if(ivalue>500000 || ivalue<20000) return(-EINVAL);
+		freq=ivalue;
+		pulse_width=(unsigned long) duty_cycle*10000/freq;
+		space_width=(unsigned long) 1000000L/freq-pulse_width;
+		if(pulse_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			pulse_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		if(space_width>=LIRC_ON_SA1100_TRANSMITTER_LATENCY)
+			space_width-=LIRC_ON_SA1100_TRANSMITTER_LATENCY;
+		break;
+#endif
+	default:
+		retval = -ENOIOCTLCMD;
+
+	}
+
+	if (retval)
+		return retval;
+
+#ifdef CONFIG_LIRC_SIR_TEKRAM
+	if (cmd == LIRC_SET_REC_MODE) {
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+	} else if (cmd == LIRC_SET_SEND_MODE) {
+		retval = -ENOSYS;
+	}
+#else
+	if (cmd == LIRC_SET_REC_MODE) {
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+	} else if (cmd == LIRC_SET_SEND_MODE) {
+		if (value != LIRC_MODE_PULSE)
+			retval = -ENOSYS;
+	}
+#endif
+	return retval;
+}
+
+static void add_read_queue(int flag, unsigned long val)
+{
+	unsigned int new_rx_tail;
+	lirc_t newval;
+
+#ifdef DEBUG_SIGNAL
+	printk(KERN_DEBUG LIRC_DRIVER_NAME
+		": add flag %d with val %lu\n",
+		flag,val);
+#endif
+
+	newval = val & PULSE_MASK;
+
+	/* statistically pulses are ~TIME_CONST/2 too long: we could
+	   maybe make this more exactly but this is good enough */
+	if(flag) /* pulse */
+	{
+		if(newval>TIME_CONST/2)
+		{
+			newval-=TIME_CONST/2;
+		}
+		else /* should not ever happen */
+		{
+			newval=1;
+		}
+		newval|=PULSE_BIT;
+	}
+	else
+	{
+		newval+=TIME_CONST/2;
+	}
+	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
+	if (new_rx_tail == rx_head) {
+#               ifdef DEBUG
+		printk(KERN_WARNING LIRC_DRIVER_NAME ": Buffer overrun.\n");
+#               endif
+		return;
+	}
+	rx_buf[rx_tail] = newval;
+	rx_tail = new_rx_tail;
+	wake_up_interruptible(&lirc_read_queue);
+}
+
+static struct file_operations lirc_fops =
+{
+	.read    = lirc_read,
+	.write   = lirc_write,
+	.poll    = lirc_poll,
+	.ioctl   = lirc_ioctl,
+	.open    = lirc_open,
+	.release = lirc_close,
+};
+
+static int set_use_inc(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       if (!try_module_get(THIS_MODULE)) {
+                return -EINVAL;
+       }
+#endif
+       return 0;
+}
+
+static void set_use_dec(void* data)
+{
+#if WE_DONT_USE_LOCAL_OPEN_CLOSE
+       module_put(THIS_MODULE);
+#endif
+}
+static struct lirc_plugin plugin = {
+       .name          = LIRC_DRIVER_NAME,
+       .minor         = -1,
+       .code_length   = 1,
+       .sample_rate   = 0,
+       .data          = NULL,
+       .add_to_buf    = NULL,
+       .get_queue     = NULL,
+       .set_use_inc   = set_use_inc,
+       .set_use_dec   = set_use_dec,
+       .fops          = &lirc_fops,
+};
+
+int init_chrdev(void)
+{
+	plugin.minor = lirc_register_plugin(&plugin);
+	if (plugin.minor < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void drop_chrdev(void)
+{
+	lirc_unregister_plugin(plugin.minor);
+}
+
+/* SECTION: Hardware */
+static long delta(struct timeval * tv1, struct timeval * tv2)
+{
+	unsigned long deltv;
+
+	deltv = tv2->tv_sec - tv1->tv_sec;
+	if (deltv > 15)
+		deltv = 0xFFFFFF;
+	else
+		deltv = deltv*1000000 +
+			tv2->tv_usec -
+			tv1->tv_usec;
+	return deltv;
+}
+
+static void sir_timeout(unsigned long data)
+{
+	/* if last received signal was a pulse, but receiving stopped
+	   within the 9 bit frame, we need to finish this pulse and
+	   simulate a signal change to from pulse to space. Otherwise
+	   upper layers will receive two sequences next time. */
+
+	unsigned long flags;
+	unsigned long pulse_end;
+
+	/* avoid interference with interrupt */
+ 	spin_lock_irqsave(&timer_lock, flags);
+	if (last_value)
+	{
+#ifndef CONFIG_LIRC_ON_SA1100
+		/* clear unread bits in UART and restart */
+		outb(UART_FCR_CLEAR_RCVR, io + UART_FCR);
+#endif
+		/* determine 'virtual' pulse end: */
+	 	pulse_end = delta(&last_tv, &last_intr_tv);
+#ifdef DEBUG_SIGNAL
+		printk(KERN_DEBUG LIRC_DRIVER_NAME
+			": timeout add %d for %lu usec\n",last_value,pulse_end);
+#endif
+		add_read_queue(last_value,pulse_end);
+		last_value = 0;
+		last_tv=last_intr_tv;
+	}
+	spin_unlock_irqrestore(&timer_lock, flags);
+}
+
+static irqreturn_t sir_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned char data;
+	struct timeval curr_tv;
+	static unsigned long deltv;
+#ifdef CONFIG_LIRC_ON_SA1100
+	int status;
+	static int n=0;
+
+	//printk("interrupt\n");
+	status = Ser2UTSR0;
+	/*
+	 * Deal with any receive errors first.  The bytes in error may be
+	 * the only bytes in the receive FIFO, so we do this first.
+	 */
+	while (status & UTSR0_EIF)
+	{
+		int bstat;
+
+#ifdef DEBUG
+		printk("EIF\n");
+		bstat = Ser2UTSR1;
+
+		if (bstat & UTSR1_FRE)
+			printk("frame error\n");
+		if (bstat & UTSR1_ROR)
+			printk("receive fifo overrun\n");
+		if(bstat&UTSR1_PRE)
+			printk("parity error\n");
+#endif
+
+		bstat = Ser2UTDR;
+		n++;
+		status = Ser2UTSR0;
+	}
+
+	if (status & (UTSR0_RFS | UTSR0_RID))
+	{
+		do_gettimeofday(&curr_tv);
+		deltv = delta(&last_tv, &curr_tv);
+		do
+		{
+#ifdef DEBUG_SIGNAL
+			printk(KERN_DEBUG LIRC_DRIVER_NAME": t %lu , d %d\n",
+			       deltintrtv,(int)data);
+#endif
+			data=Ser2UTDR;
+			//printk("data: %d\n",data);
+			n++;
+		}
+		while(status&UTSR0_RID && /* do not empty fifo in
+                                             order to get UTSR0_RID in
+                                             any case */
+		      Ser2UTSR1 & UTSR1_RNE); /* data ready */
+
+		if(status&UTSR0_RID)
+		{
+			//printk("add\n");
+			add_read_queue(0,deltv-n*TIME_CONST); /*space*/
+			add_read_queue(1,n*TIME_CONST); /*pulse*/
+			n=0;
+			last_tv=curr_tv;
+		}
+	}
+
+	if (status & UTSR0_TFS) {
+
+		printk("transmit fifo not full, shouldn't ever happen\n");
+	}
+
+	/*
+	 * We must clear certain bits.
+	 */
+	status &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+	if (status)
+		Ser2UTSR0 = status;
+#else
+	unsigned long deltintrtv;
+	unsigned long flags;
+	int iir, lsr;
+
+	while ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {
+		switch (iir&UART_IIR_ID) { /* FIXME toto treba preriedit */
+		case UART_IIR_MSI:
+			(void) inb(io + UART_MSR);
+			break;
+		case UART_IIR_RLSI:
+			(void) inb(io + UART_LSR);
+			break;
+		case UART_IIR_THRI:
+#if 0
+			if (lsr & UART_LSR_THRE) /* FIFO is empty */
+				outb(data, io + UART_TX)
+#endif
+			break;
+		case UART_IIR_RDI:
+			/* avoid interference with timer */
+		 	spin_lock_irqsave(&timer_lock, flags);
+			do
+			{
+				del_timer(&timerlist);
+				data = inb(io + UART_RX);
+				do_gettimeofday(&curr_tv);
+				deltv = delta(&last_tv, &curr_tv);
+				deltintrtv = delta(&last_intr_tv, &curr_tv);
+#ifdef DEBUG_SIGNAL
+				printk(KERN_DEBUG LIRC_DRIVER_NAME": t %lu , d %d\n",deltintrtv,(int)data);
+#endif
+				/* if nothing came in last X cycles,
+				   it was gap */
+				if (deltintrtv > TIME_CONST * threshold) {
+					if (last_value) {
+#ifdef DEBUG_SIGNAL
+						printk(KERN_DEBUG LIRC_DRIVER_NAME ": GAP\n");
+#endif
+						/* simulate signal change */
+						add_read_queue(last_value,
+							       deltv-
+							       deltintrtv);
+						last_value = 0;
+						last_tv.tv_sec = last_intr_tv.tv_sec;
+						last_tv.tv_usec = last_intr_tv.tv_usec;
+						deltv = deltintrtv;
+					}
+				}
+				data = 1;
+				if (data ^ last_value) {
+					/* deltintrtv > 2*TIME_CONST,
+                                           remember ? */
+					/* the other case is timeout */
+					add_read_queue(last_value,
+						       deltv-TIME_CONST);
+					last_value = data;
+					last_tv = curr_tv;
+					if(last_tv.tv_usec>=TIME_CONST)
+					{
+						last_tv.tv_usec-=TIME_CONST;
+					}
+					else
+					{
+						last_tv.tv_sec--;
+						last_tv.tv_usec+=1000000-
+							TIME_CONST;
+					}
+				}
+				last_intr_tv = curr_tv;
+				if (data)
+				{
+					/* start timer for end of sequence detection */
+					timerlist.expires = jiffies + SIR_TIMEOUT;
+					add_timer(&timerlist);
+				}
+			}
+			while ((lsr = inb(io + UART_LSR))
+				& UART_LSR_DR); /* data ready */
+			spin_unlock_irqrestore(&timer_lock, flags);
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_LIRC_ON_SA1100
+void send_pulse(unsigned long length)
+{
+	unsigned long k,delay;
+	int flag;
+
+	if(length==0) return;
+	/* this won't give us the carrier frequency we really want
+	   due to integer arithmetic, but we can accept this inaccuracy */
+
+	for(k=flag=0;k<length;k+=delay,flag=!flag)
+	{
+		if(flag)
+		{
+			off();
+			delay=space_width;
+		}
+		else
+		{
+			on();
+			delay=pulse_width;
+		}
+		safe_udelay(delay);
+	}
+	off();
+}
+
+void send_space(unsigned long length)
+{
+	if(length==0) return;
+	off();
+	safe_udelay(length);
+}
+#elif defined(CONFIG_LIRC_SIR_TEKRAM)
+#else
+static void send_space(unsigned long len)
+{
+	safe_udelay(len);
+}
+
+static void send_pulse(unsigned long len)
+{
+	long bytes_out = len / TIME_CONST;
+	long time_left;
+
+	if (!bytes_out)
+		bytes_out++;
+	time_left = (long)len - (long)bytes_out * (long)TIME_CONST;
+	while (--bytes_out) {
+		outb(PULSE, io + UART_TX);
+		/* FIXME treba seriozne cakanie z drivers/char/serial.c */
+		while (!(inb(io + UART_LSR) & UART_LSR_THRE));
+	}
+#if 0
+	if (time_left > 0)
+		safe_udelay(time_left);
+#endif
+}
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+static inline int sa1100_irda_set_power_collie(int state)
+{
+	if (state) {
+		/*
+		 *  0 - off
+		 *  1 - short range, lowest power
+		 *  2 - medium range, medium power
+		 *  3 - maximum range, high power
+		 */
+		ucb1200_set_io_direction(TC35143_GPIO_IR_ON,
+					 TC35143_IODIR_OUTPUT);
+		ucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_LOW);
+		udelay(100);
+	}
+	else {
+		/* OFF */
+		ucb1200_set_io_direction(TC35143_GPIO_IR_ON,
+					 TC35143_IODIR_OUTPUT);
+		ucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_HIGH);
+	}
+	return 0;
+}
+#endif
+
+static int init_hardware(void)
+{
+	int flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+	/* reset UART */
+#ifdef CONFIG_LIRC_ON_SA1100
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		printk("Power on IR module\n");
+		set_bitsy_egpio(EGPIO_BITSY_IR_ON);
+	}
+#endif
+#ifdef CONFIG_SA1100_COLLIE
+	sa1100_irda_set_power_collie(3);	/* power on */
+#endif
+	sr.hscr0=Ser2HSCR0;
+
+	sr.utcr0=Ser2UTCR0;
+	sr.utcr1=Ser2UTCR1;
+	sr.utcr2=Ser2UTCR2;
+	sr.utcr3=Ser2UTCR3;
+	sr.utcr4=Ser2UTCR4;
+
+	sr.utdr=Ser2UTDR;
+	sr.utsr0=Ser2UTSR0;
+	sr.utsr1=Ser2UTSR1;
+
+	/* configure GPIO */
+	/* output */
+	PPDR|=PPC_TXD2;
+	PSDR|=PPC_TXD2;
+	/* set output to 0 */
+	off();
+
+	/*
+	 * Enable HP-SIR modulation, and ensure that the port is disabled.
+	 */
+	Ser2UTCR3=0;
+	Ser2HSCR0=sr.hscr0 & (~HSCR0_HSSP);
+
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+
+	/* 7N1 */
+	Ser2UTCR0=UTCR0_1StpBit|UTCR0_7BitData;
+	/* 115200 */
+	Ser2UTCR1=0;
+	Ser2UTCR2=1;
+	/* use HPSIR, 1.6 usec pulses */
+	Ser2UTCR4=UTCR4_HPSIR|UTCR4_Z1_6us;
+
+	/* enable receiver, receive fifo interrupt */
+	Ser2UTCR3=UTCR3_RXE|UTCR3_RIE;
+
+	/* clear status register to prevent unwanted interrupts */
+	Ser2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);
+
+#elif defined(CONFIG_LIRC_SIR_TEKRAM)
+	/* disable FIFO */
+	soutp(UART_FCR,
+	      UART_FCR_CLEAR_RCVR|
+	      UART_FCR_CLEAR_XMIT|
+	      UART_FCR_TRIGGER_1);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* First of all, disable all interrupts */
+	soutp(UART_IER, sinp(UART_IER)&
+	      (~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+
+	/* Set divisor to 12 => 9600 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,12);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* power supply */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	safe_udelay(50*1000);
+
+	/* -DTR low -> reset PIC */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
+	udelay(1*1000);
+
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(100);
+
+
+        /* -RTS low -> send control byte */
+	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(7);
+	soutp(UART_TX, TEKRAM_115200|TEKRAM_PW);
+
+	/* one byte takes ~1042 usec to transmit at 9600,8N1 */
+	udelay(1500);
+
+	/* back to normal operation */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(50);
+
+	udelay(1500);
+
+	/* read previous control byte */
+	printk(KERN_INFO LIRC_DRIVER_NAME
+	       ": 0x%02x\n",sinp(UART_RX));
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+
+	/* Set divisor to 1 => 115200 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,1);
+
+	/* Set DLAB 0, 8 Bit */
+	soutp(UART_LCR, UART_LCR_WLEN8);
+	/* enable interrupts */
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);
+#else
+	outb(0, io + UART_MCR);
+	outb(0, io + UART_IER);
+	/* init UART */
+		/* set DLAB, speed = 115200 */
+	outb(UART_LCR_DLAB | UART_LCR_WLEN7, io + UART_LCR);
+	outb(1, io + UART_DLL); outb(0, io + UART_DLM);
+		/* 7N1+start = 9 bits at 115200 ~ 3 bits at 44000 */
+	outb(UART_LCR_WLEN7, io + UART_LCR);
+		/* FIFO operation */
+	outb(UART_FCR_ENABLE_FIFO, io + UART_FCR);
+		/* interrupts */
+	// outb(UART_IER_RLSI|UART_IER_RDI|UART_IER_THRI, io + UART_IER);
+	outb(UART_IER_RDI, io + UART_IER);
+	/* turn on UART */
+	outb(UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2, io + UART_MCR);
+#ifdef CONFIG_LIRC_SIR_ACTISYS_ACT200L
+	init_act200();
+#endif
+#endif
+	spin_unlock_irqrestore(&hardware_lock, flags);
+	return 0;
+}
+
+static void drop_hardware(void)
+{
+	int flags;
+
+	spin_lock_irqsave(&hardware_lock, flags);
+
+#ifdef CONFIG_LIRC_ON_SA1100
+	Ser2UTCR3=0;
+
+	Ser2UTCR0=sr.utcr0;
+	Ser2UTCR1=sr.utcr1;
+	Ser2UTCR2=sr.utcr2;
+	Ser2UTCR4=sr.utcr4;
+	Ser2UTCR3=sr.utcr3;
+
+	Ser2HSCR0=sr.hscr0;
+#ifdef CONFIG_SA1100_BITSY
+	if (machine_is_bitsy()) {
+		clr_bitsy_egpio(EGPIO_BITSY_IR_ON);
+	}
+#endif
+#ifdef CONFIG_SA1100_COLLIE
+	sa1100_irda_set_power_collie(0);	/* power off */
+#endif
+#else
+	/* turn off interrupts */
+	outb(0, io + UART_IER);
+#endif
+	spin_unlock_irqrestore(&hardware_lock, flags);
+}
+
+/* SECTION: Initialisation */
+
+static int init_port(void)
+{
+	int retval;
+
+#ifndef CONFIG_LIRC_ON_SA1100
+	/* get I/O port access and IRQ line */
+	retval = request_region(io, 8, LIRC_DRIVER_NAME);
+	if (!retval) {
+		printk(KERN_ERR LIRC_DRIVER_NAME
+			": i/o port 0x%.4x already in use.\n",
+			io);
+		return retval;
+	}
+	printk(KERN_INFO LIRC_DRIVER_NAME
+		": I/O port 0x%.4x, IRQ %d.\n",
+		io, irq);
+#endif
+	retval = request_irq(irq, sir_interrupt, SA_INTERRUPT,
+			     LIRC_DRIVER_NAME, NULL);
+	if (retval < 0) {
+		printk(KERN_ERR LIRC_DRIVER_NAME
+			": IRQ %d already in use.\n",
+			irq);
+		return retval;
+	}
+
+	init_timer(&timerlist);
+	timerlist.function = sir_timeout;
+	timerlist.data = 0xabadcafe;
+
+	return 0;
+}
+
+static void drop_port(void)
+{
+	disable_irq(irq);
+	free_irq(irq, NULL);
+	del_timer_sync(&timerlist);
+#ifndef CONFIG_LIRC_ON_SA1100
+	release_region(io, 8);
+#endif
+}
+
+#ifdef CONFIG_LIRC_SIR_ACTISYS_ACT200L
+/******************************************************/
+/* Crystal/Cirrus CS8130 IR transceiver, used in Actisys Act200L dongle */
+/* some code borrowed from Linux IRDA driver */
+
+/* Regsiter 0: Control register #1 */
+#define ACT200L_REG0    0x00
+#define ACT200L_TXEN    0x01 /* Enable transmitter */
+#define ACT200L_RXEN    0x02 /* Enable receiver */
+#define ACT200L_ECHO    0x08 /* Echo control chars */
+
+/* Register 1: Control register #2 */
+#define ACT200L_REG1    0x10
+#define ACT200L_LODB    0x01 /* Load new baud rate count value */
+#define ACT200L_WIDE    0x04 /* Expand the maximum allowable pulse */
+
+/* Register 3: Transmit mode register #2 */
+#define ACT200L_REG3    0x30
+#define ACT200L_B0      0x01 /* DataBits, 0=6, 1=7, 2=8, 3=9(8P)  */
+#define ACT200L_B1      0x02 /* DataBits, 0=6, 1=7, 2=8, 3=9(8P)  */
+#define ACT200L_CHSY    0x04 /* StartBit Synced 0=bittime, 1=startbit */
+
+/* Register 4: Output Power register */
+#define ACT200L_REG4    0x40
+#define ACT200L_OP0     0x01 /* Enable LED1C output */
+#define ACT200L_OP1     0x02 /* Enable LED2C output */
+#define ACT200L_BLKR    0x04
+
+/* Register 5: Receive Mode register */
+#define ACT200L_REG5    0x50
+#define ACT200L_RWIDL   0x01 /* fixed 1.6us pulse mode */
+    /*.. other various IRDA bit modes, and TV remote modes..*/
+
+/* Register 6: Receive Sensitivity register #1 */
+#define ACT200L_REG6    0x60
+#define ACT200L_RS0     0x01 /* receive threshold bit 0 */
+#define ACT200L_RS1     0x02 /* receive threshold bit 1 */
+
+/* Register 7: Receive Sensitivity register #2 */
+#define ACT200L_REG7    0x70
+#define ACT200L_ENPOS   0x04 /* Ignore the falling edge */
+
+/* Register 8,9: Baud Rate Dvider register #1,#2 */
+#define ACT200L_REG8    0x80
+#define ACT200L_REG9    0x90
+
+#define ACT200L_2400    0x5f
+#define ACT200L_9600    0x17
+#define ACT200L_19200   0x0b
+#define ACT200L_38400   0x05
+#define ACT200L_57600   0x03
+#define ACT200L_115200  0x01
+
+/* Register 13: Control register #3 */
+#define ACT200L_REG13   0xd0
+#define ACT200L_SHDW    0x01 /* Enable access to shadow registers */
+
+/* Register 15: Status register */
+#define ACT200L_REG15   0xf0
+
+/* Register 21: Control register #4 */
+#define ACT200L_REG21   0x50
+#define ACT200L_EXCK    0x02 /* Disable clock output driver */
+#define ACT200L_OSCL    0x04 /* oscillator in low power, medium accuracy mode */
+
+static void init_act200(void)
+{
+  int i;
+	__u8 control[] = {
+		ACT200L_REG15,
+		ACT200L_REG13 | ACT200L_SHDW,
+		ACT200L_REG21 | ACT200L_EXCK | ACT200L_OSCL,
+		ACT200L_REG13,
+		ACT200L_REG7  | ACT200L_ENPOS,
+		ACT200L_REG6  | ACT200L_RS0  | ACT200L_RS1,
+		ACT200L_REG5  | ACT200L_RWIDL,
+		ACT200L_REG4  | ACT200L_OP0  | ACT200L_OP1 | ACT200L_BLKR,
+		ACT200L_REG3  | ACT200L_B0,
+		ACT200L_REG0  | ACT200L_TXEN | ACT200L_RXEN,
+		ACT200L_REG8 |  (ACT200L_115200       & 0x0f),
+		ACT200L_REG9 | ((ACT200L_115200 >> 4) & 0x0f),
+		ACT200L_REG1 | ACT200L_LODB | ACT200L_WIDE
+	};
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);
+
+	/* Set divisor to 12 => 9600 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,12);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, UART_LCR_WLEN8);
+	/* Set divisor to 12 => 9600 Baud */
+
+	/* power supply */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	for (i=0; i<50; i++) {
+		safe_udelay(1000);
+	}
+
+		/* Reset the dongle : set RTS low for 25 ms */
+	soutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);
+	for (i=0; i<25; i++) {
+		udelay(1000);
+	}
+
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(100);
+
+	/* Clear DTR and set RTS to enter command mode */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);
+	udelay(7);
+
+/* send out the control register settings for 115K 7N1 SIR operation */
+	for (i=0; i<sizeof(control); i++) {
+		soutp(UART_TX, control[i]);
+		/* one byte takes ~1042 usec to transmit at 9600,8N1 */
+		udelay(1500);
+	}
+
+	/* back to normal operation */
+	soutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);
+	udelay(50);
+
+	udelay(1500);
+	soutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);
+
+	/* Set DLAB 1. */
+	soutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);
+
+	/* Set divisor to 1 => 115200 Baud */
+	soutp(UART_DLM,0);
+	soutp(UART_DLL,1);
+
+	/* Set DLAB 0. */
+	soutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));
+
+	/* Set DLAB 0, 7 Bit */
+	soutp(UART_LCR, UART_LCR_WLEN7);
+
+	/* enable interrupts */
+	soutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);
+}
+#endif
+
+int init_lirc_sir(void)
+{
+	int retval;
+
+	init_waitqueue_head(&lirc_read_queue);
+	retval = init_port();
+	if (retval < 0)
+		return retval;
+	init_hardware();
+	enable_irq(irq);
+	printk(KERN_INFO LIRC_DRIVER_NAME
+		": Installed.\n");
+	return 0;
+}
+
+#ifdef CONFIG_LIRC_SIR_TEKRAM
+MODULE_AUTHOR("Christoph Bartelmus");
+MODULE_DESCRIPTION("Infrared receiver driver for Tekram Irmate 210");
+#elif defined(CONFIG_LIRC_ON_SA1100)
+MODULE_AUTHOR("Christoph Bartelmus");
+MODULE_DESCRIPTION("LIRC driver for StrongARM SA1100 embedded microprocessor");
+#elif defined(CONFIG_LIRC_SIR_ACTISYS_ACT200L)
+MODULE_AUTHOR("Karl Bongers");
+MODULE_DESCRIPTION("LIRC driver for Actisys Act200L");
+#else
+MODULE_AUTHOR("Milan Pikula");
+MODULE_DESCRIPTION("Infrared receiver driver for SIR type serial ports");
+#endif
+
+#ifdef CONFIG_LIRC_ON_SA1100
+MODULE_PARM(irq, "i");
+MODULE_PARM_DESC(irq, "Interrupt (16)");
+#else
+MODULE_PARM(io, "i");
+MODULE_PARM_DESC(io, "I/O address base (0x3f8 or 0x2f8)");
+MODULE_PARM(irq, "i");
+MODULE_PARM_DESC(irq, "Interrupt (4 or 3)");
+MODULE_PARM(threshold, "i");
+MODULE_PARM_DESC(threshold, "space detection threshold (3)");
+#endif
+
+MODULE_LICENSE("GPL");
+
+static int __init lirc_sir_init(void)
+{
+	int retval;
+
+	retval=init_chrdev();
+	if(retval < 0)
+		return retval;
+	retval = init_lirc_sir();
+	if (retval) {
+		drop_chrdev();
+		return retval;
+	}
+	return 0;
+}
+
+static void __exit lirc_sir_exit(void)
+{
+#ifdef CONFIG_MODULE_UNLOAD
+	if(module_refcount(THIS_MODULE)) return;
+#endif
+	drop_hardware();
+	drop_chrdev();
+	drop_port();
+	printk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");
+}
+
+module_init(lirc_sir_init);
+module_exit(lirc_sir_exit);
diff -Naur linux-2.6.17.8/drivers/char/lirc/lirc_stm.c linux-2.6.17.8-sh/drivers/char/lirc/lirc_stm.c
--- linux-2.6.17.8/drivers/char/lirc/lirc_stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/lirc_stm.c	2006-08-23 13:29:41.345669000 +0100
@@ -0,0 +1,1048 @@
+/*
+ * LIRC plugin for the STMicroelectronics IRDA devices
+ *
+ * Copyright (C) 2004-2005 STMicroelectronics
+ *
+ * June 2004:  first implementation for a 2.4 Linux kernel
+ *             Giuseppe Cavallaro  <peppe.cavallaro@st.com>
+ * March 2005: review to support pure raw mode and to adapt to Linux 2.6
+ *             Giuseppe Cavallaro  <peppe.cavallaro@st.com>
+ * June 2005:  Change to a MODE2 receive driver and made into a generic
+ *             ST driver.
+ *             Carl Shaw <carl.shaw@st.com>
+ * July 2005:  fix STB7100 MODE2 implementation and improve performance
+ *             of STm8000 version. <carl.shaw@st.com>
+ * Aug  2005:  Added clock autoconfiguration support.  Fixed module exit code.
+ * 	       Added UHF support (kernel build only).
+ * 	       Carl Shaw <carl.shaw@st.com>
+ * Sep  2005:  Added first transmit support
+ *             Added ability to set rxpolarity register
+ * 	       Angelo Castello <angelo.castello@st.com>
+ * 	       and Carl Shaw <carl.shaw@st.com>
+ * Oct  2005:  Added 7100 transmit
+ *             Added carrier width configuration
+ * 	       Carl Shaw <carl.shaw@st.com>
+ *
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include "lirc.h"
+#include "lirc_dev.h"
+
+/* General debugging */
+#undef LIRC_STM_DEBUG
+//#define LIRC_STM_DEBUG
+
+/* Generate test pattern for transmit */
+#undef LIRC_STM_TESTPATTERN
+//#define LIRC_STM_TESTPATTERN
+
+#ifdef  LIRC_STM_DEBUG
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define SUCCESS		0
+
+/*
+ * Infra Red: hardware register map
+ */
+#if defined(CONFIG_IRB_RECEIVER) || defined(MODULE)
+static int ir_uhf_switch = 0;
+#else
+static int ir_uhf_switch = 1;
+#endif
+
+static int ir_or_uhf_offset = 0;	/* = 0 for IR mode */
+static int irb_irq = 0;		/* IR block irq */
+static void *irb_base_address;	/* IR block register base address */
+
+/* RX timing fine control */
+static int irb_symbol_mult;
+static int irb_symbol_div;
+static int irb_pulse_mult;
+static int irb_pulse_div;
+
+/* TX timing fine control */
+static unsigned int lirc_stm_tx_mult;
+static unsigned int lirc_stm_tx_div;
+static int lirc_stm_tx_carrier_freq = 38000;	// in Hz
+
+/* maximum symbol period.  Symbol periods longer than this will generate
+ * an interrupt and terminate a command
+ */
+static unsigned int irb_max_period;
+
+/* IR transmitter registers */
+#define IRB_TX_PRESCALAR		(irb_base_address + 0x00)	/* clock prescalar */
+#define IRB_TX_SUBCARRIER		(irb_base_address + 0x04)	/* subcarrier frequency */
+#define IRB_TX_SYMPERIOD		(irb_base_address + 0x08)	/* symbol period (space + pulse) */
+#define IRB_TX_ONTIME			(irb_base_address + 0x0c)	/* symbol pulse time */
+#define IRB_TX_INT_ENABLE		(irb_base_address + 0x10)	/* TX irq enable */
+#define IRB_TX_INT_STATUS		(irb_base_address + 0x14)	/* TX irq status */
+#define IRB_TX_ENABLE			(irb_base_address + 0x18)	/* TX enable */
+#define IRB_TX_INT_CLEAR		(irb_base_address + 0x1c)	/* TX interrupt clear */
+#define IRB_TX_SUBCARRIER_WIDTH		(irb_base_address + 0x20)	/* subcarrier frequency width */
+#define IRB_TX_STATUS			(irb_base_address + 0x24)	/* TX status */
+
+#define TX_INT_PENDING			0x01
+#define TX_INT_UNDERRUN			0x02
+
+#define TX_FIFO_DEPTH			7
+#define TX_FIFO_USED			((readl(IRB_TX_STATUS) >> 8) & 0x07)
+
+/* IR receiver registers */
+#define IRB_RX_ON	    		(irb_base_address + 0x40 + ir_or_uhf_offset)	/* RX pulse time capture */
+#define IRB_RX_SYS          		(irb_base_address + 0x44 + ir_or_uhf_offset)	/* RX sym period capture */
+#define IRB_RX_INT_EN	    		(irb_base_address + 0x48 + ir_or_uhf_offset)	/* RX IRQ enable (R/W)   */
+#define IRB_RX_INT_STATUS      		(irb_base_address + 0x4C + ir_or_uhf_offset)	/* RX IRQ status (R/W)   */
+#define IRB_RX_EN	    		(irb_base_address + 0x50 + ir_or_uhf_offset)	/* Receive enable (R/W)  */
+#define IRB_MAX_SYM_PERIOD  		(irb_base_address + 0x54 + ir_or_uhf_offset)	/* end of sym. max value */
+#define IRB_RX_INT_CLEAR 		(irb_base_address + 0x58 + ir_or_uhf_offset)	/* overrun status (W)    */
+#define IRB_RX_STATUS	    		(irb_base_address + 0x6C + ir_or_uhf_offset)	/* receive status        */
+#define IRB_RX_NOISE_SUPPR  		(irb_base_address + 0x5C + ir_or_uhf_offset)	/* noise suppression     */
+#define IRB_RX_POLARITY_INV 		(irb_base_address + 0x68 + ir_or_uhf_offset)	/* polarity inverter     */
+
+/* IRB and UHF common registers */
+#define IRB_RX_RATE_COMMON   		(irb_base_address + 0x64)	/* sampling frequency divisor */
+#define IRB_RX_CLOCK_SELECT  		(irb_base_address + 0x70)	/* clock selection (for low-power mode) */
+#define IRB_RX_CLOCK_SELECT_STATUS 	(irb_base_address + 0x74)	/* clock selection status */
+#define IRB_RX_NOISE_SUPP_WIDTH 	(irb_base_address + 0x9C)
+
+#define MASTER_LIRC_DEV_NAME	"lirc_stm"
+#define LIRC_STM_MINOR		0
+
+#define RX_LAST_SYMBOL		0x02
+#define RXUNDERRUN_STATUS	0x02
+
+/* SOC dependent section - these values are set in the appropriate arch/<cpu>/soc/<soc> files and
+ * transfered when the lirc device is opened
+ */
+
+static unsigned int rx_fifo_has_data = 0;
+static unsigned int rx_clear_overrun = 0;
+static unsigned int overrun_error = 0;
+static unsigned int rx_sampling_freq_div = 0;
+static unsigned int enable_irq_rx = 0;
+static unsigned int irb_version = 0;
+#define RX_CLEAR_IRQ(x) \
+	if (irb_version >1) writel((x), IRB_RX_INT_CLEAR)
+#define HOW_MANY_WORDS_IN_FIFO() \
+	( (irb_version == 1)? readl(IRB_RX_INT_STATUS) & 0x30 : readl(IRB_RX_STATUS) & 0x0700 )
+
+/* Definition of a single RC symbol */
+typedef struct symbol_s {
+	unsigned int PulseUs;
+	unsigned int SpaceUs;
+} symbol_t;
+
+/* InfraRed receive control structure */
+#define MAX_SYMBOLS	100
+struct st_plugin_data_t {
+	int open_count;		/* INC at any open                      */
+	int error;		/* true if receive error.. skip symbols */
+	int symbols;		/* how many symbols in buf..            */
+	symbol_t buf[MAX_SYMBOLS];
+} pd;
+
+/* IR transmit buffer */
+static lirc_t wbuf[MAX_SYMBOLS];
+static volatile int off_wbuf = 0;
+
+/* LIRC subsytem symbol buffer */
+struct lirc_buffer stlirc_buffer;	/* managed only via common lirc routines */
+				     /* user process read symbols from here  */
+
+static inline void reset_irq_data(struct st_plugin_data_t *pd)
+{
+	pd->error = 0;
+	pd->symbols = 0;
+	memset((unsigned char *)pd->buf, 0, sizeof(pd->buf));
+}
+
+#ifdef LIRC_STM_DEBUG
+/* For debug only: in memory structure to trace interrupt
+ * status registers and symbols timing received.
+ */
+#define MAX_IRD		200
+typedef struct ird_t {
+	unsigned int a_intsta;
+	unsigned int b_intsta;
+	unsigned int c_intsta;
+	unsigned int a_status;
+	unsigned int b_status;
+	unsigned int sym;
+	unsigned int mark;
+	unsigned int sr;
+} ird_t;
+static int ird_valid = -1;
+static ird_t ird[MAX_IRD];
+
+static void trace_prt(void)
+{
+	int i;
+
+	if (ird_valid == -1)
+		return;
+
+	DPRINTK
+	    ("  #   IRQst  stats      S      M   IRQst  stats  IRQst   s.r\n");
+	for (i = 0; i < ird_valid; i++)
+		DPRINTK
+		    ("%3d    %04x  %04x   %5d  %5d    %04x   %04x   %04x   %3d\n",
+		     i, ird[i].a_intsta, ird[i].a_status, ird[i].sym,
+		     ird[i].mark, ird[i].b_intsta, ird[i].b_status,
+		     ird[i].c_intsta, ird[i].sr);
+	memset(ird, 0, sizeof(ird));
+	ird_valid = -1;
+}
+
+#define TRACEA(a,b)   { if (ird_valid >= MAX_IRD) \
+				ird_valid = -1; \
+			ird_valid++; \
+			ird[ird_valid].a_intsta = (a); \
+			ird[ird_valid].a_status = (b); }
+#define TRACES(a,b,c) { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+			{\
+				ird[ird_valid].sym  = (a); \
+				ird[ird_valid].mark = (b); \
+				ird[ird_valid].sr   = (c); \
+			}\
+		      }
+#define TRACEC(a,b)   { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+	                {\
+				ird[ird_valid].b_intsta = (a); \
+				ird[ird_valid].b_status = (b); \
+			}\
+		      }
+#define TRACEE(a)     { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
+				ird[ird_valid].c_intsta = (a); }
+#define TRACE_PRT()     trace_prt();
+#else
+#define TRACEA(a,b)
+#define TRACES(a,b,c)
+#define TRACEC(a,b)
+#define TRACEE(a)
+#define TRACE_PRT()
+
+#endif
+
+static inline unsigned int lirc_stm_time_to_cycles(unsigned int microsecondtime)
+{
+	/* convert a microsecond time to the nearest number of subcarrier clock
+	 * cycles
+	 */
+	microsecondtime *= lirc_stm_tx_mult;
+	microsecondtime /= lirc_stm_tx_div;
+	return (microsecondtime * lirc_stm_tx_carrier_freq / 1000000);
+}
+
+static inline int last_symbol(unsigned int symbol_time,
+			      unsigned int rx_irq_status)
+{
+	if ((symbol_time == 0xFFFF) && (rx_irq_status & RX_LAST_SYMBOL)) {
+		RX_CLEAR_IRQ(RX_LAST_SYMBOL);
+		return (1);
+	}
+	return (0);
+}
+
+static irqreturn_t lirc_stm_interrupt(int irq, void *dev_id,
+				      struct pt_regs *regs)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)dev_id;
+	unsigned int symbol, mark, done = 0;
+
+	/* loop until transmit complete
+	 * nasty - but linux doesn't have the interrupt response
+	 * to handle these uS interrupts in real time
+	 */
+
+	unsigned int tx_irq_status = readl(IRB_TX_INT_STATUS);
+
+	if ((tx_irq_status & TX_INT_PENDING) == TX_INT_PENDING) {
+		while (done == 0) {
+			if ((readl(IRB_TX_INT_STATUS) & TX_INT_UNDERRUN) ==
+			    TX_INT_UNDERRUN) {
+				/* There has been an underrun - clear flag, switch
+				 * off transmitter and signal possible exit
+				 */
+				printk(KERN_ERR
+				       "lirc_stm : transmit underrun!\n");
+				writel(1, IRB_TX_INT_CLEAR);
+				writel(0x00, IRB_TX_INT_ENABLE);
+				writel(0x00, IRB_TX_ENABLE);
+				done = 1;
+				DPRINTK("disabled TX\n");
+			} else {
+				int fifoslots = TX_FIFO_USED;
+
+				while (fifoslots < TX_FIFO_DEPTH) {
+					mark = wbuf[(off_wbuf * 2)];
+					symbol =
+					    mark + wbuf[(off_wbuf * 2) + 1];
+
+					mark =
+					    lirc_stm_time_to_cycles(mark) + 1;
+					symbol =
+					    lirc_stm_time_to_cycles(symbol) + 2;
+
+					if (wbuf[(off_wbuf * 2) + 1] == 0xFFFF) {
+						/* Dump out last symbol */
+						writel(mark * 2,
+						       IRB_TX_SYMPERIOD);
+						writel(mark, IRB_TX_ONTIME);
+#ifdef LIRC_STM_DEBUG
+						printk("Fm %d s %d\n", mark,
+						       mark * 2);
+#endif
+						/* flush transmit fifo */
+						while (TX_FIFO_USED != 0) {
+						};
+						writel(0, IRB_TX_SYMPERIOD);
+						writel(0, IRB_TX_ONTIME);
+						/* spin until TX fifo empty */
+						while (TX_FIFO_USED != 0) {
+						};
+						/* disable tx interrupts and transmitter */
+						writel(1, IRB_TX_INT_CLEAR);
+						writel(0x00, IRB_TX_INT_ENABLE);
+						writel(0x00, IRB_TX_ENABLE);
+						DPRINTK
+						    ("finished.  disabled TX\n");
+						off_wbuf = 0;
+						fifoslots = 999;
+						done = 1;
+					} else {
+						writel(symbol,
+						       IRB_TX_SYMPERIOD);
+						writel(mark, IRB_TX_ONTIME);
+#ifdef LIRC_STM_DEBUG
+						printk("Nm %d s %d\n", mark,
+						       symbol);
+#endif
+						off_wbuf++;
+						//fifoslots ++;
+						fifoslots = TX_FIFO_USED;
+					}
+				}
+			}
+		}
+	}
+
+	for (;;) {
+		/* if receive FIFO is empty exit from loop */
+		/* also deal with fifo underrun interrupt */
+		if (HOW_MANY_WORDS_IN_FIFO() == 0) {
+			RX_CLEAR_IRQ(rx_fifo_has_data | RXUNDERRUN_STATUS);
+			break;
+		} else {
+			unsigned int rx_irq_status = readl(IRB_RX_INT_STATUS);
+
+			/* discard the entire collection in case of errors!  */
+			if (rx_irq_status & overrun_error) {
+				printk(KERN_INFO "IR overrun\n");
+				writel(rx_clear_overrun, IRB_RX_INT_CLEAR);
+				pd->error = 1;
+			}
+
+			TRACEA(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
+
+			/* get the symbol times from FIFO */
+			symbol = (readl(IRB_RX_SYS));
+			mark = (readl(IRB_RX_ON));
+
+			/*  Clear the interrupt (not required for some boards) */
+			RX_CLEAR_IRQ(rx_fifo_has_data);
+
+			if (pd->symbols >= MAX_SYMBOLS) {
+				printk("IR too many symbols (max %d)\n",
+				       MAX_SYMBOLS);
+				pd->error = 1;
+			}
+
+			/* now handle the data depending on error condition */
+			if (pd->error) {
+				/*  Try again */
+				reset_irq_data(pd);
+			} else {
+				int lastSymbol =
+				    last_symbol(symbol, rx_irq_status);
+
+				/* A sequence seems to start with a constant time symbol (1us)
+				 * pulse and symbol time length, both of 1us. We ignore this.
+				 */
+				if ((mark > 2) && (symbol > 1)) {
+					TRACES(symbol, mark, pd->symbols);
+
+					/* Make fine adjustments to timings */
+					symbol -= mark;	/* to get space timing */
+					symbol *= irb_symbol_mult;
+					symbol /= irb_symbol_div;
+					mark *= irb_pulse_mult;
+					mark /= irb_pulse_div;
+
+					/* The ST hardware returns the pulse time and the period, which is
+					 * the pulse time + space time, so we need to subtract the pulse time from
+					 * the period to get the space time.
+					 * For a pulse in LIRC MODE2, we need to set the PULSE_BIT ON
+					 */
+					pd->buf[pd->symbols].PulseUs =
+					    mark | PULSE_BIT;
+					pd->buf[pd->symbols].SpaceUs = symbol;
+					pd->symbols++;
+
+					if (lastSymbol) {
+						if (pd->symbols > 1) {
+							/* move the entire collection into user buffer if enough
+							 * space, drop it otherwise (perhaps too crude a recovery?)
+							 */
+							if (lirc_buffer_available(&stlirc_buffer) >= (2 * pd->symbols)) {
+								lirc_t longSpace
+								    =
+								    (lirc_t)
+								    PULSE_MASK;
+
+								DPRINTK
+								    ("W symbols = %d\n",
+								     pd->
+								     symbols);
+
+								/*  Write a long space to synchronise higher levels
+								 *  We should maybe change this to IRB_MAX_SYM_PERIOD in useconds
+								 *  as this is the actual space that will trigger a value of 0xFFFF
+								 *  in IRB_RX_SYM_PERIOD.
+								 *  A value of 0xFFFF microseconds may not be large enough for the
+								 *  higher level lirc software, so we replace it with <longSpace>.
+								 */
+								lirc_buffer_write_1
+								    (&stlirc_buffer,
+								     (unsigned
+								      char *)
+								     &longSpace);
+
+								/*  Now write the pulse / space pairs EXCEPT FOR THE LAST SPACE
+								 *  The last space value should be 0xFFFF to denote a timeout
+								 */
+								lirc_buffer_write_n
+								    (&stlirc_buffer,
+								     (unsigned
+								      char *)
+								     pd->buf,
+								     (2 *
+								      pd->
+								      symbols) -
+								     1);
+								wake_up
+								    (&stlirc_buffer.
+								     wait_poll);
+							} else
+								printk(KERN_ERR
+								       "Not enough space in user buffer\n");
+
+							TRACE_PRT();
+						}
+
+						reset_irq_data(pd);
+					}
+
+				}
+
+			}
+
+			TRACEC(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
+		}		/* receive handler */
+	}
+
+	TRACEE(readl(IRB_RX_INT_STATUS));
+
+	return IRQ_HANDLED;
+}
+
+static int stm_set_use_inc(void *data)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
+
+	DPRINTK("entering (open N. %d)\n", pd->open_count);
+
+	/* enable the device only at the first open */
+	if (pd->open_count++ == 0) {
+		unsigned long flags;
+		DPRINTK("Enabled\n");
+		local_irq_save(flags);
+
+		/* enable interrupts and receiver */
+		writel(enable_irq_rx, IRB_RX_INT_EN);
+		writel(0x01, IRB_RX_EN);
+		reset_irq_data(pd);
+
+		local_irq_restore(flags);
+	} else
+		DPRINTK("Already open\n");
+
+	return (SUCCESS);
+}
+
+static void flush_stm_lirc(struct st_plugin_data_t *pd)
+{
+	/* Disable receiver and clean the buffer */
+	writel(0x00, IRB_RX_EN);
+
+	if (irb_version == 2) {
+		/* TBD: set one word in FIFO ??? and disable interrupt */
+		writel(0x20, IRB_RX_INT_EN);
+	} else {
+		writel(0x00, IRB_RX_INT_EN);
+	}
+
+	reset_irq_data(pd);
+}
+
+/*
+** Called by lirc_dev as a last action on a real close
+*/
+static void stm_set_use_dec(void *data)
+{
+	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
+	DPRINTK("entering (close N. %d)\n", pd->open_count);
+
+	/* The last close disable the receiver */
+	if (--pd->open_count == 0)
+		flush_stm_lirc(pd);
+	TRACE_PRT();
+}
+
+static int lirc_stm_ioctl(struct inode *node, struct file *filep,
+			  unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	unsigned long value = 0;
+	char *msg = "";
+
+	switch (cmd) {
+	case LIRC_GET_FEATURES:
+		/*
+		 * Our driver can receive in mode2 and send in pulse mode.
+		 * TODO: We can generate our own carrier freq (LIRC_CAN_SET_SEND_CARRIER)
+		 *       and also change duty cycle (LIRC_CAN_SET_SEND_DUTY_CYCLE)
+		 */
+		DPRINTK("LIRC_GET_FEATURES return REC_MODE2|SEND_PULSE\n");
+		retval = put_user(LIRC_CAN_REC_MODE2 |
+				  LIRC_CAN_SEND_PULSE, (unsigned long *)arg);
+		break;
+
+	case LIRC_GET_REC_MODE:
+		DPRINTK("LIRC_GET_REC_MODE return LIRC_MODE_MODE2\n");
+		retval = put_user(LIRC_MODE_MODE2, (unsigned long *)arg);
+		break;
+
+	case LIRC_SET_REC_MODE:
+		retval = get_user(value, (unsigned long *)arg);
+		DPRINTK("LIRC_SET_REC_MODE to 0x%lx\n", value);
+		if (value != LIRC_MODE_MODE2)
+			retval = -ENOSYS;
+		break;
+
+	case LIRC_GET_SEND_MODE:
+		DPRINTK("LIRC_GET_SEND_MODE return LIRC_MODE_PULSE\n");
+		retval = put_user(LIRC_MODE_PULSE, (unsigned long *)arg);
+		break;
+
+	case LIRC_SET_SEND_MODE:
+		retval = get_user(value, (unsigned long *)arg);
+		DPRINTK("LIRC_SET_SEND_MODE to 0x%lx\n", value);
+		/* only LIRC_MODE_PULSE supported */
+		if (value != LIRC_MODE_PULSE)
+			return (-ENOSYS);
+		break;
+
+	case LIRC_GET_REC_RESOLUTION:
+		msg = "LIRC_GET_REC_RESOLUTION";
+		goto _not_supported;
+
+	case LIRC_GET_REC_CARRIER:
+		msg = "LIRC_GET_REC_CARRIER";
+		goto _not_supported;
+
+	case LIRC_SET_REC_CARRIER:
+		msg = "LIRC_SET_REC_CARRIER";
+		goto _not_supported;
+
+	case LIRC_GET_SEND_CARRIER:
+		msg = "LIRC_GET_SEND_CARRIER";
+		goto _not_supported;
+
+	case LIRC_SET_SEND_CARRIER:
+		msg = "LIRC_SET_SEND_CARRIER";
+		goto _not_supported;
+
+	case LIRC_GET_REC_DUTY_CYCLE:
+		msg = "LIRC_GET_REC_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_SET_REC_DUTY_CYCLE:
+		msg = "LIRC_SET_REC_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_GET_SEND_DUTY_CYCLE:
+		msg = "LIRC_GET_SEND_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_SET_SEND_DUTY_CYCLE:
+		msg = "LIRC_SET_SEND_DUTY_CYCLE";
+		goto _not_supported;
+
+	case LIRC_GET_LENGTH:
+		msg = "LIRC_GET_LENGTH";
+		goto _not_supported;
+
+	default:
+		msg = "???";
+	      _not_supported:
+		DPRINTK("command %s (0x%x) not supported\n", msg, cmd);
+		retval = -ENOIOCTLCMD;
+	}
+
+	return retval;
+}
+
+static ssize_t lirc_stm_write(struct file *file, const char *buf,
+			      size_t n, loff_t * ppos)
+{
+	int retval, i;
+	int symbol = 0;
+	char local[256];
+	unsigned int period, mark;
+	int fifosyms;
+
+	if (n % sizeof(lirc_t))
+		return (-EINVAL);
+
+	retval = verify_area(VERIFY_READ, buf, n);
+	if (retval)
+		return (retval);
+
+	if (n == 0)
+		return 0;
+
+	copy_from_user(local, buf, n);
+
+	i = 0;
+	while (i < n) {
+		wbuf[symbol] = (unsigned char)local[i];
+		wbuf[symbol] |= (((unsigned char)local[i + 1]) << 8);
+		wbuf[symbol] |= (((unsigned char)local[i + 2]) << 16);
+		wbuf[symbol] |= (((unsigned char)local[i + 3]) << 24);
+
+#if defined(LIRC_STM_DEBUG) && defined(LIRC_STM_TESTPATTERN)
+		/* XXX TEST PATTERN XXX */
+		if (i % 8 == 0)
+			wbuf[symbol] = 1000 + ((i / 4) * 500);
+		else
+			wbuf[symbol] = 1000 + ((i / 4) * 500);
+#endif
+
+#ifdef LIRC_STM_DEBUG
+		printk("%05d  ", wbuf[symbol]);
+		if (symbol % 8 == 0 && symbol != 0)
+			printk("\n");
+#endif
+
+		symbol++;
+
+		i = i + sizeof(int);
+	}
+	wbuf[symbol] = 0xFFFF;
+#ifdef LIRC_STM_DEBUG
+	printk("%4d\n", wbuf[symbol]);
+#endif
+
+	off_wbuf = 0;
+
+	DPRINTK("IRB_TX_PRESCALAR = %d\n", readl(IRB_TX_PRESCALAR));
+	DPRINTK("IRB_TX_SUBCARRIER = %d\n", readl(IRB_TX_SUBCARRIER));
+	DPRINTK("IRB_TX_SUBCARRIER_WIDTH = %d\n",
+		readl(IRB_TX_SUBCARRIER_WIDTH));
+
+	/* load the first (up to) words into the FIFO */
+	fifosyms = (n / sizeof(lirc_t));
+	if (fifosyms > TX_FIFO_DEPTH)
+		fifosyms = TX_FIFO_DEPTH;
+
+	for (i = 0; i < fifosyms; i++) {
+		mark = wbuf[i * 2];
+		period = mark + wbuf[i * 2 + 1];
+		mark = lirc_stm_time_to_cycles(mark) + 1;
+		period = lirc_stm_time_to_cycles(period) + 2;
+		DPRINTK("adding:  mark = %d  space = %d\n", mark,
+			period - mark);
+		off_wbuf++;
+		writel(period, IRB_TX_SYMPERIOD);
+		writel(mark, IRB_TX_ONTIME);
+	}
+
+#if defined(LIRC_STM_DEBUG) && defined(LIRC_STM_TESTPATTERN)
+	/* XXX TEST PATTERN XXX */
+	wbuf[off_wbuf * 2 + 1] = 0xFFFF;
+#endif
+
+	/* enable the transmit */
+	writel(0x07, IRB_TX_INT_ENABLE);
+	writel(0x01, IRB_TX_ENABLE);
+
+	DPRINTK("lirc_stm_write(): exiting \n");
+	return 0;
+}
+
+static void lirc_stm_calc_tx_clocks(unsigned int clockfreq,
+				    unsigned int carrierfreq,
+				    unsigned int subwidthpercent)
+{
+	/*  We know the system base clock and the required IR carrier frequency
+	 *  We now want a divisor of the system base clock that gives the nearest
+	 *  integer multiple of the carrier frequency
+	 */
+
+	const unsigned int clkratio = clockfreq / carrierfreq;
+	unsigned int scalar, n;
+	int delta;
+	unsigned int diffbest = clockfreq, nbest = 0, scalarbest = 0;
+	unsigned int nmin = clkratio / 255;
+
+	if ((nmin & 0x01) == 1)
+		nmin++;
+
+	for (n = nmin; n < clkratio; n += 2) {
+		scalar = clkratio / n;
+		if ((scalar & 0x01) == 0 && scalar != 0) {
+			delta = clockfreq - (scalar * carrierfreq * n);
+			if (delta < 0)
+				delta *= -1;
+
+			if (delta < diffbest) {	/* better set of parameters ? */
+				diffbest = delta;
+				nbest = n;
+				scalarbest = scalar;
+			}
+			if (delta == 0)	/* an exact multiple */
+				break;
+		}
+	}
+
+	scalarbest /= 2;
+	nbest *= 2;
+
+	DPRINTK("TX clock scalar = %d\n", scalarbest);
+	DPRINTK("TX subcarrier scalar = %d\n", nbest);
+
+	/*  Set the registers now  */
+
+	writel(scalarbest, IRB_TX_PRESCALAR);
+	writel(nbest, IRB_TX_SUBCARRIER);
+	writel(nbest * subwidthpercent / 100, IRB_TX_SUBCARRIER_WIDTH);
+
+	/*  Now calculate timing to subcarrier cycles factors which compensate for
+	 *  any remaining difference between our clock ratios and real times in
+	 *  microseconds
+	 */
+
+	if (diffbest == 0) {
+		/* no adjustment required - our clock is running at the required speed */
+		lirc_stm_tx_mult = 1;
+		lirc_stm_tx_div = 1;
+	} else {
+		/* adjustment is required */
+		delta = scalarbest * carrierfreq * nbest;
+		lirc_stm_tx_mult = delta / (clockfreq / 10000);
+
+		if (delta < clockfreq) {	/* our clock is running too fast */
+			DPRINTK("Clock running slow at %d\n", delta);
+			lirc_stm_tx_div = lirc_stm_tx_mult;
+			lirc_stm_tx_mult = 10000;
+		} else {	/* our clock is running too slow */
+
+			DPRINTK("Clock running fast at %d\n", delta);
+			lirc_stm_tx_div = 10000;
+		}
+	}
+
+	DPRINTK("TX fine adjustment mult = %d\n", lirc_stm_tx_mult);
+	DPRINTK("TX fine adjustment div  = %d\n", lirc_stm_tx_div);
+}
+
+static struct file_operations lirc_stm_fops = {
+      write:lirc_stm_write,
+};
+
+static struct lirc_plugin lirc_stm_plugin = {
+	.name = "lirc_stm",
+	.minor = LIRC_STM_MINOR,
+	.code_length = 1,
+	.sample_rate = 0,
+	/* plugin can receive raw pulse and space timings for each symbol */
+	.features = LIRC_CAN_REC_MODE2,
+	/* plugin private data  */
+	.data = (void *)&pd,
+	/* buffer handled by upper layer */
+	.add_to_buf = NULL,
+	.get_queue = NULL,
+	.set_use_inc = stm_set_use_inc,
+	.set_use_dec = stm_set_use_dec,
+	.ioctl = lirc_stm_ioctl,
+	.fops = &lirc_stm_fops,
+	.rbuf = &stlirc_buffer,
+	.owner = THIS_MODULE,
+};
+
+static int __init lirc_stm_init(void)
+{
+	int ret = 0;
+	struct platform_device *pridat = NULL;
+	struct plat_lirc_data *lirc_private_info = NULL;
+	struct resource *res;
+	int baseclock;
+	unsigned int scwidth;
+
+	DPRINTK("initializing the IR receiver...\n");
+
+	/* inform the top level driver that we use our own user buffer */
+	if (lirc_buffer_init(&stlirc_buffer, sizeof(lirc_t), (2 * MAX_SYMBOLS))) {
+		printk(KERN_ERR "initializing the STM LIRC plug-in buffer\n");
+		return -EINVAL;
+	}
+
+	request_module("lirc_dev");
+	if ((ret = lirc_register_plugin(&lirc_stm_plugin)) < 0) {
+		printk(KERN_ERR "ERROR: IR plug-in registration failed\n");
+		return -EINVAL;
+	}
+
+	/*  At this point, we need to get a pointer to the platform-specific data */
+	if ((pridat = (struct platform_device *)lirc_get_config()) == NULL) {
+		printk(KERN_ERR "ERROR: Configuration information not found\n");
+		return -EINVAL;
+	}
+
+	/* Request the IRQ */
+	if ((irb_irq = platform_get_irq(pridat, 0)) == 0) {
+		printk(KERN_ERR
+		       "ERROR: IRQ configuration information not found\n");
+		return -ENODEV;
+	}
+
+	if ((ret = request_irq(irb_irq, lirc_stm_interrupt, SA_INTERRUPT,
+			       MASTER_LIRC_DEV_NAME, (void *)&pd)) < 0) {
+		printk(KERN_ERR "ERROR:IRQ register failed\n");
+		return (-EIO);
+	}
+
+	printk(KERN_INFO "STM LIRC plugin has IRQ %d\n", irb_irq);
+
+	/* Hardware IR block setup - the PIO ports should already be set up
+	 * in the board-dependent configuration.  We need to remap the
+	 * IR registers into kernel space - we do this in one chunk
+	 */
+
+	res = platform_get_resource(pridat, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR
+		       "ERROR: IO MEM configuration information not found\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start, "lirc")) {
+		printk(KERN_ERR "ERROR: request_mem_region failed\n");
+		return -EBUSY;
+	}
+
+	irb_base_address = ioremap(res->start, res->end - res->start);
+	if (irb_base_address == NULL) {
+		printk(KERN_ERR "ERROR: Cannot ioremap IRB register block\n");
+		release_mem_region(res->start, res->end - res->start);
+		return -ENOMEM;
+	}
+
+	DPRINTK(KERN_INFO "ioremapped register block at 0x%lx\n", res->start);
+	DPRINTK(KERN_INFO "ioremapped to 0x%x\n",
+		(unsigned int)irb_base_address);
+
+	/* Configure for ir or uhf */
+	if (ir_uhf_switch) {
+		ir_or_uhf_offset = 0x40;
+		printk(KERN_INFO " Lirc STM: Using UHF mode\n");
+	} else {
+		ir_or_uhf_offset = 0x0;
+		printk(KERN_INFO " Lirc STM: Using IRB mode\n");
+	}
+
+	/*  set up the hardware version dependent setup parameters */
+	lirc_private_info = pridat->dev.platform_data;
+
+	/* Set the polarity inversion bit to the correct state */
+	writel(lirc_private_info->rxpolarity, IRB_RX_POLARITY_INV);
+
+	irb_version = lirc_private_info->irbversion;
+	DPRINTK(KERN_INFO "IRB type is %d\n", irb_version);
+
+	overrun_error = 0x04;
+
+	if (irb_version == 1) {	/* For Stm8000, STi5528 */
+		rx_fifo_has_data = 0x30;
+		rx_clear_overrun = 0x01;
+		/* IRQ set: 2 word in Fifo (half full) 10 -> bits 5,4;
+		 *          Enable last symbol IRQ     1  -> bit  1:
+		 *          Enable RX interrupt        1  -> bit  0;
+		 */
+		enable_irq_rx = 0x23;
+	} else if (irb_version == 2 || 3) {	/* For STb7100 (2), and 5301 (3) */
+		rx_fifo_has_data = 0x38;
+		rx_clear_overrun = 0x04;
+		/* IRQ set: Enable at least 1 word in FIFO   1  -> bit  5;
+		 *          Enable overrun IRQ               1  -> bit  2;
+		 *          Enable last symbol IRQ           1  -> bit  1:
+		 *          Enable RX interrupt              1  -> bit  0;
+		 */
+		enable_irq_rx = 0x27;
+	}
+
+	/*  Get or calculate the clock and timing adjustment values.
+	 *  We can auto-calculate these in some cases
+	 */
+
+	if (lirc_private_info->irbclock == 0)
+		baseclock =
+		    current_cpu_data.bus_clock / lirc_private_info->sysclkdiv;
+	else
+		baseclock = lirc_private_info->irbclock;
+
+	if (lirc_private_info->irbclkdiv == 0) {
+		/* Auto-calculate clock divisor */
+
+		int freqdiff;
+
+		rx_sampling_freq_div = baseclock / 10000000;
+
+		/* Work out the timing adjustment factors */
+		freqdiff = baseclock - (rx_sampling_freq_div * 10000000);
+
+		/* freqdiff contains the difference between our clock and a
+		 * true 10 MHz clock which the IR block wants
+		 */
+
+		if (freqdiff == 0) {
+			/* no adjustment required - our clock is running at the required speed */
+			irb_symbol_mult = 1;
+			irb_pulse_mult = 1;
+			irb_symbol_div = 1;
+			irb_pulse_div = 1;
+		} else {
+			/* adjustment is required */
+			irb_symbol_mult =
+			    baseclock / (10000 * rx_sampling_freq_div);
+
+			if (freqdiff > 0) {
+				/* our clock is running too fast */
+				irb_pulse_mult = 1000;
+				irb_pulse_div = irb_symbol_mult;
+				irb_symbol_mult = irb_pulse_mult;
+				irb_symbol_div = irb_pulse_div;
+			} else {
+				/* our clock is running too slow */
+				irb_symbol_div = 1000;
+				irb_pulse_mult = irb_symbol_mult;
+				irb_pulse_div = 1000;
+			}
+
+		}
+
+	} else {
+		rx_sampling_freq_div = (lirc_private_info->irbclkdiv);
+		irb_symbol_mult = (lirc_private_info->irbperiodmult);
+		irb_symbol_div = (lirc_private_info->irbperioddiv);
+		irb_pulse_mult = (lirc_private_info->irbontimemult);
+		irb_pulse_div = (lirc_private_info->irbontimediv);
+	}
+
+	writel(rx_sampling_freq_div, IRB_RX_RATE_COMMON);
+	DPRINTK(KERN_INFO "IRB clock is %d\n", baseclock);
+	DPRINTK(KERN_INFO "IRB clock divisor is %d\n", rx_sampling_freq_div);
+	DPRINTK(KERN_INFO "IRB clock divisor readlack is %d\n",
+		readl(IRB_RX_RATE_COMMON));
+	DPRINTK(KERN_INFO "IRB period mult factor is %d\n", irb_symbol_mult);
+	DPRINTK(KERN_INFO "IRB period divisor factor is %d\n", irb_symbol_div);
+	DPRINTK(KERN_INFO "IRB pulse mult factor is %d\n", irb_pulse_mult);
+	DPRINTK(KERN_INFO "IRB pulse divisor factor is %d\n", irb_pulse_div);
+
+	/*  Set the RC command timeout value */
+
+	if ((lirc_private_info->irbrxmaxperiod) != 0)
+		irb_max_period =
+		    (lirc_private_info->irbrxmaxperiod) * irb_symbol_mult /
+		    irb_symbol_div;
+	else
+		irb_max_period = 0;
+
+	DPRINTK(KERN_INFO "IRB RX Maximum symbol period register 0x%x\n",
+		irb_max_period);
+	writel(irb_max_period, IRB_MAX_SYM_PERIOD);
+
+	/*  Set up the transmit timings  */
+	if (lirc_private_info->subcarrwidth != 0)
+		scwidth = lirc_private_info->subcarrwidth;
+	else
+		scwidth = 50;
+
+	if (scwidth > 100)
+		scwidth = 50;
+
+	DPRINTK(KERN_INFO "Subcarrier width set to %d %%\n", scwidth);
+	lirc_stm_calc_tx_clocks(baseclock, lirc_stm_tx_carrier_freq, scwidth);
+
+	printk(KERN_INFO "STMicroelectronics LIRC driver configured\n");
+
+	return (0);
+}
+
+void __exit lirc_stm_release(void)
+{
+	int ret_value;
+	struct platform_device *pridat = NULL;
+	struct resource *res;
+
+	DPRINTK("removing STM lirc plugin\n");
+
+	flush_stm_lirc(&pd);
+
+	if ((ret_value = lirc_unregister_plugin(LIRC_STM_MINOR)) < 0)
+		printk(KERN_ERR "STM InfraRed plug-in unregister failed\n");
+
+	iounmap(irb_base_address);
+
+	pridat = (struct platform_device *)lirc_get_config();
+	res = platform_get_resource(pridat, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start);
+
+	free_irq(irb_irq, (void *)&pd);
+	printk(KERN_INFO "STMicroelectronics LIRC driver removed\n");
+}
+
+module_param(ir_uhf_switch, bool, 0644);
+MODULE_PARM_DESC(ir_uhf_switch, "Enable uhf mode");
+
+module_init(lirc_stm_init);
+module_exit(lirc_stm_release);
+MODULE_DESCRIPTION
+    ("Linux InfraRed receiver plugin for STMicroelectronics platforms");
+MODULE_AUTHOR("Carl Shaw <carl.shaw@st.com>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/char/lirc/Makefile linux-2.6.17.8-sh/drivers/char/lirc/Makefile
--- linux-2.6.17.8/drivers/char/lirc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/lirc/Makefile	2006-08-23 13:29:34.183508000 +0100
@@ -0,0 +1,15 @@
+#
+# Makefile for the lirc drivers
+#
+
+obj-$(CONFIG_LIRC_SUPPORT) += lirc_dev.o
+obj-$(CONFIG_LIRC_GPIO) += lirc_gpio.o
+obj-$(CONFIG_LIRC_BT829) += lirc_bt829.o
+obj-$(CONFIG_LIRC_IT87) += lirc_it87.o
+obj-$(CONFIG_LIRC_PARALLEL) += lirc_parallel.o
+obj-$(CONFIG_LIRC_SERIAL) += lirc_serial.o
+obj-$(CONFIG_LIRC_SIR) += lirc_sir.o
+obj-$(CONFIG_LIRC_ATIUSB) += lirc_atiusb.o
+obj-$(CONFIG_LIRC_MCEUSB) += lirc_mceusb.o
+obj-$(CONFIG_LIRC_I2C) += lirc_i2c.o
+obj-$(CONFIG_ST_LIRC) += lirc_stm.o
diff -Naur linux-2.6.17.8/drivers/char/Makefile linux-2.6.17.8-sh/drivers/char/Makefile
--- linux-2.6.17.8/drivers/char/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/Makefile	2006-08-23 13:29:41.789668000 +0100
@@ -7,7 +7,7 @@
 #
 FONTMAPFILE = cp437.uni
 
-obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o
+obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o lirc/
 
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
@@ -67,6 +67,10 @@
 obj-$(CONFIG_SGI_IP27_RTC)	+= ip27-rtc.o
 obj-$(CONFIG_DS1302)		+= ds1302.o
 obj-$(CONFIG_S3C2410_RTC)	+= s3c2410-rtc.o
+obj-$(CONFIG_RTC_9701JE)	+= rtc9701_rtc.o
+obj-$(CONFIG_RS5C313_RTC)	+= rs5c313_rtc.o
+obj-$(CONFIG_SH03_RTC)		+= sh03rtc.o
+obj-$(CONFIG_STM_RTC)           += st-rtc.o
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM)	+= generic_nvram.o
 else
@@ -86,6 +90,7 @@
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_TANBAC_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_ST_PIO)		+= stpio.o
 
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_MWAVE)		+= mwave/
diff -Naur linux-2.6.17.8/drivers/char/rs5c313_rtc.c linux-2.6.17.8-sh/drivers/char/rs5c313_rtc.c
--- linux-2.6.17.8/drivers/char/rs5c313_rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/rs5c313_rtc.c	2006-08-23 13:29:14.727047000 +0100
@@ -0,0 +1,855 @@
+/*
+ * RICHO RS5C313 Real Time Clock interface for Linux
+ *
+ *  2005-09-19 modifed by kogiidena
+ *
+ *  Copyright (C) 2000 Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 1999 Tetsuya Okada & Niibe Yutaka
+ *
+ * Based on code written by Paul Gortmaker.
+ *  Copyright (C) 1996 Paul Gortmaker
+ *
+ *  This driver allows use of the real time clock (built into
+ *  nearly all computers) from user space. It exports the /dev/rtc
+ *  interface supporting various ioctl() and also the
+ *  /proc/driver/rtc pseudo-file for status information.
+ *
+ *  The ioctls can be used to set the interrupt behaviour and
+ *  generation rate from the RTC via IRQ 8. Then the /dev/rtc
+ *  interface can be used to make use of these timer interrupts,
+ *  be they interval or alarm based.
+ *
+ *  The /dev/rtc interface will block on reads until an interrupt
+ *  has been received. If a RTC interrupt has already happened,
+ *  it will output an unsigned long and then block. The output value
+ *  contains the interrupt status in the low byte and the number of
+ *  interrupts since the last read in the remaining high bytes. The
+ *  /dev/rtc interface can also be used with the select(2) call.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ *  Based on other minimal char device drivers, like Alan's
+ *  watchdog, Ted's random, etc. etc.
+ *
+ *	1.07	Paul Gortmaker.
+ *	1.08	Miquel van Smoorenburg: disallow certain things on the
+ *		DEC Alpha as the CMOS clock is also used for other things.
+ *	1.09	Nikita Schmidt: epoch support and some Alpha cleanup.
+ *	1.09a	Pete Zaitcev: Sun SPARC
+ *	1.09b	Jeff Garzik: Modularize, init cleanup
+ *	1.09c	Jeff Garzik: SMP cleanup
+ *	1.10    Paul Barton-Davis: add support for async I/O
+ *	1.10a	Andrea Arcangeli: Alpha updates
+ *	1.10b	Andrew Morton: SMP lock fix
+ *	1.10c	Cesar Barros: SMP locking fixes and cleanup
+ *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit
+ *	1.10e	Maciej W. Rozycki: Handle DECstation's year weirdness.
+ *      1.11    Takashi Iwai: Kernel access functions
+ *			      rtc_register/rtc_unregister/rtc_control
+ *      1.11a   Daniele Bellucci: Audit create_proc_read_entry in rtc_init
+ *	1.12	Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
+ *		CONFIG_HPET_EMULATE_RTC
+ *
+ */
+
+#define RTC_VERSION		"1.12"
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/bcd.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/mc146818rtc.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/spinlock.h>
+#include <linux/sysctl.h>
+#include <linux/wait.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+
+#ifndef CONFIG_SH_LANDISK
+#error  rs5c313 read and write function not defined
+#endif
+
+#ifdef CONFIG_SH_LANDISK
+/*****************************************************/
+/* LANDISK dependence part of RS5C313                */
+/*****************************************************/
+
+#define SCSMR1	0xFFE00000
+#define SCSCR1	0xFFE00008
+#define SCSMR1_CA	0x80
+#define SCSCR1_CKE	0x03
+#define SCSPTR1	0xFFE0001C
+#define SCSPTR1_EIO	0x80
+#define SCSPTR1_SPB1IO	0x08
+#define SCSPTR1_SPB1DT	0x04
+#define SCSPTR1_SPB0IO	0x02
+#define SCSPTR1_SPB0DT	0x01
+
+#define SDA_OEN	SCSPTR1_SPB1IO
+#define SDA	SCSPTR1_SPB1DT
+#define SCL_OEN	SCSPTR1_SPB0IO
+#define SCL	SCSPTR1_SPB0DT
+
+/* RICOH RS5C313 CE port */
+#define RS5C313_CE		0xB0000003
+
+/* RICOH RS5C313 CE port bit */
+#define RS5C313_CE_RTCCE	0x02
+
+/* SCSPTR1 data */
+unsigned char scsptr1_data;
+
+#define RS5C313_CEENABLE    ctrl_outb(RS5C313_CE_RTCCE, RS5C313_CE);
+#define RS5C313_CEDISABLE   ctrl_outb(0x00, RS5C313_CE)
+#define RS5C313_MISCOP      ctrl_outb(0x02, 0xB0000008)
+
+static void rs5c313_initialize(void)
+{
+	/* Set SCK as I/O port and Initialize SCSPTR1 data & I/O port. */
+	ctrl_outb(ctrl_inb(SCSMR1) & ~SCSMR1_CA, SCSMR1);
+	ctrl_outb(ctrl_inb(SCSCR1) & ~SCSCR1_CKE, SCSCR1);
+
+	/* And Initialize SCL for RS5C313 clock */
+	scsptr1_data = ctrl_inb(SCSPTR1) | SCL;	/* SCL:H */
+	ctrl_outb(scsptr1_data, SCSPTR1);
+	scsptr1_data = ctrl_inb(SCSPTR1) | SCL_OEN;	/* SCL output enable */
+	ctrl_outb(scsptr1_data, SCSPTR1);
+	RS5C313_CEDISABLE;	/* CE:L */
+}
+
+static void rs5c313_write(unsigned char data)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		/* SDA:Write Data */
+		scsptr1_data = (scsptr1_data & ~SDA)
+		             | ((((0x80 >> i) & data) >> (7 - i)) << 2);
+		ctrl_outb(scsptr1_data, SCSPTR1);
+		if (i == 0) {
+			scsptr1_data |= SDA_OEN;	/* SDA:output enable */
+			ctrl_outb(scsptr1_data, SCSPTR1);
+		}
+		ndelay(700);
+		scsptr1_data &= ~SCL;	/* SCL:L */
+		ctrl_outb(scsptr1_data, SCSPTR1);
+		ndelay(700);
+		scsptr1_data |= SCL;	/* SCL:H */
+		ctrl_outb(scsptr1_data, SCSPTR1);
+	}
+
+	scsptr1_data &= ~SDA_OEN;	/* SDA:output disable */
+	ctrl_outb(scsptr1_data, SCSPTR1);
+
+}
+
+static unsigned char rs5c313_read_data(void)
+{
+	int i;
+	unsigned char data = 0;
+
+	for (i = 0; i < 8; i++) {
+		ndelay(700);
+		/* SDA:Read Data */
+		data |= ((ctrl_inb(SCSPTR1) & SDA) >> 2) << (7 - i);
+		scsptr1_data &= ~SCL;	/* SCL:L */
+		ctrl_outb(scsptr1_data, SCSPTR1);
+		ndelay(700);
+		scsptr1_data |= SCL;	/* SCL:H */
+		ctrl_outb(scsptr1_data, SCSPTR1);
+	}
+	return data & 0x0F;
+}
+
+#endif  /* CONFIG_SH_LANDISK */
+
+
+/*****************************************************/
+/* machine independence part of RS5C313              */
+/*****************************************************/
+
+/* RICOH RS5C313 address */
+#define RS5C313_ADDR_SEC	0x00
+#define RS5C313_ADDR_SEC10	0x01
+#define RS5C313_ADDR_MIN	0x02
+#define RS5C313_ADDR_MIN10	0x03
+#define RS5C313_ADDR_HOUR	0x04
+#define RS5C313_ADDR_HOUR10	0x05
+#define RS5C313_ADDR_WEEK	0x06
+#define RS5C313_ADDR_INTINTVREG	0x07
+#define RS5C313_ADDR_DAY	0x08
+#define RS5C313_ADDR_DAY10	0x09
+#define RS5C313_ADDR_MON	0x0A
+#define RS5C313_ADDR_MON10	0x0B
+#define RS5C313_ADDR_YEAR	0x0C
+#define RS5C313_ADDR_YEAR10	0x0D
+#define RS5C313_ADDR_CNTREG	0x0E
+#define RS5C313_ADDR_TESTREG	0x0F
+
+/* RICOH RS5C313 control register */
+#define RS5C313_CNTREG_ADJ_BSY	0x01
+#define RS5C313_CNTREG_WTEN_XSTP	0x02
+#define RS5C313_CNTREG_12_24	0x04
+#define RS5C313_CNTREG_CTFG	0x08
+
+/* RICOH RS5C313 test register */
+#define RS5C313_TESTREG_TEST	0x01
+
+/* RICOH RS5C313 control bit */
+#define RS5C313_CNTBIT_READ	0x40
+#define RS5C313_CNTBIT_AD	0x20
+#define RS5C313_CNTBIT_DT	0x10
+
+static unsigned char rs5c313_read_reg(unsigned char addr)
+{
+
+	rs5c313_write(addr | RS5C313_CNTBIT_READ | RS5C313_CNTBIT_AD);
+	return rs5c313_read_data();
+
+}
+
+static void rs5c313_write_reg(unsigned char addr, unsigned char data)
+{
+        data &= 0x0f;
+	rs5c313_write(addr | RS5C313_CNTBIT_AD);
+	rs5c313_write(data | RS5C313_CNTBIT_DT);
+	return;
+}
+
+#define rs5c313_read_cntreg()       rs5c313_read_reg(RS5C313_ADDR_CNTREG)
+#define rs5c313_write_cntreg(data)  rs5c313_write_reg(RS5C313_ADDR_CNTREG,data)
+#define rs5c313_write_intintvreg(data) rs5c313_write_reg(RS5C313_ADDR_INTINTVREG,data)
+
+
+static void rs5c313_get_cur_time(unsigned char *sec, unsigned char *min,
+				 unsigned char *hr,
+				 unsigned char *day, unsigned char *mon,
+				 unsigned char *yr)
+{
+
+	while (1) {
+	        RS5C313_CEENABLE;	/* CE:H */
+
+		/* Initialize control reg. 24 hour */
+		rs5c313_write_cntreg(0x04);
+
+		if (!(rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY))
+			break;
+		RS5C313_MISCOP;
+		RS5C313_CEDISABLE;
+		ndelay(700);	/* CE:L */
+	}
+
+	*sec = rs5c313_read_reg(RS5C313_ADDR_SEC);
+	*sec |= (rs5c313_read_reg(RS5C313_ADDR_SEC10) << 4);
+
+	*min = rs5c313_read_reg(RS5C313_ADDR_MIN);
+	*min |= (rs5c313_read_reg(RS5C313_ADDR_MIN10) << 4);
+
+	*hr = rs5c313_read_reg(RS5C313_ADDR_HOUR);
+	*hr |= (rs5c313_read_reg(RS5C313_ADDR_HOUR10) << 4);
+
+	*day = rs5c313_read_reg(RS5C313_ADDR_DAY);
+	*day |= (rs5c313_read_reg(RS5C313_ADDR_DAY10) << 4);
+
+	*mon = rs5c313_read_reg(RS5C313_ADDR_MON);
+	*mon |= (rs5c313_read_reg(RS5C313_ADDR_MON10) << 4);
+
+	*yr = rs5c313_read_reg(RS5C313_ADDR_YEAR);
+	*yr |= (rs5c313_read_reg(RS5C313_ADDR_YEAR10) << 4);
+
+	RS5C313_CEDISABLE;
+	ndelay(700);		/* CE:L */
+
+}
+
+static void rs5c313_set_cur_time(unsigned char sec, unsigned char min,
+				 unsigned char hr,
+				 unsigned char day, unsigned char mon,
+				 unsigned char yr)
+{
+
+	/* bysy check. */
+	while (1) {
+	        RS5C313_CEENABLE;  /* CE:H */
+
+		/* Initialize control reg. 24 hour */
+		rs5c313_write_cntreg(0x04);
+
+		if (!(rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY))
+			break;
+		RS5C313_MISCOP;
+		RS5C313_CEDISABLE;
+		ndelay(700);	/* CE:L */
+	}
+
+	rs5c313_write_reg(RS5C313_ADDR_SEC, sec);
+	rs5c313_write_reg(RS5C313_ADDR_SEC10, (sec >> 4));
+
+	rs5c313_write_reg(RS5C313_ADDR_MIN, min);
+	rs5c313_write_reg(RS5C313_ADDR_MIN10, (min >> 4));
+
+	rs5c313_write_reg(RS5C313_ADDR_HOUR, hr);
+	rs5c313_write_reg(RS5C313_ADDR_HOUR10, (hr >> 4));
+
+	rs5c313_write_reg(RS5C313_ADDR_DAY, day);
+	rs5c313_write_reg(RS5C313_ADDR_DAY10,(day >> 4));
+
+	rs5c313_write_reg(RS5C313_ADDR_MON, mon);
+	rs5c313_write_reg(RS5C313_ADDR_MON10, (mon >> 4));
+
+	rs5c313_write_reg(RS5C313_ADDR_YEAR, yr);
+	rs5c313_write_reg(RS5C313_ADDR_YEAR10, (yr >> 4));
+
+	RS5C313_CEDISABLE;
+	ndelay(700);		/* CE:H */
+
+}
+
+unsigned long rs5c313_get_cmos_time(
+        unsigned int *BCD_yr,  unsigned int *BCD_mon,
+	unsigned int *BCD_day, unsigned int *BCD_hr,
+	unsigned int *BCD_min, unsigned int *BCD_sec)
+{
+
+	unsigned int sec128, sec, min, hr, day, mon, yr, yr100;
+	int clkstop = 0;
+
+	/* Set SCK as I/O port and Initialize SCSPTR1 data & I/O port. */
+	/* And Initialize SCL for RS5C313 clock */
+	rs5c313_initialize();
+
+      again:
+	/* check XSTP bit for clock stoped */
+	RS5C313_CEENABLE;	/* CE:H */
+	if (rs5c313_read_cntreg() & RS5C313_CNTREG_WTEN_XSTP) {
+		/* INT interval reg. OFF */
+		rs5c313_write_intintvreg(0x00);
+		/* Initialize control reg. 24 hour & adjust */
+		rs5c313_write_cntreg(0x07);
+		/* bysy check. */
+		while (rs5c313_read_cntreg() & RS5C313_CNTREG_ADJ_BSY)
+			RS5C313_MISCOP;
+		/* Initialize control reg. 24 hour */
+		rs5c313_write_cntreg(0x04);
+		clkstop = 1;
+	} else {
+		clkstop = 0;
+	}
+	RS5C313_CEDISABLE;
+	ndelay(700);		/* CE:L */
+
+	/* Get current time. */
+	sec = 0;
+	min = 0;
+	hr = 0;
+	day = 0;
+	mon = 0;
+	yr = 0;
+	rs5c313_get_cur_time((unsigned char *)&sec,
+			     (unsigned char *)&min, (unsigned char *)&hr,
+			     (unsigned char *)&day,
+			     (unsigned char *)&mon, (unsigned char *)&yr);
+
+	/* S-3531A count year from 2000 to 2099. */
+	yr100 = 0x20;
+	/* S-3531A can't get sec128. */
+	sec128 = 0;
+
+	*BCD_yr = yr;
+	*BCD_mon = mon;
+	*BCD_day = day;
+	*BCD_hr = hr;
+	*BCD_min = min;
+	*BCD_sec = sec;
+
+	yr100 = BCD2BIN(yr100);
+	yr    = BCD2BIN(yr);
+	mon   = BCD2BIN(mon);
+	day   = BCD2BIN(day);
+	hr    = BCD2BIN(hr);
+	min   = BCD2BIN(min);
+	sec   = BCD2BIN(sec);
+
+	if (yr > 99 || mon < 1 || mon > 12 || day > 31 || day < 1 ||
+	    hr > 23 || min > 59 || sec > 59 || clkstop) {
+		printk(KERN_ERR
+		       "RICHO RS5C313: invalid value, resetting to 1 Jan 2000\n");
+		/* Reset S-3531A set (20)00year/01month/01day  */
+		/*                    00hour 00minute 00second */
+		sec = 0;
+		min = 0;
+		hr  = 0;
+		day = 1;
+		mon = 1;
+		yr = 00;
+		rs5c313_set_cur_time((unsigned char)sec,
+				     (unsigned char)min, (unsigned char)hr,
+				     (unsigned char)day,
+				     (unsigned char)mon, (unsigned char)yr);
+
+		goto again;
+	}
+
+	return mktime(yr100 * 100 + yr, mon, day, hr, min, sec);
+}
+
+void rs5c313_set_cmos_time(unsigned int BCD_yr,  unsigned int BCD_mon,
+			   unsigned int BCD_day, unsigned int BCD_hr,
+			   unsigned int BCD_min, unsigned int BCD_sec)
+{
+
+	rs5c313_set_cur_time((unsigned char)BCD_sec,
+			     (unsigned char)BCD_min,
+			     (unsigned char)BCD_hr,
+			     (unsigned char)BCD_day,
+			     (unsigned char)BCD_mon, (unsigned char)BCD_yr);
+
+}
+
+/*****************************************************/
+/* machine independence part of RTC driver           */
+/*****************************************************/
+
+#define RTC_IO_EXTENT	0x8
+
+static struct fasync_struct *rtc_async_queue;
+static DECLARE_WAIT_QUEUE_HEAD(rtc_wait);
+static ssize_t rtc_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos);
+static int rtc_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg);
+static int rtc_proc_open(struct inode *inode, struct file *file);
+
+/*
+ *	Bits in rtc_status. (6 bits of room for future expansion)
+ */
+
+#define RTC_IS_OPEN		0x01	/* means /dev/rtc is in use	*/
+#define RTC_TIMER_ON		0x02	/* missed irq timer active	*/
+
+/*
+ * rtc_status is never changed by rtc_interrupt, and ioctl/open/close is
+ * protected by the big kernel lock. However, ioctl can still disable the timer
+ * in rtc_status and then with del_timer after the interrupt has read
+ * rtc_status but before mod_timer is called, which would then reenable the
+ * timer (but you would need to have an awful timing before you'd trip on it)
+ */
+static unsigned long rtc_status = 0;	/* bitmapped status byte.	*/
+static unsigned long rtc_freq = 0;	/* Current periodic IRQ rate	*/
+static unsigned long rtc_irq_data = 0;	/* our output to the world	*/
+static unsigned long rtc_max_user_freq = 64; /* > this, need CAP_SYS_RESOURCE */
+
+/*
+ *	If this driver ever becomes modularised, it will be really nice
+ *	to make the epoch retain its value across module reload...
+ */
+
+static unsigned long epoch = 1900;	/* year corresponding to 0x00	*/
+
+static const unsigned char days_in_mo[] =
+{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+/*
+ * sysctl-tuning infrastructure.
+ */
+static ctl_table rtc_table[] = {
+	{
+		.ctl_name	= 1,
+		.procname	= "max-user-freq",
+		.data		= &rtc_max_user_freq,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table rtc_root[] = {
+	{
+		.ctl_name	= 1,
+		.procname	= "rtc",
+		.maxlen		= 0,
+		.mode		= 0555,
+		.child		= rtc_table,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table dev_root[] = {
+	{
+		.ctl_name	= CTL_DEV,
+		.procname	= "dev",
+		.maxlen		= 0,
+		.mode		= 0555,
+		.child		= rtc_root,
+	},
+	{ .ctl_name = 0 }
+};
+
+static struct ctl_table_header *sysctl_header;
+
+static int __init init_sysctl(void)
+{
+    sysctl_header = register_sysctl_table(dev_root, 0);
+    return 0;
+}
+
+static void __exit cleanup_sysctl(void)
+{
+    unregister_sysctl_table(sysctl_header);
+}
+
+/*
+ *	Now all the various file operations that we export.
+ */
+
+static ssize_t rtc_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return -EIO;
+}
+
+static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
+{
+	struct rtc_time wtime;
+
+	switch (cmd) {
+	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
+	{
+		memset(&wtime, 0, sizeof(struct rtc_time));
+		rtc_get_rtc_time(&wtime);
+		break;
+	}
+	case RTC_SET_TIME:	/* Set the RTC */
+	{
+		struct rtc_time rtc_tm;
+		unsigned char mon, day, hrs, min, sec, leap_yr;
+		unsigned int yrs;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, (struct rtc_time __user *)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		yrs = rtc_tm.tm_year + 1900;
+		mon = rtc_tm.tm_mon + 1;   /* tm_mon starts at zero */
+		day = rtc_tm.tm_mday;
+		hrs = rtc_tm.tm_hour;
+		min = rtc_tm.tm_min;
+		sec = rtc_tm.tm_sec;
+
+		if (yrs < 1970)
+			return -EINVAL;
+
+		leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+
+		if ((mon > 12) || (day == 0))
+			return -EINVAL;
+
+		if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+			return -EINVAL;
+
+		if ((hrs >= 24) || (min >= 60) || (sec >= 60))
+			return -EINVAL;
+
+		if ((yrs -= epoch) > 255)    /* They are unsigned */
+			return -EINVAL;
+
+		/* These limits and adjustments are independent of
+		 * whether the chip is in binary mode or not.
+		 */
+		if (yrs > 169) {
+			return -EINVAL;
+		}
+		if (yrs >= 100)
+			yrs -= 100;
+
+		sec = BIN2BCD(sec);
+		min = BIN2BCD(min);
+		hrs = BIN2BCD(hrs);
+		day = BIN2BCD(day);
+		mon = BIN2BCD(mon);
+		yrs = BIN2BCD(yrs);
+
+		spin_lock_irq(&rtc_lock);
+		rs5c313_set_cmos_time(yrs, mon, day, hrs, min, sec);
+		spin_unlock_irq(&rtc_lock);
+
+		return 0;
+	}
+	case RTC_EPOCH_READ:	/* Read the epoch.	*/
+	{
+		return put_user (epoch, (unsigned long __user *)arg);
+	}
+	case RTC_EPOCH_SET:	/* Set the epoch.	*/
+	{
+		/*
+		 * There were no RTC clocks before 1900.
+		 */
+		if (arg < 1900)
+			return -EINVAL;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		epoch = arg;
+		return 0;
+	}
+	default:
+		return -ENOTTY;
+	}
+	return copy_to_user((void __user *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	return rtc_do_ioctl(cmd, arg, 0);
+}
+
+/*
+ *	We enforce only one user at a time here with the open/close.
+ *	Also clear the previous interrupt data on an open, and clean
+ *	up things on a close.
+ */
+
+/* We use rtc_lock to protect against concurrent opens. So the BKL is not
+ * needed here. Or anywhere else in this driver. */
+static int rtc_open(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&rtc_lock);
+
+	if(rtc_status & RTC_IS_OPEN)
+		goto out_busy;
+
+	rtc_status |= RTC_IS_OPEN;
+
+	rtc_irq_data = 0;
+	spin_unlock_irq (&rtc_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&rtc_lock);
+	return -EBUSY;
+}
+
+static int rtc_fasync (int fd, struct file *filp, int on)
+
+{
+	return fasync_helper (fd, filp, on, &rtc_async_queue);
+}
+
+static int rtc_release(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&rtc_lock);
+	rtc_irq_data = 0;
+	rtc_status &= ~RTC_IS_OPEN;
+	spin_unlock_irq (&rtc_lock);
+	return 0;
+}
+
+
+/*
+ * exported stuffs
+ */
+
+EXPORT_SYMBOL(rtc_register);
+EXPORT_SYMBOL(rtc_unregister);
+EXPORT_SYMBOL(rtc_control);
+
+int rtc_register(rtc_task_t *task)
+{
+	return -EIO;
+}
+
+int rtc_unregister(rtc_task_t *task)
+{
+	return -EIO;
+}
+
+int rtc_control(rtc_task_t *task, unsigned int cmd, unsigned long arg)
+{
+	return -EIO;
+}
+
+
+/*
+ *	The various file operations we support.
+ */
+
+static struct file_operations rtc_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= rtc_read,
+	.ioctl		= rtc_ioctl,
+	.open		= rtc_open,
+	.release	= rtc_release,
+	.fasync		= rtc_fasync,
+};
+
+static struct miscdevice rtc_dev = {
+	.minor		= RTC_MINOR,
+	.name		= "rtc",
+	.fops		= &rtc_fops,
+};
+
+static struct file_operations rtc_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtc_proc_open,
+	.read  = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+
+static int __init rtc_init(void)
+{
+	struct proc_dir_entry *ent;
+
+	if (!request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc")) {
+		printk(KERN_ERR "rtc: I/O port %d is not free.\n", RTC_PORT (0));
+		return -EIO;
+	}
+
+	if (misc_register(&rtc_dev)) {
+		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		return -ENODEV;
+	}
+
+	ent = create_proc_entry("driver/rtc", 0, NULL);
+	if (!ent) {
+		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		misc_deregister(&rtc_dev);
+		return -ENOMEM;
+	}
+	ent->proc_fops = &rtc_proc_fops;
+	(void) init_sysctl();
+
+	printk(KERN_INFO "RICHO RS5C313 Real Time Clock Driver v" RTC_VERSION "\n");
+
+	return 0;
+}
+
+static void __exit rtc_exit (void)
+{
+	cleanup_sysctl();
+	remove_proc_entry ("driver/rtc", NULL);
+	misc_deregister(&rtc_dev);
+	release_region (RTC_PORT (0), RTC_IO_EXTENT);
+}
+
+module_init(rtc_init);
+module_exit(rtc_exit);
+
+
+/*
+ *	Info exported via "/proc/driver/rtc".
+ */
+
+static int rtc_proc_show(struct seq_file *seq, void *v)
+{
+#define YN(bit) ((ctrl & bit) ? "yes" : "no")
+#define NY(bit) ((ctrl & bit) ? "no" : "yes")
+	struct rtc_time tm;
+	unsigned char batt, ctrl;
+	unsigned long freq;
+
+	batt = 1;
+	freq = rtc_freq;
+	ctrl = RTC_24H;
+
+	rtc_get_rtc_time(&tm);
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	seq_printf(seq,
+		   "rtc_time\t: %02d:%02d:%02d\n"
+		   "rtc_date\t: %04d-%02d-%02d\n"
+		   "rtc_epoch\t: %04lu\n",
+		   tm.tm_hour, tm.tm_min, tm.tm_sec,
+		   tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, epoch);
+
+	seq_puts(seq, "alarm\t\t: **:**:**\n");
+
+	seq_printf(seq,
+		   "DST_enable\t: %s\n"
+		   "BCD\t\t: %s\n"
+		   "24hr\t\t: %s\n"
+		   "square_wave\t: %s\n"
+		   "alarm_IRQ\t: %s\n"
+		   "update_IRQ\t: %s\n"
+		   "periodic_IRQ\t: %s\n"
+		   "periodic_freq\t: %ld\n"
+		   "batt_status\t: %s\n",
+		   YN(RTC_DST_EN),
+		   NY(RTC_DM_BINARY),
+		   YN(RTC_24H),
+		   YN(RTC_SQWE),
+		   YN(RTC_AIE),
+		   YN(RTC_UIE),
+		   YN(RTC_PIE),
+		   freq,
+		   batt ? "okay" : "dead");
+
+	return  0;
+#undef YN
+#undef NY
+}
+
+static int rtc_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtc_proc_show, NULL);
+}
+
+void rtc_get_rtc_time(struct rtc_time *rtc_tm)
+{
+	unsigned int BCD_yr, BCD_mon, BCD_day, BCD_hr, BCD_min, BCD_sec;
+
+	spin_lock_irq(&rtc_lock);
+	rs5c313_get_cmos_time(&BCD_yr, &BCD_mon, &BCD_day,
+			      &BCD_hr, &BCD_min, &BCD_sec);
+	spin_unlock_irq(&rtc_lock);
+
+	rtc_tm->tm_sec  = BCD2BIN(BCD_sec);
+	rtc_tm->tm_min  = BCD2BIN(BCD_min);
+	rtc_tm->tm_hour = BCD2BIN(BCD_hr);
+	rtc_tm->tm_mday = BCD2BIN(BCD_day);
+	rtc_tm->tm_mon  = BCD2BIN(BCD_mon);
+	rtc_tm->tm_year = BCD2BIN(BCD_yr);
+
+	/*
+	 * Account for differences between how the RTC uses the values
+	 * and how they are defined in a struct rtc_time;
+	 */
+	if ((rtc_tm->tm_year += (epoch - 1900)) <= 69)
+		rtc_tm->tm_year += 100;
+
+	rtc_tm->tm_mon--;
+}
+
+
+MODULE_AUTHOR("kogiidena");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(RTC_MINOR);
+
diff -Naur linux-2.6.17.8/drivers/char/rtc9701_rtc.c linux-2.6.17.8-sh/drivers/char/rtc9701_rtc.c
--- linux-2.6.17.8/drivers/char/rtc9701_rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/rtc9701_rtc.c	2006-08-23 13:29:10.346955000 +0100
@@ -0,0 +1,888 @@
+/*
+ * linux/drivers/char/rtc9701_rtc.c
+ *
+ * Real Time Clock interface for Linux
+ * EPSON RTC-9701JE support
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include <asm/io.h>
+#include <asm/rts7751r2d/rts7751r2d.h>
+
+#include <linux/rtc.h>
+
+/* define to 1 enable copious debugging info */
+#undef RTC9701_DEBUG
+#undef RTC9701_DEBUG_IO
+#undef RTC9701_DEBUG_INTR
+
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#define	DRIVER_VERSION	"0.02"
+
+#define RSECCNT	0x00	/* Second Counter */
+#define	RMINCNT	0x01	/* Minute Counter */
+#define	RHRCNT	0x02	/* Hour Counter */
+#define	RWKCNT	0x03	/* Week Counter */
+#define	RDAYCNT	0x04	/* Day Counter */
+#define	RMONCNT	0x05	/* Month Counter */
+#define	RYRCNT	0x06	/* Year Counter */
+#define R100CNT	0x07	/* Y100 Counter */
+#define	RMINAR	0x08	/* Minute Alarm */
+#define	RHRAR	0x09	/* Hour Alarm */
+#define	RWKAR	0x0a	/* Week/Day Alarm */
+#define	RTIMCNT	0x0c	/* Interval Timer */
+#define REXT	0x0d	/* Extension Register */
+#define	RFLAG	0x0e	/* RTC Flag Register */
+#define	RCR	0x0f	/* RTC Control Register */
+
+#define WRITE_CMD	0x00	/* Write Command */
+#define	READ_CMD	0x08	/* Read Command */
+
+#define SCSMR1	0xffe00000	/* Serial Mode Register(SCI) */
+#define SCSCR1	0xffe00008	/* Serial Control Register(SCI) */
+#define SCSPTR1	0xffe0001c	/* Serial Port Register(SCI) */
+
+static int rtc_usage;
+static int rtc_irq_data;
+
+static struct fasync_struct* rtc_async_queue;
+
+static DECLARE_WAIT_QUEUE_HEAD(rtc_wait);
+extern spinlock_t rtc_lock;
+static unsigned int epoch = 1900;      /* year corresponding to 0x00   */
+
+static const unsigned char days_in_mo[] =
+{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+static __inline__ unsigned char rtc9701_inb(unsigned long addr)
+{
+	unsigned char data, retval;
+	int i;
+
+	ctrl_outw(0x0001, PA_RTCCE);		/* CE=1 */
+	ndelay(170);				/* 170ns delay (tZR) */
+	ctrl_outb(0x8c, SCSPTR1);
+	for (i=0 ; i<18 ; i++)
+		if (ctrl_inb(SCSPTR1) & 0x01)	/* Check ready */
+			break;
+		else
+			mdelay(1);		/* 1ms delay */
+//#ifdef RTC9701_DEBUG_IO
+	if (i >= 18)
+		printk("RTC-9701JE Read Time out ready wait\n");
+//#endif
+	ndelay(65);				/* 65ns delay (tRDY) */
+
+	for (i=0 ; i<4 ; i++) {			/* Command Set */
+		if ((READ_CMD << i) & 0x08)
+			data = 0x8b;		/* DATA=1 */
+		else
+			data = 0x8a;		/* DATA=0 */
+		ctrl_outb(data, SCSPTR1);	/* CLK=0, DATA */
+		ndelay(250);			/* 250ns delay (tWL) */
+		data |= 0x04;
+		ctrl_outb(data, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+	for (i=0 ; i<4 ; i++) {			/* Address Set */
+		if ((addr << i) & 0x08)
+			data = 0x8b;		/* DATA=1 */
+		else
+			data = 0x8a;		/* DATA=0 */
+		ctrl_outb(data, SCSPTR1);	/* CLK=0, DATA */
+		ndelay(250);			/* 250ns delay (tWL) */
+		data |= 0x04;
+		ctrl_outb(data, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+#if 0
+	/* Dummy clock */
+	ctrl_outb(0x88, SCSPTR1);		/* CLK=0 */
+	ndelay(250);				/* 250ns delay (tWL) */
+	ctrl_inb(SCSPTR1);			/* Dummy read */
+	ctrl_outb(0x8c, SCSPTR1);		/* CLK=1 */
+	ndelay(250);				/* 250ns delay (tWH) */
+#endif
+
+	retval = 0;
+	for (i=0 ; i<8 ; i++) {			/* DATA Read */
+		ctrl_outb(0x88, SCSPTR1);	/* CLK=0 */
+#if 0
+		if (i == 0)
+			ndelay(200);		/* 200ns delay (tZR) */
+#endif
+		ndelay(250);			/* 250ns delay (tWL) */
+		retval <<= 1;
+		retval &= 0xfe;
+		if (ctrl_inb(SCSPTR1) & 0x01)
+			retval |= 0x01;
+		ctrl_outb(0x8c, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+	ctrl_outw(0x0000, PA_RTCCE);		/* CE=0 */
+#if 0
+	mdelay(1);				/* 1ms delay (tCR) */
+#endif
+
+#ifdef RTC9701_DEBUG_IO
+	printk("rtc9701_inb addr=%x value=%x\n", (unsigned int)addr, retval);
+#endif
+	return retval;
+}
+
+static __inline__ void rtc9701_outb(unsigned char b, unsigned long addr)
+{
+	int i;
+	unsigned char data;
+
+#ifdef RTC9701_DEBUG_IO
+	printk("rtc9701_outb addr=%x value=%x\n", (unsigned int)addr, b);
+#endif
+	ctrl_outw(0x0001, PA_RTCCE);		/* CE=1 */
+	ndelay(170);				/* 170ns delay (tZR) */
+	ctrl_outb(0x8c, SCSPTR1);
+	for (i=0 ; i<18 ; i++)
+		if (ctrl_inb(SCSPTR1) & 0x01)	/* Check ready */
+			break;
+		else
+			mdelay(1);		/* 1ms delay */
+//#ifdef RTC9701_DEBUG_IO
+	if (i >= 18)
+		printk("RTC-9701JE Write Time out ready wait\n");
+//#endif
+	ndelay(65);				/* 65ns delay (tRDY) */
+
+	for (i=0 ; i<4 ; i++) {			/* Command Set */
+		if ((WRITE_CMD << i) & 0x08)
+			data = 0x8b;		/* DATA=1 */
+		else
+			data = 0x8a;		/* DATA=0 */
+		ctrl_outb(data, SCSPTR1);	/* CLK=0, DATA */
+		ndelay(250);			/* 250ns delay (tWL) */
+		data |= 0x04;
+		ctrl_outb(data, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+	for (i=0 ; i<4 ; i++) {			/* Address Set */
+		if ((addr << i) & 0x08)
+			data = 0x8b;		/* DATA=1 */
+		else
+			data = 0x8a;		/* DATA=0 */
+		ctrl_outb(data, SCSPTR1);	/* CLK=0, DATA */
+		ndelay(250);			/* 250ns delay (tWL) */
+		data |= 0x04;
+		ctrl_outb(data, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+	for (i=0 ; i<8 ; i++) {			/* DATA Write */
+		if ((b << i ) & 0x80)
+			data = 0x8b;		/* DATA=1 */
+		else
+			data = 0x8a;		/* DATA=0 */
+		ctrl_outb(data, SCSPTR1);	/* CLK=0, DATA */
+		ndelay(250);			/* 250ns delay (tWL) */
+		data |= 0x04;
+		ctrl_outb(data, SCSPTR1);	/* CLK=1 */
+		ndelay(250);			/* 250ns delay (tWH) */
+	}
+
+	ctrl_outw(0x0000, PA_RTCCE);		/* CE=0 */
+#if 0
+	mdelay(1);				/* 1ms delay (tCR) */
+#endif
+}
+
+static irqreturn_t rtc9701_rtc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned char	wk;
+
+#ifdef RTC9701_DEBUG
+	printk("RTC-9701JE Interrupt irq=%d\n", irq);
+#endif
+	spin_lock(&rtc_lock);
+
+	if (irq == IRQ_RTCALM) {
+		wk = rtc9701_inb(RFLAG);
+#ifdef RTC9701_DEBUG_INTR
+		printk("RTC-9701JE Interrupt alarm flag=%02x\n", wk);
+#endif
+		if (wk & 0x08) {
+			wk &= 0xb6;
+			rtc9701_outb(wk, RFLAG);
+			rtc_irq_data = 1;
+		}
+	} else if (irq == IRQ_RTCTIME) {
+		wk = rtc9701_inb(RFLAG);
+#ifdef RTC9701_DEBUG_INTR
+		printk("RTC-9701JE Interrupt timer flag=%02x\n", wk);
+#endif
+		if (wk & 0x10) {	/* Interval timer */
+			wk &= 0xae;
+			rtc9701_outb(wk, RFLAG);
+			rtc_irq_data = 2;
+		}
+		if (wk & 0x20) {	/* Update time */
+			wk &= 0x9e;
+			rtc9701_outb(wk, RFLAG);
+			rtc_irq_data = 2;
+		}
+	}
+
+	spin_unlock(&rtc_lock);
+#if 0
+	mdelay(20);
+#endif
+	wake_up_interruptible(&rtc_wait);
+
+	kill_fasync(&rtc_async_queue, SIGIO, POLL_IN);
+
+	return IRQ_HANDLED;
+}
+
+static int rtc9701_rtc_open(struct inode *minode, struct file *mfile)
+{
+	if (rtc_usage != 0)
+		return -EBUSY;
+
+	rtc_usage = 1;
+
+        return 0;
+}
+
+static int rtc9701_rtc_release(struct inode *minode, struct file *mfile)
+{
+	rtc_usage = 0;
+
+        return 0;
+}
+
+static int rtc9701_rtc_fasync(int fd, struct file *filp, int on)
+{
+        return fasync_helper(fd, filp, on, &rtc_async_queue);
+}
+
+static loff_t rtc9701_rtc_llseek(struct file *file, loff_t offset, int origin)
+{
+        return -ESPIPE;
+}
+
+static ssize_t rtc9701_rtc_read(struct file* file,
+			      char*        buf,
+			      size_t       count,
+			      loff_t*      ppos)
+{
+        DECLARE_WAITQUEUE(wait, current);
+	unsigned long data = 1;
+        ssize_t retval;
+
+	if (count < sizeof(unsigned long))
+		return -EINVAL;
+
+	add_wait_queue(&rtc_wait, &wait);
+
+	current->state = TASK_INTERRUPTIBLE;
+
+	do {
+		spin_lock_irq (&rtc_lock);
+		data = rtc_irq_data;
+		spin_unlock_irq (&rtc_lock);
+
+		if (data != 0) {
+			rtc_irq_data = 0;
+			break;
+		}
+
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			goto out;
+		}
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			goto out;
+		}
+		schedule();
+	} while (1);
+
+	retval = put_user(data, (unsigned long *)buf);
+	if (!retval)
+		retval = sizeof(unsigned long);
+out:
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&rtc_wait, &wait);
+
+        return retval;
+}
+
+static void rtc_set_timer(unsigned long value)
+{
+	unsigned char time;
+
+	time = (unsigned char)value | 0x80;
+	rtc9701_outb(time, RTIMCNT);
+#ifdef RTC9701_DEBUG
+	time = rtc9701_inb(RTIMCNT);
+	printk("RTC-9701JE Set timer value=%x\n", time);
+#endif
+}
+
+static unsigned long rtc_read_timer(void)
+{
+	unsigned char time;
+
+	time = rtc9701_inb(RTIMCNT);
+#ifdef RTC9701_DEBUG
+	printk("RTC-9701JE Read timer value=%x\n", time);
+#endif
+	return (unsigned long)time;
+}
+
+static void control_periodic_irq(int mode)
+{
+	unsigned char wk;
+	unsigned char rcr;
+
+	if (mode == 0) {	/* OFF */
+		rcr	= rtc9701_inb(RCR);
+		wk	= rcr & 0x2e;
+		rtc9701_outb(wk, RCR);
+	} else {		/* ON */
+		rcr	= rtc9701_inb(RCR);
+		wk	= rcr | 0x10;
+		rtc9701_outb(wk, RCR);
+	}
+
+	rtc_irq_data = 0;
+}
+
+static void control_alarm_irq(int mode)
+{
+	unsigned char rcr;
+
+	if (mode == 0) {	/* AIE = OFF */
+		rcr = rtc9701_inb(RCR);
+		rcr &= 0x36;
+		rtc9701_outb(rcr, RCR);
+	} else {		/* AIE = ON */
+		rcr = rtc9701_inb(RCR);
+		rcr |= 0x08;
+		rtc9701_outb(rcr, RCR);
+	}
+
+	rtc_irq_data = 0;
+}
+
+static void get_rtc_data(struct rtc_time *tm)
+{
+	unsigned char wk;
+
+	tm->tm_sec	= 0;
+	tm->tm_min	= 0;
+	tm->tm_hour	= 0;
+	tm->tm_mday	= 0;
+	tm->tm_mon	= 0;
+	tm->tm_year	= 0;
+	tm->tm_wday	= 0;
+	tm->tm_yday	= 0;
+	tm->tm_isdst	= 0;
+
+	wk = rtc9701_inb(RSECCNT);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_sec	= wk;
+
+	wk = rtc9701_inb(RMINCNT);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_min	= wk;
+
+	wk = rtc9701_inb(RHRCNT);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_hour	= wk;
+
+	wk = rtc9701_inb(RWKCNT);
+	wk &= 0x7f;
+	tm->tm_wday	= wk - 1;
+
+	wk = rtc9701_inb(RDAYCNT);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_mday	= wk;
+
+	wk = rtc9701_inb(RMONCNT);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_mon	= wk - 1;
+
+	wk = rtc9701_inb(RYRCNT);
+	BCD_TO_BIN(wk);
+	tm->tm_year	= wk + 100;
+}
+
+static void get_rtc_alarm_data(struct rtc_time *tm)
+{
+	unsigned char wk;
+	unsigned char rflag, rcr;
+
+	tm->tm_sec	= 0;
+	tm->tm_min	= 0;
+	tm->tm_hour	= 0;
+	tm->tm_mday	= 0;
+	tm->tm_mon	= 0;
+	tm->tm_year	= 0;
+	tm->tm_wday	= 0;
+	tm->tm_yday	= 0;
+	tm->tm_isdst	= 0;
+
+	rflag = rtc9701_inb(RFLAG);
+	wk = rflag & 0xf7;
+	rtc9701_outb(wk, RFLAG);	/* AF=0 */
+	rcr = rtc9701_inb(RCR);
+	wk = rcr & 0xf7;
+	rtc9701_outb(wk, RCR);		/* AIE=0 */
+
+	wk = rtc9701_inb(RMINAR);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_min	= wk;
+
+	wk = rtc9701_inb(RHRAR);
+	wk &= 0x7f;
+	BCD_TO_BIN(wk);
+	tm->tm_hour	= wk;
+
+	rtc9701_outb(rflag, RFLAG);
+	rtc9701_outb(rcr, RCR);
+#ifdef RTC9701_DEBUG
+	printk("get_rtc_alarm_data: hour:%x min:%x\n", tm->tm_hour, tm->tm_min);
+#endif
+}
+
+static void set_rtc_data(struct rtc_time *tm)
+{
+	unsigned char sec, min, hour, mday, wday, mon, year;
+
+#ifdef RTC9701_DEBUG
+	printk("set_rtc_data:%d/%d/%d %d:%d:%d\n", tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+#endif
+	sec = tm->tm_sec;
+	min = tm->tm_min;
+	hour = tm->tm_hour;
+	mday = tm->tm_mday;
+	wday = tm->tm_wday;
+	mon = tm->tm_mon;
+
+	BIN_TO_BCD(sec);
+	rtc9701_outb(sec, RSECCNT);
+
+	BIN_TO_BCD(min);
+	rtc9701_outb(min, RMINCNT);
+
+	BIN_TO_BCD(hour);
+	rtc9701_outb(hour, RHRCNT);
+
+	rtc9701_outb(wday, RWKCNT);
+
+	BIN_TO_BCD(mday);
+	rtc9701_outb(mday, RDAYCNT);
+
+	BIN_TO_BCD(mon);
+	rtc9701_outb(mon, RMONCNT);
+
+	if (tm->tm_year > 100)
+		tm->tm_year -= 100;
+	year = tm->tm_year;
+	BIN_TO_BCD(year);
+	rtc9701_outb(year, RYRCNT);
+}
+
+static void set_rtc_alarm_data(struct rtc_time *tm)
+{
+	unsigned char wk;
+	unsigned char min, hour;
+
+#ifdef RTC9701_DEBUG
+	printk("set_rtc_alarm_data: hour:%x min:%x\n", tm->tm_hour, tm->tm_min);
+#endif
+	wk = rtc9701_inb(RFLAG);
+	wk &= 0xf7;
+	rtc9701_outb(wk, RFLAG);	/* AF=0 */
+	wk = rtc9701_inb(RCR);
+	wk &= 0xf7;
+	rtc9701_outb(wk, RCR);		/* AIE=0 */
+
+	min = tm->tm_min;
+	BIN_TO_BCD(min);
+	rtc9701_outb(min, RMINAR);
+
+	hour = tm->tm_hour;
+	BIN_TO_BCD(hour);
+	rtc9701_outb(hour, RHRAR);
+
+	wk = rtc9701_inb(RFLAG);
+	wk &= 0xf7;
+	rtc9701_outb(wk, RFLAG);	/* AF=0 */
+}
+
+static int rtc9701_rtc_ioctl(struct inode* inode,
+			   struct file*  file,
+			   unsigned int  cmd,
+			   unsigned long arg)
+{
+	struct rtc_time	wtime, rtc_tm;
+	unsigned char	mon, day, hrs, min, sec, week, leap_yr;
+	unsigned int	yrs;
+	unsigned long	value;
+
+	wtime.tm_sec	= 0;
+	wtime.tm_min	= 0;
+	wtime.tm_hour	= 0;
+	wtime.tm_mday	= 0;
+	wtime.tm_mon	= 0;
+	wtime.tm_year	= 0;
+	wtime.tm_wday	= 0;
+	wtime.tm_yday	= 0;
+	wtime.tm_isdst	= 0;
+
+	switch (cmd) {
+	case RTC_AIE_OFF:			/* =2:Alarm int. disable */
+		spin_lock_irq(&rtc_lock);
+		control_alarm_irq(0);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	case RTC_AIE_ON:			/* =1:Alarm int. enable */
+		spin_lock_irq(&rtc_lock);
+		control_alarm_irq(1);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	case RTC_PIE_OFF:			/* =6:Periodic int. disable */
+		spin_lock_irq(&rtc_lock);
+		control_periodic_irq(0);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	case RTC_PIE_ON:			/* =5:Periodic int. enable */
+		spin_lock_irq(&rtc_lock);
+		control_periodic_irq(1);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	case RTC_IRQP_SET:
+		if (copy_from_user(&value, (unsigned long *)arg, sizeof(value)))
+			return -EFAULT;
+		rtc_set_timer(value);
+		mdelay(20);
+		return 0;
+
+	case RTC_IRQP_READ:
+		value = rtc_read_timer();
+		mdelay(20);
+		return put_user(value, (unsigned long *)arg);
+
+	case RTC_ALM_READ:			/* =8:Read alarm time */
+		get_rtc_alarm_data(&wtime);
+		mdelay(20);
+		break;
+
+	case RTC_ALM_SET:			/* =7:Set alarm time */
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg,
+                                   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		hrs = rtc_tm.tm_hour;
+		min = rtc_tm.tm_min;
+
+		if ((hrs >= 24) || (min >= 60)) {
+			return -EINVAL;
+		}
+
+		/* update the alarm register */
+		spin_lock_irq(&rtc_lock);
+		wtime.tm_min	= min;
+		wtime.tm_hour	= hrs;
+		set_rtc_alarm_data(&wtime);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	case RTC_RD_TIME:			/* =9:Read RTC time */
+		spin_lock_irq(&rtc_lock);
+		get_rtc_data(&wtime);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		break;
+
+	case RTC_SET_TIME:			/* =10:Set RTC time */
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg,
+                                   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		yrs = rtc_tm.tm_year + epoch;
+		mon = rtc_tm.tm_mon+1;
+		day = rtc_tm.tm_mday;
+		hrs = rtc_tm.tm_hour;
+		min = rtc_tm.tm_min;
+		sec = rtc_tm.tm_sec;
+		week = rtc_tm.tm_wday+1;
+
+		if (yrs < epoch){
+			return -EINVAL;
+		}
+		leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+		if ((mon > 12) || (day == 0)){
+			return -EINVAL;
+		}
+		if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr))){
+			return -EINVAL;
+		}
+		if ((hrs >= 24) || (min >= 60) || (sec >= 60) || (week > 64)){
+			return -EINVAL;
+		}
+		if ((yrs - epoch) > 255){
+			return -EINVAL;
+		}
+
+		spin_lock_irq(&rtc_lock);
+		wtime.tm_sec	= sec;
+		wtime.tm_min	= min;
+		wtime.tm_hour	= hrs;
+		wtime.tm_mday	= day;
+		wtime.tm_mon	= mon;
+		wtime.tm_wday	= week;
+		wtime.tm_year	= yrs - epoch;
+		set_rtc_data(&wtime);
+		spin_unlock_irq(&rtc_lock);
+		mdelay(20);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+
+        return copy_to_user((void*)arg, &wtime, sizeof(wtime)) ? -EFAULT : 0;
+}
+
+static unsigned int rtc9701_rtc_poll(struct file* file, poll_table* wait)
+{
+	unsigned long l;
+
+	poll_wait(file, &rtc_wait, wait);
+
+	spin_lock_irq(&rtc_lock);
+	l = rtc_irq_data;
+	spin_unlock_irq(&rtc_lock);
+
+	if (l != 0)
+		return POLLIN | POLLRDNORM;
+	else
+        	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static int rtc9701_rtc_proc_output(char *buf)
+{
+        char		*p;
+        struct rtc_time	tm;
+
+	get_rtc_data(&tm);
+	mdelay(20);
+
+	p = buf;
+	p += sprintf(p,
+                     "rtc_time\t: %02d:%02d:%02d\n"
+                     "rtc_date\t: %04d-%02d-%02d\n"
+                     "rtc_epoch\t: %04lu\n",
+                     tm.tm_hour, tm.tm_min, tm.tm_sec,
+                     tm.tm_year + epoch, tm.tm_mon+1, tm.tm_mday,
+		     (unsigned long)epoch);
+
+	get_rtc_alarm_data(&tm);
+	mdelay(20);
+
+	p += sprintf(p,
+		     "alrm_time\t: %02d:%02d\n",
+                     tm.tm_hour, tm.tm_min);
+
+	p += sprintf(p,"alarm_IRQ\t: %s\n",
+		     (rtc9701_inb(RCR) & 0x08) ? "yes" : "no" );
+	mdelay(20);
+	p += sprintf(p,"periodic_IRQ\t: %s\n",
+		     (rtc9701_inb(RCR) & 0x10) ? "yes" : "no" );
+	mdelay(20);
+
+	p += sprintf(p,"periodic_freq\t: 1\n");
+	p += sprintf(p,"batt_status\t: unsupported\n");
+
+        return (p - buf);
+}
+
+static int rtc9701_rtc_read_proc(char*  page,
+			       char** start,
+			       off_t  off,
+			       int    count,
+			       int*   eof,
+			       void*  data)
+{
+        int len = rtc9701_rtc_proc_output(page);
+
+	if (len <= off + count) { *eof = 1; }
+	*start = page + off;
+	len -= off;
+	if (len > count) { len = count; }
+	if (len < 0)     { len = 0; }
+
+        return len;
+}
+
+#endif
+
+static void rtc9701_initial_check(void)
+{
+	unsigned int sec, min, hr, day, mon, yr;
+
+	sec = rtc9701_inb(RSECCNT) & 0x7f;
+	min = rtc9701_inb(RMINCNT) & 0x7f;
+	hr  = rtc9701_inb(RHRCNT) & 0x7f;
+	day = rtc9701_inb(RDAYCNT) & 0x7f;
+	mon = rtc9701_inb(RMONCNT) & 0x7f;
+	yr  = rtc9701_inb(RYRCNT) & 0x7f;
+
+	BCD_TO_BIN(sec);
+	BCD_TO_BIN(min);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(day);
+	BCD_TO_BIN(mon);
+	BCD_TO_BIN(yr);
+
+	if (yr > 99 || mon < 1 || mon > 12 || day > 31 || day < 1 ||
+	    hr > 23 || min > 59 || sec > 59) {
+		printk("Current RTC Time:%d-%d-%d %d:%d:%d\n", yr, mon, day, hr, min, sec);
+		printk(KERN_ERR "RTC-9701: invalid value, resetting to 1 Jan 2000\n");
+		rtc9701_outb(0, RSECCNT);
+		rtc9701_outb(0, RMINCNT);
+		rtc9701_outb(0, RHRCNT);
+		rtc9701_outb(0x40, RWKCNT);
+		rtc9701_outb(1, RDAYCNT);
+		rtc9701_outb(1, RMONCNT);
+		rtc9701_outb(0, RYRCNT);
+	}
+}
+
+static struct file_operations rtc_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= rtc9701_rtc_llseek,
+	.read		= rtc9701_rtc_read,
+	.poll		= rtc9701_rtc_poll,
+	.ioctl		= rtc9701_rtc_ioctl,
+	.open		= rtc9701_rtc_open,
+	.release	= rtc9701_rtc_release,
+	.fasync		= rtc9701_rtc_fasync,
+};
+
+
+static struct miscdevice rts7751r2drtc_miscdev = {
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+static void rtc9701_rtc_exit(void)
+{
+	spin_lock_irq(&rtc_lock);
+	rtc9701_outb(0x00, RCR);
+	spin_unlock_irq(&rtc_lock);
+	mdelay(20);
+
+	free_irq(IRQ_RTCALM, NULL);
+	free_irq(IRQ_RTCTIME, NULL);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("driver/rtc", NULL);
+#endif
+
+	misc_deregister(&rts7751r2drtc_miscdev);
+}
+
+static int __init rtc9701_rtc_init(void)
+{
+	unsigned char val;
+
+	misc_register(&rts7751r2drtc_miscdev);
+
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry("driver/rtc", 0, 0, rtc9701_rtc_read_proc, NULL);
+#endif
+	ctrl_outb((ctrl_inb(SCSMR1) & 0x7f), SCSMR1);
+	ctrl_outb((ctrl_inb(SCSCR1) & 0x9c), SCSCR1);
+	ctrl_outw(0x0000, PA_RTCCE);	/* CE=0 */
+	ctrl_outb(0x8c, SCSPTR1);	/* EIO=1, SPB1IO=1, SPB1DT=1, SPB0IO=0 */
+
+	rtc9701_initial_check();	/* RTC Data Initial check */
+	mdelay(20);
+
+	rtc9701_outb(0x02, REXT);	/* WADA=0, UDUTY=0, USEL=0, TSEL1=1, TSEL0=0 */
+	mdelay(20);
+	rtc9701_outb(0x00, RCR);	/* UIE=0, TIE=0, AIE=0, EXIE=0, VLIE=0 */
+	mdelay(20);
+	rtc9701_outb(0x00, RFLAG);
+	mdelay(20);
+#if 0
+	val = rtc9701_inb(REXT);
+	val &= 0x33;
+	rtc9701_outb(val, REXT);	/* WADA=0 */
+#endif
+	val = 0xff;
+	rtc9701_outb(val, RWKAR);
+	mdelay(20);
+
+	rtc9701_outb(0x00, RTIMCNT);
+	mdelay(20);
+
+	if (request_irq(IRQ_RTCALM, rtc9701_rtc_interrupt, SA_INTERRUPT, "rtc_alarm", NULL)) {
+		printk(KERN_ERR "rtc: IRQ %d already in use.\n", IRQ_RTCALM);
+		return -EIO;
+	}
+
+	if (request_irq(IRQ_RTCTIME, rtc9701_rtc_interrupt, SA_INTERRUPT, "rtc_timer", NULL)) {
+		printk(KERN_ERR "rtc: IRQ %d already in use.\n", IRQ_RTCTIME);
+		return -EIO;
+	}
+
+	printk(KERN_INFO "RTC-9701JE Real Time Clock Driver v" DRIVER_VERSION "\n");
+
+        return 0;
+}
+
+module_init(rtc9701_rtc_init);
+module_exit(rtc9701_rtc_exit);
diff -Naur linux-2.6.17.8/drivers/char/rtc.c linux-2.6.17.8-sh/drivers/char/rtc.c
--- linux-2.6.17.8/drivers/char/rtc.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/rtc.c	2006-08-23 13:29:07.579888000 +0100
@@ -104,7 +104,7 @@
 #endif
 
 #ifdef RTC_IRQ
-static int rtc_has_irq = 1;
+static int rtc_has_irq = RTC_IRQ;
 #endif
 
 #ifndef CONFIG_HPET_EMULATE_RTC
diff -Naur linux-2.6.17.8/drivers/char/sh03rtc.c linux-2.6.17.8-sh/drivers/char/sh03rtc.c
--- linux-2.6.17.8/drivers/char/sh03rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/sh03rtc.c	2006-08-23 13:29:21.394208000 +0100
@@ -0,0 +1,1184 @@
+/*
+ *	Real Time Clock interface for Linux
+ *
+ *	Copyright (C) 2004 Interface Corporation Saito.K
+ *
+ *	Based on skelrton from the drivers/char/rtc.c
+ *
+ *	This driver allows use of the real time clock (built into
+ *	nearly all computers) from user space. It exports the /dev/rtc
+ *	interface supporting various ioctl() and also the
+ *	/proc/driver/rtc pseudo-file for status information.
+ *
+ *	The ioctls can be used to set the interrupt behaviour and
+ *	generation rate from the RTC via IRQ 8. Then the /dev/rtc
+ *	interface can be used to make use of these timer interrupts,
+ *	be they interval or alarm based.
+ *
+ *	The /dev/rtc interface will block on reads until an interrupt
+ *	has been received. If a RTC interrupt has already happened,
+ *	it will output an unsigned long and then block. The output value
+ *	contains the interrupt status in the low byte and the number of
+ *	interrupts since the last read in the remaining high bytes. The
+ *	/dev/rtc interface can also be used with the select(2) call.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Based on other minimal char device drivers, like Alan's
+ *	watchdog, Ted's random, etc. etc.
+ *
+ *	1.07	Paul Gortmaker.
+ *	1.08	Miquel van Smoorenburg: disallow certain things on the
+ *		DEC Alpha as the CMOS clock is also used for other things.
+ *	1.09	Nikita Schmidt: epoch support and some Alpha cleanup.
+ *	1.09a	Pete Zaitcev: Sun SPARC
+ *	1.09b	Jeff Garzik: Modularize, init cleanup
+ *	1.09c	Jeff Garzik: SMP cleanup
+ *	1.10    Paul Barton-Davis: add support for async I/O
+ *	1.10a	Andrea Arcangeli: Alpha updates
+ *	1.10b	Andrew Morton: SMP lock fix
+ *	1.10c	Cesar Barros: SMP locking fixes and cleanup
+ *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit
+ *	1.10e	Maciej W. Rozycki: Handle DECstation's year weirdness.
+ *      1.11    Takashi Iwai: Kernel access functions
+ *			      rtc_register/rtc_unregister/rtc_control
+ *      1.11a   Daniele Bellucci: Audit create_proc_read_entry in rtc_init
+ *	1.12	Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
+ *		CONFIG_HPET_EMULATE_RTC
+ *
+ */
+
+#define SH03_RTC_VERSION	"0.09"
+
+#define RTC_IO_EXTENT	0x8
+
+/*
+ *	Note that *all* calls to CMOS_READ and CMOS_WRITE are done with
+ *	interrupts disabled. Due to the index-port/data-port (0x70/0x71)
+ *	design of the RTC, we don't want two different things trying to
+ *	get to it at once. (e.g. the periodic 11 min sync from time.c vs.
+ *	this driver.)
+ */
+
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+
+// @@@@@ 16.09.29 #include <linux/mc146818rtc.h>
+#include <linux/rtc.h>
+
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/sysctl.h>
+#include <linux/wait.h>
+#include <linux/bcd.h>
+
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+extern spinlock_t	rtc_lock;
+
+/*
+TODO: Timer
+*/
+#define	SH03_RTC_IRQ	11
+
+#define RTC_BASE	0xb0000000
+#define RTC_SEC1	(RTC_BASE + 0)
+#define RTC_SEC10	(RTC_BASE + 1)
+#define RTC_MIN1	(RTC_BASE + 2)
+#define RTC_MIN10	(RTC_BASE + 3)
+#define RTC_HOU1	(RTC_BASE + 4)
+#define RTC_HOU10	(RTC_BASE + 5)
+#define RTC_WEE1	(RTC_BASE + 6)
+#define RTC_DAY1	(RTC_BASE + 7)
+#define RTC_DAY10	(RTC_BASE + 8)
+#define RTC_MON1	(RTC_BASE + 9)
+#define RTC_MON10	(RTC_BASE + 10)
+#define RTC_YEA1	(RTC_BASE + 11)
+#define RTC_YEA10	(RTC_BASE + 12)
+#define RTC_YEA100	(RTC_BASE + 13)
+#define RTC_YEA1000	(RTC_BASE + 14)
+#define RTC_CTL		(RTC_BASE + 15)
+#define RTC_BUSY	1
+#define RTC_STOP	2
+#define RTC_BANK0	(0 << 2)
+#define RTC_BANK1	(1 << 2)
+#define RTC_BANK2	(2 << 2)
+
+#define RTC_ATCTL	(RTC_BASE + 14)
+#define RTC_AIE		1
+#define RTC_AF		2
+
+#define RTC_TE_CLOCK	(RTC_BASE +  8)
+#define RTC_TMCTL	(RTC_BASE + 14)
+#define RTC_TIE		1
+#define RTC_TF		2
+
+#define SH03_RTC_PORT(n)	((RTC_BASE) + n)
+#define SH03_RTC_IO_EXTENT	0x10
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val)	((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#define SELECT_BANK(n)	ctrl_outb((n), RTC_CTL)
+
+#define READ_SECONDS	((ctrl_inb(RTC_SEC1) & 15) + (ctrl_inb(RTC_SEC10) &  7) * 10)
+#define READ_MINUTES	((ctrl_inb(RTC_MIN1) & 15) + (ctrl_inb(RTC_MIN10) &  7) * 10)
+#define READ_HOURS	((ctrl_inb(RTC_HOU1) & 15) + (ctrl_inb(RTC_HOU10) &  3) * 10)
+#define READ_WEEK	 (ctrl_inb(RTC_WEE1) &  7)
+#define READ_DAY	((ctrl_inb(RTC_DAY1) & 15) + (ctrl_inb(RTC_DAY10) &  3) * 10)
+#define READ_MONTH	((ctrl_inb(RTC_MON1) & 15) + (ctrl_inb(RTC_MON10) &  1) * 10)
+#define READ_YEAR	((ctrl_inb(RTC_YEA1) & 15) + (ctrl_inb(RTC_YEA10) & 15) * 10 \
+		       + (ctrl_inb(RTC_YEA100) & 15) * 100 + (ctrl_inb(RTC_YEA1000) & 3) * 1000)
+
+#define WRITE_SECONDS(d)	ctrl_outb((d) & 15, RTC_SEC1); ctrl_outb((d) >> 4, RTC_SEC10)
+#define WRITE_MINUTES(d)	ctrl_outb((d) & 15, RTC_MIN1); ctrl_outb((d) >> 4, RTC_MIN10)
+#define WRITE_HOURS(d)		ctrl_outb((d) & 15, RTC_HOU1); ctrl_outb((d) >> 4, RTC_HOU10)
+#define WRITE_WEEK(d)		ctrl_outb((d) & 15, RTC_WEE1)
+#define WRITE_DAY(d)		ctrl_outb((d) & 15, RTC_DAY1); ctrl_outb((d) >> 4, RTC_DAY10)
+#define WRITE_MONTH(d)		ctrl_outb((d) & 15, RTC_MON1); ctrl_outb((d) >> 4, RTC_MON10)
+#define WRITE_YEAR_LOW(d)	ctrl_outb((d) & 15, RTC_YEA1); ctrl_outb((d) >> 4, RTC_YEA10)
+#define WRITE_YEAR_HIGH(d)	ctrl_outb((d) & 15, RTC_YEA100); ctrl_outb((d) >> 4, RTC_YEA1000)
+
+#define READ_ATCTL		(ctrl_inb(RTC_ATCTL))
+#define WRITE_ATCTL(d)		ctrl_outb((d), RTC_ATCTL)
+
+#define READ_TMCTL		(ctrl_inb(RTC_TMCTL))
+#define WRITE_TMCTL(d)		ctrl_outb((d), RTC_TMCTL)
+
+#define READ_CLOCK		(ctrl_inb(RTC_TE_CLOCK))
+#define WRITE_CLOCK(d)		ctrl_outb((d) & 15, RTC_TE_CLOCK)
+
+
+
+#ifdef SH03_RTC_IRQ
+static int sh03_rtc_has_irq = SH03_RTC_IRQ;
+#endif
+
+/*
+ *	We sponge a minor off of the misc major. No need slurping
+ *	up another valuable major dev number for this. If you add
+ *	an ioctl, make sure you don't conflict with SPARC's RTC
+ *	ioctls.
+ */
+
+static struct fasync_struct *sh03_rtc_async_queue;
+
+static DECLARE_WAIT_QUEUE_HEAD(sh03_rtc_wait);
+
+#ifdef SH03_RTC_IRQ
+static struct timer_list sh03_rtc_irq_timer;
+#endif
+
+static ssize_t sh03_rtc_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos);
+
+static int sh03_rtc_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg);
+
+#ifdef SH03_RTC_IRQ
+static unsigned int sh03_rtc_poll(struct file *file, poll_table *wait);
+#endif
+
+void sh03_rtc_get_rtc_time(struct rtc_time *rtc_tm);
+static void sh03_get_rtc_alm_time (struct rtc_time *alm_tm);
+#ifdef SH03_RTC_IRQ
+static void sh03_rtc_dropped_irq(unsigned long data);
+
+static void sh03_set_rtc_irq_bit(unsigned int bit);
+static void sh03_mask_rtc_irq_bit(unsigned int bit);
+#endif
+
+static int sh03_rtc_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data);
+
+/*
+ *	Bits in rtc_status. (6 bits of room for future expansion)
+ */
+
+#define RTC_IS_OPEN		0x01	/* means /dev/rtc is in use	*/
+#define RTC_TIMER_ON		0x02	/* missed irq timer active	*/
+
+/*
+ * rtc_status is never changed by rtc_interrupt, and ioctl/open/close is
+ * protected by the big kernel lock. However, ioctl can still disable the timer
+ * in rtc_status and then with del_timer after the interrupt has read
+ * rtc_status but before mod_timer is called, which would then reenable the
+ * timer (but you would need to have an awful timing before you'd trip on it)
+ */
+static unsigned long rtc_status = 0;	/* bitmapped status byte.	*/
+static unsigned long rtc_freq = 0;	/* Current periodic IRQ rate	*/
+static unsigned long rtc_irq_data = 0;	/* our output to the world	*/
+static unsigned long rtc_max_user_freq = 64; /* > this, need CAP_SYS_RESOURCE */
+
+#ifdef SH03_RTC_IRQ
+/*
+ * rtc_task_lock nests inside rtc_lock.
+ */
+static spinlock_t rtc_task_lock = SPIN_LOCK_UNLOCKED;
+static rtc_task_t *rtc_callback = NULL;
+#endif
+
+/*
+ *	If this driver ever becomes modularised, it will be really nice
+ *	to make the epoch retain its value across module reload...
+ */
+
+static unsigned long epoch = 1900;	/* year corresponding to 0x00	*/
+
+static const unsigned char days_in_mo[] =
+{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+#if 0 /* @@@@@ 16.09.29 TODO */
+/*
+ * Returns true if a clock update is in progress
+ */
+static inline unsigned char rtc_is_updating(void)
+{
+	unsigned char uip;
+
+	spin_lock_irq(&rtc_lock);
+	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
+	spin_unlock_irq(&rtc_lock);
+	return uip;
+}
+#endif
+
+#ifdef SH03_RTC_IRQ
+/*
+ *	A very tiny interrupt handler. It runs with SA_INTERRUPT set,
+ *	but there is possibility of conflicting with the set_rtc_mmss()
+ *	call (the rtc irq and the timer irq can easily run at the same
+ *	time in two different CPUs). So we need to serialize
+ *	accesses to the chip with the rtc_lock spinlock that each
+ *	architecture should implement in the timer code.
+ *	(See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)
+ */
+
+irqreturn_t sh03_rtc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/*
+	 *	Can be an alarm interrupt, update complete interrupt,
+	 *	or a periodic interrupt. We store the status in the
+	 *	low byte and the number of interrupts received since
+	 *	the last read in the remainder of rtc_irq_data.
+	 */
+
+	spin_lock (&rtc_lock);
+	rtc_irq_data += 0x100;
+	rtc_irq_data &= ~0xff;
+	SELECT_BANK(RTC_BANK1);
+	rtc_irq_data |= (READ_ATCTL & RTC_AF) >> 1;
+	WRITE_ATCTL(READ_ATCTL & ~ RTC_AF);
+	SELECT_BANK(RTC_BANK2);
+	rtc_irq_data |= (READ_TMCTL & RTC_TF);
+	WRITE_TMCTL(READ_TMCTL & ~ RTC_TF);
+	SELECT_BANK(RTC_BANK0);
+
+	if (rtc_status & RTC_TIMER_ON)
+		mod_timer(&sh03_rtc_irq_timer, jiffies + HZ/rtc_freq + 2*HZ/100);
+
+	spin_unlock (&rtc_lock);
+
+	/* Now do the rest of the actions */
+	spin_lock(&rtc_task_lock);
+	if (rtc_callback)
+		rtc_callback->func(rtc_callback->private_data);
+	spin_unlock(&rtc_task_lock);
+	wake_up_interruptible(&sh03_rtc_wait);
+
+	kill_fasync (&sh03_rtc_async_queue, SIGIO, POLL_IN);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*
+ * sysctl-tuning infrastructure.
+ */
+static ctl_table rtc_table[] = {
+	{
+		.ctl_name	= 1,
+		.procname	= "max-user-freq",
+		.data		= &rtc_max_user_freq,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table rtc_root[] = {
+	{
+		.ctl_name	= 1,
+		.procname	= "rtc",
+		.maxlen		= 0,
+		.mode		= 0555,
+		.child		= rtc_table,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table dev_root[] = {
+	{
+		.ctl_name	= CTL_DEV,
+		.procname	= "dev",
+		.maxlen		= 0,
+		.mode		= 0555,
+		.child		= rtc_root,
+	},
+	{ .ctl_name = 0 }
+};
+
+static struct ctl_table_header *sysctl_header;
+
+static int __init init_sysctl(void)
+{
+    sysctl_header = register_sysctl_table(dev_root, 0);
+    return 0;
+}
+
+static void __exit cleanup_sysctl(void)
+{
+    unregister_sysctl_table(sysctl_header);
+}
+
+/*
+ *	Now all the various file operations that we export.
+ */
+
+static ssize_t sh03_rtc_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+#ifndef SH03_RTC_IRQ
+	return -EIO;
+#else
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long data;
+	ssize_t retval;
+
+	if (sh03_rtc_has_irq == 0)
+		return -EIO;
+
+	if (count < sizeof(unsigned))
+		return -EINVAL;
+
+	add_wait_queue(&sh03_rtc_wait, &wait);
+
+	do {
+		/* First make it right. Then make it fast. Putting this whole
+		 * block within the parentheses of a while would be too
+		 * confusing. And no, xchg() is not the answer. */
+
+		__set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq (&rtc_lock);
+		data = rtc_irq_data;
+		rtc_irq_data = 0;
+		spin_unlock_irq (&rtc_lock);
+
+		if (data != 0)
+			break;
+
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			goto out;
+		}
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			goto out;
+		}
+		schedule();
+	} while (1);
+
+	if (count < sizeof(unsigned long))
+		retval = put_user(data, (unsigned int __user *)buf) ?: sizeof(int);
+	else
+		retval = put_user(data, (unsigned long __user *)buf) ?: sizeof(long);
+ out:
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&sh03_rtc_wait, &wait);
+
+	return retval;
+#endif
+}
+
+static int sh03_rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
+{
+	struct rtc_time wtime;
+
+#ifdef SH03_RTC_IRQ
+	if (sh03_rtc_has_irq == 0) {
+		switch (cmd) {
+		case RTC_AIE_OFF:
+		case RTC_AIE_ON:
+		case RTC_PIE_OFF:
+		case RTC_PIE_ON:
+		case RTC_UIE_OFF:
+		case RTC_UIE_ON:
+		case RTC_IRQP_READ:
+		case RTC_IRQP_SET:
+			return -EINVAL;
+		};
+	}
+#endif
+
+	switch (cmd) {
+#ifdef SH03_RTC_IRQ
+	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit	*/
+	{
+		sh03_mask_rtc_irq_bit(RTC_AIE);
+		return 0;
+	}
+	case RTC_AIE_ON:	/* Allow alarm interrupts.	*/
+	{
+		sh03_set_rtc_irq_bit(RTC_AIE);
+		return 0;
+	}
+	case RTC_PIE_OFF:	/* Mask periodic int. enab. bit	*/
+	{
+		sh03_mask_rtc_irq_bit(RTC_PIE_OFF);
+		if (rtc_status & RTC_TIMER_ON) {
+			spin_lock_irq (&rtc_lock);
+			rtc_status &= ~RTC_TIMER_ON;
+			del_timer(&sh03_rtc_irq_timer);
+			spin_unlock_irq (&rtc_lock);
+		}
+		return 0;
+	}
+	case RTC_PIE_ON:	/* Allow periodic ints		*/
+	{
+
+		/*
+		 * We don't really want Joe User enabling more
+		 * than 64Hz of interrupts on a multi-user machine.
+		 */
+		if (!kernel && (rtc_freq > rtc_max_user_freq) &&
+			(!capable(CAP_SYS_RESOURCE)))
+			return -EACCES;
+
+		if (!(rtc_status & RTC_TIMER_ON)) {
+			spin_lock_irq (&rtc_lock);
+			sh03_rtc_irq_timer.expires = jiffies + HZ/rtc_freq + 2*HZ/100;
+			add_timer(&sh03_rtc_irq_timer);
+			rtc_status |= RTC_TIMER_ON;
+			spin_unlock_irq (&rtc_lock);
+		}
+		sh03_set_rtc_irq_bit(RTC_PIE_ON);
+		return 0;
+	}
+#if 1 /* @@@@@ 16.09.29 TODO */
+	case RTC_UIE_OFF:	/* Mask ints from RTC updates.	*/
+	case RTC_UIE_ON:	/* Allow ints for RTC updates.	*/
+		return -EINVAL;
+#else
+	case RTC_UIE_OFF:	/* Mask ints from RTC updates.	*/
+	{
+		sh03_mask_rtc_irq_bit(RTC_UIE);
+		return 0;
+	}
+	case RTC_UIE_ON:	/* Allow ints for RTC updates.	*/
+	{
+		sh03_set_rtc_irq_bit(RTC_UIE);
+		return 0;
+	}
+#endif
+#endif
+	case RTC_ALM_READ:	/* Read the present alarm time */
+	{
+		/*
+		 * This returns a struct rtc_time. Reading >= 0xc0
+		 * means "don't care" or "match all". Only the tm_hour,
+		 * tm_min, and tm_sec values are filled in.
+		 */
+		memset(&wtime, 0, sizeof(struct rtc_time));
+		sh03_get_rtc_alm_time(&wtime);
+		break;
+	}
+	case RTC_ALM_SET:	/* Store a time into the alarm */
+	{
+		/*
+		 * This expects a struct rtc_time. Writing 0xff means
+		 * "don't care" or "match all". Only the tm_hour,
+		 * tm_min and tm_sec are used.
+		 */
+		unsigned char day, week, hrs, min, sec;
+		struct rtc_time alm_tm;
+
+		if (copy_from_user(&alm_tm, (struct rtc_time __user *)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		day  = alm_tm.tm_mday;
+		week = alm_tm.tm_wday;
+		hrs  = alm_tm.tm_hour;
+		min  = alm_tm.tm_min;
+		sec  = alm_tm.tm_sec;
+		if (day >= 31)
+			day = 99;
+
+		if (week >= 7)
+			week = 9;
+
+		if (hrs >= 24)
+			hrs = 99;
+
+		if (min >= 60)
+			min = 99;
+
+		if (sec >= 60)
+			sec = 99;
+
+		spin_lock_irq(&rtc_lock);
+		BIN_TO_BCD(sec);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(hrs);
+		BIN_TO_BCD(day);
+		SELECT_BANK(RTC_BANK1);
+		WRITE_DAY(day);
+		WRITE_WEEK(week);
+		WRITE_HOURS(hrs);
+		WRITE_MINUTES(min);
+		WRITE_SECONDS(sec);
+		SELECT_BANK(RTC_BANK0);
+		spin_unlock_irq(&rtc_lock);
+
+		return 0;
+	}
+	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
+	{
+		memset(&wtime, 0, sizeof(struct rtc_time));
+		sh03_rtc_get_rtc_time(&wtime);
+		break;
+	}
+	case RTC_SET_TIME:	/* Set the RTC */
+	{
+		struct rtc_time rtc_tm;
+		unsigned char mon, day, hrs, min, sec, leap_yr;
+		unsigned int yrs, yrs_low, yrs_high;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, (struct rtc_time __user *)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		yrs = rtc_tm.tm_year + 1900;
+		mon = rtc_tm.tm_mon + 1;   /* tm_mon starts at zero */
+		day = rtc_tm.tm_mday;
+		hrs = rtc_tm.tm_hour;
+		min = rtc_tm.tm_min;
+		sec = rtc_tm.tm_sec;
+
+		if (yrs < 1970)
+			return -EINVAL;
+
+		leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+
+		if ((mon > 12) || (day == 0))
+			return -EINVAL;
+
+		if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+			return -EINVAL;
+
+		if ((hrs >= 24) || (min >= 60) || (sec >= 60))
+			return -EINVAL;
+
+		if ((yrs -= epoch) > 255)    /* They are unsigned */
+			return -EINVAL;
+
+		spin_lock_irq(&rtc_lock);
+
+		/* These limits and adjustments are independent of
+		 * whether the chip is in binary mode or not.
+		 */
+		if (yrs > 169) {
+			spin_unlock_irq(&rtc_lock);
+			return -EINVAL;
+		}
+		if (yrs >= 100)
+			yrs -= 100;
+
+		yrs += epoch;
+		BIN_TO_BCD(sec);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(hrs);
+		BIN_TO_BCD(day);
+		BIN_TO_BCD(mon);
+		yrs_low = yrs % 100;
+		yrs_high = yrs / 100;
+		BIN_TO_BCD(yrs_low);
+		BIN_TO_BCD(yrs_high);
+
+		WRITE_YEAR_HIGH(yrs_high);
+		WRITE_YEAR_LOW(yrs_low);
+		WRITE_MONTH(mon);
+		WRITE_DAY(day);
+		WRITE_HOURS(hrs);
+		WRITE_MINUTES(min);
+		WRITE_SECONDS(sec);
+
+		spin_unlock_irq(&rtc_lock);
+		return 0;
+	}
+#ifdef SH03_RTC_IRQ
+	case RTC_IRQP_READ:	/* Read the periodic IRQ rate.	*/
+	{
+		return put_user(rtc_freq, (unsigned long __user *)arg);
+	}
+	case RTC_IRQP_SET:	/* Set periodic IRQ rate.	*/
+	{
+		int tmp = 0;
+
+		/*
+		 * We don't really want Joe User generating more
+		 * than 64Hz of interrupts on a multi-user machine.
+		 */
+		if (!kernel && (arg > rtc_max_user_freq) && (!capable(CAP_SYS_RESOURCE)))
+			return -EACCES;
+
+		switch (arg) {
+		case    1: tmp = 2; break;
+		case   64: tmp = 1; break;
+		case 4096: tmp = 0; break;
+		default:   return -EINVAL;
+		}
+
+		spin_lock_irq(&rtc_lock);
+		rtc_freq = arg;
+		SELECT_BANK(RTC_BANK2);
+		WRITE_CLOCK((READ_CLOCK & ~3) | tmp);
+		SELECT_BANK(RTC_BANK0);
+		spin_unlock_irq(&rtc_lock);
+		return 0;
+	}
+#endif
+	case RTC_EPOCH_READ:	/* Read the epoch.	*/
+	{
+		return put_user (epoch, (unsigned long __user *)arg);
+	}
+	case RTC_EPOCH_SET:	/* Set the epoch.	*/
+	{
+		/*
+		 * There were no RTC clocks before 1900.
+		 */
+		if (arg < 1900)
+			return -EINVAL;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		epoch = arg;
+		return 0;
+	}
+	default:
+		return -ENOTTY;
+	}
+	return copy_to_user((void __user *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+static int sh03_rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	return sh03_rtc_do_ioctl(cmd, arg, 0);
+}
+
+/*
+ *	We enforce only one user at a time here with the open/close.
+ *	Also clear the previous interrupt data on an open, and clean
+ *	up things on a close.
+ */
+
+/* We use rtc_lock to protect against concurrent opens. So the BKL is not
+ * needed here. Or anywhere else in this driver. */
+static int sh03_rtc_open(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&rtc_lock);
+
+	if(rtc_status & RTC_IS_OPEN)
+		goto out_busy;
+
+	rtc_status |= RTC_IS_OPEN;
+
+	rtc_irq_data = 0;
+	spin_unlock_irq (&rtc_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&rtc_lock);
+	return -EBUSY;
+}
+
+static int sh03_rtc_fasync (int fd, struct file *filp, int on)
+
+{
+	return fasync_helper (fd, filp, on, &sh03_rtc_async_queue);
+}
+
+static int sh03_rtc_release(struct inode *inode, struct file *file)
+{
+#ifdef SH03_RTC_IRQ
+	if (sh03_rtc_has_irq == 0)
+		goto no_irq;
+
+	/*
+	 * Turn off all interrupts once the device is no longer
+	 * in use, and clear the data.
+	 */
+
+	spin_lock_irq(&rtc_lock);
+	SELECT_BANK(RTC_BANK1);
+	ctrl_outb(0, RTC_ATCTL);
+	SELECT_BANK(RTC_BANK2);
+	ctrl_outb(0, RTC_TMCTL);
+	SELECT_BANK(RTC_BANK0);
+
+	if (rtc_status & RTC_TIMER_ON) {
+		rtc_status &= ~RTC_TIMER_ON;
+		del_timer(&sh03_rtc_irq_timer);
+	}
+	spin_unlock_irq(&rtc_lock);
+
+	if (file->f_flags & FASYNC) {
+		sh03_rtc_fasync (-1, file, 0);
+	}
+no_irq:
+#endif
+
+	spin_lock_irq (&rtc_lock);
+	rtc_irq_data = 0;
+	rtc_status &= ~RTC_IS_OPEN;
+	spin_unlock_irq (&rtc_lock);
+	return 0;
+}
+
+#ifdef SH03_RTC_IRQ
+/* Called without the kernel lock - fine */
+static unsigned int sh03_rtc_poll(struct file *file, poll_table *wait)
+{
+	unsigned long l;
+
+	if (sh03_rtc_has_irq == 0)
+		return 0;
+
+	poll_wait(file, &sh03_rtc_wait, wait);
+
+	spin_lock_irq (&rtc_lock);
+	l = rtc_irq_data;
+	spin_unlock_irq (&rtc_lock);
+
+	if (l != 0)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+#endif
+
+int rtc_control(rtc_task_t *task, unsigned int cmd, unsigned long arg)
+{
+#ifndef SH03_RTC_IRQ
+	return -EIO;
+#else
+	spin_lock_irq(&rtc_task_lock);
+	if (rtc_callback != task) {
+		spin_unlock_irq(&rtc_task_lock);
+		return -ENXIO;
+	}
+	spin_unlock_irq(&rtc_task_lock);
+	return sh03_rtc_do_ioctl(cmd, arg, 1);
+#endif
+}
+
+
+/*
+ *	The various file operations we support.
+ */
+
+static struct file_operations sh03_rtc_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= sh03_rtc_read,
+#ifdef SH03_RTC_IRQ
+	.poll		= sh03_rtc_poll,
+#endif
+	.ioctl		= sh03_rtc_ioctl,
+	.open		= sh03_rtc_open,
+	.release	= sh03_rtc_release,
+	.fasync		= sh03_rtc_fasync,
+};
+
+static struct miscdevice sh03_rtc_dev=
+{
+	RTC_MINOR,
+	"sh03-rtc",
+	&sh03_rtc_fops
+};
+
+#ifdef SH03_RTC_IRQ
+static irqreturn_t (*rtc_int_handler_ptr)(int irq, void *dev_id, struct pt_regs *regs);
+#endif
+
+static int __init sh03_rtc_init(void)
+{
+	if (!request_region(SH03_RTC_PORT(0), SH03_RTC_IO_EXTENT, "sh03-rtc")) {
+		printk(KERN_ERR "sh03-rtc: I/O port %d is not free.\n", SH03_RTC_PORT (0));
+		return -EIO;
+	}
+
+#ifdef SH03_RTC_IRQ
+	rtc_int_handler_ptr = sh03_rtc_interrupt;
+	if(request_irq(SH03_RTC_IRQ, rtc_int_handler_ptr, SA_INTERRUPT, "sh03-rtc", NULL)) {
+		/* Yeah right, seeing as irq 8 doesn't even hit the bus. */
+		printk(KERN_ERR "sh03-rtc: IRQ %d is not free.\n", RTC_IRQ);
+		release_region(SH03_RTC_PORT(0), SH03_RTC_IO_EXTENT);
+		return -EIO;
+	}
+#endif
+
+	if (misc_register(&sh03_rtc_dev)) {
+#ifdef SH03_RTC_IRQ
+		free_irq(SH03_RTC_IRQ, NULL);
+#endif
+		release_region(SH03_RTC_PORT(0), SH03_RTC_IO_EXTENT);
+		return -ENODEV;
+	}
+	if (!create_proc_read_entry ("driver/sh03-rtc", 0, NULL, sh03_rtc_read_proc, NULL)) {
+#ifdef SH03_RTC_IRQ
+		free_irq(SH03_RTC_IRQ, NULL);
+#endif
+		release_region(SH03_RTC_PORT(0), SH03_RTC_IO_EXTENT);
+		misc_deregister(&sh03_rtc_dev);
+		return -ENOMEM;
+	}
+
+#ifdef SH03_RTC_IRQ
+	if (sh03_rtc_has_irq == 0)
+		goto no_irq2;
+
+	init_timer(&sh03_rtc_irq_timer);
+	sh03_rtc_irq_timer.function = sh03_rtc_dropped_irq;
+	spin_lock_irq(&rtc_lock);
+	SELECT_BANK(RTC_BANK2);
+	WRITE_CLOCK(2);
+	SELECT_BANK(RTC_BANK0);
+	rtc_freq = 1;
+	spin_unlock_irq(&rtc_lock);
+no_irq2:
+#endif
+
+	(void) init_sysctl();
+
+	printk(KERN_INFO "CTP/PCI-SH03 Real Time Clock Driver v" SH03_RTC_VERSION "\n");
+
+	return 0;
+}
+
+static void __exit sh03_rtc_exit (void)
+{
+	cleanup_sysctl();
+	remove_proc_entry ("driver/sh03-rtc", NULL);
+	misc_deregister(&sh03_rtc_dev);
+	release_region (SH03_RTC_PORT (0), SH03_RTC_IO_EXTENT);
+#ifdef SH03_RTC_IRQ
+	if (sh03_rtc_has_irq)
+		free_irq (SH03_RTC_IRQ, NULL);
+#endif
+}
+
+module_init(sh03_rtc_init);
+module_exit(sh03_rtc_exit);
+
+#ifdef SH03_RTC_IRQ
+/*
+ * 	At IRQ rates >= 4096Hz, an interrupt may get lost altogether.
+ *	(usually during an IDE disk interrupt, with IRQ unmasking off)
+ *	Since the interrupt handler doesn't get called, the IRQ status
+ *	byte doesn't get read, and the RTC stops generating interrupts.
+ *	A timer is set, and will call this function if/when that happens.
+ *	To get it out of this stalled state, we just read the status.
+ *	At least a jiffy of interrupts (rtc_freq/HZ) will have been lost.
+ *	(You *really* shouldn't be trying to use a non-realtime system
+ *	for something that requires a steady > 1KHz signal anyways.)
+ */
+
+static void sh03_rtc_dropped_irq(unsigned long data)
+{
+	unsigned long freq;
+
+	spin_lock_irq (&rtc_lock);
+
+	/* Just in case someone disabled the timer from behind our back... */
+	if (rtc_status & RTC_TIMER_ON)
+		mod_timer(&sh03_rtc_irq_timer, jiffies + HZ/rtc_freq + 2*HZ/100);
+
+	rtc_irq_data += ((rtc_freq/HZ)<<8);
+	rtc_irq_data &= ~0xff;
+	SELECT_BANK(RTC_BANK1);
+	rtc_irq_data |= (READ_ATCTL & RTC_AF) >> 1;
+	SELECT_BANK(RTC_BANK2);
+	rtc_irq_data |= (READ_TMCTL & RTC_TF);
+	SELECT_BANK(RTC_BANK0);
+
+	freq = rtc_freq;
+
+	spin_unlock_irq(&rtc_lock);
+
+	printk(KERN_WARNING "sh03-rtc: lost some interrupts at %ldHz.\n", freq);
+
+	/* Now we have new data */
+	wake_up_interruptible(&sh03_rtc_wait);
+
+	kill_fasync (&sh03_rtc_async_queue, SIGIO, POLL_IN);
+}
+#endif
+
+/*
+ *	Info exported via "/proc/driver/sh03-rtc".
+ */
+
+static int sh03_rtc_proc_output (char *buf)
+{
+#define YN(bit) ((bit) ? "yes" : "no")
+#define NY(bit) ((bit) ? "no" : "yes")
+	char *p;
+	struct rtc_time tm;
+	unsigned char aie, tie, af, tf;
+	unsigned long freq;
+	int sec_ae, min_ae, hour_ae, week_ae, day_ae;
+
+	spin_lock_irq(&rtc_lock);
+	SELECT_BANK(RTC_BANK1);
+	aie = READ_ATCTL & RTC_AIE;
+	af  = READ_ATCTL & 2;
+	sec_ae  = ctrl_inb(RTC_SEC10) & 8;
+	min_ae  = ctrl_inb(RTC_MIN10) & 8;
+	hour_ae = ctrl_inb(RTC_HOU10) & 8;
+	week_ae = ctrl_inb(RTC_WEE1 ) & 8;
+	day_ae  = ctrl_inb(RTC_DAY10) & 8;
+	SELECT_BANK(RTC_BANK2);
+	tie = READ_TMCTL & RTC_TIE;
+	tf  = READ_TMCTL & 2;
+	SELECT_BANK(RTC_BANK0);
+	freq = rtc_freq;
+	spin_unlock_irq(&rtc_lock);
+
+	p = buf;
+
+	sh03_rtc_get_rtc_time(&tm);
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+		     "rtc_time\t: %02d:%02d:%02d\n"
+		     "rtc_date\t: %04d-%02d-%02d\n"
+	 	     "rtc_epoch\t: %04lu\n",
+		     tm.tm_hour, tm.tm_min, tm.tm_sec,
+		     tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, epoch);
+
+	sh03_get_rtc_alm_time(&tm);
+
+	/*
+	 * We implicitly assume 24hr mode here. Alarm values >= 0xc0 will
+	 * match any value for that particular field. Values that are
+	 * greater than a valid time, but less than 0xc0 shouldn't appear.
+	 */
+	p += sprintf(p, "alarm\t\t: ");
+	if (!day_ae)
+		p += sprintf(p, "%02d ", tm.tm_mday);
+	else
+		p += sprintf(p, "** ");
+	if (!week_ae)
+		p += sprintf(p, "%01d ", tm.tm_wday);
+	else
+		p += sprintf(p, "* ");
+	if (!hour_ae)
+		p += sprintf(p, "%02d:", tm.tm_hour);
+	else
+		p += sprintf(p, "**:");
+
+	if (!min_ae)
+		p += sprintf(p, "%02d:", tm.tm_min);
+	else
+		p += sprintf(p, "**:");
+
+	if (!sec_ae)
+		p += sprintf(p, "%02d\n", tm.tm_sec);
+	else
+		p += sprintf(p, "**\n");
+
+	p += sprintf(p,
+		     "alarm_IRQ\t: %s-%s\n"
+		     "periodic_IRQ\t: %s-%s\n"
+		     "periodic_freq\t: %ld\n"
+		     "FOS\t\t: %s\n"
+		     "Control Reg\t: %x\n",
+		     YN(aie),YN(af),
+		     YN(tie),YN(tf),
+		     freq,
+		     ctrl_inb(RTC_SEC10) & 8 ? "on" : "off",
+		     ctrl_inb(RTC_CTL) & 15);
+
+	return  p - buf;
+#undef YN
+#undef NY
+}
+
+static int sh03_rtc_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data)
+{
+        int len = sh03_rtc_proc_output (page);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count) len = count;
+        if (len<0) len = 0;
+        return len;
+}
+
+void sh03_rtc_get_rtc_time(struct rtc_time *rtc_tm)
+{
+// @@@@@ 16.09.29 TODO	unsigned long uip_watchdog = jiffies;
+
+	/*
+	 * read RTC once any update in progress is done. The update
+	 * can take just over 2ms. We wait 10 to 20ms. There is no need to
+	 * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.
+	 * If you need to know *exactly* when a second has started, enable
+	 * periodic update complete interrupts, (via ioctl) and then
+	 * immediately read /dev/rtc which will block until you get the IRQ.
+	 * Once the read clears, read the RTC time (again via ioctl). Easy.
+	 */
+
+#if 0 /* @@@@@ 16.09.29 TODO */
+	if (rtc_is_updating() != 0)
+		while (jiffies - uip_watchdog < 2*HZ/100) {
+			barrier();
+			cpu_relax();
+		}
+#endif
+	/*
+	 * Only the values that we read from the RTC are set. We leave
+	 * tm_wday, tm_yday and tm_isdst untouched. Even though the
+	 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
+	 * by the RTC when initially set to a non-zero value.
+	 */
+	spin_lock_irq(&rtc_lock);
+	rtc_tm->tm_sec = READ_SECONDS;
+	rtc_tm->tm_min = READ_MINUTES;
+	rtc_tm->tm_hour = READ_HOURS;
+	rtc_tm->tm_wday = READ_WEEK;
+	rtc_tm->tm_mday = READ_DAY;
+	rtc_tm->tm_mon = READ_MONTH;
+	rtc_tm->tm_year = READ_YEAR - epoch;
+	spin_unlock_irq(&rtc_lock);
+
+	/*
+	 * Account for differences between how the RTC uses the values
+	 * and how they are defined in a struct rtc_time;
+	 */
+	if ((rtc_tm->tm_year += (epoch - 1900)) <= 69)
+		rtc_tm->tm_year += 100;
+
+	rtc_tm->tm_mon--;
+}
+
+static void sh03_get_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	/*
+	 * Only the values that we read from the RTC are set. That
+	 * means only tm_hour, tm_min, and tm_sec.
+	 */
+	spin_lock_irq(&rtc_lock);
+	SELECT_BANK(RTC_BANK1);
+	alm_tm->tm_sec = READ_SECONDS;
+	alm_tm->tm_min = READ_MINUTES;
+	alm_tm->tm_hour = READ_HOURS;
+	alm_tm->tm_wday = READ_WEEK;
+	alm_tm->tm_mday = READ_DAY;
+	SELECT_BANK(RTC_BANK0);
+	spin_unlock_irq(&rtc_lock);
+}
+
+#ifdef SH03_RTC_IRQ
+/*
+ * Used to disable/enable interrupts for any one of UIE, AIE, PIE.
+ * Rumour has it that if you frob the interrupt enable/disable
+ * bits in RTC_CONTROL, you should read RTC_INTR_FLAGS, to
+ * ensure you actually start getting interrupts. Probably for
+ * compatibility with older/broken chipset RTC implementations.
+ * We also clear out any old irq data after an ioctl() that
+ * meddles with the interrupt enable/disable bits.
+ */
+
+static void sh03_mask_rtc_irq_bit(unsigned int bit)
+{
+	unsigned char val;
+
+	spin_lock_irq(&rtc_lock);
+	switch(bit) {
+	case RTC_AIE_OFF:
+	  SELECT_BANK(RTC_BANK1);
+	  val = READ_ATCTL;
+	  val &= ~RTC_AIE;
+	  WRITE_ATCTL(val);
+	  SELECT_BANK(RTC_BANK0);
+	  break;
+	case RTC_PIE_OFF:
+	  SELECT_BANK(RTC_BANK2);
+	  val = READ_TMCTL;
+	  val &= ~RTC_TIE;
+	  WRITE_TMCTL(val);
+	  SELECT_BANK(RTC_BANK0);
+	  break;
+	}
+
+	rtc_irq_data = 0;
+	spin_unlock_irq(&rtc_lock);
+}
+
+static void sh03_set_rtc_irq_bit(unsigned int bit)
+{
+	unsigned char val;
+
+	spin_lock_irq(&rtc_lock);
+	switch(bit) {
+	case RTC_AIE_ON:
+	  SELECT_BANK(RTC_BANK1);
+	  val = READ_ATCTL;
+	  val |= RTC_AIE;
+	  WRITE_ATCTL(val);
+	  SELECT_BANK(RTC_BANK0);
+	  break;
+	case RTC_PIE_ON:
+	  SELECT_BANK(RTC_BANK2);
+	  val = READ_TMCTL;
+	  val |= RTC_TIE;
+	  WRITE_TMCTL(val);
+	  SELECT_BANK(RTC_BANK0);
+	  break;
+	}
+
+	rtc_irq_data = 0;
+	spin_unlock_irq(&rtc_lock);
+}
+#endif
+
+MODULE_AUTHOR("Saito.K Interface Corporation");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(RTC_MINOR);
diff -Naur linux-2.6.17.8/drivers/char/stpio.c linux-2.6.17.8-sh/drivers/char/stpio.c
--- linux-2.6.17.8/drivers/char/stpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/stpio.c	2006-08-23 13:29:46.205786000 +0100
@@ -0,0 +1,425 @@
+/*
+ * drivers/char/stpio.c
+ *
+ * (c) 2001 Stuart Menefy <stuart.menefy@st.com>
+ * based on hd64465_gpio.c:
+ * by Greg Banks <gbanks@pocketpenguins.com>
+ * (c) 2000 PocketPenguins Inc
+ *
+ * PIO pin support for ST40 devices.
+ *
+ * History:
+ * 	9/3/2006
+ * 	Added stpio_enable_irq and stpio_disable_irq
+ * 		Angelo Castello <angelo.castello@st.com>
+ * 	13/3/2006
+ * 	Added stpio_request_set_pin and /proc support
+ * 	  	 Marek Skuczynski <mareksk@easymail.pl>
+ *	13/3/2006
+ *	Integrated patches above and tidied up STPIO_PIN_DETAILS
+ *	macro to stop code duplication
+ *		Carl Shaw <carl.shaw@st.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/stpio.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/kallsyms.h>
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#define STPIO_NPORTS 3
+#elif defined(CONFIG_CPU_SUBTYPE_ST40GX1)
+#define STPIO_NPORTS 5
+#elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+#define STPIO_NPORTS 8
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+#define STPIO_NPORTS 7
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define STPIO_NPORTS 6
+#else
+#error Unknown CPU
+#endif
+
+#define STPIO_POUT_OFFSET	0x00
+#define STPIO_PIN_OFFSET	0x10
+#define STPIO_PC0_OFFSET	0x20
+#define STPIO_PC1_OFFSET	0x30
+#define STPIO_PC2_OFFSET	0x40
+#define STPIO_PCOMP_OFFSET	0x50
+#define STPIO_PMASK_OFFSET	0x60
+
+#define STPIO_SET_OFFSET	0x4
+#define STPIO_CLEAR_OFFSET	0x8
+
+#define MODNAME "stpio"
+
+struct stpio_pin {
+	const char* name;
+	void (*func)(struct stpio_pin *pin, void *dev);
+	void *dev;
+#ifdef CONFIG_PROC_FS
+	int  direction;
+#endif
+};
+
+struct stpio_port {
+	unsigned long base;
+	unsigned int irq;
+};
+
+static struct stpio_pin stpio_pin_conf[STPIO_NPORTS*8];
+
+static const struct stpio_port stpio_port_conf[STPIO_NPORTS] = {
+#if defined(CONFIG_CPU_SUBTYPE_ST40GX1) || \
+    defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+	{0xbb010000, 80 },			/* PIO0 */
+	{0xbb020000, 84 },			/* PIO1 */
+	{0xbb030000, 88 },			/* PIO2 */
+#if defined(CONFIG_CPU_SUBTYPE_ST40GX1)
+	{0xbb20c000, 136},			/* IO_PIO0 */
+	{0xbb20d000, 156},			/* IO_PIO1 */
+	/* the remaining four are not implemented
+	{0xbb20e000, ??},			 * IO_PIO2 *
+	{0xbb20f000, ??},			 * IO_PIO3 *
+	{0xbb210000, ??},			 * IO_PIO4 *
+	{0xbb212000, ??}			 * IO_PIO5 - note odd address *
+	*/
+#endif
+#elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+	{0xba020000, 80 },			/* PIO0 */
+	{0xba021000, 84 },			/* PIO1 */
+	{0xba022000, 88 },			/* PIO2 */
+	{0xba023000, 112},			/* PIO3 */
+	{0xba024000, 113},			/* PIO4 */
+	{0xba025000, 114},			/* PIO5 */
+	{0xba026000, 115},			/* PIO6 */
+	{0xba027000, 116},			/* PIO7 */
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+	{0xb8320000, ILC_FIRST_IRQ + 0 },
+	{0xb8321000, ILC_FIRST_IRQ + 1 },
+	{0xb8322000, ILC_FIRST_IRQ + 2 },
+	{0xb8323000, ILC_FIRST_IRQ + 3 },
+	{0xb8324000, ILC_FIRST_IRQ + 4 },
+	{0xb8325000, ILC_FIRST_IRQ + 5 },
+	{0xb8326000, ILC_FIRST_IRQ + 6 },
+	/* PIO7 has an address, but no interrupt or pins */
+	/* {0xb8327000, ??? },*/
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+	{0xb8020000, 80 },
+	{0xb8021000, 84 },
+	{0xb8022000, 88 },
+	{0xb8023000, 115 },
+	{0xb8024000, 114 },
+	{0xb8025000, 113 },
+#else
+#error Unknown CPU
+#endif
+};
+
+static spinlock_t stpio_lock = SPIN_LOCK_UNLOCKED;
+
+#define STPIO_PIN_DETAILS(pin, port, pinno)		\
+	unsigned int pinno;				\
+	const struct stpio_port *port;			\
+	do {						\
+		unsigned offset = pin - stpio_pin_conf;	\
+		port = &stpio_port_conf[offset >> 3];	\
+		pinno = offset & 7;			\
+	} while (0)
+
+static void stpio_configure_pin(struct stpio_pin* pin, int direction)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+#ifdef CONFIG_PROC_FS
+	pin->direction = direction;
+#endif
+
+	ctrl_outl(1<<pinno, port->base + STPIO_PC0_OFFSET +
+		  ((direction & (1<<0)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+	ctrl_outl(1<<pinno, port->base + STPIO_PC1_OFFSET +
+		  ((direction & (1<<1)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+	ctrl_outl(1<<pinno, port->base + STPIO_PC2_OFFSET +
+		  ((direction & (1<<2)) ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+}
+
+struct stpio_pin* stpio_request_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction)
+{
+	struct stpio_pin *pin = NULL;
+
+	spin_lock(&stpio_lock);
+
+	if ((portno < STPIO_NPORTS) && (pinno < 8) &&
+	    (stpio_pin_conf[portno*8 + pinno].name == NULL)) {
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		stpio_configure_pin(pin, direction);
+		pin->name = name;
+	}
+
+	spin_unlock(&stpio_lock);
+
+	return pin;
+}
+
+struct stpio_pin* stpio_request_set_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction, unsigned int value)
+{
+	struct stpio_pin *pin = NULL;
+
+	spin_lock(&stpio_lock);
+
+	if ((portno < STPIO_NPORTS) && (pinno < 8)) {
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		if( (pin->name == NULL) ) {
+		    stpio_set_pin(pin, value);
+		    stpio_configure_pin(pin, direction);
+		    pin->name = name;
+		} else {
+		    pin = NULL;
+		}
+	}
+
+	spin_unlock(&stpio_lock);
+
+	return pin;
+}
+
+void stpio_free_pin(struct stpio_pin* pin)
+{
+	stpio_configure_pin(pin, STPIO_IN);
+	pin->name = NULL;
+	pin->func = 0;
+	pin->dev  = 0;
+}
+
+void stpio_set_pin(struct stpio_pin* pin, unsigned int value)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	ctrl_outl(1<<pinno, port->base + STPIO_POUT_OFFSET +
+		  (value ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+}
+
+unsigned int stpio_get_pin(struct stpio_pin* pin)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	return (ctrl_inl(port->base + STPIO_PIN_OFFSET) & (1<<pinno)) ? 1 : 0;
+}
+
+static irqreturn_t stpio_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	const struct stpio_port *port = dev;
+	unsigned portno = port - stpio_port_conf;
+    	unsigned long in, mask, comp;
+	unsigned int pinno;
+
+	in   = ctrl_inl(port->base + STPIO_PIN_OFFSET);
+	mask = ctrl_inl(port->base + STPIO_PMASK_OFFSET);
+	comp = ctrl_inl(port->base + STPIO_PCOMP_OFFSET);
+
+	mask &= in ^ comp;
+
+	while ((pinno = ffs(mask)) != 0) {
+		struct stpio_pin *pin;
+		pinno--;
+		pin = &stpio_pin_conf[portno*8 + pinno];
+		if (pin->func != 0)
+			pin->func(pin, pin->dev);
+		else
+			printk(KERN_NOTICE "unexpected PIO interrupt, PIO%d[%d]\n",
+			       portno, pinno);
+		mask &= ~(1<<pinno);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void stpio_enable_irq(struct stpio_pin* pin, int comp)
+{
+    STPIO_PIN_DETAILS(pin, port, pinno);
+
+    ctrl_outl(1<<pinno, port->base + STPIO_PCOMP_OFFSET +
+              (comp ? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));
+    ctrl_outl(1<<pinno, port->base + STPIO_PMASK_OFFSET + STPIO_SET_OFFSET);
+}
+
+void stpio_disable_irq(struct stpio_pin* pin)
+{
+    STPIO_PIN_DETAILS(pin, port, pinno);
+
+    ctrl_outl(1<<pinno, port->base + STPIO_PMASK_OFFSET + STPIO_CLEAR_OFFSET);
+}
+
+void stpio_request_irq(struct stpio_pin* pin, int comp,
+		       void (*handler)(struct stpio_pin *pin, void *dev),
+		       void *dev)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	disable_irq(port->irq);
+
+	pin->func = handler;
+	pin->dev = dev;
+
+        stpio_enable_irq(pin, comp);
+
+	enable_irq(port->irq);
+}
+
+void stpio_free_irq(struct stpio_pin* pin)
+{
+	STPIO_PIN_DETAILS(pin, port, pinno);
+
+	disable_irq(port->irq);
+
+    	stpio_disable_irq(pin);
+	pin->func = 0;
+	pin->dev = 0;
+
+	enable_irq(port->irq);
+}
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_stpio;
+
+static const char *stpio_dir_name[] =
+{
+    "IN  (pull-up)      ",
+    "BI  (open-drain)   ",
+    "OUT (push-pull)    ",
+    "forbidden          ",
+    "IN  (Hi-Z)         ",
+    "forbidden          ",
+    "Alt-OUT (push-pull)",
+    "Alt-BI (open-drain)"
+};
+
+static const char *stpio_get_handler_name(unsigned long addr)
+{
+    static char sym_name[KSYM_NAME_LEN+1];
+    char *modname;
+    unsigned long symbolsize, offset;
+    const char *symb;
+
+    symb = kallsyms_lookup(addr, &symbolsize, &offset, &modname, sym_name);
+    return ( symb ? symb : "");
+}
+
+static inline int stpio_proc_info (char *buf, int port, int pin)
+{
+/*
+    PIO port.pin name mode handler_name mask
+*/
+    struct stpio_pin *pin_ptr = &stpio_pin_conf[port*8 + pin];
+
+    return sprintf(buf, "PIO %d.%d [%-10s] [%s] [%s]\n",
+	port, pin,
+	(pin_ptr->name ? pin_ptr->name : "     "),
+	stpio_dir_name[pin_ptr->direction & 0x7],
+	(pin_ptr->func ? stpio_get_handler_name((unsigned long)pin_ptr->func) : "")
+	);
+}
+
+static int stpio_read_proc (char *page, char **start, off_t off, int count,
+			  int *eof, void *data_unused)
+{
+	int len, l, i, j;
+        off_t   begin = 0;
+
+	spin_lock(&stpio_lock);
+
+	len = sprintf(page, "  port      name          direction\n");
+        for (i=0; i< STPIO_NPORTS; i++)
+	{
+	    for(j=0; j < 8; j++ )
+	    {
+                l = stpio_proc_info(page + len, i, j);
+                len += l;
+                if (len+begin > off+count)
+                        goto done;
+                if (len+begin < off) {
+                        begin += len;
+                        len = 0;
+                }
+	    }
+        }
+
+        *eof = 1;
+
+done:
+	spin_unlock(&stpio_lock);
+        if (off >= len+begin)
+                return 0;
+        *start = page + (off-begin);
+        return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+#endif /* CONFIG_PROC_FS */
+
+static int __init stpio_init(void)
+{
+	int portno;
+
+    	/* TODO: check return values */
+
+	for (portno=0; portno<STPIO_NPORTS; portno++) {
+		const struct stpio_port *port = &stpio_port_conf[portno];
+		request_mem_region(port->base, 0x1000, MODNAME);
+		request_irq(port->irq, stpio_interrupt,
+			    SA_INTERRUPT, MODNAME, (void*)port);
+	}
+
+#ifdef CONFIG_PROC_FS
+	if ((proc_stpio = create_proc_entry( "stpio", 0, proc_root_driver )))
+		proc_stpio->read_proc = stpio_read_proc;
+#endif
+
+    	printk("STPIO layer initialised\n");
+	return 0;
+}
+
+static void __exit stpio_exit(void)
+{
+	int portno;
+
+    	/* TODO: check return values */
+
+#ifdef CONFIG_PROC_FS
+	if (proc_stpio)
+		remove_proc_entry( "stpio", proc_root_driver);
+#endif
+
+	for (portno=0; portno<STPIO_NPORTS; portno++) {
+		const struct stpio_port *port = &stpio_port_conf[portno];
+		release_mem_region(port->base, 0x1000);
+		free_irq(port->irq, (void*)port);
+	}
+}
+
+module_init(stpio_init);
+module_exit(stpio_exit);
+
+EXPORT_SYMBOL(stpio_request_pin);
+EXPORT_SYMBOL(stpio_request_set_pin);
+EXPORT_SYMBOL(stpio_free_pin);
+EXPORT_SYMBOL(stpio_get_pin);
+EXPORT_SYMBOL(stpio_set_pin);
+EXPORT_SYMBOL(stpio_request_irq);
+EXPORT_SYMBOL(stpio_free_irq);
+EXPORT_SYMBOL(stpio_disable_irq);
+EXPORT_SYMBOL(stpio_enable_irq);
diff -Naur linux-2.6.17.8/drivers/char/st-rtc.c linux-2.6.17.8-sh/drivers/char/st-rtc.c
--- linux-2.6.17.8/drivers/char/st-rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/st-rtc.c	2006-08-23 13:29:42.709691000 +0100
@@ -0,0 +1,761 @@
+/*
+   -------------------------------------------------------------------------
+   st-rtc.c
+   -------------------------------------------------------------------------
+   STMicroelectronics
+
+
+   ---------------------------------------------------------------------------
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, wrssc to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
+/* ------------------------------------------------------------------------- */
+
+#include <linux/rtc.h>
+#include <linux/stpio.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/bcd.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/st_soc.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#undef dgb_print
+
+#ifdef  CONFIG_STM_RTC_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+static struct platform_device *rtc_device_data;
+
+#define rtc_store8(rtc , offset, value)    iowrite8(value, (void *)rtc.base+offset)
+#define rtc_store16(rtc , offset, value)   iowrite16(value, (void *)rtc.base+offset)
+
+#define rtc_load8(rtc , offset)            ioread8((void *)(rtc.base+offset))
+#define rtc_load16(rtc , offset)           ioread16((void *)(rtc.base+offset))
+
+
+
+#define RTC_R64CNT           0x00
+
+#define RTC_RSECCNT          0x04
+#define RTC_RSECCNT_UNITS    0x0f
+#define RTC_RSECCNT_TENS     0x70
+
+#define RTC_RMINCNT          0x08
+#define RTC_RMINCNT_UNITS    0x0f
+#define RTC_RMINCNT_TENS     0x70
+
+#define RTC_RHRCNT           0x0C
+#define RTC_RHRCNT_UNITS     0x0f
+#define RTC_RHRCNT_TENS      0x30
+
+#define RTC_RWKCNT           0x10
+#define RTC_RWKCNT_UNITS     0x07
+
+#define RTC_RDAYCNT          0x14
+#define RTC_RDAYCNT_UNITS    0x0f
+#define RTC_RDAYCNT_TENS     0x30
+
+#define RTC_RMONCNT          0x18
+#define RTC_RMONCNT_UNITS    0x0f
+#define RTC_RMONCNT_TENS     0x10
+
+#define RTC_RYRCNT           0x1C
+#define RTC_RYRCNT_UNITS     0x0f
+#define RTC_RYRCNT_TENS      0xf0
+#define RTC_RYRCNT_HUND      0xf00
+#define RTC_RYRCNT_THOUS     0xf000
+
+#define RTC_RSECAR           0x20
+#define RTC_RSECAR_UNITS     0x0f
+#define RTC_RSECAR_TENS      0x70
+#define RTC_RSECAR_ENB       0x80
+
+#define RTC_RMINAR           0x24
+#define RTC_RMINAR_UNITS     0x0f
+#define RTC_RMINAR_TENS      0x70
+#define RTC_RMINAR_ENB       0x80
+
+#define RTC_RHRAR            0x28
+#define RTC_RHRAR_UNITS      0x0f
+#define RTC_RHRAR_TENS       0x30
+#define RTC_RHRAR_ENB        0x80
+
+#define RTC_RWKAR            0x2C
+#define RTC_RWKAR_UNITS      0x07
+#define RTC_RWKAR_ENB        0x80
+
+#define RTC_RDAYAR           0x30
+#define RTC_RDAYAR_UNITS     0x0f
+#define RTC_RDAYAR_TENS      0x30
+#define RTC_RDAYAR_ENB       0x80
+
+#define RTC_RMONAR           0x34
+#define RTC_RMONAR_UNITS     0x0f
+#define RTC_RMONAR_TENS      0x10
+#define RTC_RMONAR_ENB       0x80
+
+#define RTC_AR_ENB           0x80
+
+#define RTC_RCR1             0x38
+#define RTC_RCR1_AF          0x01
+#define RTC_RCR1_AIE         0x08
+#define RTC_RCR1_CIE         0x10
+#define RTC_RCR1_CF          0x80
+
+#define RTC_RCR2             0x3C
+#define RTC_RCR2_START       0x01
+#define RTC_RCR2_RESET       0x02
+#define RTC_RCR2_ADJ         0x04
+#define RTC_RCR2_RTCEN       0x08
+#define RTC_RCR2_PES         0x70
+#define RTC_RCR2_PEF         0x80
+
+/*
+ *      Bits in rtc.status.
+ */
+#define RTC_IS_OPEN             0x01    /* means /dev/rtc is in use     */
+
+/*
+ * The ST40 RTC supports only:
+ * 1Hz, 2Hz, 4Hz, 16Hz, 64Hz and 256Hz;
+ * the 8Hz, 32 Hz and 128 Hz are supported
+ * waiting two periodic interrupt...
+ */
+#define RTC_PERIOD_SPLIT        0x02
+#define RTC_PERIOD_CARRY        0x04
+#define RTC_INT_ALARM_VIRT_ON   0x08
+#define RTC_PERIOD           0x1ff00    /* store the period for periodic interrupt */
+
+struct stm_rtc_t {
+    unsigned long data;
+    unsigned long status;
+    unsigned long base;
+    unsigned long epoch;
+    wait_queue_head_t wait_queue;
+    rtc_task_t    *callback;
+    spinlock_t    task_lock;
+    spinlock_t    lock;
+    struct device dev;
+};
+
+static struct stm_rtc_t rtc;
+static irqreturn_t rtc_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+  unsigned char tmp;
+  switch ( this_irq ) {
+    case 20:
+        dgb_print("RTC Int alarm\n");
+        tmp = rtc_load8(rtc,RTC_RCR1);
+        rtc_store8(rtc,RTC_RCR1, tmp & ~(RTC_RCR1_AF | RTC_RCR1_AIE));
+	rtc.status |= RTC_INT_ALARM_VIRT_ON;
+        break;
+    case 21:
+        dgb_print("RTC Int periodic\n");
+        tmp = rtc_load8(rtc,RTC_RCR2);
+        rtc_store8(rtc,RTC_RCR2, tmp & ~RTC_RCR2_PEF);
+        if (   rtc.status & RTC_PERIOD_SPLIT &&
+             !(rtc.status & RTC_PERIOD_CARRY) ) {
+                   rtc.status |= RTC_PERIOD_CARRY;
+                   return IRQ_HANDLED;
+        }
+      break;
+   }
+   rtc.data++;
+   rtc.status &= ~RTC_PERIOD_CARRY;
+   spin_lock(&rtc.task_lock);
+   if (rtc.callback)
+        rtc.callback->func(rtc.callback->private_data);
+   spin_unlock(&rtc.task_lock);
+   wake_up(&rtc.wait_queue);
+   return IRQ_HANDLED;
+}
+
+static void stm_rtc_get_time(struct rtc_time *rtc_tm)
+{
+   unsigned short year;
+   unsigned char tmp;
+   unsigned char carry;
+   tmp = rtc_load8(rtc, RTC_RCR1);
+   rtc_store8(rtc, RTC_RCR1, tmp & ~RTC_RCR1_CIE);
+   do {
+      rtc_store8(rtc, RTC_RCR1, tmp & ~RTC_RCR1_CIE & ~RTC_RCR1_CF);
+      rtc_tm->tm_sec  = BCD2BIN( rtc_load8(rtc, RTC_RSECCNT ) & 0x7f );
+      rtc_tm->tm_min  = BCD2BIN( rtc_load8(rtc, RTC_RMINCNT ) & 0x7f );
+      rtc_tm->tm_hour = BCD2BIN( rtc_load8(rtc, RTC_RHRCNT  ) & 0x3f );
+      rtc_tm->tm_mday = BCD2BIN( rtc_load8(rtc, RTC_RDAYCNT ) & 0x3f );
+      rtc_tm->tm_wday = BCD2BIN( rtc_load8(rtc, RTC_RWKCNT  ) & 0x07 );
+      rtc_tm->tm_mon  = BCD2BIN( rtc_load8(rtc, RTC_RMONCNT ) & 0x1f );
+      year = rtc_load16(rtc, RTC_RYRCNT ) ;
+      rtc_tm->tm_year = BCD2BIN(  year >> 12 )         * 1000 +
+                        BCD2BIN( ( year >> 8 ) & 0xf ) * 100  +
+                        BCD2BIN( ( year >> 4 ) & 0xf ) * 10   +
+                        BCD2BIN( year & 0xf ) ;
+     carry = rtc_load8(rtc, RTC_RCR1) & RTC_RCR1_CF;
+   } while (carry != 0 );
+   rtc_store8(rtc, RTC_RCR1, tmp );
+   rtc_tm->tm_yday  = 0;
+   rtc_tm->tm_isdst = 0;
+/* Correnction */
+   rtc_tm->tm_mon--;
+   rtc_tm->tm_mday--;
+/* End Correnction */
+}
+
+static void stm_rtc_get_alarm(struct rtc_time *rtc_tm)
+{
+   unsigned short year;
+   dgb_print("\n");
+   rtc_tm->tm_sec  = BCD2BIN( rtc_load8(rtc, RTC_RSECAR) & ~RTC_AR_ENB) ;
+   rtc_tm->tm_min  = BCD2BIN( rtc_load8(rtc, RTC_RMINAR) & ~RTC_AR_ENB) ;
+   rtc_tm->tm_hour = BCD2BIN( rtc_load8(rtc, RTC_RHRAR)  & ~RTC_AR_ENB) ;
+   rtc_tm->tm_mday = BCD2BIN( rtc_load8(rtc, RTC_RDAYAR) & ~RTC_AR_ENB) ;
+   rtc_tm->tm_wday = BCD2BIN( rtc_load8(rtc, RTC_RWKAR)  & ~RTC_AR_ENB) ;
+   rtc_tm->tm_mon  = BCD2BIN( rtc_load8(rtc, RTC_RMONAR) & ~RTC_AR_ENB) ;
+   year = rtc_load16(rtc, RTC_RYRCNT ) ;
+   rtc_tm->tm_year = BCD2BIN(  year >> 12 )         * 1000 +
+                     BCD2BIN( ( year >> 8 ) & 0xf ) * 100  +
+                     BCD2BIN( ( year >> 4 ) & 0xf ) * 10   +
+                     BCD2BIN( year & 0xf ) ;
+/* Correnction */
+   rtc_tm->tm_mday--;
+   rtc_tm->tm_mon--;
+/* End Correnction */
+}
+
+static void stm_rtc_set_time(struct rtc_time *rtc_tm)
+{
+/* Correnction */
+   unsigned char  month = rtc_tm->tm_mon  + 1;
+   unsigned char  day   = rtc_tm->tm_mday + 1;
+/* End Correnction */
+   unsigned short year = rtc_tm->tm_year;
+   unsigned short year_th;
+   unsigned short year_h;
+   unsigned short year_t;
+   unsigned short year_u;
+   unsigned char tmp;
+/*
+ * turn off
+ */
+   if ( rtc_tm->tm_sec >= 60 ) {
+       rtc_tm->tm_sec = 0;
+       rtc_tm->tm_min++  ;
+       }
+   if ( rtc_tm->tm_min >= 60 ) {
+       rtc_tm->tm_min = 0;
+       rtc_tm->tm_hour++;
+       }
+   if ( rtc_tm->tm_hour >= 24 ) {
+       rtc_tm->tm_wday++;
+       rtc_tm->tm_mday++;
+       rtc_tm->tm_hour = 0;
+       }
+
+   tmp = rtc_load8(rtc, RTC_RCR2);
+   rtc_store8(rtc, RTC_RCR2, (tmp & ~RTC_RCR2_START) | RTC_RCR2_RESET);
+
+   rtc_store8(rtc, RTC_RSECCNT , BIN2BCD(rtc_tm->tm_sec  )  );
+   rtc_store8(rtc, RTC_RMINCNT , BIN2BCD(rtc_tm->tm_min  )  );
+   rtc_store8(rtc, RTC_RHRCNT  , BIN2BCD(rtc_tm->tm_hour )  );
+   rtc_store8(rtc, RTC_RDAYCNT , BIN2BCD(day )  );
+   rtc_store8(rtc, RTC_RWKCNT  , BIN2BCD(rtc_tm->tm_wday )  );
+   rtc_store8(rtc, RTC_RMONCNT , BIN2BCD(month )  );
+
+   year_th= ( year / 1000 ) ;
+   year_h = ( year - year_th*1000) / 100;
+   year_t = ( year - year_th*1000 - year_h*100) / 10;
+   year_u = ( year - year_th*1000 - year_h*100 - year_t*10);
+   rtc_store16(rtc, RTC_RYRCNT ,year_th<<12 | year_h << 8 | year_t<<4 | year_u);
+/*
+ * turn on
+ */
+   rtc_store8(rtc, RTC_RCR2, (tmp & ~RTC_RCR2_RESET) | RTC_RCR2_START | RTC_RCR2_RTCEN);
+}
+
+static void stm_rtc_set_alarm(struct rtc_time *rtc_tm)
+{
+   unsigned char tmp   ;
+   unsigned char month ;
+   unsigned char day   ;
+
+   dgb_print("\n");
+      if ( rtc_tm->tm_sec >= 60 ) {
+       rtc_tm->tm_sec = 0;
+       rtc_tm->tm_min++  ;
+       }
+   if ( rtc_tm->tm_min >= 60 ) {
+       rtc_tm->tm_min = 0;
+       rtc_tm->tm_hour++;
+       }
+   if ( rtc_tm->tm_hour >= 24 ) {
+       rtc_tm->tm_wday++;
+       rtc_tm->tm_mday++;
+       rtc_tm->tm_hour = 0;
+       }
+/* Correction */
+   month = rtc_tm->tm_mon  +1;
+   day   = rtc_tm->tm_mday +1;
+/* End Correnction */
+
+   tmp = rtc_load8(rtc, RTC_RCR1);
+   /* clear the alarm condition */
+   rtc_store8(rtc, RTC_RCR1, tmp & ~RTC_RCR1_AF);
+   /* set the alarm date */
+   rtc_store8(rtc, RTC_RSECAR , BIN2BCD(rtc_tm->tm_sec  ) | RTC_AR_ENB);
+   rtc_store8(rtc, RTC_RMINAR , BIN2BCD(rtc_tm->tm_min  ) | RTC_AR_ENB);
+   rtc_store8(rtc, RTC_RHRAR  , BIN2BCD(rtc_tm->tm_hour ) | RTC_AR_ENB);
+   rtc_store8(rtc, RTC_RDAYAR , BIN2BCD(day )             | RTC_AR_ENB);
+   rtc_store8(rtc, RTC_RWKAR  , BIN2BCD(rtc_tm->tm_wday ) | RTC_AR_ENB);
+   rtc_store8(rtc, RTC_RMONAR , BIN2BCD(month  )          | RTC_AR_ENB);
+   /* check if the interrupt is virtual on */
+   if (rtc.status & RTC_INT_ALARM_VIRT_ON) {
+       rtc.status &= ~RTC_INT_ALARM_VIRT_ON;
+       rtc_store8(rtc, RTC_RCR1, (tmp | RTC_RCR1_AIE) & ~RTC_RCR1_AF);
+   }
+}
+
+static int stm_rtc_open(struct inode *inode, struct file *filp)
+{
+  dgb_print("\n");
+
+  spin_lock_irq (&rtc.lock);
+  if( rtc.status & RTC_IS_OPEN)
+     goto out_busy;
+
+  rtc.status  = RTC_IS_OPEN;
+  rtc.data    = 0;
+  spin_unlock_irq (&rtc.lock);
+  return 0;
+
+out_busy:
+   spin_unlock_irq (&rtc.lock);
+   return -EBUSY;
+}
+
+static int stm_rtc_release(struct inode *inode, struct file *filp)
+{
+   unsigned char tmp;
+   dgb_print("\n");
+   spin_lock_irq(&rtc.lock);
+   if (rtc.status & RTC_IS_OPEN) {
+       rtc.status &= ~RTC_IS_OPEN;
+   }
+   rtc.data   = 0;
+   rtc.status = 0;
+/*
+ * turn off the interrupts
+ */
+   rtc_store8(rtc,RTC_RCR1, 0x0);
+   tmp = rtc_load8(rtc,RTC_RCR2);
+   rtc_store8(rtc,RTC_RCR2, tmp & ~(RTC_RCR2_PES | RTC_RCR2_PEF));
+   spin_unlock_irq (&rtc.lock);
+   return 0;
+}
+
+static ssize_t stm_rtc_read(struct file *filp, char __user * buff,
+                             size_t count, loff_t * offp)
+{
+   dgb_print("\n");
+   wait_event(rtc.wait_queue,rtc.data!=0);
+   copy_to_user(buff,&rtc.data,sizeof(rtc.data));
+   rtc.data = 0;
+   return sizeof(rtc.data);
+}
+
+static unsigned int stm_rtc_poll(struct file *filp, poll_table *wait)
+{
+        unsigned long l;
+
+        poll_wait(filp, &rtc.wait_queue, wait);
+
+        spin_lock_irq (&rtc.lock);
+        l = rtc.data;
+        spin_unlock_irq (&rtc.lock);
+
+        if (l != 0)
+                return POLLIN | POLLRDNORM;
+        return 0;
+}
+
+static void stm_rtc_set_period(unsigned long herz)
+{
+   unsigned char tmp = rtc_load8(rtc, RTC_RCR2) & ~RTC_RCR2_PES;
+
+   rtc.status &= ~( RTC_PERIOD_SPLIT | RTC_PERIOD_CARRY);
+
+   switch ( herz ) {
+     case 0:   rtc_store8(rtc, RTC_RCR2, tmp );
+               return;
+     case 1:   tmp |= 0x60;      break;
+     case 2:   tmp |= 0x50;      break;
+     case 4:   tmp |= 0x40;      break;
+
+     case 8:   rtc.status |= RTC_PERIOD_SPLIT;
+     case 16:  tmp |= 0x30;
+               break;
+     case 32:  rtc.status |= RTC_PERIOD_SPLIT;
+     case 64:  tmp |= 0x20;
+               break;
+     case 128: rtc.status |= RTC_PERIOD_SPLIT;
+     case 256: tmp  |= 0x10;
+               break;
+   }
+  rtc_store8(rtc, RTC_RCR2, tmp);
+}
+
+static int stm_rtc_ioctl(struct inode *inode, struct file *filp,
+                          unsigned int cmd, unsigned long arg)
+{
+struct rtc_time wtime;
+   unsigned char tmp_1;
+   unsigned char tmp_2;
+   unsigned long tmp;
+
+   tmp_1 = rtc_load8(rtc, RTC_RCR1);
+   tmp_2 = rtc_load8(rtc, RTC_RCR2);
+
+   switch (cmd) {
+     case RTC_AIE_OFF:       /* Enable/Disable alarm int.    */
+     case RTC_AIE_ON:
+          rtc.data = 0;
+          rtc.status &= ~RTC_INT_ALARM_VIRT_ON;
+          if (cmd == RTC_AIE_OFF) {
+             dgb_print("RTC_AIE_OFF\n");
+          rtc_store8(rtc, RTC_RCR1, tmp_1 & ~RTC_RCR1_AIE);
+          }
+          else {
+          dgb_print("RTC_AIE_ON\n");
+          rtc_store8(rtc, RTC_RCR1, tmp_1 | RTC_RCR1_AIE);
+          }
+          return 0;
+     case RTC_PIE_OFF:       /* Mask periodic int. enab. bit */
+     case RTC_UIE_OFF:       /* Mask ints from RTC updates.  */
+          dgb_print("RTC_PIE_OFF\n");
+          stm_rtc_set_period(0);
+          return 0;
+     case RTC_PIE_ON:        /* Allow periodic ints          */
+          dgb_print("RTC_PIE_ON\n");
+          stm_rtc_set_period(rtc.status >> 8 );
+          return 0;
+     case RTC_UIE_ON:        /* Allow ints for RTC updates. (one per second)*/
+          dgb_print("RTC_UIE_ON\n");
+          stm_rtc_set_period(1);
+           return 0;
+     case RTC_ALM_SET:       /* Store a time into the alarm */
+          dgb_print("RTC_ALM_SET\n");
+          copy_from_user(&wtime,(void *)arg,sizeof wtime);
+          stm_rtc_set_alarm(&wtime);
+          return 0;
+     case RTC_SET_TIME:      /* Set the RTC */
+          dgb_print("RTC_SET_TIME\n");
+          copy_from_user(&wtime,(void *)arg,sizeof wtime);
+          stm_rtc_set_time(&wtime);
+          return 0;
+     case RTC_ALM_READ:      /* Read the present alarm time */
+          dgb_print("RTC_ALM_READ\n");
+          stm_rtc_get_alarm(&wtime);
+          break;
+     case RTC_RD_TIME:       /* Read the time/date from RTC  */
+          dgb_print("RTC_RD_TIME\n");
+          stm_rtc_get_time(&wtime);
+          break;
+     case RTC_IRQP_READ:     /* Read the periodic IRQ rate.  */
+          dgb_print("RTC_IRQP_READ\n");
+          tmp = ( rtc.status & RTC_PERIOD ) >> 8;
+          copy_to_user( (void *)arg, &tmp,sizeof(long));
+          return 0;
+     case RTC_IRQP_SET:      /* Set periodic IRQ rate.       */
+          dgb_print("RTC_IRQP_SET %d\n",arg);
+          rtc.status &= ~RTC_PERIOD ;
+          rtc.status |= arg << 8;
+          return 0;
+     case RTC_EPOCH_READ:    /* Read the epoch.      */
+          copy_to_user((void*)arg,&rtc.epoch,sizeof(long));
+	  return 0;
+     case RTC_EPOCH_SET:     /* Set the epoch.       */
+          copy_from_user(&rtc.epoch,(void*)arg,sizeof(long));
+          return 0;
+     default:
+          return -ENOTTY;
+     }
+   copy_to_user((void *)arg, &wtime, sizeof wtime);
+   return (sizeof wtime);
+}
+
+static int __init stm_rtc_probe(struct device *dev)
+{
+   dgb_print("\n");
+   rtc_device_data = to_platform_device(dev);
+
+   if ( !rtc_device_data->name ){
+      printk(KERN_ERR
+         "Device probe failed. Check your kernel SoC config!!\n");
+   }
+   return 0;
+}
+
+static struct device_driver rtc_driver = {
+   .name = "rtc",
+   .owner = THIS_MODULE,
+   .bus = &platform_bus_type,
+   .probe = stm_rtc_probe,
+};
+
+struct file_operations stm_rtc_fops = {
+   .owner   = THIS_MODULE,
+   .llseek  = no_llseek,
+   .open    = stm_rtc_open,
+   .release = stm_rtc_release,
+   .read    = stm_rtc_read,
+   .poll    = stm_rtc_poll,
+   .ioctl   = stm_rtc_ioctl,
+};
+
+static struct miscdevice stm_rtc_miscdev = {
+   .minor = RTC_MINOR,
+   .name = "rtc",
+   .fops = &stm_rtc_fops,
+};
+
+int rtc_register(rtc_task_t *task)
+{
+   if (task == NULL || task->func == NULL)
+         return -EINVAL;
+
+/*
+ *  Check if the device is free
+ */
+   spin_lock_irq(&rtc.lock);
+   if (rtc.status & RTC_IS_OPEN) {
+         spin_unlock_irq(&rtc.lock);
+         return -EBUSY;
+   }
+/*
+ * Check if callback is free
+ */
+   spin_lock(&rtc.task_lock);
+   if (rtc.callback) {
+       spin_unlock(&rtc.task_lock);
+       spin_unlock_irq(&rtc.lock);
+       return -EBUSY;
+   }
+   rtc.status   = RTC_IS_OPEN;
+   rtc.callback = task;
+   spin_unlock(&rtc.task_lock);
+   spin_unlock_irq(&rtc.lock);
+   return 0;
+}
+
+int rtc_unregister(rtc_task_t *task)
+{
+   unsigned char tmp;
+
+   spin_lock_irq(&rtc.lock);
+   spin_lock(&rtc.task_lock);
+   if (rtc.callback != task) {
+      spin_unlock(&rtc.task_lock);
+      spin_unlock_irq(&rtc.lock);
+      return -ENXIO;
+   }
+   rtc.callback = NULL;
+
+   /* disable controls */
+   tmp = rtc_load8(rtc,RTC_RCR1);
+   rtc_store8(rtc,RTC_RCR1,tmp & ~(RTC_RCR1_AIE | RTC_RCR1_CIE) );
+   tmp = rtc_load8(rtc,RTC_RCR2);
+   rtc_store8(rtc,RTC_RCR2, tmp & ~RTC_RCR2_PES);
+   rtc.status = 0;
+
+   spin_unlock(&rtc.task_lock);
+   spin_unlock_irq(&rtc.lock);
+   return 0;
+}
+
+int rtc_control(rtc_task_t *task, unsigned int cmd, unsigned long arg)
+{
+   spin_lock_irq(&rtc.task_lock);
+   if (rtc.callback != task) {
+        spin_unlock_irq(&rtc.task_lock);
+        return -ENXIO;
+   }
+   spin_unlock_irq(&rtc.task_lock);
+   return stm_rtc_ioctl(NULL,NULL, cmd, arg);
+}
+
+void rtc_get_rtc_time(struct rtc_time *rtc_tm)
+{
+   stm_rtc_get_time(rtc_tm);
+}
+/*
+ * Request the IO memory
+ * Remap   the IO memory
+ * Request the interrupt line.
+ */
+static int stm_rtc_hw_resrc_init(void)
+{
+   struct resource *res;
+   int idx;
+   int ret;
+   dgb_print("\n");
+
+/* 1. IO Mem*/
+   res = platform_get_resource(rtc_device_data, IORESOURCE_MEM,0);
+   if (!res) {
+      printk(KERN_ERR
+	       "Error on platform_get_resource mem settings\n");
+      return -ENODEV;
+   }
+   if (!request_mem_region(res->start, res->end - res->start, "rtc")) {
+	printk(KERN_ERR
+             "ERROR: rtc %d Request MEM Region NOT Done\n",0);
+        return -ENODEV;
+   }
+   rtc.base = (unsigned long)ioremap(res->start, res->end - res->start);
+
+/* 2. Request of IRQ */
+   res = platform_get_resource(rtc_device_data, IORESOURCE_IRQ, 0);
+   if (!res) {
+     printk(KERN_ERR
+		"Error on platform_get_resource irq settings\n");
+     goto release_mem_region;
+   }
+   for (idx =0; idx < 2; ++idx) {
+      ret =  request_irq(res->start+idx, rtc_handler,SA_INTERRUPT, "rtc",NULL);
+      if ( ret < 0 ) {
+         printk(KERN_ERR "st-rtc: Error IRQ %ld with code %d\n",
+                    res->start+idx, ret);
+         goto release_irq;
+         }
+   }
+   return 0;
+
+   release_irq:
+     for (idx--; idx>-1;idx--) {
+         free_irq(res->start+idx,NULL);
+     }
+   release_mem_region:
+     res = platform_get_resource(rtc_device_data, IORESOURCE_MEM,0);
+     release_mem_region(res->start, res->end - res->start);
+   return -ENODEV;
+}
+
+static void stm_rts_hw_release(void)
+{
+   struct resource *res;
+   int idx;
+
+   dgb_print("\n");
+   res =
+       platform_get_resource(rtc_device_data, IORESOURCE_MEM,0);
+
+   release_mem_region(res->start, res->end - res->start);
+   res =
+        platform_get_resource(rtc_device_data, IORESOURCE_IRQ,0);
+   for (idx = 0; idx <2; ++idx) {
+      free_irq(res->start+idx,NULL);
+   }
+}
+
+static int __init stm_rtc_init(void)
+{
+   int rc;
+   unsigned int idx;
+   struct rtc_time tmp = { 0,0,0,0,0,0,0,0,0};
+
+   dgb_print("\n");
+   driver_register(&rtc_driver);
+
+   if (!rtc_device_data) {
+      printk(KERN_ERR "Error on RTC platform settings\n");
+      return -ENODEV;
+   }
+   dgb_print("rtc driver registered\n");
+
+   rc = misc_register(&stm_rtc_miscdev);
+   if (rc) {
+      printk(KERN_ERR
+      "STM rtc: Can't register miscdev on minor=%d (error=%d)\n",
+                       stm_rtc_miscdev.minor, rc);
+      goto drv_unregister;
+   }
+   dgb_print("rtc misc device registered\n");
+   if ( stm_rtc_hw_resrc_init() < 0 )
+      goto msc_unregister;
+
+   spin_lock_init(&rtc.lock);
+   spin_lock_init(&rtc.task_lock);
+   init_waitqueue_head(&(rtc.wait_queue));
+   rtc.epoch      = 1900; /* default value on Linux */
+   rtc.dev.driver = &rtc_driver;
+   rtc.dev.parent = &platform_bus;
+   sprintf(rtc.dev.bus_id, "rtc-%d", 0);
+
+   dgb_print("Enable RTC\n");
+   rtc_store8(rtc,RTC_RCR2, RTC_RCR2_RESET );
+   stm_rtc_set_time(&tmp );
+   rtc_store8(rtc,RTC_RCR2, RTC_RCR2_START | RTC_RCR2_RTCEN );
+   rtc_store8(rtc,RTC_RCR1, 0x0);
+/*
+ * Disable the Alarm register
+ */
+   for ( idx = 0; idx < 6 ; idx++)
+     rtc_store8(rtc,RTC_RSECAR + (idx<<2) , 0x0 );
+
+   if ( device_register(&rtc.dev) < 0 ) {
+      printk(KERN_ERR "ERROR: Incapable to register rtc device\n");
+      goto hw_release;
+   }
+   printk(KERN_INFO "strtc device initialized\n");
+   return 1;
+
+hw_release:
+   dgb_print("hardware released\n");
+   stm_rts_hw_release();
+msc_unregister:
+   dgb_print("misc device deregistered\n");
+   misc_deregister(&stm_rtc_miscdev);
+drv_unregister:
+   dgb_print("driver unregistered\n");
+   driver_unregister(&rtc_driver);
+ return -ENODEV;
+}
+
+static void __exit stm_rtc_exit(void)
+{
+   dgb_print("\n");
+
+   if (!rtc_device_data)
+      return;
+   stm_rts_hw_release();
+   driver_unregister(&rtc_driver);
+   misc_deregister(&stm_rtc_miscdev);
+}
+
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("st rtc device driver");
+MODULE_LICENSE("GPL");
+
+module_init(stm_rtc_init);
+module_exit(stm_rtc_exit);
diff -Naur linux-2.6.17.8/drivers/char/sysrq.c linux-2.6.17.8-sh/drivers/char/sysrq.c
--- linux-2.6.17.8/drivers/char/sysrq.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/sysrq.c	2006-08-23 13:29:06.909863000 +0100
@@ -38,6 +38,18 @@
 #include <linux/kexec.h>
 
 #include <asm/ptrace.h>
+#ifdef CONFIG_KGDB_SYSRQ
+#include <asm/kgdb.h>
+#define  GDB_OP &kgdb_op
+static struct sysrq_key_op kgdb_op={
+	.handler	= (void *)breakpoint,
+	.help_msg	= "kGdb ",
+	.action_msg	= "Debug breakpoint\n",
+};
+
+#else
+#define  GDB_OP NULL
+#endif
 
 /* Whether we react on sysrq keys or just ignore them */
 int sysrq_enabled = 1;
@@ -296,7 +308,7 @@
 	&sysrq_showlocks_op,		/* d */
 	&sysrq_term_op,			/* e */
 	&sysrq_moom_op,			/* f */
-	NULL,				/* g */
+	GDB_OP,				/* g */
 	NULL,				/* h */
 	&sysrq_kill_op,			/* i */
 	NULL,				/* j */
diff -Naur linux-2.6.17.8/drivers/char/watchdog/Kconfig linux-2.6.17.8-sh/drivers/char/watchdog/Kconfig
--- linux-2.6.17.8/drivers/char/watchdog/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/watchdog/Kconfig	2006-08-23 13:29:44.278738000 +0100
@@ -58,6 +58,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called softdog.
 
+# STMicroelectronics Architecture
+
+config STM_WD
+        tristate "STM Watchdog"
+        depends on WATCHDOG && CPU_SUBTYPE_ST40
+        help
+          This is the driver for the STM Watchdog.
+
 # ARM Architecture
 
 config AT91_WATCHDOG
@@ -496,6 +504,7 @@
 config SH_WDT
 	tristate "SuperH Watchdog"
 	depends on WATCHDOG && SUPERH
+	select SH_FAST_HZ
 	help
 	  This driver adds watchdog support for the integrated watchdog in the
 	  SuperH processors. If you have one of these processors and wish
diff -Naur linux-2.6.17.8/drivers/char/watchdog/Makefile linux-2.6.17.8-sh/drivers/char/watchdog/Makefile
--- linux-2.6.17.8/drivers/char/watchdog/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/watchdog/Makefile	2006-08-23 13:29:39.984622000 +0100
@@ -75,5 +75,8 @@
 
 # SPARC64 Architecture
 
+# Used on STMicroelectronics devices (SuperH and ST200 architecture)
+obj-$(CONFIG_STM_WD) += stm_wdt.o
+
 # Architecture Independant
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
diff -Naur linux-2.6.17.8/drivers/char/watchdog/stm_wdt.c linux-2.6.17.8-sh/drivers/char/watchdog/stm_wdt.c
--- linux-2.6.17.8/drivers/char/watchdog/stm_wdt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/char/watchdog/stm_wdt.c	2006-08-23 13:29:44.291738000 +0100
@@ -0,0 +1,391 @@
+/*
+   -------------------------------------------------------------------------
+   stm_wdt.c
+   -------------------------------------------------------------------------
+   (c)2005 STMicroelectronics
+   ----------------------------------------------------------------------------
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, wrssc to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  -------------------------------------------------------------------------
+
+  5th Aug 2005	Written by Francesco Virlinzi (francesco.virlinzi@st.com)
+  9th Aug 2005 	Now uses linux/watchdog.h for ioctl definitions
+  		Added platform support and changed to a miscdevice
+	       	Added shutdown notifier support
+  		Added WATCHDOG_NOWAYOUT support
+  						Carl Shaw <carl.shaw@st.com>
+  29th ug 2005  Added ST40 support
+  		               Francesco Virlinzi <francesco.virlinzi@st.com>
+
+*/
+
+#include <linux/ioport.h>
+#include <linux/vmalloc.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/platform.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/timer.h>
+#include <linux/reboot.h>
+#include <linux/notifier.h>
+#include <linux/st_soc.h>
+#include <asm/semaphore.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/param.h>		/* for HZ */
+
+/*
+ * #define CONFIG_STM_WDT_DEBUG
+ */
+
+#undef DPRINTK(fmt, args...)
+
+#ifdef  CONFIG_STM_WDT_DEBUG
+#define DPRINTK(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define WDT_STARTING_TIMEOUT             15
+
+/*
+ * ST40 (SH4) Arch
+ */
+#define WDT_COUNT                        0x0
+#define WDT_CFG                          0x4
+
+#define WDT_CFG_CLOCK                    0x7
+#define WDT_CFG_TMR_OVERFLOW             0x8
+#define WDT_CFG_WTD_OVERFLOW             0x10
+#define WDT_CFG_RESET                    0x20
+#define WDT_CFG_MODE                     0x40
+#define WDT_CFG_ENABLE                   0x80
+
+#define wdt_store8(wdt , offset, value) {  \
+              if ( offset ) iowrite16(0xA500 | (value & 0xff), (void *)wdt->base+offset); \
+              else          iowrite16(0x5A00 | (value & 0xff), (void *)wdt->base+offset); }
+
+#define wdt_load8(wdt , offset)            ioread8((void *)(wdt->base+offset))
+
+
+struct stm_wdt_s {
+	unsigned int status;
+	unsigned long timeout;
+	unsigned long base;
+};
+
+static struct stm_wdt_s stm_watchdog;
+
+#define WDT_STATUS_ENABLE               0x01
+#define WDT_STATUS_DISABLE_ON_CLOSE     0x02
+
+static struct platform_device *wdt_device_data;
+
+#if !defined(CONFIG_WATCHDOG_NOWAYOUT)
+static int stm_wdt_nowayout = 0;
+#else
+static int stm_wdt_nowayout = 1;
+#endif
+
+/*
+ *   This function will be called if and only if
+ *   the user application doesn't say that it is ok
+ */
+static void stm_wdt_fired(unsigned long data)
+{
+	struct stm_wdt_s *wdt = &(stm_watchdog);
+
+	printk(KERN_WARNING "Heartbeat lost! Will not ping the watchdog\n");
+	wdt_store8(wdt, WDT_COUNT, 0x0);
+	wdt_store8(wdt, WDT_CFG, WDT_CFG_ENABLE |
+		   WDT_CFG_MODE | WDT_CFG_RESET | 0x7);
+}
+
+static struct timer_list timer = {
+	.function = stm_wdt_fired,
+	.data = 0,
+};
+
+static ssize_t stm_wdt_read(struct file *filp,
+			    char __user * buff, size_t count, loff_t * offp)
+{
+	DPRINTK("\n");
+
+	return count;
+}
+
+static ssize_t stm_wdt_write(struct file *filp,
+			     const char __user * buff,
+			     size_t count, loff_t * offp)
+{
+	unsigned short reg_reset;
+	char V;
+	struct stm_wdt_s *wdt = (struct stm_wdt_s *)filp->private_data;
+
+	copy_from_user(&V, buff, 1);
+	/* If the user writes a "V" then this prepares driver for
+	 * shutting down the watchdog.  The write must then be followed
+	 * by a close()
+	 */
+
+	if (V == 'V') {
+		DPRINTK("Disable on Close\n");
+		wdt->status |= WDT_STATUS_DISABLE_ON_CLOSE;
+	} else {
+		DPRINTK("NOT Disable on Close\n");
+		wdt->status &= ~WDT_STATUS_DISABLE_ON_CLOSE;
+	}
+
+/*
+ * We have to reset the timeout counter
+ */
+	mod_timer(&timer, jiffies + (wdt->timeout * HZ));
+	return count;
+}
+
+static int stm_wdt_ioctl(struct inode *inode,
+			 struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned short reg_reset;
+	struct stm_wdt_s *wdt = (struct stm_wdt_s *)filp->private_data;
+	unsigned long timeout_in_tick = jiffies + (wdt->timeout * HZ);
+
+	DPRINTK("\n");
+	switch (cmd) {
+	case WDIOC_KEEPALIVE:
+		DPRINTK("Reset TimeOut\n");
+		mod_timer(&timer, timeout_in_tick);
+		break;
+	case WDIOC_SETTIMEOUT:
+		DPRINTK("Set TimeOut to %ld seconds\n", arg);
+		wdt->timeout = (unsigned int)(arg & 0xfffff);
+		mod_timer(&timer, timeout_in_tick);
+		break;
+	case WDIOC_GETTIMEOUT:
+		DPRINTK("Get TimeOut value of %ld seconds\n", wdt->timeout);
+		copy_to_user((void __user *)arg, &(wdt->timeout), sizeof(long));
+		break;
+	default:
+		;
+	}
+
+	return 0;
+}
+
+static int stm_wdt_open(struct inode *inode, struct file *filp)
+{
+	struct stm_wdt_s *wdt = &stm_watchdog;
+	DPRINTK("\n");
+
+	if (stm_wdt_nowayout)
+		__module_get(THIS_MODULE);
+
+	wdt->timeout = WDT_STARTING_TIMEOUT;
+	wdt->status = WDT_STATUS_ENABLE;
+/*
+ *      Set the next timeout in tick
+ */
+	mod_timer(&timer, jiffies + (wdt->timeout * HZ));
+	wdt_store8(wdt, WDT_CFG, ~WDT_CFG_ENABLE);
+	filp->private_data = wdt;
+	return nonseekable_open(inode, filp);
+}
+
+static int stm_wdt_release(struct inode *inode, struct file *filp)
+{
+	struct stm_wdt_s *wdt = (struct stm_wdt_s *)filp->private_data;
+
+	DPRINTK("\n");
+	if (wdt->status & WDT_STATUS_DISABLE_ON_CLOSE) {
+		if (stm_wdt_nowayout) {
+			printk(KERN_CRIT
+			       "STM watchdog: nowayout is set. NOT disabling watchdog!");
+		} else {
+			DPRINTK("TimeOut disabled\n");
+			del_timer(&timer);
+			wdt_store8(wdt, WDT_CFG, ~WDT_CFG_ENABLE);
+		}
+	} else {
+		printk(KERN_CRIT
+		       "STM watchdog not notified of closure. NOT disabling watchdog!");
+	}
+/*
+ * If the user application didn't send a V char
+ * during the close we will not disable the watchdog
+ */
+	return 0;
+}
+
+/* Disable the watchdog if we are doing a system halt */
+static int stm_wdt_notify_sys(struct notifier_block *this,
+			      unsigned long code, void *unused)
+{
+	struct stm_wdt_s *wdt = &stm_watchdog;
+
+	if (code == SYS_DOWN || code == SYS_HALT) {
+		DPRINTK("Watchdog notified of SYS_DOWN or SYS_HALT!!\n");
+		if (stm_wdt_nowayout) {
+			printk(KERN_CRIT
+			       "STM watchdog: nowayout is set. NOT disabling watchdog on shutdown!");
+		} else {
+			DPRINTK("TimeOut disabled\n");
+			wdt_store8(wdt, WDT_CFG, ~WDT_CFG_ENABLE);
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block stm_wdt_notifier = {
+	.notifier_call = stm_wdt_notify_sys,
+};
+
+struct file_operations stm_wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = stm_wdt_open,
+	.release = stm_wdt_release,
+	.read = stm_wdt_read,
+	.write = stm_wdt_write,
+	.ioctl = stm_wdt_ioctl
+};
+/*
+static ssize_t stm_wdt_show_timeout(struct device *dev, char *buf)
+{
+   struct stm_wdt_s *wdt = &stm_watchdog;
+   return sprintf(buf,"%d\n",wdt->timeout);
+
+}
+static ssize_t stm_wdt_store_timeout(struct device *dev, char *buf,
+                                      size_t count)
+{
+     struct stm_wdt_s *wdt = &stm_watchdog;
+     unsigned int value;
+     if ( sscanf(buf,"%d",&value) != 1)
+        return -EINVAL;
+     wdt->timeout = value;
+     return strlen(buf);
+}
+
+static DEVICE_ATTR(timeout, S_IRUGO | S_IWUGO, stm_wdt_show_timeout, stm_wdt_store_timeout);
+*/
+static int __init stm_wdt_probe(struct device *dev)
+{
+	wdt_device_data = to_platform_device(dev);
+
+	if (wdt_device_data->name != NULL)
+		printk(KERN_INFO
+		       "Device probe found data for platform device %s\n",
+		       wdt_device_data->name);
+	else
+		printk(KERN_ERR
+		       "Device probe failed.  Check your kernel SoC config!!\n");
+
+	return 0;
+}
+
+static struct device_driver wdt_driver = {
+	.name = "wdt",
+	.bus = &platform_bus_type,
+	.probe = stm_wdt_probe,
+};
+
+static struct miscdevice stm_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &stm_wdt_fops,
+};
+
+static int __init stm_watchdog_init(void)
+{
+	struct stm_wdt_s *wdt = &stm_watchdog;
+	struct resource *res;
+	int rc;
+
+	rc = register_reboot_notifier(&stm_wdt_notifier);
+	if (rc) {
+		printk(KERN_ERR "Can't register reboot notifier (err=%d)\n",
+		       rc);
+		return rc;
+	}
+
+	driver_register(&wdt_driver);
+/*
+ *      driver_create_file(&wdt_driver,&dev_attr_timeout);
+ */
+	res = platform_get_resource(wdt_device_data, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR
+		       "ERROR: IO MEM configuration information not found\n");
+		driver_unregister(&wdt_driver);
+		unregister_reboot_notifier(&stm_wdt_notifier);
+		return -ENODEV;
+	}
+
+	rc = misc_register(&stm_wdt_miscdev);
+	if (rc) {
+		printk(KERN_ERR
+		       "STM watchdog: Can't register miscdev on minor=%d (error=%d)\n",
+		       stm_wdt_miscdev.minor, rc);
+		driver_unregister(&wdt_driver);
+		misc_deregister(&stm_wdt_miscdev);
+		unregister_reboot_notifier(&stm_wdt_notifier);
+		return rc;
+	}
+
+	if (!request_mem_region
+	    (res->start, res->end - res->start, "STM-watchdog")) {
+		printk(KERN_ERR
+		       " Request for register memory failed for STM watchdog\n");
+		driver_unregister(&wdt_driver);
+		misc_deregister(&stm_wdt_miscdev);
+		unregister_reboot_notifier(&stm_wdt_notifier);
+		return -EBUSY;
+	};
+
+	wdt->base = (unsigned long)ioremap(res->start, res->end - res->start);
+	wdt->status = 0;
+	wdt->timeout = 0;
+/*
+ *   The ST40 needs an internal timer to play with the watchdog...
+ */
+	init_timer(&timer);
+	printk(KERN_INFO "STM watchdog initialized\n");
+
+	return 0;
+}
+
+static void __exit stm_watchdog_exit(void)
+{
+	driver_unregister(&wdt_driver);
+	misc_deregister(&stm_wdt_miscdev);
+	unregister_reboot_notifier(&stm_wdt_notifier);
+}
+
+module_param(stm_wdt_nowayout, int, 0);
+MODULE_PARM_DESC(stm_wdt_nowayout,
+		 "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
+
+module_init(stm_watchdog_init);
+module_exit(stm_watchdog_exit);
+
+MODULE_AUTHOR("Francesco Virlinzi <francesco.virlinzi@st.com>");
+MODULE_DESCRIPTION("ST watchdog driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -Naur linux-2.6.17.8/drivers/hwmon/Kconfig linux-2.6.17.8-sh/drivers/hwmon/Kconfig
--- linux-2.6.17.8/drivers/hwmon/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/hwmon/Kconfig	2006-08-23 13:29:50.654875000 +0100
@@ -349,6 +349,17 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called smsc47b397.
 
+config SENSORS_STM_PWM
+	tristate "STM PWM Support"
+	depends on HWMON && CPU_SUBTYPE_ST40
+	default n
+	help
+	  This is a simple driver for the PWM (Pulse Width Modulation)
+	  hardware present on many ST chips. Although the PWM hardware can
+	  be used for many things, this driver simply allows the mark/space
+	  ratio to be set, which is sufficient for many purposes, including
+	  controlling the speed of a fan.
+
 config SENSORS_VIA686A
 	tristate "VIA686A"
 	depends on HWMON && I2C && PCI
diff -Naur linux-2.6.17.8/drivers/hwmon/Makefile linux-2.6.17.8-sh/drivers/hwmon/Makefile
--- linux-2.6.17.8/drivers/hwmon/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/hwmon/Makefile	2006-08-23 13:29:50.680875000 +0100
@@ -40,6 +40,7 @@
 obj-$(CONFIG_SENSORS_SIS5595)	+= sis5595.o
 obj-$(CONFIG_SENSORS_SMSC47B397)+= smsc47b397.o
 obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
+obj-$(CONFIG_SENSORS_STM_PWM)	+= stm-pwm.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_VT8231)	+= vt8231.o
 obj-$(CONFIG_SENSORS_W83627EHF)	+= w83627ehf.o
diff -Naur linux-2.6.17.8/drivers/hwmon/stm-pwm.c linux-2.6.17.8-sh/drivers/hwmon/stm-pwm.c
--- linux-2.6.17.8/drivers/hwmon/stm-pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/hwmon/stm-pwm.c	2006-08-23 13:29:50.686875000 +0100
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2006 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Contains code copyright (C) Echostar Technologies Corporation
+ * Author: Anthony Jackson <anthony.jackson@echostar.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/st_soc.h>
+#include <asm/io.h>
+
+struct stm_pwm {
+	struct resource *mem;
+	void* base;
+	struct class_device *class_dev;
+};
+
+/* PWM registers */
+#define PWM0_VAL		0x00
+#define PWM1_VAL		0x04
+#define PWM_CTRL		0x50
+#define PWM_CTRL_PWM_EN			(1<<9)
+#define PWM_CTRL_PWM_CLK_VAL0_SHIFT	0
+#define PWM_CTRL_PWM_CLK_VAL0_MASK	0x0f
+#define PWM_CTRL_PWM_CLK_VAL4_SHIFT	11
+#define PWM_CTRL_PWM_CLK_VAL4_MASK	0xf0
+#define PWM_INT_EN		0x54
+
+/* Prescale value (clock dividor):
+ * 0: divide by 1
+ * 0xff: divide by 256 */
+#define PWM_CLK_VAL		0
+
+static ssize_t show_pwm(struct device *dev, char * buf, int offset)
+{
+	struct stm_pwm *pwm = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%ld\n", readl(pwm->base + offset));
+}
+
+static ssize_t store_pwm(struct device *dev, const char * buf, size_t count,
+			 int offset)
+{
+	struct stm_pwm *pwm = dev_get_drvdata(dev);
+	char* p;
+	long val = simple_strtol(buf, &p, 10);
+
+	if (p != buf) {
+		val &= 0xff;
+		writel(val, pwm->base + offset);
+		return p-buf;
+	}
+	return -EINVAL;
+}
+
+#define pwm_fns(n)							\
+static ssize_t								\
+show_pwm##n(struct device *dev,	struct device_attribute *attr,		\
+	    char *buf)							\
+{									\
+	return show_pwm(dev, buf, PWM##n##_VAL);			\
+}									\
+static ssize_t								\
+store_pwm##n(struct device *dev, struct device_attribute *attr,		\
+	     const char *buf, size_t count)				\
+{									\
+	return store_pwm(dev, buf, count, PWM##n##_VAL);		\
+}									\
+static DEVICE_ATTR(pwm##n, S_IRUGO| S_IWUSR, show_pwm##n, store_pwm##n);
+
+pwm_fns(0)
+pwm_fns(1)
+
+static void
+stm_pwm_init(struct platform_device* pdev, struct stm_pwm *pwm,
+	     struct plat_stm_pwm_data *pwm_private_info)
+{
+	u32 reg = 0;
+
+	/* disable PWM if currently running */
+	reg = readl(pwm->base + PWM_CTRL);
+	reg &= ~PWM_CTRL_PWM_EN;
+	writel(reg, pwm->base + PWM_CTRL);
+
+	/* disable all PWM related interrupts */
+	reg = 0;
+	writel(reg, pwm->base + PWM_INT_EN);
+
+	/* Set global PWM state:
+	 * disable capture... */
+	reg = 0;
+
+	/* set prescale value... */
+	reg |= (PWM_CLK_VAL & PWM_CTRL_PWM_CLK_VAL0_MASK) << PWM_CTRL_PWM_CLK_VAL0_SHIFT;
+	reg |= (PWM_CLK_VAL & PWM_CTRL_PWM_CLK_VAL4_MASK) << PWM_CTRL_PWM_CLK_VAL4_SHIFT;
+
+	/* enable */
+	reg |= PWM_CTRL_PWM_EN;
+	writel(reg, pwm->base + PWM_CTRL);
+
+	/* Initial value */
+	writel(0, pwm->base + PWM0_VAL);
+	writel(0, pwm->base + PWM1_VAL);
+
+	if (pwm_private_info->flags & PLAT_STM_PWM_OUT0) {
+		device_create_file(&pdev->dev, &dev_attr_pwm0);
+	}
+	if (pwm_private_info->flags & PLAT_STM_PWM_OUT1) {
+		device_create_file(&pdev->dev, &dev_attr_pwm1);
+	}
+}
+
+static int stm_pwm_probe(struct platform_device *pdev)
+{
+	struct plat_stm_pwm_data *pwm_private_info = pdev->dev.platform_data;
+	struct resource *res;
+	struct stm_pwm *pwm;
+	int err;
+
+	pwm = kmalloc(sizeof(struct stm_pwm), GFP_KERNEL);
+	if (pwm == NULL) {
+		return -ENOMEM;
+	}
+	memset(pwm, 0, sizeof(*pwm));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+                err = -ENODEV;
+		goto failed1;
+	}
+
+	pwm->mem = request_mem_region(res->start, res->end - res->start + 1, "stm-pwn");
+	if (pwm->mem == NULL) {
+		dev_err(&pdev->dev, "failed to claim memory region\n");
+                err = -EBUSY;
+		goto failed1;
+	}
+
+	pwm->base = ioremap(res->start, res->end - res->start + 1);
+	if (pwm->base == NULL) {
+		dev_err(&pdev->dev, "failed ioremap");
+		err = -EINVAL;
+		goto failed2;
+	}
+
+	pwm->class_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(pwm->class_dev)) {
+		err = PTR_ERR(pwm->class_dev);
+		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
+		goto failed3;
+	}
+
+	platform_set_drvdata(pdev, pwm);
+	dev_info(&pdev->dev, "registers at 0x%lx, mapped to 0x%p\n",
+		 res->start, pwm->base);
+
+	stm_pwm_init(pdev, pwm, pwm_private_info);
+
+	return 0;
+
+failed3:
+	iounmap(pwm->base);
+failed2:
+	release_resource(pwm->mem);
+failed1:
+	kfree(pwm);
+	return err;
+}
+
+static int stm_pwm_remove(struct platform_device *dev)
+{
+	struct stm_pwm *pwm = platform_get_drvdata(dev);
+	if (pwm) {
+		hwmon_device_unregister(pwm->class_dev);
+		iounmap(pwm->base);
+		release_resource(pwm->mem);
+		kfree(pwm);
+	}
+	return 0;
+}
+
+static struct platform_driver stm_pwm_driver = {
+	.driver = {
+		.name		= "stm-pwm",
+	},
+	.probe		= stm_pwm_probe,
+	.remove		= stm_pwm_remove,
+};
+
+static int __init stm_pwm_module_init(void)
+{
+	return platform_driver_register(&stm_pwm_driver);
+}
+
+static void __exit stm_pwm_module_exit(void)
+{
+	platform_driver_unregister(&stm_pwm_driver);
+}
+
+module_init(stm_pwm_module_init);
+module_exit(stm_pwm_module_exit);
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics simple PWM driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/i2c/algos/i2c-algo-voyager.c linux-2.6.17.8-sh/drivers/i2c/algos/i2c-algo-voyager.c
--- linux-2.6.17.8/drivers/i2c/algos/i2c-algo-voyager.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/algos/i2c-algo-voyager.c	2006-08-23 13:29:07.688886000 +0100
@@ -0,0 +1,415 @@
+/* -------------------------------------------------------------------- */
+/* i2c-algo-voyagergx.c:                                                */
+/* -------------------------------------------------------------------- */
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Copyright 2003 (c) Lineo uSolutions,Inc.
+    Copyright 2004 (c) Paul Mundt
+*/
+/* -------------------------------------------------------------------- */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+
+#include <linux/i2c.h>
+#include "i2c-algo-voyager.h"
+
+/* ----- global defines ----------------------------------------------- */
+#define DEB(x) if (i2c_debug>=1) x
+#define DEB2(x) if (i2c_debug>=2) x
+#define DEB3(x) if (i2c_debug>=3) x /* print several statistical values*/
+#define DEBPROTO(x) if (i2c_debug>=9) x;
+ 	/* debug the protocol by showing transferred bits */
+#define DEF_TIMEOUT 16
+
+/* debugging - slow down transfer to have a look at the data .. 	*/
+/* I use this with two leds&resistors, each one connected to sda,scl 	*/
+/* respectively. This makes sure that the algorithm works. Some chips   */
+/* might not like this, as they have an internal timeout of some mils	*/
+
+
+/* ----- global variables ---------------------------------------------	*/
+
+/* module parameters:
+ */
+static int i2c_debug=0;
+
+/* --- setting states on the bus with the right timing: ---------------	*/
+
+#define iic_outb(adap, reg, val) adap->setiic(adap->data, reg, val)
+#define iic_inb(adap, reg) adap->getiic(adap->data, reg)
+
+/* --- other auxiliary functions --------------------------------------	*/
+
+static void iic_start(struct i2c_algo_iic_data *adap)
+{
+	unsigned char ctl;
+ 	ctl = iic_inb(adap, I2C_CONTROL);
+	ctl = (ctl | I2C_CONTROL_STATUS);
+	DEB(printk("iic_start I2C_CONTROL = 0x%x\n", ctl));
+	iic_outb(adap,I2C_CONTROL,ctl);
+}
+
+static void iic_stop(struct i2c_algo_iic_data *adap)
+{
+	unsigned char ctl;
+	ctl = iic_inb(adap, I2C_CONTROL);
+	ctl = (ctl & ~I2C_CONTROL_STATUS);
+	DEB(printk("iic_stop I2C_CONTROL = 0x%x\n", ctl));
+	iic_outb(adap,I2C_CONTROL,ctl);
+}
+
+static void iic_reset(struct i2c_algo_iic_data *adap)
+{
+	unsigned char ctl;
+	ctl = iic_inb(adap, I2C_RESET);
+	ctl = (ctl & ~I2C_RESET_ERROR);
+	DEB(printk("iic_reset I2C_CONTROL = 0x%x\n", ctl));
+	iic_outb(adap,I2C_RESET,ctl);
+}
+
+
+static int wait_for_bb(struct i2c_algo_iic_data *adap)
+{
+	int timeout = DEF_TIMEOUT;
+	char status;
+
+	status = iic_inb(adap, I2C_STATUS);
+#ifndef STUB_I2C
+	while (timeout-- && (status & I2C_STATUS_BUSY)) {
+		udelay(1000); /* How much is this? */
+		status = iic_inb(adap, I2C_STATUS);
+	}
+#endif
+	if (timeout<=0) {
+		printk(KERN_ERR "Timeout, host is busy (%d)\n",timeout);
+		iic_reset(adap);
+	}
+	return(timeout<=0);
+}
+
+/*
+ * Puts this process to sleep for a period equal to timeout
+ */
+static inline void iic_sleep(unsigned long timeout)
+{
+	schedule_timeout( timeout * HZ);
+}
+
+static int wait_for_pin(struct i2c_algo_iic_data *adap, char *status)
+{
+	int timeout = DEF_TIMEOUT;
+
+	timeout = wait_for_bb(adap);
+	if (timeout) {
+  		DEB2(printk("Timeout waiting for host not busy\n");)
+  		return -EIO;
+	}
+
+	timeout = DEF_TIMEOUT;
+
+	*status = iic_inb(adap, I2C_STATUS);
+	while (timeout-- && !(*status & I2C_STATUS_ACK)) {
+	   adap->waitforpin();
+	   *status = iic_inb(adap, I2C_STATUS);
+	}
+	if (timeout <= 0)
+		return(-1);
+	else
+		return(0);
+}
+
+/* Verify the device we want to talk to on the IIC bus really exists. */
+static inline int try_address(struct i2c_algo_iic_data *adap,
+		       unsigned int addr, int retries)
+{
+	int i, ret = -1;
+	unsigned char status;
+
+	for (i=0;i<retries;i++) {
+		iic_outb(adap, I2C_SADDRESS, addr);
+		iic_start(adap);
+		if (wait_for_pin(adap, &status) == 0) {
+			ret=1;
+			break;	/* success! */
+		}
+		iic_stop(adap);
+		udelay(adap->udelay);
+	}
+	DEB2(if (i) printk("try_address: needed %d retries for 0x%x\n",i,
+	                   addr));
+	return ret;
+}
+
+int iic_sendbytes(struct i2c_adapter *i2c_adap,const char *buf,
+                         int count)
+{
+	struct i2c_algo_iic_data	*adap = i2c_adap->algo_data;
+	int				wrcount,timeout,i;
+	unsigned char			*addr,status;
+
+	if (count != PACKET_SIZE)
+		return -EPROTO;
+
+	iic_outb(adap,I2C_BYTECOUNT,(unsigned char)(count - 1));
+	iic_outb(adap,I2C_SADDRESS,(unsigned char)SERIAL_WRITE_ADDR);
+
+	timeout = wait_for_bb(adap);
+	if (timeout)
+		return -ETIMEDOUT;
+
+	wrcount	= 0;
+	addr	= (unsigned char *)I2C_DATA;
+
+	for (i = 0;i < count;i++){
+		iic_outb(adap,(int)addr++,buf[wrcount++]);
+	}
+
+	iic_start(adap);
+
+	/* Wait for transmission to complete */
+	timeout = wait_for_pin(adap,&status);
+	if (timeout){
+		iic_stop(adap);
+		printk("iic_sendbytes: %s write timeout.\n", i2c_adap->name);
+		return -EREMOTEIO; /* got a better one ?? */
+     	}
+
+	iic_stop(adap);
+
+	return wrcount;
+}
+
+static int iic_readbytes(struct i2c_adapter *i2c_adap, char *buf, int count,
+	int sread)
+{
+	struct i2c_algo_iic_data	*adap = i2c_adap->algo_data;
+	int				rdcount,timeout,i;
+	unsigned char			*addr,wk,status;
+
+	iic_outb(adap,I2C_BYTECOUNT,(unsigned char)(PACKET_SIZE - 1));
+	iic_outb(adap,I2C_SADDRESS,(unsigned char)SERIAL_READ_ADDR);
+
+	rdcount	= 0;
+	addr	= (unsigned char *)I2C_DATA;
+
+	iic_start(adap);
+
+	timeout = wait_for_pin(adap,&status);
+	if (timeout){
+		iic_stop(adap);
+		printk("iic_readbytes: %s read timeout.\n", i2c_adap->name);
+		return -EREMOTEIO; /* got a better one ?? */
+     	}
+
+	for (i = 0;i < PACKET_SIZE;i++){
+		wk = iic_inb(adap,(int)addr++);
+		buf[rdcount++] = wk;
+	}
+
+	iic_stop(adap);
+
+	return rdcount;
+}
+
+/* Whenever we initiate a transaction, the first byte clocked
+ * onto the bus after the start condition is the address (7 bit) of the
+ * device we want to talk to.  This function manipulates the address specified
+ * so that it makes sense to the hardware when written to the IIC peripheral.
+ *
+ * Note: 10 bit addresses are not supported in this driver, although they are
+ * supported by the hardware.  This functionality needs to be implemented.
+ */
+static inline int iic_doAddress(struct i2c_algo_iic_data *adap,
+                                struct i2c_msg *msg, int retries)
+{
+	unsigned int addr;
+	int ret;
+
+	addr = ( msg->addr << 1 );
+
+	if (iic_inb(adap, I2C_SADDRESS) != addr) {
+		iic_outb(adap, I2C_SADDRESS, addr);
+		ret = try_address(adap, addr, retries);
+		if (ret!=1) {
+			printk("iic_doAddress: died at address code.\n");
+				return -EREMOTEIO;
+		}
+	}
+
+	return 0;
+}
+
+
+/* Description: Prepares the controller for a transaction (clearing status
+ * registers, data buffers, etc), and then calls either iic_readbytes or
+ * iic_sendbytes to do the actual transaction.
+ *
+ * still to be done: Before we issue a transaction, we should
+ * verify that the bus is not busy or in some unknown state.
+ */
+static int iic_xfer(struct i2c_adapter *i2c_adap,
+		    struct i2c_msg msgs[],
+		    int num)
+{
+	struct i2c_algo_iic_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *pmsg;
+	int i = 0;
+	int ret, timeout;
+
+	pmsg = &msgs[i];
+
+	if(!pmsg->len) {
+		DEB2(printk("iic_xfer: read/write length is 0\n");)
+		return -EIO;
+	}
+
+	/* Wait for any pending transfers to complete */
+	timeout = wait_for_bb(adap);
+	if (timeout) {
+		DEB2(printk("iic_xfer: Timeout waiting for host not busy\n");)
+		return -EIO;
+	}
+
+	/* Load address */
+	ret = iic_doAddress(adap, pmsg, i2c_adap->retries);
+	if (ret)
+		return -EIO;
+
+	DEB3(printk("iic_xfer: Msg %d, addr=0x%x, flags=0x%x, len=%d\n",
+		i, msgs[i].addr, msgs[i].flags, msgs[i].len);)
+
+	if (pmsg->flags & I2C_M_RD) {		/* Read */
+		ret = iic_readbytes(i2c_adap, pmsg->buf, pmsg->len, 0);
+	} else {				/* Write */
+		udelay(1000);
+		ret = iic_sendbytes(i2c_adap, pmsg->buf, pmsg->len);
+	}
+
+	if (ret != pmsg->len) {
+		DEB3(printk("iic_xfer: error or fail on read/write %d bytes.\n",ret));
+	} else {
+		DEB3(printk("iic_xfer: read/write %d bytes.\n",ret));
+	}
+
+	return ret;
+}
+
+
+/* Implements device specific ioctls.  Higher level ioctls can
+ * be found in i2c-core.c and are typical of any i2c controller (specifying
+ * slave address, timeouts, etc).  These ioctls take advantage of any hardware
+ * features built into the controller for which this algorithm-adapter set
+ * was written.  These ioctls allow you to take control of the data and clock
+ * lines and set the either high or low,
+ * similar to a GPIO pin.
+ */
+static int algo_control(struct i2c_adapter *adapter,
+	unsigned int cmd, unsigned long arg)
+{
+	struct i2c_iic_msg s_msg;
+	char *buf;
+	int ret;
+
+	if (cmd == I2C_SREAD) {
+		if(copy_from_user(&s_msg, (struct i2c_iic_msg *)arg,
+				sizeof(struct i2c_iic_msg)))
+			return -EFAULT;
+		buf = kmalloc(s_msg.len, GFP_KERNEL);
+		if (buf== NULL)
+			return -ENOMEM;
+
+		ret = iic_readbytes(adapter, buf, s_msg.len, 1);
+		if (ret>=0) {
+			if(copy_to_user( s_msg.buf, buf, s_msg.len) )
+				ret = -EFAULT;
+		}
+		kfree(buf);
+	}
+	return 0;
+}
+
+
+static u32 iic_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |
+	       I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+/* -----exported algorithm data: -------------------------------------	*/
+
+static struct i2c_algorithm iic_algo = {
+	.name		= "VoyagerGX I2C algorithm",
+	.id		= I2C_ALGO_VOYAGER,
+	.master_xfer	= iic_xfer,
+	.algo_control	= algo_control,
+	.functionality	= iic_func,
+};
+
+
+/*
+ * registering functions to load algorithms at runtime
+ */
+int i2c_voyager_add_bus(struct i2c_adapter *adap)
+{
+	DEB2(printk("i2c-algo-voyagergx: hw routines for %s registered.\n",
+	            adap->name));
+
+	adap->id |= iic_algo.id;
+	adap->algo = &iic_algo;
+
+	adap->timeout = 100;	/* default values, should	*/
+	adap->retries = 3;		/* be replaced by defines	*/
+	adap->flags = 0;
+
+	return i2c_add_adapter(adap);
+}
+
+
+int i2c_voyager_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+int __init i2c_algo_iic_init (void)
+{
+	printk(KERN_INFO "VoyagerGX iic (i2c) algorithm module\n");
+	return 0;
+}
+
+void i2c_algo_iic_exit(void)
+{
+}
+
+MODULE_AUTHOR("Lineo uSolutions,Inc. <www.lineo.co.jp>");
+MODULE_DESCRIPTION("VoyagerGX I2C algorithm");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(i2c_debug,"i");
+MODULE_PARM_DESC(i2c_debug,
+        "debug level - 0 off; 1 normal; 2,3 more verbose; 9 iic-protocol");
+
+module_init(i2c_algo_iic_init);
+module_exit(i2c_algo_iic_exit);
diff -Naur linux-2.6.17.8/drivers/i2c/algos/i2c-algo-voyager.h linux-2.6.17.8-sh/drivers/i2c/algos/i2c-algo-voyager.h
--- linux-2.6.17.8/drivers/i2c/algos/i2c-algo-voyager.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/algos/i2c-algo-voyager.h	2006-08-23 13:29:28.037346000 +0100
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------------- */
+/* i2c-algo-ite.h i2c driver algorithms for ITE IIC adapters                 */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 1995-97 Simon G. Vogl
+                   1998-99 Hans Berglund
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
+/* ------------------------------------------------------------------------- */
+
+/* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
+   Frodo Looijaard <frodol@dds.nl> */
+
+/* Modifications by MontaVista Software, 2001
+   Changes made to support the ITE IIC peripheral */
+
+
+#ifndef I2C_ALGO_ITE_H
+#define I2C_ALGO_ITE_H 1
+
+#include <linux/i2c.h>
+#include <asm/voyagergx.h>
+
+/* Example of a sequential read request:
+	struct i2c_iic_msg s_msg;
+
+	s_msg.addr=device_address;
+	s_msg.len=length;
+	s_msg.buf=buffer;
+	s_msg.waddr=word_address;
+	ioctl(file,I2C_SREAD, &s_msg);
+ */
+#define I2C_SREAD	0x780	/* SREAD ioctl command */
+
+struct i2c_iic_msg {
+	__u16 addr;	/* device address */
+	__u16 waddr;	/* word address */
+	short len;	/* msg length */
+	char *buf;	/* pointer to msg data */
+};
+
+struct i2c_algo_iic_data {
+	void *data;		/* private data for lolevel routines	*/
+	void (*setiic) (void *data, int ctl, int val);
+	int  (*getiic) (void *data, int ctl);
+	int  (*getown) (void *data);
+	int  (*getclock) (void *data);
+	void (*waitforpin) (void);
+
+	/* local settings */
+	int udelay;
+	int mdelay;
+	int timeout;
+};
+
+int i2c_voyager_add_bus(struct i2c_adapter *);
+int i2c_voyager_del_bus(struct i2c_adapter *);
+
+//#define TC56XX
+#define OV7640
+//#define OV7141
+
+#if defined(TC56XX)
+#define PACKET_SIZE		4
+#define SERIAL_WRITE_ADDR	((0x56 << 1) + 0)	//0xAC
+#define SERIAL_READ_ADDR	((0x56 << 1) + 1)	//0xAD
+//#define SERIAL_WRITE_ADDR	((0x57 << 1) + 0)       //0xAE
+//#define SERIAL_READ_ADDR	((0x57 << 1) + 0)       //0xAF
+
+#elif defined(OV7640)
+#define PACKET_SIZE		2
+//#define SERIAL_WRITE_ADDR	((0x42 << 1) + 0)
+//#define SERIAL_READ_ADDR	((0x42 << 1) + 1)
+#define SERIAL_WRITE_ADDR	(0x42)
+#define SERIAL_READ_ADDR	(0x43)
+
+#elif defined(OV7141)
+#define PACKET_SIZE		2
+#define SERIAL_WRITE_ADDR	((0x42 << 1) + 0)
+#define SERIAL_READ_ADDR	((0x42 << 1) + 1)
+//#define SERIAL_WRITE_ADDR	((0x43 << 1) + 0)
+//#define SERIAL_READ_ADDR	((0x43 << 1) + 1)
+
+#else
+#define PACKET_SIZE		16
+#endif
+
+#endif /* I2C_ALGO_ITE_H */
diff -Naur linux-2.6.17.8/drivers/i2c/algos/Kconfig linux-2.6.17.8-sh/drivers/i2c/algos/Kconfig
--- linux-2.6.17.8/drivers/i2c/algos/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/algos/Kconfig	2006-08-23 13:29:41.440670000 +0100
@@ -53,6 +53,10 @@
 	tristate "MPC8xx CPM I2C interface"
 	depends on 8xx && I2C
 
+config I2C_ALGOVOYAGER
+	tristate "Silicon Motion Voyager GX Algorithm"
+	depends on SH_RTS7751R2D && I2C
+
 config I2C_ALGO_SIBYTE
 	tristate "SiByte SMBus interface"
 	depends on SIBYTE_SB1xxx_SOC && I2C
diff -Naur linux-2.6.17.8/drivers/i2c/algos/Makefile linux-2.6.17.8-sh/drivers/i2c/algos/Makefile
--- linux-2.6.17.8/drivers/i2c/algos/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/algos/Makefile	2006-08-23 13:29:41.446668000 +0100
@@ -6,6 +6,7 @@
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
 obj-$(CONFIG_I2C_ALGOITE)	+= i2c-algo-ite.o
+obj-$(CONFIG_I2C_ALGOVOYAGER)	+= i2c-algo-voyager.o
 obj-$(CONFIG_I2C_ALGO_SIBYTE)	+= i2c-algo-sibyte.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
 
diff -Naur linux-2.6.17.8/drivers/i2c/busses/i2c-st40-pio.c linux-2.6.17.8-sh/drivers/i2c/busses/i2c-st40-pio.c
--- linux-2.6.17.8/drivers/i2c/busses/i2c-st40-pio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/i2c-st40-pio.c	2006-08-23 13:29:39.741622000 +0100
@@ -0,0 +1,270 @@
+/* linux/drivers/i2c/busses/i2c-st40-pio.c
+
+   Copyright (c) 2004 STMicroelectronics Limited
+   Author: Stuart Menefy <stuart.menefy@st.com>
+
+   ST40 I2C bus driver using PIO pins
+
+   Derived from i2c-velleman.c which was:
+   Copyright (C) 1995-96, 2000 Simon G. Vogl
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+#include <asm/param.h> /* for HZ */
+
+#define NAME "i2c_st40_pio"
+
+typedef struct {
+	int sclbank;
+	int sclpin;
+	int sdabank;
+	int sdapin;
+} pio_address;
+
+typedef struct {
+	struct stpio_pin* scl;
+	struct stpio_pin* sda;
+} pio_pins;
+
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+
+#define NR_I2C_BUSSES 1
+static pio_address i2c_address[NR_I2C_BUSSES] = {{3,1,3,0}};
+
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+#if defined(CONFIG_SH_STM8000_DEMO)
+#define NR_I2C_BUSSES 2
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{6,0,6,1},
+	{6,2,6,3}  // This isn't strictly speaking I2C but some boards use it as such
+};
+#elif defined(CONFIG_SH_ST220_EVAL)
+#define NR_I2C_BUSSES 1
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{6,0,6,1}
+	//  The "second" bus on the eval board is unconnected and hence floating
+	//  this causes a temporary hang on probe
+};
+#endif
+
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+
+#define NR_I2C_BUSSES 3
+static pio_address i2c_address[NR_I2C_BUSSES] = {
+	{2,0,2,1},
+	{3,0,3,1},
+	{4,0,4,1}
+};
+
+#else
+#error Need to configure the default I2C pins for this chip
+#endif
+
+static pio_pins i2c_busses[NR_I2C_BUSSES] = {{0}};
+
+static void bit_st40_pio_setscl(void *data, int state)
+{
+	stpio_set_pin(((pio_pins*)data)->scl, state);
+}
+
+static void bit_st40_pio_setsda(void *data, int state)
+{
+	stpio_set_pin(((pio_pins*)data)->sda, state);
+}
+
+static int bit_st40_pio_getscl(void *data)
+{
+	return stpio_get_pin(((pio_pins*)data)->scl);
+}
+
+static int bit_st40_pio_getsda(void *data)
+{
+	return stpio_get_pin(((pio_pins*)data)->sda);
+}
+
+static int bit_st40_pio_init(void)
+{
+	int i;
+	for(i = 0; i<NR_I2C_BUSSES; i++) {
+		i2c_busses[i].scl = stpio_request_pin(i2c_address[i].sclbank,
+						      i2c_address[i].sclpin,
+						      "I2C Clock",
+						      STPIO_BIDIR);
+
+		printk(KERN_INFO NAME ": allocated pin (%d,%d) for scl (0x%p)\n",i2c_address[i].sclbank, i2c_address[i].sclpin, i2c_busses[i].scl);
+
+		i2c_busses[i].sda = stpio_request_pin(i2c_address[i].sdabank,
+						      i2c_address[i].sdapin,
+						      "I2C Data",
+						      STPIO_BIDIR);
+
+		printk(KERN_INFO NAME ": allocated pin (%d,%d) for sda (0x%p)\n",i2c_address[i].sdabank, i2c_address[i].sdapin, i2c_busses[i].sda);
+
+		if(i2c_busses[i].scl == NULL || i2c_busses[i].sda == NULL)
+		{
+			printk(KERN_INFO NAME ": failed to allocate bus pins\n");
+			return -1;
+		}
+
+
+		stpio_set_pin(i2c_busses[i].sda, 0);
+		stpio_set_pin(i2c_busses[i].scl, 0);
+	}
+
+	return 0;
+}
+
+static void bit_st40_pio_free(void)
+{
+	int i;
+	for(i=0; i<NR_I2C_BUSSES; i++) {
+		if(i2c_busses[i].scl)
+		{
+			stpio_free_pin(i2c_busses[i].scl);
+			i2c_busses[i].scl = NULL;
+		}
+
+		if(i2c_busses[i].sda)
+		{
+			stpio_free_pin(i2c_busses[i].sda);
+			i2c_busses[i].sda = NULL;
+		}
+	}
+}
+
+static struct i2c_algo_bit_data bit_st40_pio_data[NR_I2C_BUSSES] = {
+{
+	.data		= &i2c_busses[0],
+	.setsda		= bit_st40_pio_setsda,
+	.setscl		= bit_st40_pio_setscl,
+	.getsda		= bit_st40_pio_getsda,
+	.getscl		= bit_st40_pio_getscl,
+	.udelay		= 10,
+	.mdelay		= 10,
+	.timeout	= HZ
+},
+#if NR_I2C_BUSSES > 1
+{
+	.data		= &i2c_busses[1],
+	.setsda		= bit_st40_pio_setsda,
+	.setscl		= bit_st40_pio_setscl,
+	.getsda		= bit_st40_pio_getsda,
+	.getscl		= bit_st40_pio_getscl,
+	.udelay		= 10,
+	.mdelay		= 10,
+	.timeout	= HZ
+},
+#if NR_I2C_BUSSES > 2
+{
+        .data           = &i2c_busses[2],
+        .setsda         = bit_st40_pio_setsda,
+        .setscl         = bit_st40_pio_setscl,
+        .getsda         = bit_st40_pio_getsda,
+        .getscl         = bit_st40_pio_getscl,
+        .udelay         = 10,
+        .mdelay         = 10,
+        .timeout        = HZ
+},
+#endif
+#endif
+};
+
+static struct i2c_adapter bit_st40_pio_ops[NR_I2C_BUSSES] = {
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[0],
+},
+#if NR_I2C_BUSSES > 1
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[1],
+},
+#if NR_I2C_BUSSES > 2
+{
+	.owner		= THIS_MODULE,
+	.name		= "ST40 (PIO based)",
+	.id		= I2C_HW_B_ST40_PIO,
+	.algo_data	= &bit_st40_pio_data[2],
+}
+#endif
+#endif
+};
+
+static void bit_st40_pio_unregister(void)
+{
+	int i;
+
+	for(i=0;i<NR_I2C_BUSSES;i++)
+	{
+		i2c_bit_del_bus(&bit_st40_pio_ops[i]);
+	}
+
+	bit_st40_pio_free();
+}
+
+static int __init i2c_st40_pio_init(void)
+{
+	int i;
+
+	printk(KERN_INFO NAME ": ST40 PIO based I2C Driver\n");
+
+	if (bit_st40_pio_init() < 0) {
+		printk(KERN_INFO NAME ": initialization failed\n");
+		bit_st40_pio_free();
+	}
+
+	for(i=0;i<NR_I2C_BUSSES;i++)
+	{
+		printk(KERN_INFO NAME " bus %d: SCL=PIO%u[%u], SDA=PIO%u[%u]\n", i,
+			i2c_address[i].sclbank, i2c_address[i].sclpin,
+			i2c_address[i].sdabank, i2c_address[i].sdapin);
+
+		if (i2c_bit_add_bus(&bit_st40_pio_ops[i]) < 0) {
+			printk(KERN_ERR NAME ": adapter registration failed\n");
+			bit_st40_pio_unregister();
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static void __exit i2c_st40_pio_exit(void)
+{
+	bit_st40_pio_unregister();
+}
+
+MODULE_AUTHOR("Stuart Menefy <stuart.menefy@st.com>");
+MODULE_DESCRIPTION("ST40 PIO based I2C Driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_st40_pio_init);
+module_exit(i2c_st40_pio_exit);
+
diff -Naur linux-2.6.17.8/drivers/i2c/busses/i2c-stm.c linux-2.6.17.8-sh/drivers/i2c/busses/i2c-stm.c
--- linux-2.6.17.8/drivers/i2c/busses/i2c-stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/i2c-stm.c	2006-08-23 13:29:49.979852000 +0100
@@ -0,0 +1,606 @@
+/*
+   --------------------------------------------------------------------
+
+   i2c-stm.c
+   i2c algorithms for STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#include <linux/i2c.h>
+#include <linux/stpio.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/preempt.h>
+#include <asm/processor.h>
+#include <asm/delay.h>
+#include "./i2c-stm.h"
+#include "../../stm/stm_ssc.h"
+
+#undef dgb_print
+
+#ifdef  CONFIG_I2C_STM_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+/* --- Defines for I2C --- */
+#define DEVICE_ID                    0x041175
+#define I2C_STM_ALGO                 DEVICE_ID
+
+#define STI2C_RATE_NORMAL            100000
+#define STI2C_RATE_FASTMODE          400000
+#define NANOSEC_PER_SEC              1000000000
+
+#define REP_START_HOLD_TIME_NORMAL   4000	/* standard */
+#define REP_START_HOLD_TIME_FAST     3500	/* it should be 600 */
+#define START_HOLD_TIME_NORMAL       4000	/* standard */
+#define START_HOLD_TIME_FAST          600	/* standard */
+#define REP_START_SETUP_TIME_NORMAL  4700	/* standard */
+#define REP_START_SETUP_TIME_FAST     600	/* standard */
+#define DATA_SETUP_TIME_NORMAL        250	/* standard */
+#define DATA_SETUP_TIME_FAST          100	/* standard */
+#define STOP_SETUP_TIME_NORMAL       4000	/* standard */
+#define STOP_SETUP_TIME_FAST          600	/* standard */
+#define BUS_FREE_TIME_NORMAL         4700	/* standard */
+#define BUS_FREE_TIME_FAST           1300	/* standard */
+
+/* To manage normal vs fast mode */
+#define IIC_STM_CONFIG_SPEED_MASK          0x1
+#define IIC_STM_CONFIG_SPEED_NORMAL        0x0
+#define IIC_STM_CONFIG_SPEED_FAST          0x1
+
+#define IIC_STM_CONFIG_BAUDRATE_MASK       0xffff0000
+
+typedef enum _iic_state_machine_e {
+	IIC_FSM_VOID = 0,
+	IIC_FSM_START,
+	IIC_FSM_DATA_WRITE,
+	IIC_FSM_PREPARE_2_READ,
+	IIC_FSM_DATA_READ,
+	IIC_FSM_STOP,
+	IIC_FSM_COMPLETE,
+	IIC_FSM_REPSTART,
+	IIC_FSM_REPSTART_ADDR,
+	IIC_FSM_ABORT
+} iic_state_machine_e;
+
+typedef enum _iic_fsm_error_e {
+	IIC_E_NO_ERROR = 0x0,
+	IIC_E_RUNNING = 0x1,
+	IIC_E_NOTACK = 0x2
+} iic_fsm_error_e;
+
+struct iic_ssc {
+	unsigned int iic_idx;
+	struct i2c_adapter adapter;
+	unsigned int virtual_configuration;
+	iic_state_machine_e start_state;
+	iic_state_machine_e state;
+	iic_state_machine_e next_state;
+	struct i2c_msg *msgs_queue;
+	int attempt;
+	int queue_length;
+	int current_msg;	/* the message on going */
+	int idx_current_msg;	/* the byte in the message */
+	iic_fsm_error_e status_error;
+};
+
+static void iic_algo_stm_setup_timing(struct iic_ssc *adapter);
+
+#define jump_on_fsm_start()  { adap->state = IIC_FSM_START; \
+				goto be_fsm_start; }
+
+#define jump_on_fsm_repstart()  { adap->state = IIC_FSM_REPSTART; \
+                                  goto be_fsm_repstart; }
+
+#define jump_on_fsm_stop()      { adap->state = IIC_FSM_STOP;     \
+                                  goto be_fsm_stop;        }
+
+#define jump_on_fsm_abort()     { adap->state = IIC_FSM_ABORT;    \
+                                  goto be_fsm_abort;       }
+
+#define check_fastmode(adap)  ( (adap->virtual_configuration & \
+                                 IIC_STM_CONFIG_SPEED_MASK   )!=0 ? 1 : 0 )
+
+void iic_algo_state_machine(struct iic_ssc *adap)
+{
+	unsigned short status;
+	unsigned short tx_fifo_status;
+	unsigned short rx_fifo_status;
+	unsigned int idx;
+	unsigned short address;
+	struct i2c_msg *pmsg;
+	struct ssc_t *ssc_bus;
+	struct device *dev;
+	char local_fast_mode;
+	union {
+		char bytes[2];
+		short word;
+	} tmp;
+
+	dgb_print("\n");
+	dev = adap->adapter.dev.parent;
+	ssc_bus = container_of(dev, struct ssc_t, dev);
+	local_fast_mode = check_fastmode(adap);
+	pmsg = adap->msgs_queue + adap->current_msg;
+
+	adap->state = adap->next_state;
+
+	barrier();
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+	tx_fifo_status = ssc_load16(ssc_bus, SSC_TX_FSTAT);
+	rx_fifo_status = ssc_load16(ssc_bus, SSC_RX_FSTAT);
+#endif
+	switch (adap->state) {
+	case IIC_FSM_START:
+	      be_fsm_start:
+		dgb_print("-Start address 0x%x\n", pmsg->addr);
+		adap->start_state = IIC_FSM_START;
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | 0x1);
+		ssc_store16(ssc_bus, SSC_BRG,
+			    (adap->virtual_configuration &
+			     IIC_STM_CONFIG_BAUDRATE_MASK) >> 16);
+		ssc_store16(ssc_bus, SSC_CTL,
+			    SSC_CTL_EN | SSC_CTL_MS |
+			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    (SSC_I2C_I2CFSMODE * local_fast_mode));
+		address = (pmsg->addr << 2) | 0x1;
+		adap->next_state = IIC_FSM_DATA_WRITE;
+		if (pmsg->flags & I2C_M_RD) {
+			address |= 0x2;
+			adap->next_state = IIC_FSM_PREPARE_2_READ;
+		}
+		adap->idx_current_msg = 0;
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN);
+		ssc_store16(ssc_bus, SSC_TBUF, address);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    SSC_I2C_STRTG | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * local_fast_mode));
+		break;
+	case IIC_FSM_PREPARE_2_READ:
+		/* Just to clear th RBUF */
+		ssc_load16(ssc_bus, SSC_RBUF);
+		status = ssc_load16(ssc_bus, SSC_STA);
+		dgb_print(" Prepare to Read... Status=0x%x\n", status);
+		if (status & SSC_STA_NACK)
+			jump_on_fsm_abort();
+		adap->next_state = IIC_FSM_DATA_READ;
+		if (!pmsg->len) {
+			dgb_print("Zero Read\n");
+			jump_on_fsm_stop();
+		}
+		ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+		if (pmsg->len == 1) {
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    (SSC_I2C_I2CFSMODE * local_fast_mode));
+		} else {
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    SSC_I2C_ACKG |
+				    (SSC_I2C_I2CFSMODE * local_fast_mode));
+			ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_RIEN);
+		}
+		break;
+	case IIC_FSM_DATA_READ:
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if (!(status & SSC_STA_TE))
+			return;
+		tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+		tmp.word = tmp.word >> 1;
+		pmsg->buf[adap->idx_current_msg++] = tmp.bytes[0];
+		dgb_print(" Data Read...Status=0x%x %d-%c\n",
+			  status, tmp.bytes[0], tmp.bytes[0]);
+		/*Did we finish? */
+		if (adap->idx_current_msg == pmsg->len) {
+			status &= ~SSC_STA_NACK;
+			jump_on_fsm_stop();
+		} else {
+			ssc_store16(ssc_bus, SSC_TBUF, 0x1ff);
+			/*Is this the last byte? */
+			if (adap->idx_current_msg == (pmsg->len - 1)) {
+				ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+					    (SSC_I2C_I2CFSMODE *
+					     local_fast_mode));
+				ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN);
+			}
+		}
+		break;
+	case IIC_FSM_DATA_WRITE:
+		/* just to clear some bits in the STATUS register */
+		ssc_load16(ssc_bus, SSC_RBUF);
+/*
+ * Be careful!!!!
+ * Here I don't have to use 0xdc0 for
+ * the SSC_CLR register
+ */
+		ssc_store16(ssc_bus, SSC_CLR, 0x9c0);
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if (status & SSC_STA_NACK)
+			jump_on_fsm_abort();
+		if (adap->idx_current_msg == pmsg->len || !(pmsg->len))
+			jump_on_fsm_stop();;
+		dgb_print(" Data Write...Status=0x%x 0x%x-%c\n", status,
+			  pmsg->buf[adap->idx_current_msg],
+			  pmsg->buf[adap->idx_current_msg]);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * local_fast_mode));
+
+		adap->next_state = IIC_FSM_DATA_WRITE;
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TEEN);
+
+		tmp.bytes[0] = pmsg->buf[adap->idx_current_msg++];
+		ssc_store16(ssc_bus, SSC_TBUF, tmp.word << 1 | 0x1);
+		break;
+
+	case IIC_FSM_ABORT:
+	      be_fsm_abort:
+		dgb_print(" Abort\n");
+		adap->status_error |= IIC_E_NOTACK;
+		/* Don't ADD the break */
+
+	case IIC_FSM_STOP:
+	      be_fsm_stop:
+		if (!(status & SSC_STA_NACK) &&
+		    (++adap->current_msg < adap->queue_length)) {
+			jump_on_fsm_repstart();
+		}
+		dgb_print(" Stop\n");
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+			    SSC_I2C_TXENB | SSC_I2C_STOPG |
+			    (SSC_I2C_I2CFSMODE * local_fast_mode));
+		adap->next_state = IIC_FSM_COMPLETE;
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_STOPEN);
+		break;
+
+	case IIC_FSM_COMPLETE:
+		dgb_print(" Complete\n");
+		ssc_store16(ssc_bus, SSC_IEN, 0x0);
+		ssc_store16(ssc_bus, SSC_I2C, 0x0);
+/*
+ *  If there was some problem i can try again for adap->adapter.retries time...
+ */
+		if ((adap->status_error & IIC_E_NOTACK) &&	/* there was a problem */
+		    adap->start_state == IIC_FSM_START &&	/* it cames from start state */
+		    adap->idx_current_msg == 0 &&	/* the problem is on address */
+		    ++adap->attempt <= adap->adapter.retries) {
+			adap->status_error = 0;
+			jump_on_fsm_start();
+		}
+		if (!(adap->status_error & IIC_E_NOTACK))
+			adap->status_error = IIC_E_NO_ERROR;
+		wake_up(&(ssc_bus->wait_queue));
+		break;
+	case IIC_FSM_REPSTART:
+	      be_fsm_repstart:
+		pmsg = adap->msgs_queue + adap->current_msg;
+		dgb_print("-Rep Start addr 0x%x\n", pmsg->addr);
+		adap->start_state = IIC_FSM_REPSTART;
+		adap->idx_current_msg = 0;
+		adap->next_state = IIC_FSM_REPSTART_ADDR;
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM
+			    | SSC_I2C_REPSTRTG | (SSC_I2C_I2CFSMODE *
+						  local_fast_mode));
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_REPSTRTEN);
+		break;
+	case IIC_FSM_REPSTART_ADDR:
+		ssc_store16(ssc_bus, SSC_CLR, 0xdc0);
+		ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |
+			    (SSC_I2C_I2CFSMODE * local_fast_mode));
+		address = (pmsg->addr << 2) | 0x1;
+		adap->next_state = IIC_FSM_DATA_WRITE;
+		if (pmsg->flags & I2C_M_RD) {
+			address |= 0x2;
+			adap->next_state = IIC_FSM_PREPARE_2_READ;
+		}
+		ssc_store16(ssc_bus, SSC_TBUF, address);
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN);
+		break;
+	default:
+		printk(KERN_ERR " Error in the FSM\n");
+		;
+	}
+	return;
+}
+
+/*
+  Description: Prepares the controller for a transaction
+*/
+static int iic_algo_stm_xfer(struct i2c_adapter *i2c_adap,
+			     struct i2c_msg msgs[], int num)
+{
+	struct iic_ssc *adap;
+	struct ssc_t *ssc_bus;
+	struct device *dev;
+	unsigned int local_flag;
+	int result;
+
+	dgb_print("\n");
+	adap = container_of(i2c_adap, struct iic_ssc, adapter);
+	dev = i2c_adap->dev.parent;
+	ssc_bus = container_of(dev, struct ssc_t, dev);
+
+	/* Here i have to prepare all the environment */
+	adap->msgs_queue = msgs;
+	adap->queue_length = num;
+	adap->current_msg = 0x0;
+	adap->attempt = 0x0;
+	adap->status_error = IIC_E_RUNNING;
+	adap->next_state = IIC_FSM_START;
+
+	ssc_request_bus(ssc_bus, iic_algo_state_machine, adap);
+/*
+ * check if the i2c timing register
+ * of ssc are ready to use
+*/
+	if (!(ssc_bus->i2c_timing == SSC_I2C_READY_NORMAL &&
+	      !(check_fastmode(adap))
+	      ||
+	      ssc_bus->i2c_timing == SSC_I2C_READY_FAST &&
+	      check_fastmode(adap)))
+		iic_algo_stm_setup_timing(adap);
+
+	local_irq_save(local_flag);
+	iic_algo_state_machine(adap);
+	interruptible_sleep_on_timeout(&(ssc_bus->wait_queue),
+				       i2c_adap->timeout * num * HZ);
+
+	result = adap->current_msg;
+
+	if (adap->status_error != IIC_E_NO_ERROR) {	/* There was some problem */
+		if (adap->status_error == IIC_E_RUNNING) {	/* There was a timeout !!! */
+			/* if there was a timeout we have to
+			   - disable the interrupt
+			   - generate a stop condition on the bus
+			   all this task are done without interrupt....
+			 */
+			ssc_store16(ssc_bus, SSC_IEN, 0x0);
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM |
+				    SSC_I2C_STOPG | SSC_I2C_TXENB |
+				    (SSC_I2C_I2CFSMODE * check_fastmode(adap)));
+			/* wait until the ssc detects a Stop condition on the bus */
+			while((ssc_load16(ssc_bus,SSC_STA) & SSC_STA_STOP) == 0 );
+			/* tourn off the ssc */
+			ssc_store16(ssc_bus, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB);
+			printk(KERN_ERR
+			       "stm-i2c: Error timeout in the finite state machine\n");
+		}
+		result = -EREMOTEIO;
+	}
+	local_irq_restore(local_flag);
+
+	while((ssc_load16(ssc_bus,SSC_STA) & SSC_STA_BUSY) != 0 );
+
+		ndelay(BUS_FREE_TIME_FAST);
+
+   if (!check_fastmode(adap))
+	ndelay(BUS_FREE_TIME_NORMAL-BUS_FREE_TIME_FAST);
+
+	ssc_release_bus(ssc_bus);
+
+	return result;
+}
+
+#ifdef CONFIG_I2C_STM_DEBUG
+static void iic_algo_stm_timing_trace(struct iic_ssc *adap)
+{
+	struct device *dev = adap->adapter.dev.parent;
+	struct ssc_t *ssc_bus = container_of(dev, struct ssc_t, dev);
+	dgb_print("SSC_BRG  %d\n", ssc_load16(ssc_bus, SSC_BRG));
+	dgb_print("SSC_REP_START_HOLD %d\n",
+		  ssc_load16(ssc_bus, SSC_REP_START_HOLD));
+	dgb_print("SSC_REP_START_SETUP %d\n",
+		  ssc_load16(ssc_bus, SSC_REP_START_SETUP));
+	dgb_print("SSC_START_HOLD %d\n", ssc_load16(ssc_bus, SSC_START_HOLD));
+	dgb_print("SSC_DATA_SETUP %d\n", ssc_load16(ssc_bus, SSC_DATA_SETUP));
+	dgb_print("SSC_STOP_SETUP %d\n", ssc_load16(ssc_bus, SSC_STOP_SETUP));
+	dgb_print("SSC_BUS_FREE %d\n", ssc_load16(ssc_bus, SSC_BUS_FREE));
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	dgb_print("SSC_PRE_SCALER_BRG %d\n",
+		  ssc_load16(ssc_bus, SSC_PRE_SCALER_BRG));
+#endif
+	dgb_print("SSC_AGFR 0x%x\n", ssc_load8(ssc_bus, SSC_AGFR));
+	dgb_print("SSC_PRSC %d\n", ssc_load8(ssc_bus, SSC_PRSC));
+}
+#endif
+
+static void iic_algo_stm_setup_timing(struct iic_ssc *adap)
+{
+	struct device *dev = adap->adapter.dev.parent;
+	struct ssc_t *ssc_bus = container_of(dev, struct ssc_t, dev);
+	unsigned long iic_baudrate;
+	unsigned short iic_rep_start_hold;
+	unsigned short iic_start_hold, iic_rep_start_setup;
+	unsigned short iic_data_setup, iic_stop_setup;
+	unsigned short iic_bus_free, iic_pre_scale_baudrate;
+	unsigned char iic_agfr, iic_prsc;
+	unsigned long NSPerCyc = NANOSEC_PER_SEC / ssc_get_clock();
+
+	dgb_print("Assuming %d MHz for the Timing Setup\n",
+		  ssc_get_clock() / 1000000);
+
+	iic_agfr = 0x0;
+	iic_prsc = (int)ssc_get_clock() / 10000000;
+	iic_pre_scale_baudrate = 0x1;
+
+	if (check_fastmode(adap)) {
+		ssc_bus->i2c_timing = SSC_I2C_READY_FAST;
+		iic_baudrate = ssc_get_clock()
+		    / (2 * STI2C_RATE_FASTMODE);
+		iic_rep_start_hold = REP_START_HOLD_TIME_FAST / NSPerCyc;
+		iic_start_hold = START_HOLD_TIME_FAST / NSPerCyc;
+		iic_rep_start_setup = REP_START_SETUP_TIME_FAST / NSPerCyc;
+		iic_data_setup = DATA_SETUP_TIME_FAST / NSPerCyc;
+		iic_stop_setup = STOP_SETUP_TIME_FAST / NSPerCyc;
+		iic_bus_free = BUS_FREE_TIME_FAST / NSPerCyc;
+	} else {
+		ssc_bus->i2c_timing = SSC_I2C_READY_NORMAL;
+		iic_baudrate = ssc_get_clock()
+		    / (2 * STI2C_RATE_NORMAL);
+		iic_rep_start_hold = REP_START_HOLD_TIME_NORMAL / NSPerCyc;
+		iic_start_hold = START_HOLD_TIME_NORMAL / NSPerCyc;
+		iic_rep_start_setup = REP_START_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_data_setup = DATA_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_stop_setup = STOP_SETUP_TIME_NORMAL / NSPerCyc;
+		iic_bus_free = BUS_FREE_TIME_NORMAL / NSPerCyc;
+	}
+
+	adap->virtual_configuration =
+	    (adap->virtual_configuration & ~IIC_STM_CONFIG_BAUDRATE_MASK);
+	adap->virtual_configuration |= iic_baudrate << 16;
+
+	ssc_store16(ssc_bus, SSC_REP_START_HOLD, iic_rep_start_hold);
+	ssc_store16(ssc_bus, SSC_START_HOLD, iic_start_hold);
+	ssc_store16(ssc_bus, SSC_REP_START_SETUP, iic_rep_start_setup);
+	ssc_store16(ssc_bus, SSC_DATA_SETUP, iic_data_setup);
+	ssc_store16(ssc_bus, SSC_STOP_SETUP, iic_stop_setup);
+	ssc_store16(ssc_bus, SSC_BUS_FREE, iic_bus_free);
+	ssc_store8(ssc_bus, SSC_AGFR, iic_agfr);
+	ssc_store8(ssc_bus, SSC_PRSC, iic_prsc);
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+	ssc_store16(ssc_bus, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);
+#endif
+#ifdef CONFIG_I2C_STM_DEBUG
+	iic_algo_stm_timing_trace(adap);
+#endif
+	return;
+}
+
+static int iic_algo_stm_control(struct i2c_adapter *adapter,
+				unsigned int cmd, unsigned long arg)
+{
+	struct iic_ssc *iic_adap =
+	    container_of(adapter, struct iic_ssc, adapter);
+
+	if (cmd == I2C_STM_IOCTL_FAST) {
+		dgb_print("IOCTL Fast\n");
+		iic_adap->virtual_configuration &= ~IIC_STM_CONFIG_SPEED_MASK;
+		if (arg)
+			iic_adap->virtual_configuration |=
+			    IIC_STM_CONFIG_SPEED_FAST;
+	}
+/*
+ * the timeout and he retries ioctl
+ * are managed by i2c core system
+ */
+	return 0;
+}
+
+static u32 iic_algo_stm_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm iic_stm_algo = {
+	.name = "stm i2c algorithm",
+	.id = I2C_STM_ALGO,
+	.master_xfer = iic_algo_stm_xfer,
+	.functionality = iic_algo_stm_func,
+	.algo_control = iic_algo_stm_control
+};
+
+static LIST_HEAD(stm_busses);
+
+struct stm_adapter {
+	struct iic_ssc iic_adap;
+	struct list_head stm_list;
+};
+
+static int __init iic_stm_bus_init()
+{
+	unsigned int ssc_number = ssc_device_available();
+	unsigned int idx;
+	struct stm_adapter *st_adapter;
+	struct iic_ssc *iic_stm;
+
+	for (idx = 0; idx < ssc_number; ++idx) {
+		if (!(ssc_capability(idx) & SSC_I2C_CAPABILITY))
+			continue;
+		st_adapter =
+		    (struct stm_adapter *)kmalloc(sizeof(struct stm_adapter),
+						  GFP_KERNEL);
+		if (!st_adapter) {
+			printk(KERN_EMERG
+			       "Error on initialization of  ssc-i2c adapter module\n");
+			return -ENODEV;
+		}
+		iic_stm = &(st_adapter->iic_adap);
+		iic_stm->virtual_configuration &= ~IIC_STM_CONFIG_SPEED_MASK;
+		memset(&(iic_stm->adapter), 0, sizeof(struct i2c_adapter));
+		iic_stm->adapter.nr = idx;
+		iic_stm->adapter.owner = THIS_MODULE;
+		iic_stm->adapter.id = I2C_STM_ALGO;
+		iic_stm->adapter.timeout = 4;
+		iic_stm->adapter.retries = 0;
+		iic_stm->adapter.algo = &iic_stm_algo;
+		iic_stm->adapter.dev.bus = &i2c_bus_type;
+		iic_stm->adapter.dev.parent = &(ssc_device_request(idx)->dev);
+		iic_algo_stm_setup_timing(iic_stm);
+		init_MUTEX(&(iic_stm->adapter.bus_lock));
+		init_MUTEX(&(iic_stm->adapter.clist_lock));
+
+		if (i2c_add_adapter(&(iic_stm->adapter)) < 0) {
+			printk(KERN_ERR,
+			       "i2c/stm: The I2C Core refuses the i2c/stm adapter\n");
+			kfree(st_adapter);
+			return -ENODEV;
+		}
+		list_add(&(st_adapter->stm_list), &(stm_busses));
+	}
+	return 0;
+}
+
+static void __exit iic_stm_bus_exit(void)
+{
+	struct stm_adapter *st_adapter;
+	struct i2c_adapter *iic_adapter;
+	struct list_head *item;
+	dgb_print("\n");
+	list_for_each(item, &(stm_busses)) {
+		st_adapter = container_of(item, struct stm_adapter, stm_list);
+		list_del(&st_adapter->stm_list);
+		iic_adapter = &(st_adapter->iic_adap.adapter);
+		i2c_del_adapter(iic_adapter);
+		kfree(st_adapter);
+	}
+}
+
+late_initcall(iic_stm_bus_init);
+
+module_exit(iic_stm_bus_exit);
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("i2c-stm algorithm for ssc device");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/i2c/busses/i2c-stm.h linux-2.6.17.8-sh/drivers/i2c/busses/i2c-stm.h
--- linux-2.6.17.8/drivers/i2c/busses/i2c-stm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/i2c-stm.h	2006-08-23 13:29:41.463671000 +0100
@@ -0,0 +1,6 @@
+#ifndef I2C_STM
+#define I2C_STM
+
+#define I2C_STM_IOCTL_FAST           0xfa57
+
+#endif
diff -Naur linux-2.6.17.8/drivers/i2c/busses/i2c-voyager.c linux-2.6.17.8-sh/drivers/i2c/busses/i2c-voyager.c
--- linux-2.6.17.8/drivers/i2c/busses/i2c-voyager.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/i2c-voyager.c	2006-08-23 13:29:07.741886000 +0100
@@ -0,0 +1,216 @@
+/* -------------------------------------------------------------------- */
+/* i2c-voyagergx.c:                                                     */
+/* -------------------------------------------------------------------- */
+/*  This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Copyright 2003 (c) Lineo uSolutions,Inc.
+    Copyright 2004 (c) Paul Mundt
+*/
+/* -------------------------------------------------------------------- */
+
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <linux/i2c.h>
+#include "../algos/i2c-algo-voyager.h"
+
+//#define I2C_USE_INTR
+
+#if defined(I2C_USE_INTR)
+#define DEFAULT_IRQ   10
+#else
+#define DEFAULT_IRQ   0
+#endif
+
+struct iic_voyagergx {
+	unsigned long	iic_base;
+	int 		iic_irq;
+};
+static struct iic_voyagergx gpi;
+
+static wait_queue_head_t iic_wait;
+static int iic_pending;
+
+static void iic_voyagergx_setiic(void *data, int ctl, int val)
+{
+	outw(val,ctl);
+}
+
+static int iic_voyagergx_getiic(void *data, int ctl)
+{
+	return inw(ctl);
+}
+
+/* Put this process to sleep.  We will wake up when the
+ * IIC controller interrupts.
+ */
+static void iic_voyagergx_waitforpin(void)
+{
+	int timeout = 2;
+
+	/* If interrupts are enabled (which they are), then put the process to
+	 * sleep.  This process will be awakened by two events -- either the
+	 * the IIC peripheral interrupts or the timeout expires.
+	 * If interrupts are not enabled then delay for a reasonable amount
+	 * of time and return.
+	 */
+	if (gpi.iic_irq > 0) {
+		local_irq_disable();
+
+		if (iic_pending == 0) {
+			interruptible_sleep_on_timeout(&iic_wait, timeout*HZ);
+		} else {
+			iic_pending = 0;
+		}
+
+		local_irq_enable();
+	} else {
+		udelay(100);
+	}
+}
+
+#if defined(I2C_USE_INTR)
+static irqreturn_t iic_voyagergx_handler(int this_irq, void *dev_id,
+					 struct pt_regs *regs)
+{
+	iic_pending = 1;
+
+	pr_debug("iic_voyagergx_handler: in interrupt handler\n");
+	wake_up_interruptible(&iic_wait);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Lock the region of memory where I/O registers exist.  Request our
+ * interrupt line and register its associated handler.
+ */
+static int iic_hw_resrc_init(void)
+{
+	unsigned char		ctl;
+	unsigned long		val;
+
+	// Power Mode Gate
+	val = inl(POWER_MODE0_GATE);
+	val |= 0x00000040;
+	outl(val, POWER_MODE0_GATE);
+	val = inl(POWER_MODE1_GATE);
+	val |= 0x00000040;
+	outl(val, POWER_MODE1_GATE);
+
+	// GPIO Control
+	val = inl( GPIO_MUX_HIGH);
+	val |= 0x0000c000;
+	outl(val, GPIO_MUX_HIGH);
+
+#if defined(I2C_USE_INTR)
+	// Interrupt Mask
+	val = inl(VOYAGER_INT_MASK);
+	val |= 0x00800000;
+	outl(val, VOYAGER_INT_MASK);
+#endif
+
+        // Enable I2c controller and select mode to high
+        ctl = inb(I2C_CONTROL);
+        outb((ctl | I2C_CONTROL_E | I2C_CONTROL_MODE), I2C_CONTROL);
+
+#if defined(I2C_USE_INTR)
+	if (gpi.iic_irq > 0) {
+		if (request_irq(gpi.iic_irq, iic_voyagergx_handler, 0,
+				"VoyagerGX IIC", 0) < 0) {
+			gpi.iic_irq = 0;
+		} else {
+			pr_debug("Enabled IIC IRQ %d\n", gpi.iic_irq);
+		}
+
+		enable_irq(gpi.iic_irq);
+	}
+#endif
+
+	return 0;
+}
+
+static struct i2c_algo_iic_data iic_voyagergx_data = {
+	.setiic		= iic_voyagergx_setiic,
+	.getiic		= iic_voyagergx_getiic,
+	.waitforpin	= iic_voyagergx_waitforpin,
+	.udelay		= 80,
+	.mdelay		= 80,
+	.timeout	= 100,
+};
+
+static struct i2c_adapter iic_voyagergx_ops = {
+	.owner		= THIS_MODULE,
+	.name		= "VoyagerGX I2C",
+	.id		= I2C_HW_SMBUS_VOYAGER,
+	.class		= I2C_ADAP_CLASS_SMBUS,
+	.algo_data	= &iic_voyagergx_data,
+};
+
+static int __init iic_voyagergx_init(void)
+{
+	struct iic_voyagergx *piic = &gpi;
+
+	printk(KERN_INFO "Initialize VoyagerGX I2C module\n");
+
+	piic->iic_base	= VOYAGER_BASE;
+	piic->iic_irq	= DEFAULT_IRQ;
+
+	iic_voyagergx_data.data = (void *)piic;
+	init_waitqueue_head(&iic_wait);
+
+	if (iic_hw_resrc_init() == 0) {
+		if (i2c_voyager_add_bus(&iic_voyagergx_ops) < 0)
+			return -ENODEV;
+	} else {
+		return -ENODEV;
+	}
+
+#if defined(I2C_USE_INTR)
+	printk(KERN_INFO " found device at %#lx irq %d.\n",
+		piic->iic_base, piic->iic_irq);
+#else
+	printk(KERN_INFO " found device at %#lx\n", piic->iic_base);
+#endif
+
+	return 0;
+}
+
+
+static void iic_voyagergx_exit(void)
+{
+	if (gpi.iic_irq > 0) {
+		disable_irq(gpi.iic_irq);
+		free_irq(gpi.iic_irq, 0);
+	}
+
+	release_region(gpi.iic_base, 2);
+}
+
+MODULE_AUTHOR("Lineo uSolutions,Inc. <www.lineo.co.jp>");
+MODULE_DESCRIPTION("I2C-Bus adapter for VoyagerGX Silicon Motion, Inc.");
+MODULE_LICENSE("GPL");
+
+module_init(iic_voyagergx_init);
+module_exit(iic_voyagergx_exit);
+
diff -Naur linux-2.6.17.8/drivers/i2c/busses/Kconfig linux-2.6.17.8-sh/drivers/i2c/busses/Kconfig
--- linux-2.6.17.8/drivers/i2c/busses/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/Kconfig	2006-08-23 13:29:42.855691000 +0100
@@ -496,6 +496,16 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-voodoo3.
 
+config I2C_VOYAGER
+	tristate "Silicon Motion Voyager GX"
+	depends on I2C && SH_RTS7751R2D
+	help
+	  If you say yes to this option, support will be included for the
+	  Silicon Motion SM501 of mainboard I2C interfaces.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-voyager.
+
 config I2C_PCA_ISA
 	tristate "PCA9564 on an ISA bus"
 	depends on I2C
@@ -517,4 +527,41 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-mv64xxx.
 
+choice
+	prompt "STMicroelectronics I2C support"
+	depends on I2C && (CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STI5528 || CPU_SUBTYPE_STB7100)
+
+	help
+	  STMicroelectronics SoCs have I2C drivers exist for bit-banging using PIO pins or
+          running an I2C bus using the hardware SSC
+
+	config I2C_ST40_PIO
+	tristate "I2C bit-banging PIO driver"
+	depends on I2C && (CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STI5528 || CPU_SUBTYPE_STB7100)
+	select I2C_ALGOBIT
+	help
+
+	  If you say yes to this option, support will be included for the
+	  PIO based I2C on the STm8000, STi5528 and STb7100.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-st40-pio
+
+	config I2C_STM
+	tristate "I2C hardware SSC driver"
+	depends on I2C && (CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STI5528 || CPU_SUBTYPE_STB7100)
+       	select STM_SSC
+	help
+
+	  If you say yes to this option, support will be included for the
+	  I2C-SSC for the STM SOCs: STi5528, STm8000 and the STb7100
+
+config I2C_STM_DEBUG
+	bool "I2C hardware SSC driver debug"
+	depends on I2C_STM
+	help
+	Enable this option to print out information on STM I2C (SSC) device driver
+
+endchoice
+
 endmenu
diff -Naur linux-2.6.17.8/drivers/i2c/busses/Makefile linux-2.6.17.8-sh/drivers/i2c/busses/Makefile
--- linux-2.6.17.8/drivers/i2c/busses/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/busses/Makefile	2006-08-23 13:29:36.967553000 +0100
@@ -40,8 +40,11 @@
 obj-$(CONFIG_I2C_VIA)		+= i2c-via.o
 obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
+obj-$(CONFIG_I2C_VOYAGER)	+= i2c-voyager.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_ST40_PIO)      += i2c-st40-pio.o
+obj-$(CONFIG_I2C_STM)           += i2c-stm.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Naur linux-2.6.17.8/drivers/i2c/chips/at24c.c linux-2.6.17.8-sh/drivers/i2c/chips/at24c.c
--- linux-2.6.17.8/drivers/i2c/chips/at24c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/chips/at24c.c	2006-08-23 13:29:46.516783000 +0100
@@ -0,0 +1,737 @@
+/*
+ * at24c.c -- support many I2C EEPROMs, including Atmel AT24C models
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+// #define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+
+#ifdef CONFIG_ARM
+#include <asm/mach-types.h>
+#endif
+
+
+/* If all the bus drivers are statically linked, I2C drivers often won't
+ * need hotplug support.  Iff that's true in your config, you can #define
+ * NO_I2C_DYNAMIC_BUSSES and shrink this driver's runtime footprint.
+ */
+#define NO_I2C_DYNAMIC_BUSSES
+
+#ifdef	NO_I2C_DYNAMIC_BUSSES
+#undef	__devinit
+#undef	__devinitdata
+#undef	__devexit
+#undef	__devexit_p
+/* no I2C devices will be hotplugging */
+#define	__devinit	__init
+#define	__devinitdata	__initdata
+#define	__devexit	__exit
+#define	__devexit_p	__exit_p
+#endif
+
+
+/* I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.
+ * Differences between different vendor product lines (like Atmel AT24C or
+ * MicroChip 24LC, etc) won't much matter for typical read/write access.
+ *
+ * However, misconfiguration can lose data (e.g. "set 16 bit memory address"
+ * could be interpreted as "write data at 8 bit address", or writing with too
+ * big a page size), so board-specific EEPROM configuration should use static
+ * board descriptions rather than dynamic probing when there's much potential
+ * for confusion.
+ *
+ * Using /etc/modprobe.conf you might configure a system with several EEPROMs
+ * something like this:
+ *
+ *   options at24c	chip_names=24c00,dimm,dimm,24c64  \
+ *			probe=0,50,1,50,1,51,2,52 \
+ *			readonly=Y,Y,Y,N
+ *
+ * Or, add some board-specific code at the end of this driver, before
+ * registering the driver.
+ *
+ * CONFIGURATION MECHANISM IS SUBJECT TO CHANGE!!
+ *
+ * Key current(*) differences from "eeprom" driver:
+ *  (a) "at24c" also supports write access
+ *  (b) "at24c" handles all common eeproms, not just 24c02 compatibles
+ *  (c) "eeprom" will probe i2c and set up a 24c02 at each address;
+ *      "at24c" expects a static config, with part types and addresses
+ *  (d) "eeprom" also works on SMBUS-only pc type hardware
+ *
+ * (*) Patches accepted...
+ */
+static unsigned short probe[I2C_CLIENT_MAX_OPTS] __devinitdata
+	= I2C_CLIENT_DEFAULTS;
+static unsigned n_probe __devinitdata;
+module_param_array(probe, ushort, &n_probe, 0);
+MODULE_PARM_DESC(probe, "List of adapter,address pairs for I2C eeproms");
+
+static unsigned short ignore[] __devinitdata = { I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data __devinitdata = {
+	.normal_i2c	= ignore,
+	.probe		= probe,
+	.ignore		= ignore,
+	.force		= ignore,
+};
+
+static char *chip_names[I2C_CLIENT_MAX_OPTS / 2] __devinitdata;
+static unsigned n_chip_names __devinitdata;
+module_param_array(chip_names, charp, &n_chip_names, 0);
+MODULE_PARM_DESC(chip_names,
+		"Type of chip; one chip name per probe pair");
+
+static int readonly[I2C_CLIENT_MAX_OPTS / 2] __devinitdata;
+static unsigned n_readonly __devinitdata;
+module_param_array(readonly, bool, &n_readonly, 0);
+MODULE_PARM_DESC(chip_names, "Readonly flags, one per probe pair");
+
+
+/* As seen through Linux I2C, differences between the most common types
+ * of I2C memory include:
+ *	- How many I2C addresses the chip consumes: 1, 2, 4, or 8?
+ *	- Memory address space for one I2C address:  256 bytes, or 64 KB?
+ *	- How full that memory space is:  16 bytes, 256, 32Kb, etc?
+ *	- What write page size does it support?
+ */
+struct chip_desc {
+	u32		byte_len;		/* of 1..8 i2c addrs, total */
+	char		name[10];
+	u16		page_size;		/* for writes */
+	u8		i2c_addr_mask;		/* for multi-addr chips */
+	u8		flags;
+#define	EE_ADDR2	0x0080			/* 16 bit addrs; <= 64 KB */
+#define	EE_READONLY	0x0040
+#define	EE_24RF08	0x0001
+};
+
+struct at24c_data {
+	struct i2c_client	client;
+	struct semaphore	lock;
+	struct bin_attribute	bin;
+
+	struct chip_desc	chip;
+
+	/* each chip has an internal "memory address" pointer;
+	 * we remember it for faster read access.
+	 */
+	u32			next_addr;
+
+	/* some chips tie up multiple I2C addresses ... */
+	int			users;
+	struct i2c_client	extras[];
+};
+
+/* Specs often allow 5 msec for a page write, sometimes 20 msec;
+ * it's important to recover from write timeouts.
+ */
+#define	EE_TIMEOUT	25
+
+
+/*-------------------------------------------------------------------------*/
+
+static struct chip_desc chips[] __devinitdata = {
+
+/* this first block of EEPROMS uses 8 bit memory addressing
+ * and can be accessed using standard SMBUS requests.
+ */
+{
+	/* 128 bit chip */
+	.name		= "24c00",
+	.byte_len	= 128 / 8,
+	.i2c_addr_mask	= 0x07,			/* I2C A0-A2 ignored */
+	.page_size	= 1,
+}, {
+	/* 1 Kbit chip */
+	.name		= "24c01",
+	.byte_len	= 1024 / 8,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 2 Kbit chip */
+	.name		= "24c02",
+	.byte_len	= 2048 / 8,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 2 Kbit chip */
+	.name		= "dimm",		/* 24c02 in memory DIMMs */
+	.byte_len	= 2048 / 8,
+	.flags		= EE_READONLY,
+	/* some have 16 byte pages: */
+	.page_size	= 8,
+}, {
+	/* 4 Kbit chip */
+	.name		= "24c04",
+	.byte_len	= 4096 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x01,			/* I2C A0 is MEM A8 */
+}, {
+	/* 8 Kbit chip */
+	.name		= "24c08",
+	.byte_len	= 8192 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x03, 		/* I2C A1-A0 is MEM A9-A8 */
+}, {
+	/* 8 Kbit chip */
+	.name		= "24rf08",
+	.byte_len	= 8192 / 8,
+	.flags		= EE_24RF08,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x03, 		/* I2C A1-A0 is MEM A9-A8 */
+}, {
+	/* 16 Kbit chip */
+	.name		= "24c16",
+	.byte_len	= 16384 / 8,
+	.page_size	= 16,
+	.i2c_addr_mask	= 0x07,			/* I2C A2-A0 is MEM A10-A8 */
+},
+
+/* this second block of EEPROMS uses 16 bit memory addressing
+ * and can't be accessed using standard SMBUS requests.
+ * REVISIT maybe SMBUS 2.0 requests could work ...
+ */
+{
+	/* 32 Kbits */
+	.name		= "24c32",
+	.byte_len	= 32768 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 32,
+}, {
+	/* 64 Kbits */
+	.name		= "24c64",
+	.byte_len	= 65536 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 32,
+}, {
+	/* 128 Kbits */
+	.name		= "24c128",
+	.byte_len	= 131072 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 64,
+}, {
+	/* 256 Kbits */
+	.name		= "24c256",
+	.byte_len	= 262144 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 64,
+}, {
+	/* 512 Kbits */
+	.name		= "24c512",
+	.byte_len	= 524288 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 128,
+}, {
+	/* 1 Mbits */
+	.name		= "24c1024",
+	.byte_len	= 1048576 / 8,
+	.flags		= EE_ADDR2,
+	.page_size	= 256,
+	.i2c_addr_mask	= 0x01,			/* I2C A0 is MEM A16 */
+}
+
+};
+
+static inline const struct chip_desc *__devinit
+find_chip(const char *s)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(chips); i++)
+		if (strnicmp(s, chips[i].name, sizeof chips[i].name) == 0)
+			return &chips[i];
+	return NULL;
+}
+
+static inline const struct chip_desc *__devinit
+which_chip(struct i2c_adapter *adapter, int address, int *writable)
+{
+	unsigned		i;
+
+	for (i = 0; i < n_probe; i++) {
+		const struct chip_desc	*chip;
+		char			*name;
+
+		if (probe[i++] != adapter->id)
+			continue;
+		if (probe[i] != address)
+			continue;
+
+		i >>= 1;
+		if ((name = chip_names[i]) == NULL) {
+			dev_err(&adapter->dev, "no chipname for addr %d\n",
+				address);
+			return NULL;
+
+		}
+		chip = find_chip(name);
+		if (chip == NULL)
+			dev_err(&adapter->dev, "unknown chipname %s\n", name);
+
+		/* user specified r/o value will overide the default */
+		if (i < n_readonly)
+			*writable = !readonly[i];
+		else
+			*writable = !(chip->flags & EE_READONLY);
+		return chip;
+	}
+
+	/* "can't happen" */
+	dev_dbg(&adapter->dev, "addr %d not in probe[]\n", address);
+	return NULL;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* This parameter is to help this driver avoid blocking other drivers
+ * out of I2C for potentially troublesome amounts of time.  With a
+ * 100 KHz I2C clock, one 256 byte read takes about 1/43 second.
+ * VALUE MUST BE A POWER OF TWO so writes will align on pages!!
+ * Note that SMBUS has a 32 byte ceiling...
+ */
+static unsigned io_limit = 128;
+module_param(io_limit, uint, 0);
+MODULE_PARM_DESC(io_limit, "maximum bytes per i/o (default 128)");
+
+static inline int at24c_ee_address(
+	const struct chip_desc	*chip,
+	struct i2c_msg		*msg,
+	unsigned		*offset,
+	u32			*next_addr
+)
+{
+	unsigned	per_address = 256;
+
+	if (*offset >= chip->byte_len)
+		return -EINVAL;
+
+	/* Nothing to do unless accessing that memory would go to some
+	 * later I2C address.  In that case, modify the output params.
+	 * Yes, it can loop more than once on 24c08 and 24c16.
+	 */
+	if (chip->flags & EE_ADDR2)
+		per_address = 64 * 1024;
+	while (*offset >= per_address) {
+		msg->addr++;
+		*offset -= per_address;
+		*next_addr -= per_address;
+	}
+	return 0;
+}
+
+static ssize_t
+at24c_ee_read(
+	struct at24c_data	*at24c,
+	char			*buf,
+	unsigned		offset,
+	size_t			count
+)
+{
+	struct i2c_msg		msg;
+	ssize_t			status;
+	u32			next_addr;
+	size_t			transferred = 0;
+
+	down(&at24c->lock);
+	msg.addr = at24c->client.addr;
+	msg.flags = 0;
+
+	/* maybe adjust i2c address and offset
+	 * NOTE:  we could now search at24c->extras to choose use
+	 * some i2c_client other than the main one...
+	 */
+	next_addr = at24c->next_addr;
+	status = at24c_ee_address(&at24c->chip, &msg, &offset, &next_addr);
+	if (status < 0)
+		goto done;
+
+	/* REVISIT at least some key cases here can use just the
+	 * SMBUS subset; one issue is 16 byte "register" writes.
+	 */
+
+	/* Maybe change the current on-chip address with a dummy write */
+	if (next_addr != offset) {
+		u8	tmp[2];
+
+		msg.buf = tmp;
+		tmp[1] = (u8) offset;
+		tmp[0] = (u8) (offset >> 8);
+		if (at24c->chip.flags & EE_ADDR2) {
+			msg.len = 2;
+		} else {
+			msg.len = 1;
+			msg.buf++;
+		}
+		status = i2c_transfer(at24c->client.adapter, &msg, 1);
+		dev_dbg(&at24c->client.dev,
+				"addr %02x, set current to %d --> %d\n",
+				msg.addr, offset, status);
+		if (status < 0)
+			goto done;
+		next_addr = at24c->next_addr = offset;
+	}
+
+	/* issue bounded sequential reads for the data bytes, knowing that
+	 * read page rollover goes to the next page and/or memory block.
+	 */
+	while (count > 0) {
+		unsigned	segment;
+
+		if (count > io_limit)
+			segment = io_limit;
+		else
+			segment = count;
+
+		msg.len = segment;
+		msg.buf = buf;
+		msg.flags = I2C_M_RD;
+		status = i2c_transfer(at24c->client.adapter, &msg, 1);
+		dev_dbg(&at24c->client.dev, "read %d, %d --> %d\n",
+				transferred, count, status);
+
+		if (status < 0)
+			break;
+		if (status != segment) {
+			status = -EIO;
+			break;
+		}
+
+		count -= segment;
+
+		at24c->next_addr += segment;
+		offset += segment;
+		buf += segment;
+		transferred += segment;
+	}
+done:
+	if (status <= 0)
+		at24c->next_addr = at24c->bin.size;
+	up(&at24c->lock);
+	return transferred ? transferred : status;
+}
+
+static ssize_t
+at24c_bin_read(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client	*client;
+	struct at24c_data	*at24c;
+
+	client = to_i2c_client(container_of(kobj, struct device, kobj));
+	at24c = i2c_get_clientdata(client);
+
+	if (unlikely(off >= at24c->bin.size))
+		return 0;
+	if ((off + count) > at24c->bin.size)
+		count = at24c->bin.size - off;
+	if (unlikely(!count))
+		return count;
+
+	/* we don't maintain caches for any data:  simpler, cheaper */
+	return at24c_ee_read(at24c, buf, off, count);
+}
+
+
+/* Note that if the hardware write-protect pin is pulled high, the whole
+ * chip is normally write protected.  But there are plenty of product
+ * variants here, including OTP fuses and partial chip protect.
+ */
+static ssize_t
+at24c_ee_write(struct at24c_data *at24c, char *buf, loff_t off, size_t count)
+{
+	struct i2c_msg		msg;
+	ssize_t			status = 0;
+	unsigned		written = 0;
+	u32			scratch;
+	unsigned		buf_size;
+	unsigned long		timeout, retries;
+
+	/* temp buffer lets us stick the address at the beginning */
+	buf_size = at24c->chip.page_size;
+	if (buf_size > io_limit)
+		buf_size = io_limit;
+	msg.buf = kmalloc(buf_size + 2, GFP_KERNEL);
+	if (!msg.buf)
+		return -ENOMEM;
+	msg.flags = 0;
+
+	/* For write, rollover is within the page ... so we write at
+	 * most one page, then manually roll over to the next page.
+	 */
+	down(&at24c->lock);
+	timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+	retries = 0;
+	do {
+		unsigned	segment;
+		unsigned	offset = (unsigned) off;
+
+		/* maybe adjust i2c address and offset */
+		msg.addr = at24c->client.addr;
+		status = at24c_ee_address(&at24c->chip, &msg,
+						&offset, &scratch);
+		if (status < 0)
+			break;
+
+		/* write as much of a page as we can */
+		segment = buf_size - (offset % buf_size);
+		if (segment > count)
+			segment = count;
+		msg.len = segment + 1;
+		if (at24c->chip.flags & EE_ADDR2) {
+			msg.len++;
+			msg.buf[1] = (u8) offset;
+			msg.buf[0] = (u8) (offset >> 8);
+			memcpy(&msg.buf[2], buf, segment);
+		} else {
+			msg.buf[0] = offset;
+			memcpy(&msg.buf[1], buf, segment);
+		}
+
+		/* The chip may take a while to finish its previous write;
+		 * this write also polls for completion of the last one.
+		 * So we always retry a few times.
+		 */
+		status = i2c_transfer(at24c->client.adapter, &msg, 1);
+		dev_dbg(&at24c->client.dev,
+			"write %d bytes to %02x at %d --> %d (%ld)\n",
+			segment, msg.addr, offset, status, jiffies);
+		if (status < 0) {
+			if (retries++ < 3 || time_after(timeout, jiffies)) {
+				/* REVISIT:  at HZ=100, this is sloooow */
+				msleep(1);
+				continue;
+			}
+			dev_err(&at24c->client.dev,
+				"write %d bytes offset %d to %02x, "
+				"%ld ticks err %d\n",
+				segment, offset, msg.addr,
+				jiffies - (timeout - EE_TIMEOUT),
+				status);
+			status = -ETIMEDOUT;
+			break;
+		}
+
+		off += segment;
+		buf += segment;
+		count -= segment;
+		written += segment;
+		if (status < 0 || count == 0) {
+			if (written != 0)
+				status = written;
+			break;
+		}
+
+		/* yielding may avoid the losing msleep() path above */
+		yield();
+		timeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);
+		retries = 0;
+	} while (count > 0);
+	at24c->next_addr = at24c->bin.size;
+	up(&at24c->lock);
+
+	kfree(msg.buf);
+	return status;
+}
+
+static ssize_t
+at24c_bin_write(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client	*client;
+	struct at24c_data	*at24c;
+
+	client = to_i2c_client(container_of(kobj, struct device, kobj));
+	at24c = i2c_get_clientdata(client);
+
+	if (unlikely(off >= at24c->bin.size))
+		return -EFBIG;
+	if ((off + count) > at24c->bin.size)
+		count = at24c->bin.size - off;
+	if (unlikely(!count))
+		return count;
+
+	return at24c_ee_write(at24c, buf, off, count);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver at24c_driver;
+
+static void __devinit
+at24c_activate(
+	struct i2c_adapter	*adapter,
+	int			address,
+	const struct chip_desc	*chip,
+	int			writable
+)
+{
+	struct at24c_data	*at24c;
+	int			err = -ENOMEM;
+
+	if (!(at24c = kcalloc(1, sizeof(struct at24c_data)
+			+ chip->i2c_addr_mask * sizeof(struct i2c_client),
+			GFP_KERNEL)))
+		goto fail;
+
+	init_MUTEX(&at24c->lock);
+	at24c->chip = *chip;
+	snprintf(at24c->client.name, I2C_NAME_SIZE,
+			"%s I2C EEPROM", at24c->chip.name);
+
+	/* Export the EEPROM bytes through sysfs, since that's convenient.
+	 * By default, only root should see the data (maybe passwords etc)
+	 */
+	at24c->bin.attr.name = "eeprom";
+	at24c->bin.attr.mode = S_IRUSR;
+	at24c->bin.attr.owner = THIS_MODULE;
+	at24c->bin.read = at24c_bin_read;
+
+	at24c->bin.size = at24c->chip.byte_len;
+	at24c->next_addr = at24c->bin.size;
+	if (writable) {
+		at24c->bin.write = at24c_bin_write;
+		at24c->bin.attr.mode |= S_IWUSR;
+	}
+
+	/* register the first chip address */
+	address &= ~at24c->chip.i2c_addr_mask;
+
+	at24c->client.addr = address;
+	at24c->client.adapter = adapter;
+	at24c->client.driver = &at24c_driver;
+	at24c->client.flags = 0;
+	i2c_set_clientdata(&at24c->client, at24c);
+
+	/* prevent AT24RF08 corruption, a possible consequence of the
+	 * probe done by the i2c core (verifying a chip is present).
+	 */
+	if (chip->flags & EE_24RF08)
+		i2c_smbus_write_quick(&at24c->client, 0);
+
+	if ((err = i2c_attach_client(&at24c->client)))
+		goto fail;
+	at24c->users++;
+
+	/* then register any other addresses, so other drivers can't */
+	if (chip->i2c_addr_mask) {
+		unsigned		i;
+		struct i2c_client	*c;
+
+		for (i = 0; i < chip->i2c_addr_mask; i++) {
+			c = &at24c->extras[i];
+			c->addr = address + i + 1;
+			c->adapter = adapter;
+			c->driver = &at24c_driver;
+
+			i2c_set_clientdata(c, at24c);
+			snprintf(c->name, sizeof c->name,
+				"%s address %d", chip->name, i + 2);
+			err = i2c_attach_client(c);
+			if (err == 0)
+				at24c->users++;
+		}
+	}
+
+	sysfs_create_bin_file(&at24c->client.dev.kobj, &at24c->bin);
+
+	dev_info(&at24c->client.dev, "%d byte %s%s\n",
+		at24c->bin.size, at24c->client.name,
+		writable ? " (writable)" : "");
+	dev_dbg(&at24c->client.dev, "page_size %d, i2c_addr_mask %d\n",
+		at24c->chip.page_size, at24c->chip.i2c_addr_mask);
+	return;
+fail:
+	dev_dbg(&adapter->dev, "%s probe, err %d\n", at24c_driver.name, err);
+	kfree(at24c);
+}
+
+static int __devinit
+at24c_old_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	const struct chip_desc	*chip;
+	int			writable;
+
+	chip = which_chip(adapter, address, &writable);
+	if (chip)
+		at24c_activate(adapter, address, chip, writable);
+	return 0;
+}
+
+
+static int __devinit at24c_attach_adapter(struct i2c_adapter *adapter)
+{
+	/* REVISIT: using SMBUS calls would improve portability, though
+	 * maybe at the cost of support for 16 bit memory addressing...
+	 */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_dbg(&adapter->dev, "%s probe, no I2C\n",
+			at24c_driver.name);
+		return 0;
+	}
+	return i2c_probe(adapter, &addr_data, at24c_old_probe);
+}
+
+static int __devexit at24c_detach_client(struct i2c_client *client)
+{
+	int			err;
+	struct at24c_data	*at24c;
+
+	err = i2c_detach_client(client);
+	if (err) {
+		dev_err(&client->dev, "deregistration failed, %d\n", err);
+		return err;
+	}
+
+	/* up to eight clients per chip, detached in any order... */
+	at24c = i2c_get_clientdata(client);
+	if (at24c->users-- == 0)
+		kfree(at24c);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver at24c_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "at24c",
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= at24c_attach_adapter,
+	.detach_client	= __devexit_p(at24c_detach_client),
+};
+
+static int __init at24c_init(void)
+{
+#ifdef CONFIG_OMAP_OSK_MISTRAL
+	if (machine_is_omap_osk()) {
+		n_chip_names = 1;
+		n_probe = 1;
+		chip_names[0] = "24c04";
+		probe[0] = 0;
+		probe[1] = 0x50;
+	}
+
+#endif
+	return i2c_add_driver(&at24c_driver);
+}
+module_init(at24c_init);
+
+static void __exit at24c_exit(void)
+{
+	i2c_del_driver(&at24c_driver);
+}
+module_exit(at24c_exit);
+
+MODULE_DESCRIPTION("Driver for AT24C series (and compatible) I2C EEPROMs");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.17.8/drivers/i2c/chips/Kconfig linux-2.6.17.8-sh/drivers/i2c/chips/Kconfig
--- linux-2.6.17.8/drivers/i2c/chips/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/chips/Kconfig	2006-08-23 13:29:46.489786000 +0100
@@ -25,6 +25,29 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called ds1374.
 
+config I2C_AT24C
+	tristate "EEPROMs from most vendors"
+	depends on I2C && EXPERIMENTAL
+	help
+	  Enable this driver to get read/write support to most I2C EEPROMs,
+	  after you configure the driver to know about each eeprom on on
+	  your target board.  Use these generic chip names, instead of
+	  vendor-specific ones like at24c64 or 24lc02:
+
+	     24c00, 24c01, 24c02, dimm (readonly 24c02), 24c04, 24c08,
+	     24c16, 24c32, 24c64, 24c128, 24c256, 24c512, 24c1024
+
+	  Unless you like data loss puzzles, always be sure that any chip
+	  you configure as a 24c32 (32 Kbits) or larger is NOT really a
+	  24c16 (16 Kbits) or smaller.  (Marking the chip as readonly won't
+	  help recover from this.)
+
+	  The current version of this driver demands full I2C bus support,
+	  so it won't yet work on most PCs (limited to SMBUS).
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called at24c.
+
 config SENSORS_EEPROM
 	tristate "EEPROM reader"
 	depends on I2C && EXPERIMENTAL
@@ -117,4 +140,32 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called max6875.
 
+config  SENSORS_M41ST85Y
+        tristate "M41ST85Y RTC Driver (EXPERIMENTAL)"
+        depends on CPU_SUBTYPE_ST40 && (I2C_STM || I2C_ST40_PIO) && EXPERIMENTAL
+        help
+          Enable this entry to support the external M41ST85Y Real Time Clock
+	  device series roundly fitted on some I2C serial bus interface seeng that
+          nothing board have one.
+
+config SENSORS_M41ST85Y_IRQPIO
+        depends on SENSORS_M41ST85Y
+	hex "IRQ PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-IRQ line.
+          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x0F represents PIO1[7]. Default is
+          an invalid value.
+
+config SENSORS_M41ST85Y_SQWPIO
+        depends on SENSORS_M41ST85Y
+	hex "SQW PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-SQW line.
+          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x07 represents PIO0[7]. Default is
+          an invalid value.
+
 endmenu
diff -Naur linux-2.6.17.8/drivers/i2c/chips/m41st85y.c linux-2.6.17.8-sh/drivers/i2c/chips/m41st85y.c
--- linux-2.6.17.8/drivers/i2c/chips/m41st85y.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/chips/m41st85y.c	2006-08-23 13:29:46.409783000 +0100
@@ -0,0 +1,733 @@
+/* STMicroelectronics
+
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, wrssc to the Free Software
+* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/poll.h>
+#include <linux/i2c.h>
+#include <linux/bcd.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/stpio.h>
+#include <asm/io.h>
+
+/* General debugging */
+#undef M41ST85Y_DEBUG
+#ifdef  M41ST85Y_DEBUG
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define M41ST85Y_NAME		"m41st85y"
+#define M41ST85Y_NREGMAP	0x14	/* no of RTC's registers */
+#define M41ST85Y_ADDR		0x68	/* MY41ST85Y slave address */
+#define M41ST85Y_ISOPEN		0x01	/* means /dev/rtc is in use */
+#define M41ST85Y_RD		0x01	/* read flag for a i2c transfer */
+#define M41ST85Y_WR		0x00	/* write flag for a i2c transfer */
+#define M41ST85Y_INVALID	0xff	/* invalid value */
+#define M41ST85Y_IRQ_LEVEL	0x01	/* default value. 1=High, 0=Low */
+#define M41ST85Y_SQW_LEVEL	0x00	/* default value. 1=High, 0=Low */
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define M41ST85Y_NOBUS		0x03	/* number of I2C busses */
+#else
+#error platform not supported.
+#endif
+
+/*
+ * Addressing compliante to SPI PIO address mechanism
+ * Address = [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+ */
+#define m41st85y_get_pioport(address)	((address >> 0x03) & 0x0f)
+#define m41st85y_get_piopin(address)	(address & 0x07)
+
+struct m41st85y_s {
+	struct i2c_adapter *adapter;
+	long data_queue;
+	wait_queue_head_t wait_queue;
+	unsigned long status;
+	unsigned long epoch;
+	unsigned long irqp;
+	spinlock_t lock;
+	spinlock_t task_lock;
+	rtc_task_t *task_callback;
+	unsigned int cmd;
+} m41st85y;
+
+static __u8 rbuf[M41ST85Y_NREGMAP];
+static __u8 wbuf[M41ST85Y_NREGMAP];
+static __u32 busid = M41ST85Y_NOBUS;
+static __u32 irqpio = CONFIG_SENSORS_M41ST85Y_IRQPIO, sqwpio =
+    CONFIG_SENSORS_M41ST85Y_SQWPIO;
+static struct stpio_pin *m41st85y_irqpio, *m41st85y_sqwpio;
+
+static int m41st85y_transfer(struct m41st85y_s *instance,
+			     __u8 * buf, __u8 len, __u8 oper, __u8 at_addr)
+{
+	struct i2c_msg msg[2];
+	__u8 n_msg;
+
+	if (oper == M41ST85Y_WR) {
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = oper;
+		msg[0].len = len;
+		msg[0].buf = buf;
+		n_msg = 1;
+	} else {
+		rbuf[0] = at_addr;
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = M41ST85Y_WR;
+		msg[0].len = 1;
+		msg[0].buf = rbuf;
+
+		msg[1].addr = M41ST85Y_ADDR;
+		msg[1].flags = M41ST85Y_RD;
+		msg[1].len = len;
+		msg[1].buf = buf;
+		n_msg = 2;
+	}
+	return i2c_transfer(instance->adapter, msg, n_msg);
+}
+
+static int m41st85y_power_up(void)
+{
+	__u8 RegsMap[M41ST85Y_NREGMAP];
+
+	while (1) {
+		m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0F);
+		if ((rbuf[0] & 0x40) == 0x00)
+			break;
+		printk(KERN_INFO
+		       "There was an alarm during the back-up mode AF 0x%x\n",
+		       rbuf[0]);
+	}
+
+	if (m41st85y_transfer(&m41st85y,
+			      RegsMap + 1, M41ST85Y_NREGMAP - 1,
+			      M41ST85Y_RD, 0x01) >= 0) {
+		RegsMap[0x00] = 0x01;	/* address offset */
+		RegsMap[0x01] &= ~0x80;	/* ST bit, wake up the oscillator */
+		RegsMap[0x08] = 0x80;	/* IRQ/FT/OUT line is driven low */
+		RegsMap[0x0A] &= ~0x40;	/* Swq disable */
+		RegsMap[0x0C] &= ~0x40;	/* Update the TIMEKEEPER registers */
+		RegsMap[0x13] &= 0x00;	/* Default Square wave output is 1Hz */
+		m41st85y.irqp = 1;	/* 1Hz */
+		if (m41st85y_transfer(&m41st85y,
+				      RegsMap, M41ST85Y_NREGMAP,
+				      M41ST85Y_WR, M41ST85Y_INVALID) < 0) {
+			printk(KERN_ERR "I2C transfer write failure\n");
+			return -EIO;
+		}
+		/* waiting RTC hardware restart */
+		ssleep(1);
+		return 0;
+	}
+	printk(KERN_ERR "I2C transfer read failure.\n");
+	return -EIO;
+}
+
+static int m41st85y_alarmset(unsigned int ioctl_cmd, struct rtc_time *ltime)
+{
+	if ((ioctl_cmd != RTC_UIE_ON) && (ioctl_cmd != RTC_ALM_SET))
+		return -1;
+
+	if (ioctl_cmd == RTC_UIE_ON) {
+		rtc_get_rtc_time(ltime);
+
+		/* alarm update */
+		wbuf[0] = 0x0A;
+		wbuf[1] = BIN2BCD(ltime->tm_mon);
+		wbuf[2] = 0xC0 | BIN2BCD(ltime->tm_mday);
+		wbuf[3] = 0x80 | BIN2BCD(ltime->tm_hour);
+		wbuf[4] = 0x80 | BIN2BCD(ltime->tm_min);
+		wbuf[5] = 0x80 | BIN2BCD(ltime->tm_sec + 1);
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 6, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			wbuf[0] = 0x0A;
+			wbuf[1] = (wbuf[1] | 0x80);
+			DPRINTK("enable AFE writing %#x\n", wbuf[1]);
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 2, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	} else {
+		if (m41st85y_transfer(&m41st85y,
+				      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0) {
+			/* alarm update */
+			wbuf[0] = 0x0A;
+			wbuf[1] = (rbuf[0] & 0xE0) | BIN2BCD(ltime->tm_mon);
+			wbuf[2] = (rbuf[1] & 0xC0) | BIN2BCD(ltime->tm_mday);
+			wbuf[3] = (rbuf[2] & 0xC0) | BIN2BCD(ltime->tm_hour);
+			wbuf[4] = (rbuf[3] & 0x80) | BIN2BCD(ltime->tm_min);
+			wbuf[5] = (rbuf[4] & 0x80) | BIN2BCD(ltime->tm_sec);
+			DPRINTK("writing alarm date\n");
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 6, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	}
+	return -EIO;
+}
+
+void m41st85y_handler(struct stpio_pin *pin, void *dev)
+{
+	struct m41st85y_s *instance = dev;
+	char skip = 0;
+
+	stpio_disable_irq(pin);
+
+	if ((instance->cmd == RTC_PIE_ON) || (instance->cmd == RTC_UIE_ON)) {
+		if (stpio_get_pin(pin) == M41ST85Y_IRQ_LEVEL) {
+			skip = 1;
+			stpio_enable_irq(pin, M41ST85Y_IRQ_LEVEL);
+		} else
+			stpio_enable_irq(pin, !M41ST85Y_IRQ_LEVEL);
+	}
+
+	if (!skip) {
+		/* Now do the rest of the actions */
+		spin_lock(&instance->task_lock);
+		if (instance->task_callback)
+			instance->task_callback->func(instance->task_callback->
+						      private_data);
+		spin_unlock(&instance->task_lock);
+
+		instance->data_queue++;
+		wake_up(&instance->wait_queue);
+	}
+}
+
+static int m41st85y_ioctl(struct inode *inode,
+			  struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	struct rtc_time ltime;
+
+	memset(&ltime, 0, sizeof(struct rtc_time));
+	m41st85y.cmd = cmd;
+
+	switch (cmd) {
+	case RTC_UIE_OFF:	/* Mask ints from RTC updates.  */
+		DPRINTK("RTC_UIE_OFF\n");
+	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit    */
+		DPRINTK("RTC_AIE_OFF\n");
+	case RTC_AIE_ON:	/* Allow alarm interrupts.      */
+		{
+			DPRINTK("RTC_AIE_ON\n");
+
+			/* reading AFE bits */
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				char n_data = 2;
+
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_AIE_ON) {
+					stpio_enable_irq(m41st85y_irqpio,
+							 M41ST85Y_IRQ_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x80);
+				} else {
+					stpio_disable_irq(m41st85y_irqpio);
+					m41st85y.cmd = 0;	/* disable status */
+					n_data = 6;
+					wbuf[1] = (rbuf[0] & ~0xA0);	/* disabling AFE flag bit */
+					wbuf[2] = wbuf[3] = wbuf[4] = wbuf[5] = 0x00;	/* disabling RPT5-RPT1 */
+				}
+
+				DPRINTK(" writing AFE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, n_data, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0) {
+					return 0;
+				}
+			}
+			return -EIO;
+		}
+	case RTC_PIE_OFF:	/* Mask periodic int. enab. bit */
+		DPRINTK("RTC_PIE_OFF\n");
+	case RTC_PIE_ON:	/* Allow periodic ints          */
+		{
+			DPRINTK("RTC_PIE_ON\n");
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_PIE_OFF) {
+					stpio_disable_irq(m41st85y_sqwpio);
+					wbuf[1] = (rbuf[0] & ~0x40);
+				} else {
+					stpio_enable_irq(m41st85y_sqwpio,
+							 M41ST85Y_SQW_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x40);
+				}
+
+				DPRINTK("writing on SWQE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, 2, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0)
+					return 0;
+			}
+			return -EIO;
+		}
+	case RTC_UIE_ON:	/* Allow ints for RTC updates. (one per second) */
+		{
+			DPRINTK("RTC_UIE_ON\n");
+			stpio_enable_irq(m41st85y_irqpio, M41ST85Y_IRQ_LEVEL);
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_ALM_READ:	/* Read the present alarm time */
+		{
+			DPRINTK("RTC_ALM_READ\n");
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				ltime.tm_mon = BCD2BIN(rbuf[0] & 0x1f);
+				ltime.tm_mday = BCD2BIN(rbuf[1] & 0x3f);
+				ltime.tm_hour = BCD2BIN(rbuf[2] & 0x3f);
+				ltime.tm_min = BCD2BIN(rbuf[3] & 0x7f);
+				ltime.tm_sec = BCD2BIN(rbuf[4] & 0x7f);
+				return copy_to_user((void __user *)arg,
+						    &ltime,
+						    sizeof ltime) ? -EFAULT : 0;
+			}
+			return -EIO;
+		}
+	case RTC_ALM_SET:	/* Store a time into the alarm */
+		{
+			DPRINTK("RTC_ALM_SET\n");
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_RD_TIME:	/* Read the time/date from RTC  */
+		{
+			DPRINTK("RTC_RD_TIME\n");
+			rtc_get_rtc_time(&ltime);
+			return copy_to_user((void __user *)arg,
+					    &ltime, sizeof ltime) ? -EFAULT : 0;
+		}
+	case RTC_SET_TIME:	/* Set the RTC */
+		{
+			DPRINTK("RTC_SET_TIME\n");
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 8, M41ST85Y_RD, 0x00) >= 0)
+			{
+				/* time update */
+				wbuf[0] = 0x00;
+				wbuf[1] = 0x00;
+				wbuf[2] =
+				    (rbuf[1] & 0x80) | BIN2BCD(ltime.tm_sec);
+				wbuf[3] =
+				    (rbuf[2] & 0x80) | BIN2BCD(ltime.tm_min);
+				wbuf[4] =
+				    (rbuf[3] & 0xC0) | BIN2BCD(ltime.tm_hour);
+				memcpy(&wbuf[5], &rbuf[4], sizeof(char));
+				wbuf[6] =
+				    (rbuf[5] & 0xC0) | BIN2BCD(ltime.tm_mday);
+				wbuf[7] =
+				    (rbuf[6] & 0xE0) | BIN2BCD(ltime.tm_mon);
+				wbuf[8] =
+				    BIN2BCD((ltime.tm_year - m41st85y.epoch));
+
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, 9, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0)
+					return 0;
+			}
+			return -EIO;
+		}
+	case RTC_IRQP_READ:	/* Read the periodic IRQ rate.  */
+		{
+			DPRINTK("RTC_IRQP_READ\n");
+			return put_user(m41st85y.irqp,
+					(unsigned long __user *)arg);
+		}
+	case RTC_IRQP_SET:	/* Set periodic IRQ rate.       */
+		{
+			DPRINTK("RTC_IRQP_SET\n");
+			wbuf[0] = 0x13;
+			switch (arg) {
+			case 0:
+				wbuf[1] = 0x00;
+				break;
+			case 1:
+				wbuf[1] = 0xF0;
+				break;
+			case 2:
+				wbuf[1] = 0xE0;
+				break;
+			case 4:
+				wbuf[1] = 0xD0;
+				break;
+			case 8:
+				wbuf[1] = 0xC0;
+				break;
+			case 16:
+				wbuf[1] = 0xB0;
+				break;
+			case 32:
+				wbuf[1] = 0xA0;
+				break;
+			case 64:
+				wbuf[1] = 0x90;
+				break;
+			case 128:
+				wbuf[1] = 0x80;
+				break;
+			case 256:
+				wbuf[1] = 0x70;
+				break;
+			case 512:
+				wbuf[1] = 0x60;
+				break;
+			case 1024:
+				wbuf[1] = 0x50;
+				break;
+			case 2048:
+				wbuf[1] = 0x40;
+				break;
+			case 4096:
+				wbuf[1] = 0x30;
+				break;
+			case 8192:
+				wbuf[1] = 0x20;
+				break;
+			case 32768:
+				wbuf[1] = 0x10;
+				break;
+			default:
+				return -1;
+			}
+
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 2, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+			return -EIO;
+		}
+	case RTC_EPOCH_READ:	/* Read the epoch.      */
+		{
+			DPRINTK("RTC_EPOCH_READ\n");
+			return put_user(m41st85y.epoch,
+					(unsigned long __user *)arg);
+		}
+	case RTC_EPOCH_SET:	/* Set the epoch.       */
+		{
+			DPRINTK("RTC_EPOCH_SET\n");
+			copy_from_user(&m41st85y.epoch, (void *)arg,
+				       sizeof(long));
+			return 0;
+		}
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int m41st85y_open(struct inode *inode, struct file *file)
+{
+	int lerrno = -EBUSY;
+
+	spin_lock_irq(&m41st85y.lock);
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		spin_unlock_irq(&m41st85y.lock);
+		return lerrno;
+	}
+
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	m41st85y.data_queue = 0;
+	spin_unlock_irq(&m41st85y.lock);
+	return 0;
+}
+
+static int m41st85y_close(struct inode *inode, struct file *file)
+{
+	spin_lock_irq(&m41st85y.lock);
+	m41st85y.status &= ~M41ST85Y_ISOPEN;
+	spin_unlock_irq(&m41st85y.lock);
+	return 0;
+}
+
+static ssize_t m41st85y_read(struct file *filp, char __user * buff,
+			     size_t count, loff_t * offp)
+{
+	wait_event(m41st85y.wait_queue, m41st85y.data_queue != 0);
+	m41st85y.data_queue = 0;
+
+	if ((m41st85y.cmd == RTC_AIE_ON) || (m41st85y.cmd == RTC_UIE_ON)) {
+		while (1) {
+			m41st85y_transfer(&m41st85y,
+					  rbuf, 1, M41ST85Y_RD, 0x0F);
+
+			DPRINTK("AF 0x%x\n", rbuf[0]);
+			if ((rbuf[0] & 0x40) == 0x00)
+				break;
+		}
+	}
+	copy_to_user(buff, &m41st85y.data_queue, sizeof(m41st85y.data_queue));
+	return sizeof(m41st85y.data_queue);
+}
+
+/*
+ * exported stuffs
+ */
+
+EXPORT_SYMBOL(rtc_register);
+EXPORT_SYMBOL(rtc_unregister);
+EXPORT_SYMBOL(rtc_control);
+
+int rtc_register(rtc_task_t * task)
+{
+	if (task == NULL || task->func == NULL)
+		return -EINVAL;
+	spin_lock_irq(&m41st85y.lock);
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		spin_unlock_irq(&m41st85y.lock);
+		return -EBUSY;
+	}
+	spin_lock(&m41st85y.task_lock);
+	if (m41st85y.task_callback) {
+		spin_unlock(&m41st85y.task_lock);
+		spin_unlock_irq(&m41st85y.lock);
+		return -EBUSY;
+	}
+
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	m41st85y.task_callback = task;
+	spin_unlock(&m41st85y.task_lock);
+	spin_unlock_irq(&m41st85y.lock);
+	return 0;
+}
+
+int rtc_control(rtc_task_t * task, unsigned int cmd, unsigned long arg)
+{
+	spin_lock_irq(&m41st85y.task_lock);
+	if (m41st85y.task_callback != task) {
+		spin_unlock_irq(&m41st85y.task_lock);
+		return -ENXIO;
+	}
+	spin_unlock_irq(&m41st85y.task_lock);
+	return m41st85y_ioctl(NULL, NULL, cmd, arg);
+}
+
+int rtc_unregister(rtc_task_t * task)
+{
+	spin_lock_irq(&m41st85y.lock);
+	spin_lock(&m41st85y.task_lock);
+
+	if (m41st85y.task_callback != task) {
+		spin_unlock(&m41st85y.task_lock);
+		spin_unlock_irq(&m41st85y.lock);
+		return -ENXIO;
+	}
+	m41st85y.task_callback = NULL;
+
+	/* diasbilng the RTC's AIE, UIE and PIE control */
+	if (m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0A) >= 0) {
+		wbuf[0] = 0x0A;
+		wbuf[1] = rbuf[0] & ~0xC0;
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 2, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			m41st85y.status &= ~M41ST85Y_ISOPEN;
+			spin_unlock(&m41st85y.task_lock);
+			spin_unlock_irq(&m41st85y.lock);
+			return 0;
+		}
+	}
+
+	spin_unlock(&m41st85y.task_lock);
+	spin_unlock_irq(&m41st85y.lock);
+	return -EIO;
+}
+
+void rtc_get_rtc_time(struct rtc_time *ltime)
+{
+	if (ltime == NULL)
+		return;
+
+	memset(ltime, 0, sizeof(struct rtc_time));
+
+	if (m41st85y_transfer(&m41st85y, rbuf, 9, M41ST85Y_RD, 0x00) >= 0) {
+		ltime->tm_sec = BCD2BIN(rbuf[1] & 0x7f);
+		ltime->tm_min = BCD2BIN(rbuf[2] & 0x7f);
+		ltime->tm_hour = BCD2BIN(rbuf[3] & 0x3f);
+		ltime->tm_wday = BCD2BIN(rbuf[4] & 0x07);
+		ltime->tm_mday = BCD2BIN(rbuf[5] & 0x3f);
+		ltime->tm_mon = BCD2BIN(rbuf[6] & 0x1f);
+		ltime->tm_year = BCD2BIN(rbuf[7]);
+	}
+}
+
+/*
+ * The various file operations we support.
+ */
+
+static struct file_operations m41st85y_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = m41st85y_read,
+	.poll = NULL /* ??? m41st85y_poll */ ,
+	.ioctl = m41st85y_ioctl,
+	.open = m41st85y_open,
+	.release = m41st85y_close,
+	.fasync = NULL /* ??? m41st85y_fasync */ ,
+};
+
+static struct miscdevice m41st85y_dev = {
+	RTC_MINOR,
+	M41ST85Y_NAME,
+	&m41st85y_fops
+};
+
+static int __init m41st85y_init(void)
+{
+	int i = M41ST85Y_NOBUS;
+	struct i2c_msg msg[1];
+
+	if ((irqpio != M41ST85Y_INVALID) && (sqwpio != M41ST85Y_INVALID)) {
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = M41ST85Y_WR;
+		msg[0].len = 0;
+		msg[0].buf = NULL;
+		if (busid < M41ST85Y_NOBUS) {
+			DPRINTK("busid[%d]\n", busid);
+			m41st85y.adapter = i2c_get_adapter(busid);
+			if (i2c_transfer(m41st85y.adapter, msg, 1) >= 0)
+				i = busid;
+		} else {
+			/* searching in which bus is the RTC */
+			for (i = 0; i < M41ST85Y_NOBUS; i++) {
+				int res;
+
+				m41st85y.adapter = i2c_get_adapter(i);
+				if ((res =
+				     i2c_transfer(m41st85y.adapter, msg,
+						  1)) >= 0)
+					break;
+				DPRINTK("RTC device isn't on I2C-%d=%d\n", i,
+					res);
+			}
+		}
+		if (i != M41ST85Y_NOBUS) {
+			DPRINTK("RTC device is on I2C-%d=yes\n", i);
+
+			if (m41st85y_power_up() >= 0) {
+				if (misc_register(&m41st85y_dev) == 0) {
+					spin_lock_init(&m41st85y.lock);
+					spin_lock_init(&m41st85y.task_lock);
+					init_waitqueue_head(&
+							    (m41st85y.
+							     wait_queue));
+					m41st85y.cmd = 0;	/* none */
+					m41st85y.epoch = 1900;	/* default value on Linux */
+					printk(KERN_INFO
+					       "RTC-IRQ line plugged on PIO[%d,%d]\n",
+					       m41st85y_get_pioport(irqpio),
+					       m41st85y_get_piopin(irqpio));
+					printk(KERN_INFO
+					       "RTC-SQW line plugged on PIO[%d,%d]\n",
+					       m41st85y_get_pioport(sqwpio),
+					       m41st85y_get_piopin(sqwpio));
+
+					if ((m41st85y_irqpio =
+					     stpio_request_pin
+					     (m41st85y_get_pioport(irqpio),
+					      m41st85y_get_piopin(irqpio),
+					      M41ST85Y_NAME,
+					      STPIO_BIDIR_Z1)) != NULL) {
+						if ((m41st85y_sqwpio =
+						     stpio_request_pin
+						     (m41st85y_get_pioport
+						      (sqwpio),
+						      m41st85y_get_piopin
+						      (sqwpio), M41ST85Y_NAME,
+						      STPIO_IN)) != NULL) {
+							stpio_request_irq
+							    (m41st85y_irqpio,
+							     M41ST85Y_IRQ_LEVEL,
+							     m41st85y_handler,
+							     (void *)&m41st85y);
+							stpio_request_irq
+							    (m41st85y_sqwpio,
+							     M41ST85Y_SQW_LEVEL,
+							     m41st85y_handler,
+							     (void *)&m41st85y);
+
+							printk(KERN_INFO
+							       "STMicroelectronics M41ST85Y RTC Driver up I2C-%d initialized\n",
+							       i);
+							return 0;
+						} else
+							stpio_free_pin
+							    (m41st85y_irqpio);
+					}
+					printk(KERN_ERR
+					       "RTC request irq failure.\n");
+					misc_deregister(&m41st85y_dev);
+				} else
+					printk(KERN_ERR
+					       "RTC driver registration failure.\n");
+			}
+		} else
+			printk(KERN_ERR
+			       "I2C adapter layer initialization failure.\n");
+	} else
+		printk(KERN_ERR
+		       "PIOs input values are required. irqpio=0Xxx sqwpio=0Xxx\n");
+
+	printk(KERN_ERR
+	       "STMicroelectronics M41ST85Y RTC initialization failure.\n");
+	return -ENODEV;
+}
+
+static void __exit m41st85y_exit(void)
+{
+	stpio_free_irq(m41st85y_irqpio);
+	stpio_free_pin(m41st85y_irqpio);
+	stpio_free_irq(m41st85y_sqwpio);
+	stpio_free_pin(m41st85y_sqwpio);
+
+	misc_deregister(&m41st85y_dev);
+	printk(KERN_INFO "STMicroelectronics M41ST85Y RTC Driver released.\n");
+}
+
+module_param(busid, uint, 0644);
+module_param(irqpio, uint, 0644);
+module_param(sqwpio, uint, 0644);
+module_init(m41st85y_init);
+module_exit(m41st85y_exit);
+MODULE_PARM_DESC(busid, "I2C bus ID");
+MODULE_PARM_DESC(irqpio, "PIO port/pin for RTC-IRQ line");
+MODULE_PARM_DESC(busid, "PIO port/pin for RTC-SWQ line");
+MODULE_DESCRIPTION("External RTC upon I2C");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/i2c/chips/Makefile linux-2.6.17.8-sh/drivers/i2c/chips/Makefile
--- linux-2.6.17.8/drivers/i2c/chips/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/i2c/chips/Makefile	2006-08-23 13:29:46.505783000 +0100
@@ -2,6 +2,9 @@
 # Makefile for miscellaneous I2C chip drivers.
 #
 
+# let 'at24c' get a chance before the less powerful 'eeprom'
+obj-$(CONFIG_I2C_AT24C)		+= at24c.o
+
 obj-$(CONFIG_SENSORS_DS1337)	+= ds1337.o
 obj-$(CONFIG_SENSORS_DS1374)	+= ds1374.o
 obj-$(CONFIG_SENSORS_EEPROM)	+= eeprom.o
@@ -12,6 +15,7 @@
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
+obj-$(CONFIG_SENSORS_M41ST85Y)	+= m41st85y.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Naur linux-2.6.17.8/drivers/ide/ide.c linux-2.6.17.8-sh/drivers/ide/ide.c
--- linux-2.6.17.8/drivers/ide/ide.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/ide.c	2006-08-23 13:29:36.598553000 +0100
@@ -1604,6 +1604,12 @@
 				drive->forced_geom = 1;
 				hwif->noprobe = 0;
 				goto done;
+#ifdef CONFIG_BLK_DEV_ST40IDE
+			case 1: /* <dma rate> */
+				drive->autodma = 1;
+				sh_udma_choosen[unit] = vals[0];
+				goto done;
+#endif
 			default:
 				goto bad_option;
 		}
@@ -1776,6 +1782,7 @@
 
 extern void pnpide_init(void);
 extern void h8300_ide_init(void);
+extern void ide_sh_init(void);
 
 /*
  * probe_for_hwifs() finds/initializes "known" IDE interfaces
@@ -1840,6 +1847,10 @@
 #ifdef CONFIG_H8300
 	h8300_ide_init();
 #endif
+
+#if defined(CONFIG_IDE_SH)
+        ide_sh_init();
+#endif
 }
 
 void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
diff -Naur linux-2.6.17.8/drivers/ide/ide-cd.c linux-2.6.17.8-sh/drivers/ide/ide-cd.c
--- linux-2.6.17.8/drivers/ide/ide-cd.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/ide-cd.c	2006-08-23 13:29:48.257829000 +0100
@@ -324,6 +324,7 @@
 #include <asm/unaligned.h>
 
 #include "ide-cd.h"
+#include "ide-piodma.h"
 
 static DEFINE_MUTEX(idecd_ref_mutex);
 
@@ -850,7 +851,11 @@
 
 	/* Set up the controller registers. */
 	/* FIXME: for Virtual DMA we must check harder */
+#ifdef CONFIG_BLK_DEV_IDEDMA_PIO
+	HWIF(drive)->OUTB(0, IDE_FEATURE_REG);
+#else
 	HWIF(drive)->OUTB(info->dma, IDE_FEATURE_REG);
+#endif
 	HWIF(drive)->OUTB(0, IDE_IREASON_REG);
 	HWIF(drive)->OUTB(0, IDE_SECTOR_REG);
 
@@ -910,6 +915,9 @@
 	}
 
 	/* Arm the interrupt handler. */
+	if (info->dma) {
+		handler = ide_piodma_set_driver_handler(drive, handler, &(info->dma));
+	}
 	ide_set_handler(drive, handler, rq->timeout, cdrom_timer_expiry);
 
 	/* ATAPI commands get padded out to 12 bytes minimum */
diff -Naur linux-2.6.17.8/drivers/ide/ide-io.c linux-2.6.17.8-sh/drivers/ide/ide-io.c
--- linux-2.6.17.8/drivers/ide/ide-io.c	2006-08-21 14:42:22.786771000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/ide-io.c	2006-08-23 13:29:39.598622000 +0100
@@ -1092,7 +1092,7 @@
  * the driver.  This makes the driver much more friendlier to shared IRQs
  * than previous designs, while remaining 100% (?) SMP safe and capable.
  */
-static void ide_do_request (ide_hwgroup_t *hwgroup, int masked_irq)
+void ide_do_request (ide_hwgroup_t *hwgroup, int masked_irq)
 {
 	ide_drive_t	*drive;
 	ide_hwif_t	*hwif;
diff -Naur linux-2.6.17.8/drivers/ide/ide-piodma.h linux-2.6.17.8-sh/drivers/ide/ide-piodma.h
--- linux-2.6.17.8/drivers/ide/ide-piodma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/ide-piodma.h	2006-08-23 13:29:48.275829000 +0100
@@ -0,0 +1,33 @@
+/*
+ * PIO DMA support for Linux IDE
+ *
+ * Copyright (C) 2005  STMicroelectronics Limited.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef _IDE_VDMA_H
+#define _IDE_VDMA_H
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_PIO
+
+#define TASKFILE_ATAPI_IN	0x4001
+#define TASKFILE_ATAPI_OUT	0x4004
+
+extern void init_ide_piodma(void);
+extern void default_hwif_iops_piodma(ide_hwif_t *hwif);
+extern ide_handler_t *ide_piodma_set_driver_handler(
+		ide_drive_t *drive, ide_handler_t *hdlr, int *dma_flag);
+
+#else /* CONFIG_BLK_DEV_IDEDMA_PIO */
+
+#define init_ide_piodma() ((void) 0)
+#define default_hwif_iops_piodma(hwif) ((void) 0)
+#define ide_piodma_set_driver_handler(drive, hdlr, dma_flag) (hdlr)
+
+#endif /* CONFIG_BLK_DEV_IDEDMA_PIO */
+
+#endif /* _IDE_VDMA_H */
+
diff -Naur linux-2.6.17.8/drivers/ide/Kconfig linux-2.6.17.8-sh/drivers/ide/Kconfig
--- linux-2.6.17.8/drivers/ide/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/Kconfig	2006-08-23 13:29:39.564622000 +0100
@@ -780,6 +780,37 @@
 	  This option enables the use of the sleep LED as a hard drive
 	  activity LED.
 
+config IDE_SH
+	def_bool SUPERH
+
+config BLK_DEV_ST40IDE
+	def_bool CPU_SUBTYPE_STI5528 || CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STB7100
+
+config BLK_DEV_IDEDMA_PIO
+	bool "PIO DMA support (EXPERIMENTAL)"
+	depends on BLK_DEV_ST40IDE && STM_DMA && EXPERIMENTAL
+	default n
+	help
+	  Perform PIO tranfers using a generic (non-IDE) DMA peripheral.
+	  Without a IDE DMA peripheral data transfers are normally performed
+	  by the CPU. Performing these transfers with a DMA peripheral
+	  reduces the CPU time needed to manage the disk while simultanously
+	  improving bandwidth since DMA controller typically pipelines reads
+	  more efficiently than the CPU.
+
+	  Currently supported are ATA hard discs (read/write) and ATAPI CD/DVD
+	  drives (read only).
+
+	  This should only be used on targets where a dedicated IDE DMA
+	  controller is not present or unsuitable for paged memory systems.
+	  If unsure say N.
+
+config BLK_DEV_IDEDMA_STHDDI
+	def_bool BLK_DEV_ST40IDE && !CPU_SUBTYPE_STB7100
+
+config BLK_DEV_IDEDMA_ST40
+	def_bool BLK_DEV_IDEDMA_STHDDI && !BLK_DEV_IDEDMA_PIO
+
 config BLK_DEV_IDE_SWARM
 	tristate "IDE for Sibyte evaluation boards"
 	depends on SIBYTE_SB1xxx_SOC
@@ -1040,7 +1071,7 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA || BLK_DEV_IDEDMA_PIO || BLK_DEV_IDEDMA_ST40
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
diff -Naur linux-2.6.17.8/drivers/ide/legacy/ide-cs.c linux-2.6.17.8-sh/drivers/ide/legacy/ide-cs.c
--- linux-2.6.17.8/drivers/ide/legacy/ide-cs.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/legacy/ide-cs.c	2006-08-23 13:29:26.258323000 +0100
@@ -73,6 +73,11 @@
 #define DEBUG(n, args...)
 #endif
 
+
+#if defined(CONFIG_HD64461_PCMCIA) || defined(CONFIG_HD64461_PCMCIA_MODULE)
+#define USE_MEM 1
+#endif
+
 /*====================================================================*/
 
 static const char ide_major[] = {
@@ -117,13 +122,19 @@
     info->p_dev = link;
     link->priv = info;
 
+#ifndef USE_MEM
     link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
     link->io.Attributes2 = IO_DATA_PATH_WIDTH_8;
     link->io.IOAddrLines = 3;
+#endif
     link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
     link->irq.IRQInfo1 = IRQ_LEVEL_ID;
     link->conf.Attributes = CONF_ENABLE_IRQ;
+#ifdef USE_MEM
+    link->conf.IntType = INT_MEMORY;
+#else
     link->conf.IntType = INT_MEMORY_AND_IO;
+#endif
 
     return ide_config(link);
 } /* ide_attach */
@@ -229,6 +240,22 @@
 	    }
 	}
 
+#ifdef USE_MEM
+	if ((cfg->mem.nwin > 0) || (stk->dflt.mem.nwin > 0)) {
+		win_req_t wr;
+		wr.Attributes = WIN_ENABLE|WIN_MEMORY_TYPE_CM;
+		wr.Base = 0;
+		wr.Size = 0;
+		wr.AccessSpeed = 0;
+		link->win = (window_handle_t)link;
+		link->conf.ConfigIndex = cfg->index;
+		if (pcmcia_request_window(&link, &wr, &link->win) != 0)
+			goto next_entry;
+		io_base = wr.Base;
+		ctl_base = io_base + 0x0e;
+		break;
+	}
+#else
 	if (cfg->vpp1.present & (1 << CISTPL_POWER_VNOM))
 	    link->conf.Vpp =
 		cfg->vpp1.param[CISTPL_POWER_VNOM] / 10000;
@@ -262,6 +289,7 @@
 	    /* If we've got this far, we're done */
 	    break;
 	}
+#endif
 
     next_entry:
 	if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
@@ -278,12 +306,19 @@
     CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
     CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
 
+#ifndef USE_MEM
+    /* deal with brain dead IDE resource management */
+    release_region(link->io.BasePort1, link->io.NumPorts1);
+    if (link->io.NumPorts2)
+	release_region(link->io.BasePort2, link->io.NumPorts2);
+
     /* disable drive interrupts during IDE probe */
     outb(0x02, ctl_base);
 
     /* special setup for KXLC005 card */
     if (is_kme)
 	outb(0x81, ctl_base+1);
+#endif
 
     /* retry registration in case device is still spinning up */
     for (hd = -1, i = 0; i < 10; i++) {
@@ -352,6 +387,13 @@
 	   -- need to investigate the required PCMCIA magic */
 	ide_unregister(info->hd);
     }
+
+#ifndef USE_MEM
+    request_region(link->io.BasePort1, link->io.NumPorts1,"ide-cs");
+    if (link->io.NumPorts2)
+		request_region(link->io.BasePort2, link->io.NumPorts2,"ide-cs");
+#endif
+
     info->ndev = 0;
 
     pcmcia_disable_device(link);
diff -Naur linux-2.6.17.8/drivers/ide/Makefile linux-2.6.17.8-sh/drivers/ide/Makefile
--- linux-2.6.17.8/drivers/ide/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/Makefile	2006-08-23 13:29:39.521622000 +0100
@@ -19,7 +19,15 @@
 
 # Core IDE code - must come before legacy
 ide-core-$(CONFIG_BLK_DEV_IDEPCI)	+= setup-pci.o
+ifeq ($(CONFIG_BLK_DEV_ST40IDE), y)
+ifeq ($(CONFIG_BLK_DEV_IDEDMA_STHDDI), y)
+ide-core-$(CONFIG_BLK_DEV_IDEDMA)	+= sh/ide-st40_dma.o
+else
 ide-core-$(CONFIG_BLK_DEV_IDEDMA)	+= ide-dma.o
+endif
+else
+ide-core-$(CONFIG_BLK_DEV_IDEDMA)	+= ide-dma.o
+endif
 ide-core-$(CONFIG_PROC_FS)		+= ide-proc.o
 ide-core-$(CONFIG_BLK_DEV_IDEPNP)	+= ide-pnp.o
 
@@ -37,6 +45,10 @@
 ide-core-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+= ppc/mpc8xx.o
 ide-core-$(CONFIG_BLK_DEV_IDE_PMAC)	+= ppc/pmac.o
 
+# built-in only drivers from sh/
+ide-core-$(CONFIG_IDE_SH)		+= sh/ide-sh.o
+ide-core-$(CONFIG_BLK_DEV_IDEDMA_PIO)	+= sh/ide-piodma.o
+
 # built-in only drivers from h8300/
 ide-core-$(CONFIG_H8300)		+= h8300/ide-h8300.o
 
diff -Naur linux-2.6.17.8/drivers/ide/pci/alim15x3.c linux-2.6.17.8-sh/drivers/ide/pci/alim15x3.c
--- linux-2.6.17.8/drivers/ide/pci/alim15x3.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/pci/alim15x3.c	2006-08-23 13:29:07.359886000 +0100
@@ -65,6 +65,16 @@
 	"PIO mode" };
 
 static char *udmaT[8] = {
+#if defined(CONFIG_SH_MPC1211)
+	"  1T",
+	"1.5T",
+	"  2T",
+	"  3T",
+	"  4T",
+	"2.5T",
+	"  6T",
+	"3.5T"
+#else
 	"1.5T",
 	"  2T",
 	"2.5T",
@@ -73,6 +83,7 @@
 	"  4T",
 	"  6T",
 	"  8T"
+#endif
 };
 
 static char *channel_status[8] = {
@@ -303,7 +314,11 @@
 	u8 cd_dma_fifo = 0;
 	int unit = drive->select.b.unit & 1;
 
+#if defined(CONFIG_SH_MPC1211)
+	pio = ide_get_best_pio_mode(drive, pio, 0, &d);
+#else
 	pio = ide_get_best_pio_mode(drive, pio, 5, &d);
+#endif
 	s_time = ide_pio_timings[pio].setup_time;
 	a_time = ide_pio_timings[pio].active_time;
 	if ((s_clc = (s_time * bus_speed + 999) / 1000) >= 8)
@@ -420,6 +435,10 @@
 		return 0;
 	}
 
+#ifdef CONFIG_SH_MPC1211
+	mode = 1;
+#endif
+
 	/*
 	 *	If the drive sees no suitable cable then UDMA 33
 	 *	is the highest permitted mode
diff -Naur linux-2.6.17.8/drivers/ide/sh/ide-piodma.c linux-2.6.17.8-sh/drivers/ide/sh/ide-piodma.c
--- linux-2.6.17.8/drivers/ide/sh/ide-piodma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/sh/ide-piodma.c	2006-08-23 13:29:49.221852000 +0100
@@ -0,0 +1,1064 @@
+/*
+ * IDE PIO DMA driver
+ *
+ * Copyright (C) 2005  STMicroelectronics Limited
+ *
+ * Based on the old include/asm-sh/ide.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/debugfs.h>
+
+#include <asm/dma.h>
+
+#include "../ide-cd.h"
+#include "../ide-piodma.h"
+
+typedef struct ide_piodma {
+	unsigned int ref_count;
+	ide_handler_t *driver_handler;
+	int *driver_dma_flag;
+	struct scatterlist dma_table[PRD_ENTRIES];
+	int dma_busy;
+	int dma_deferred_configure;
+	int dma_end_request_from_callback;
+	unsigned int dma_direction_write;
+	int dma_chan_id;
+	struct dma_channel *dma_channel;
+} ide_piodma_t;
+
+/* The number of attempts we will make to allocate a DMA channel before issuing
+ * a warning (the order of driver initialisation means that we will often not
+ * receive a DMA channel while we enumerate the partition table)
+ */
+#define REQUEST_DMA_LIMIT 64
+
+/*#define CONFIG_IDE_PIODMA_DEBUG*/
+#ifdef CONFIG_IDE_PIODMA_DEBUG
+static int enable_dma = 1;
+static int enable_trace = 0;
+static int hide_errors = 0;
+#else
+#define enable_dma 1
+#define enable_trace 0
+#define hide_errors 0
+#endif
+
+#define PDMA_TRACE(fmt, args...) \
+	((void) (enable_trace && printk("%s: " fmt, __FUNCTION__, ##args)))
+#define PDMA_ERROR(fmt, args...) \
+	((void) (!hide_errors && \
+	         printk(KERN_ERR "%s: " fmt,__FUNCTION__,##args)))
+
+/**
+ * Utility functions               -       Generic PIO utility functions
+ *
+ * Copied directly from ide-taskfile.c.
+ */
+
+static u8 wait_drive_not_busy(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int retries = 100;
+	u8 stat;
+
+	/*
+	 * Last sector was transfered, wait until drive is ready.
+	 * This can take up to 10 usec, but we will wait max 1 ms
+	 * (drive_cmd_intr() waits that long).
+	 */
+	while (((stat = hwif->INB(IDE_STATUS_REG)) & BUSY_STAT) && retries--)
+		udelay(10);
+
+	if (!retries)
+		PDMA_ERROR("%s: drive still BUSY!\n", drive->name);
+
+	return stat;
+}
+
+static ide_startstop_t task_error(ide_drive_t *drive, struct request *rq,
+				  const char *s, u8 stat)
+{
+	if (rq->bio) {
+		ide_hwif_t *hwif = drive->hwif;
+		int sectors = hwif->nsect - hwif->nleft;
+
+		switch (hwif->data_phase) {
+		case TASKFILE_IN:
+			if (hwif->nleft)
+				break;
+			/* fall through */
+		case TASKFILE_OUT:
+			sectors--;
+			break;
+		case TASKFILE_MULTI_IN:
+			if (hwif->nleft)
+				break;
+			/* fall through */
+		case TASKFILE_MULTI_OUT:
+			sectors -= drive->mult_count;
+		default:
+			break;
+		}
+
+		if (sectors > 0) {
+			if (rq->rq_disk) {
+				ide_driver_t *drv;
+
+				drv = *(ide_driver_t **)rq->rq_disk->private_data;
+				drv->end_request(drive, 1, sectors);
+			} else {
+				ide_end_request(drive, 1, sectors);
+			}
+		}
+	}
+	return ide_error(drive, s, stat);
+}
+
+static void task_end_request(ide_drive_t *drive, struct request *rq, u8 stat)
+{
+       if (rq->flags & REQ_DRIVE_TASKFILE) {
+               ide_task_t *task = rq->special;
+
+               if (task->tf_out_flags.all) {
+                       u8 err = drive->hwif->INB(IDE_ERROR_REG);
+                       ide_end_drive_cmd(drive, stat, err);
+                       return;
+               }
+       }
+
+       if (rq->rq_disk) {
+	       ide_driver_t *drv;
+
+	       drv = *(ide_driver_t **)rq->rq_disk->private_data;
+	       drv->end_request(drive, 1, rq->hard_nr_sectors);
+       } else
+	       ide_end_request(drive, 1, rq->hard_nr_sectors);
+}
+
+/**
+ * ide_piodma_do_cpu_transfer - Use the CPU to perform the data transfer
+ * @drive: drive to control
+ * @len: number of bytes to be transfered
+ * @write: whether to perform a write or a read
+ */
+static ide_startstop_t ide_piodma_do_cpu_transfer(ide_drive_t *drive,
+	struct scatterlist *sg, unsigned int nents, unsigned int write)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int i;
+
+	for (i=0; i<nents; i++) {
+		u8 *buf = (void *) P2SEGADDR(sg[i].dma_address);
+
+		BUG_ON(sg[i].dma_address > 0x20000000);
+
+		if (write) {
+			PDMA_TRACE("%s: ata_output_data(%p, %p, %d)\n",
+				   drive->name, drive, buf, sg[i].length / 4);
+			hwif->ata_output_data(drive, buf, sg[i].length / 4);
+		} else {
+			PDMA_TRACE("%s: ata_input_data(%p, %p, %d)\n",
+				   drive->name, drive, buf, sg[i].length / 4);
+			hwif->ata_input_data(drive, buf, sg[i].length / 4);
+		}
+	}
+
+	return ide_started;
+}
+
+/**
+ * ide_piodma_build_sg - Populate a subset of the master scatterlist
+ * @drive: drive to control
+ * @subsg: scatter list to populate
+ * @length: length of scatter list to generate (in bytes)
+ */
+static int ide_piodma_build_sg (ide_drive_t *drive, struct scatterlist *subsg,
+                                unsigned int len)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg = hwif->sg_table;
+	unsigned int cursub = 0, ofs;
+	int length = len;
+
+	if (length < 0) {
+		return -1;
+	}
+
+	PDMA_TRACE("%s: building %d byte scatterlist\n", drive->name, length);
+
+	subsg[cursub] = sg[hwif->cursg];
+
+	/* the first entry in the scatter list may be offset */
+	ofs = hwif->cursg_ofs * SECTOR_SIZE;
+	subsg[cursub].offset += ofs;
+	subsg[cursub].dma_address += ofs;
+	subsg[cursub].length -= ofs;
+
+	length -= subsg[cursub].length;
+
+	while (length > 0) {
+		subsg[++cursub] = sg[++hwif->cursg];
+		length -= subsg[cursub].length;
+
+		/* I'll a little worried about running of the end of sg_table
+		 * because the CD driver appears to always read 32KB
+		 * irrespective of what the upper layers want. This code at
+		 * least makes sure we squawk a bit if 'something bad' happens.
+		 */
+		if (hwif->cursg >= hwif->sg_nents) {
+			/* TODO: we should fabricate some dummy transfers if
+			 * we don't want to rely on the (60 second) timeout
+			 * handler.
+			 */
+			BUG();
+		}
+	}
+
+	ofs = -length;
+	if (0 == ofs) {
+		hwif->cursg++;
+		hwif->cursg_ofs = 0;
+	} else {
+		hwif->cursg_ofs = (sg[hwif->cursg].length - ofs) / SECTOR_SIZE;
+		subsg[cursub].length -= ofs;
+	}
+
+	hwif->nleft -= len / SECTOR_SIZE;
+
+	return cursub+1;
+}
+
+static inline void ide_piodma_issue_deferred_transaction(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	int res;
+	unsigned int write = pd->dma_direction_write;
+	struct scatterlist *sg;
+	unsigned int nents;
+
+	pd->dma_deferred_configure = 0;
+
+	PDMA_TRACE("%s: about to issue deferred DMA request\n", drive->name);
+	res = dma_configure_channel(pd->dma_channel);
+	if (0 == res) {
+		dma_xfer(pd->dma_chan_id);
+	} else {
+		PDMA_ERROR("%s: cannot configure deferred DMA request "
+		           "(res = %d)\n", drive->name, res);
+
+		if (write) {
+			sg = pd->dma_channel->dst_sg;
+			nents = pd->dma_channel->dst_sg_len;
+		} else {
+			sg = pd->dma_channel->src_sg;
+			nents = pd->dma_channel->src_sg_len;
+		}
+
+		pd->dma_busy = 0;
+		ide_piodma_do_cpu_transfer(drive, sg, nents, write);
+	}
+}
+
+static inline void ide_piodma_end_request(ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+	u8 stat;
+	unsigned long flags;
+
+	PDMA_TRACE("%s: completing IDE request\n", drive->name);
+
+	stat = wait_drive_not_busy(drive);
+	if (!OK_STAT(stat, 0, BAD_R_STAT)) {
+		PDMA_ERROR("%s: bad drive status\n", drive->name);
+		task_error(drive, rq, __FUNCTION__, stat);
+	}
+
+	task_end_request(drive, rq, stat);
+
+	/* This follow on call to ide_do_request() would normally be performed
+	 * by the IDE interrupt handler on receipt of ide_stopped. Since we
+	 * have already left the interrupt handler we must do this here instead.
+	 */
+	BUG_ON(hwgroup->handler); /* paranoia */
+	spin_lock_irqsave(&ide_lock, flags);
+	hwgroup->busy = 0;
+	ide_do_request(hwgroup, IDE_NO_IRQ);
+	spin_unlock_irqrestore(&ide_lock, flags);
+}
+
+static void ide_piodma_dma_completion_handler(void *p)
+{
+	ide_drive_t *drive = p;
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	unsigned long flags;
+
+	PDMA_TRACE("%s: entering PIO DMA completion callback\n", drive->name);
+
+	BUG_ON(!pd->dma_busy);
+
+	spin_lock_irqsave(&ide_lock, flags);
+	if (pd->dma_deferred_configure) {
+		spin_unlock_irqrestore(&ide_lock, flags);
+		ide_piodma_issue_deferred_transaction(drive);
+	} else {
+		pd->dma_busy = 0;
+
+		if (pd->dma_end_request_from_callback) {
+			pd->dma_end_request_from_callback = 0;
+			spin_unlock_irqrestore(&ide_lock, flags);
+			ide_piodma_end_request(drive);
+		} else {
+			spin_unlock_irqrestore(&ide_lock, flags);
+		}
+	}
+}
+
+/* TODO: need an error handler to clear DMA busy and to complete the
+ * DMA request with an error
+ */
+
+static void ide_piodma_prepare_channel(ide_drive_t *drive, unsigned int len,
+				       unsigned int write)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	struct dma_channel *chan;
+	u8 transfer_sz = drive->io_32bit ? 4 : 2;
+
+	chan = get_dma_channel(pd->dma_chan_id);
+	BUG_ON(IS_ERR(chan));
+
+	chan->mode = MODE_FREERUNNING;
+	chan->count = len;
+
+	chan->comp_callback = ide_piodma_dma_completion_handler;
+	chan->comp_callback_param = drive;
+	chan->err_callback = 0;
+
+	chan->flags = LIST_TYPE_UNLINKED | DMA_SETUP_NOBLOCK;
+
+#ifdef CONFIG_STB7100_FDMA
+	/* Currently any attempt to set the FDMA transfer size smaller than
+	 * 32 bytes results in serious failure. Fortunately when the IDE device
+	 * is attached to EMI then the bottom bits of the address bus are
+	 * ignored and the disk continues to work!
+	 */
+	transfer_sz = 32;
+#endif
+
+	if (write) {
+		chan->flags |= DIM_SG_x_0;
+		chan->dar = virt_to_bus((void *) IDE_DATA_REG);
+		chan->dst_sz = transfer_sz;
+	} else {
+		chan->flags |= DIM_0_x_SG;
+		chan->sar = virt_to_bus((void *) IDE_DATA_REG);
+		chan->src_sz = transfer_sz;
+		PDMA_TRACE("sar = %p\n", (void *) chan->sar);
+	}
+
+	pd->dma_channel = chan;
+}
+
+/**
+ * ide_piodma_program_engine - Program the DMA engine to do a PIO transfer
+ * @drive: drive to control
+ * @len: number of bytes to be transfered
+ * @write: whether to perform a write or a read
+ */
+static ide_startstop_t ide_piodma_program_engine(
+	ide_drive_t *drive, unsigned int len, unsigned int write)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	struct scatterlist *sg = pd->dma_table;
+	int nents, res;
+
+	nents = ide_piodma_build_sg(drive, sg, len);
+	if (nents < 0)
+		return ide_stopped;
+
+	if (!enable_dma)
+		return ide_piodma_do_cpu_transfer(drive, sg, nents, write);
+
+	ide_piodma_prepare_channel(drive, len, write);
+
+	if (write) {
+		pd->dma_channel->src_sg = sg;
+		pd->dma_channel->src_sg_len = nents;
+	} else {
+		pd->dma_channel->dst_sg = sg;
+		pd->dma_channel->dst_sg_len = nents;
+	}
+
+	if (pd->dma_busy) {
+		PDMA_TRACE("%s: deferring DMA request\n", drive->name);
+		pd->dma_direction_write = write;
+		pd->dma_deferred_configure = 1;
+	} else {
+		PDMA_TRACE("%s: about to issue DMA request\n", drive->name);
+		res = dma_configure_channel(pd->dma_channel);
+		if (0 != res) {
+			BUG();
+			return ide_piodma_do_cpu_transfer(drive, sg, nents,
+			                                  write);
+		}
+		pd->dma_busy = 1;
+		dma_xfer(pd->dma_chan_id);
+	}
+
+	return ide_started;
+}
+
+/**
+ * ide_piodma_off_quietly	-	Generic DMA kill
+ * @drive: drive to control
+ *
+ * Turn off the current DMA on this IDE controller.
+ */
+static int ide_piodma_off_quietly (ide_drive_t *drive)
+{
+	PDMA_TRACE("%s: quietly disabling PIO DMA\n", drive->name);
+
+	drive->using_dma = 0;
+
+	if (HWIF(drive)->ide_dma_host_off(drive))
+		return 1;
+
+	return 0;
+}
+
+/**
+ * ide_piodma_host_off	-	Generic DMA kill
+ * @drive: drive to control
+ *
+ * Release the resources allocated when we enabled DMA.
+ */
+static int ide_piodma_host_off (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+
+	PDMA_TRACE("%s: deallocating PIO DMA channel\n", drive->name);
+
+	if (pd) {
+		if (0 == --pd->ref_count) {
+			free_dma(pd->dma_chan_id);
+			kfree(pd);
+			ide_set_hwifdata(hwif, NULL);
+		}
+	} else {
+		PDMA_ERROR("%s: PIO DMA is not enabled\n", drive->name);
+	}
+
+	return 0;
+}
+
+/**
+ * ide_piodma_on	-	Enable DMA on a device
+ * @drive: drive to enable DMA on
+ *
+ * Enable PIO DMA for a device on this IDE controller.
+ */
+static int ide_piodma_on (ide_drive_t *drive)
+{
+	PDMA_TRACE("%s: enabling PIO DMA\n", drive->name);
+
+	drive->using_dma = 1;
+	if (HWIF(drive)->ide_dma_host_on(drive))
+		return 1;
+
+	return 0;	/* DMA enabled */
+}
+
+/**
+ * ide_piodma_host_on	-	Enable DMA on a host
+ * @drive: drive to enable for DMA
+ *
+ * Enable DMA on an IDE controller following generic bus mastering
+ * IDE controller behaviour
+ */
+static int ide_piodma_host_on (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+
+	PDMA_TRACE("%s: allocating PIO DMA channel\n", drive->name);
+
+	if (0 == drive->using_dma)
+		return 1;
+
+	if (pd) {
+		pd->ref_count++;
+		return 0;
+	}
+
+	pd = kmalloc(sizeof(ide_piodma_t), GFP_KERNEL);
+	if (!pd) {
+		PDMA_ERROR("%s: not enough memory\n", drive->name);
+		return 1;
+	}
+	pd->ref_count = 0;
+	pd->dma_chan_id = -1;
+	pd->dma_busy = 0;
+
+	ide_set_hwifdata(hwif, pd);
+	return 0; /* DMA enabled */
+}
+
+/**
+ * ide_piodma_check		-	check DMA setup
+ * @drive: drive to check
+ *
+ * Don't use - due for extermination
+ *
+ * This function is slightly mis-named. The original __ide_dma_check sets
+ * using_dma for any drive where this is safe. In our case we are actually
+ * leaving the drive in PIO mode so this is *always* safe and we
+ * unconditionally enable DMA.
+ */
+static int ide_piodma_check (ide_drive_t *drive)
+{
+	PDMA_TRACE("%s: checking whether PIO DMA can be enabled\n",
+	           drive->name);
+
+	drive->using_dma = 1;
+	if (HWIF(drive)->ide_dma_host_on(drive))
+		return 1;
+
+	return 0;	/* DMA enabled */
+}
+
+/**
+ * ide_piodma_ata_sectors	- determine the number of sectors to transfer
+ * @drive: target device
+ *
+ * Returns the number of sectors that an ATA drive has ready in a singleu
+ * PIO interrupt.
+ */
+static inline int ide_piodma_ata_sectors(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (hwif->data_phase == TASKFILE_MULTI_IN ||
+	    hwif->data_phase == TASKFILE_MULTI_OUT)
+		return min_t(unsigned int, hwif->nleft, drive->mult_count);
+
+	return 1;
+}
+
+/**
+ * ide_piodma_ata_intr - handle drive irqs when transfering data in ATA mode
+ * @drive: target device
+ */
+static ide_startstop_t ide_piodma_ata_intr (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	struct request *rq = HWGROUP(drive)->rq;
+	u8 stat = hwif->INB(IDE_STATUS_REG);
+	unsigned int nsect = ide_piodma_ata_sectors(drive);
+
+	PDMA_TRACE("%s: entered PIO DMA ATA interrupt handler\n", drive->name);
+
+	if (hwif->data_phase == TASKFILE_OUT ||
+	    hwif->data_phase == TASKFILE_MULTI_OUT) {
+		if (!OK_STAT(stat, DRIVE_READY, drive->bad_wstat)) {
+			PDMA_ERROR("%s: bad drive status\n", drive->name);
+			return task_error(drive, rq, __FUNCTION__, stat);
+		}
+
+		/* Deal with unexpected ATA data phase. */
+		if (((stat & DRQ_STAT) == 0) ^ !hwif->nleft) {
+			PDMA_ERROR("%s: unexpected ATA data phase\n",
+			           drive->name);
+			return task_error(drive, rq, __FUNCTION__, stat);
+		}
+
+		if (!hwif->nleft) {
+			task_end_request(drive, rq, stat);
+			return ide_stopped;
+		}
+
+		/* Still data left to transfer. */
+		if (!ide_piodma_program_engine(drive, nsect*SECTOR_SIZE,
+		                               WRITE)) {
+			PDMA_ERROR("%s: failed to write data\n", drive->name);
+			return task_error(drive, rq, __FUNCTION__, stat);
+		}
+	} else {
+		if (!ide_piodma_program_engine(drive, nsect*SECTOR_SIZE,
+		                               READ)) {
+			PDMA_ERROR("%s: failed to read data\n", drive->name);
+			return task_error(drive, rq, __FUNCTION__, stat);
+		}
+
+		/* If it was the last datablock check status and finish
+		 * transfer.
+		 */
+		if (!hwif->nleft) {
+			pd->dma_end_request_from_callback = 1;
+			PDMA_TRACE("%s: waiting for DMA to complete\n",
+			           drive->name);
+			/* We don't expect another IDE interrupt so we won't
+			 * arm an interrupt handler.
+			 */
+			return ide_started;
+		}
+	}
+
+	/* Still data left to transfer. */
+	ide_set_handler(drive, &ide_piodma_ata_intr, WAIT_WORSTCASE, NULL);
+	return ide_started;
+}
+
+/**
+ * ide_piodma_call_driver_handler -	get driver handler
+ * @drive:  target device
+ * @failed: if set, we are falling back to the driver interrupt
+ *          handler because we were unable to transfer the data
+ *          (rather than because we have finished).
+ *
+ * Call the device driver handler previously recorded with
+ * ide_piodma_set_handler.
+ */
+static inline ide_startstop_t ide_piodma_call_driver_handler(ide_drive_t *drive, int failed)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	int dma_error;
+
+	if (failed && pd->driver_dma_flag) {
+		dma_error = hwif->ide_dma_end(drive);
+		if (dma_error) {
+			PDMA_ERROR("%s: failed to end DMA transaction (%d)",
+			           drive->name, dma_error);
+		}
+
+		/* since we have 'failed' we are relying on the driver's
+		 * handler to complete any outstanding PIO transfers. many
+		 * of the driver interrupt handlers ignore drive PIO
+		 * requests if they believe that the drive should have
+		 * performed a DMA transfer. by clearing this flag we
+		 * allow the original interrupt handlers to do their job
+		 * properly (only audited for CDROM).
+		 */
+		*(pd->driver_dma_flag) = 0;
+	}
+
+	return pd->driver_handler(drive);
+}
+
+/**
+ * ide_piodma_atapi_in_intr - handle read transfers from ATAPI devices
+ * @drive: target device
+ */
+static ide_startstop_t ide_piodma_atapi_in_intr (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int stat;
+	int ireason, len;
+	u8 lowcyl = 0, highcyl = 0;
+
+	PDMA_TRACE("%s: entering PIO DMA ATAPI read interrupt\n", drive->name);
+
+	/* Check if the drive wants to transfer data, if not this is a job for
+	 * the driver handler.
+	 */
+	stat = hwif->INB(IDE_STATUS_REG);
+	if ((stat & DRQ_STAT) == 0) {
+		return ide_piodma_call_driver_handler(drive, 0);
+	}
+
+	/* Read the interrupt reason and the transfer length. */
+	ireason = hwif->INB(IDE_IREASON_REG) & 0x3;
+	lowcyl  = hwif->INB(IDE_BCOUNTL_REG);
+	highcyl = hwif->INB(IDE_BCOUNTH_REG);
+
+	len = lowcyl + (256 * highcyl);
+
+	/* Check that the ireason (a.k.a. sector count) register expects data
+	 * to shift in the same direction that we do. If the ireason does not
+	 * match up to our expectations then this is pretty fatal, we'll just
+	 * try to get the driver to sort it out for us.
+	 */
+	if (ireason != 2) {
+		/* If this fires then the drive is probably about to write
+		 * to a CD/DVD writer. The fallback should work but has not
+		 * been tested (and really we should have an implementation
+		 * of ide_piodma_atapi_out_intr) so leave this reporting an error.
+		 */
+		PDMA_ERROR("%s: unexpected ireason %d\n", drive->name, ireason);
+		return ide_piodma_call_driver_handler(drive, 1); /* FAILED */
+	}
+
+	/* Assume that the drive will always provide data in multiples
+	   of at least SECTOR_SIZE, as it gets hairy to keep track
+	   of the transfers otherwise.
+	   */
+	if ((len % SECTOR_SIZE) != 0) {
+		return ide_piodma_call_driver_handler(drive, 1); /* FAILED */
+	}
+
+	/* WARNING: I removed loads of pretty nasty code from the cdrom
+	 * interrupt code and replaced it with this call to program the DMA
+	 * engine. I assume this code is much less robust against broken
+	 * drives than the PIO code.
+	 */
+
+	if (ide_stopped == ide_piodma_program_engine(drive, len, READ)) {
+		PDMA_ERROR("%s: failed to read data\n", drive->name);
+		return ide_piodma_call_driver_handler(drive, 1); /* FAILED */
+	}
+
+	PDMA_TRACE("%s: stat = %x\n", drive->name, stat);
+
+	/* Started moving data!  Wait for another interrupt. */
+	ide_set_handler(drive, &ide_piodma_atapi_in_intr, ATAPI_WAIT_PC, NULL);
+	return ide_started;
+}
+
+/**
+ * ide_piodma_setup	-	begin a DMA phase
+ * @drive: target device
+ *
+ * Update the scatterlist so that all the DMA addresses are fully populated
+ * and physically adjacent pages are coallesed.
+ *
+ * Returns 0 on success. If a PIO fallback is required then 1
+ * is returned.
+ */
+static int ide_piodma_setup (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+	struct request *rq = HWGROUP(drive)->rq;
+
+	PDMA_TRACE("%s: preparing for PIO DMA transaction\n", drive->name);
+
+	ide_init_sg_cmd(drive, rq);
+	ide_map_sg(drive, rq);
+
+	if (!pd) {
+		BUG();
+		return 1; /* fallback to PIO */
+	}
+
+	/* Due to unpredictable module initialization sequences we are forced
+	 * to allocate a DMA channel only when we need it. These ordering
+	 * issues also make it likely that we issue warnings when we read the
+	 * partition table.
+	 */
+	if (pd->dma_chan_id < 0) {
+		int chan_id = request_dma(ANY_CHANNEL, __FILE__);
+		if (chan_id < 0) {
+			pd->dma_chan_id--;
+			if (REQUEST_DMA_LIMIT < -pd->dma_chan_id) {
+				pd->dma_chan_id = -1;
+				printk(KERN_ERR "%s: cannot allocate DMA "
+				                "channel for IDE (PIODMA)\n",
+				       drive->name);
+			}
+
+			return 1; /* fallback to PIO */
+		}
+
+		pd->dma_chan_id = chan_id;
+		PDMA_TRACE("%s: allocated DMA channel %d\n",
+		           drive->name, chan_id);
+	}
+
+	if (drive->bswap) {
+		PDMA_ERROR("%s: cannot use PIO DMA because device is byte "
+		           "swapped\n", drive->name);
+		return 1; /* fallback to PIO */
+	}
+
+	hwif->sg_dma_direction = (rq_data_dir(rq) == READ
+	                          ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	hwif->sg_nents = dma_map_sg(NULL, hwif->sg_table, hwif->sg_nents,
+	                            hwif->sg_dma_direction);
+	if (hwif->sg_nents < 0) {
+		PDMA_ERROR("%s: cannot map PIO DMA request\n", drive->name);
+		return 1; /* fallback to PIO */
+	}
+
+	/* ATAPI drivers (or at least the CD driver) do not call ide_exec_cmd()
+	 * which would normally responsible for setting up the data_phase after
+	 * examining the command being issued to the drive. For this reason we
+	 * speculatively assume that this command is going to be an ATAPI
+	 * command knowing that if we are wrong this error will be corrected by
+	 * ide_exec_cmd().
+	 */
+	hwif->data_phase = (rq_data_dir(rq) == WRITE
+	                    ? TASKFILE_ATAPI_OUT : TASKFILE_ATAPI_IN);
+
+	pd->dma_deferred_configure = 0;
+	pd->dma_end_request_from_callback = 0;
+
+	drive->waiting_for_dma = 1;
+	return 0;
+}
+
+/**
+ * ide_piodma_timer_expiry -	handle a timeout while waiting for PIO DMA
+ * @drive: Drive that timed out.
+ */
+static int ide_piodma_timer_expiry(ide_drive_t *drive)
+{
+	PDMA_TRACE("%s: PIO DMA timer expired\n", drive->name);
+	return 0;	/* Not sure what to do here; reset the bus */
+}
+
+
+/**
+ * ide_piodma_exec_cmd	-	Issue cmd to drive.
+ * @drive: target device
+ * @command: cmd to issue
+ *
+ * Note that this function cannot fail but calls functions that can.
+ * Unfortunately this means we can only really report the problem and leave
+ * recovery to the timeout handler. :-(
+ */
+static void ide_piodma_exec_cmd (ide_drive_t *drive, u8 command)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int mult = drive->mult_count, direction;
+	ide_startstop_t startstop;
+	unsigned int nsect;
+
+	PDMA_TRACE("%s: issuing drive command %x\n", drive->name, command);
+
+	/* translate the command */
+	switch (command) {
+	case WIN_WRITEDMA:
+		hwif->data_phase = mult ? TASKFILE_MULTI_OUT : TASKFILE_OUT;
+		command = mult ? WIN_MULTWRITE : WIN_WRITE;
+		direction = WRITE;
+		break;
+	case WIN_WRITEDMA_EXT:
+		hwif->data_phase = mult ? TASKFILE_MULTI_OUT : TASKFILE_OUT;
+		command = mult ? WIN_MULTWRITE_EXT : WIN_WRITE_EXT;
+		direction = WRITE;
+		break;
+	case WIN_READDMA:
+		hwif->data_phase = mult ? TASKFILE_MULTI_IN : TASKFILE_IN;
+		command = mult ? WIN_MULTREAD : WIN_READ;
+		direction = READ;
+		break;
+	case WIN_READDMA_EXT:
+		hwif->data_phase = mult ? TASKFILE_MULTI_IN : TASKFILE_IN;
+		command = mult ? WIN_MULTREAD_EXT : WIN_READ_EXT;
+		direction = READ;
+		break;
+	default:
+		BUG();
+		return;
+	}
+
+	if (WRITE == direction) {
+		PDMA_TRACE("%s: synchronously issuing write command %x "
+		           "[data_phase = %x]\n",
+			   drive->name, command, hwif->data_phase);
+		/* FIXME: ->OUTBSYNC ? */
+		hwif->OUTB(command, IDE_COMMAND_REG);
+
+		if (ide_wait_stat(&startstop, drive, DATA_READY,
+		                  drive->bad_wstat, WAIT_DRQ)) {
+			PDMA_ERROR("%s: no DRQ after issuing %sWRITE%s\n",
+			           drive->name,
+				   drive->hwif->data_phase ? "MULT" : "",
+				   drive->addressing ? "_EXT" : "");
+			return;
+		}
+
+		if (!drive->unmask)
+			local_irq_disable();
+
+		ide_set_handler(drive, &ide_piodma_ata_intr,
+		                WAIT_WORSTCASE, NULL);
+		nsect = ide_piodma_ata_sectors(drive);
+		if (!ide_piodma_program_engine(drive, nsect*SECTOR_SIZE, WRITE))
+			PDMA_ERROR("%s: failed to write initial data block\n",
+			           drive->name);
+	} else {
+		PDMA_TRACE("%s: asynchronously issuing read command %x "
+		           "[data_phase = %x]\n",
+			   drive->name, command, hwif->data_phase);
+		ide_execute_command(drive, command, &ide_piodma_ata_intr,
+				    2*WAIT_CMD, &ide_piodma_timer_expiry);
+	}
+}
+
+/**
+ * ide_piodma_start	-	start DMA transfer
+ * @drive: target device
+ *
+ * This is merely a stub function since all work to start the transfer is
+ * performed by ide_piodma_exec_cmd (ATA) or the driver itself (ATAPI).
+ */
+static void ide_piodma_start (ide_drive_t *drive)
+{
+	PDMA_TRACE("%s: started PIO DMA transaction\n", drive->name);
+
+	/* wait for the PIO interrupt to fire */
+}
+
+/**
+ * ide_piodma_end	-	end a DMA transfer
+ * @drive: target device
+ *
+ * Called when the while DMA request has been safisied in order to clean up
+ * resources allocated during setup.
+ */
+static int ide_piodma_end (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	ide_piodma_t *pd = ide_get_hwifdata(hwif);
+
+	PDMA_TRACE("%s: terminating PIO DMA transaction\n", drive->name);
+
+	drive->waiting_for_dma = 0;
+	dma_stop_channel(pd->dma_chan_id);
+	dma_unmap_sg(NULL, hwif->sg_table, hwif->sg_nents,
+	             hwif->sg_dma_direction);
+	hwif->dma = 0;
+
+	/* TODO: we should report failures in the ATAPI transfers here,
+	 * otherwise the kernel could potentially throw corrupt buffers back to
+	 * userspace.
+	 */
+	return 0;
+}
+
+/**
+ * ide_piodma_test_irq -	Determine whether a dma irq is issued.
+ * @drive: target device
+ *
+ * Returns 1 if dma irq issued, 0 otherwise
+ */
+static int ide_piodma_test_irq (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 stat = hwif->INB(IDE_STATUS_REG);
+
+	PDMA_TRACE("%s: testing for PIO DMA interrupt [stat = %x]\n",
+	           drive->name, stat);
+
+	/* we should never be asked to test for an IRQ when the drive is BSY */
+	while (stat & (1 << 7)) {
+		PDMA_ERROR("%s: cannot test for interrupt when drive is BUSY\n",
+		           drive->name);
+		return 0;
+	}
+
+	if (!drive->waiting_for_dma) {
+		PDMA_ERROR("%s: testing for PIO DMA without setup\n",
+		           drive->name);
+		return 0;
+	}
+
+	return 1;
+}
+
+/**
+ * ide_piodma_timeout -	Timeout handler
+ * @drive: target device
+ */
+static int ide_piodma_timeout (ide_drive_t *drive)
+{
+	PDMA_ERROR("%s: device timeout\n", drive->name);
+	return 1;
+}
+
+/**
+ * ide_piodma_lostirq -	???
+ * @drive: target device
+ */
+static int ide_piodma_lostirq (ide_drive_t *drive)
+{
+	PDMA_ERROR("%s: PIO DMA interrupt recovery\n", drive->name);
+	return 1;
+}
+
+/**
+ * ide_piodma_set_driver_handler -	set the driver handler
+ * @drive: target device
+ * @hdlr:  device driver handler to be called when the ATAPI transfer functions
+ *         have done their bit.
+ * @dma:   pointer to the dma flag, drivers generally require this flag to be
+ *         cleared before sending any work to their interrupt handlers
+ */
+ide_handler_t *ide_piodma_set_driver_handler(ide_drive_t *drive,
+                                             ide_handler_t *hdlr,
+					     int *dma_flag)
+{
+	ide_piodma_t *pd = ide_get_hwifdata(HWIF(drive));
+
+	if (!pd) {
+		BUG();
+		return hdlr;
+	}
+
+	if (dma_flag && 0 == *dma_flag) {
+		BUG();
+		return hdlr;
+	}
+
+	pd->driver_handler = hdlr;
+	pd->driver_dma_flag = dma_flag;
+
+	/* TODO: use data_phase to choose handler */
+	return ide_piodma_atapi_in_intr;
+}
+EXPORT_SYMBOL_GPL (ide_piodma_call_driver_handler);
+
+void init_ide_piodma(void)
+{
+#ifdef CONFIG_IDE_PIODMA_DEBUG
+	struct dentry *dir;
+
+	dir = debugfs_create_dir("piodma", NULL);
+	if (dir) {
+		(void) debugfs_create_bool("dma", 0600, dir, &enable_dma);
+		(void) debugfs_create_bool("trace", 0600, dir, &enable_trace);
+		(void) debugfs_create_bool("hide_errors", 0600, dir, &hide_errors);
+	}
+#endif
+}
+EXPORT_SYMBOL_GPL (init_ide_piodma);
+
+void default_hwif_iops_piodma(ide_hwif_t *hwif)
+{
+	hwif->rqsize = 256;
+
+	/* this is a nop on the STb7100 */
+	{
+		extern void _ide_setup_dma(ide_hwif_t *,
+		                           unsigned long, unsigned int);
+		hddi_setup_dma(hwif, ATA_ADDRESS, 0x400)
+	}
+
+	hwif->ide_dma_off_quietly = &ide_piodma_off_quietly;
+	hwif->ide_dma_host_off = &ide_piodma_host_off;
+	hwif->ide_dma_on = &ide_piodma_on;
+	hwif->ide_dma_host_on = &ide_piodma_host_on;
+	hwif->ide_dma_check = &ide_piodma_check;
+	hwif->dma_setup = &ide_piodma_setup;
+	hwif->dma_exec_cmd = &ide_piodma_exec_cmd;
+	hwif->dma_start = &ide_piodma_start;
+	hwif->ide_dma_end = &ide_piodma_end;
+	hwif->ide_dma_test_irq = &ide_piodma_test_irq;
+	hwif->ide_dma_timeout = &ide_piodma_timeout;
+	hwif->ide_dma_lostirq = &ide_piodma_lostirq;
+}
+EXPORT_SYMBOL_GPL (default_hwif_iops_piodma);
diff -Naur linux-2.6.17.8/drivers/ide/sh/ide-sh.c linux-2.6.17.8-sh/drivers/ide/sh/ide-sh.c
--- linux-2.6.17.8/drivers/ide/sh/ide-sh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/sh/ide-sh.c	2006-08-23 13:29:39.496622000 +0100
@@ -0,0 +1,329 @@
+/*
+ * SuperH default IDE host driver
+ *
+ * Copyright (C) 2004, 2005  Paul Mundt
+ *
+ * Based on the old include/asm-sh/ide.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Last modified: June 2005.
+ * 		  Added the hw_setup function, in order to perform the ide
+ *		  st40 initialization. Modified ide_sh_init, now only pio
+ *		  timing initialization is performed, whereas dma timing are
+ *		  initialized on demand when transfer in dma mode is required.
+ *		  This is dued because now different device could operate at
+ *		  different dma speed, established through the command line
+ *		  or based to the max dma rate supported by the device.
+ *		  DMA setup is performed only for those platforms that support
+ *		  the HDDI interface. STB7100mboard works in pio mode 4 only,
+ *		  fixed into EMI bank 3.
+ */
+
+#include <linux/ide.h>
+
+#include "../ide-piodma.h"
+
+#if defined(CONFIG_BLK_DEV_ST40IDE)
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/machvec.h>
+
+extern ide_hwif_t ide_hwifs[MAX_HWIFS];
+int sh_udma_choosen[] = {[0 ... ((MAX_HWIFS * MAX_DRIVES) - 1)] = -1 };
+
+#ifdef HDDI_INTERFACE_PRESENT
+extern void _ide_setup_dma(ide_hwif_t *, unsigned long, unsigned int);
+
+/* HDDI PIO timing registers! */
+#define HDDI_DPIO_I        (ATA_ADDRESS + 0x00000090)
+#define HDDI_DPIO_IORDY    (ATA_ADDRESS + 0x00000094)
+#define HDDI_DPIO_WR       (ATA_ADDRESS + 0x00000098)
+#define HDDI_DPIO_RD       (ATA_ADDRESS + 0x0000009C)
+#define HDDI_DPIO_WREN     (ATA_ADDRESS + 0x000000A0)
+#define HDDI_DPIO_AH       (ATA_ADDRESS + 0x000000A4)
+#define HDDI_DPIO_WRRE     (ATA_ADDRESS + 0x000000A8)
+#define HDDI_DPIO_RDRE     (ATA_ADDRESS + 0x000000AC)
+
+typedef struct {
+	unsigned int ir;
+	unsigned int iordy;
+	unsigned int wr;
+	unsigned int rd;
+	unsigned int wren;
+	unsigned int ah;
+	unsigned int wrre;
+	unsigned int rdre;
+} pio_t;
+
+static pio_t pioTime[] = {
+	/* Level:    Ir    IORdy   Wr    Rd    WrEn    AH    WrRe    RdRe   */
+	/*   0 */ {70, 40, 120, 120, 10, 20, 340, 330},
+	/*   1 */ {50, 40, 80, 80, 10, 20, 190, 190},
+	/*   2 */ {30, 40, 50, 50, 10, 10, 100, 110},
+	/*   3 */ {30, 40, 30, 30, 10, 10, 70, 70},
+	/*   4 */ {30, 40, 20, 20, 10, 10, 30, 30}
+};
+
+void set_pio_timings(int prate)
+{
+
+	/*
+	 ** configure HDDI PIO register access timings
+	 */
+	ctrl_outl(_ata_adjust(pioTime[prate].ir), HDDI_DPIO_I);
+	ctrl_outl(_ata_adjust(pioTime[prate].iordy), HDDI_DPIO_IORDY);
+	ctrl_outl(_ata_adjust(pioTime[prate].wr), HDDI_DPIO_WR);
+	ctrl_outl(_ata_adjust(pioTime[prate].rd), HDDI_DPIO_RD);
+	ctrl_outl(_ata_adjust(pioTime[prate].ah), HDDI_DPIO_AH);
+	ctrl_outl(_ata_adjust(pioTime[prate].wren), HDDI_DPIO_WREN);
+	ctrl_outl(_ata_adjust(pioTime[prate].wrre), HDDI_DPIO_WRRE);
+	ctrl_outl(_ata_adjust(pioTime[prate].rdre), HDDI_DPIO_RDRE);
+
+#ifdef DEBUG
+	printk
+	    ("ST40-HDDI: set PIO %d timings (i %u, IOrdy %u, Wr %u, Rd %u, WrEn %u, Ah %u, WrRe %u, RdRe %u)\n",
+	     PIO_RATE, ctrl_inl(HDDI_DPIO_I), ctrl_inl(HDDI_DPIO_IORDY),
+	     ctrl_inl(HDDI_DPIO_WR), ctrl_inl(HDDI_DPIO_RD),
+	     ctrl_inl(HDDI_DPIO_WREN), ctrl_inl(HDDI_DPIO_AH),
+	     ctrl_inl(HDDI_DPIO_WRRE), ctrl_inl(HDDI_DPIO_RDRE));
+#endif
+}
+#endif
+
+/* Check if there are devices plugged on the IDE interface.
+ * It returns 1 if at least a device is present, 0 if no device
+ * is plugged on IDE interface.
+ * If there are no devices plugged, probing will be not extecuted.
+ */
+
+int check_dev_present(ide_hwif_t * hw_int)
+{
+	int i, j, timeout;
+
+	timeout = 0;
+	while (timeout < 10) {
+		for (i = 0; i < MAX_HWIFS; i++) {
+			hw_int = &ide_hwifs[i];
+			for (j = 0; j < MAX_DRIVES; j++) {
+				SELECT_DRIVE(&hw_int->drives[j]);
+				mdelay(50);
+				if (ctrl_inb
+				    (ide_hwifs->
+				     io_ports[IDE_CONTROL_OFFSET]) & BUSY_STAT)
+					timeout++;
+				else
+					return 1;
+			}
+		}
+		mdelay(50);
+	}
+	/* Select the first device */
+	hw_int = &ide_hwifs[0];
+	mdelay(50);
+	SELECT_DRIVE(&hw_int->drives[0]);
+	mdelay(50);
+
+	return 0;
+}
+
+static inline int __init hw_setup(hw_regs_t * hw, ide_hwif_t * hwifc)
+{
+	unsigned long base = ATA_REG_ADDRESS;
+
+	if (!request_region(base, 8, "ide-sh"))
+		return -EBUSY;
+	if (!request_region(base + CTRL_REG_OFFSET, 1, "ide-sh")) {
+		release_region(base, 8);
+		return -EBUSY;
+	}
+
+	memset(hw, 0, sizeof(hw_regs_t));
+	ide_sh_init_hwif_ports(hw, base, base + CTRL_REG_OFFSET, NULL);
+	memcpy(hwifc->hw.io_ports, hw->io_ports, sizeof(hwifc->hw.io_ports));
+	memcpy(&hwifc->hw, hw, sizeof(*hw));
+	memcpy(hwifc->io_ports, hwifc->hw.io_ports, sizeof(hwifc->hw.io_ports));
+	hwifc->hold = 1;
+
+	hw->irq = ide_default_irq_st40;
+	hw->chipset = ide_generic;
+	hwifc->irq = hw->irq;
+	hwifc->chipset = hw->chipset;
+	hwifc->ultra_mask = 0x3f;	/* UDMA mode 0 to 5 */
+	hwifc->atapi_dma = 1;	/* Set atapi capable to go in dma mode */
+	hwifc->mmio = 2;
+	return 0;
+}
+
+void __init ide_sh_init(void)
+{
+	int i, idx;
+	static int called = 0;
+	ide_hwif_t *hwif;
+	hw_regs_t hw;
+
+	/* be sure to call it once
+	 */
+	if (called)
+		return;
+	called = 1;
+	printk(KERN_INFO "ide: SuperH generic IDE interface\n");
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		hwif = &ide_hwifs[i];
+		if (hw_setup(&hw, hwif) < 0)
+			goto region_cleanup;
+	}
+
+	ide_enable()
+
+	    hddi_reset()
+#ifdef DEBUG
+	    printk("ST40 ide setup: perform software reset\n");
+#endif
+
+#ifdef DEBUG
+	printk("ST40-HDDI setup: perform ATA interrupt reset\n");
+#endif
+	/* Perform an interrupt reset */
+	ctrl_outl(0x02, ide_hwifs->io_ports[IDE_CONTROL_OFFSET]);
+
+#ifdef DEBUG
+	printk("ST40-HDDI setup: bus clock = %d hertz\n",
+	       boot_cpu_data.bus_clock);
+#endif
+
+	hddi_set_pio_timings(PIO_RATE)
+
+	    /* DMA timings will be setted when read/write dma command
+	     * will be raised.
+	     */
+	    for (i = 0; i < MAX_HWIFS; ++i) {
+		hwif = &ide_hwifs[i];
+
+#if defined CONFIG_BLK_DEV_IDEDMA_ST40
+		/*
+		 * Limit the I/O request to 4k since the ST40 DMA
+		 * engine does not support scatter/gather.
+		 * ide_setup_dma(): to be called in case of not
+		 * IDE PCI chipset
+		 */
+		hwif->rqsize = 4;
+		hddi_setup_dma(hwif, ATA_ADDRESS, 0x400);
+#elif defined CONFIG_BLK_DEV_IDEDMA_PIO
+		default_hwif_iops_piodma(hwif);
+#endif
+	}
+
+	if (!check_dev_present(hwif))
+		hwif->noprobe = 1;
+
+	init_ide_piodma();
+
+	return;
+
+      region_cleanup:
+	for (idx = 0; idx < i; idx++) {
+		unsigned long base = ATA_REG_ADDRESS;
+
+		release_region(base + CTRL_REG_OFFSET, 1);
+		release_region(base, 8);
+	}
+	return;
+}
+
+#else				/* CONFIG_BLK_DEV_ST40IDE */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+
+enum {
+	IDE_SH_CFCARD_IO = 0x1f0,
+	IDE_SH_PCMCIA_IO = 0x170,
+};
+
+static struct sh_ide_hwif {
+	unsigned long base;
+	int irq;
+} sh_ide_hwifs[] __initdata = {
+	{
+	IDE_SH_CFCARD_IO, IRQ_CFCARD}, {
+	IDE_SH_PCMCIA_IO, IRQ_PCMCIA}, {
+0,},};
+
+static inline int __init hw_setup(hw_regs_t * hw, int idx)
+{
+	unsigned long base = sh_ide_hwifs[idx].base;
+
+	if (!request_region(base, 8, "ide-sh"))
+		return -EBUSY;
+	if (!request_region(base + 0x206, 1, "ide-sh")) {
+		release_region(base, 8);
+		return -EBUSY;
+	}
+
+	memset(hw, 0, sizeof(hw_regs_t));
+	ide_std_init_ports(hw, base, base + 0x206);
+
+	hw->irq = sh_ide_hwifs[idx].irq;
+	hw->chipset = ide_generic;
+
+	return 0;
+}
+
+static inline void __init hwif_setup(ide_hwif_t * hwif)
+{
+	hwif->mmio = 2;
+	default_hwif_iops_piodma(hwif);
+}
+
+void __init ide_sh_init(void)
+{
+	int i, idx;
+
+	printk(KERN_INFO "ide: SuperH generic IDE interface\n");
+
+	init_ide_piodma();
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		ide_hwif_t *hwif;
+		hw_regs_t hw;
+
+		if (!sh_ide_hwifs[i].base) {
+			printk(KERN_ERR "ide-sh: Attempting to register ide%d "
+			       "when only %d interfaces are available.\n",
+			       i, i - 1);
+			break;
+		}
+
+		if (hw_setup(&hw, i) < 0)
+			goto region_cleanup;
+
+		idx = ide_register_hw(&hw, &hwif);
+		if (idx == -1) {
+			printk(KERN_ERR
+			       "ide-sh: IDE interface registration failed\n");
+			i++;	/* release this interface too */
+			goto region_cleanup;
+		}
+
+		hwif_setup(hwif);
+	}
+
+      region_cleanup:
+	for (idx = 0; idx < i; idx++) {
+		unsigned long base = sh_ide_hwifs[idx].base;
+
+		release_region(base + 0x206, 1);
+		release_region(base, 8);
+	}
+}
+
+#endif				/* CONFIG_BLK_DEV_ST40IDE */
diff -Naur linux-2.6.17.8/drivers/ide/sh/ide-st40_dma.c linux-2.6.17.8-sh/drivers/ide/sh/ide-st40_dma.c
--- linux-2.6.17.8/drivers/ide/sh/ide-st40_dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/ide/sh/ide-st40_dma.c	2006-08-23 13:29:37.057553000 +0100
@@ -0,0 +1,1343 @@
+/* DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).
+ *
+ * By default, DMA support is prepared for use, but is currently enabled only
+ * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),
+ * or which are recognized as "good" (see table below).  Drives with only mode0
+ * or mode1 (multi/single) DMA should also work with this chipset/driver
+ * (eg. MC2112A) but are not enabled by default.
+ *
+ * Use "hdparm -i" to view modes supported by a given drive.
+ *
+ * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling
+ * DMA support, but must be (re-)compiled against this kernel version or later.
+ *
+ * To enable DMA, use "hdparm -d1 /dev/hd?" on a per-drive basis after booting.
+ * If problems arise, ide.c will disable DMA operation after a few retries.
+ * This error recovery mechanism works and has been extremely well exercised.
+ *
+ * IDE drives, depending on their vintage, may support several different modes
+ * of DMA operation.  The boot-time modes are indicated with a "*" in
+ * the "hdparm -i" listing, and can be changed with *knowledgeable* use of
+ * the "hdparm -X" feature.  There is seldom a need to do this, as drives
+ * normally power-up with their "best" PIO/DMA modes enabled.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <linux/scatterlist.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+/* HDDI U-DMA timing registers! */
+#define HDDI_UDMA_RP       (ATA_ADDRESS + 0x000000F0)
+#define HDDI_UDMA_ACK      (ATA_ADDRESS + 0x000000F4)
+#define HDDI_UDMA_ENV      (ATA_ADDRESS + 0x000000F8)
+#define HDDI_UDMA_CVS      (ATA_ADDRESS + 0x000000FC)
+#define HDDI_UDMA_SS       (ATA_ADDRESS + 0x00000100)
+#define HDDI_UDMA_ML       (ATA_ADDRESS + 0x00000104)
+#define HDDI_UDMA_RFS      (ATA_ADDRESS + 0x00000108)
+#define HDDI_UDMA_DVS      (ATA_ADDRESS + 0x0000010C)
+#define HDDI_UDMA_DVH      (ATA_ADDRESS + 0x00000110)
+
+/*
+ * HDDI timings: Controlling U-DMA access protocol ------------------------
+ */
+typedef struct {
+    unsigned int   ack;
+    unsigned int   env;
+    unsigned int   rp;
+    unsigned int   ml;
+    unsigned int   cvs;
+    unsigned int   ss;
+    unsigned int   dvs;
+    unsigned int   dvh;
+} udma_t;
+
+static udma_t udmaTime[] = {
+   /* Level:    ack    env    rp    ml    cvs    ss    dvs    dvh   */
+   /*   0 */ {   30,    30,  160,   20,    70,   50,   110,    10   },
+   /*   1 */ {   30,    30,  125,   20,    48,   50,    70,    10   },
+   /*   2 */ {   30,    30,  100,   20,    32,   50,    50,    10   },
+   /*   3 */ {   30,    30,  100,   20,    20,   50,    30,    10   },
+   /*   4 */ {   30,    30,  100,   20,    20,   50,    22,     7   },
+   /*   5 */ {   30,    30,  100,   20,    20,   50,    13,     7   }
+};
+
+static inline void set_udma_timings(int drate)
+{
+        /*
+         * Currently do it here but it would be the case to perform these
+         * settings in the HDD driver
+         * ... configure HDDI PIO register access timings
+         */
+        ctrl_outl(_ata_adjust(udmaTime[drate].ack), HDDI_UDMA_ACK);
+        ctrl_outl(_ata_adjust(udmaTime[drate].env), HDDI_UDMA_ENV);
+        ctrl_outl(_ata_adjust(udmaTime[drate].rp),  HDDI_UDMA_RP);
+        ctrl_outl(_ata_adjust(udmaTime[drate].ml),  HDDI_UDMA_ML);
+        ctrl_outl(_ata_adjust(udmaTime[drate].cvs), HDDI_UDMA_CVS);
+        ctrl_outl(_ata_adjust(udmaTime[drate].ss),  HDDI_UDMA_SS);
+        ctrl_outl(_ata_adjust(udmaTime[drate].dvs), HDDI_UDMA_DVS);
+        ctrl_outl(_ata_adjust(udmaTime[drate].dvh), HDDI_UDMA_DVH);
+#ifdef DEBUG
+        printk("ST40-HDDI: set UDMA %d timings (ack %u, env %u, rp %u, ml %u, cvs %u, ss %u, dvs %u, dvh %u)\n",
+                drate,
+                ctrl_inl(HDDI_UDMA_ACK),
+                ctrl_inl(HDDI_UDMA_ENV),
+                ctrl_inl(HDDI_UDMA_RP),
+                ctrl_inl(HDDI_UDMA_ML),
+                ctrl_inl(HDDI_UDMA_CVS),
+                ctrl_inl(HDDI_UDMA_SS),
+                ctrl_inl(HDDI_UDMA_DVS),
+                ctrl_inl(HDDI_UDMA_DVH));
+#endif
+}
+
+static const struct drive_list_entry drive_whitelist [] = {
+
+	{ "Micropolis 2112A"	,       "ALL"		},
+	{ "CONNER CTMA 4000"	,       "ALL"		},
+	{ "CONNER CTT8000-A"	,       "ALL"		},
+	{ "ST34342A"		,	"ALL"		},
+	{ NULL			,	NULL		}
+};
+
+static const struct drive_list_entry drive_blacklist [] = {
+
+	{ "WDC AC11000H"	,	"ALL"		},
+	{ "WDC AC22100H"	,	"ALL"		},
+	{ "WDC AC32500H"	,	"ALL"		},
+	{ "WDC AC33100H"	,	"ALL"		},
+	{ "WDC AC31600H"	,	"ALL"		},
+	{ "WDC AC32100H"	,	"24.09P07"	},
+	{ "WDC AC23200L"	,	"21.10N21"	},
+	{ "Compaq CRD-8241B"	,	"ALL"		},
+	{ "CRD-8400B"		,	"ALL"		},
+	{ "CRD-8480B",			"ALL"		},
+	{ "CRD-8482B",			"ALL"		},
+ 	{ "CRD-84"		,	"ALL"		},
+	{ "SanDisk SDP3B"	,	"ALL"		},
+	{ "SanDisk SDP3B-64"	,	"ALL"		},
+	{ "SANYO CD-ROM CRD"	,	"ALL"		},
+	{ "HITACHI CDR-8"	,	"ALL"		},
+	{ "HITACHI CDR-8335"	,	"ALL"		},
+	{ "HITACHI CDR-8435"	,	"ALL"		},
+	{ "Toshiba CD-ROM XM-6202B"	,	"ALL"		},
+	{ "CD-532E-A"		,	"ALL"		},
+	{ "E-IDE CD-ROM CR-840",	"ALL"		},
+	{ "CD-ROM Drive/F5A",	"ALL"		},
+	{ "WPI CDD-820",		"ALL"		},
+	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
+	{ "SAMSUNG CD-ROM SC",	"ALL"		},
+	{ "SanDisk SDP3B-64"	,	"ALL"		},
+	{ "SAMSUNG CD-ROM SN-124",	"ALL"		},
+	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
+	{ "_NEC DV5800A",               "ALL"           },
+	{ NULL			,	NULL		}
+
+};
+
+/*
+ * This routine, called by the first stage of the interrupt handler,
+ * acknowledge and reset the HDDI interrupt by reading the register
+ * HDDI_DMA_ITS.
+ * Note: this routine is aliased with the generic name "ide_ack_intr"
+ *
+ * HDDI_DMA_ITS: bit 0 set -> DMA completed OK
+ *               bit 1  "  -> Interrupt from Disk
+ *               bit 2  "  -> Multi-Word or U-DMA completed without
+ *                            errors
+ *
+ * Return: 1 if an interrupt is flagged
+ *         0 (should never happen) otherwise
+ *
+ */
+int st40ide_ack_intr(ide_hwif_t *hwif)
+{
+        /*
+         * Note: IRQs should be reset, reading the HDDI_DMA_ITS reg
+         *       at the end of interrupt routine.   Unfortunatelly
+         *       reading the HDDI_DMA_ITS it's the only way to know
+         *       which interrupts have been signaled: the DMA status
+         *       register (HDDI_DMA_STA) should latch them but this
+         *       doesn't work.
+         *       Only the ATA IRQ is latched by the status register.
+         *       Because of this we save and clear any pending IRQ
+         *       here (this guarantee also the PIO mode).
+         *       To do this we use the "select_data" field which
+         *       (I hope) is reserved for specific chipset infos.
+         *
+         *       Return 1 (true) if an interrupt is raised, 0 otherwise
+         */
+#ifdef DEBUG
+        printk("st40ide_ack_intr: DMA status 0x%x  mode 0x%x\n",
+                        hwif->INL(hwif->dma_status), hwif->INB(HDDI_MODE));
+#endif
+        /*
+         * In PIO Mode we have to reset the Interrupt at HDDI interface,
+         * in UDMA mode this will be done by the ide_dma_end routine.
+         * Note: bits[0-2] of the HDDI DMA status register reflects the
+         *       bits[0-2] of the HDDI Interrupts Status register.
+         */
+        if (hwif->INB(HDDI_MODE) == ATA_PIO_MODE)
+
+                hwif->select_data = hwif->INB(HDDI_DMA_ITS) & 0x07;
+        else
+                hwif->select_data = hwif->INL(hwif->dma_status) & 0x07;
+
+        /*
+         * If an interrupt is arrived... hanlde it!
+         */
+        if (hwif->select_data & 0x07)
+                return (1);
+
+        return (0);
+}
+
+void ide_sh_fix_udma_rate(ide_drive_t *drive, int *choosen)
+{
+        int index;
+        int bit_index;
+        int read_rate; /* The rate the drive will be set */
+        int res;
+
+
+        index = drive->name[2] - 'a';
+
+	if (drive->id->field_valid & 4) { /*  53: says word 88 is ok */
+
+	/* Check the best dma rate supported by the device.
+	 * ATA/ATAPI-6 standard provides dma rate from 0 to 5.
+	 * The info is contained into the word 88 of the identification
+	 * packet. Bit interested are bit 0 to 5. The following cycle
+	 * will check the best dma rate supported (read from word 88)
+	 * to set the device at the maximum speed it can go.
+	 * ide_dma_speed (ide-lib.c) read the better dma rate the
+	 * device support.
+	 * The function checks at maximum the dma rate 6.
+	 * Because timings for dma rate 6 are not yet
+	 * implemented (ATA/ATAPI 6 STANDARD), if dma rate 6 is supported,
+	 * timings will be programmed to dma 5.
+ 	 */
+		for(bit_index = 0x3; bit_index >= 0x0; bit_index--) {
+			read_rate = ide_dma_speed(drive, bit_index);
+			if(read_rate)
+				break;
+           	}
+
+	/* Check if the user has choosen a different dma rate from
+	 * command line and force the device to use it.
+	 */
+                if ((choosen[index] != -1) &&
+		(choosen[index] < (read_rate & 7))) {
+                        switch (choosen[index]) {
+        /* XFER_UDMA_7 and XFER_UDMA_6 are not yet implemented
+	 * (ATA/ATAPI 6 STANDARD), timings are not available.
+	 * When the rate is set to 7 or 6, timings will be
+         * programmed to dma 5 (see ide-st40_dma.c).
+         */
+                        case 7:
+                       	case 6:
+                       	case 5: read_rate = XFER_UDMA_5; break;
+                       	case 4: read_rate = XFER_UDMA_4; break;
+                       	case 3: read_rate = XFER_UDMA_3; break;
+                       	case 2: read_rate = XFER_UDMA_2; break;
+                       	case 1: read_rate = XFER_UDMA_1; break;
+                       	case 0: read_rate = XFER_UDMA_0; break;
+                       	default: break;
+			}
+
+                }
+        /* Set the better dma rate. Timings will be programmed inside
+         * this module.
+         */
+                res = ide_config_drive_speed(drive, read_rate);
+
+        }
+}
+EXPORT_SYMBOL(ide_sh_fix_udma_rate);
+
+/**
+ *	in_drive_list	-	look for drive in black/white list
+ *	@id: drive identifier
+ *	@drive_table: list to inspect
+ *
+ *	Look for a drive in the blacklist and the whitelist tables
+ *	Returns 1 if the drive is found in the table.
+ */
+
+static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
+{
+	for ( ; drive_table->id_model ; drive_table++)
+		if ((!strcmp(drive_table->id_model, id->model)) &&
+		    ((strstr(drive_table->id_firmware, id->fw_rev)) ||
+		     (!strcmp(drive_table->id_firmware, "ALL"))))
+			return 1;
+	return 0;
+}
+
+/**
+ *	ide_dma_intr	-	IDE DMA interrupt handler
+ *	@drive: the drive the interrupt is for
+ *
+ *	Handle an interrupt completing a read/write DMA transfer on an
+ *	IDE device
+ */
+
+ide_startstop_t ide_dma_intr (ide_drive_t *drive)
+{
+	u8 stat = 0, dma_stat = 0;
+
+	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+		if (!dma_stat) {
+			struct request *rq = HWGROUP(drive)->rq;
+
+			if (rq->rq_disk) {
+				ide_driver_t *drv;
+
+				drv = *(ide_driver_t **)rq->rq_disk->private_data;
+				drv->end_request(drive, 1, rq->nr_sectors);
+			} else
+				ide_end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+	return ide_error(drive, "dma_intr", stat);
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_intr);
+
+/**
+ *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
+ *	@drive: the drive to build the DMA table for
+ *	@rq: the request holding the sg list
+ *
+ *	Perform the PCI mapping magic necessary to access the source or
+ *	target buffers of a request via PCI DMA. The lower layers of the
+ *	kernel provide the necessary cache management so that we can
+ *	operate in a portable fashion
+ */
+
+int ide_build_sglist(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+	else
+		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+
+	return pci_map_sg(hwif->pci_dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+}
+
+EXPORT_SYMBOL_GPL(ide_build_sglist);
+
+/*
+ * Prepare the DMA request:
+ * 1.  using an intermediate buffer if the Scatter/Gather table has:
+ *     - more than one entry
+ *     - not all the requests (entries) are 32 bytes aligned
+ * 2.  doing it directly directly otherwise
+ *
+ * Input:  driver, DMA direction
+ *
+ * Output: the DMA start address (bus address) and length in bytes
+ *         length = 0 means error!
+ */
+static int ide_hddi_dma_prologue(ide_drive_t *drive, int ddir,
+                                 dma_addr_t *dma_addr)
+{
+        ide_hwif_t   *hwif      = HWIF(drive);
+        int          dma_len;
+        int          i;
+        struct scatterlist *sg;
+        unsigned char *_to;
+
+        /* Most of the time the scatter/gather has only one entry (this
+         * because the HWIF request size: hif->rqsize; has been limited
+         * to a page length (4k). In this case the transfer request can
+         * be done directly!
+         */
+        sg = hwif->sg_table;
+        if ( (hwif->sg_nents == 1) && ((sg_dma_address(sg) & 0x03f) == 0) )
+        {
+                *dma_addr = sg_dma_address(sg);
+                return(sg_dma_len(sg));
+        }
+
+        /* When there are more than one I/O block, or not all of them
+         * are 32 bytes boundary aligned, the request is handled with
+         * an intermediate DMA-able buffer... :-(
+         */
+        dma_len = 0;
+
+        /* temporary buffer (in P2 region) */
+        _to = (unsigned char *)hwif->config_data;
+
+        for (i = 0; i < hwif->sg_nents; i++, sg++)
+        {
+                if ( ddir == WRITE ) /* to device */
+                {
+#ifdef DEBUG
+                        printk("HDDI: gathering 0x%x bytes from 0x%x(0x%x) -> 0x%x\n",
+                                sg_dma_len(sg),
+                                P2SEGADDR(bus_to_virt(sg_dma_address(sg)),
+                                sg_dma_address(sg), _to);
+#endif
+                        memcpy(_to,
+                             (void *)P2SEGADDR(bus_to_virt(sg_dma_address(sg))),
+                               sg_dma_len(sg));
+
+                        _to += sg_dma_len(sg);
+                }
+
+                dma_len += sg_dma_len(sg);
+
+                if ( dma_len > MAX_REQUEST_SIZE(hwif) )
+                {
+                        printk(KERN_ERR "HDDI: %s dma error, SG list too big; rerty in PIO\n", drive->name);
+                        return(0);
+                }
+        }
+        *dma_addr = (dma_addr_t)virt_to_bus(hwif->config_data);
+
+        /* set buffer in use! and remember that scattering of data will
+         * be done at the end of the I/O operation
+         */
+        if ( ddir == READ )
+                hwif->config_data |= 0x1;
+        return(dma_len);
+}
+
+static void ide_hddi_dma_epilogue(ide_drive_t *drive)
+{
+        ide_hwif_t   *hwif      = HWIF(drive);
+        int          i;
+        struct scatterlist *sg;
+        unsigned char *_from;
+
+        /* if a DMA read has been done into the intermediate buffer
+         * now it's time to scatter it out ...
+         * Driven by SG list!
+         */
+        if ( (hwif->config_data & 0x1) == 0 )
+                return;         /* NOP ... it was a WRITE to device */
+
+
+        /* fix and get temporary buffer addr. (in P2 region) */
+        hwif->config_data &= ~0x1;
+        _from = (unsigned char *)hwif->config_data;
+
+        /* scatter the data into the destination buffers */
+        sg = hwif->sg_table;
+        for (i = 0; i < hwif->sg_nents; i++, sg++)
+        {
+#ifdef DEBUG
+                printk("HDDI: scattering 0x%x bytes from 0x%x -> 0x%x(0x%x)\n",
+                                sg_dma_len(sg), _from,
+                                P2SEGADDR(bus_to_virt(sg_dma_address(sg))),
+                                sg_dma_address(sg));
+#endif
+                memcpy((void *) P2SEGADDR(bus_to_virt(sg_dma_address(sg))),
+                        _from, sg_dma_len(sg));
+
+                _from += sg_dma_len(sg);
+        }
+}
+
+
+
+
+/**
+ *	ide_build_dmatable	-	build IDE DMA table
+ *
+ *	ide_build_dmatable() prepares a dma request. We map the command
+ *	to get the pci bus addresses of the buffers and then build up
+ *	the PRD table that the IDE layer wants to be fed. The code
+ *	knows about the 64K wrap bug in the CS5530.
+ *
+ *	Returns the number of built PRD entries if all went okay,
+ *	returns 0 otherwise.
+ *
+ *	May also be invoked from trm290.c
+ */
+
+int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	unsigned int *table	= hwif->dmatable_cpu;
+	unsigned int is_trm290	= (hwif->chipset == ide_trm290) ? 1 : 0;
+	unsigned int count = 0;
+	int i;
+	struct scatterlist *sg;
+
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
+
+	if (!i)
+		return 0;
+
+	sg = hwif->sg_table;
+	while (i) {
+		u32 cur_addr;
+		u32 cur_len;
+
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		/*
+		 * Fill in the dma table, without crossing any 64kB boundaries.
+		 * Most hardware requires 16-bit alignment of all blocks,
+		 * but the trm290 requires 32-bit alignment.
+		 */
+
+		while (cur_len) {
+			if (count++ >= PRD_ENTRIES) {
+				printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+				goto use_pio_instead;
+			} else {
+				u32 xcount, bcount = 0x10000 - (cur_addr & 0xffff);
+
+				if (bcount > cur_len)
+					bcount = cur_len;
+				*table++ = cpu_to_le32(cur_addr);
+				xcount = bcount & 0xffff;
+				if (is_trm290)
+					xcount = ((xcount >> 2) - 1) << 16;
+				if (xcount == 0x0000) {
+	/*
+	 * Most chipsets correctly interpret a length of 0x0000 as 64KB,
+	 * but at least one (e.g. CS5530) misinterprets it as zero (!).
+	 * So here we break the 64KB entry into two 32KB entries instead.
+	 */
+					if (count++ >= PRD_ENTRIES) {
+						printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+						goto use_pio_instead;
+					}
+					*table++ = cpu_to_le32(0x8000);
+					*table++ = cpu_to_le32(cur_addr + 0x8000);
+					xcount = 0x8000;
+				}
+				*table++ = cpu_to_le32(xcount);
+				cur_addr += bcount;
+				cur_len -= bcount;
+			}
+		}
+
+		sg++;
+		i--;
+	}
+
+	if (count) {
+		if (!is_trm290)
+			*--table |= cpu_to_le32(0x80000000);
+		return count;
+	}
+	printk(KERN_ERR "%s: empty DMA table?\n", drive->name);
+use_pio_instead:
+	pci_unmap_sg(hwif->pci_dev,
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
+	return 0; /* revert to PIO for this request */
+}
+
+EXPORT_SYMBOL_GPL(ide_build_dmatable);
+
+/**
+ *	ide_destroy_dmatable	-	clean up DMA mapping
+ *	@drive: The drive to unmap
+ *
+ *	Teardown mappings after DMA has completed. This must be called
+ *	after the completion of each use of ide_build_dmatable and before
+ *	the next use of ide_build_dmatable. Failure to do so will cause
+ *	an oops as only one mapping can be live for each target at a given
+ *	time.
+ */
+
+void ide_destroy_dmatable (ide_drive_t *drive)
+{
+	struct pci_dev *dev = HWIF(drive)->pci_dev;
+	struct scatterlist *sg = HWIF(drive)->sg_table;
+	int nents = HWIF(drive)->sg_nents;
+
+	pci_unmap_sg(dev, sg, nents, HWIF(drive)->sg_dma_direction);
+}
+
+EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
+
+/**
+ *	config_drive_for_dma	-	attempt to activate IDE DMA
+ *	@drive: the drive to place in DMA mode
+ *
+ *	If the drive supports at least mode 2 DMA or UDMA of any kind
+ *	then attempt to place it into DMA mode. Drives that are known to
+ *	support DMA but predate the DMA properties or that are known
+ *	to have DMA handling bugs are also set up appropriately based
+ *	on the good/bad drive lists.
+ */
+
+static int config_drive_for_dma (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = HWIF(drive);
+
+	/* Fix the udma rate to the max rate the driver support
+	 * or to the rate the user has choosen.
+	 */
+	ide_sh_fix_udma_rate(drive,sh_udma_choosen);
+
+	if ((id->capability & 1) && (hwif->autodma || drive->autodma)) {
+		/*
+		 * Enable DMA on any drive that has
+		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
+		 */
+		if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
+			return hwif->ide_dma_on(drive);
+		/*
+		 * Enable DMA on any drive that has mode2 DMA
+		 * (multi or single) enabled
+		 */
+		if (id->field_valid & 2) {	/* regular DMA */
+			if ((id->dma_mword & 0x404) == 0x404 ||
+			    (id->dma_1word & 0x404) == 0x404)
+				return hwif->ide_dma_on(drive);
+
+		}
+
+		/* Consult the list of known "good" drives */
+		if (__ide_dma_good_drive(drive))
+			return hwif->ide_dma_on(drive);
+	}
+//	if (hwif->tuneproc != NULL) hwif->tuneproc(drive, 255);
+	return hwif->ide_dma_off_quietly(drive);
+}
+
+/**
+ *	dma_timer_expiry	-	handle a DMA timeout
+ *	@drive: Drive that timed out
+ *
+ *	An IDE DMA transfer timed out. In the event of an error we ask
+ *	the driver to resolve the problem, if a DMA transfer is still
+ *	in progress we continue to wait (arguably we need to add a
+ *	secondary 'I don't care what the drive thinks' timeout here)
+ *	Finally if we have an interrupt we let it complete the I/O.
+ *	But only one time - we clear expiry and if it's still not
+ *	completed after WAIT_CMD, we error and retry in PIO.
+ *	This can occur if an interrupt is lost or due to hang or bugs.
+ */
+
+static int dma_timer_expiry (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+        u32 dma_stat            = hwif->INL(hwif->dma_status) & 0x0000ffff;
+
+        printk(KERN_WARNING "%s: dma timer expired (status 0x%04x)\n",
+                drive->name, dma_stat);
+
+        /* Assume BUSY if DMA still in progress
+         * BUSY Stupid Early Timer !!
+         */
+        if ( (dma_stat & 0x0600) == 0x0600 )
+                return WAIT_CMD;
+
+        /*
+         * Clear the expiry handler in case we decide to wait more,
+         * next time timer expires it is an error
+         */
+        HWGROUP(drive)->expiry = NULL;
+
+        if ( (dma_stat & 0x7) ) return WAIT_CMD;        /* got an interrupt */
+
+        /*
+         * Assume Error for any other state of the DMA Engine but
+         * burst in progress and idle
+         */
+        if ( (dma_stat & 0x0E00) ) return -1;           /* ERROR            */
+
+	return 0;	/* Status is unknown -- reset the bus */
+}
+
+/**
+ *	__ide_dma_host_off	-	Generic DMA kill
+ *	@drive: drive to control
+ *
+ *	Perform the generic IDE controller DMA off operation. This
+ *	works for most IDE bus mastering controllers
+ */
+
+int __ide_dma_host_off (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+        u8 dma_stat             = hwif->INL(hwif->dma_command);
+
+        hwif->OUTB( (dma_stat | 0x2 ), hwif->dma_command);  /* set stop bit */
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_host_off);
+
+/**
+ *	__ide_dma_host_off_quietly	-	Generic DMA kill
+ *	@drive: drive to control
+ *
+ *	Turn off the current DMA on this IDE controller.
+ */
+
+int __ide_dma_off_quietly (ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	ide_toggle_bounce(drive, 0);
+
+	if (HWIF(drive)->ide_dma_host_off(drive))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_off_quietly);
+
+/**
+ *	__ide_dma_off	-	disable DMA on a device
+ *	@drive: drive to disable DMA on
+ *
+ *	Disable IDE DMA for a device on this IDE controller.
+ *	Inform the user that DMA has been disabled.
+ */
+
+int __ide_dma_off (ide_drive_t *drive)
+{
+	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
+	return HWIF(drive)->ide_dma_off_quietly(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_off);
+
+/**
+ *	__ide_dma_host_on	-	Enable DMA on a host
+ *	@drive: drive to enable for DMA
+ *
+ *	Enable DMA on an IDE controller following generic bus mastering
+ *	IDE controller behaviour
+ */
+
+int __ide_dma_host_on (ide_drive_t *drive)
+{
+        /*
+         * may be we should do nothing!
+         */
+        if (drive->using_dma) {
+                ide_hwif_t *hwif  = HWIF(drive);
+                u8 dma_cmd        = hwif->INL(hwif->dma_command);
+                hwif->OUTL( (dma_cmd & ~0x2), hwif->dma_command);
+                return 0;
+        }
+        return 1;
+}
+
+EXPORT_SYMBOL(__ide_dma_host_on);
+
+/**
+ *	__ide_dma_on		-	Enable DMA on a device
+ *	@drive: drive to enable DMA on
+ *
+ *	Enable IDE DMA for a device on this IDE controller.
+ */
+
+int __ide_dma_on (ide_drive_t *drive)
+{
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 1;
+
+	drive->using_dma = 1;
+	ide_toggle_bounce(drive, 1);
+
+	if (HWIF(drive)->ide_dma_host_on(drive))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_on);
+
+/**
+ *	__ide_dma_check		-	check DMA setup
+ *	@drive: drive to check
+ *
+ *	Don't use - due for extermination
+ */
+
+int __ide_dma_check (ide_drive_t *drive)
+{
+	return config_drive_for_dma(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_check);
+
+/**
+ *	ide_dma_setup	-	begin a DMA phase
+ *	@drive: target device
+ *
+ *	Build an IDE DMA PRD (IDE speak for scatter gather table)
+ *	and then set up the DMA transfer registers for a device
+ *	that follows generic IDE PCI DMA behaviour. Controllers can
+ *	override this function if they need to
+ *
+ *	Returns 0 on success. If a PIO fallback is required then 1
+ *	is returned.
+ */
+
+int ide_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int reading;
+        unsigned int temp;
+        dma_addr_t   dma_addr;
+        unsigned int dma_len;
+
+	if (rq_data_dir(rq))
+		reading = 0;
+	else
+		reading = 1 << 3;
+
+	/* fall back to pio! */
+	if (!ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
+
+        /*
+         * The HDDI DMA doesn't support scatter gather, moreover
+         * it requires DMAable buffer to be aligned to 32 bytes
+         * boundary...
+         */
+        dma_len = ide_hddi_dma_prologue(drive, reading, &dma_addr);
+        if (!dma_len)
+        {
+                /* this should never happen ... it's a BUG
+                 * purge DMA mappings (done when building the
+                 * DMA table... this could be optimized for ST40
+                 * try in PIO mode instead
+                 */
+                ide_destroy_dmatable(drive);
+                return 1;       /* try PIO instead of DMA */
+        }
+
+        /*
+         * To setup the ST40 DMA engine, do the following:
+         *   1: Enable ONLY the ATA IRQ interrupt
+         *   2: Write the physical addr. of I/O buffer
+         *   3: Set the DMA burst to 32 bytes
+         *   4: Set the DMA message to a max of 1 packet
+         *   5: Set the DMA transfer size in word (16 bits)
+         *   6: clear any HDDI pending event (may be avoided)
+         */
+        hwif->OUTL(0x05, HDDI_DMA_ITM);
+        hwif->OUTL(dma_addr, HDDI_DMA_SA);
+        hwif->OUTL(0x1, HDDI_DMA_SI);           /* packet size = 32   */
+        hwif->OUTL(0x1, HDDI_DMA_PS);           /* chunk size = 1 pkt.*/
+        hwif->OUTL((dma_len / sizeof(short)), HDDI_DMA_WC);
+        temp = hwif->INL(HDDI_DMA_ITS);
+	drive->waiting_for_dma = 1;
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_setup);
+
+static void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
+}
+
+void ide_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_cmd		= hwif->INB(hwif->dma_command);
+
+	/* Note that this is done *after* the cmd has
+	 * been issued to the drive, as per the BM-IDE spec.
+	 * The Promise Ultra33 doesn't work correctly when
+	 * we do this part before issuing the drive cmd.
+	 */
+	/* start DMA */
+
+	if((drive->using_dma) && (drive->id->field_valid & 4))
+		set_udma_timings(drive->current_speed & 0x7);
+
+        /* enable the DMA engine but keep it quiet... */
+        if ( rq_data_dir(HWGROUP(drive)->rq) == READ )
+                dma_cmd = ((1<<4) | DMA_ENABLE | DMA_START);
+        else
+                dma_cmd = (DMA_ENABLE | DMA_START);
+
+#ifdef DEBUG
+        printk("ide_dma_begin: cmd 0x%x before firing DMA: STA 0x%x C 0x%x, ATA stat 0x%x\n", dma_cmd, ctrl_inl(HDDI_DMA_STA), ctrl_inl(HDDI_DMA_C), hwif->INB(IDE_STATUS_REG));
+#endif
+
+        hwif->OUTL(dma_cmd, HDDI_DMA_C);          /* enable the DMA         */
+        hwif->OUTL(ATA_UDMA_MODE, HDDI_MODE);     /* set UDMA protocol mode */
+        hwif->OUTL((dma_cmd & 0xFE), HDDI_DMA_C); /* Fire! DMA              */
+    //    return 0;
+	hwif->dma = 1;
+	wmb();
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_start);
+
+/* returns 1 on error, 0 otherwise */
+int __ide_dma_end (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+
+#define MAX_RETRY       100
+
+#ifdef DEBUG
+        printk(">>>ide_dma_end %s DMA: STA 0x%x, ITS was 0x%x\n",
+                drive->name, hwif->INL(hwif->dma_status),
+                hwif->select_data);             /* saved HDDI_DMA_ITS reg. */
+#endif
+
+        /* don't wait more for this DMA interrupt! */
+        drive->waiting_for_dma = 0;
+
+        /*
+         * bit 0: DMA_END
+         *  "  1: ATA IRQ
+         *  "  2: DMA_TERM_OK
+         * Actually use only the ATA IRQ event!
+         */
+        if ( (hwif->select_data & 0x02) != 0x02 )
+        {
+                printk(KERN_ERR "HDDI: %s DMA aborted, no IRQs (ITS 0x%lx); retry in PIO\n",
+                       drive->name, hwif->select_data);
+                goto _dma_end_error;
+        }
+
+        /*
+         * checks for the DMA engine not ACTIVE (idle)
+         */
+        {
+                int wait_for_dma_idle = MAX_RETRY;
+                do {
+                        if ((hwif->INL(hwif->dma_status) & DMA_MASK) == 0x0)
+                                break;
+                        udelay(20);
+                        wait_for_dma_idle--;
+                } while (wait_for_dma_idle);
+
+                if (!wait_for_dma_idle)
+                {
+                        printk(KERN_ERR "HDDI: %s DMA error, still active; retry in PIO\n",
+                               drive->name);
+                        goto _dma_end_error;
+                }
+        }
+
+#if 0
+        /*
+         * HW bug: the Byte Count register sometime remain set
+         *         although the transfer succeeded
+         *
+         * Now check if the DMA has left bytes...
+         */
+        {
+                int dma_wait_timeout = MAX_RETRY;
+                do {
+                        if (hwif->INL(HDDI_DMA_CB) == 0x0)
+                                break;
+                        udelay(20);
+                        dma_wait_timeout--;
+                } while (dma_wait_timeout);
+
+                if (!dma_wait_timeout)
+                {
+                        printk(KERN_ERR "HDDI: %s DMA error, lost 0x%x bytes; retry in PIO\n",
+                                drive->name, hwif->INL(HDDI_DMA_CB));
+                        goto _dma_end_error;
+                }
+#ifdef DEBUG
+                if (dma_wait_timeout < MAX_RETRY)
+                        printk("HDDI spent %dus to wait for DMA end\n",
+                                (MAX_RETRY - dma_wait_timeout) * 20);
+#endif
+        }
+#endif
+
+        /* Should we stop the DMA ? we assume NO! */
+
+        /* Reset any pending interrupt at HDDI level */
+        (void) hwif->INB(HDDI_DMA_ITS);
+        hwif->select_data = 0;
+
+        /*
+         * Return HDDI protocol in PIO mode (this will prevent to read
+         * garbage from ATA registers!)
+         */
+        hwif->OUTL(ATA_PIO_MODE, HDDI_MODE);
+
+        /*
+         * Make a double check: the DMA is complete, also the ATA bus
+         * sould be in the idle state!
+         */
+        {
+                u8  ata_stat = 0;
+                u8  poll_ataIdle = 0;
+#ifdef DEBUG
+                printk("                  ATA: sr 0x%x  err 0x%x\n",
+                        hwif->INB(IDE_STATUS_REG), hwif->INB(IDE_ERROR_REG));
+#endif
+                do {
+                        ata_stat = hwif->INB(IDE_STATUS_REG);
+                        if ( (ata_stat &  (BUSY_STAT|ERR_STAT|DRQ_STAT|READY_STAT)) == READY_STAT )
+                                break;
+                        udelay(10);
+                        poll_ataIdle++;
+                } while (poll_ataIdle < 10);
+
+                if (poll_ataIdle >= 10)
+                {
+                        printk(KERN_ERR "HDDI: %s error, timeout waiting for ATA ready (status 0x%x)\n",
+                               drive->name, ata_stat);
+                        goto _dma_end_error;
+                }
+        }
+        ide_hddi_dma_epilogue(drive);           /* scatter data if reading */
+        ide_destroy_dmatable(drive);            /* purge DMA mappings */
+        return(0);                              /* return OK */
+
+_dma_end_error:
+        hwif->OUTL(ATA_PIO_MODE, HDDI_MODE);    /* revert on PIO mode */
+        ide_destroy_dmatable(drive);            /* purge DMA mappings */
+        return(1);                              /* Error */
+#undef MAX_RETRY
+}
+
+EXPORT_SYMBOL(__ide_dma_end);
+
+/* returns 1 if dma irq issued, 0 otherwise */
+static int __ide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+
+        if (hwif->select_data & 0x07)   /* return 1 if any IRQ */
+                return 1;
+
+#if 0  /* do not set unless you know what you are doing */
+	if (dma_stat & 4) {
+		u8 stat = hwif->INB(IDE_STATUS_REG);
+		hwif->OUTB(hwif->dma_status, dma_stat & 0xE4);
+	}
+#endif
+	if (!drive->waiting_for_dma)
+		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
+			drive->name, __FUNCTION__);
+	return 0;
+}
+
+int __ide_dma_bad_drive (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	int blacklist = in_drive_list(id, drive_blacklist);
+	if (blacklist) {
+		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
+				    drive->name, id->model);
+		return blacklist;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_bad_drive);
+
+int __ide_dma_good_drive (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	return in_drive_list(id, drive_whitelist);
+}
+
+EXPORT_SYMBOL(__ide_dma_good_drive);
+
+int ide_use_dma(ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = drive->hwif;
+
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 0;
+
+	/* capable of UltraDMA modes */
+	if (id->field_valid & 4) {
+		if (hwif->ultra_mask & id->dma_ultra)
+			return 1;
+	}
+
+	/* capable of regular DMA modes */
+	if (id->field_valid & 2) {
+		if (hwif->mwdma_mask & id->dma_mword)
+			return 1;
+		if (hwif->swdma_mask & id->dma_1word)
+			return 1;
+	}
+
+	/* consult the list of known "good" drives */
+	if (__ide_dma_good_drive(drive) && id->eide_dma_time < 150) {
+		return 1;
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_use_dma);
+
+void ide_dma_verbose(ide_drive_t *drive)
+{
+	struct hd_driveid *id	= drive->id;
+	ide_hwif_t *hwif	= HWIF(drive);
+
+	if (id->field_valid & 4) {
+		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
+			goto bug_dma_off;
+		if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
+			if ((id->dma_ultra >> 11) & 0x1F) {
+				if ((id->dma_ultra >> 15) & 1) {
+					printk(", UDMA(mode 7)");
+				} else if ((id->dma_ultra >> 14) & 1) {
+					printk(", UDMA(133)");
+				} else if ((id->dma_ultra >> 13) & 1) {
+					printk(", UDMA(100)");
+				} else if ((id->dma_ultra >> 12) & 1) {
+					printk(", UDMA(66)");
+				} else if ((id->dma_ultra >> 11) & 1) {
+					printk(", UDMA(44)");
+				} else
+					goto mode_two;
+			} else {
+		mode_two:
+				if ((id->dma_ultra >> 10) & 1) {
+					printk(", UDMA(33)");
+				} else if ((id->dma_ultra >> 9) & 1) {
+					printk(", UDMA(25)");
+				} else if ((id->dma_ultra >> 8) & 1) {
+					printk(", UDMA(16)");
+				}
+			}
+		} else {
+			printk(", (U)DMA");	/* Can be BIOS-enabled! */
+		}
+	} else if (id->field_valid & 2) {
+		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
+			goto bug_dma_off;
+		printk(", DMA");
+	} else if (id->field_valid & 1) {
+		printk(", BUG");
+	}
+	return;
+bug_dma_off:
+	printk(", BUG DMA OFF");
+	hwif->ide_dma_off_quietly(drive);
+	return;
+}
+
+EXPORT_SYMBOL(ide_dma_verbose);
+
+int __ide_dma_lostirq (ide_drive_t *drive)
+{
+	printk("%s: DMA interrupt recovery\n", drive->name);
+	return 1;
+}
+
+EXPORT_SYMBOL(__ide_dma_lostirq);
+
+int __ide_dma_timeout (ide_drive_t *drive)
+{
+	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
+
+	return HWIF(drive)->ide_dma_end(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_timeout);
+
+/*
+ * Needed for allowing full modular support of ide-driver
+ */
+static int ide_release_dma_engine(ide_hwif_t *hwif)
+{
+	if (hwif->dmatable_cpu) {
+		pci_free_consistent(hwif->pci_dev,
+				    PRD_ENTRIES * PRD_BYTES,
+				    hwif->dmatable_cpu,
+				    hwif->dmatable_dma);
+		hwif->dmatable_cpu = NULL;
+	}
+	if (hwif->config_data) {
+		pci_free_consistent(hwif->pci_dev,
+				    MAX_REQUEST_SIZE(hwif),
+				    (void *)hwif->config_data,
+				    virt_to_bus(hwif->config_data));
+		hwif->config_data = 0;
+	}
+
+	return 1;
+}
+
+static int ide_allocate_dma_engine(ide_hwif_t *hwif)
+{
+	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
+						  PRD_ENTRIES * PRD_BYTES,
+						  &hwif->dmatable_dma);
+
+        {
+		dma_addr_t      handle;
+
+		/*
+                 * ST40 DMA doesn't support scatter gather, so allocate an
+                 * intermediate buffer to perform non contiguous I/O
+                 * Use "config_data" (chipset reserved) field to store the
+		 * buffer address (in P2 region). Buffer is page aligned
+		 * hence should satisfy the 32 bytes boudary alignement
+		 * required by the ST40 HDDI
+		 */
+		hwif->config_data =
+			(unsigned long) pci_alloc_consistent( hwif->pci_dev,
+							      MAX_REQUEST_SIZE(hwif),
+							      &handle);
+	}
+	if ((hwif->dmatable_cpu) && (hwif->config_data))
+		return 0;
+
+	printk(KERN_ERR "%s: -- Error, unable to allocate%s%s table(s).\n",
+	       "ST40 HDDI",
+	       (hwif->dmatable_cpu == NULL) ? " CPU" : "",
+	       ((void *)hwif->config_data == NULL) ?  " SG buffer" : "");
+	ide_release_dma_engine(hwif);
+	return 1;
+}
+
+static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
+
+	hwif->dma_base = base;
+
+	if(hwif->mate)
+		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
+	else
+		hwif->dma_master = base;
+	return 0;
+}
+
+static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
+		hwif->name, base, base + ports - 1);
+	if (!request_region(base, ports, hwif->name)) {
+		printk(" -- Error, ports in use.\n");
+		return 1;
+	}
+	hwif->dma_base = base;
+	if ((hwif->cds->extra) && (hwif->channel == 0)) {
+		request_region(base+16, hwif->cds->extra, hwif->cds->name);
+		hwif->dma_extra = hwif->cds->extra;
+	}
+
+	if(hwif->mate)
+		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
+	else
+		hwif->dma_master = base;
+	if (hwif->dma_base2) {
+		if (!request_region(hwif->dma_base2, ports, hwif->name))
+		{
+			printk(" -- Error, secondary ports in use.\n");
+			release_region(base, ports);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	if (hwif->mmio == 2)
+		return ide_mapped_mmio_dma(hwif, base,ports);
+	BUG_ON(hwif->mmio == 1);
+	return ide_iomio_dma(hwif, base, ports);
+}
+
+/*
+ * This can be called for a dynamically installed interface. Don't __init it
+ */
+void _ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_ports)
+{
+        hwif->mmio = 2;         /* Assume memory mapped DMA */
+        printk(KERN_INFO "ide setup: hwif 0x%lx, dma_base 0x%lx, ports 0x%x\n",
+               (unsigned long)hwif, dma_base, num_ports);
+	if (ide_dma_iobase(hwif, dma_base, num_ports))
+		return;
+
+	if (ide_allocate_dma_engine(hwif)) {
+		ide_release_dma(hwif);
+		return;
+	}
+
+        if (!(hwif->dma_command))  hwif->dma_command    = HDDI_DMA_C;
+        if (!(hwif->dma_vendor1))  hwif->dma_vendor1    = 0; /* na */
+        if (!(hwif->dma_status))   hwif->dma_status     = HDDI_DMA_STA;
+        if (!(hwif->dma_vendor3))  hwif->dma_vendor3    = 0; /* na */
+        if (!(hwif->dma_prdtable)) hwif->dma_prdtable   = HDDI_DMA_SA;
+
+	if (!hwif->ide_dma_off_quietly)
+		hwif->ide_dma_off_quietly = &__ide_dma_off_quietly;
+	if (!hwif->ide_dma_host_off)
+		hwif->ide_dma_host_off = &__ide_dma_host_off;
+	if (!hwif->ide_dma_on)
+		hwif->ide_dma_on = &__ide_dma_on;
+	if (!hwif->ide_dma_host_on)
+		hwif->ide_dma_host_on = &__ide_dma_host_on;
+	if (!hwif->ide_dma_check)
+		hwif->ide_dma_check = &__ide_dma_check;
+	if (!hwif->dma_setup)
+		hwif->dma_setup = &ide_dma_setup;
+	if (!hwif->dma_exec_cmd)
+		hwif->dma_exec_cmd = &ide_dma_exec_cmd;
+	if (!hwif->dma_start)
+		hwif->dma_start = &ide_dma_start;
+	if (!hwif->ide_dma_end)
+		hwif->ide_dma_end = &__ide_dma_end;
+	if (!hwif->ide_dma_test_irq)
+		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
+	if (!hwif->ide_dma_timeout)
+		hwif->ide_dma_timeout = &__ide_dma_timeout;
+	if (!hwif->ide_dma_lostirq)
+		hwif->ide_dma_lostirq = &__ide_dma_lostirq;
+
+	printk("\n");
+
+	if (!(hwif->dma_master))
+		BUG();
+}
+
+EXPORT_SYMBOL_GPL(_ide_setup_dma);
diff -Naur linux-2.6.17.8/drivers/input/keyboard/hp620_keyb.c linux-2.6.17.8-sh/drivers/input/keyboard/hp620_keyb.c
--- linux-2.6.17.8/drivers/input/keyboard/hp620_keyb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/hp620_keyb.c	2006-08-23 13:29:22.460231000 +0100
@@ -0,0 +1,169 @@
+/*
+ * drivers/input/keyboard/hp680_keyb.c
+ *
+ * HP Jornada 620 scan keyboard
+ *
+ *  Copyright (C) 2005  Andriy Skulysh
+ *  Copyright (C) 2006  Paul Mundt
+ *
+ * Splited from drivers/input/keyboard/hp600_keyb.c
+ *
+ *	Copyright (C) 2000 YAEGASHI Takeshi
+ *	HP600 keyboard scan routine and translation table
+ *	Copyright (C) 2000 Niibe Yutaka
+ *	HP620 keyboard translation table
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include "scan_keyb.h"
+
+#define PCDR 0xa4000124
+#define PDDR 0xa4000126
+#define PEDR 0xa4000128
+#define PFDR 0xa400012a
+#define PGDR 0xa400012c
+#define PHDR 0xa400012e
+#define PJDR 0xa4000130
+#define PKDR 0xa4000132
+#define PLDR 0xa4000134
+
+/****************************************************************
+HP Jornada 620(Japanese version) keyboard scan matrix
+
+	PTC7	PTC6	PTC5	PTC4	PTC3	PTC2	PTC1	PTC0
+PTD1	EREC		BS	Ctrl	on/off	-	0	9
+PTD5	EREC		BS	Ctrl	on/off	^	P	O
+PTD7	EREC		BS	Ctrl	on/off	]	@	L
+PTE0	EREC		BS	Ctrl	on/off	Han/Zen [	;
+PTE1	EREC		BS	Ctrl	on/off	Enter	:	/
+PTE3	EREC		BS	Ctrl	on/off		Right	Up
+PTE6	EREC		BS	Ctrl	on/off		Down	Left
+PTE7	EREC		BS	Ctrl	on/off		F8	F7
+
+	PTF7	PTF6	PTF5	PTF4	PTF3	PTF2	PTF1	PTF0
+PTD1	8	7	6	5	4	3	2	1
+PTD5	I	U	Y	T	R	E	W	Q
+PTD7	K	J	H	G	F	D	S	A
+PTE0						ESC	Tab	Shift
+PTE1	.			V			Caps	Hira
+PTE3	,	M	N	B	Muhen	C	X
+PTE6	_	\	Henkan	Space		Alt	Z
+PTE7	F6	F5	F4	F3	F2	F1		REC
+
+	PTH0
+*	on/off
+
+		7	6	5	4	3	2	1	0
+C: 0xffff 0xff	IP	IP	IP	IP	IP	IP	IP	IP
+D: 0x4404 0xaf	O	F	O	F	F	F	O	F
+E: 0x5045 0xff	O	O	F	F	O	F	O	O
+F: 0xffff 0xff	IP	IP	IP	IP	IP	IP	IP	IP
+G: 0xd5ff 0x00	IP	O	O	O	IP	IP	IP	IP
+H: 0x63ff 0xd1	O	I	F	IP	IP	IP	IP	IP
+J: 0x0004 0x02	F	F	F	F	F	F	O	F
+K: 0x0401 0xff	F	F	O	F	F	F	F	O
+L: 0x0c00 0x20	F	F	IP	F	F	F	F	F
+
+ADCSR: 0x08
+ADCR: 0x3f
+
+ ****************************************************************/
+
+/****************************************************************
+Japanese 109 keyboard scan code layout
+
+                                              E02A-     E1-
+01    3B 3C 3D 3E  3F 40 41 42  43 44 57 58   E037  46  1045
+
+29 02 03 04 05 06 07 08 09 0A 0B 0C 0D 7D 0E  E052 E047 E049   45 E035 37  4A
+0F  10 11 12 13 14 15 16 17 18 19 1A 1B   1C  E053 E04F E051   47  48  49  4E
+3A   1E 1F 20 21 22 23 24 25 26 27 28 2B                       4B  4C  4D
+2A    2C 2D 2E 2F 30 31 32 33 34 35 73    36       E048        4F  50  51  E0-
+1D  DB  38  7B   39   79 70  E038 DC DD E01D  E04B E050 E04D     52    53  1C
+
+****************************************************************/
+
+static const unsigned char hp620_japanese_table[] = {
+	/* PTD1 */
+	0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x0e, 0x00, 0x00,
+	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+	/* PTD5 */
+	0x18, 0x19, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	/* PTD7 */
+	0x26, 0x1a, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
+	/* PTE0 */
+	0x27, 0x1b, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x2a, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* PTE1 */
+	0x35, 0x28, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x70, 0x3a, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x34,
+	/* PTE3 */
+	0x48, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x2d, 0x2e, 0x7b, 0x30, 0x31, 0x32, 0x33,
+	/* PTE6 */
+	0x4b, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x2c, 0x38, 0x00, 0x39, 0x79, 0x7d, 0x73,
+	/* PTE7 */
+	0x41, 0x42, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
+	/* **** */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static int hp620_japanese_scan_kbd(unsigned char *s)
+{
+	int i;
+	unsigned char matrix_switch[] = {
+		0xfd, 0xff,	/* PTD1 */
+		0xdf, 0xff,	/* PTD5 */
+		0x7f, 0xff,	/* PTD7 */
+		0xff, 0xfe,	/* PTE0 */
+		0xff, 0xfd,	/* PTE1 */
+		0xff, 0xf7,	/* PTE3 */
+		0xff, 0xbf,	/* PTE6 */
+		0xff, 0x7f,	/* PTE7 */
+	}, *t=matrix_switch;
+
+	for(i=0; i<8; i++) {
+		ctrl_outb(*t++, PDDR);
+		ctrl_outb(*t++, PEDR);
+		udelay(50);
+		*s++=ctrl_inb(PCDR);
+		*s++=ctrl_inb(PFDR);
+	}
+
+	ctrl_outb(0xff, PDDR);
+	ctrl_outb(0xff, PEDR);
+
+	*s++=ctrl_inb(PGDR);
+	*s++=ctrl_inb(PHDR);
+
+	return 0;
+}
+
+static struct scan_keyboard hp620_kbd = {
+	.scan		= hp620_japanese_scan_kbd,
+	.table		= hp620_japanese_table,
+	.length		= 18,
+};
+
+static int __init hp620_kbd_init_hw(void)
+{
+	printk(KERN_INFO "HP620 matrix scan keyboard registered\n");
+	return register_scan_keyboard(&hp620_kbd);
+}
+
+static void __exit hp620_kbd_exit_hw(void)
+{
+	unregister_scan_keyboard(&hp620_kbd);
+}
+
+module_init(hp620_kbd_init_hw);
+module_exit(hp620_kbd_exit_hw);
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/input/keyboard/hp680_keyb.c linux-2.6.17.8-sh/drivers/input/keyboard/hp680_keyb.c
--- linux-2.6.17.8/drivers/input/keyboard/hp680_keyb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/hp680_keyb.c	2006-08-23 13:29:22.475232000 +0100
@@ -0,0 +1,152 @@
+/*
+ * drivers/input/keyboard/hp680_keyb.c
+ *
+ * HP Jornada 680/690 scan keyboard
+ *
+ *  Copyright (C) 2005  Andriy Skulysh
+ *  Copyright (C) 2006  Paul Mundt
+ *
+ * Splited from drivers/input/keyboard/hp600_keyb.c
+ *
+ *	Copyright (C) 2000 YAEGASHI Takeshi
+ *	HP600 keyboard scan routine and translation table
+ *	Copyright (C) 2000 Niibe Yutaka
+ *	HP620 keyboard translation table
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include "scan_keyb.h"
+
+#define PCDR 0xa4000124
+#define PDDR 0xa4000126
+#define PEDR 0xa4000128
+#define PFDR 0xa400012a
+#define PGDR 0xa400012c
+#define PHDR 0xa400012e
+#define PJDR 0xa4000130
+#define PKDR 0xa4000132
+#define PLDR 0xa4000134
+
+/****************************************************************
+HP Jornada 690(Japanese version) keyboard scan matrix
+
+	PTC7	PTC6	PTC5	PTC4	PTC3	PTC2	PTC1	PTC0
+PTD1	REC			Escape	on/off	Han/Zen	Hira	Eisu
+PTD5	REC			Z	on/off	Enter	:	/
+PTD7	REC						Right	Down
+PTE0	REC			Windows	on/off
+PTE1	REC			A	on/off	]	[	;
+PTE3	REC			Tab	on/off	ShirtR	\	Up
+PTE6	REC			Q	on/off	BS	@	P
+PTE7	REC			1	on/off	^	-	0
+
+	PTF7	PTF6	PTF5	PTF4	PTF3	PTF2	PTF1	PTF0
+PTD1	F5	F4	F6	F7	F8	F3	F2	F1
+PTD5	N	B	M	,	.	V	C	X
+PTD7	Muhen	Alt			Left
+PTE0			Henkan	_	Del	Space		Ctrl
+PTE1	H	G	J	K	L	F	D	S
+PTE3							ShiftL
+PTE6	Y	T	U	I	O	R	E	W
+PTE7	6	5	7	8	9	4	3	2
+
+	PTG5	PTG4	PTG3	PTG0	PTH0
+*	REC	REW	FWW	Cover	on/off
+
+
+		7	6	5	4	3	2	1	0
+C: 0xffff 0xdf	IP	IP	IP	IP	IP	IP	IP	IP
+D: 0x6786 0x59	O	I	O	IP	I	F	O	I
+E: 0x5045 0x00	O	O	F	F	O	F	O	O
+F: 0xffff 0xff	IP	IP	IP	IP	IP	IP	IP	IP
+G: 0xaffe 0xfd	I	I	IP	IP	IP	IP	IP	I
+H: 0x70f2 0x49	O	IP	F	F	IP	IP	F	I
+J: 0x0704 0x22	F	F	O	IP	F	F	O	F
+K: 0x0100 0x10	F	F	F	O	F	F	F	F
+L: 0x0c3c 0x26	F	F	IP	F	F	IP	IP	F
+
+****************************************************************/
+
+static const unsigned char hp680_japanese_table[] = {
+	/* PTD1 */
+	0x3a, 0x70, 0x29, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x3b, 0x3c, 0x3d, 0x42, 0x41, 0x40, 0x3e, 0x3f,
+	/* PTD5 */
+	0x35, 0x28, 0x1c, 0x00, 0x2c, 0x00, 0x00, 0x00,
+	0x2d, 0x2e, 0x2f, 0x34, 0x33, 0x32, 0x30, 0x31,
+	/* PTD7 */
+	0x50, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x38, 0x7b,
+	/* PTE0 */
+	0x00, 0x00, 0x00, 0x00, 0xdb, 0x00, 0x00, 0x00,
+	0x1d, 0x00, 0x39, 0x53, 0x73, 0xf9, 0x00, 0x00,
+	/* PTE1 */
+	0x27, 0x1b, 0x2b, 0x00, 0x1e, 0x00, 0x00, 0x00,
+	0x1f, 0x20, 0x21, 0x26, 0x25, 0x24, 0x22, 0x23,
+	/* PTE3 */
+	0x48, 0x7d, 0x36, 0x00, 0x0f, 0x00, 0x00, 0x00,
+	0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* PTE6 */
+	0x19, 0x1a, 0x0e, 0x00, 0x10, 0x00, 0x00, 0x00,
+	0x11, 0x12, 0x13, 0x18, 0x17, 0x16, 0x14, 0x15,
+	/* PTE7 */
+	0x0b, 0x0c, 0x0d, 0x00, 0x02, 0x00, 0x00, 0x00,
+	0x03, 0x04, 0x05, 0x0a, 0x09, 0x08, 0x06, 0x07,
+	/* **** */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static int hp680_japanese_scan_kbd(unsigned char *s)
+{
+	int i;
+	unsigned char matrix_switch[] = {
+		0xfd, 0xff,	/* PTD1 */
+		0xdf, 0xff,	/* PTD5 */
+		0x7f, 0xff,	/* PTD7 */
+		0xff, 0xfe,	/* PTE0 */
+		0xff, 0xfd,	/* PTE1 */
+		0xff, 0xf7,	/* PTE3 */
+		0xff, 0xbf,	/* PTE6 */
+		0xff, 0x7f,	/* PTE7 */
+	}, *t=matrix_switch;
+
+	for(i=0; i<8; i++) {
+		ctrl_outb(*t++, PDDR);
+		ctrl_outb(*t++, PEDR);
+		*s++=ctrl_inb(PCDR);
+		*s++=ctrl_inb(PFDR);
+	}
+
+	ctrl_outb(0xff, PDDR);
+	ctrl_outb(0xff, PEDR);
+
+	*s++=ctrl_inb(PGDR);
+	*s++=ctrl_inb(PHDR);
+
+	return 0;
+}
+
+static struct scan_keyboard hp680_kbd = {
+	.scan		= hp680_japanese_scan_kbd,
+	.table		= hp680_japanese_table,
+	.length		= 18,
+};
+
+static int __init hp680_kbd_init_hw(void)
+{
+	printk(KERN_INFO "HP680 matrix scan keyboard registered\n");
+	return register_scan_keyboard(&hp680_kbd);
+}
+
+static void __exit hp680_kbd_exit_hw(void)
+{
+	unregister_scan_keyboard(&hp680_kbd);
+}
+
+module_init(hp680_kbd_init_hw);
+module_exit(hp680_kbd_exit_hw);
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/input/keyboard/Kconfig linux-2.6.17.8-sh/drivers/input/keyboard/Kconfig
--- linux-2.6.17.8/drivers/input/keyboard/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/Kconfig	2006-08-23 13:29:12.521001000 +0100
@@ -183,4 +183,21 @@
 	  This driver implements support for HIL-keyboards attached
 	  to your machine, so normally you should say Y here.
 
+choice
+	prompt "HP6XX keyboard"
+	depends on SH_HP6XX
+	default KEYBOARD_HP680
+
+config KEYBOARD_HP620
+	tristate "HP620 keyboard"
+	help
+	  Say Y here if you are running Linux on HP Jornada 620.
+
+config KEYBOARD_HP680
+	tristate "HP680 keyboard"
+	help
+	  Say Y here if you are running Linux on HP Jornada 680.
+
+endchoice
+
 endif
diff -Naur linux-2.6.17.8/drivers/input/keyboard/Makefile linux-2.6.17.8-sh/drivers/input/keyboard/Makefile
--- linux-2.6.17.8/drivers/input/keyboard/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/Makefile	2006-08-23 13:29:12.077979000 +0100
@@ -15,4 +15,6 @@
 obj-$(CONFIG_KEYBOARD_SPITZ)		+= spitzkbd.o
 obj-$(CONFIG_KEYBOARD_HIL)		+= hil_kbd.o
 obj-$(CONFIG_KEYBOARD_HIL_OLD)		+= hilkbd.o
+obj-$(CONFIG_KEYBOARD_HP620)		+= scan_keyb.o hp620_keyb.o
+obj-$(CONFIG_KEYBOARD_HP680)		+= scan_keyb.o hp680_keyb.o
 
diff -Naur linux-2.6.17.8/drivers/input/keyboard/scan_keyb.c linux-2.6.17.8-sh/drivers/input/keyboard/scan_keyb.c
--- linux-2.6.17.8/drivers/input/keyboard/scan_keyb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/scan_keyb.c	2006-08-23 13:29:22.495231000 +0100
@@ -0,0 +1,148 @@
+/*
+ * Generic scan keyboard driver
+ *
+ * Copyright (C) 2000 YAEGASHI Takeshi
+ * Copyright (C) 2003 Andriy Skulysh
+ * Copyright (C) 2006 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kbd_kern.h>
+#include <linux/input.h>
+#include <linux/timer.h>
+#include "scan_keyb.h"
+
+#define SCANHZ	(HZ/20)
+
+static int scan_jiffies;
+static struct scan_keyboard *keyboards;
+struct timer_list scan_timer;
+static char *hpkbd_name = "Hitachi scankeyboard";
+static char *hpkbd_phys = "input0";
+
+static void check_kbd(struct scan_keyboard *kbd,
+		      unsigned char *new, unsigned char *old)
+{
+	const unsigned char *table = kbd->table;
+	int length = kbd->length;
+	int need_tasklet_schedule = 0;
+	unsigned int xor, bit;
+
+	while (length-- > 0) {
+		if ((xor = *new ^ *old) == 0)
+			table += 8;
+		else {
+			for (bit = 0x01; bit < 0x100; bit <<= 1) {
+				if (xor & bit) {
+					input_report_key(kbd->dev, *table,
+							 !(*new & bit));
+					need_tasklet_schedule = 1;
+				}
+
+				table++;
+			}
+		}
+
+		new++;
+		old++;
+	}
+
+	if (need_tasklet_schedule) {
+		input_sync(kbd->dev);
+		tasklet_schedule(&keyboard_tasklet);
+	}
+}
+
+static void scan_kbd(unsigned long dummy)
+{
+	struct scan_keyboard *kbd;
+
+	scan_jiffies++;
+
+	for (kbd = keyboards; kbd != NULL; kbd = kbd->next) {
+		if (scan_jiffies & 1) {
+			if (!kbd->scan(kbd->s0))
+				check_kbd(kbd, kbd->s0, kbd->s1);
+			else
+				memcpy(kbd->s0, kbd->s1, kbd->length);
+		} else {
+			if (!kbd->scan(kbd->s1))
+				check_kbd(kbd, kbd->s1, kbd->s0);
+			else
+				memcpy(kbd->s1, kbd->s0, kbd->length);
+		}
+	}
+
+	mod_timer(&scan_timer, jiffies + SCANHZ);
+}
+
+int register_scan_keyboard(struct scan_keyboard *kbd)
+{
+	int i;
+
+	kbd->s0 = kmalloc(kbd->length, GFP_KERNEL);
+	if (kbd->s0 == NULL)
+		goto error;
+
+	kbd->s1 = kmalloc(kbd->length, GFP_KERNEL);
+	if (kbd->s1 == NULL)
+		goto error;
+
+	memset(kbd->s0, -1, kbd->length);
+	memset(kbd->s1, -1, kbd->length);
+
+	kbd->dev = input_allocate_device();
+	if (!kbd->dev)
+		goto error;
+
+	kbd->dev->name = hpkbd_name;
+	kbd->dev->phys = hpkbd_phys;
+	kbd->dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
+	init_input_dev(kbd->dev);
+	kbd->dev->keycode = (unsigned char *)kbd->table;
+	kbd->dev->keycodesize = sizeof(unsigned char);
+	kbd->dev->keycodemax = ARRAY_SIZE(kbd->table);
+
+	for (i = 0; i < 128; i++)
+		if (kbd->table[i])
+			set_bit(kbd->table[i], kbd->dev->keybit);
+
+	clear_bit(0, kbd->dev->keybit);
+	input_register_device(kbd->dev);
+
+	kbd->next = keyboards;
+	keyboards = kbd;
+
+	init_timer(&scan_timer);
+	scan_timer.expires = jiffies + SCANHZ;
+	scan_timer.data = 0;
+	scan_timer.function = scan_kbd;
+	add_timer(&scan_timer);
+
+	return 0;
+
+error:
+	kfree(kbd->s1);
+	kfree(kbd->s0);
+
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(register_scan_keyboard);
+
+void unregister_scan_keyboard(struct scan_keyboard *kbd)
+{
+	del_timer_sync(&scan_timer);
+	keyboards = kbd->next;
+	input_unregister_device(kbd->dev);
+	input_free_device(kbd->dev);
+}
+EXPORT_SYMBOL_GPL(unregister_scan_keyboard);
diff -Naur linux-2.6.17.8/drivers/input/keyboard/scan_keyb.h linux-2.6.17.8-sh/drivers/input/keyboard/scan_keyb.h
--- linux-2.6.17.8/drivers/input/keyboard/scan_keyb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/keyboard/scan_keyb.h	2006-08-23 13:29:22.508231000 +0100
@@ -0,0 +1,16 @@
+#ifndef	__DRIVER_CHAR_SCAN_KEYB_H
+#define	__DRIVER_CHAR_SCAN_KEYB_H
+
+struct scan_keyboard {
+	struct scan_keyboard *next;
+	int (*scan)(unsigned char *buffer);
+	const unsigned char *table;
+	unsigned char *s0, *s1;
+	int length;
+	struct input_dev *dev;
+};
+
+int register_scan_keyboard(struct scan_keyboard *);
+void unregister_scan_keyboard(struct scan_keyboard *);
+
+#endif
diff -Naur linux-2.6.17.8/drivers/input/touchscreen/hp680_ts_input.c linux-2.6.17.8-sh/drivers/input/touchscreen/hp680_ts_input.c
--- linux-2.6.17.8/drivers/input/touchscreen/hp680_ts_input.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/input/touchscreen/hp680_ts_input.c	2006-08-23 13:29:22.400231000 +0100
@@ -15,7 +15,6 @@
 #define HP680_TS_ABS_Y_MIN	80
 #define HP680_TS_ABS_Y_MAX	910
 
-#define	SCPCR	0xa4000116
 #define	PHDR	0xa400012e
 #define SCPDR	0xa4000136
 
@@ -77,19 +76,6 @@
 
 static int __init hp680_ts_init(void)
 {
-	u8 scpdr;
-	u16 scpcr;
-
-	scpdr = ctrl_inb(SCPDR);
-	scpdr |= SCPDR_TS_SCAN_X | SCPDR_TS_SCAN_Y;
-	scpdr &= ~SCPDR_TS_SCAN_ENABLE;
-	ctrl_outb(scpdr, SCPDR);
-
-	scpcr = ctrl_inw(SCPCR);
-	scpcr &= ~SCPCR_TS_MASK;
-	scpcr |= SCPCR_TS_ENABLE;
-	ctrl_outw(scpcr, SCPCR);
-
 	hp680_ts_dev = input_allocate_device();
 	if (!hp680_ts_dev)
 		return -ENOMEM;
diff -Naur linux-2.6.17.8/drivers/Kconfig linux-2.6.17.8-sh/drivers/Kconfig
--- linux-2.6.17.8/drivers/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/Kconfig	2006-08-23 13:29:35.727531000 +0100
@@ -72,4 +72,6 @@
 
 source "drivers/rtc/Kconfig"
 
+source "drivers/stm/Kconfig"
+
 endmenu
diff -Naur linux-2.6.17.8/drivers/Makefile linux-2.6.17.8-sh/drivers/Makefile
--- linux-2.6.17.8/drivers/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/Makefile	2006-08-23 13:29:35.746531000 +0100
@@ -74,3 +74,4 @@
 obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
 obj-$(CONFIG_SUPERH)		+= sh/
+obj-$(CONFIG_STM_DRIVERS)	+= stm/
diff -Naur linux-2.6.17.8/drivers/mtd/maps/Kconfig linux-2.6.17.8-sh/drivers/mtd/maps/Kconfig
--- linux-2.6.17.8/drivers/mtd/maps/Kconfig	2006-08-21 14:42:47.262868000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/maps/Kconfig	2006-08-23 13:29:33.286485000 +0100
@@ -409,11 +409,37 @@
 
 config MTD_SOLUTIONENGINE
 	tristate "CFI Flash device mapped on Hitachi SolutionEngine"
-	depends on SUPERH && MTD_CFI && MTD_REDBOOT_PARTS
+	depends on SUPERH && MTD_CFI
 	help
 	  This enables access to the flash chips on the Hitachi SolutionEngine and
 	  similar boards. Say 'Y' if you are building a kernel for such a board.
 
+config MTD_SUPERH_RESERVE
+    hex "Default reserved Flash size"
+    depends on MTD_SOLUTIONENGINE
+    default 300000
+    help
+      The reserved memory is used by kernel and ram disk themselves. It's
+      starting from 0.
+
+config MTD_MPC1211
+	tristate "CFI Flash device mapped on Interface MPC-1211"
+	depends on SUPERH && SH_MPC1211 && MTD_CFI
+	help
+	  This enables access to the flash chips on the Interface MPC-1211(CTP/PCI/MPC-SH02).
+	  Say 'Y' if you are building a kernel for such a board.
+
+config MTD_RTS7751R2D
+	tristate "CFI Flash device mapped on Renesas RTS7751R2D"
+	depends on SUPERH && SH_RTS7751R2D && MTD_CFI && MTD_PARTITIONS
+	help
+ 	  This enables access to the flash chips on the Renesas Technology Sales RTS7751R2D.
+	  Say 'Y' if you are building a kernel for such a board.
+
+config MTD_MICRODEV
+	tristate "CFI Flash device mapped on SuperH SH4-202 MicroDev"
+	depends on SUPERH && SH_SH4202_MICRODEV && MTD_CFI && MTD_PARTITIONS
+
 config MTD_ARM_INTEGRATOR
 	tristate "CFI Flash device mapped on ARM Integrator/P720T"
 	depends on ARM && MTD_CFI
@@ -523,13 +549,6 @@
 	  This enables access to the flash chips on the Hynix evaluation boards.
 	  If you have such a board, say 'Y'.
 
-config MTD_MPC1211
-	tristate "CFI Flash device mapped on Interface MPC-1211"
-	depends on SH_MPC1211 && MTD_CFI
-	help
-	  This enables access to the flash chips on the Interface MPC-1211(CTP/PCI/MPC-SH02).
-	  If you have such a board, say 'Y'.
-
 config MTD_OMAP_NOR
 	tristate "TI OMAP board mappings"
 	depends on MTD_CFI && ARCH_OMAP
@@ -630,5 +649,25 @@
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_STBOARDS
+        tristate "CFI Flash device mapped on STMicroelectronics ST40 boards"
+        depends on SUPERH && MTD_CFI
+        help
+          Support for CFI Flash device mapped on STMicroelectronics ST40 boards.
+
+config MTD_STBOARDS_STEM
+        tristate "STEM module support"
+        depends on MTD_STBOARDS
+
+config MTD_STBOARDS_STEM_ADDR
+        depends on MTD_STBOARDS_STEM
+        hex "STEM module base address" if MTD_STBOARDS_STEM
+        default "0x02000000"
+
+config MTD_STBOARDS_STEM_SIZE
+        depends on MTD_STBOARDS_STEM
+        hex "STEM module size" if MTD_STBOARDS_STEM
+        default "0x02000000"
+
 endmenu
 
diff -Naur linux-2.6.17.8/drivers/mtd/maps/Makefile linux-2.6.17.8-sh/drivers/mtd/maps/Makefile
--- linux-2.6.17.8/drivers/mtd/maps/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/maps/Makefile	2006-08-23 13:29:33.300484000 +0100
@@ -62,6 +62,7 @@
 obj-$(CONFIG_MTD_SBC8240)	+= sbc8240.o
 obj-$(CONFIG_MTD_NOR_TOTO)	+= omap-toto-flash.o
 obj-$(CONFIG_MTD_MPC1211)	+= mpc1211.o
+obj-$(CONFIG_MTD_RTS7751R2D)	+= rts7751r2d-flash.o
 obj-$(CONFIG_MTD_IXP4XX)	+= ixp4xx.o
 obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
@@ -69,5 +70,7 @@
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+obj-$(CONFIG_MTD_MICRODEV)	+= microdev-flash.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_STBOARDS)	+= stboards.o
diff -Naur linux-2.6.17.8/drivers/mtd/maps/microdev-flash.c linux-2.6.17.8-sh/drivers/mtd/maps/microdev-flash.c
--- linux-2.6.17.8/drivers/mtd/maps/microdev-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/maps/microdev-flash.c	2006-08-23 13:29:09.615932000 +0100
@@ -0,0 +1,165 @@
+/*
+ * drivers/mtd/maps/microdev-flash.c
+ *
+ * Flash Mapping for the SuperH SH4-202 MicroDev.
+ *
+ *  Copyright (C) 2004  SuperH, Inc.
+ *  Copyright (C) 2004  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+/*
+ * The SH4-202 MicroDev has 32M of Intel StrataFlash mapped into the
+ * beginning of the FEMI address space (mapped to P0). MicroDev flash
+ * consists of 2x16M chips, mapped contiguously, and accessed with a
+ * 32-bit buswidth.
+ *
+ * Additionally, the MicroDev also supports booting from an EEPROM.
+ * In the event that the EEPROM is configured, it is mapped in the
+ * same address space window as the StrataFlash. As such, we can only
+ * use one at a time.
+ *
+ * Since the EEPROM is only accessible with an 8-bit buswidth, flash
+ * is preferrable as far as performance is concerned.
+ */
+struct map_info microdev_flash_map = {
+	.name		= "MicroDev Flash",
+	.size		= 0x02000000,
+	.bankwidth	= 4,
+};
+
+struct map_info microdev_eeprom_map = {
+	.name		= "MicroDev EEPROM",
+	.size		= 0x00100000,
+	.bankwidth	= 1,
+};
+
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+static struct mtd_partition *parsed_parts;
+
+/*
+ * Default partition map.
+ */
+static struct mtd_partition microdev_partitions[] = {
+#ifdef CONFIG_MTD_PARTITIONS
+	{
+		.name		= "bootloader",
+		.size		= 0x00080000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	}, {
+		.name		= "User FS",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+#endif
+};
+
+static struct mtd_info *microdev_flash;
+static struct mtd_info *microdev_eeprom;
+static struct mtd_info *microdev_mtd;
+
+static void show_map_info(struct map_info *info)
+{
+	unsigned long addr;
+
+	if (!info)
+		return;
+
+	addr = info->phys & 0x1fffffff;
+
+	printk(KERN_NOTICE "%s at 0x%08lx:0x%08lx, using a %d-bit bankwidth.\n",
+	       info->name, addr, addr + info->size, info->bankwidth << 3);
+}
+
+static int __init microdev_map_init(void)
+{
+	struct mtd_partition *parts;
+	int nr_parts, parsed_nr_parts;
+
+	/* Flash mapped at FEMI area 0 */
+	microdev_flash_map.phys  = 0;
+	microdev_flash_map.virt  = (void __iomem *)P2SEGADDR(0);
+
+	/* EEPROM mapped in the same place */
+	microdev_eeprom_map.phys = 0;
+	microdev_eeprom_map.virt = (void __iomem *)P2SEGADDR(0);
+
+	simple_map_init(&microdev_flash_map);
+	simple_map_init(&microdev_eeprom_map);
+
+	/* Try the flash first */
+	printk(KERN_NOTICE "MicroDev flash: probing for flash chips at 0x00000000:\n");
+	microdev_flash = do_map_probe("cfi_probe", &microdev_flash_map);
+	if (!microdev_flash) {
+		printk(KERN_NOTICE "Flash chips not detected, probing for EEPROM\n");
+
+		/* No luck, try EEPROM */
+		microdev_eeprom = do_map_probe("map_rom", &microdev_eeprom_map);
+		if (!microdev_eeprom) {
+			/* Nope.. */
+			printk(KERN_ERR "nothing found\n");
+			return -ENXIO;
+		}
+	}
+
+	if (microdev_flash) {
+		microdev_mtd = microdev_flash;
+		show_map_info(&microdev_flash_map);
+	} else {
+		microdev_mtd = microdev_eeprom;
+		show_map_info(&microdev_eeprom_map);
+	}
+
+	microdev_mtd->owner = THIS_MODULE;
+
+	/* Start out with a static map.. */
+	parts = microdev_partitions;
+	nr_parts = ARRAY_SIZE(microdev_partitions);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Try to parse the partitions */
+	parsed_nr_parts = parse_mtd_partitions(microdev_mtd, probes, &parsed_parts, 0);
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nr_parts = parsed_nr_parts;
+	}
+#endif
+
+	if (nr_parts > 0) {
+		add_mtd_partitions(microdev_mtd, parts, nr_parts);
+	} else {
+		add_mtd_device(microdev_mtd);
+	}
+
+	return 0;
+}
+
+static void __exit microdev_map_exit(void)
+{
+	if (parsed_parts) {
+		del_mtd_partitions(microdev_mtd);
+	} else {
+		del_mtd_device(microdev_mtd);
+	}
+
+	map_destroy(microdev_mtd);
+}
+
+module_init(microdev_map_init);
+module_exit(microdev_map_exit);
+
+MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
+MODULE_DESCRIPTION("MTD map driver for SuperH SH4-202 MicroDev");
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.17.8/drivers/mtd/maps/rts7751r2d-flash.c linux-2.6.17.8-sh/drivers/mtd/maps/rts7751r2d-flash.c
--- linux-2.6.17.8/drivers/mtd/maps/rts7751r2d-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/maps/rts7751r2d-flash.c	2006-08-23 13:29:09.621932000 +0100
@@ -0,0 +1,167 @@
+/* -------------------------------------------------------------------- */
+/* rts7751r2d-flash.c:                                                     */
+/* -------------------------------------------------------------------- */
+/*  This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Copyright 2003 (c) Lineo uSolutions,Inc.
+*/
+/* -------------------------------------------------------------------- */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#undef FLASH4M_16BIT
+#define FLASH16M_16BIT
+
+#if defined(FLASH4M_16BIT)
+#define RTS7751R2D_FLASH_SIZE 0x00100000
+#else
+#define RTS7751R2D_FLASH_SIZE 0x01000000
+#endif
+
+static struct map_info rts7751r2d_map = {
+	.name		= "SH-Graphic flash",
+	.bankwidth	= 2,
+	.size		= RTS7751R2D_FLASH_SIZE,
+};
+
+/*
+ * Here are partition information for all known SH-Graphic based devices.
+ * See include/linux/mtd/partitions.h for definition of the mtd_partition
+ * structure.
+ *
+ * The *_max_flash_size is the maximum possible mapped flash size which
+ * is not necessarily the actual flash size.  It must correspond to the
+ * value specified in the mapping definition defined by the
+ * "struct map_desc *_io_desc" for the corresponding machine.
+ */
+
+#if defined(FLASH4M_16BIT)
+static struct mtd_partition rts7751r2d_partitions[] = {
+	{
+		.name		= "bootloader",
+		.size		= 0x00080000,
+		.offset		= 0xa0000000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},{
+		.name		= "SH-Graphic jffs",
+		.size		= 0x00080000,
+		.offset		= 0xa0080000,
+	}
+};
+#else
+static struct mtd_partition rts7751r2d_partitions[] = {
+	{
+		.name		= "bootloader",
+		.size		= 0x00020000,
+		.offset		= 0x00000000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},{
+		.name		= "mtdblock1",
+		.size		= 0x00300000,
+		.offset		= 0x00020000,
+	},{
+		.name		= "mtdblock2",
+		.size		= 0x004e0000,
+		.offset		= 0x00320000,
+	},{
+		.name		= "mtdblock3",
+		.size		= 0x00800000,
+		.offset		= 0x00800000,
+	}
+};
+#endif
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init rts7751r2d_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	char *part_type;
+
+	/* Default flash buswidth */
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = rts7751r2d_partitions;
+
+	nb_parts = ARRAY_SIZE(rts7751r2d_partitions);
+	rts7751r2d_map.phys = 0;
+	rts7751r2d_map.virt = P2SEGADDR(0);
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "RTS7751R2D flash: probing %d-bit flash bus\n",
+			rts7751r2d_map.bankwidth*8);
+	simple_map_init(&rts7751r2d_map);
+
+	mymtd = do_map_probe("cfi_probe", &rts7751r2d_map);
+	if (!mymtd)
+		return -ENXIO;
+
+	mymtd->owner = THIS_MODULE;
+	mymtd->erasesize = 0x10000;
+
+	/*
+	 * Dynamic partition selection stuff (might override the static ones)
+	 */
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	}
+
+	if (nb_parts == 0) {
+		printk(KERN_NOTICE "RTS7751R2D partition info available, registering whole flash at once\n");
+		add_mtd_device(mymtd);
+	} else {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	}
+	return 0;
+}
+
+static void __exit rts7751r2d_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(rts7751r2d_mtd_init);
+module_exit(rts7751r2d_mtd_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lineo uSolutions,Inc.");
+MODULE_DESCRIPTION("MTD map driver for RTS7751R2D base board");
diff -Naur linux-2.6.17.8/drivers/mtd/maps/stboards.c linux-2.6.17.8-sh/drivers/mtd/maps/stboards.c
--- linux-2.6.17.8/drivers/mtd/maps/stboards.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/maps/stboards.c	2006-08-23 13:29:43.028691000 +0100
@@ -0,0 +1,261 @@
+/*
+ * $Id$
+ *
+ * Chip mappings for the ST Microelectronics ST40STB1 and ST40GX1 based boards.
+ * Adapted from physmap.c
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define ONBOARD_ADDR 0x00000000
+
+#if defined(CONFIG_SH_STB1_HARP)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_GX1_EVAL)
+#define ONBOARD_SIZE (16*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_MEDIAREF)
+#define ONBOARD_SIZE (16*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_STB1_OVERDRIVE)
+#define ONBOARD_SIZE 0
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_STB1_EVAL)
+#define ONBOARD_SIZE (4*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_ST40_STARTER)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_STM8000_DEMO)
+#define ONBOARD_SIZE (16*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#elif defined(CONFIG_SH_TMM_LR2)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#elif defined(CONFIG_SH_STI5528_EVAL)
+#define ONBOARD_SIZE (32*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_STI5528_ESPRESSO)
+#define ONBOARD_SIZE (16*1024*1024)
+#define ONBOARD_BANKWIDTH 4
+#elif defined(CONFIG_SH_ST220_EVAL)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#elif defined(CONFIG_SH_STB7100_MBOARD)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#elif defined(CONFIG_SH_STB7100_REF)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#elif defined(CONFIG_SH_STB7109E_REF)
+#define ONBOARD_SIZE (8*1024*1024)
+#define ONBOARD_BANKWIDTH 2
+#else
+#error Unknown board
+#endif
+
+#ifdef CONFIG_MTD_STBOARDS_STEM_ADDR
+#define STEM_ADDR CONFIG_MTD_STBOARDS_STEM_ADDR
+#define STEM_SIZE CONFIG_MTD_STBOARDS_STEM_SIZE
+#endif
+
+#if ONBOARD_SIZE > 0
+static struct mtd_info *onboard_mtd;
+#endif
+#ifdef STEM_ADDR
+static struct mtd_info *stem_mtd;
+#endif
+
+#define dprintk(x...)  printk(KERN_DEBUG x)
+//#define dprintk(x...)
+
+#if defined(CONFIG_SH_STB1_HARP) || \
+    defined(CONFIG_SH_GX1_EVAL) || \
+    defined(CONFIG_SH_ST40_STARTER) || \
+    defined(CONFIG_SH_TMM_LR2) || \
+    defined(CONFIG_SH_STI5528_EVAL) || \
+    defined(CONFIG_SH_STB7100_MBOARD)
+#define NEED_VPP
+#include <asm/mach/harp.h>
+#endif
+
+#ifdef NEED_VPP
+/*
+ * The comments in mtd/map.h say that this needs to nest correctly,
+ * but in practice vpp gets disabled without being first enabled,
+ * so clearly this is not true. So ignore this, and simply enable and
+ * disable as requested.
+ */
+static void stboards_set_vpp(struct map_info *map, int vpp)
+{
+	if (vpp) {
+		harp_set_vpp_on();
+	} else {
+		harp_set_vpp_off();
+	}
+}
+#endif
+
+#if ONBOARD_SIZE > 0
+static struct map_info onboard_map = {
+	.name = "Onboard_Flash",
+	.size = ONBOARD_SIZE,
+	.bankwidth = ONBOARD_BANKWIDTH,
+#ifdef NEED_VPP
+	.set_vpp = stboards_set_vpp,
+#endif
+};
+#endif
+
+#ifdef STEM_ADDR
+static struct map_info stem_map = {
+	.name = "STEM Flash",
+	.size = STEM_SIZE,
+	.bankwidth = 4,
+};
+#endif
+
+static struct mtd_partition onboard_partitions[3] = {
+	{
+	 .name = "Boot firmware",
+	 .size = 0x00040000,
+	 .offset = 0x00000000,
+	 /* mask_flags: MTD_WRITEABLE *//* force read-only */
+	 },
+	{
+	 .name = "Kernel",
+	 .size = 0x00100000,
+	 .offset = 0x00040000,
+
+	 },
+	{
+	 .name = "Root FS",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x00140000,
+	 }
+};
+static struct mtd_partition *parsed_parts;
+static const char *probes[] = { "cmdlinepart", NULL };
+
+int __init init_stboards(void)
+{
+	int nr_parts = 0;
+
+#ifdef CONFIG_SH_STB1_HARP
+	/* Enable writing to Flash */
+	ctrl_outl(3, EPLD_FLASHCTRL);
+#endif
+
+#if ONBOARD_SIZE > 0
+	printk(KERN_NOTICE
+	       "Generic ST boards onboard flash device: 0x%08x (%d.%dMb) at 0x%08x\n",
+	       ONBOARD_SIZE,
+	       (ONBOARD_SIZE / (1024 * 1024)),
+	       (ONBOARD_SIZE / ((1024 * 1024) / 10)) % 10, ONBOARD_ADDR);
+
+	onboard_map.phys = ONBOARD_ADDR;
+	onboard_map.size = ONBOARD_SIZE;
+	onboard_map.virt =
+	    (unsigned long *)ioremap(onboard_map.phys, onboard_map.size);
+	dprintk("%s %s[%d] onboard_map.virt = 0x%08x\n", __FILE__, __FUNCTION__,
+		__LINE__, (int)onboard_map.virt);
+	if (onboard_map.virt == 0) {
+		printk(KERN_ERR "Failed to ioremap onboard Flash\n");
+	} else {
+#ifndef CONFIG_MTD_COMPLEX_MAPPINGS
+		simple_map_init(&onboard_map);
+#endif
+#if defined(CONFIG_SH_STB1_HARP) || defined(CONFIG_SH_STB1_EVAL)
+		onboard_mtd = do_map_probe("jedec_probe", &onboard_map);
+#else
+		onboard_mtd = do_map_probe("cfi_probe", &onboard_map);
+#endif
+		if (onboard_mtd != NULL) {
+			onboard_mtd->owner = THIS_MODULE;
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+			nr_parts =
+			    parse_mtd_partitions(onboard_mtd, probes,
+						 &parsed_parts, 0);
+#endif
+			if (nr_parts <= 0)
+				add_mtd_partitions(onboard_mtd,
+						   onboard_partitions,
+						   ARRAY_SIZE
+						   (onboard_partitions));
+			else
+				add_mtd_partitions(onboard_mtd, parsed_parts,
+						   nr_parts);
+		} else {
+			iounmap((void *)onboard_map.virt);
+		}
+	}
+#endif
+
+#ifdef STEM_ADDR
+	printk(KERN_NOTICE
+	       "Generic ST boards STEM flash device: 0x%08x at 0x%08x\n",
+	       STEM_SIZE, STEM_ADDR);
+
+	stem_map.phys = STEM_ADDR;
+	stem_map.size = STEM_SIZE;
+	stem_map.virt = (unsigned long)ioremap(stem_map.phys, stem_map.size);
+	if (stem_map.virt == 0) {
+		printk(KERN_ERR "Failed to ioremap STEM Flash\n");
+	} else {
+#ifndef CONFIG_MTD_COMPLEX_MAPPINGS
+		simple_map_init(&stem_map);
+#endif
+		stem_mtd = do_map_probe("cfi_probe", &stem_map);
+		if (stem_mtd != NULL) {
+			stem_mtd->owner = THIS_MODULE;
+#if ONBOARD_SIZE > 0
+			add_mtd_device(stem_mtd);
+#else
+			add_mtd_partitions(stem_mtd, onboard_partitions,
+					   ARRAY_SIZE(onboard_partitions));
+#endif
+		} else {
+			iounmap((void *)stem_map.virt);
+		}
+	}
+#endif
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_stboards(void)
+{
+#if ONBOARD_SIZE > 0
+	if (onboard_mtd) {
+		del_mtd_partitions(onboard_mtd);
+		map_destroy(onboard_mtd);
+	}
+	if (onboard_map.virt != 0) {
+		iounmap((void *)onboard_map.virt);
+		onboard_map.virt = 0;
+	}
+#endif
+
+#ifdef STEM_ADDR
+	if (stem_mtd) {
+		del_mtd_partitions(stem_mtd);
+		map_destroy(stem_mtd);
+	}
+	if (stem_map.virt != 0) {
+		iounmap((void *)stem_map.virt);
+		stem_map.virt = 0;
+	}
+#endif
+}
+
+module_init(init_stboards);
+module_exit(cleanup_stboards);
diff -Naur linux-2.6.17.8/drivers/mtd/mtdpart.c linux-2.6.17.8-sh/drivers/mtd/mtdpart.c
--- linux-2.6.17.8/drivers/mtd/mtdpart.c	2006-08-21 14:42:47.576871000 +0100
+++ linux-2.6.17.8-sh/drivers/mtd/mtdpart.c	2006-08-23 13:29:07.226886000 +0100
@@ -410,6 +410,14 @@
 		printk (KERN_NOTICE "0x%08x-0x%08x : \"%s\"\n", slave->offset,
 			slave->offset + slave->mtd.size, slave->mtd.name);
 
+#ifdef CONFIG_SUPERH
+		/*
+		 * slave->offset contains a P2 address, this confuses the rest
+		 * of the sanity checks, so kick it back down to P0.
+		 */
+		slave->offset &= 0x1fffffff;
+#endif
+
 		/* let's do some sanity checks */
 		if (slave->offset >= master->size) {
 				/* let's register it anyway to preserve ordering */
diff -Naur linux-2.6.17.8/drivers/net/8139too.c linux-2.6.17.8-sh/drivers/net/8139too.c
--- linux-2.6.17.8/drivers/net/8139too.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/8139too.c	2006-08-23 13:29:07.171887000 +0100
@@ -970,11 +970,17 @@
 	ioaddr = tp->mmio_addr;
 	assert (ioaddr != NULL);
 
+#ifdef CONFIG_SH_SECUREEDGE5410
+	/* Don't rely on the eeprom, get MAC from chip. */
+	for (i = 0; i < 6; i++)
+		dev->dev_addr[i] = readb(ioaddr + MAC0 + i);
+#else
 	addr_len = read_eeprom (ioaddr, 0, 8) == 0x8129 ? 8 : 6;
 	for (i = 0; i < 3; i++)
 		((u16 *) (dev->dev_addr))[i] =
 		    le16_to_cpu (read_eeprom (ioaddr, i + 7, addr_len));
 	memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
+#endif
 
 	/* The Rtl8139-specific entries in the device structure. */
 	dev->open = rtl8139_open;
diff -Naur linux-2.6.17.8/drivers/net/8390.c linux-2.6.17.8-sh/drivers/net/8390.c
--- linux-2.6.17.8/drivers/net/8390.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/8390.c	2006-08-23 13:29:20.074162000 +0100
@@ -108,6 +108,13 @@
 int ei_debug = 1;
 #endif
 
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+#ifdef ETH_ZLEN
+#undef ETH_ZLEN
+#define ETH_ZLEN	64
+#endif
+#endif
+
 /* Index to functions. */
 static void ei_tx_intr(struct net_device *dev);
 static void ei_tx_err(struct net_device *dev);
@@ -938,7 +945,11 @@
 	 */
 	 
 	if (netif_running(dev))
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+		outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);
+#else
 		outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);
+#endif
 	outb_p(E8390_NODMA + E8390_PAGE1, e8390_base + E8390_CMD);
 	for(i = 0; i < 8; i++) 
 	{
@@ -951,11 +962,23 @@
 	outb_p(E8390_NODMA + E8390_PAGE0, e8390_base + E8390_CMD);
 
   	if(dev->flags&IFF_PROMISC)
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+  		outb_p(E8390_RXCONFIG | 0x40 | 0x18, e8390_base + EN0_RXCR);
+#else
   		outb_p(E8390_RXCONFIG | 0x18, e8390_base + EN0_RXCR);
+#endif
 	else if(dev->flags&IFF_ALLMULTI || dev->mc_list)
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+  		outb_p(E8390_RXCONFIG | 0x40 | 0x08, e8390_base + EN0_RXCR);
+#else
   		outb_p(E8390_RXCONFIG | 0x08, e8390_base + EN0_RXCR);
+#endif
   	else
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+  		outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);
+#else
   		outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);
+#endif
  }
 
 /*
@@ -1029,8 +1052,13 @@
 	struct ei_device *ei_local = (struct ei_device *) netdev_priv(dev);
 	int i;
 	int endcfg = ei_local->word16
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+	    ? (0x00 | ENDCFG_WTS | (ei_local->bigendian ? ENDCFG_BOS : 0))
+	    : 0x00;
+#else
 	    ? (0x48 | ENDCFG_WTS | (ei_local->bigendian ? ENDCFG_BOS : 0))
 	    : 0x48;
+#endif
     
 	if(sizeof(struct e8390_pkt_hdr)!=4)
     		panic("8390.c: header struct mispacked\n");    
@@ -1041,7 +1069,11 @@
 	outb_p(0x00,  e8390_base + EN0_RCNTLO);
 	outb_p(0x00,  e8390_base + EN0_RCNTHI);
 	/* Set to monitor and loopback mode -- this is vital!. */
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+	outb_p(E8390_RXOFF | 0x40, e8390_base + EN0_RXCR); /* 0x20 */
+#else
 	outb_p(E8390_RXOFF, e8390_base + EN0_RXCR); /* 0x20 */
+#endif
 	outb_p(E8390_TXOFF, e8390_base + EN0_TXCR); /* 0x02 */
 	/* Set the transmit page and receive ring. */
 	outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);
@@ -1078,7 +1110,11 @@
 		outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);
 		outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR); /* xmit on. */
 		/* 3c503 TechMan says rxconfig only after the NIC is started. */
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+		outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR); /* rx on,  */
+#else
 		outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR); /* rx on,  */
+#endif
 		do_set_multicast_list(dev);	/* (re)load the mcast table */
 	}
 }
diff -Naur linux-2.6.17.8/drivers/net/88796l.c linux-2.6.17.8-sh/drivers/net/88796l.c
--- linux-2.6.17.8/drivers/net/88796l.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/88796l.c	2006-08-23 13:29:20.086162000 +0100
@@ -0,0 +1,95 @@
+#define	NE_EEPROM	0x14
+
+static inline void delay(void);
+static unsigned char asix88796_eeprom_getbit(int ioaddr);
+static void asix88796_eeprom_send(int ioaddr, int value);
+static unsigned short asix88796_eeprom_get(int ioaddr);
+static void asix88796_eeprom_setaddr(int ioaddr, int addr);
+static void asix88796_eeprom_command(int ioaddr);
+static void asix88796_eeprom_read(int ioaddr, unsigned char *buff);
+
+static inline void delay(void)
+{
+	ctrl_inw(0xa0000000);
+}
+
+static unsigned char asix88796_eeprom_getbit(int ioaddr)
+{
+	unsigned char value;
+
+	outb(inb(ioaddr + NE_EEPROM) & 0x7f, ioaddr + NE_EEPROM);
+	delay();
+	value = (inb(ioaddr + NE_EEPROM) & 0x40) >> 6;
+	outb(inb(ioaddr + NE_EEPROM) | 0x80, ioaddr + NE_EEPROM);
+	delay();
+
+	return value;
+}
+
+static void asix88796_eeprom_send(int ioaddr, int value)
+{
+	if (value)
+		outb(inb(ioaddr + NE_EEPROM) | 0x20, ioaddr + NE_EEPROM);
+	else
+		outb(inb(ioaddr + NE_EEPROM) & 0xdf, ioaddr + NE_EEPROM);
+	outb(inb(ioaddr + NE_EEPROM) & 0x7f, ioaddr + NE_EEPROM);
+	delay();
+	outb(inb(ioaddr + NE_EEPROM) | 0x80, ioaddr + NE_EEPROM);
+	delay();
+	outb(inb(ioaddr + NE_EEPROM) & 0xdf, ioaddr + NE_EEPROM);
+}
+
+static unsigned short asix88796_eeprom_get(int ioaddr)
+{
+	unsigned short value = 0;
+	int i;
+
+	asix88796_eeprom_getbit(ioaddr);
+	for (i=0; i<16; i++) {
+		value <<= 1;
+		value |= asix88796_eeprom_getbit(ioaddr);
+	}
+
+	return value;
+}
+
+static void asix88796_eeprom_setaddr(int ioaddr, int addr)
+{
+	asix88796_eeprom_send(ioaddr, addr & 0x0080);
+	asix88796_eeprom_send(ioaddr, addr & 0x0040);
+	asix88796_eeprom_send(ioaddr, addr & 0x0020);
+	asix88796_eeprom_send(ioaddr, addr & 0x0010);
+	asix88796_eeprom_send(ioaddr, addr & 0x0008);
+	asix88796_eeprom_send(ioaddr, addr & 0x0004);
+	asix88796_eeprom_send(ioaddr, addr & 0x0002);
+	asix88796_eeprom_send(ioaddr, addr & 0x0001);
+}
+
+static void asix88796_eeprom_command(int ioaddr)
+{
+	asix88796_eeprom_send(ioaddr, 0);
+	asix88796_eeprom_send(ioaddr, 1);
+	asix88796_eeprom_send(ioaddr, 1);
+	asix88796_eeprom_send(ioaddr, 0);
+}
+
+static void asix88796_eeprom_read(int ioaddr, unsigned char *buff)
+{
+	int i;
+	int addr = 0;
+	unsigned short value;
+
+	for (i=0; i<3; i++) {
+		outb(inb(ioaddr + NE_EEPROM) | 0x10, ioaddr + NE_EEPROM);
+		outb(inb(ioaddr + NE_EEPROM) & 0xdf, ioaddr + NE_EEPROM);
+		delay();
+		asix88796_eeprom_command(ioaddr);
+		asix88796_eeprom_setaddr(ioaddr, addr++);
+		value = asix88796_eeprom_get(ioaddr);
+		*buff++ = (unsigned char)(value & 0xff);
+		*buff++ = (unsigned char)((value >> 8) & 0xff);
+		outb(inb(ioaddr + NE_EEPROM) & 0x7f, ioaddr + NE_EEPROM);
+		outb(inb(ioaddr + NE_EEPROM) & 0xdf, ioaddr + NE_EEPROM);
+		outb(inb(ioaddr + NE_EEPROM) & 0xef, ioaddr + NE_EEPROM);
+	}
+}
diff -Naur linux-2.6.17.8/drivers/net/Kconfig linux-2.6.17.8-sh/drivers/net/Kconfig
--- linux-2.6.17.8/drivers/net/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/Kconfig	2006-08-23 13:29:50.477875000 +0100
@@ -116,6 +116,17 @@
 
 	  If you don't know what to use this for, you don't need it.
 
+config NWHW_CONFIG
+	bool "Configure network hardware from the command line"
+	depends on NETDEVICES
+	---help---
+	  Many network drivers now support hardware level configuration via
+	  utilities such as ifconfig, ethtool and mii-tool. However sometimes
+	  these settings need to be adjusted before a file system is
+	  available (typically if the root file system uses NFS). This
+	  option adds a simple kernel command line interface to configure
+	  some common network parameters.
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on PNP
@@ -837,6 +848,34 @@
 	  module, say M here and read <file:Documentation/modules.txt> as well
 	  as <file:Documentation/networking/net-modules.txt>.
 
+config SMSC911x
+	tristate "SMSC 911x support"
+	depends on NET_ETHERNET && SUPERH
+	select CRC32
+	---help---
+	  This is a driver for SMSC's 911x series of Ethernet chips,
+	  including the SMSC9118. Say Y if you want it
+	  compiled into the kernel, and read the file
+	  <file:drivers/net/smsc_911x/readme.txt> and the Ethernet-HOWTO,
+	  available from  <http://www.linuxdoc.org/docs.html#howto>.
+
+	  This is a modified version of the driver available from
+	  SMSC: http://www.smsc.com/main/catalog/lan9118.html
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>. The module
+	  will be called smsc911x.
+
+config SMSC911x_DMA
+	boolean "SMSC 911x DMA support (EXPERIMENTAL)"
+	depends on SMSC911x && EXPERIMENTAL
+	---help---
+	  Enabling this option will set the default behaviour of the
+	  SMSC 911x driver to use DMA transfers, otherwise it will use
+	  PIO transfers. This may reduce the CPU overhead, will probably
+	  reduce performance.
+
+
 config SMC9194
 	tristate "SMC 9194 support"
 	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
@@ -1078,7 +1117,7 @@
 
 config NE2000
 	tristate "NE2000/NE1000 support"
-	depends on NET_ISA || (Q40 && m) || M32R
+	depends on NET_ISA || (Q40 && m) || M32R || SUPERH
 	select CRC32
 	---help---
 	  If you have a network (Ethernet) card of this type, say Y and read
@@ -1821,6 +1860,49 @@
 source "drivers/net/fec_8xx/Kconfig"
 source "drivers/net/fs_enet/Kconfig"
 
+config STB7109_ETH
+        tristate "STb7109 Ethernet driver"
+        select MII
+        select STE101P
+        select PHYLIB
+        depends on NET_ETHERNET && (SH_STB7100_MBOARD || SH_STB7109E_REF)
+        ---help---
+          This is the driver for the STB7109 on-chip Ethernet controller.
+          The STb7109 ETH subsystem is composed of three main layers:
+	  a DMA layer, a Transaction Layer Interface (TLI), and a Media Access
+	  Controller layer (MAC).
+
+config DMA_RX_SIZE
+        int "RX DMA list size"
+        default "8"
+	depends on STB7109_ETH
+        help
+          it's the max number of descriptors in the RX list.
+
+config DMA_TX_SIZE
+        int "TX DMA list size"
+        default "8"
+	depends on STB7109_ETH
+        help
+          it's the max number of descriptors in the TX list.
+
+config 7109ETH_DEBUG
+        boolean "Debug mode"
+	depends on STB7109_ETH
+        help
+          it enables the debug mode for the IRQ handle.
+
+config 7109ETH_NAPI
+        bool "Enable NAPI support (EXPERIMENTAL)"
+        depends on STB7109_ETH && EXPERIMENTAL
+        help
+          NAPI is a new driver API designed to reduce CPU and interrupt load
+          when the driver is receiving lots of packets from the card.
+	  It is still somewhat experimental and thus not yet enabled by default.
+
+          Please, for more information about the NAPI support see:
+		<file:Documentation/networking/NAPI_HOWTO.txt>
+
 endmenu
 
 #
diff -Naur linux-2.6.17.8/drivers/net/Makefile linux-2.6.17.8-sh/drivers/net/Makefile
--- linux-2.6.17.8/drivers/net/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/Makefile	2006-08-23 13:29:46.013761000 +0100
@@ -88,6 +88,7 @@
 obj-$(CONFIG_SHAPER) += shaper.o
 obj-$(CONFIG_HP100) += hp100.o
 obj-$(CONFIG_SMC9194) += smc9194.o
+obj-$(CONFIG_SMSC911x) += smsc_911x/
 obj-$(CONFIG_FEC) += fec.o
 obj-$(CONFIG_68360_ENET) += 68360enet.o
 obj-$(CONFIG_ARM_ETHERH) += 8390.o
@@ -195,6 +196,7 @@
 obj-$(CONFIG_SMC91X) += smc91x.o
 obj-$(CONFIG_DM9000) += dm9000.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
+obj-$(CONFIG_STB7109_ETH) += stb7109eth.o
 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
@@ -213,3 +215,5 @@
 
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
+# This needs to be after any devices which may use it
+obj-$(CONFIG_NWHW_CONFIG) += nwhwconfig.o
diff -Naur linux-2.6.17.8/drivers/net/ne.c linux-2.6.17.8-sh/drivers/net/ne.c
--- linux-2.6.17.8/drivers/net/ne.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/ne.c	2006-08-23 13:29:21.232208000 +0100
@@ -142,6 +142,10 @@
 #elif defined(CONFIG_PLAT_OAKS32R)  || \
    defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
 #  define DCR_VAL 0x48		/* 8-bit mode */
+#elif defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || \
+   defined(CONFIG_SH_R7780RP)
+#  include "88796l.c"
+#  define DCR_VAL 0x01
 #else
 #  define DCR_VAL 0x49
 #endif
@@ -191,6 +195,11 @@
 
 	SET_MODULE_OWNER(dev);
 
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+	base_addr = AX88796L_IO_BASE;
+	dev->irq = IRQ_ONETH;
+#endif
+
 	/* First check any supplied i/o locations. User knows best. <cough> */
 	if (base_addr > 0x1ff)	/* Check a single specified location. */
 		return ne_probe1(dev, base_addr);
@@ -324,7 +333,11 @@
 	if (ei_debug  &&  version_printed++ == 0)
 		printk(KERN_INFO "%s" KERN_INFO "%s", version1, version2);
 
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+	printk(KERN_INFO "ASIX AX88796L ethercard probe at %#3x:", ioaddr);
+#else
 	printk(KERN_INFO "NE*000 ethercard probe at %#3x:", ioaddr);
+#endif
 
 	/* A user with a poor card that fails to ack the reset, or that
 	   does not have a valid 0x57,0x57 signature can still use this
@@ -365,12 +378,20 @@
 		struct {unsigned char value, offset; } program_seq[] =
 		{
 			{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD}, /* Select page 0*/
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+			{0x00,	EN0_DCFG},	/* Set byte-wide (0x00) access. */
+#else
 			{0x48,	EN0_DCFG},	/* Set byte-wide (0x48) access. */
+#endif
 			{0x00,	EN0_RCNTLO},	/* Clear the count regs. */
 			{0x00,	EN0_RCNTHI},
 			{0x00,	EN0_IMR},	/* Mask completion irq. */
 			{0xFF,	EN0_ISR},
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+			{E8390_RXOFF|0x40, EN0_RXCR},	/* 0x60  Set to monitor */
+#else
 			{E8390_RXOFF, EN0_RXCR},	/* 0x20  Set to monitor */
+#endif
 			{E8390_TXOFF, EN0_TXCR},	/* 0x02  and loopback mode. */
 			{32,	EN0_RCNTLO},
 			{0x00,	EN0_RCNTHI},
@@ -395,6 +416,9 @@
 		for (i = 0; i < 16; i++)
 			SA_prom[i] = SA_prom[i+i];
 		/* We must set the 8390 for word mode. */
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+		asix88796_eeprom_read(ioaddr, SA_prom);
+#endif
 		outb_p(DCR_VAL, ioaddr + EN0_DCFG);
 		start_page = NESM_START_PG;
 
@@ -426,7 +450,11 @@
 
 	/* Set up the rest of the parameters. */
 	if (neX000 || bad_card || copam) {
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R77703DRP) || defined(CONFIG_SH_R7780RP)
+		name = (wordlength == 2) ? "AX88796L" : "NE1000";
+#else
 		name = (wordlength == 2) ? "NE2000" : "NE1000";
+#endif
 	}
 	else if (ctron)
 	{
diff -Naur linux-2.6.17.8/drivers/net/nwhwconfig.c linux-2.6.17.8-sh/drivers/net/nwhwconfig.c
--- linux-2.6.17.8/drivers/net/nwhwconfig.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/nwhwconfig.c	2006-08-23 13:29:41.257668000 +0100
@@ -0,0 +1,193 @@
+/*
+ * Configuration of network device hardware from the kernel command line.
+ *
+ * Copyright (c) STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/utsname.h>
+#include <linux/in.h>
+#include <linux/if.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/socket.h>
+#include <linux/route.h>
+#include <linux/udp.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/ethtool.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/ipconfig.h>
+
+#include <asm/uaccess.h>
+#include <net/checksum.h>
+#include <asm/processor.h>
+
+static char user_dev_name[IFNAMSIZ] __initdata = { 0, };
+static char user_hw_addr[18] __initdata = { 0, };
+static char user_speed = -1;
+static char user_duplex = -1;
+
+static int __init hex_conv_nibble(char x)
+{
+        if ((x >= '0') && (x <= '9'))
+                return x - '0';
+        if ((x >= 'a') && (x <= 'f'))
+                return x - 'a' + 10;
+        if ((x >= 'A') && (x <= 'F'))
+                return x - 'A' + 10;
+
+        return -1;
+}
+
+static int __init parse_ether(const char *mac_addr_str, struct sockaddr *addr)
+{
+        int i, c1, c2;
+	char* mac_addr = addr->sa_data;
+
+        /*
+         * Pull out 6 two-digit hex chars
+         */
+        for (i = 0; i < 6; i++) {
+
+                c1 = hex_conv_nibble(*mac_addr_str++);
+                c2 = hex_conv_nibble(*mac_addr_str++);
+
+                if ((c1 == -1) || (c2 == -1))
+                        return 0;
+
+                mac_addr[i] = (c1 << 4) | c2;
+
+                if ((i != 5) && (*mac_addr_str++ != ':'))
+                        return 0;
+        }
+
+        return 1;
+}
+
+
+static int __init nwhw_config(void)
+{
+	struct net_device *dev;
+	struct sockaddr ether_addr;
+	int valid_ether = user_hw_addr[0];
+
+	if (valid_ether) {
+		valid_ether = parse_ether(user_hw_addr, &ether_addr);
+		if (! valid_ether) {
+			printk("Failed to parse ether addr: %s\n", user_hw_addr);
+		}
+	}
+
+        dev = __dev_get_by_name(user_dev_name);
+	if (! dev) {
+		printk("%s: device not found\n", __FUNCTION__);
+		return -1;
+	}
+
+	if (valid_ether) {
+		if (!dev->set_mac_address ||
+		    dev->set_mac_address(dev, &ether_addr)) {
+			printk(KERN_WARNING "%s: not set MAC address...\n",
+				__FUNCTION__);
+		}
+	}
+
+	if ((user_speed != -1) || (user_duplex != -1)) {
+		struct ethtool_cmd cmd = { ETHTOOL_GSET };
+
+		if (! dev->ethtool_ops->get_settings ||
+		    (dev->ethtool_ops->get_settings(dev, &cmd) < 0)) {
+			printk("Failed to read ether device settings\n");
+		} else {
+			cmd.cmd = ETHTOOL_SSET;
+			cmd.autoneg = AUTONEG_DISABLE;
+			if (user_speed != -1)
+				cmd.speed = user_speed;
+			if (user_duplex != -1)
+				cmd.duplex = user_duplex;
+			if (! dev->ethtool_ops->set_settings ||
+			    (dev->ethtool_ops->set_settings(dev, &cmd) < 0)) {
+				printk("Failed to set ether device settings\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+device_initcall(nwhw_config);
+
+#if defined (CONFIG_NETPOLL)
+void nwhw_uconfig(struct net_device *dev)
+{
+	struct sockaddr ether_addr;
+	int valid_ether = user_hw_addr[0];
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (valid_ether) {
+		valid_ether = parse_ether(user_hw_addr, &ether_addr);
+		if (! valid_ether) {
+			printk(KERN_WARNING "\tfailed to parse ether addr:%s\n",
+				user_hw_addr);
+		}
+	}
+	if (valid_ether) {
+		if (!dev->set_mac_address ||
+		    dev->set_mac_address(dev, &ether_addr)) {
+			printk(KERN_WARNING "\tnot set MAC address...\n");
+		}
+	}
+	return;
+}
+#endif
+
+static int __init nwhw_config_setup(char* str)
+{
+	char* opt;
+
+	if (!str || !*str)
+		return 0;
+
+	while ((opt=strsep(&str, ",")) != NULL) {
+		if (! strncmp(opt, "device:", 7)) {
+			strlcpy(user_dev_name, opt+7, sizeof(user_dev_name));
+		}
+		else if (! strncmp(opt, "hwaddr:", 7)) {
+			strlcpy(user_hw_addr, opt+7, sizeof(user_hw_addr));
+		}
+		else if (! strncmp(opt, "speed:", 6)) {
+			switch (simple_strtoul(opt+6, NULL, 0)) {
+			case 10:
+				user_speed = SPEED_10;
+				break;
+			case 100:
+				user_speed = SPEED_100;
+				break;
+			}
+		}
+		else if (! strcmp(opt, "duplex:full")) {
+			user_duplex = DUPLEX_FULL;
+		}
+		else if (! strcmp(opt, "duplex:half")) {
+			user_duplex = DUPLEX_HALF;
+		}
+	}
+
+	return 1;
+}
+
+__setup("nwhwconf=", nwhw_config_setup);
diff -Naur linux-2.6.17.8/drivers/net/phy/Kconfig linux-2.6.17.8-sh/drivers/net/phy/Kconfig
--- linux-2.6.17.8/drivers/net/phy/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/phy/Kconfig	2006-08-23 13:29:48.691829000 +0100
@@ -45,5 +45,33 @@
 	---help---
 	  Currently supports the cis8204
 
+config STE101P
+	depends on NET_ETHERNET && PHYLIB && EXPERIMENTAL
+        tristate "Drivers for STe101p (EXPERIMENTAL)"
+        ---help---
+          This is the driver for the STe101p SMII/RMII/MII interface.
+          Say Y if you want it compiled into the kernel. To compile this
+          driver as a module, choose M here.
+choice
+	depends on STE101P
+        prompt "Media Indipendent Interface mode"
+        default MII_INTERFACE
+
+config STE101P_MII
+        bool "MII interface"
+        depends on STE101P
+        help
+	  Support of MII protocol to interface the MAC with the MII-based PHY.
+
+config  STE101P_RMII
+        depends on STE101P
+        bool "RMII interface"
+        help
+	  Activated the Reduced Media Indipendent Interface (RMII).
+	  The Reduced Media Independent Interface (RMII) provides a low cost
+	  alternative to the IEEE 802.3u MII interface.
+
+endchoice
+
 endmenu
 
diff -Naur linux-2.6.17.8/drivers/net/phy/Makefile linux-2.6.17.8-sh/drivers/net/phy/Makefile
--- linux-2.6.17.8/drivers/net/phy/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/phy/Makefile	2006-08-23 13:29:48.714831000 +0100
@@ -8,3 +8,4 @@
 obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 obj-$(CONFIG_LXT_PHY)		+= lxt.o
 obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
+obj-$(CONFIG_STE101P)		+= ste101p.o
diff -Naur linux-2.6.17.8/drivers/net/phy/ste101p.c linux-2.6.17.8-sh/drivers/net/phy/ste101p.c
--- linux-2.6.17.8/drivers/net/phy/ste101p.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/phy/ste101p.c	2006-08-23 13:29:48.730830000 +0100
@@ -0,0 +1,552 @@
+/* ============================================================================
+ * This is a driver for the Ste101p PHY controller.
+ *
+ * Copyright (C) 2006 by  Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * ----------------------------------------------------------------------------
+ * Kernel Command line arguments:
+ *	- ste101p=device:<ethx>,addr:<phy_n>,flowctrl:<flowctrl>
+ *		where:
+ *		 - "device:<ethx>" is the ethernet device name (by default
+ *				   the "eth0" will be used),
+ *		 - "addr:<phy_n>" is STe101p PHY device address, by default the
+ *				  driver is able to detect it automatically.
+ *		 - "flowctrl:<flowctrl>: it enables/disables the flow-control.
+ *		 NOTE: you must use the , as delimiter.
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   May 2006
+ *	- It's indipendend from the STb7109eth driver.
+ *   April 2006 (first release of the driver):
+ *	- Added the RMII interface support.
+ * 	- The driver has been tested, on the MB411 platform with the DB666
+ * 	  daughter board, using:
+ *		- the clock through the STPIO3[7],
+ *		- the clock through an external clock generator device.
+ *	- Added the "fix_mac_speed" function: it is used for changing
+ *	  the MAC speed field in the SYS_CFG7 register.
+ *	  (required when we are using the RMII interface).
+ *
+ * ----------------------------------------------------------------------------
+ * Known bugs:
+ * 	The SMII mode is not supported yet.
+ * ===========================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+
+#define DEFAULT_PHY_ID  0
+#define RESOURCE_NAME	"ste101p"
+
+#define MII_XCNTL   	0x10 /* 100BaseX Auxiliary Control Register */
+#define MII_XCIIS   	0x11 /* Configuration Info IRQ & Status Reg*/
+#define MII_XIE     	0x12 /* Interrupt Enable Register*/
+#define MII_XMC     	0x14 /* Mode Control Register*/
+#define MII_RSVRD   	0x15 /* Private test register*/
+#define MII_RSRVD   	0x16 /* Private test register*/
+#define MII_PTEST   	0x17 /* Private test register*/
+#define MII_AUXCS   	0x18 /* Auxiliary Control/Status Register*/
+#define MII_AUXSS   	0x19 /* AuxiliaryStatus Summary Register*/
+#define MII_INRPT   	0x1a /* Interrupt Register*/
+#define MII_AUXM2  	0x1b /* Auxiliary Mode 2 Register*/
+#define MII_TSTAT   	0x1c /* Auxiliary Error and General Status Reg */
+#define MII_AUXMD   	0x1d /* Auxiliary Mode Register*/
+#define MII_AMPHY   	0x1e /* Auxiliary PHY Register*/
+#define MII_BTEST   	0x1f /* Shadow register enable*/
+
+/* STE101P Configuration Information Interrupt & Status register */
+#define MII_XCIIS_FIFO_OVERRUN          0x0800
+#define MII_XCIIS_SPEED                 0x0200
+#define MII_XCIIS_DUPLEX                0x0100
+#define MII_XCIIS_PAUSE                 0x0080
+#define MII_XCIIS_ANE	 		0x0040
+#define MII_XCIIS_REMOTE_FAULT_INT      0x0020
+#define MII_XCIIS_LINK_DOWN 	        0x0010
+#define MII_XCIIS_AUTONEGO_ACK_INT      0x0008
+#define MII_XCIIS_PARALL_DETECT_INT     0x0004
+#define MII_XCIIS_AUTONEGO_PAGE_INT     0x0002
+#define MII_XCIIS_RX_ERROR_BUFFER_INT   0x0001
+#define MII_XIE_DEFAULT_MASK 0x0070 /* ANE complete, Remote Fault, Link Down */
+
+/* STE101P phy identifier values */
+#define STE101P_PHY_HI_ID	0x0006
+#define STE101P_PHY_LO_ID_REVA	0x1c51
+#define STE101P_PHY_LO_ID_REVB	0x1c52
+
+/* MII mode */
+#define MII_TSTAT_SMII	0x1000
+#define MII_TSTAT_RMII  0x0800
+#define MII_TSTAT_MII   0x0400
+#define MII_ADVERTISE_PAUSE 0x0400 /* supports the pause command */
+
+static char user_dev_name[IFNAMSIZ] __initdata = { 0, };
+
+struct phy_driver_local {
+	struct mii_if_info mii;
+	struct net_device *dev;
+	unsigned int phy_type;
+	unsigned int speed;
+	unsigned int irq;
+	u16 irq_status;
+	struct work_struct phy_queue;
+};
+
+/* Module Arguments */
+static int phy_n = -1;
+module_param(phy_n, int, S_IRUGO);
+MODULE_PARM_DESC(phy_n, "Physical Device Number");
+
+static int flowctrl=0;
+module_param(flowctrl, int, 0);
+MODULE_PARM_DESC(flowctrl, "flow control [0|1]");
+
+/* MII external functions */
+extern void stb7109eth_set_mac_mii_cap(struct mii_if_info mii, unsigned int speed,
+				       struct net_device *dev);
+extern int stb7109_mii_read (struct net_device *dev, int phyaddr, int phyreg);
+extern void stb7109_mii_write(struct net_device *dev, int phyaddr, int phyreg,
+                              int phydata);
+
+/* ----------------------------------------------------------------------------
+			STe101p functions
+   ---------------------------------------------------------------------------*/
+static int ste101p_restart_ane (struct phy_driver_local *phydev)
+{
+	u16 value;
+	int ret = 0, i = 100000;
+
+	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
+	/* NOTE: writing the PR00[12] has not effect when the ANE
+	 * has been disabled by HW control. */
+	value |= (BMCR_ANRESTART | AUTONEG_ENABLE);
+	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR, value);
+
+	/*  waiting for autonegotiation complete */
+        while( i-- > 0 ) {
+                value=stb7109_mii_read(phydev->dev,phydev->mii.phy_id,MII_BMSR);
+                /* STE101P: MII status reg bit n. 5 */
+                if ((value & BMSR_ANEGCOMPLETE) != 0) {
+			ret = 1;
+                        break;
+                }
+        }
+	return (ret);
+}
+
+static void dump_ste101p_registers (unsigned int n_column,
+		struct phy_driver_local *phydev)
+{
+	int i, /* phy device count */
+	    j  /* phy regs count */,
+	    pr_number = 32;
+
+	printk (KERN_DEBUG "\t STE101P registers \n");
+
+	for (i=0;i<pr_number;i++) {
+		j = 0;
+		printk (KERN_DEBUG "\tPHY device #%d\n", i);
+		while(j < 32) {
+			int k;
+			u16 tmp;
+			for (k=0;k<n_column;k++) {
+				if ( ((j+k) < 9) ||
+				     ( ((j+k) > 10)  && ((j+k) < 13) ) ||
+				     ( ((j+k) > 15)  && ((j+k) < 32) ) ) {
+				   tmp=stb7109_mii_read(phydev->dev, i, j+k);
+				   printk (KERN_DEBUG"\t PR%x: 0x%x", j+k, tmp);
+				}
+			}
+			printk(KERN_DEBUG "\n");
+			j += n_column;
+		}
+	}
+}
+
+static void ste101p_reset_phy(struct phy_driver_local *phydev)
+{
+	u16 value;
+
+	/* When the bit 15 of the register PR00 is set to 1 the STE101P'll
+         * reset entire circuits (a software reset should only take 1ms),
+	 * then clear the  bit 15 of the register PR00 and set the RIP
+	 * output pin 29 to logic 1.  */
+	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
+	value |= BMCR_RESET;
+	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR, value);
+
+	printk(KERN_DEBUG "STe101P: waiting the STE101P reset completition...");
+	do{
+		value=stb7109_mii_read(phydev->dev,phydev->mii.phy_id,MII_BMCR);
+	} while (value & BMCR_RESET);
+
+	printk(KERN_DEBUG " done!\n");
+
+	return;
+}
+
+/* Automatically gets and returns the PHY device */
+static unsigned int ste101p_get_phys_addr(struct phy_driver_local *phydev)
+{
+	int phyaddr;
+
+	for (phyaddr=0; phyaddr<32; phyaddr++) {
+		unsigned int id1, id2;
+		id1 = stb7109_mii_read(phydev->dev, phyaddr, MII_PHYSID1);
+		id2 = stb7109_mii_read(phydev->dev, phyaddr, MII_PHYSID2);
+
+                /* Make sure it is a valid identifier */
+                if ((id1==STE101P_PHY_HI_ID) &&
+			((id2 == STE101P_PHY_LO_ID_REVB) ||
+			 (id2 == STE101P_PHY_LO_ID_REVA))) {
+                        /* Save the PHY's address */
+                        phydev->phy_type = id1 << 16 | id2;
+                        return (phyaddr);
+		}
+	}
+	return (-1);
+}
+
+/* It should be used for setting an user PHY address */
+static void ste101p_set_phy_addr(struct phy_driver_local *phydev)
+{
+	u16 value;
+
+	/* Read the XMC register */
+        value=stb7109_mii_read(phydev->dev, DEFAULT_PHY_ID, MII_XMC);
+	/* Set the PHY address */
+	value |= (phydev->mii.phy_id << 3) & 0x00f8;
+	stb7109_mii_write(phydev->dev, DEFAULT_PHY_ID, MII_XMC, value);
+	return;
+}
+
+/* Power down the specified PHY: Power down can be exited by cleaning
+ * bit PR00[11] or by HW/SW reset. */
+void ste101p_powerdown(struct phy_driver_local *phydev)
+{
+
+        u16 bmcr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
+	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_BMCR,
+			  (bmcr|BMCR_PDOWN));
+
+	return;
+}
+
+static void ste101p_change(void *data)
+{
+	struct phy_driver_local *phydev = (struct  phy_driver_local *) data;
+	u16 value = phydev->irq_status;
+
+	/* Check if auto negotiation caused interrupt */
+	if (value & MII_XCIIS_ANE) { /* ANE Interrupt completed */
+
+		if (!(value & MII_XCIIS_DUPLEX)) { /* Half Duplex */
+			phydev->mii.full_duplex = 0;
+		} else {  /* Full Duplex */
+			phydev->mii.full_duplex = 1;
+		}
+
+		if (!(value & MII_XCIIS_SPEED)) {
+			phydev->speed = SPEED_10;
+		} else {
+			phydev->speed = SPEED_100;
+		}
+
+		/* we need to set the new speed and duplex values in the MAC
+		   interface*/
+		stb7109eth_set_mac_mii_cap(phydev->mii, phydev->speed,
+					   phydev->dev);
+
+		printk(KERN_INFO "%s: %s duplex, Link speed: 10%s Mbit/s"
+			  "%s\n", phydev->dev->name,
+			  (phydev->mii.full_duplex) ? "Full" : "Half",
+			  (phydev->speed == SPEED_100)  ? "0" : "",
+			  ((value & MII_XCIIS_PAUSE) &&
+			  (value & MII_XCIIS_DUPLEX)) ? ", Flow-control" : "");
+	}
+
+	/* The remote fault indicates to a link partner that a fault condition
+	 * has occurred so we need to re-start the ANE process. */
+	if (value & MII_XCIIS_REMOTE_FAULT_INT){
+		value = ste101p_restart_ane(phydev);
+		printk(KERN_INFO  "%s: auto-negotation Completed: %s\n",
+				phydev->dev->name, value ? "yes": "no");
+	}
+
+	mii_check_link (&phydev->mii);
+
+	return;
+}
+
+/* Interrupt handler for the MII.
+ * When a PHY interrupt occurs, the handler clear the
+ * interrupt and schedules a work task. */
+static irqreturn_t ste101p_interrupt(int irq, void *phy_dat,
+				     struct pt_regs *regs)
+{
+	u16 bmcr, bmsr;
+	struct phy_driver_local *phydev = (struct  phy_driver_local *)phy_dat;
+
+	/* Read the R/O Auxiliary Status register (PR11)
+	 * and clear the relative "interrupt/pending" bits */
+	phydev->irq_status = stb7109_mii_read(phydev->dev,phydev->mii.phy_id,
+					      MII_XCIIS);
+
+	bmcr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMCR);
+	bmsr = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMSR);
+
+	printk(KERN_DEBUG "ste101p IRQ handler: MII_XCIIS=0x%x, "
+	      "MII_BMCR=0x%x, MII_BMSR=0x%x\n", phydev->irq_status, bmcr, bmsr);
+
+        schedule_work(&phydev->phy_queue);
+
+        return IRQ_HANDLED;
+}
+
+static int ste101p_start_interrupt(struct phy_driver_local *phydev)
+{
+	int ret;
+
+	INIT_WORK(&phydev->phy_queue, ste101p_change, phydev);
+
+	/* Request the IRQ line*/
+        if ( (ret = request_irq(phydev->irq, &ste101p_interrupt,
+				SA_INTERRUPT, RESOURCE_NAME, phydev)) < 0 ) {
+		printk(KERN_ERR "%s: ERROR: allocating the ste101p IRQ %d "
+				"(return error: %d)\n", __FUNCTION__,
+				phydev->irq, ret);
+		return (ret);
+	}
+
+	/* Enable all STe101P interrupts (PR12) */
+	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_XIE,
+			  MII_XIE_DEFAULT_MASK);
+
+	/* clear any pending interrupts */
+	stb7109_mii_read(phydev->dev,phydev->mii.phy_id, MII_XCIIS);
+
+	return (ret);
+
+}
+
+static int ste101p_init_config(struct phy_driver_local *phydev)
+{
+	u16 value;
+	u16 advertised_caps;
+
+	unsigned int phy_valid;
+#ifdef CONFIG_STE101P_RMII
+        char *mii_mode = "RMII mode";
+#else
+        char *mii_mode = "MII mode";
+#endif
+	phy_valid = ste101p_get_phys_addr(phydev);
+	if (phy_valid < 0) {
+		/* If the auto detection process fails we can try to
+		use a default value. */
+		phy_valid = DEFAULT_PHY_ID;
+		printk(KERN_WARNING "STe101P: auto-detection failed!\n");
+	}
+	phydev->mii.phy_id = phy_valid;
+
+	/* Software Reset */
+	ste101p_reset_phy(phydev);
+
+	/* We must write the new phy address in the XCVR Mode Control Register
+	 * (bits [7-3]).
+	 * NOTE: we need a SW reset with the default value before setting the
+		 new address. */
+	if ((phy_n >=0) && (phy_n <= 31)) {
+		phydev->mii.phy_id = phy_n;
+		ste101p_set_phy_addr(phydev);
+	}
+
+	printk(KERN_INFO "STe101P Revision %s (%s) - device address: %d\n",
+	      (((stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_PHYSID2))
+	      & 0xffff) == STE101P_PHY_LO_ID_REVB) ? "B" : "A",
+	      mii_mode, phydev->mii.phy_id);
+
+#if 0
+	/* Extend the squelch levels for the detection of incoming
+	   data packets. */
+	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_AUXCS);
+	stb7109_mii_write(phydev->dev,phydev->mii.phy_id,
+			  MII_AUXCS, (value | 0xc0));
+#endif
+
+	/* Read the ANE Advertisement register */
+	advertised_caps = stb7109_mii_read(phydev->dev, phydev->mii.phy_id,
+					   MII_ADVERTISE);
+
+	/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
+	value = stb7109_mii_read(phydev->dev, phydev->mii.phy_id, MII_BMSR);
+
+	/* Set the advertised capabilities */
+	if (value & BMSR_100BASE4)
+                advertised_caps |= ADVERTISE_100BASE4;
+        if (value & BMSR_100FULL)
+                advertised_caps |= ADVERTISE_100FULL;
+        if (value & BMSR_100HALF)
+                advertised_caps |= ADVERTISE_100HALF;
+        if (value & BMSR_10FULL)
+                advertised_caps |= ADVERTISE_10FULL;
+        if (value & BMSR_10HALF)
+                advertised_caps |= ADVERTISE_10HALF;
+
+	/* If flow control enabled, we need to advertise it. */
+	if (flowctrl)
+                advertised_caps |= MII_ADVERTISE_PAUSE;
+	else
+		advertised_caps &= ~MII_ADVERTISE_PAUSE;
+
+	/* Update our Auto-Neg Advertisement Register */
+	phydev->mii.advertising = advertised_caps;
+	stb7109_mii_write(phydev->dev, phydev->mii.phy_id, MII_ADVERTISE,
+			  advertised_caps);
+
+	/* Request and start the interrupt */
+	ste101p_start_interrupt(phydev);
+
+	/* Restart auto-negotiation process in order to advertise my caps;
+	 * NOTE: in any case, in during the STe101p interrupt routine the ANE
+	 * Advertisement Register will be updated with the actual parameters*/
+	value = ste101p_restart_ane(phydev);
+	phydev->mii.force_media = 1; /* ANE */
+	printk(KERN_INFO "%s: auto-negotation Completed: %s\n",
+		phydev->dev->name, value ? "yes": "no");
+
+	/* verify the link status */
+        printk(KERN_INFO "%s: check link...", phydev->dev->name);
+        if (!mii_link_ok(&phydev->mii)) {
+                printk(KERN_INFO "failed!\n");
+                netif_carrier_off(phydev->dev);
+        } else {
+                printk(KERN_INFO "done!\n");
+                netif_carrier_on(phydev->dev);
+        }
+
+	dump_ste101p_registers(3, phydev);
+
+	return (0);
+}
+
+/* --------------------------------------------------------------------------
+ * 		Parse the optional command line arguments
+ * --------------------------------------------------------------------------*/
+static int __init ste101p_parse_option(char *str)
+{
+	char* opt;
+
+	if (!str || !*str)
+		return -EINVAL;
+
+	while ((opt=strsep(&str, ",")) != NULL) {
+                if (! strncmp(opt, "device:", 7)) {
+                        strlcpy(user_dev_name, opt+7, sizeof(user_dev_name));
+                }
+                else if (! strncmp(opt, "addr:", 5)) {
+                        phy_n = simple_strtoul(opt+5, NULL, 0);
+                }
+                else if (! strncmp(opt, "flowctrl:", 9)) {
+                         flowctrl = simple_strtoul(opt+9, NULL, 0);
+                }
+        }
+
+	printk(KERN_DEBUG "%s: device name %s, phy addr=%d, flowctrl=%s\n",
+                          RESOURCE_NAME, user_dev_name, phy_n,
+			  (flowctrl)?"enabled":"disabled");
+
+        return (0);
+}
+__setup("ste101p=", ste101p_parse_option);
+
+/* ----------------------------------------------------------------------------
+	           DEVICE registration and unloading
+   ---------------------------------------------------------------------------*/
+static int ste101p_drv_remove(struct device *dev)
+{
+	struct phy_driver_local *phydev=dev_get_drvdata(dev);
+
+	free_irq(phydev->irq, phydev);
+
+        kfree(phydev);
+        return (0);
+}
+
+static int ste101p_drv_probe(struct device *dev)
+{
+	struct net_device *ndev;
+	struct phy_driver_local *phydev;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	phydev = kmalloc(sizeof(struct phy_driver_local), GFP_KERNEL);
+
+	/* Get the IRQ number */
+        if ((phydev->irq = platform_get_irq(pdev,0)) == 0){
+                printk(KERN_ERR "%s: ERROR: IRQ configuration "
+                                "information not found\n",__FUNCTION__);
+		return (-ENODEV);
+        }
+	printk(KERN_DEBUG " IRQ #%d\n", phydev->irq);
+
+	if (!strcmp(user_dev_name, "")) {
+		strcpy(user_dev_name, "eth0");
+		printk (KERN_DEBUG "STe101P: omitting the \"device\" "
+			"parameter in the cmdline... it will try with %s\n",
+			user_dev_name);
+	}
+
+	/* Get the ETH driver by name */
+	ndev = __dev_get_by_name(user_dev_name);
+        if (!ndev) {
+                printk(KERN_ERR "%s: ERROR: network %s device not found\n",
+				__FUNCTION__, user_dev_name);
+                return (-1);
+        }
+	printk(KERN_DEBUG "network device (%s) found at address 0x%x\n",
+				ndev->name, (unsigned int)ndev);
+	phydev->dev = ndev;
+	phydev->mii.dev = ndev;
+	phydev->mii.mdio_read = stb7109_mii_read;
+	phydev->mii.mdio_write = stb7109_mii_write;
+	dev_set_drvdata(dev, phydev);
+
+	/* Init the PHY device */
+	ste101p_init_config(phydev);
+
+	return (0);
+}
+
+static struct device_driver ste101p_driver = {
+        .name           = RESOURCE_NAME,
+	.bus            = &platform_bus_type,
+        .probe          = ste101p_drv_probe,
+	.remove		= ste101p_drv_remove,
+};
+
+static int __init ste101p_init(void)
+{
+        printk(KERN_DEBUG "%s: register the device driver...", __FUNCTION__);
+        return driver_register(&ste101p_driver);
+}
+
+static void __exit ste101p_exit(void)
+{
+        printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
+        driver_unregister(&ste101p_driver);
+}
+
+module_init(ste101p_init);
+module_exit(ste101p_exit);
+
+MODULE_DESCRIPTION("STe101p driver");
+MODULE_AUTHOR("Giuseppe Cavallaro");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/net/smc91x.c linux-2.6.17.8-sh/drivers/net/smc91x.c
--- linux-2.6.17.8/drivers/net/smc91x.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smc91x.c	2006-08-23 13:29:48.525830000 +0100
@@ -1740,6 +1740,140 @@
 	lp->msg_enable = level;
 }
 
+static int smc_ethtool_get_eeprom_len(struct net_device *dev)
+{
+	return EEPROM_SIZE;
+}
+
+static int smc_eeprom_rw(struct net_device *dev, int offset, u16* val,
+			 int write)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long endtime;
+	unsigned long ioaddr = dev->base_addr;
+	int res = 0;
+	unsigned int ctl;
+	unsigned int cmd = write ? CTL_STORE : CTL_RELOAD;
+
+	spin_lock_irq(&lp->lock);
+
+	/* We want RELOAD operations to affect the GP */
+	SMC_SELECT_BANK(1);
+	ctl = SMC_GET_CTL();
+	SMC_SET_CTL(ctl | CTL_EEPROM_SELECT);
+
+	/* Set the address */
+	SMC_SELECT_BANK(2);
+	SMC_SET_PTR(offset);
+
+	SMC_SELECT_BANK(1);
+
+	if (write) {
+		SMC_outw(*val, ioaddr, GP_REG);
+	}
+
+	/* Trigger read or write */
+	SMC_SET_CTL(ctl | CTL_EEPROM_SELECT | cmd);
+
+	/* Wait for completion of read or write */
+	endtime = jiffies + (HZ/10);
+	do {
+		if (time_after(jiffies, endtime)) {
+			printk(KERN_WARNING "%s: Failed to read EEPROM\n", dev->name);
+			res = -EFAULT;
+			goto out;
+		}
+	} while (SMC_GET_CTL() & cmd);
+
+	if (! write) {
+		*val = SMC_inw(ioaddr, GP_REG);
+	}
+
+out:
+	/* Restore Control Register */
+	SMC_SET_CTL(ctl);
+	SMC_SELECT_BANK(2);
+
+	spin_unlock_irq(&lp->lock);
+	return res;
+}
+
+static int smc_ethtool_geteeprom(struct net_device *dev,
+        struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	int res;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset + len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		*bytes++ = tmp >> 8;
+		offset++;
+		len--;
+	}
+
+	for ( ; len > 1; len -= 2) {
+		res = smc_eeprom_rw(dev, offset >> 1, (u16*)bytes, 0);
+		if (res) return res;
+		bytes += 2;
+		offset += 2;
+	}
+
+	if (len > 0) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		*bytes = tmp & 0xff;
+	}
+
+	return 0;
+}
+
+static int smc_ethtool_seteeprom(struct net_device *dev,
+	struct ethtool_eeprom *eeprom, u8 *bytes)
+{
+	int res;
+	u16 tmp;
+	unsigned int offset = eeprom->offset;
+	unsigned int len = eeprom->len;
+
+	if (offset + len > EEPROM_SIZE) {
+		return -EINVAL;
+	}
+
+	if (offset & 1) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		tmp = (*bytes++ << 8) | (tmp & 0xff);
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 1);
+		if (res) return res;
+		offset++;
+		len--;
+	}
+
+	for ( ; len > 1; len -= 2) {
+		res = smc_eeprom_rw(dev, offset >> 1, (u16*)bytes, 1);
+		if (res) return res;
+		bytes += 2;
+		offset += 2;
+	}
+
+	if (len > 0) {
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 0);
+		if (res) return res;
+		tmp = (tmp & 0xff00) | (*bytes);
+		res = smc_eeprom_rw(dev, offset >> 1, &tmp, 1);
+		if (res) return res;
+	}
+
+	return 0;
+}
+
 static struct ethtool_ops smc_ethtool_ops = {
 	.get_settings	= smc_ethtool_getsettings,
 	.set_settings	= smc_ethtool_setsettings,
@@ -1749,8 +1883,9 @@
 	.set_msglevel	= smc_ethtool_setmsglevel,
 	.nway_reset	= smc_ethtool_nwayreset,
 	.get_link	= ethtool_op_get_link,
-//	.get_eeprom	= smc_ethtool_geteeprom,
-//	.set_eeprom	= smc_ethtool_seteeprom,
+	.get_eeprom_len	= smc_ethtool_get_eeprom_len,
+	.get_eeprom	= smc_ethtool_geteeprom,
+	.set_eeprom	= smc_ethtool_seteeprom,
 };
 
 /*
@@ -2029,15 +2164,14 @@
 		printk("%s%s\n", nowait ? " [nowait]" : "",
 			THROTTLE_TX_PKTS ? " [throttle_tx]" : "");
 
+		/* Print the Ethernet address */
+		printk("%s: Ethernet addr: ", dev->name);
+		for (i = 0; i < 5; i++)
+			printk("%2.2x:", dev->dev_addr[i]);
+		printk("%2.2x\n", dev->dev_addr[5]);
 		if (!is_valid_ether_addr(dev->dev_addr)) {
 			printk("%s: Invalid ethernet MAC address.  Please "
 			       "set using ifconfig\n", dev->name);
-		} else {
-			/* Print the Ethernet address */
-			printk("%s: Ethernet addr: ", dev->name);
-			for (i = 0; i < 5; i++)
-				printk("%2.2x:", dev->dev_addr[i]);
-			printk("%2.2x\n", dev->dev_addr[5]);
 		}
 
 		if (lp->phy_type == 0) {
diff -Naur linux-2.6.17.8/drivers/net/smc91x.h linux-2.6.17.8-sh/drivers/net/smc91x.h
--- linux-2.6.17.8/drivers/net/smc91x.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smc91x.h	2006-08-23 13:29:43.043691000 +0100
@@ -211,6 +211,129 @@
 
 #define SMC_IRQ_FLAGS		(0)
 
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
+
+#if defined(CONFIG_SH_STI5528_EVAL)
+/* 32 bit SMC91C111 STEM card. Needs A0-1 unmodified, A2- shifted up 1 */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	1
+#define SMC_CAN_USE_32BIT_DATA	0
+#define SMC_IO_SHIFT		1
+#define SMC_STEM_BS_MASK	7
+#elif defined(CONFIG_SH_STI5528_ESPRESSO)
+/* 32 bit on board SMC91C111. No address shifting required.
+* However, SMC91C111 notWE is driven by notBE0, so can only write if
+* bottom byte in 32 bit word is being written to. */
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_CAN_USE_32BIT_DATA	1
+#define SMC_IO_SHIFT		0
+#elif defined(CONFIG_SH_STM8000_DEMO)
+/* 16 bit SMC91C111 STEM card. Needs A0 unmodified, A1- shifted up. */
+/* NB Need to modify STEM card according to ADCS 7535866. */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_CAN_USE_32BIT_DATA	1
+#define SMC_IO_SHIFT		1
+#define SMC_STEM_BS_MASK	3
+#elif defined(CONFIG_SH_ST220_EVAL)
+/* 16 bit on board SMC91C111. No address shifting required.
+ * Note we can't set SMC_CAN_USE_32BIT. This would causes SMC_SELECT_BANK
+ * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
+ * This bypasses the special logic which would prevent this also updating
+ * this interrupt mask register. */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_CAN_USE_32BIT_DATA	1
+#define SMC_IO_SHIFT		0
+#elif defined(CONFIG_SH_STB7100_MBOARD) || \
+      defined(CONFIG_SH_STB7100_REF) || \
+      defined(CONFIG_SH_STB7109E_REF)
+/* 16 bit on board SMC91C111. No address shifting required.
+ * Note we can't set SMC_CAN_USE_32BIT. This would causes SMC_SELECT_BANK
+ * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
+ * This bypasses the special logic which would prevent this also updating
+ * this interrupt mask register. */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_CAN_USE_32BIT_DATA	1
+#define SMC_IO_SHIFT		0
+#else
+#error Undefined
+#endif
+
+#define SMC_NOWAIT		0
+#undef  SMC_USE_PXA_DMA
+
+#ifdef SMC_STEM_BS_MASK
+/*
+ * We have to shift all addresses up by 1, because the STEM
+ * module connects A2 from the CPU to to A1 on the SMC device.
+ * This was done for compatibility with the ST20 EMI, which
+ * apparently does the opposite.
+ * However the byte strobes are not shifted in hardware, so
+ * these need to be left in place.
+ */
+#define REG_OFFSET(base,reg) ({                         		\
+        u_int __reg = (reg);                            		\
+        __reg = ( (__reg & (~SMC_STEM_BS_MASK))                 ) |	\
+                ( (__reg & ( SMC_STEM_BS_MASK)) >> SMC_IO_SHIFT );	\
+	(void __iomem *)((base) + __reg); })
+#else
+#define REG_OFFSET(base,reg) ((void __iomem*)((base) + (reg)))
+#endif
+
+#define dprintk(str, ...) // printk(str, ## __VA_ARGS__)
+#define SMC_inb(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = readb(_p); dprintk("SMC_inb(%08p) = %02x\n", _p, _v); _v; })
+#define SMC_inw(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = readw(_p); dprintk("SMC_inw(%08p) = %04x\n", _p, _v); _v; })
+#define SMC_inl(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = readl(_p); dprintk("SMC_inl(%08p) = %08x\n", _p, _v); _v; })
+#define SMC_outb(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = (v);  dprintk("SMC_outb(%02x, %08p)\n", _v, _p); writeb(_v, _p); })
+#define SMC_outw(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = (v);  dprintk("SMC_outw(%04x, %08p)\n", _v, _p); writew(_v, _p); })
+#define SMC_outl(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = (v);  dprintk("SMC_outl(%08x, %08p)\n", _v, _p); writel(_v, _p); })
+#define SMC_insl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); readsl(_p, p, l); })
+#define SMC_outsl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); writesl(_p, p, l); })
+
+#define set_irq_type(irq, type)
+
+#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
+#define RPC_LSB_DEFAULT		RPC_LED_100_10
+
+#elif	defined(CONFIG_ISA)
+
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+
+#define SMC_inb(a, r)		inb((a) + (r))
+#define SMC_inw(a, r)		inw((a) + (r))
+#define SMC_outb(v, a, r)	outb(v, (a) + (r))
+#define SMC_outw(v, a, r)	outw(v, (a) + (r))
+#define SMC_insw(a, r, p, l)	insw((a) + (r), p, l)
+#define SMC_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#elif   defined(CONFIG_M32R)
+
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+
+#define SMC_inb(a, r)		inb((a) + (r) - 0xa0000000)
+#define SMC_inw(a, r)		inw((a) + (r) - 0xa0000000)
+#define SMC_outb(v, a, r)	outb(v, (a) + (r) - 0xa0000000)
+#define SMC_outw(v, a, r)	outw(v, (a) + (r) - 0xa0000000)
+#define SMC_insw(a, r, p, l)	insw((a) + (r) - 0xa0000000, p, l)
+#define SMC_outsw(a, r, p, l)	outsw((a) + (r) - 0xa0000000, p, l)
+
+#define set_irq_type(irq, type)	do {} while(0)
+
+#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
+#define RPC_LSB_DEFAULT		RPC_LED_100_10
+
 #elif	defined(CONFIG_ISA)
 
 #define SMC_CAN_USE_8BIT	1
@@ -447,7 +570,7 @@
  * use of them.
  */
 
-#if ! SMC_CAN_USE_32BIT
+#if ! (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA)
 #define SMC_inl(ioaddr, reg)		({ BUG(); 0; })
 #define SMC_outl(x, ioaddr, reg)	BUG()
 #define SMC_insl(a, r, p, l)		BUG()
@@ -884,6 +1007,11 @@
 
 #define ATTRIB_SIZE		((64*1024) << SMC_IO_SHIFT)
 
+/*
+ . EEPROM defintions
+ */
+#define EEPROM_SIZE		(64*2)	/* 64 x 16 bit words */
+
 
 /*
  * Macros to abstract register access according to the data bus
@@ -1103,7 +1231,7 @@
 
 #define SMC_PUSH_DATA(p, l)						\
 	do {								\
-		if (SMC_CAN_USE_32BIT) {				\
+		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
 			void *__ioaddr = ioaddr;			\
@@ -1127,7 +1255,7 @@
 
 #define SMC_PULL_DATA(p, l)						\
 	do {								\
-		if (SMC_CAN_USE_32BIT) {				\
+		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
 			void *__ioaddr = ioaddr;			\
@@ -1159,4 +1287,21 @@
 			SMC_insb(ioaddr, DATA_REG, p, l);		\
 	} while (0)
 
+#if defined(CONFIG_SH_STI5528_ESPRESSO)
+/*
+ * The Espresso doesn't appear to correctly connect the SMSC's ARDY pin
+ * to the 5528's WAIT pin. The only time this has been observed to be a
+ * problem is after setting the pointer register there may be insufficient
+ * delay before reading from the FIFO. Insert a delay here.
+ */
+#undef SMC_SET_PTR
+#define SMC_SET_PTR(x)							\
+	do {								\
+		unsigned int __val16 = (x);				\
+		SMC_outw( __val16, ioaddr, PTR_REG );			\
+		if (__val16 & PTR_READ)					\
+			ndelay(370);					\
+	} while (0)
+#endif
+
 #endif  /* _SMC91X_H_ */
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/cmd911x.c linux-2.6.17.8-sh/drivers/net/smsc_911x/cmd911x.c
--- linux-2.6.17.8/drivers/net/smsc_911x/cmd911x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/cmd911x.c	2006-08-23 13:29:37.652576000 +0100
@@ -0,0 +1,1576 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: cmd911x.c
+ */
+#ifdef USING_LINT
+#include "lint.h"
+#else //not USING_LINT
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <linux/delay.h>
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <net/if.h>
+
+#include <sys/ioctl.h>
+#include <net/if_arp.h>
+#include <arpa/inet.h>
+#endif //not USING_LINT
+
+#include "ioctl_11x.h"
+
+char *iam=NULL;
+
+typedef enum _bool {
+  false=0,
+  true=1
+} bool;
+
+typedef struct _COMMAND_DATA {
+	int hSockFD;
+	struct ifreq IfReq;
+	SMSC911x_IOCTL_DATA IoctlData;
+} COMMAND_DATA, *PCOMMAND_DATA;
+
+#define SOCKET	int
+#define INVALID_SOCKET	(-1)
+#define SOCKET_ERROR	(-1)
+#define DEFAULT_PORT_NUMBER		(11118U)
+SOCKET server_sock=INVALID_SOCKET;
+
+typedef struct _FLOW_PARAMS
+{
+    unsigned long MeasuredMaxThroughput;
+	unsigned long MeasuredMaxPacketCount;
+	unsigned long MaxThroughput;
+	unsigned long MaxPacketCount;
+	unsigned long PacketCost;
+	unsigned long BurstPeriod;
+	unsigned long MaxWorkLoad;
+	unsigned long IntDeas;
+} FLOW_PARAMS, * PFLOW_PARAMS;
+
+bool ParseNumber(const char *str,unsigned long *number);
+void DisplayUsage(void);
+void GetMacAddress(PCOMMAND_DATA commandData);
+void SetMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl);
+void LoadMacAddress(PCOMMAND_DATA commandData);
+void SaveMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl);
+void LanDumpRegs(PCOMMAND_DATA commandData);
+void MacDumpRegs(PCOMMAND_DATA commandData);
+void DumpEEPROM(PCOMMAND_DATA commandData);
+void DumpTemp(PCOMMAND_DATA commandData);
+void PhyDumpRegs(PCOMMAND_DATA commandData);
+void SetDebugMode(PCOMMAND_DATA commandData,
+				  unsigned long debug_mode);
+void SetLinkMode(PCOMMAND_DATA commandData,
+				 unsigned long link_mode);
+void SetPowerMode(PCOMMAND_DATA commandData,
+				  unsigned long power_mode);
+void GetLinkMode(PCOMMAND_DATA commandData);
+void CheckLink(PCOMMAND_DATA commandData);
+void GetPowerMode(PCOMMAND_DATA commandData);
+void GetFlowParams(PCOMMAND_DATA commandData);
+void GetConfiguration(PCOMMAND_DATA commandData);
+void ReadByte(PCOMMAND_DATA commandData,unsigned long address);
+void ReadWord(PCOMMAND_DATA commandData, unsigned long address);
+void ReadDWord(PCOMMAND_DATA commandData,unsigned long address);
+void WriteByte(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void WriteWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void WriteDWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data);
+void LanGetReg(PCOMMAND_DATA commandData,unsigned long address);
+void LanSetReg(PCOMMAND_DATA commandData, unsigned long address, unsigned long data);
+void MacGetReg(PCOMMAND_DATA commandData, unsigned long address);
+void MacSetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data);
+void PhyGetReg(PCOMMAND_DATA commandData, unsigned long address);
+void PhySetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data);
+bool Initialize(PCOMMAND_DATA commandData,const char *ethName);
+bool ReceiveULong(SOCKET sock,unsigned long * pDWord);
+bool SendULong(SOCKET sock,unsigned long data);
+void process_requests(PCOMMAND_DATA commandData);
+void RunServer(PCOMMAND_DATA commandData,unsigned short portNumber);
+bool ReceiveFlowParams(SOCKET sock,PFLOW_PARAMS flowParams);
+bool SendFlowParams(SOCKET sock,PFLOW_PARAMS flowParams);
+void DisplayFlowParams(PFLOW_PARAMS flowParams);
+unsigned long ReadThroughput(char * fileName);
+void RunTuner(const char *hostName,unsigned short portNum);
+
+
+bool ParseNumber(const char *str,unsigned long *number) {
+	if(str==NULL) return false;
+	if(str[0]==0) return false;
+	if((str[0]=='0')&&(str[1]=='x')) {
+		if(sscanf(&(str[2]),"%lx",number)==1) {
+			return true;
+		}
+	}
+	if(sscanf(str,"%ld",number)==1) {
+		return true;
+	}
+	return false;
+}
+
+void DisplayUsage(void) {
+	printf("usage: %s [-h] [-e adaptername] [-c command] [-a address] [-d data]\n",iam);
+	printf("       [-H host_address] [-p port_number]\n");
+	printf("  -h displays this usage information, other options ignored.\n");
+	printf("  -e specifies the adapter name (eth0,eth1...)\n");
+	printf("       if not specified then %s will attempt to\n",iam);
+	printf("       auto detect.\n");
+	printf("  -c specifies the command code\n");
+	printf("       SERVER = run in server mode\n");
+	printf("          may use -p to specify port to listen on\n");
+	printf("       TUNER = connects remotely to server to run\n");
+	printf("          automatic flow control tuning.\n");
+	printf("          use -H to specify host address\n");
+	printf("          use -p to specify port\n");
+	printf("       GET_CONFIG = gets internal variables of driver\n");
+	printf("       DUMP_REGS = dumps the LAN911x memory mapped registers\n");
+	printf("       DUMP_MAC = dumps the LAN911x MAC registers\n");
+	printf("       DUMP_PHY = dumps the LAN911x PHY registers\n");
+	printf("       DUMP_EEPROM = dumps the first 8 bytes of the EEPROM\n");
+	printf("       DUMP_TEMP = dumps temp data space used for debugging\n");
+	printf("       GET_MAC = gets MAC address from ADDRH and ADDRL\n");
+	printf("       SET_MAC = sets MAC address in ADDRH and ADDRL\n");
+	printf("         -a specifies the value to write to ADDRH\n");
+	printf("         -d specifies the value to write to ADDRL\n");
+	printf("       LOAD_MAC = causes the LAN911x to reload the MAC address\n");
+	printf("           from the external EEPROM. Also displays it\n");
+	printf("       SAVE_MAC = writes a MAC address to the EEPROM\n");
+	printf("         -a specifies the part of the MAC address that would\n");
+	printf("            appear in ADDRH\n");
+	printf("         -d specifies the part of the MAC address that would\n");
+	printf("            appear in ADDRL\n");
+	printf("       SET_DEBUG = sets the driver's internal debug_mode value\n");
+	printf("         -d specifies the debug mode\n");
+	printf("             0x01, bit 0, enables trace messages\n");
+	printf("             0x02, bit 1, enables warning messages\n");
+	printf("             0x04, bit 2, enables GPO signals\n");
+	printf("          NOTE: trace, and warning messages will only show if\n");
+	printf("             they have been turned on at driver compile time.\n");
+	printf("       SET_LINK = sets the driver's internal link_mode value\n");
+	printf("             and also attempts to relink with the new setting\n");
+	printf("         -d specifies the link mode\n");
+	printf("             1 = 10HD, 2 = 10FD, 4 = 100HD, 8 = 100FD\n");
+	printf("             to specify multiple link modes, add the values\n");
+	printf("             of each mode you want and use the sum as the link mode\n");
+	printf("       GET_LINK = gets the driver's internal link_mode value\n");
+	printf("     Warning!! Power management is not implemented as of version 0.54\n");
+	printf("       SET_POWER = sets the LAN911x power mode\n");
+	printf("         -d specifies the power state\n");
+	printf("             0 = D0, 1 = D1, 2 = D2, 3 = D3\n");
+	printf("       GET_POWER = gets the LAN911x power mode\n");
+	printf("       CHECK_LINK = causes the driver to recheck its link status\n");
+	printf("     Warning!! the following read and write commands may cause\n");
+	printf("     unpredictable results, including system lock up or crash.\n");
+	printf("     Use with caution\n");
+	printf("       READ_REG = reads a value from the LAN911x Memory Map\n");
+	printf("         -a specifies offset into LAN911x Memory Map\n");
+	printf("       WRITE_REG = writes a value to the LAN911x Memory Map\n");
+	printf("         -a specifies offset into LAN911x Memory Map\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_MAC = reads a value from the LAN911x Mac registers\n");
+	printf("         -a specifies the Mac register index\n");
+	printf("       WRITE_MAC = writes a value to the LAN911x Mac registers\n");
+	printf("         -a specifies the Mac register index\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_PHY = reads a value from the LAN911x Phy registers\n");
+	printf("         -a specifies the Phy register index\n");
+	printf("       WRITE_PHY = writes a value to the LAN911x Phy registers\n");
+	printf("         -a specifies the Phy register index\n");
+	printf("         -d specifies data to write in HEX form\n");
+	printf("       READ_BYTE = reads a byte from a location in memory\n");
+	printf("         -a address\n");
+	printf("       READ_WORD = reads a word from a location in memory\n");
+	printf("         -a address\n");
+	printf("       READ_DWORD = reads a dword from a location in memory\n");
+	printf("         -a address\n");
+	printf("       WRITE_BYTE = write a byte to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("       WRITE_WORD = write a word to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("       WRITE_DWORD = write a dword to a location in memory\n");
+	printf("         -a address -d data\n");
+	printf("  -a specifies the address, index, or offset of a register\n");
+	printf("  -d specifies the data to write to a register\n");
+	printf("       can be decimal or hexadecimal\n");
+}
+
+void GetMacAddress(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_MAC_ADDRESS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Mac Address == 0x%04lX%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Get Mac Address\n");
+	}
+}
+void SetMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SET_MAC_ADDRESS;
+	commandData->IoctlData.Data[0]=addrh;
+	commandData->IoctlData.Data[1]=addrl;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Set Mac Address\n");
+	}
+}
+void LoadMacAddress(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LOAD_MAC_ADDRESS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Mac Address == 0x%04lX%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Load Mac Address\n");
+	}
+}
+void SaveMacAddress(PCOMMAND_DATA commandData,unsigned long addrh,unsigned long addrl)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SAVE_MAC_ADDRESS;
+	commandData->IoctlData.Data[0]=addrh;
+	commandData->IoctlData.Data[1]=addrl;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Save Mac Address\n");
+	}
+}
+
+void LanDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_LAN_REGS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("offset 0x50, ID_REV       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_ID_REV]);
+		printf("offset 0x54, INT_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_CFG]);
+		printf("offset 0x58, INT_STS      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_STS]);
+		printf("offset 0x5C, INT_EN       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_INT_EN]);
+		printf("offset 0x64, BYTE_TEST    = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_BYTE_TEST]);
+		printf("offset 0x68, FIFO_INT     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FIFO_INT]);
+		printf("offset 0x6C, RX_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_CFG]);
+		printf("offset 0x70, TX_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_TX_CFG]);
+		printf("offset 0x74, HW_CFG       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_HW_CFG]);
+		printf("offset 0x78, RX_DP_CTRL   = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_DP_CTRL]);
+		printf("offset 0x7C, RX_FIFO_INF  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_FIFO_INF]);
+		printf("offset 0x80, TX_FIFO_INF  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_TX_FIFO_INF]);
+		printf("offset 0x84, PMT_CTRL     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_PMT_CTRL]);
+		printf("offset 0x88, GPIO_CFG     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPIO_CFG]);
+		printf("offset 0x8C, GPT_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPT_CFG]);
+		printf("offset 0x90, GPT_CNT      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_GPT_CNT]);
+		printf("offset 0x94, FPGA_REV     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FPGA_REV]);
+		printf("offset 0x98, ENDIAN       = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_ENDIAN]);
+		printf("offset 0x9C, FREE_RUN     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_FREE_RUN]);
+		printf("offset 0xA0, RX_DROP      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_RX_DROP]);
+		printf("offset 0xA4, MAC_CSR_CMD  = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_MAC_CSR_CMD]);
+		printf("offset 0xA8, MAC_CSR_DATA = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_MAC_CSR_DATA]);
+		printf("offset 0xAC, AFC_CFG      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_AFC_CFG]);
+		printf("offset 0xB0, E2P_CMD      = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_E2P_CMD]);
+		printf("offset 0xB4, E2P_DATA     = 0x%08lX\n",commandData->IoctlData.Data[LAN_REG_E2P_DATA]);
+	} else {
+		printf("Failed to DUMP registers\n");
+	}
+}
+
+void MacDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_MAC_REGS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("index 1, MAC_CR   = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MAC_CR]);
+		printf("index 2, ADDRH    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_ADDRH]);
+		printf("index 3, ADDRL    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_ADDRL]);
+		printf("index 4, HASHH    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_HASHH]);
+		printf("index 5, HASHL    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_HASHL]);
+		printf("index 6, MII_ACC  = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MII_ACC]);
+		printf("index 7, MII_DATA = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_MII_DATA]);
+		printf("index 8, FLOW     = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_FLOW]);
+		printf("index 9, VLAN1    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_VLAN1]);
+		printf("index A, VLAN2    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_VLAN2]);
+		printf("index B, WUFF     = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_WUFF]);
+		printf("index C, WUCSR    = 0x%08lX\n",commandData->IoctlData.Data[MAC_REG_WUCSR]);
+	} else {
+		printf("Failed to Dump Mac Registers\n");
+	}
+}
+
+void DumpEEPROM(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_EEPROM;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("EEPROM[0]=0x%02lX\n",commandData->IoctlData.Data[0]);
+		printf("EEPROM[1]=0x%02lX\n",commandData->IoctlData.Data[1]);
+		printf("EEPROM[2]=0x%02lX\n",commandData->IoctlData.Data[2]);
+		printf("EEPROM[3]=0x%02lX\n",commandData->IoctlData.Data[3]);
+		printf("EEPROM[4]=0x%02lX\n",commandData->IoctlData.Data[4]);
+		printf("EEPROM[5]=0x%02lX\n",commandData->IoctlData.Data[5]);
+		printf("EEPROM[6]=0x%02lX\n",commandData->IoctlData.Data[6]);
+		printf("EEPROM[7]=0x%02lX\n",commandData->IoctlData.Data[7]);
+	} else {
+		printf("Failed to Dump EEPROM\n");
+	}
+}
+
+void DumpTemp(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_TEMP;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		unsigned long c=0;
+		for(c=0;c<0x10;c++) {
+			printf("temp[0x%02lX]=0x%08lX, ",c,commandData->IoctlData.Data[c]);
+			printf("temp[0x%02lX]=0x%08lX, ",c+0x10,commandData->IoctlData.Data[c+0x10]);
+			printf("temp[0x%02lX]=0x%08lX, ",c+0x20,commandData->IoctlData.Data[c+0x20]);
+			printf("temp[0x%02lX]=0x%08lX\n",c+0x30,commandData->IoctlData.Data[c+0x30]);
+		}
+	} else {
+		printf("Failed to dump temp data.\n");
+	}
+}
+
+void PhyDumpRegs(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_DUMP_PHY_REGS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("index 0, Basic Control Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_0]);
+		printf("index 1, Basic Status Reg  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_1]);
+		printf("index 2, PHY identifier 1  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_2]);
+		printf("index 3, PHY identifier 2  = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_3]);
+		printf("index 4, Auto Negotiation Advertisement Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_4]);
+		printf("index 5, Auto Negotiation Link Partner Ability Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_5]);
+		printf("index 6, Auto Negotiation Expansion Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_6]);
+		printf("index 16, Silicon Revision Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_16]);
+		printf("index 17, Mode Control/Status Reg = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_17]);
+		printf("index 18, Special Modes = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_18]);
+		printf("index 20, TSTCNTL = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_20]);
+		printf("index 21, TSTREAD1 = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_21]);
+		printf("index 22, TSTREAD2 = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_22]);
+		printf("index 23, TSTWRITE = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_23]);
+		printf("index 27, Control/Status Indication = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_27]);
+		printf("index 28, Special internal testability = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_28]);
+		printf("index 29, Interrupt Source Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_29]);
+		printf("index 30, Interrupt Mask Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_30]);
+		printf("index 31, PHY Special Control/Status Register = 0x%04lX\n",commandData->IoctlData.Data[PHY_REG_31]);
+	} else {
+		printf("Failed to DUMP Phy Registers\n");
+	}
+}
+
+void SetDebugMode(PCOMMAND_DATA commandData,
+				  unsigned long debug_mode)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_SET_DEBUG_MODE;
+	commandData->IoctlData.Data[0]=debug_mode;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to set debug mode.\n");
+	}
+}
+
+void SetLinkMode(PCOMMAND_DATA commandData,
+				 unsigned long link_mode)
+{
+	if(link_mode<=0x7F) {
+		if(commandData==NULL) return;
+		commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+		commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_SET_LINK_MODE;
+		commandData->IoctlData.Data[0]=link_mode;
+		ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+			printf("Failed to set link mode.\n");
+		}
+	} else {
+		printf("Invalid Link Mode, %ld\n",link_mode);
+	}
+}
+
+void SetPowerMode(PCOMMAND_DATA commandData,
+				  unsigned long power_mode)
+{
+	if(power_mode<4) {
+		if(commandData==NULL) return;
+		commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+		commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_SET_POWER_MODE;
+		commandData->IoctlData.Data[0]=power_mode;
+		ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+			printf("Failed to set power mode.\n");
+		}
+	} else {
+		printf("Invalid Power Mode, %ld\n",power_mode);
+	}
+}
+
+void GetLinkMode(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_LINK_MODE;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		unsigned long link_mode=commandData->IoctlData.Data[0];
+		printf("link_mode == 0x%02lX == %s,%s,%s,%s,%s,%s,%s\n",
+			link_mode,
+			(link_mode&0x40)?"ANEG":"",
+			(link_mode&0x20)?"SYMP":"",
+			(link_mode&0x10)?"ASYMP":"",
+			(link_mode&0x08)?"100FD":"",
+			(link_mode&0x04)?"100HD":"",
+			(link_mode&0x02)?"10FD":"",
+			(link_mode&0x01)?"10HD":"");
+	} else {
+		printf("Failed to get link mode\n");
+	}
+}
+
+void CheckLink(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_CHECK_LINK;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Checked link successfully\n");
+	} else {
+		printf("Failed to check link\n");
+	}
+}
+
+void GetPowerMode(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_POWER_MODE;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("PMT_CTRL == 0x%08lX, PM_MODE == D%ld\n",
+			commandData->IoctlData.Data[0],
+			(((commandData->IoctlData.Data[0])&0x00030000UL)>>16));
+	} else {
+		printf("Failed to get power mode\n");
+	}
+}
+
+void GetFlowParams(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_FLOW_PARAMS;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		const unsigned long * data=commandData->IoctlData.Data;
+		printf("Flow Control Parameters\n");
+		printf("  RxFlowMeasuredMaxThroughput     = 0x%08lX\n",data[0]);
+		printf("  RxFlowMeasuredMaxPacketCount    = 0x%08lX\n",data[1]);
+		printf("  RxFlowParameters.MaxThroughput  = 0x%08lX\n",data[2]);
+		printf("  RxFlowParameters.MaxPacketCount = 0x%08lX\n",data[3]);
+		printf("  RxFlowParameters.PacketCost     = 0x%08lX\n",data[4]);
+		printf("  RxFlowParameters.BurstPeriod    = 0x%08lX\n",data[5]);
+		printf("  RxFlowMaxWorkLoad               = 0x%08lX\n",data[6]);
+		printf("  INT_CFG.INT_DEAS                = 0x%08lX\n",data[7]);
+	} else {
+		printf("Failed to get flow control parameters\n");
+	}
+}
+
+void GetConfiguration(PCOMMAND_DATA commandData)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_GET_CONFIGURATION;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		const unsigned long * data=commandData->IoctlData.Data;
+		printf("Compiled: %s\n",commandData->IoctlData.Strng1);
+		printf("Driver Version = %lX.%02lX\n",
+			data[0]>>8,data[0]&0xFFUL);
+		printf("Driver Parameters\n");
+		printf("  lan_base         = 0x%08lX\n",data[1]);
+		printf("  bus_width        = 0x%08lX\n",data[2]);
+		printf("  link_mode        = 0x%08lX\n",data[3]);
+		printf("  irq              = 0x%08lX\n",data[4]);
+		printf("  int_deas         = 0x%08lX\n",data[5]);
+		printf("  irq_pol          = 0x%08lX\n",data[6]);
+		printf("  irq_type         = 0x%08lX\n",data[7]);
+		printf("  rx_dma           = 0x%08lX\n",data[8]);
+		printf("  tx_dma           = 0x%08lX\n",data[9]);
+		printf("  dma_threshold    = 0x%08lX\n",data[10]);
+		printf("  mac_addr_hi16    = 0x%08lX\n",data[11]);
+		printf("  mac_addr_lo32    = 0x%08lX\n",data[12]);
+		printf("  debug_mode       = 0x%08lX\n",data[13]);
+		printf("  tx_fif_sz        = 0x%08lX\n",data[14]);
+		printf("  afc_cfg          = 0x%08lX\n",data[15]);
+		printf("  tasklets         = 0x%08lX\n",data[16]);
+		printf("  max_throughput   = 0x%08lX\n",data[17]);
+		printf("  max_packet_count = 0x%08lX\n",data[18]);
+		printf("  packet_cost      = 0x%08lX\n",data[19]);
+		printf("  burst_period     = 0x%08lX\n",data[20]);
+		printf("  max_work_load    = 0x%08lX\n",data[21]);
+		printf("privateData\n");
+		printf("  ifName                       = \"%s\"\n",
+			commandData->IoctlData.Strng2);
+		printf("  dwIdRev                      = 0x%08lX\n",data[22]);
+		printf("  dwFpgaRev                    = 0x%08lX\n",data[23]);
+		printf("  bPhyAddress                  = 0x%08lX\n",data[24]);
+		printf("  dwPhyId                      = 0x%08lX\n",data[25]);
+		printf("  bPhyModel                    = 0x%08lX\n",data[26]);
+		printf("  bPhyRev                      = 0x%08lX\n",data[27]);
+		printf("  dwLinkSpeed                  = 0x%08lX\n",data[28]);
+		printf("  RxFlowMeasuredMaxThroughput  = 0x%08lX\n",data[29]);
+		printf("  RxFlowMeasuredMaxPacketCount = 0x%08lX\n",data[30]);
+		printf("  RxFlowMaxThroughput          = 0x%08lX\n",data[31]);
+		printf("  RxFlowMaxPacketCount         = 0x%08lX\n",data[32]);
+		printf("  RxFlowPacketCost             = 0x%08lX\n",data[33]);
+		printf("  RxFlowBurstPeriod            = 0x%08lX\n",data[34]);
+		printf("  RxFlowMaxWorkLoad            = 0x%08lX\n",data[35]);
+	} else {
+		printf("Failed to get driver configuration\n");
+	}
+}
+
+void ReadByte(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_BYTE;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%02lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]&0xFFUL);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+}
+void ReadWord(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_WORD;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%04lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]&0xFFFFUL);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+}
+void ReadDWord(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_READ_DWORD;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Memory Address == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Memory\n");
+	}
+}
+void WriteByte(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_BYTE;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data&0xFFUL;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+void WriteWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_WORD;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data&0xFFFFUL;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+void WriteDWord(PCOMMAND_DATA commandData,unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_WRITE_DWORD;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Memory\n");
+	}
+}
+
+void LanGetReg(PCOMMAND_DATA commandData,unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LAN_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Mem Map Offset == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Register\n");
+	}
+}
+void LanSetReg(PCOMMAND_DATA commandData, unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_LAN_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Register\n");
+	}
+}
+void MacGetReg(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_MAC_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Mac Index == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to read Mac Register\n");
+	}
+}
+void MacSetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_MAC_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Mac Register\n");
+	}
+}
+void PhyGetReg(PCOMMAND_DATA commandData, unsigned long address)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_PHY_GET_REG;
+	commandData->IoctlData.Data[0]=address;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+		printf("Phy Index == 0x%08lX, Read Value == 0x%08lX\n",
+			commandData->IoctlData.Data[0],
+			commandData->IoctlData.Data[1]);
+	} else {
+		printf("Failed to Read Phy Register\n");
+	}
+}
+void PhySetReg(
+	PCOMMAND_DATA commandData,
+	unsigned long address, unsigned long data)
+{
+	if(commandData==NULL) return;
+	commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+	commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+	commandData->IoctlData.dwCommand=COMMAND_PHY_SET_REG;
+	commandData->IoctlData.Data[0]=address;
+	commandData->IoctlData.Data[1]=data;
+	ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+	if(commandData->IoctlData.dwSignature!=SMSC911x_DRIVER_SIGNATURE) {
+		printf("Failed to Write Phy Register\n");
+	}
+}
+
+bool Initialize(PCOMMAND_DATA commandData,const char *ethName) {
+	if(commandData==NULL) return false;
+	if(ethName==NULL) return false;
+	commandData->hSockFD=socket(AF_INET,SOCK_DGRAM,0);
+	if((commandData->hSockFD) < 0) {
+		perror("\r\nFailed to create socket !! ->");
+		return false;
+   	}
+	commandData->IfReq.ifr_data= (void *)&(commandData->IoctlData);
+	memset(&(commandData->IoctlData),0,sizeof(SMSC911x_IOCTL_DATA));
+	if(ethName[0]!=0) {
+		strncpy(commandData->IfReq.ifr_name,ethName,IFNAMSIZ);
+		commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+		commandData->IoctlData.dwCommand=COMMAND_GET_SIGNATURE;
+		ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+		if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+			return true;
+		}
+		printf("Failed to find 911x driver on %s\n",commandData->IfReq.ifr_name);
+	} else {
+		int ifNumber;
+		for(ifNumber=0;ifNumber<8;ifNumber++) {
+			sprintf(commandData->IfReq.ifr_name,"eth%d",ifNumber);
+			commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+			commandData->IoctlData.dwCommand=COMMAND_GET_SIGNATURE;
+			commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+			ioctl(commandData->hSockFD,SMSC911x_IOCTL,&(commandData->IfReq));
+			if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+				//printf("found 911x on %s\n",commandData->IfReq.ifr_name);
+				return true;
+			}
+		}
+		printf("Failed to find 911x driver on eth0 .. eth7\n");
+	}
+	printf("Either the driver has not been installed or there is\n");
+	printf("a possible version mismatch between smsc911x.o and cmd911x\n");
+	return false;
+}
+
+bool ReceiveULong(SOCKET sock,unsigned long * pDWord)
+{
+	bool result=false;
+	unsigned long data=0;
+	unsigned char ch=0;
+	if(recv(sock,&ch,1,0)>0) {
+		data=(unsigned long)ch;
+		if(recv(sock,&ch,1,0)>0) {
+			data|=(((unsigned long)ch)<<8);
+			if(recv(sock,&ch,1,0)>0) {
+				data|=(((unsigned long)ch)<<16);
+				if(recv(sock,&ch,1,0)>0) {
+					data|=(((unsigned long)ch)<<24);
+					(*pDWord)=data;
+					result=true;
+				}
+			}
+		}
+	}
+	return result;
+}
+
+bool SendULong(SOCKET sock,unsigned long data)
+{
+	bool result=false;
+	unsigned char ch=(unsigned char)(data&0x000000FFUL);
+	if(send(sock,&ch,1,0)==1) {
+		ch=(unsigned char)((data>>8)&0x000000FFUL);
+		if(send(sock,&ch,1,0)==1) {
+			ch=(unsigned char)((data>>16)&0x000000FFUL);
+			if(send(sock,&ch,1,0)==1) {
+				ch=(unsigned char)((data>>24)&0x000000FFUL);
+				if(send(sock,&ch,1,0)==1) {
+					result=true;
+				}
+			}
+		}
+	}
+	return result;
+}
+
+void process_requests(PCOMMAND_DATA commandData)
+{
+	unsigned long requestCode=0;
+	while(ReceiveULong(server_sock,&requestCode)) {
+		switch(requestCode) {
+		case COMMAND_GET_FLOW_PARAMS:
+			commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+			commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+			commandData->IoctlData.dwCommand=COMMAND_GET_FLOW_PARAMS;
+			ioctl(commandData->hSockFD,
+				SMSC911x_IOCTL,&(commandData->IfReq));
+			if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+				SendULong(server_sock,1);//1==success
+				SendULong(server_sock,commandData->IoctlData.Data[0]);//RxFlowMeasuredMaxThroughput
+				SendULong(server_sock,commandData->IoctlData.Data[1]);//RxFlowMeasuredMaxPacketCount
+				SendULong(server_sock,commandData->IoctlData.Data[2]);//RxFlowParameters.MaxThroughput
+				SendULong(server_sock,commandData->IoctlData.Data[3]);//RxFlowParameters.MaxPacketCount
+				SendULong(server_sock,commandData->IoctlData.Data[4]);//RxFlowParameters.PacketCost
+				SendULong(server_sock,commandData->IoctlData.Data[5]);//RxFlowParameters.BurstPeriod
+				SendULong(server_sock,commandData->IoctlData.Data[6]);//RxFlowMaxWorkLoad
+				SendULong(server_sock,commandData->IoctlData.Data[7]);//INT_CFG.INT_DEAS
+			} else {
+				SendULong(server_sock,0);//0==failed
+			}
+			break;
+		case COMMAND_SET_FLOW_PARAMS:
+			{
+				unsigned long data=0;
+				commandData->IfReq.ifr_data=(void *)&(commandData->IoctlData);
+				commandData->IoctlData.dwSignature=SMSC911x_APP_SIGNATURE;
+				commandData->IoctlData.dwCommand=COMMAND_SET_FLOW_PARAMS;
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[0]=data;//RxFlowMeasuredMaxThroughput
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[1]=data;//RxFlowMeasuredMaxPacketCount
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[2]=data;//RxFlowParameters.MaxThroughput
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[3]=data;//RxFlowParameters.MaxPacketCount
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[4]=data;//RxFlowParameters.PacketCost
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[5]=data;//RxFlowParameters.BurstPeriod
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[6]=data;//RxFlowMaxWorkLoad
+				if(!ReceiveULong(server_sock,&data)) break;
+				commandData->IoctlData.Data[7]=data;//INT_CFG.INT_DEAS
+				ioctl(commandData->hSockFD,
+					SMSC911x_IOCTL,&(commandData->IfReq));
+				if(commandData->IoctlData.dwSignature==SMSC911x_DRIVER_SIGNATURE) {
+					SendULong(server_sock,1);//1==success
+				} else {
+					SendULong(server_sock,0);//0==failed
+				}
+			}
+			break;
+		default:
+			printf("WARNING, unknown requestCode=0x%08lX\n",requestCode);
+			break;
+		}
+	}
+}
+
+void RunServer(PCOMMAND_DATA commandData,unsigned short portNumber)
+{
+    struct sockaddr *server;
+	struct sockaddr_in server4;
+	int sockaddr_len;
+	struct sockaddr peeraddr;
+	SOCKET server_control;
+	int on=1;
+
+	if(portNumber==0) {
+		portNumber=DEFAULT_PORT_NUMBER;
+	}
+
+	server4.sin_port=htons(portNumber);
+	server4.sin_addr.s_addr=INADDR_ANY;
+	server4.sin_family=AF_INET;
+	sockaddr_len=sizeof(struct sockaddr_in);
+	server=(struct sockaddr *)&server4;
+
+	printf("Starting server at port %d\n",portNumber);
+	server_control = socket(server->sa_family,SOCK_STREAM,0);
+	if(server_control==INVALID_SOCKET)
+	{
+		printf("Error creating the socket\n");
+		exit(1);
+	}
+	if(setsockopt(server_control,
+		SOL_SOCKET,
+		SO_REUSEADDR,
+		(char *)&on,
+		sizeof(on))==SOCKET_ERROR)
+	{
+		printf("Error: SO_REUSEADDR\n");
+		exit(1);
+	}
+	if(bind(server_control,server,sockaddr_len)==SOCKET_ERROR)
+	{
+		printf("Error binding the socket\n");
+		exit(1);
+	}
+	if(listen(server_control,5)==SOCKET_ERROR)
+	{
+		printf("Error listening\n");
+		exit(1);
+	}
+	switch(fork()) {
+	case -1:
+		printf("Error on fork\n");
+		exit(1);
+	case 0:
+		fclose(stdin);
+		fclose(stderr);
+		setsid();
+		for(;;)
+		{
+			if((server_sock=accept(server_control,
+					&peeraddr,
+					&sockaddr_len)) == INVALID_SOCKET)
+			{
+				printf("Error accept failed\n");
+				exit(1);
+			}
+			switch(fork()) {
+			case -1:
+				//something went wrong
+				exit(1);
+			case 0:
+				//we are the child process
+				close(server_control);
+				process_requests(commandData);
+				close(server_sock);
+				exit(0);
+				break;
+			default:
+				//we are the parent process
+				close(server_sock);
+				break;
+			}
+		}
+		break;
+	default:
+		exit(0);
+	}
+}
+
+bool ReceiveFlowParams(SOCKET sock,PFLOW_PARAMS flowParams)
+{
+	bool result=false;
+	if(SendULong(sock,COMMAND_GET_FLOW_PARAMS)) {
+		unsigned long data=0;
+		if(!ReceiveULong(sock,&data)) goto DONE;
+		if(data) {
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MeasuredMaxThroughput=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MeasuredMaxPacketCount=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxThroughput=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxPacketCount=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->PacketCost=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->BurstPeriod=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->MaxWorkLoad=data;
+			if(!ReceiveULong(sock,&data)) goto DONE;
+			flowParams->IntDeas=data;
+			result=true;
+		}
+	}
+DONE:
+	return result;
+}
+
+bool SendFlowParams(SOCKET sock,PFLOW_PARAMS flowParams)
+{
+	bool result=false;
+	unsigned long timeout=100;
+	unsigned long data=0;
+AGAIN:
+	SendULong(sock,COMMAND_SET_FLOW_PARAMS);
+	SendULong(sock,flowParams->MeasuredMaxThroughput);
+	SendULong(sock,flowParams->MeasuredMaxPacketCount);
+	SendULong(sock,flowParams->MaxThroughput);
+	SendULong(sock,flowParams->MaxPacketCount);
+	SendULong(sock,flowParams->PacketCost);
+	SendULong(sock,flowParams->BurstPeriod);
+	SendULong(sock,flowParams->MaxWorkLoad);
+	SendULong(sock,flowParams->IntDeas);
+	if(ReceiveULong(sock,&data)) {
+		if(data) {
+			result=true;
+		} else {
+			//If flow control was active this command will fail
+			//  therefore wait and try again later.
+			if(timeout>0) {
+				timeout--;
+				sleep(5);
+				goto AGAIN;
+			}
+		}
+	}
+	return result;
+}
+
+void DisplayFlowParams(PFLOW_PARAMS flowParams)
+{
+	printf("Flow Control Parameters\n");
+	printf("  MaxThroughput          = 0x%08lX\n",flowParams->MaxThroughput);
+	printf("  MaxPacketCount         = 0x%08lX\n",flowParams->MaxPacketCount);
+	printf("  PacketCost             = 0x%08lX\n",flowParams->PacketCost);
+	printf("  BurstPeriod            = 0x%08lX\n",flowParams->BurstPeriod);
+	printf("  IntDeas                = 0x%08lX\n",flowParams->IntDeas);
+}
+
+unsigned long ReadThroughput(char * fileName)
+{
+	unsigned long result=0;
+	bool clearFlag=true;
+	FILE * filePtr=NULL;
+	filePtr=fopen(fileName,"r");
+	if(filePtr!=NULL) {
+		char ch=0;
+		while(fread(&ch,1,1,filePtr)!=0) {
+			switch(ch) {
+			case '0':case '1':case '2':case '3':case '4':
+			case '5':case '6':case '7':case '8':case '9':
+				if(clearFlag) {
+					result=0;
+					clearFlag=false;
+				}
+				result*=10;
+				result+=(unsigned long)(ch-'0');
+				break;
+			case '.':
+				break;
+			default:
+				clearFlag=true;
+				break;
+			}
+		}
+		fclose(filePtr);
+	} else {
+		printf("ReadThroughput: unable to open file\n");
+	}
+	return result;
+}
+
+void RunTuner(const char *hostName,unsigned short portNum)
+{
+	SOCKET controlSocket=INVALID_SOCKET;
+	struct sockaddr_in server;
+    unsigned int addr;
+	char command[128];
+	char outputFile[]="npout.txt";
+	FLOW_PARAMS flowParams;
+	FLOW_PARAMS origParams;
+	FLOW_PARAMS bestParams;
+	unsigned long bestMeasurement=0;
+	unsigned long currentSetting=0;
+	unsigned long currentMeasurement=0;
+	unsigned long tempLow=0;
+	unsigned long tempHigh=0;
+	int salen;
+	memset((char *)&server,0,sizeof(server));
+
+	if(portNum==0) {
+		portNum=DEFAULT_PORT_NUMBER;
+	}
+	server.sin_port=htons(portNum);
+	if((addr=inet_addr(hostName))==0xFFFFFFFFUL) {
+		printf("Invalid: hostName==\"%s\"",hostName);
+		printf("   must be in IP form\n");
+		return;
+	} else {
+		server.sin_addr.s_addr=addr;
+		server.sin_family=AF_INET;
+	}
+	salen=sizeof(server);
+
+	controlSocket=socket(AF_INET,SOCK_STREAM,0);
+	if(controlSocket==INVALID_SOCKET) {
+		printf("error creating control socket\n");
+		return;
+	}
+	if(connect(controlSocket,
+		(struct sockaddr *)&server,
+		salen) == INVALID_SOCKET)
+	{
+		printf("failed to connect to %s:%d\n",hostName,portNum);
+		goto DONE;
+	}
+
+	if(!ReceiveFlowParams(controlSocket,&origParams)) goto FAILED;
+	memcpy(&bestParams,&origParams,sizeof(FLOW_PARAMS));
+	bestParams.MeasuredMaxThroughput=0;
+	bestParams.MeasuredMaxPacketCount=0;
+	bestParams.MaxThroughput=0;
+	bestParams.MaxPacketCount=0;
+	bestParams.BurstPeriod=100;
+	bestParams.MaxWorkLoad=0;
+	bestParams.IntDeas=0;
+	memcpy(&flowParams,&bestParams,sizeof(FLOW_PARAMS));
+
+	printf("Entire tuning process will take about one hour.\n");
+	printf("TUNING IntDeas\n");
+	sprintf(command,"./netperf -H%s > %s",hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=0;currentSetting<80;currentSetting++) {
+		flowParams.IntDeas=currentSetting;
+		if(!SendFlowParams(controlSocket,&flowParams)) {
+			printf("Failed to send new setting: IntDeas=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.IntDeas=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("IntDeas = %ld, Throughput = %ld\n",currentSetting,currentMeasurement);
+	}
+	printf("Best: IntDeas = %ld, Throughput = %ld\n",bestParams.IntDeas,bestMeasurement);
+	flowParams.IntDeas=bestParams.IntDeas;
+	if(!SendFlowParams(controlSocket,&flowParams)) {
+		goto FAILED;
+	}
+	//getting the FlowParams back will make sure the measurements are clear.
+	if(!ReceiveFlowParams(controlSocket,&flowParams)) goto FAILED;
+	if(flowParams.IntDeas!=bestParams.IntDeas) {
+		printf("new setting did not stick\n");
+		goto FAILED;
+	}
+	printf("Measuring Max Throughput, and Max Packet Count\n");
+	if(system(command)!=0) goto FAILED;
+	if(system(command)!=0) goto FAILED;
+	if(system(command)!=0) goto FAILED;
+	if(!ReceiveFlowParams(controlSocket,&flowParams)) goto FAILED;
+	bestParams.MeasuredMaxThroughput=flowParams.MeasuredMaxThroughput;
+	bestParams.MeasuredMaxPacketCount=flowParams.MeasuredMaxPacketCount;
+	bestParams.MaxThroughput=bestParams.MeasuredMaxThroughput;
+	bestParams.MaxPacketCount=bestParams.MeasuredMaxPacketCount;
+	bestParams.PacketCost=0;
+	bestParams.MaxWorkLoad=0xFFFFFFFFUL;
+	bestParams.BurstPeriod=100;
+	memcpy(&flowParams,&bestParams,sizeof(FLOW_PARAMS));
+
+	printf("TUNING Burst Period\n");
+	sprintf(command,"./netperf -H%s -tUDP_STREAM -l10 -- -m1472 > %s",
+		hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=10;currentSetting<120;currentSetting++) {
+		flowParams.BurstPeriod=currentSetting;
+		if(!SendFlowParams(controlSocket,&flowParams)) {
+			printf("Failed to send new setting: BurstPeriod=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.BurstPeriod=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("BurstPeriod = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	printf("Best: BurstPeriod = %ld, Throughput = %ld\n",
+		bestParams.BurstPeriod,bestMeasurement);
+	flowParams.BurstPeriod=bestParams.BurstPeriod;
+
+	printf("TUNING PacketCost\n");
+	sprintf(command,"./netperf -H%s -tUDP_STREAM -l10 -- -m16 > %s",
+		hostName,outputFile);
+	bestMeasurement=0;
+	for(currentSetting=0;currentSetting<500;currentSetting+=10) {
+		flowParams.PacketCost=currentSetting;
+		if(!SendFlowParams(controlSocket, &flowParams)) {
+			printf("Failed to send new setting: PacketCost=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.PacketCost=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("PacketCost = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	bestMeasurement=0;
+	if(bestParams.PacketCost>20) {
+		tempLow=bestParams.PacketCost-20;
+	} else {
+		tempLow=0;
+	}
+	tempHigh=bestParams.PacketCost+20;
+	for(currentSetting=tempLow;currentSetting<tempHigh;currentSetting++) {
+		flowParams.PacketCost=currentSetting;
+		if(!SendFlowParams(controlSocket, &flowParams)) {
+			printf("Failed to send new setting: PacketCost=%ld\n",currentSetting);
+			goto FAILED;
+		}
+		if(system(command)==0) {
+			currentMeasurement=ReadThroughput(outputFile);
+			if(currentMeasurement>bestMeasurement) {
+				bestMeasurement=currentMeasurement;
+				bestParams.PacketCost=currentSetting;
+			}
+		} else {
+			printf("Failed system command: \"%s\"\n",command);
+			goto FAILED;
+		}
+		printf("PacketCost = %ld, Throughput = %ld\n",
+			currentSetting,currentMeasurement);
+	}
+	printf("Best: PacketCost = %ld, Throughput = %ld\n",
+		bestParams.PacketCost,bestMeasurement);
+	printf("Best ");DisplayFlowParams(&bestParams);
+	if(!SendFlowParams(controlSocket, &origParams)) {
+		printf("Failed to restore original setting\n");
+		goto FAILED;
+	}
+
+DONE:
+	close(controlSocket);
+	return;
+FAILED:
+	close(controlSocket);
+	printf("Something went wrong\n");
+}
+
+int main(ac,av)
+int ac;
+char * av[];
+{
+	int oc=0;
+	bool eSet=false;
+	char ethName[IFNAMSIZ];
+	COMMAND_DATA commandData;
+	bool cSet=false;
+	bool aSet=false;
+	unsigned long address=0;
+	bool dSet=false;
+	unsigned long data=0;
+	unsigned long commandCode=0;
+	char hostName[128];
+	bool hSet=false;
+	unsigned long portNum=0;
+	bool pSet=false;
+
+	iam=av[0];
+	ethName[0]=0;
+	hostName[0]=0;
+
+	while((oc=getopt(ac,av,"hH:p:e:c:a:d:"))!=-1) {
+		switch(oc) {
+		case 'h'://help
+			goto BAD_USAGE;
+		case 'H'://Host address
+			if(hSet) goto BAD_USAGE;
+			strcpy(hostName,optarg);
+			hSet=true;
+			break;
+		case 'p':
+			if(pSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&portNum)) {
+				goto BAD_USAGE;
+			}
+			if(portNum>0xFFFFUL) goto BAD_USAGE;
+			pSet=true;
+			break;
+		case 'e':
+			if(eSet) goto BAD_USAGE;
+			eSet=true;
+			strncpy(ethName,optarg,IFNAMSIZ);
+			ethName[IFNAMSIZ-1]=0;
+			break;
+		case 'c':
+			if(cSet) goto BAD_USAGE;
+			if(strcmp(optarg,"GET_CONFIG")==0) {
+				commandCode=COMMAND_GET_CONFIGURATION;
+			} else if(strcmp(optarg,"DUMP_REGS")==0) {
+				commandCode=COMMAND_DUMP_LAN_REGS;
+			} else if(strcmp(optarg,"DUMP_MAC")==0) {
+				commandCode=COMMAND_DUMP_MAC_REGS;
+			} else if(strcmp(optarg,"DUMP_PHY")==0) {
+				commandCode=COMMAND_DUMP_PHY_REGS;
+			} else if(strcmp(optarg,"DUMP_EEPROM")==0) {
+				commandCode=COMMAND_DUMP_EEPROM;
+			} else if(strcmp(optarg,"DUMP_TEMP")==0) {
+				commandCode=COMMAND_DUMP_TEMP;
+			} else if(strcmp(optarg,"GET_MAC")==0) {
+				commandCode=COMMAND_GET_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SET_MAC")==0) {
+				commandCode=COMMAND_SET_MAC_ADDRESS;
+			} else if(strcmp(optarg,"LOAD_MAC")==0) {
+				commandCode=COMMAND_LOAD_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SAVE_MAC")==0) {
+				commandCode=COMMAND_SAVE_MAC_ADDRESS;
+			} else if(strcmp(optarg,"SET_DEBUG")==0) {
+				commandCode=COMMAND_SET_DEBUG_MODE;
+			} else if(strcmp(optarg,"SET_POWER")==0) {
+				commandCode=COMMAND_SET_POWER_MODE;
+			} else if(strcmp(optarg,"GET_POWER")==0) {
+				commandCode=COMMAND_GET_POWER_MODE;
+			} else if(strcmp(optarg,"SET_LINK")==0) {
+				commandCode=COMMAND_SET_LINK_MODE;
+			} else if(strcmp(optarg,"GET_LINK")==0) {
+				commandCode=COMMAND_GET_LINK_MODE;
+			} else if(strcmp(optarg,"CHECK_LINK")==0) {
+				commandCode=COMMAND_CHECK_LINK;
+			} else if(strcmp(optarg,"READ_REG")==0) {
+				commandCode=COMMAND_LAN_GET_REG;
+			} else if(strcmp(optarg,"WRITE_REG")==0) {
+				commandCode=COMMAND_LAN_SET_REG;
+			} else if(strcmp(optarg,"READ_MAC")==0) {
+				commandCode=COMMAND_MAC_GET_REG;
+			} else if(strcmp(optarg,"WRITE_MAC")==0) {
+				commandCode=COMMAND_MAC_SET_REG;
+			} else if(strcmp(optarg,"READ_PHY")==0) {
+				commandCode=COMMAND_PHY_GET_REG;
+			} else if(strcmp(optarg,"WRITE_PHY")==0) {
+				commandCode=COMMAND_PHY_SET_REG;
+			} else if(strcmp(optarg,"READ_BYTE")==0) {
+				commandCode=COMMAND_READ_BYTE;
+			} else if(strcmp(optarg,"READ_WORD")==0) {
+				commandCode=COMMAND_READ_WORD;
+			} else if(strcmp(optarg,"READ_DWORD")==0) {
+				commandCode=COMMAND_READ_DWORD;
+			} else if(strcmp(optarg,"WRITE_BYTE")==0) {
+				commandCode=COMMAND_WRITE_BYTE;
+			} else if(strcmp(optarg,"WRITE_WORD")==0) {
+				commandCode=COMMAND_WRITE_WORD;
+			} else if(strcmp(optarg,"WRITE_DWORD")==0) {
+				commandCode=COMMAND_WRITE_DWORD;
+			} else if(strcmp(optarg,"SERVER")==0) {
+				commandCode=COMMAND_RUN_SERVER;
+			} else if(strcmp(optarg,"TUNER")==0) {
+				commandCode=COMMAND_RUN_TUNER;
+			} else if(strcmp(optarg,"GET_FLOW")==0) {
+				commandCode=COMMAND_GET_FLOW_PARAMS;
+			} else {
+				goto BAD_USAGE;
+			}
+			cSet=true;
+			break;
+		case 'a':
+			if(aSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&address)) {
+				goto BAD_USAGE;
+			}
+			aSet=true;
+			break;
+		case 'd':
+			if(dSet) goto BAD_USAGE;
+			if(!ParseNumber(optarg,&data)) {
+				goto BAD_USAGE;
+			}
+			dSet=true;
+			break;
+		default:
+			goto BAD_USAGE;
+		}
+	}
+
+	if(commandCode==COMMAND_RUN_TUNER) {
+		//This command must be run before initialize because
+		//  it will typically be run on machines that do not
+		//  have the smsc911x driver installed.
+		RunTuner(hostName,(unsigned short)portNum);
+		return 1;
+	}
+
+	if(!Initialize(&commandData,ethName)) {
+		return 1;
+	}
+
+	switch(commandCode) {
+	case COMMAND_RUN_SERVER:
+		RunServer(&commandData,(unsigned short)portNum);
+		break;
+	case COMMAND_GET_FLOW_PARAMS:
+		GetFlowParams(&commandData);
+		break;
+	case COMMAND_GET_CONFIGURATION:
+		GetConfiguration(&commandData);
+		break;
+	case COMMAND_DUMP_LAN_REGS:
+		LanDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_MAC_REGS:
+		MacDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_PHY_REGS:
+		PhyDumpRegs(&commandData);
+		break;
+	case COMMAND_DUMP_EEPROM:
+		DumpEEPROM(&commandData);
+		break;
+	case COMMAND_DUMP_TEMP:
+		DumpTemp(&commandData);
+		break;
+	case COMMAND_GET_MAC_ADDRESS:
+		GetMacAddress(&commandData);
+		break;
+	case COMMAND_SET_MAC_ADDRESS:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		SetMacAddress(&commandData,address,data);
+		break;
+	case COMMAND_LOAD_MAC_ADDRESS:
+		LoadMacAddress(&commandData);
+		break;
+	case COMMAND_SAVE_MAC_ADDRESS:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		SaveMacAddress(&commandData,address,data);
+		break;
+	case COMMAND_SET_DEBUG_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetDebugMode(&commandData,data);
+		break;
+	case COMMAND_SET_LINK_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetLinkMode(&commandData,data);
+		break;
+	case COMMAND_GET_LINK_MODE:
+		GetLinkMode(&commandData);
+		break;
+	case COMMAND_CHECK_LINK:
+		CheckLink(&commandData);
+		break;
+	case COMMAND_SET_POWER_MODE:
+		if(!dSet) goto BAD_USAGE;
+		SetPowerMode(&commandData,data);
+		break;
+	case COMMAND_GET_POWER_MODE:
+		GetPowerMode(&commandData);
+		break;
+	case COMMAND_LAN_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		LanGetReg(&commandData,address);
+		break;
+	case COMMAND_LAN_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		LanSetReg(&commandData,address,data);
+		break;
+	case COMMAND_MAC_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		MacGetReg(&commandData,address);
+		break;
+	case COMMAND_MAC_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		MacSetReg(&commandData,address,data);
+		break;
+	case COMMAND_PHY_GET_REG:
+		if(!aSet) goto BAD_USAGE;
+		PhyGetReg(&commandData,address);
+		break;
+	case COMMAND_PHY_SET_REG:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		PhySetReg(&commandData,address,data);
+		break;
+	case COMMAND_READ_BYTE:
+		if(!aSet) goto BAD_USAGE;
+		ReadByte(&commandData,address);
+		break;
+	case COMMAND_READ_WORD:
+		if(!aSet) goto BAD_USAGE;
+		ReadWord(&commandData,address);
+		break;
+	case COMMAND_READ_DWORD:
+		if(!aSet) goto BAD_USAGE;
+		ReadDWord(&commandData,address);
+		break;
+	case COMMAND_WRITE_BYTE:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteByte(&commandData,address,data);
+		break;
+	case COMMAND_WRITE_WORD:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteWord(&commandData,address,data);
+		break;
+	case COMMAND_WRITE_DWORD:
+		if(!aSet) goto BAD_USAGE;
+		if(!dSet) goto BAD_USAGE;
+		WriteDWord(&commandData,address,data);
+		break;
+	default:
+		goto BAD_USAGE;
+	}
+
+	return 1;
+BAD_USAGE:
+	DisplayUsage();
+	return 1;
+}
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/COPYING linux-2.6.17.8-sh/drivers/net/smsc_911x/COPYING
--- linux-2.6.17.8/drivers/net/smsc_911x/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/COPYING	2006-08-23 13:29:37.681576000 +0100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/ioctl_11x.h linux-2.6.17.8-sh/drivers/net/smsc_911x/ioctl_11x.h
--- linux-2.6.17.8/drivers/net/smsc_911x/ioctl_11x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/ioctl_11x.h	2006-08-23 13:29:49.053830000 +0100
@@ -0,0 +1,148 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: ioctl_11x.h
+ */
+
+#ifndef IOCTL_11x_H
+#define IOCTL_11x_H
+
+#define DRIVER_VERSION	(0x00000121UL)
+
+#define SMSC911x_DRIVER_SIGNATURE	(0x82745BACUL+DRIVER_VERSION)
+#define SMSC911x_APP_SIGNATURE		(0x987BEF28UL+DRIVER_VERSION)
+
+#define SMSC911x_IOCTL				(SIOCDEVPRIVATE + 0xB)
+
+#define COMMAND_BASE				(0x974FB832UL)
+
+#define COMMAND_GET_SIGNATURE		(COMMAND_BASE+0)
+
+#define COMMAND_LAN_GET_REG			(COMMAND_BASE+1)
+#define COMMAND_LAN_SET_REG			(COMMAND_BASE+2)
+
+#define COMMAND_MAC_GET_REG			(COMMAND_BASE+3)
+#define COMMAND_MAC_SET_REG			(COMMAND_BASE+4)
+
+#define COMMAND_PHY_GET_REG			(COMMAND_BASE+5)
+#define COMMAND_PHY_SET_REG			(COMMAND_BASE+6)
+
+#define COMMAND_DUMP_LAN_REGS		(COMMAND_BASE+7)
+#define LAN_REG_ID_REV			(0)
+#define LAN_REG_INT_CFG			(1)
+#define LAN_REG_INT_STS			(2)
+#define LAN_REG_INT_EN			(3)
+#define LAN_REG_BYTE_TEST		(4)
+#define LAN_REG_FIFO_INT		(5)
+#define LAN_REG_RX_CFG			(6)
+#define LAN_REG_TX_CFG			(7)
+#define LAN_REG_HW_CFG			(8)
+#define LAN_REG_RX_DP_CTRL		(9)
+#define LAN_REG_RX_FIFO_INF		(10)
+#define LAN_REG_TX_FIFO_INF		(11)
+#define LAN_REG_PMT_CTRL		(12)
+#define LAN_REG_GPIO_CFG		(13)
+#define LAN_REG_GPT_CFG			(14)
+#define LAN_REG_GPT_CNT			(15)
+#define LAN_REG_FPGA_REV		(16)
+#define LAN_REG_ENDIAN			(17)
+#define LAN_REG_FREE_RUN		(18)
+#define LAN_REG_RX_DROP			(19)
+#define LAN_REG_MAC_CSR_CMD		(21)
+#define LAN_REG_MAC_CSR_DATA	(22)
+#define LAN_REG_AFC_CFG			(23)
+#define LAN_REG_E2P_CMD			(24)
+#define LAN_REG_E2P_DATA		(25)
+
+#define COMMAND_DUMP_MAC_REGS		(COMMAND_BASE+8)
+#define MAC_REG_MAC_CR			(0)
+#define MAC_REG_ADDRH			(1)
+#define MAC_REG_ADDRL			(2)
+#define MAC_REG_HASHH			(3)
+#define MAC_REG_HASHL			(4)
+#define MAC_REG_MII_ACC			(5)
+#define MAC_REG_MII_DATA		(6)
+#define MAC_REG_FLOW			(7)
+#define MAC_REG_VLAN1			(8)
+#define MAC_REG_VLAN2			(9)
+#define MAC_REG_WUFF			(10)
+#define MAC_REG_WUCSR			(11)
+
+#define COMMAND_DUMP_PHY_REGS		(COMMAND_BASE+9)
+#define PHY_REG_0				(0)
+#define PHY_REG_1				(1)
+#define PHY_REG_2				(2)
+#define PHY_REG_3				(3)
+#define PHY_REG_4				(4)
+#define PHY_REG_5				(5)
+#define PHY_REG_6				(6)
+#define PHY_REG_16				(7)
+#define PHY_REG_17				(8)
+#define PHY_REG_18				(9)
+#define PHY_REG_20				(10)
+#define PHY_REG_21				(11)
+#define PHY_REG_22				(12)
+#define PHY_REG_23				(13)
+#define PHY_REG_27				(14)
+#define PHY_REG_28				(15)
+#define PHY_REG_29				(16)
+#define PHY_REG_30				(17)
+#define PHY_REG_31				(18)
+
+#define COMMAND_DUMP_EEPROM			(COMMAND_BASE+10)
+
+#define COMMAND_GET_MAC_ADDRESS		(COMMAND_BASE+11)
+#define COMMAND_SET_MAC_ADDRESS		(COMMAND_BASE+12)
+#define COMMAND_LOAD_MAC_ADDRESS	(COMMAND_BASE+13)
+#define COMMAND_SAVE_MAC_ADDRESS	(COMMAND_BASE+14)
+#define COMMAND_SET_DEBUG_MODE		(COMMAND_BASE+15)
+
+#define COMMAND_SET_POWER_MODE		(COMMAND_BASE+16)
+#define COMMAND_GET_POWER_MODE		(COMMAND_BASE+17)
+
+#define COMMAND_SET_LINK_MODE		(COMMAND_BASE+18)
+#define COMMAND_GET_LINK_MODE		(COMMAND_BASE+19)
+#define COMMAND_GET_CONFIGURATION	(COMMAND_BASE+20)
+#define COMMAND_DUMP_TEMP			(COMMAND_BASE+21)
+#define COMMAND_READ_BYTE			(COMMAND_BASE+22)
+#define COMMAND_READ_WORD			(COMMAND_BASE+23)
+#define COMMAND_READ_DWORD			(COMMAND_BASE+24)
+#define COMMAND_WRITE_BYTE			(COMMAND_BASE+25)
+#define COMMAND_WRITE_WORD			(COMMAND_BASE+26)
+#define COMMAND_WRITE_DWORD			(COMMAND_BASE+27)
+#define COMMAND_CHECK_LINK			(COMMAND_BASE+28)
+
+//the following codes are intended for cmd911x only
+//  they are not intended to have any use in the driver
+#define COMMAND_RUN_SERVER			(COMMAND_BASE+29)
+#define COMMAND_RUN_TUNER			(COMMAND_BASE+30)
+
+#define COMMAND_GET_FLOW_PARAMS		(COMMAND_BASE+31)
+#define COMMAND_SET_FLOW_PARAMS		(COMMAND_BASE+32)
+
+typedef struct _SMSC911x_IOCTL_DATA {
+	unsigned long dwSignature;
+	unsigned long dwCommand;
+	unsigned long Data[0x60];
+	char Strng1[30];
+	char Strng2[10];
+} SMSC911x_IOCTL_DATA, *PSMSC911x_IOCTL_DATA;
+
+#endif
+
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/lint.h linux-2.6.17.8-sh/drivers/net/smsc_911x/lint.h
--- linux-2.6.17.8/drivers/net/smsc_911x/lint.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/lint.h	2006-08-23 13:29:37.694577000 +0100
@@ -0,0 +1,406 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ ***************************************************************************
+ * Additionally it deserves noting that the everything in this file is
+ *   for the purpose of making the lint tool happy. Therefore everything
+ *   declared or defined in this file has been thoroughly customized. It
+ *   is not suitable to be use as a reference nor compatible for any
+ *   other purpose.
+ *   For proper declarations and definitions see the linux source code.
+ ***************************************************************************
+ * File: lint.h
+ */
+
+#ifndef LINT_H
+#define LINT_H
+
+/********************************************************
+******************SHARED*********************************
+********************************************************/
+#define IFNAMSIZ	(10)
+#define SIOCDEVPRIVATE (10000UL)
+struct ifreq
+{
+//#define IFHWADDRLEN	6
+//#define	IFNAMSIZ	16
+#ifdef CMD911X
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	} ifr_ifrn;
+#endif
+
+	union {
+//		struct	sockaddr ifru_addr;
+//		struct	sockaddr ifru_dstaddr;
+//		struct	sockaddr ifru_broadaddr;
+//		struct	sockaddr ifru_netmask;
+//		struct  sockaddr ifru_hwaddr;
+//		short	ifru_flags;
+//		int	ifru_ivalue;
+//		int	ifru_mtu;
+//		struct  ifmap ifru_map;
+//		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
+//		char	ifru_newname[IFNAMSIZ];
+		char *	ifru_data;
+//		struct	if_settings ifru_settings;
+	} ifr_ifru;
+};
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+
+#define NULL ((void *)(0))
+extern void memset(void *__s, int __c, unsigned int __count);
+extern void memcpy(void *a,const void * b,unsigned int c);
+extern void sprintf(char * a,const char * b,...);
+extern void strcpy(signed char * s,const signed char * s);
+
+/***********************************************************
+************DRIVER ONLY*************************************
+************************************************************/
+#ifndef CMD911X
+
+#define LINUX_VERSION_CODE 132113
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+
+//typedef void irqreturn_t;
+//#define IRQ_NONE
+//#define IRQ_HANDLED
+//#define IRQ_RETVAL(x)
+
+
+//typedef long TIME_SPAN;
+//#define MAX_TIME_SPAN	((TIME_SPAN)(0x7FFFFFFFUL))
+//typedef unsigned long DWORD;
+//typedef unsigned short WORD;
+//typedef unsigned char BYTE;
+//typedef unsigned char BOOLEAN;
+//#define TRUE	((BOOLEAN)1)
+//#define FALSE	((BOOLEAN)0)
+//
+//#define HIBYTE(word)  ((BYTE)(((WORD)(word))>>8))
+//#define LOBYTE(word)  ((BYTE)(((WORD)(word))&0x00FFU))
+//#define HIWORD(dWord) ((WORD)(((DWORD)(dWord))>>16))
+//#define LOWORD(dWord) ((WORD)(((DWORD)(dWord))&0x0000FFFFUL))
+typedef unsigned long spinlock_t;
+
+typedef unsigned long ULONG;
+typedef unsigned char UCHAR;
+
+//extern void SMSC_TRACE(const char * a,...);
+//extern void SMSC_WARNING(const char * a,...);
+//extern void SMSC_ASSERT(BOOLEAN condition);
+
+//#define TRANSFER_PIO			((DWORD)256)
+//#define TRANSFER_REQUEST_DMA	((DWORD)255)
+
+//DMA Transfer structure
+//typedef struct _DMA_XFER
+//{
+//	DWORD dwLanReg;
+//	DWORD *pdwBuf;
+//	DWORD dwDmaCh;
+//	DWORD dwDwCnt;
+//	BOOLEAN fMemWr;
+//} DMA_XFER, *PDMA_XFER;
+//
+//typedef struct _FLOW_CONTROL_PARAMETERS
+//{
+//	DWORD MaxThroughput;
+//	DWORD MaxPacketCount;
+//	DWORD PacketCost;
+//	DWORD BurstPeriod;
+//	DWORD IntDeas;
+//} FLOW_CONTROL_PARAMETERS, *PFLOW_CONTROL_PARAMETERS;
+
+struct net_device_stats
+{
+	ULONG	rx_packets;
+	ULONG	tx_packets;
+	ULONG	rx_bytes;
+	ULONG	tx_bytes;
+	ULONG	rx_errors;
+	ULONG	tx_errors;
+	ULONG	rx_dropped;
+	ULONG	multicast;
+	ULONG	collisions;
+	ULONG	rx_length_errors;
+	ULONG	rx_crc_errors;
+	ULONG	tx_aborted_errors;
+	ULONG	tx_carrier_errors;
+};
+
+struct timer_list {
+	ULONG expires;
+	ULONG data;
+	void (*function)(ULONG param);
+};
+
+#define MODULE_PARM(var,type)		 	\
+const char __module_parm_##var[] = type
+
+#define MODULE_PARM_DESC(var,desc)		\
+const char __module_parm_desc_##var[] = desc
+
+#define MODULE_LICENSE(license) 	\
+static const char __module_license[] =license
+
+#define MOD_INC_USE_COUNT	do { } while (0)
+#define MOD_DEC_USE_COUNT	do { } while (0)
+
+#define MAX_ADDR_LEN (6)
+
+struct dev_mc_list
+{
+	struct dev_mc_list	*next;
+	UCHAR dmi_addr[MAX_ADDR_LEN];
+	UCHAR dmi_addrlen;
+};
+
+struct net_device
+{
+	char name[IFNAMSIZ];
+	struct net_device_stats* (*get_stats)(struct net_device *dev);
+	unsigned short flags;
+//	spinlock_t xmit_lock;
+	void * priv;
+	UCHAR dev_addr[MAX_ADDR_LEN];
+	struct dev_mc_list * mc_list;
+	int mc_count;
+//	int (*init)(struct net_device *dev);
+	int	(*open)(struct net_device *dev);
+	int	(*stop)(struct net_device *dev);
+	int	(*hard_start_xmit) (struct sk_buff *skb,struct net_device *dev);
+	void (*set_multicast_list)(struct net_device *dev);
+	int (*do_ioctl)(struct net_device *dev, struct ifreq *ifr,int cmd);
+};
+
+struct mii_ioctl_data {
+	ULONG	phy_id;
+	ULONG	reg_num;
+	ULONG	val_in;
+	ULONG	val_out;
+};
+
+#define SIOCGMIIPHY	(1000UL)
+#define SIOCGMIIREG	(1001UL)
+#define SIOCSMIIREG	(1002UL)
+
+
+struct sk_buff {
+	struct net_device	*dev;
+	unsigned int 	len;
+	unsigned char	ip_summed;
+	unsigned short	protocol;
+	unsigned char	*head;
+	unsigned char	*data;
+	unsigned char	*tail;
+};
+
+struct tasklet_struct
+{
+	struct tasklet_struct *next;
+	unsigned long state;
+	unsigned long count;
+	void (*func)(unsigned long param);
+	unsigned long data;
+};
+
+#define DECLARE_TASKLET(name, func, data) \
+struct tasklet_struct name = { NULL, 0, 0, func, data }
+
+extern struct sk_buff *dev_alloc_skb(unsigned int length);
+extern unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev);
+extern void netif_carrier_on(struct net_device *dev);
+extern void netif_carrier_off(struct net_device *dev);
+extern int netif_rx(struct sk_buff *skb);
+extern void netif_start_queue(struct net_device *dev);
+extern void netif_wake_queue(struct net_device *dev);
+extern void netif_stop_queue(struct net_device *dev);
+extern void free_irq(unsigned int Irq, void *isr);
+extern int check_mem_region(unsigned long a, unsigned long b);
+extern void release_mem_region(unsigned long a, unsigned long b);
+extern void tasklet_schedule(struct tasklet_struct *t);
+extern void del_timer_sync(struct timer_list * timer);
+extern void init_timer(struct timer_list * timer);
+extern void ether_setup(struct net_device *dev);
+extern int register_netdev(struct net_device *dev);
+extern void add_timer(struct timer_list * timer);
+extern void spin_lock(spinlock_t *s);
+extern void spin_unlock(spinlock_t *s);
+extern void spin_lock_init(spinlock_t *s);
+extern void spin_lock_irqsave(spinlock_t *s,unsigned long f);
+extern void spin_unlock_irqrestore(spinlock_t *s,unsigned long f);
+extern void unregister_netdev(struct net_device *dev);
+extern void udelay(unsigned long usecs);
+#define SET_MODULE_OWNER(some_struct) do { } while (0)
+extern void request_mem_region(unsigned long start, unsigned long n, const signed char *name);
+extern int request_irq(unsigned int a,
+		       void (*handler)(int a, void * b, struct pt_regs * c),
+		       unsigned long c, const signed char * d, void * e);
+extern void dev_kfree_skb(struct sk_buff *skb);
+extern void skb_reserve(struct sk_buff *skb, unsigned int len);
+extern void skb_put(struct sk_buff *skb, unsigned int len);
+
+
+#define NET_RX_SUCCESS		0
+#define NET_RX_DROP			1
+#define NET_RX_CN_LOW		2
+#define NET_RX_CN_MOD		3
+#define NET_RX_CN_HIGH		4
+
+#define CHECKSUM_NONE 0
+
+#define	ENOMEM		12
+#define	EFAULT		14
+#define	ENODEV		19
+
+#define GFP_KERNEL	(1)
+
+#define IFF_MULTICAST   (1U)
+#define IFF_PROMISC		(2U)
+#define IFF_ALLMULTI	(4U)
+
+#define SA_INTERRUPT	0x20000000
+
+extern void *kmalloc(unsigned int a, int b);
+extern void kfree(const void *a);
+
+extern unsigned long volatile jiffies;
+#define HZ 100
+
+#endif //not CMD911X
+
+
+/*******************************************************
+*************XSCALE DRIVER******************************
+*******************************************************/
+#ifdef USE_XSCALE
+#define MST_EXP_BASE (0x80000000UL)
+#define MST_EXP_PHYS (0x00000005UL)
+#define MSC2 (*((volatile unsigned long *)(0x48000000UL)))
+#define MAINSTONE_nExBRD_IRQ (50UL)
+#define DCSR_RUN (1UL)
+#define DCSR_STOPSTATE (2UL)
+#define DCSR_NODESC (4UL)
+#define DCMD_INCTRGADDR (1UL)
+#define DCMD_INCSRCADDR (2UL)
+#define DCMD_BURST32 (4UL)
+#define DCMD_LENGTH (8UL)
+#define DCSR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DTADR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DSADR(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+#define DCMD(dmaCh) (*((volatile unsigned long *)(0x40000000UL+dmaCh)))
+extern unsigned long virt_to_bus(unsigned long arg);
+#endif //USE_XSCALE
+
+
+/********************************************************
+**************PEAKS DRIVER*******************************
+********************************************************/
+#if (defined(USE_PEAKS)||defined(USE_PEAKS_LITE))
+struct hw_interrupt_type {
+	const char * typename;
+	unsigned int (*startup)(unsigned int irq);
+	void (*shutdown)(unsigned int irq);
+	void (*enable)(unsigned int irq);
+	void (*disable)(unsigned int irq);
+	void (*ack)(unsigned int irq);
+	void (*end)(unsigned int irq);
+	void (*set_affinity)(unsigned int irq, unsigned long mask);
+};
+#define Gicr(arg) (*(volatile WORD *)(arg))
+typedef struct _IRQ_TYPE {
+	struct hw_interrupt_type *handler;
+} IRQ_TYPE, * PIRQ_TYPE;
+PIRQ_TYPE irq_desc=NULL;
+extern void purge_cache(unsigned long arg1,unsigned long arg2,unsigned long arg3);
+#endif //USE_PEAKS or USE_PEAKS_LITE
+
+
+/**********************************************************
+***************COMMAND APPLICATION*************************
+**********************************************************/
+#ifdef CMD911X
+#define AF_INET		(0)
+#define SOCK_DGRAM	(0)
+struct in_addr {
+	unsigned long s_addr;
+};
+#define INADDR_ANY (0xFFFFFFFFUL)
+struct sockaddr_in {
+  unsigned short int	sin_family;	/* Address family		*/
+  unsigned short int	sin_port;	/* Port number			*/
+  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+//  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+//			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+struct sockaddr {
+  unsigned short int	sa_family;	/* Address family		*/
+//  unsigned short int	sin_port;	/* Port number			*/
+//  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+//  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+//			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+
+#define SOCK_STREAM		(1)
+#define SOL_SOCKET		(2)
+#define SO_REUSEADDR	(3)
+
+#define FILE void
+
+extern void * fopen(const char * fileName,const char * mode);
+
+extern void * stdin;
+extern void * stderr;
+extern const char * optarg;
+extern void printf(const char * b,...);
+extern int recv(int sock,unsigned char *ch,int a,int b);
+extern int send(int sock,unsigned char *ch,int a,int b);
+extern unsigned int inet_addr(const char * hostname);
+extern int socket(int a,int b,int c);
+extern void close(int a);
+extern int fork(void);
+extern int system(const char * command);
+extern void fclose(void *);
+extern void strncpy(char * a, const char *b, int c);
+extern void perror(char * c);
+extern unsigned short htons(unsigned short a);
+extern void sleep(int s);
+extern void exit(int x);
+extern int sscanf(const char *a,char *b,...);
+extern int accept(int a,struct sockaddr *b,int *c);
+extern int listen(int a,int b);
+extern int strcmp(const char *a,const char *b);
+extern int bind(int a,struct sockaddr *b,int c);
+extern int connect(int a,struct sockaddr *b,int c);
+extern int fread(char *a,int b,int c,void *d);
+extern void ioctl(int a,int b,struct ifreq *c);
+extern int getopt(int a,char **b,char *c);
+extern int setsockopt(int a,int b,int c,char *d,int e);
+extern void setsid(void);
+
+
+#endif //CMD911X
+
+#endif //LINT_H
+
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/Makefile linux-2.6.17.8-sh/drivers/net/smsc_911x/Makefile
--- linux-2.6.17.8/drivers/net/smsc_911x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/Makefile	2006-08-23 13:29:51.721898000 +0100
@@ -0,0 +1,6 @@
+# kbuild part of makefile
+
+obj-$(CONFIG_SMSC911x) := smsc911x.o
+
+CFLAGS_smsc911x.o += -DPLATFORM_SOURCE=\"st40.c\" -DUSE_ST40_STMICRO
+CFLAGS_smsc911x.o += -DUSE_DEBUG
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/readme.txt linux-2.6.17.8-sh/drivers/net/smsc_911x/readme.txt
--- linux-2.6.17.8/drivers/net/smsc_911x/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/readme.txt	2006-08-23 13:29:49.070829000 +0100
@@ -0,0 +1,1498 @@
+/***************************************************************************
+ *
+ * Copyright (c) 2004-2005, SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: Readme.txt
+ */
+
+This is the users/programmers guide for the LAN911x Linux Driver
+The following sections can be found below
+*  Revision History
+*  Files
+*  Features
+*  Driver Parameters
+*  Rx Performance Tuning
+*  Tested Platforms
+*  Rx Code Path
+*  Tx Code Path
+*  Platform Interface Descriptions
+
+#######################################################
+############### REVISION HISTORY ######################
+#######################################################
+06/04/2004 Bryan Whitehead. Version 0.50:
+This is the first beta version
+
+06/21/2004 Bryan Whitehead, Version 0.51:
+added multicast
+added private ioctls to set mac address and write eeprom (not tested)
+removed timeout function, which served no purpose anyway.
+
+07/09/2004 Bryan Whitehead, Version 0.52
+Improved Flow Control
+More Control on Link Management
+   the driver parameter link_mode is now a bit wise field that
+     specifies any combination of 4 or fewer link speeds
+     1=10HD,2=10FD,4=100HD,8=100FD
+     Still Autonegotiation is always used.
+
+07/13/2004 Bryan Whitehead, Version 0.53
+EEPROM has been fixed and tested.
+   If there is an EEPROM connected and loaded correctly, its
+     mac address will be loaded into the 11x
+Improved Flow Control again. Measured >10X improvement
+    in UDP_STREAM test with small packets.
+
+07/30/2004 Bryan Whitehead, Version 0.54
+Added many IOCTL codes for use with the command app, cmd911x.
+Added functions to the Platform interface
+	Platform_RequestDmaChannel
+	Platform_ReleaseDmaChannel
+Added Macros to Platform interface
+	PLATFORM_DEFAULT_RX_DMA
+	PLATFORM_DEFAULT_TX_DMA
+
+08/12/2004 Bryan Whitehead, Version 0.55
+Updated driver documentation
+Consolidated most driver source files into smsc911x.c
+Minor changes to the platform interface
+
+08/13/2004 Bryan Whitehead, Version 0.56
+Added Ioctl COMMAND_GET_CONFIGURATION
+  this command used with "cmd911x -cGET_CONFIG"
+  will display driver information, which is especially
+  useful if trace points have been disabled.
+
+08/24/2004 Bryan Whitehead, Version 0.57
+Implemented software patch to resynchronize Rx fifos after an
+overrun is detected.
+
+08/24/2004 Bryan Whitehead, Version 0.58
+Turned on LEDs which were accidentally turned off in version 0.57
+
+08/25/2004 Bryan Whitehead, Version 0.59
+Added extra driver context variables useful for debugging
+They can be accessed with the following command
+# cmd911x -cGET_CONFIG
+
+08/30/2004 Bryan Whitehead, Version 0.60
+Fixed bug in software patch (0.57) that caused the receiver to be turned
+off and not turned back on.
+Added symple packet filter to detect bad packets. If a bad packet
+is detected the driver will handle it like an overrun. That is, turn off
+receiver, empty fifos, clear fifo pointers(RX_DUMP), and turn on receiver.
+This method allows the driver to recover after a fifo synchronization fault.
+
+09/01/2004 Bryan Whitehead, Version 0.61
+This version was used for testing the patch. It was for internal purposes only
+
+09/03/2004 Bryan Whitehead, Version 0.62
+This version fixes some bugs in 0.60 and includes extra work around code
+to improve patch reliability.
+
+09/07/2004 Bryan Whitehead, Version 0.63
+Added IOCTLs for reading and writing to general memory
+
+09/13/2004 Bryan Whitehead, Version 0.64
+As the hardware issue is now fully understood, this patch includes
+a few changes to make the work around reliable in all situations.
+This version also has a the beginnings of new flow control feature,
+however this feature is disable for this version because it is
+still in progress.
+The build process has also changed. Now instead of building one
+debug driver, you can build a release and debug driver by choosing
+to include or not include the define USE_DEBUG. The release version
+enables activity LEDs, and removes all trace, warning, and assertion
+messages. The debug version enables GPIO signals, and enables trace,
+warning, and assertion messages.
+
+09/15/2004 Bryan Whitehead, Version 0.65
+Removed packet filter from 0.64
+Added non-Auto-Negotiate link modes. See description of the
+  link_mode driver parameter below
+
+09/28/2004 Bryan Whitehead, Version 0.66/0.67
+Added Rx flow control which is only turned on when the driver
+detects a lack of flow control in the higher layers.
+
+10/07/2004 Bryan Whitehead, Version 0.68
+Added support for Peakslite, and Polaris.
+Implemented support for Phy management tools
+  such as mii-diag and mii-tool.
+
+10/13/2004 Bryan Whitehead, Version 0.69
+Fixed some issues with Linux 2.6.
+
+10/18/2004 Bryan Whitehead, Version 0.70
+Added support for new chips 115, 116, 117.
+	NOTE: 115, and 116 may still require bus timing
+		adjustment.
+Disabled workaround when rev b is detected.
+
+10/20/2004 Bryan Whitehead, Version 0.71/0.72
+Added support for tasklets, which allow the bulk of the
+Rx processing to be done with out blocking interrupts for
+the rest of the system.
+
+10/27/2004 Bryan Whitehead, Version 1.00
+Tuned the PLATFORM_INT_DEAS for sh3 platforms to get better
+TCP performance. Bumped up version number to 1.00 because this
+will be the first official release.
+
+10/27/2004 Bryan Whitehead, Version 1.01
+Changed sh3 POLARIS platform to use cycle steal DMA
+
+11/11/2004 Bryan Whitehead, Version 1.02/1.03
+Changed tasklets to default to off, (tasklets=0)
+Testing has shown that tasklets are not stable yet. So changing the
+default allows us to release this version. The user may still turn
+tasklets on but does so at there own risk.
+
+11/11/2004 Bryan Whitehead, Version 1.04
+Fixed Tasklet Issue.
+Changed tasklets to be ON by default, (tasklets=1)
+
+11/18/2004 Bryan Whitehead, Version 1.05
+Improved software flow control.
+Updated platform code to handle all chips 118/117/116/115
+
+11/19/2004 Bryan Whitehead, Version 1.06
+Added support to provide separate flow control parameters
+  for 118/117 and 116/115. And the driver will use which
+  ever is appropriate.
+
+11/23/2004 Bryan Whitehead, Version 1.07
+Changed the driver so that PAUSE frames will be enable or disabled
+based on state of the local and remote pause bits, as specified in
+IEEE Standard 802.3, 2000 Edition, page 1360, Table 28B-3-Pause Resolution
+
+12/01/2004 Bryan Whitehead, Version 1.08
+Added support for external phy.
+To enable use of external phy use the follow driver parameter setting
+    ext_phy=1
+other wise the driver will use the internal phy as it always has before.
+
+12/01/2004 Bryan Whitehead, Version 1.09
+replace the ext_phy parameter with phy_addr which works as follows
+if(phy_addr==0xFFFFFFFF) {
+	//use internal phy
+} else if (phy_addr<32) {
+	//use external phy at address specified by phy_addr
+	//  if external phy can not be found use internal phy
+} else {
+	//attempt to auto detect external phy
+	//  if external phy can not be found use internal phy
+}
+
+02/14/2005 Bryan Whitehead, Version 1.11
+Automated the tuning procedure. See RX PERFORMANCE TUNING.
+Changed all register access to use a Macro instead of
+   a memory mapped structure. This should simplify porting,
+   if register access is ever done through IO space.
+Tuned all current platforms.
+Increased time out of Rx_FastForward to 500.
+Fixed faulty define TX_CMD_A_BUF_SIZE_
+Fixed faulty define TX_CMD_B_PKT_BYTE_LENGTH_
+Changed Phy reset to use PHY_BCR_RESET
+Cleaned driver with Lint tool
+Updated Rx_CountErrors
+	Only count length error if length/type field is set
+	If there is a CRC error don't count length error or
+	  multicast
+Changed access to Mac and Phy registers. Now requires only
+	one lock, MacPhyLock. This replaces the MacAccessLock,
+	PhyAccessLock, and RxSwitchLock.
+
+02/28/2005 Bryan Whitehead, Version 1.12
+Added date_code static constant
+
+02/28/2005 Bryan Whitehead, Version 1.13
+Added support for LAN9112
+
+03/21/2005 Bryan Whitehead, Version 1.13
+Updated Platforms ".h" file to include a version number in
+   the PLATFORM_NAME macro. This version number is platform
+   specific and independent of the common code version
+   number.
+Merged in STMICRO platform code to release tree
+
+03/22/2005 Bryan Whitehead, Version 1.13
+Updated platform code see st40.c for changes
+
+03/23/2005 Bryan Whitehead, Version 1.13
+Changed the format of the platform version to rN,
+  where N is the number of the platform revision.
+  This is visible in the PLATFORM_NAME macro.
+
+04/11/2005 Bryan Whitehead, Version 1.14
+Added Platform_CleanUp function, to be used in the event
+	that a particular platform should release resources
+	when the driver is unloaded from memory
+Moved register access and data port access from common
+	code to platform code. This is to support the
+	possibility that a big endian system may need to do
+	byte swapping.
+Changed Lan_SetRegDW to use Platform_SetRegDW
+Changed Lan_GetRegDW to use Platform_GetRegDW
+Changed Lan_ClrBitsDW to use Platform_S/GetRegDW
+Changed Lan_SetBitsDW to use Platform_S/GetRegDW
+Changed Tx_WriteFifo to Platform_WriteFifo
+Changed Rx_ReadFifo to Platform_ReadFifo
+Changed the way platform files are included.
+	Now the Macros PLATFORM_HEADER and PLATFORM_SOURCE
+	will define a string that is the path to those
+	header and source files.
+
+04/15/2005 Bryan Whitehead, Version 1.15
+Migrated source control to perforce.
+Merged platform ".h" and ".c" file to a single
+	platform ".c" file
+
+05/26/2005 M David Gelbman, Version 1.16
+Integrated Beacon PHY work-around into both Concord and
+Beacon versions.
+LED1 - 10/100 LED activity corrected to go OFF when link
+state goes DOWN.
+
+07/12/2005 Bryan Whitehead, Version 1.17
+Fixed issue where driver parameter phy_addr was not used.
+
+07/20/2005 Bryan Whitehead, Version 1.18
+Preserve Platform Data from close to reopen.
+
+07/26/2005 Phong Le
+Version 1.19 Make delay time for EEPROM longer.
+Fix bugs
+Bug#1 external/internal problem. These are bugs introduced
+when making LED work around and PHY work around.
+Bug#2 Fix bug when bring down a driver, then bring up, driver crashed.
+
+08/29/2005 - Phong Le
+Version 1.20 Integrate fixes for false statistic error count report.
+
+10/31/2005 - Phong Le
+Version 1.21 Integrate fixes for Rx Multicast work around.
+
+11/02/2005 - Phong Le
+Still version 1.21 Fix bugs for version 1.21.
+
+11/07/2005 - Phong Le
+Still version 1.21 Fix bugs for version 1.21.
+
+#######################################################
+#################### FILES ############################
+#######################################################
+readme.txt: this file
+
+smsc911x.c: Main driver source code file.
+       This file contains all platform independent code
+       It also includes platform dependent code based
+       on the following defines
+          USE_SH3
+          USE_PEAKS
+          USE_XSCALE
+       One of these should be defined in the build batch file
+        or makefile
+
+peaks.h
+xscale.h
+sh3.h
+      These files are platform dependent files. They define
+      the platform dependent structure, PLATFORM_DATA.
+      They also define some platform dependent constants for
+      use by smsc911x.c. see PLATFORM INTERFACE DESCRIPTIONS
+      below for more information
+
+peaks.c
+xscale.c
+sh3.c
+       These files implement the platform dependent functions
+       used by smsc911x.c. see PLATFORM INTERFACE DESCRIPTIONS
+       below for more information
+
+ioctl_11x.h
+      defines ioctl codes common between the driver(smsc911x.c)
+      and the helper application (cmd911x.c)
+
+cmd911x.c
+       This is the source code for the helper application.
+       It provides the means by which one can send any ioctl code
+       to the driver (smsc911x.c).
+
+buildp: This batch file is used for building the driver for the
+        peaks platform, and the helper application
+        usage: bash buildp
+
+builds: This batch file is used for building the driver for the
+        sh3 platform, and the helper application
+        usage: bash builds
+
+buildx: This batch file is used for building the driver for the
+        xscale platform, and the helper application
+        usage: bash buildx
+
+smsc911x.o: this is the driver binary obtained after building
+        smsc911x.c
+
+cmd911x: this is the helper application binary obtained after
+        building cmd911x.c
+
+lint.h:
+	This is a header file for use only with the lint tool.
+	It provides structure definitions and function declarations
+	used by the driver so the lint tool does not need to
+	scan the real header files. This is done because the real
+	header files generate too many error messages.
+
+cmd911x.Lnt:
+smsc911x-*.Lnt:
+	These are lint configuration files used with the lint tool
+
+cmd911x-Lnt.txt
+smsc911x-*-Lnt.txt:
+	These are lint output files created by the lint tool.
+
+COPYING:
+	This is a copy of the GNU GENERAL PUBLIC LICENSE
+
+
+############################################################
+################### FEATURES ###############################
+############################################################
+transmit and receive for pio and dma
+Automatic Flow control for Tx, and Rx
+Multicast capable
+Mac Address Management
+External Phy support
+
+
+############################################################
+################## DRIVER PARAMETERS #######################
+############################################################
+The following are load time modifiable driver parameters.
+They can be set when using insmod
+Example:
+# insmod smsc911x.o rx_dma=0 tx_dma=1 irq=5
+
+lan_base
+    specifies the physical base location in memory where the
+    LAN911x can be accessed. By default the location will be
+    choosen by Platform_Initialize.
+
+bus_width
+    specifies the bus_width to be configured by
+    Platform_Initialize. Must be set to either 16, or 32.
+    Any other value or by default Platform_Initialize will
+    attempt to autodetect the bus width
+
+
+link_mode
+    specifies the link mode used. Each bit has different meanings
+      bit 0, 0x01, 10Mbps Half Duplex,
+      bit 1, 0x02, 10Mbps Full Duplex,
+      bit 2, 0x04, 100Mbps Half Duplex,
+      bit 3, 0x08, 100Mbps Full Duplex,
+      bit 4, 0x10, Symmetrical Pause,
+      bit 5, 0x20, Asymmetrical Pause,
+      bit 6, 0x40, Auto Negotiate,
+
+    if bit 6 is set, then Auto Negotiation is used, and bits 0 through 5
+      define what modes are advertised.
+
+    if bit 6 is clear, then Auto Negotiation is not used, and bits 0
+      through 3 select which speed and duplex setting to use. In this case,
+      only the most significant set bit is used to set the speed and duplex.
+      Example, the following are bits 6 to 0, and the resulting setting
+      bits 6 5 4 3 2 1 0
+           0 x x 0 0 0 x, 10Mbps Half Duplex
+           0 x x 0 0 1 x, 10Mbps Full Duplex
+           0 x x 0 1 x x, 100Mbps Half Duplex
+           0 x x 1 x x x, 100Mbps Full Duplex
+
+    by default link_mode=0x7F which uses Auto Negotiation and advertises
+       all modes.
+
+irq
+    specifies the irq number to use. The default value is decided
+    by the platform layer with the macro PLATFORM_IRQ
+
+int_deas
+    specifies the interrupt deassertion period to be written to
+    INT_DEAS of INT_CFG register. The default value is decided by
+    the platform layer with the macro PLATFORM_INT_DEAS
+
+irq_pol
+    specifies the value to be written to IRQ_POL of INT_CFG register.
+    The default value is decided by the platform layer with the
+    macro PLATFORM_INT_POL.
+
+irq_type
+    specifies the value to be written to IRQ_TYPE of INT_CFG register.
+    The default value is decided by the platform layer with the
+    macro PLATFORM_IRQ_TYPE
+
+rx_dma
+    specifies the dma channel to use for receiving packets. It may
+    also be set to the following values
+        256 = TRANSFER_PIO
+            the driver will not use dma, it will use PIO.
+        255 = TRANSFER_REQUEST_DMA
+            the driver will call the Platform_RequestDmaChannel
+            to get an available dma channel
+    the default value is decided by the platform layer with the
+    macro PLATFORM_RX_DMA
+
+tx_dma
+    specifies the dma channel to use for transmitting packets. It may
+    also be set to the following values
+        256 = TRANSFER_PIO
+            the driver will not use dma, it will use PIO.
+        255 = TRANSFER_REQUEST_DMA
+            the driver will call the Platform_RequestDmaChannel
+            to get an available dma channel
+    the default value is decided by the platform layer with the
+    macro PLATFORM_TX_DMA
+
+dma_threshold
+    specifies the minimum size a packet must be for using DMA.
+    Otherwise the driver will use PIO. For small packets PIO may
+    be faster than DMA because DMA requires a certain amount of set
+    up time where as PIO can start almost immediately. Setting this
+    value to 0 means dma will always be used where dma has been enabled.
+
+    The default value is decided by the platform layer with the
+    macro PLATFORM_DMA_THRESHOLD
+
+mac_addr_hi16
+    Specifies the high word of the mac address. If it was not
+    specified then the driver will try to read the mac address
+    from the eeprom. If that failes then the driver will set it
+    to a valid value. Both mac_addr_hi16 and mac_addr_lo32 must be
+    used together or not at all.
+
+mac_addr_lo32
+    Specifies the low dword of the mac address. If it was not
+    specified then the driver will try to read the mac address
+    from the eeprom. If that failes then the driver will set it to
+    a valid value. Both mac_addr_hi16 and mac_addr_lo32 must be
+    used together or not at all.
+
+debug_mode
+    specifies the debug mode
+        0x01, bit 0 display trace messages
+        0x02, bit 1 display warning messages
+        0x04, bit 2 enable GPO signals
+    Trace messages will only display if the driver was compiled
+        with USE_TRACE defined.
+    Warning message will only display if the driver was compiled
+        with USE_WARNING defined.
+
+tx_fifo_sz
+    specifies the value to write to TX_FIFO_SZ of the
+    HW_CFG register. It should be set to a value from 0 to 15
+    that has been left shifted 16 bits.
+    The default value is 0x00050000UL
+
+afc_cfg
+    specifies the value to write to write to the AFC_CFG register
+    during initialization. By default the driver will choose a value
+    that seems resonable for the tx_fifo_sz setting. However it
+    should be noted that the driver has only be tested using the
+    default setting for tx_fifo_sz
+
+tasklets
+	A non zero value specifies that most of the receive work
+	should be done in a tasklet, thereby enabling other system interrupts.
+	A zero value specifies that all receive work is done in the ISR,
+	where interrupts are not enabled. A single burst of receive work has
+	been seen to take as long as 3 mS. It would not be friendly for this
+	driver to hold the CPU for that long, there for tasklets are enabled
+	by default. However there are some tests that measure a mild performance
+	drop when using tasklets, therefor this parameter is included so the
+	end user can choose to disable tasklets.
+	NOTE:10/29/2004: as of version 1.02 tasklets are disabled by default because
+	testing has not confirmed their stability. The user may still turn on
+	tasklets but does so at there own risk.
+	NOTE:11/05/2004: as of version 1.04 tasklets are enabled by default because
+	the issue observed before has been solved.
+
+phy_addr
+	The default value of 0xFFFFFFFF tells the driver to use the internal phy.
+	A value less than or equal to 31 tells the driver to use the external phy
+	    at that address. If the external phy is not found the internal phy
+	    will be used.
+	Any other value tells the driver to search for the external phy on all
+	    addresses from 0 to 31. If the external phy is not found the internal
+	    phy will be used.
+
+max_throughput
+    This is one of the software flow control parameters. It specifies the
+    maximum throughput in a 100mS period that was measured during an rx
+    TCP_STREAM test. It is used to help the driver decide when to activate
+    software flow control and what work load to maintain when flow control
+    is active. By default the driver will decide what value to use.
+    See RX PERFORMANCE TUNING.
+
+max_packet_count
+	This is one of the software flow control parameters. It specifies the
+	maximum packets counted in a 100mS period during an rx TCP_STREAM test.
+	It is used to help the driver decide when to activate software flow
+	control, and what work load to maintain when flow control is active.
+	By default the driver will decide what value to use.
+	See RX PERFORMANCE TUNING.
+
+packet_cost
+	This is one of the software flow control parameters. It specifies the
+	ideal packet cost. This allows the driver achieve the best performance
+	with both large and small packets, when flow control is active.
+	By default the driver will decide what value to use.
+	See RX PERFORMANCE TUNING.
+
+burst_period
+	This is one of the software flow control parameters. When flow control is active
+	the driver will do work in bursts. This value specifies the length of
+	the burst period in 100uS units. By default the driver will decide what value to
+	use. See RX PERFORMANCE TUNING.
+
+max_work_load
+	This is one of the software flow control parameters. It specifies the amount
+	of work the driver can do in a 100mS period. By default it is set as
+	max_work_load = max_throughput + (max_packet_count*packet_cost);
+	See RX PERFORMANCE TUNING.
+
+
+###########################################################
+################# RX PERFORMANCE TUNING ###################
+###########################################################
+
+Under most real world conditions traffic is flow controlled at
+the upper layers of the protocol stack. The most common example is
+TCP traffic. Even UDP traffic is usually flow controlled in the sense
+that the transmitter does not normally send continuous wirespeed traffic.
+When high level flow control is in use, it usually produces the
+best performance on its own with no intervention from the driver.
+But if high level flow control is not in use, then the driver will be
+working as fast as it can to receive packets and pass them up to
+the OS. In doing so it will hog CPU time and the OS may drop packets
+due to lack of an ability to process them. It has been found that
+during these heavy traffic conditions, throughput can be significantly
+improved if the driver voluntarily releases the CPU. Yes, this will
+cause more packets to be dropped on the wire but a greater number
+of packets are spared because the OS has more time to process them.
+
+As of version 1.05 and later, the driver implements a new flow control
+detection method that operates like this. If the driver detects an
+excessive work load in the period of 100mS, then the driver
+assumes there is insufficient flow control in use. Therefor it will
+turn on driver level flow control. Which significantly reduces the
+amount of time the driver holds the CPU, and causes more packets to
+be dropped on the wire. So a balancing/tuning, needs to be performed
+on each system to get the best performance under these conditions.
+If however the driver detects a tolerable work load in a period of
+100mS then it assumes flow control is being managed well and does
+not attempt to intervene by releasing the CPU. Under these conditions
+the driver will naturally release the CPU to the OS, since the system
+as a whole is keeping up with traffic.
+
+Now that the background has been discussed, its necessary to talk
+about how the driver implements flow control. The method used is a
+work load model. This is similar but not exactly the same as
+throughput. Work load is the sum of all the packet sizes plus a constant
+packet cost for each packet. This provides more balance. For instance
+a stream of max size packets will give a large throughput with fewer
+packets, while a stream of min size packets will give a low throughput
+with many packets. Adding a per packet cost to the work load allows these
+two cases to both activate and manage flow control. If work load only
+counted packet sizes then only a stream of max size packets would
+activate flow control, while a stream of min size packets would not.
+
+There are five primary parameters responsible for managing flow control.
+They can be found in the FLOW_CONTROL_PARAMETERS structure.
+They are
+	MaxThroughput, Represents the maximum throughput measured in a
+		100mS period, during an rx TCP_STREAM test.
+	MaxPacketCount, Represents the maximum packet count measured in a
+		100mS period, during an rx TCP_STREAM test.
+	PacketCost, Represents the optimal per packet cost
+	BurstPeriod, Represents the optimal burst period in 100uS units.
+	IntDeas, This is the value for the interrupt deassertion period.
+	    It is set to INT_DEAS field of the INT_CFG register.
+The driver will call Platform_GetFlowControlParameters to get these
+
+parameters for the specific platform and current configuration.
+These parameters must be carefully choosen by the driver writer so
+optimal performance can be achieved. Therefor it is necessary to
+describe how the driver uses each parameter.
+
+The first three parameters MaxThroughput, MaxPacketCount, and PacketCost,
+are used to calculate the secondary parameter, MaxWorkLoad according
+to the following formula.
+	MaxWorkLoad=MaxThroughput+(MaxPacketCount*PacketCost);
+MaxWorkLoad represents the maximum work load the system can handle during
+a 100mS period.
+	The driver will use MaxWorkLoad and BurstPeriod to determine
+BurstPeriodMaxWorkLoad, which represents the maximum amount of work the
+system can handle during a single burst period. It is calculated as follows
+	BurstPeriodMaxWorkLoad=(MaxWorkLoad*BurstPeriod)/1000;
+
+Every 100mS the driver measures the CurrentWorkLoad by the following
+algorithm.
+
+	At the beginning of a 100mS period
+		CurrentWorkLoad=0;
+
+	During a 100mS period CurrentWorkLoad is adjusted when a packet
+	arrives according to the following formula.
+		CurrentWorkLoad+=PacketSize+PacketCost;
+
+	At the end of a 100mS period
+		if(CurrentWorkLoad>((MaxWorkLoad*(100+ActivationMargin))/100))
+		{
+			if(!FlowControlActive) {
+				FlowControlActive=TRUE;
+				//Do other flow control initialization
+				BurstPeriodCurrentWorkLoad=0;
+			}
+		}
+		if(CurrentWorkLoad<((MaxWorkLoad*(100-DeactivationMargin))/100))
+		{
+			if(FlowControlActive) {
+				FlowControlActive=FALSE;
+				//Do other flow control clean up
+				Enable Receiver interrupts
+			}
+		}
+
+During periods where flow control is active, that is
+FlowControlActive==TRUE, the driver will manage flow control by the
+following algorithm.
+
+	At the end/beginning of a burst period
+		if(BurstPeriodCurrentWorkLoad>BurstPeriodMaxWorkLoad) {
+			BurstPeriodCurrentWorkLoad-=BurstPeriodMaxWorkLoad;
+		} else {
+			BurstPeriodCurrentWorkLoad=0;
+		}
+		Enable Receiver Interrupts;
+
+	When checking if a packet arrives
+		if(BurstPeriodCurrentWorkLoad<BurstPeriodMaxWorkLoad) {
+			//check for packet normally
+			BurstPeriodCurrentWorkLoad+=PacketSize+PacketCost;
+		} else {
+			//Do not check for packet, but rather
+			//  behave as though there is no new packet.
+			Disable Receiver interrupts
+		}
+
+This algorithm will allow the driver to do a specified amount
+of work and then give up the CPU until the next burst period. Doing this
+allows the OS to process all the packets that have been sent to it.
+
+So that is generally how the driver manages flow control. For more
+detail you can refer to the source code. Now it is necessary to
+describe the exact method for obtaining the optimal flow control
+parameters.
+
+When obtaining the optimal flow control parameters it is important
+to note the configuration you are using. Generally there are 8
+configurations for each platform. They involve the following options
+	DMA or PIO
+	16 bit or 32 bit
+	118/117/112 or 116/115
+Some platforms may only use 16 bit mode. While other platforms may
+have a selectable clock rate. What ever the options are, every combination
+should be identifiable, and Platform_GetFlowControlParameters should be
+implemented to provide the correct flow control parameters. It is important
+to be sure that the carefully selected parameters are applied to the
+same configuration used during tuning.
+
+Flow control tuning requires a publically available program called
+netperf, and netserver, which are a client/server pair. These are built
+with the same make file and can be found on the web.
+
+Fortunately, as of version 1.10, smsc911x and cmd911x supports an automated
+tuning mechanism. The process takes about one hour and can be initiated as
+follows
+
+AUTOMATED TUNING:
+
+Choose the configuration you want to tune.
+That is choose between
+  DMA or PIO,
+  16 bit or 32 bit,
+  118/117/112 or 116/115,
+Make sure there is a direct connection between the target platform
+and the host platform. Do not use a hub, or switch. The target
+platform is the platform that will run this driver. The host platform
+should be a PC easily capable of sending wire speed traffic.
+
+Install the driver on your target platform with your choosen configuration.
+	insmod smsc911xd.o
+	ifconfig eth1 192.1.1.118
+load servers on target platform
+	netserver
+	cmd911x -cSERVER
+On host platform, make sure the netperf executable is
+located in the same directory and the cmd911x executable. While in that
+directory run the following.
+	cmd911x -cTUNER -H192.1.1.118
+This command, if successful, will begin the one hour tuning process.
+At the end you will get a dump of the optimal flow control parameters.
+The key parameters needed are
+    MaxThroughput
+    MaxPacketCount
+    PacketCost
+    BurstPeriod
+    IntDeas
+These value must be assigned in Platform_GetFlowControlParameters to
+	flowControlParameters->MaxThroughput
+	flowControlParameters->MaxPacketCount
+	flowControlParameters->PacketCost
+	flowControlParameters->BurstPeriod
+	flowControlParameters->IntDeas
+Make sure the Platform_GetFlowControlParameters checks the current configuration
+and will only set those parameters if the current configuration matches the
+configuration you tuned with.
+
+Next start over but choose a configuration you haven't already tuned.
+
+
+MANUAL TUNING:
+In the off chance that the automated tuning fails to work properly, you may
+use the following manual tuning procedure.
+
+STEP 1:
+	Select a configuration. That is choose between DMA or PIO, 16 bit or
+	32 bit, 118/117/112 or 116/115.
+	Make sure there is a direct connection between the target platform
+	and the host platform. Do not use a hub, or switch. The target
+	platform is the platform that will run this driver. The host platform
+	should be a PC easily capable of sending wire speed traffic.
+
+STEP 2:
+	load the driver on the target platform with the following commands
+		insmod smsc911x.o max_work_load=0 int_deas=ID
+		ifconfig eth1 192.1.1.118
+		netserver
+	ID will be replated by the number you will be adjusting to obtain the
+		best throughput score in STEP 3, initially a goog number to start
+		with is 0.
+
+STEP 3:
+	On  the host platform run the following command
+		netperf -H192.1.1.118
+	Examine the output. The goal is to maximize the number on the
+		Throughput column.
+	If you are satisfied with the throughput remember the ID number
+		you used and move on to STEP 4.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc911x
+		goto STEP 2 and use a different value for ID
+
+
+STEP 4:
+	unload the driver with
+		ifconfig eth1 down
+		rmmod smsc911x
+	load driver on the target platform with the following commands
+		insmod smsc911x.o max_work_load=0 int_deas=ID
+		ifconfig eth1 192.1.1.118
+		netserver
+	NOTE: the driver will be making traffic measurements. Therefor
+		it is important not to insert any steps between 4 and 6.
+
+STEP 5:
+	run netperf on the host platform
+		netperf -H192.1.1.118
+	repeat two more times.
+
+STEP 6:
+	on target platform run the following
+		cmd911x -cGET_FLOW
+	Many variables will be displayed. Two of them are measurements we need.
+	You can set the following two parameters as follows.
+		MaxThroughput  = RxFlowMeasuredMaxThroughput;
+		MaxPacketCount = RxFlowMeasuredMaxPacketCount;
+
+STEP 7:
+	Unload the driver on target platform with
+		ifconfig eth1 down
+		rmmod smsc911x
+	Apply the parameters obtained in STEP 6 and 2/3 to the appropriate location,
+		given the configuration choosen in STEP 1, in
+		Platform_GetFlowControlParameters. The parameters for your
+		choosen configuration should be set as follows
+			MaxThroughput = (RxFlowMeasuredMaxThroughput from step 6);
+			MaxPacketCount = (RxFlowMeasuredMaxPacketCount from step 6);
+			PacketCost=0; //temporarily set to 0
+			BurstPeriod=100; //temporarily set to 100
+			IntDeas= (ID from step 2/3).
+	recompile driver.
+
+STEP 8:
+	Again make sure your still using the same configuration you selected
+		in STEP 1.
+	Load recompiled driver on target platform with the following commands
+		insmod smsc911x.o burst_period=BP
+		ifconfig eth1 192.1.1.118
+	BP will be replaced by the number you will be adjusting to obtain the
+		best throughput score in STEP 9, initially a good number to
+		start with is 100.
+
+STEP 9:
+	On Host platform run the following command
+		netperf -H192.1.1.118 -tUDP_STREAM -l10 -- -m1472
+	Examine the output.	The goal is to maximize the lower
+		number on the Throughput column.
+	If you are satisfied with the throughput remember the BP number
+		you used and move on to STEP 10.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc911x
+		goto STEP 8 and use a different value for BP.
+
+STEP 10:
+	unload the driver on target platform
+		ifconfig eth1 192.1.1.118 down
+		rmmod smsc911x
+	Again make sure your still using the same configuration you selected
+		in STEP 1.
+	Load the recompiled driver from STEP 7 on target platform with
+		insmod smsc911x.o burst_period=BP packet_cost=PC
+		ifconfig eth1 192.1.1.118
+	BP will be replaced with the value you settled on in STEP 8/9.
+	PC will be replaced by the number you will be adjusting to
+		obtain the best throughput score in STEP 11, typically PC ends
+		up somewhere between 100 and 200.
+
+STEP 11:
+	On Host platform run the following command
+		netperf -H192.1.1.118 -tUDP_STREAM -l10 -- -m16
+	Examine the output. The goal is to maximize the lower
+		number on the Throughput column.
+	If you are satisfied with the throughput remember the PC number
+		you used and move on the STEP 12.
+	If you would like to try improving the throughput
+		unload the driver on the target with
+			ifconfig eth1 down
+			rmmod smsc911x
+		goto STEP 10 and use a different value for PC
+
+STEP 12:
+	Apply the parameters to the appropriate location, given the
+	configuration choosen in step 1, in Platform_GetFlowControlParameters.
+		PacketCost= (PC from step 10/11);
+		BurstPeriod= (BP from step 8/9);
+	recompile driver.
+	Now the values you applied will be the default values used when that
+		same configuration is used again.
+	Goto STEP 1 and choose a configuration you have not yet tuned.
+
+###########################################################
+################### TESTED PLATFORMS ######################
+###########################################################
+This driver has been tested on the following platforms.
+The driver was loaded as a module with the following command
+line.
+
+	insmod smsc911x.o
+
+===========================================================
+Platform:
+	SH3 SE01
+Motherboard:
+	Hitachi/Renesas, MS7727SE01/02
+SMSC LAN911x Board:
+	LAN9118 FPGA DEV BOARD, ASSY 6337 REV A
+LAN911x:
+	LAN9118
+Linux Kernel Version:
+	2.4.18
+Driver Resources:
+	LAN_BASE=0xB4000000
+	IRQ=8
+
+===========================================================
+Platform:
+	XSCALE
+Motherboard:
+	Intel Corp, MAINSTONE II MAIN BOARD REV 2.1
+SMSC LAN911x Board:
+	LAN9118 XSCALE FPGA DEV BOARD, ASSY 6343 REV A
+LAN911x:
+	LAN9118
+Linux Kernel Version:
+	2.4.21
+Driver Resources:
+	LAN_BASE=0xF2000000
+	IRQ=198
+
+###########################################################
+##################### RX CODE PATH ########################
+###########################################################
+The purpose of this section is to describe how the driver
+receives packets out of the LAN911x and passes them to the
+Linux OS. Most functions in the Rx code path start with Rx_
+
+During initialization (Smsc911x_open) the function
+Rx_Initialize is called. This call enables interrupts for
+receiving packets.
+
+When a packet is received the LAN911x signals an interrupt,
+which causes Smsc911x_ISR to be called. The Smsc911x_ISR function
+is the main ISR which passes control to various handler routines.
+One such handler routine that gets called is Rx_HandleInterrupt.
+
+Rx_HandleInterrupt first checks to make sure the proper
+interrupt has been signaled (INT_STS_RSFL_). If it has not
+it returns immediately. If it has been signaled then it decides
+if it should use PIO or DMA to read the data.
+
+In both cases the process is like this
+    An Rx status DWORD is read using Rx_PopRxStatus
+    If there is an error
+        the packet is purged from the LAN911x
+            data fifo with Rx_FastForward
+    If there is no error
+        an sk_buff is allocated to receive the data
+        The data is read into the sk_buff using PIO or DMA.
+        After data is read the sk_buff is sent to linux using
+            Rx_HandOffSkb
+    The process continues until Rx_PopRxStatus returns 0
+
+DMA is a little more complicated than PIO because it is written
+to take advantage of concurrent processing. To get as much useful
+work done as possible while a DMA operation is in progress.
+Therefor DMA has the best performance boost when there are
+several packets to service on a single call to Rx_HandleInterrupt
+
+This is the purpose of the INT_DEAS field of INT_CFG. When that
+field is set (using the driver parameter int_deas or platform macro
+PLATFORM_INT_DEAS) it forces interrupts to be paced, so more packets
+can arrive before a single call to the ISR.
+
+The LAN911x has been proven to receive at about 94Mbps on the
+xscale platform. However other platforms run slower and require
+some means of flow control. Rx flow control is built into the
+LAN911x. It is configured by writing the AFC_CFG register. The
+user can set this value at load time using the afc_cfg parameter.
+
+Basically it works like this. If the Rx Data fifo fills up to
+a level specified by AFC_HI in AFC_CFG then the LAN911x will begin
+flow control. If the link is half duplex then the LAN911x will
+exert back pressure by forcing a collision on the wire when a
+packet is arriving. This will cause the sender to retransmit later.
+If the link is full duplex then the LAN911x will transmit a Pause
+frame requesting the partner to stop sending packets. Then when
+the Rx Data fifo drops to AFC_LO in AFC_CFG then the LAN911x will
+stop exerting back pressure in half duplex, or in full duplex it
+will transmit another pause frame that lets the partner know it
+can start sending packets again. See the LAN911x specification
+for more information. But all of this is done with out the help
+of the driver.
+
+Still the driver must participate in Rx flow control because of
+platform speed limitations. Rx flow control in the driver is handled
+in the functions Rx_HandOffSkb, and Rx_PopRxStatus. The function
+Rx_HandOffSkb calls netif_rx which returns a congestion level.
+If any congestion is detected then Rx_HandOffSkb will set the
+RxCongested flag. The next time the driver calls Rx_PopRxStatus it
+will see the RxCongested flag is set and will not Pop a new status
+off the RX_STATUS_FIFO, but rather it will disable and re-enable
+interrupts. This action will cause the interrupt deassertion interval
+to begin. The ISR will return, and not be called again until the
+deassertion interval has expired. This gives CPU time to linux so it
+can handle the packets that have been sent to it and lower the
+congestion level. In this case the driver voluntarily stops
+servicing packets, which means the RX Data Fifo will fill up.
+Eventually the hardware flow control will start up to slow down the
+sender. Many times this will still result in an overflow of the
+Rx Data fifo and packets will be lost under heavy traffic conditions.
+But if the driver did not release the CPU to linux, then linux would
+drop almost all the packets. So it is better to let the packets be
+lost on the wire, rather than over consuming resources to service
+them.
+
+
+###########################################################
+##################### TX CODE PATH ########################
+###########################################################
+When Linux wants to transmit a packet it will call
+Smsc911x_hard_start_xmit. This function performs some checks
+then calles Tx_SendSkb to send the packet.
+
+Tx_SendSkb works with PIO or DMA depending on the selected
+mode.
+
+The basic sequence is this.
+First Write TxCmdA and TxCmdB into the TX_DATA_FIFO.
+Then Write the packet data into the TX_DATA_FIFO with
+    adjustments for offset and end alignment.
+Then free the skb using dev_kfree_skb
+
+DMA is a little more complicated than PIO because it is written
+to take advantage of concurrent processing. To get as much useful
+work done as possible while a DMA operation is in progress.
+Therefor DMA has the best performance boost when there are
+a burst of large packets to transmit.
+
+Tx Flow control works like this.
+If the free space in the TX_DATA_FIFO after writing the data
+is determined to be less than about the size of one full size
+packet then the driver can't be sure it can transmit the next
+packet without overflowing. Therefor the driver turns off the
+Tx queue by calling Tx_StopQueue. Then it prepares an interrupt
+to be signaled when the free space in the TX_DATA_FIFO has risen
+to an acceptable level. When that level of free space has been
+reached the interrupt is signaled and the handler will turn on
+the Tx queue by calling Tx_WakeQueue
+
+Statistic counters are updated after about every 30 packets or
+when linux calls Smsc911x_get_stats
+
+###########################################################
+########## PLATFORM INTERFACE DESCRIPTIONS ################
+###########################################################
+The platform interface provides a platform independent
+interface for the driver (smsc911x.c) This interface
+simplifies the task of porting the driver to other platforms.
+
+All functions that start with Platform_ are part of the
+platform interface. All macros that start with PLATFORM_
+are part of the platform interface.
+
+Below are descriptions of PLATFORM_ macros.
+for examples of usage see sh3.h, xscale.h or peaks.h
+
+PLATFORM_CACHE_LINE_BYTES
+      This macro is set to the size of a cache line in bytes.
+      It is used with dma operations to insure cache line
+          alignment which generally improves dma efficiency
+      It is also used to insure that the IP header of received
+          packets will be aligned on a cache line boundary
+
+PLATFORM_IRQ_POL
+      This macro is set to 0 or 1 and indicates the default
+      value the driver will use when setting the IRQ_POL bit
+      of the INT_CFG register. The user can override this
+      value at load time by setting the driver parameter irq_pol.
+
+PLATFORM_IRQ_TYPE
+      This macro is set to 0 or 1 and indicates the default
+      value the driver will use when setting the IRQ_TYPE bit
+      of the INT_CFG register. The user can override this
+      value at load time by setting the driver parameter irq_type.
+
+PLATFORM_IRQ
+      This macro indicates the default irq the driver will
+      use when requesting an ISR.
+      The user can override this value at load time by setting
+      the driver parameter irq.
+
+PLATFORM_RX_DMA
+      This macro indicates the default dma channel to use for
+      receiving packets. It may also be set to the following
+      macros
+         TRANSFER_PIO = 256
+             the driver will not use dma. It will use PIO.
+         TRANSFER_REQUEST_DMA = 255
+             the driver will call the Platform_RequestDmaChannel
+             to get an available dma channel
+      The user can override this value at load time by setting
+      the driver parameter rx_dma.
+
+PLATFORM_TX_DMA
+      This macro indicates the default dma channel to use for
+      transmitting packets. It may also be set to the following
+      macros
+         TRANSFER_PIO = 256
+             the driver will not use dma. It will use PIO.
+         TRANSFER_REQUEST_DMA = 255
+             the driver will call the Platform_RequestDmaChannel
+             to get an available dma channel
+      The user can override this value at load time by setting
+      the driver parameter
+
+PLATFORM_DMA_THRESHOLD
+      This macro indicates the default value for dma_threshold.
+      This value specifies the minimum size a packet must be
+      for using DMA. Otherwise the driver will use PIO. For small
+      packets PIO may be faster than DMA because DMA requires a
+      certain amount of set up time where as PIO can start almost
+      immediately. Setting this value to 0 means dma will always
+      be used where dma has been enabled.
+
+The platform specific header files (sh3.h, and xscale.h)
+must also define the platform specific data structure
+PLATFORM_DATA, and its pointer PPLATFORM_DATA.
+this structure is passed to most Platform_ functions. It
+allows the platform layer to maintain its own context information.
+
+The following are descriptions of the Platform_ functions
+for examples of usage see the files sh3.c, or xscale.c
+
+/************************************************************
+FUNCTION: Platform_Initialize
+PARAMETERS:
+	platformData, pointer to platform specified data structure
+	dwLanBase,	user specified physical base address for the LAN911x
+		= 0, let this function decide
+	dwBusWidth,
+		= 16, user specifies 16 bit mode operation, bypass autodetection
+		= 32, user specifies 32 bit mode operation, bypass autodetection
+		= any other value, driver should auto detect bus width
+DESCRIPTION:
+    This is the first Platform_xxx function that will be called
+	This function will initialize the PLATFORM_DATA structure.
+	This function will prepare the system to access the LAN911x.
+	It will properly initialize the bus and return the virtual
+	memory location where the LAN911x can be access.
+RETURN VALUE:
+	0 = failed,
+	any other value is the virtual base address where the LAN911x
+	   can be accessed
+************************************************************/
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,
+	DWORD dwBusWidth);
+
+/***********************************************************
+FUNCTION: Platform_CleanUp
+PARAMETERS:
+	platformData, pointer to platform specified data structure
+DESCRIPTION:
+	This function is called so the platform layer can clean up
+	any resources that may have been acquired in Platform_Initialize.
+	If Platform_Initialize returned 0, then this function will
+	not be called.
+***********************************************************/
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData);
+
+/************************************************************
+FUNCTION: Platform_SetRegDW
+PARAMETERS:
+	DWORD dwLanBase, the virtual base address returned by
+			Platform_Initialize
+	DWORD dwOffset, the byte offset into the Lan address space
+			where the register of interest is located.
+			dwOffset should be DWORD aligned.
+	DWORD dwVal, the value to write to the register of interest
+DESCRIPTION:
+	This function is used to provide a platform independent
+		method of register access. It allows platform code
+		for big endian systems to do byte swapping, if necessary.
+	Because this function is very simple, it is recommended that
+		it should be implemented as inline or as a macro.
+RETURN VALUE: void
+************************************************************/
+inline void Platform_SetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset,
+	DWORD dwVal);
+
+/************************************************************
+FUNCTION: Platform_GetRegDW
+PARAMETERS:
+	DWORD dwLanBase, the virtual base address returned by
+			Platform_Initialize
+	DWORD dwOffset, the byte offset into the Lan address space
+			where the register of interest is located.
+			dwOffset should be DWORD aligned.
+DESCRIPTION:
+	This function is used to provide a platform independent
+		method of register access. It allows platform code
+		for big endian systems to do byte swapping if necessary.
+	Because this function is very simple, it is recommended that
+		it should be implemented as inline or as a macro.
+RETURN VALUE:
+	The DWORD value read from the register of interest;
+************************************************************/
+inline DWORD Platform_GetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset);
+
+/***********************************************************
+FUNCTION: Platform_Is16BitMode
+PARAMETER:
+	platformData, pointer to platform specific data structure
+RETURN VALUE:
+	TRUE if the platform is configured for 16 bit mode
+	FALSE if the platform is configured for 32 bit mode
+NOTE: this function is not currently used.
+***********************************************************/
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData);
+
+/************************************************************
+FUNCTION: Platform_RequestIRQ
+DESCRIPTION:
+    Used to request and set up the ISR
+PARAMETERS:
+	platformData, pointer to platform specific data structure
+	dwIrq,
+	  = 0xFFFFFFFF, let this function decide what IRQ to use
+	  = any other value is the IRQ requested by the user
+	pIsr, pointer to the ISR, to be registered.
+	dev_id, pointer to the driver specific structure
+	   used when registering the ISR with Linux
+RETURN VALUE:
+    TRUE if successful
+	FALSE is unsuccessful
+************************************************************/
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	void (*pIsr)(int irq,void *dev_id,struct pt_regs *regs),
+	void *dev_id);
+
+/***********************************************************
+FUNCTION: Platform_CurrentIRQ
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+RETURN VALUE:
+	The IRQ number actually used by Platform_RequestIRQ
+	  This may be different than the requested IRQ
+***********************************************************/
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData);
+
+/**********************************************************
+FUNCTION: Platform_FreeIRQ
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+DESCRIPTION:
+    uninstalls the ISR installed from Platform_RequestIRQ
+**********************************************************/
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData);
+
+/*********************************************************
+FUNCTION: Platform_IsValidDmaChannel
+PARAMETERS:
+	dwDmaCh, the dma channel number to test for validity
+DESCRIPTION:
+    This function is used to test the validity of the
+    channels request with parameters rx_dma, and tx_dma
+RETURN VALUE:
+	TRUE if the dma channel may be used
+	FALSE if the dma channel may not be used
+NOTE: this function does not use PLATFORM_DATA because
+    it is called before the driver allocates memory for
+    PLATFORM_DATA
+*********************************************************/
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh);
+
+/********************************************************
+FUNCTION: Platform_DmaInitialize
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	dwDmaCh, the Dma channel to initialize
+RETURN VALUE:
+	TRUE, on Success
+	FALSE, on Failure
+********************************************************/
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh);
+
+/********************************************************
+FUNCTION: Platform_DmaDisable
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	dwDmaCh, the Dma channel to disable
+RETURN VALUE:
+	TRUE on success
+	FALSE on failure
+********************************************************/
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/*******************************************************
+FUNCTION: Platform_CacheInvalidate
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	pStartAddress, the starting virtual address of the region
+	dwLengthInBytes, the length in bytes of the region to invalidate
+DESCRIPTION:
+	Invalidates a specified memory region if it exists in cache.
+	  Does not necessarily write the data back to memory.
+*******************************************************/
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+
+/*******************************************************
+FUNCTION: Platform_CachePurge
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	pStartAddress, the starting virtual address of the region
+	dwLengthInBytes, the length in bytes of the region to purge
+DESCRIPTION:
+    Writes back data to a specified memory region if it
+      exists in cache.
+*******************************************************/
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+
+/******************************************************
+FUNCTION: Platform_RequestDmaChannel
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+DESCRIPTION:
+	If the OS supports Dma Channel allocation then this function
+	  will use that support to reserve a dma channel.
+	If the OS does not support Dma Channel allocation, or a
+	  channel can not be reserved then this function
+	  will return TRANSFER_PIO
+RETURN VALUE:
+	returns the DMA channel number that has been reserved
+	if a channel can not be reserved then return TRANSFER_PIO
+******************************************************/
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData);
+
+/*****************************************************
+FUNCTION: Platform_ReleaseDmaChannel
+PARAMETERS:
+	platformData, pointer to the platform specific data structure
+	dwDmaChannel, the Dma channel number to be released
+DESCRIPTION:
+	Releases the DMA channel specified by dwDmaChannel,
+	  which was previously returned by Platform_RequestDmaChannel
+    If the OS supports it this function will notify the OS
+	  that the dma channel is free to be used by other devices
+******************************************************/
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel);
+
+/*****************************************************
+FUNCTION: Platform_DmaStartXfer
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+    pDmaXfer, pointer to DMA_XFER structure
+	    which describes the requested transfer
+DESCRIPTION:
+    Begins a new dma transfer,
+	Should not be called if another transfer is in progress
+RETURN VALUE:
+    TRUE if dma has begun the transfer
+	FALSE for any error
+******************************************************/
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer);
+
+/*******************************************************
+FUNCTION: Platform_DmaGetDwCnt
+PARAMETERS:
+    platformData, pointer to the platform specific data structure
+	dwDmaCh, Dma channel number
+RETURN VALUE:
+    0, if the DMA channel is ready to handle another
+	   request from Platform_DmaStartXfer
+   non zero, is the number of DWORDS left for the
+       dma channel to transfer
+*******************************************************/
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/******************************************************
+FUNCTION: Platform_DmaComplete
+PARAMETERS:
+    platformData, pointer to platform specific data structure
+	dwDmaCh, dma channel number
+DESCRIPTION:
+	Waits for the specified dma channel to finish
+	transfering data. Upon return the dma channel should
+	be ready to handle another request from
+	Platform_DmaStartXfer
+	This function should be the same as waiting for
+	Platform_DmaGetDwCnt to return 0
+******************************************************/
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+
+/*****************************************************
+FUNCTION: Platform_GetFlowControlParameters
+PARAMETERS:
+	platformData, pointer to platform specific data structure
+	flowControlParameters, pointer to structure which receives
+	     the flow control parameters.
+    useDma, flag which specifies whether to get flow control
+         parameters for PIO(FALSE) or DMA(TRUE).
+DESCRIPTION:
+	fills the structure pointed to by flowControlParameters,
+	with the appropriate flow control parameters for the
+	current combination of ((118/117/112) or (116/115)),
+	(16 or 32 bit mode), and (PIO or DMA).
+******************************************************/
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma);
+
+/******************************************************
+FUNCTION: Platform_WriteFifo
+PARAMETERS:
+	DWORD dwLanBase, the lan base address
+	DWORD * pdwBuf, a pointer to and array of DWORDs to
+		be written to the TX_DATA_FIFO
+	DWORD dwDwordCount, the number of DWORDs in the dword
+		array pointed to by pdwBuf
+DESCRIPTION:
+	This function is during PIO transfers to write packet
+	data to the TX_DATA_FIFO. This function was made
+	platform dependent to allow platforms to perform
+	byte swapping on big endian systems, if necessary.
+******************************************************/
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD * pdwBuf,
+	DWORD dwDwordCount);
+
+/******************************************************
+FUNCTION: Platform_ReadFifo
+PARAMETERS:
+	DWORD dwLanBase, the lan base address
+	DWORD * pdwBuf, a pointer to and array of DWORDs which
+		will be read from the RX_DATA_FIFO
+	DWORD dwDwordCount, the number of DWORDs in the dword
+		array pointed to by pdwBuf
+DESCRIPTION:
+	This function is during PIO transfers to read packet
+	data from the RX_DATA_FIFO. This function was made
+	platform dependent to allow platforms to perform
+	byte swapping on big endian systems, if necessary.
+******************************************************/
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD * pdwBuf,
+	DWORD dwDwordCount);
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/smsc911x.c linux-2.6.17.8-sh/drivers/net/smsc_911x/smsc911x.c
--- linux-2.6.17.8/drivers/net/smsc_911x/smsc911x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/smsc911x.c	2006-08-23 13:29:50.756875000 +0100
@@ -0,0 +1,5424 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: smsc911x.c
+ *   see readme.txt for programmers guide
+ */
+
+
+#ifndef __KERNEL__
+#	define __KERNEL__
+#endif
+
+#ifdef USING_LINT
+#include "lint.h"
+#else //not USING_LINT
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/version.h>
+
+#endif //not USING_LINT
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#ifndef USE_ST40_STMICRO
+typedef void irqreturn_t;
+#endif
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#else
+#define LINUX_2_6_OR_NEWER
+#endif
+
+#ifdef USE_DEBUG
+//select debug modes
+#define USE_WARNING
+#define USE_TRACE
+#define USE_ASSERT
+#endif //USE_DEBUG
+
+#define	USE_LED1_WORK_AROUND	// 10/100 LED link-state inversion
+#define	USE_PHY_WORK_AROUND		// output polarity inversion
+
+typedef long TIME_SPAN;
+#define MAX_TIME_SPAN	((TIME_SPAN)(0x7FFFFFFFUL))
+typedef unsigned long DWORD;
+typedef unsigned short WORD;
+typedef unsigned char BYTE;
+typedef unsigned char BOOLEAN;
+#define TRUE	((BOOLEAN)1)
+#define FALSE	((BOOLEAN)0)
+
+#define HIBYTE(word)  ((BYTE)(((WORD)(word))>>8))
+#define LOBYTE(word)  ((BYTE)(((WORD)(word))&0x00FFU))
+#define HIWORD(dWord) ((WORD)(((DWORD)(dWord))>>16))
+#define LOWORD(dWord) ((WORD)(((DWORD)(dWord))&0x0000FFFFUL))
+
+#define TRANSFER_PIO			(256UL)
+#define TRANSFER_REQUEST_DMA	(255UL)
+//these are values that can be assigned to
+//PLATFORM_RX_DMA
+//PLATFORM_TX_DMA
+// in addition to any specific dma channel
+
+/*******************************************************
+* Macro: SMSC_TRACE
+* Description:
+*    This macro is used like printf.
+*    It can be used anywhere you want to display information
+*    For any release version it should not be left in
+*      performance sensitive Tx and Rx code paths.
+*    To use this macro define USE_TRACE and set bit 0 of debug_mode
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_TRACE(const char * a, ...);
+#else //not USING_LINT
+#ifdef USE_TRACE
+extern DWORD debug_mode;
+#ifndef USE_WARNING
+#define USE_WARNING
+#endif
+#	define SMSC_TRACE(msg,args...)			\
+	if(debug_mode&0x01UL) {					\
+		printk("SMSC: " msg "\n", ## args);	\
+	}
+#else
+#	define SMSC_TRACE(msg,args...)
+#endif
+#endif //not USING_LINT
+
+/*******************************************************
+* Macro: SMSC_WARNING
+* Description:
+*    This macro is used like printf.
+*    It can be used anywhere you want to display warning information
+*    For any release version it should not be left in
+*      performance sensitive Tx and Rx code paths.
+*    To use this macro define USE_TRACE or
+*      USE_WARNING and set bit 1 of debug_mode
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_WARNING(const char * a, ...);
+#else //not USING_LINT
+#ifdef USE_WARNING
+extern DWORD debug_mode;
+#ifndef USE_ASSERT
+#define USE_ASSERT
+#endif
+#	define SMSC_WARNING(msg, args...)				\
+	if(debug_mode&0x02UL) {							\
+		printk("SMSC_WARNING: " msg "\n",## args);	\
+	}
+#else
+#	define SMSC_WARNING(msg, args...)
+#endif
+#endif //not USING_LINT
+
+
+/*******************************************************
+* Macro: SMSC_ASSERT
+* Description:
+*    This macro is used to test assumptions made when coding.
+*    It can be used anywhere, but is intended only for situations
+*      where a failure is fatal.
+*    If code execution where allowed to continue it is assumed that
+*      only further unrecoverable errors would occur and so this macro
+*      includes an infinite loop to prevent further corruption.
+*    Assertions are only intended for use during developement to
+*      insure consistency of logic through out the driver.
+*    A driver should not be released if assertion failures are
+*      still occuring.
+*    To use this macro define USE_TRACE or USE_WARNING or
+*      USE_ASSERT
+*******************************************************/
+#ifdef USING_LINT
+extern void SMSC_ASSERT(BOOLEAN condition);
+#else //not USING_LINT
+#ifdef USE_ASSERT
+#	define SMSC_ASSERT(condition)													\
+	if(!(condition)) {																\
+		printk("SMSC_ASSERTION_FAILURE: File=" __FILE__ ", Line=%d\n",__LINE__);	\
+		while(1);																	\
+	}
+#else
+#	define SMSC_ASSERT(condition)
+#endif
+#endif //not USING_LINT
+
+//Below are the register offsets and bit definitions
+//  of the Lan911x memory space
+#define RX_DATA_FIFO	    (0x00UL)
+
+#define TX_DATA_FIFO        (0x20UL)
+#define		TX_CMD_A_INT_ON_COMP_		(0x80000000UL)
+#define		TX_CMD_A_INT_BUF_END_ALGN_	(0x03000000UL)
+#define		TX_CMD_A_INT_4_BYTE_ALGN_	(0x00000000UL)
+#define		TX_CMD_A_INT_16_BYTE_ALGN_	(0x01000000UL)
+#define		TX_CMD_A_INT_32_BYTE_ALGN_	(0x02000000UL)
+#define		TX_CMD_A_INT_DATA_OFFSET_	(0x001F0000UL)
+#define		TX_CMD_A_INT_FIRST_SEG_		(0x00002000UL)
+#define		TX_CMD_A_INT_LAST_SEG_		(0x00001000UL)
+#define		TX_CMD_A_BUF_SIZE_			(0x000007FFUL)
+#define		TX_CMD_B_PKT_TAG_			(0xFFFF0000UL)
+#define		TX_CMD_B_ADD_CRC_DISABLE_	(0x00002000UL)
+#define		TX_CMD_B_DISABLE_PADDING_	(0x00001000UL)
+#define		TX_CMD_B_PKT_BYTE_LENGTH_	(0x000007FFUL)
+
+#define RX_STATUS_FIFO      (0x40UL)
+#define		RX_STS_ES_			(0x00008000UL)
+#define		RX_STS_MCAST_		(0x00000400UL)
+#define RX_STATUS_FIFO_PEEK (0x44UL)
+#define TX_STATUS_FIFO		(0x48UL)
+#define TX_STATUS_FIFO_PEEK (0x4CUL)
+#define ID_REV              (0x50UL)
+#define		ID_REV_CHIP_ID_		(0xFFFF0000UL)	// RO
+#define		ID_REV_REV_ID_		(0x0000FFFFUL)	// RO
+
+#define INT_CFG				(0x54UL)
+#define		INT_CFG_INT_DEAS_	(0xFF000000UL)	// R/W
+#define		INT_CFG_IRQ_INT_	(0x00001000UL)	// RO
+#define		INT_CFG_IRQ_EN_		(0x00000100UL)	// R/W
+#define		INT_CFG_IRQ_POL_	(0x00000010UL)	// R/W Not Affected by SW Reset
+#define		INT_CFG_IRQ_TYPE_	(0x00000001UL)	// R/W Not Affected by SW Reset
+
+#define INT_STS				(0x58UL)
+#define		INT_STS_SW_INT_		(0x80000000UL)	// R/WC
+#define		INT_STS_TXSTOP_INT_	(0x02000000UL)	// R/WC
+#define		INT_STS_RXSTOP_INT_	(0x01000000UL)	// R/WC
+#define		INT_STS_RXDFH_INT_	(0x00800000UL)	// R/WC
+#define		INT_STS_RXDF_INT_	(0x00400000UL)	// R/WC
+#define		INT_STS_TX_IOC_		(0x00200000UL)	// R/WC
+#define		INT_STS_RXD_INT_	(0x00100000UL)	// R/WC
+#define		INT_STS_GPT_INT_	(0x00080000UL)	// R/WC
+#define		INT_STS_PHY_INT_	(0x00040000UL)	// RO
+#define		INT_STS_PME_INT_	(0x00020000UL)	// R/WC
+#define		INT_STS_TXSO_		(0x00010000UL)	// R/WC
+#define		INT_STS_RWT_		(0x00008000UL)	// R/WC
+#define		INT_STS_RXE_		(0x00004000UL)	// R/WC
+#define		INT_STS_TXE_		(0x00002000UL)	// R/WC
+#define		INT_STS_ERX_		(0x00001000UL)	// R/WC
+#define		INT_STS_TDFU_		(0x00000800UL)	// R/WC
+#define		INT_STS_TDFO_		(0x00000400UL)	// R/WC
+#define		INT_STS_TDFA_		(0x00000200UL)	// R/WC
+#define		INT_STS_TSFF_		(0x00000100UL)	// R/WC
+#define		INT_STS_TSFL_		(0x00000080UL)	// R/WC
+#define		INT_STS_RDFO_		(0x00000040UL)	// R/WC
+#define		INT_STS_RDFL_		(0x00000020UL)	// R/WC
+#define		INT_STS_RSFF_		(0x00000010UL)	// R/WC
+#define		INT_STS_RSFL_		(0x00000008UL)	// R/WC
+#define		INT_STS_GPIO2_INT_	(0x00000004UL)	// R/WC
+#define		INT_STS_GPIO1_INT_	(0x00000002UL)	// R/WC
+#define		INT_STS_GPIO0_INT_	(0x00000001UL)	// R/WC
+
+#define INT_EN				(0x5CUL)
+#define		INT_EN_SW_INT_EN_		(0x80000000UL)	// R/W
+#define		INT_EN_TXSTOP_INT_EN_	(0x02000000UL)	// R/W
+#define		INT_EN_RXSTOP_INT_EN_	(0x01000000UL)	// R/W
+#define		INT_EN_RXDFH_INT_EN_	(0x00800000UL)	// R/W
+#define		INT_EN_RXDF_INT_EN_		(0x00400000UL)	// R/W
+#define		INT_EN_TIOC_INT_EN_		(0x00200000UL)	// R/W
+#define		INT_EN_RXD_INT_EN_		(0x00100000UL)	// R/W
+#define		INT_EN_GPT_INT_EN_		(0x00080000UL)	// R/W
+#define		INT_EN_PHY_INT_EN_		(0x00040000UL)	// R/W
+#define		INT_EN_PME_INT_EN_		(0x00020000UL)	// R/W
+#define		INT_EN_TXSO_EN_			(0x00010000UL)	// R/W
+#define		INT_EN_RWT_EN_			(0x00008000UL)	// R/W
+#define		INT_EN_RXE_EN_			(0x00004000UL)	// R/W
+#define		INT_EN_TXE_EN_			(0x00002000UL)	// R/W
+#define		INT_EN_ERX_EN_			(0x00001000UL)	// R/W
+#define		INT_EN_TDFU_EN_			(0x00000800UL)	// R/W
+#define		INT_EN_TDFO_EN_			(0x00000400UL)	// R/W
+#define		INT_EN_TDFA_EN_			(0x00000200UL)	// R/W
+#define		INT_EN_TSFF_EN_			(0x00000100UL)	// R/W
+#define		INT_EN_TSFL_EN_			(0x00000080UL)	// R/W
+#define		INT_EN_RDFO_EN_			(0x00000040UL)	// R/W
+#define		INT_EN_RDFL_EN_			(0x00000020UL)	// R/W
+#define		INT_EN_RSFF_EN_			(0x00000010UL)	// R/W
+#define		INT_EN_RSFL_EN_			(0x00000008UL)	// R/W
+#define		INT_EN_GPIO2_INT_		(0x00000004UL)	// R/W
+#define		INT_EN_GPIO1_INT_		(0x00000002UL)	// R/W
+#define		INT_EN_GPIO0_INT_		(0x00000001UL)	// R/W
+
+#define BYTE_TEST				(0x64UL)
+#define FIFO_INT				(0x68UL)
+#define		FIFO_INT_TX_AVAIL_LEVEL_	(0xFF000000UL)	// R/W
+#define		FIFO_INT_TX_STS_LEVEL_		(0x00FF0000UL)	// R/W
+#define		FIFO_INT_RX_AVAIL_LEVEL_	(0x0000FF00UL)	// R/W
+#define		FIFO_INT_RX_STS_LEVEL_		(0x000000FFUL)	// R/W
+
+#define RX_CFG					(0x6CUL)
+#define		RX_CFG_RX_END_ALGN_		(0xC0000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN4_		(0x00000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN16_		(0x40000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN32_		(0x80000000UL)	// R/W
+#define		RX_CFG_RX_DMA_CNT_		(0x0FFF0000UL)	// R/W
+#define		RX_CFG_RX_DUMP_			(0x00008000UL)	// R/W
+#define		RX_CFG_RXDOFF_			(0x00001F00UL)	// R/W
+#define		RX_CFG_RXBAD_			(0x00000001UL)	// R/W
+
+#define TX_CFG					(0x70UL)
+#define		TX_CFG_TX_DMA_LVL_		(0xE0000000UL)	// R/W
+#define		TX_CFG_TX_DMA_CNT_		(0x0FFF0000UL)	// R/W Self Clearing
+#define		TX_CFG_TXS_DUMP_		(0x00008000UL)	// Self Clearing
+#define		TX_CFG_TXD_DUMP_		(0x00004000UL)	// Self Clearing
+#define		TX_CFG_TXSAO_			(0x00000004UL)	// R/W
+#define		TX_CFG_TX_ON_			(0x00000002UL)	// R/W
+#define		TX_CFG_STOP_TX_			(0x00000001UL)	// Self Clearing
+
+#define HW_CFG					(0x74UL)
+#define		HW_CFG_TTM_				(0x00200000UL)	// R/W
+#define		HW_CFG_SF_				(0x00100000UL)	// R/W
+#define		HW_CFG_TX_FIF_SZ_		(0x000F0000UL)	// R/W
+#define		HW_CFG_TR_				(0x00003000UL)	// R/W
+#define     HW_CFG_PHY_CLK_SEL_		(0x00000060UL)  // R/W
+#define         HW_CFG_PHY_CLK_SEL_INT_PHY_	(0x00000000UL) // R/W
+#define         HW_CFG_PHY_CLK_SEL_EXT_PHY_	(0x00000020UL) // R/W
+#define         HW_CFG_PHY_CLK_SEL_CLK_DIS_ (0x00000040UL) // R/W
+#define     HW_CFG_SMI_SEL_			(0x00000010UL)  // R/W
+#define     HW_CFG_EXT_PHY_DET_		(0x00000008UL)  // RO
+#define     HW_CFG_EXT_PHY_EN_		(0x00000004UL)  // R/W
+#define		HW_CFG_32_16_BIT_MODE_	(0x00000004UL)	// RO
+#define     HW_CFG_SRST_TO_			(0x00000002UL)  // RO
+#define		HW_CFG_SRST_			(0x00000001UL)	// Self Clearing
+
+#define RX_DP_CTRL				(0x78UL)
+#define		RX_DP_CTRL_RX_FFWD_		(0x00000FFFUL)	// R/W
+#define		RX_DP_CTRL_FFWD_BUSY_	(0x80000000UL)	// RO
+
+#define RX_FIFO_INF				(0x7CUL)
+#define		RX_FIFO_INF_RXSUSED_	(0x00FF0000UL)	// RO
+#define		RX_FIFO_INF_RXDUSED_	(0x0000FFFFUL)	// RO
+
+#define TX_FIFO_INF				(0x80UL)
+#define		TX_FIFO_INF_TSUSED_		(0x00FF0000UL)  // RO
+#define		TX_FIFO_INF_TSFREE_		(0x00FF0000UL)	// RO
+#define		TX_FIFO_INF_TDFREE_		(0x0000FFFFUL)	// RO
+
+#define PMT_CTRL				(0x84UL)
+#define		PMT_CTRL_PM_MODE_			(0x00018000UL)	// Self Clearing
+#define		PMT_CTRL_PHY_RST_			(0x00000400UL)	// Self Clearing
+#define		PMT_CTRL_WOL_EN_			(0x00000200UL)	// R/W
+#define		PMT_CTRL_ED_EN_				(0x00000100UL)	// R/W
+#define		PMT_CTRL_PME_TYPE_			(0x00000040UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_WUPS_				(0x00000030UL)	// R/WC
+#define			PMT_CTRL_WUPS_NOWAKE_		(0x00000000UL)	// R/WC
+#define			PMT_CTRL_WUPS_ED_			(0x00000010UL)	// R/WC
+#define			PMT_CTRL_WUPS_WOL_			(0x00000020UL)	// R/WC
+#define			PMT_CTRL_WUPS_MULTI_		(0x00000030UL)	// R/WC
+#define		PMT_CTRL_PME_IND_		(0x00000008UL)	// R/W
+#define		PMT_CTRL_PME_POL_		(0x00000004UL)	// R/W
+#define		PMT_CTRL_PME_EN_		(0x00000002UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_READY_			(0x00000001UL)	// RO
+
+#define GPIO_CFG				(0x88UL)
+#define		GPIO_CFG_LED3_EN_		(0x40000000UL)	// R/W
+#define		GPIO_CFG_LED2_EN_		(0x20000000UL)	// R/W
+#define		GPIO_CFG_LED1_EN_		(0x10000000UL)	// R/W
+#define		GPIO_CFG_GPIO2_INT_POL_	(0x04000000UL)	// R/W
+#define		GPIO_CFG_GPIO1_INT_POL_	(0x02000000UL)	// R/W
+#define		GPIO_CFG_GPIO0_INT_POL_	(0x01000000UL)	// R/W
+#define		GPIO_CFG_EEPR_EN_		(0x00E00000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF2_		(0x00040000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF1_		(0x00020000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF0_		(0x00010000UL)	// R/W
+#define		GPIO_CFG_GPIODIR2_		(0x00000400UL)	// R/W
+#define		GPIO_CFG_GPIODIR1_		(0x00000200UL)	// R/W
+#define		GPIO_CFG_GPIODIR0_		(0x00000100UL)	// R/W
+#define		GPIO_CFG_GPIOD4_		(0x00000020UL)	// R/W
+#define		GPIO_CFG_GPIOD3_		(0x00000010UL)	// R/W
+#define		GPIO_CFG_GPIOD2_		(0x00000004UL)	// R/W
+#define		GPIO_CFG_GPIOD1_		(0x00000002UL)	// R/W
+#define		GPIO_CFG_GPIOD0_		(0x00000001UL)	// R/W
+
+#define GPT_CFG					(0x8CUL)
+#define		GPT_CFG_TIMER_EN_		(0x20000000UL)	// R/W
+#define		GPT_CFG_GPT_LOAD_		(0x0000FFFFUL)	// R/W
+
+#define GPT_CNT					(0x90UL)
+#define		GPT_CNT_GPT_CNT_		(0x0000FFFFUL)	// RO
+
+#define FPGA_REV				(0x94UL)
+#define		FPGA_REV_FPGA_REV_		(0x0000FFFFUL)	// RO
+
+#define ENDIAN					(0x98UL)
+#define FREE_RUN				(0x9CUL)
+#define RX_DROP					(0xA0UL)
+#define MAC_CSR_CMD				(0xA4UL)
+#define		MAC_CSR_CMD_CSR_BUSY_	(0x80000000UL)	// Self Clearing
+#define		MAC_CSR_CMD_R_NOT_W_	(0x40000000UL)	// R/W
+#define		MAC_CSR_CMD_CSR_ADDR_	(0x000000FFUL)	// R/W
+
+#define MAC_CSR_DATA			(0xA8UL)
+#define AFC_CFG					(0xACUL)
+#define		AFC_CFG_AFC_HI_			(0x00FF0000UL)	// R/W
+#define		AFC_CFG_AFC_LO_			(0x0000FF00UL)	// R/W
+#define		AFC_CFG_BACK_DUR_		(0x000000F0UL)	// R/W
+#define		AFC_CFG_FCMULT_			(0x00000008UL)	// R/W
+#define		AFC_CFG_FCBRD_			(0x00000004UL)	// R/W
+#define		AFC_CFG_FCADD_			(0x00000002UL)	// R/W
+#define		AFC_CFG_FCANY_			(0x00000001UL)	// R/W
+
+#define E2P_CMD					(0xB0UL)
+#define		E2P_CMD_EPC_BUSY_		(0x80000000UL)	// Self Clearing
+#define		E2P_CMD_EPC_CMD_		(0x70000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_READ_	(0x00000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWDS_	(0x10000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWEN_	(0x20000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRITE_	(0x30000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRAL_	(0x40000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERASE_	(0x50000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERAL_	(0x60000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_RELOAD_	(0x70000000UL)  // R/W
+#define		E2P_CMD_EPC_TIMEOUT_	(0x00000200UL)	// R
+#define		E2P_CMD_MAC_ADDR_LOADED_	(0x00000100UL)	// RO
+#define		E2P_CMD_EPC_ADDR_		(0x000000FFUL)	// R/W
+
+#define E2P_DATA				(0xB4UL)
+#define		E2P_DATA_EEPROM_DATA_	(0x000000FFUL)	// R/W
+//end of lan register offsets and bit definitions
+
+#define LAN_REGISTER_EXTENT		(0x00002000UL)
+
+//The following describes the synchronization policies used in this driver.
+//Register Name				Policy
+//RX_DATA_FIFO				Only used by the Rx Thread, Rx_ProcessPackets
+//TX_DATA_FIFO				Only used by the Tx Thread, Tx_SendSkb
+//RX_STATUS_FIFO			Only used by the Rx Thread, Rx_ProcessPackets
+//RX_STATUS_FIFO_PEEK		Not used.
+//TX_STATUS_FIFO			Used in	Tx_CompleteTx in Tx_UpdateTxCounters.
+//							protected by TxCounterLock
+//TX_STATUS_FIFO_PEEK		Not used.
+//ID_REV					Read only
+//INT_CFG					Set in Lan_Initialize,
+//							protected by IntEnableLock
+//INT_STS					Sharable,
+//INT_EN					Initialized at startup,
+//							Used in Rx_ProcessPackets
+//							otherwise protected by IntEnableLock
+//BYTE_TEST					Read Only
+//FIFO_INT					Initialized at startup,
+//                          During run time only accessed by
+//                              Tx_HandleInterrupt, and Tx_SendSkb and done in a safe manner
+//RX_CFG					Used during initialization
+//                          During runtime only used by Rx Thread
+//TX_CFG					Only used during initialization
+//HW_CFG					Only used during initialization
+//RX_DP_CTRL				Only used in Rx Thread, in Rx_FastForward
+//RX_FIFO_INF				Read Only, Only used in Rx Thread, in Rx_PopRxStatus
+//TX_FIFO_INF				Read Only, Only used in Tx Thread, in Tx_GetTxStatusCount, Tx_SendSkb, Tx_CompleteTx
+//PMT_CTRL					Not Used
+//GPIO_CFG					used during initialization, in Lan_Initialize
+//                          used for debugging
+//                          used during EEPROM access.
+//                          safe enough to not require a lock
+//GPT_CFG					protected by GpTimerLock
+//GPT_CNT					Not Used
+//ENDIAN					Not Used
+//FREE_RUN					Read only
+//RX_DROP					Used in Rx Interrupt Handler,
+//                          and get_stats.
+//                          safe enough to not require a lock.
+//MAC_CSR_CMD				Protected by MacPhyLock
+//MAC_CSR_DATA				Protected by MacPhyLock
+//                          Because the two previous MAC_CSR_ registers are protected
+//                            All MAC, and PHY registers are protected as well.
+//AFC_CFG					Used during initialization, in Lan_Initialize
+//                          During run time, used in timer call back, in Phy_UpdateLinkMode
+//E2P_CMD					Used during initialization, in Lan_Initialize
+//                          Used in EEPROM functions
+//E2P_DATA					Used in EEPROM functions
+
+//DMA Transfer structure
+typedef struct _DMA_XFER
+{
+	DWORD dwLanReg;
+	DWORD *pdwBuf;
+	DWORD dwDmaCh;
+	DWORD dwDwCnt;
+	BOOLEAN fMemWr;
+} DMA_XFER;
+
+typedef struct _FLOW_CONTROL_PARAMETERS
+{
+	DWORD MaxThroughput;
+	DWORD MaxPacketCount;
+	DWORD PacketCost;
+	DWORD BurstPeriod;
+	DWORD IntDeas;
+} FLOW_CONTROL_PARAMETERS, *PFLOW_CONTROL_PARAMETERS;
+
+#include PLATFORM_SOURCE
+//PLATFORM_SOURCE is defined from the command line
+//  with the -D option
+//  example: -D"PLATFORM_SOURCE=\"platform.c\""
+
+#define Lan_GetRegDW(dwOffset)	\
+	Platform_GetRegDW(privateData->dwLanBase,dwOffset)
+
+#define Lan_SetRegDW(dwOffset,dwVal) \
+	Platform_SetRegDW(privateData->dwLanBase,dwOffset,dwVal)
+
+#define Lan_ClrBitsDW(dwOffset,dwBits)						\
+	Platform_SetRegDW(privateData->dwLanBase,				\
+		dwOffset,Platform_GetRegDW(privateData->dwLanBase,	\
+		dwOffset)&(~dwBits))
+
+#define Lan_SetBitsDW(dwOffset,dwBits)						\
+	Platform_SetRegDW(privateData->dwLanBase,				\
+		dwOffset,Platform_GetRegDW(privateData->dwLanBase,	\
+		dwOffset)|dwBits);
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+typedef unsigned long VL_KEY;
+typedef struct _VERIFIABLE_LOCK {
+	spinlock_t Lock;
+	VL_KEY KeyCode;
+} VERIFIABLE_LOCK, * PVERIFIABLE_LOCK;
+
+void Vl_InitLock(PVERIFIABLE_LOCK pVl);
+BOOLEAN Vl_CheckLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode);
+VL_KEY Vl_WaitForLock(PVERIFIABLE_LOCK pVl,DWORD *pdwIntFlags);
+void Vl_ReleaseLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode,DWORD *pdwIntFlags);
+
+typedef struct _PRIVATE_DATA {
+	DWORD dwLanBase;
+	DWORD dwIdRev;
+	DWORD dwFpgaRev;
+	struct net_device *dev;
+
+	spinlock_t IntEnableLock;
+	BOOLEAN LanInitialized;
+	VERIFIABLE_LOCK MacPhyLock;
+
+	DWORD dwTxDmaCh;
+	BOOLEAN TxDmaChReserved;
+	DMA_XFER TxDmaXfer;
+	DWORD dwTxDmaThreshold;
+	DWORD dwTxQueueDisableMask;
+	struct sk_buff *TxSkb;
+	spinlock_t TxSkbLock;
+	spinlock_t TxQueueLock;
+	spinlock_t TxCounterLock;
+	BOOLEAN TxInitialized;
+
+	DWORD dwRxDmaCh;
+	struct sk_buff *RxSkb;
+	BOOLEAN RxDmaChReserved;
+	DWORD dwRxDmaThreshold;
+	BOOLEAN RxCongested;
+	DWORD dwRxOffCount;
+	BOOLEAN RxOverrun;
+	DWORD RxOverrunCount;
+	DWORD RxStatusDWReadCount;
+	DWORD RxDataDWReadCount;
+	DWORD RxPacketReadCount;
+	DWORD RxFastForwardCount;
+	DWORD RxPioReadCount;
+	DWORD RxDmaReadCount;
+	DWORD RxCongestedCount;
+	DWORD RxDumpCount;
+	DWORD LastReasonForReleasingCPU;
+	DWORD LastRxStatus1;
+	DWORD LastRxStatus2;
+	DWORD LastRxStatus3;
+	DWORD LastIntStatus1;
+	DWORD LastIntStatus2;
+	DWORD LastIntStatus3;
+	DWORD RxUnloadProgress;
+	DWORD RxUnloadPacketProgress;
+	DWORD RxMaxDataFifoSize;
+
+	DWORD RxFlowCurrentThroughput;
+	DWORD RxFlowCurrentPacketCount;
+	DWORD RxFlowCurrentWorkLoad;
+	BOOLEAN MeasuringRxThroughput;
+	DWORD RxFlowMeasuredMaxThroughput;
+	DWORD RxFlowMeasuredMaxPacketCount;
+
+//RX_FLOW_ACTIVATION specifies the percentage that RxFlowCurrentWorkLoad must exceed
+//     RxFlowMaxWorkLoad in order to activate flow control
+#define RX_FLOW_ACTIVATION	(4UL)
+
+//RX_FLOW_DEACTIVATION specifies the percentage that RxFlowCurrentWorkLoad must reduce
+//     from RxFlowMaxWorkLoad in order to deactivate flow control
+#define RX_FLOW_DEACTIVATION (25UL)
+	DWORD RxFlowMaxWorkLoad;
+
+	FLOW_CONTROL_PARAMETERS RxFlowParameters;
+
+	DWORD RxFlowBurstWorkLoad;
+	DWORD RxFlowBurstMaxWorkLoad;
+	BOOLEAN RxFlowControlActive;
+	BOOLEAN RxFlowBurstActive;
+	DWORD RxInterrupts;
+
+#define GPT_SCHEDULE_DEPTH	(3)
+	void *GptFunction[GPT_SCHEDULE_DEPTH];
+	DWORD GptCallTime[GPT_SCHEDULE_DEPTH];
+	DWORD Gpt_scheduled_slot_index;
+	spinlock_t GpTimerLock;
+
+	BOOLEAN Running;
+	struct net_device_stats stats;
+
+	DWORD dwPhyAddress;
+	DWORD dwPhyId;
+#ifdef USE_LED1_WORK_AROUND
+	DWORD NotUsingExtPhy;
+#endif
+	BYTE bPhyModel;
+	BYTE bPhyRev;
+	DWORD dwLinkSpeed;
+	DWORD dwLinkSettings;
+	DWORD dwRemoteFaultCount;
+	struct timer_list LinkPollingTimer;
+	BOOLEAN StopLinkPolling;
+	WORD wLastADV;
+	WORD wLastADVatRestart;
+#ifdef USE_PHY_WORK_AROUND
+#define MIN_PACKET_SIZE (64)
+	DWORD dwTxStartMargen;
+	BYTE LoopBackTxPacket[MIN_PACKET_SIZE];
+	DWORD dwTxEndMargen;
+	DWORD dwRxStartMargen;
+	BYTE LoopBackRxPacket[MIN_PACKET_SIZE];
+	DWORD dwRxEndMargen;
+	DWORD dwResetCount;
+#endif
+
+	BOOLEAN SoftwareInterruptSignal;
+
+	PLATFORM_DATA PlatformData;
+
+#define SMSC_IF_NAME_SIZE	(10)
+	char ifName[SMSC_IF_NAME_SIZE];
+
+	/* for Rx Multicast work around */
+	volatile DWORD HashLo;
+	volatile DWORD HashHi;
+	volatile BOOLEAN MulticastUpdatePending;
+	volatile DWORD set_bits_mask;
+	volatile DWORD clear_bits_mask;
+
+} PRIVATE_DATA, *PPRIVATE_DATA;
+
+
+/*
+ ****************************************************************************
+ ****************************************************************************
+ *	MAC Control and Status Register (Indirect Address)
+ *	Offset (through the MAC_CSR CMD and DATA port)
+ ****************************************************************************
+ ****************************************************************************
+ *
+ */
+#define MAC_CR				(0x01UL)	// R/W
+
+	/* MAC_CR - MAC Control Register */
+	#define MAC_CR_RXALL_		(0x80000000UL)
+	#define MAC_CR_HBDIS_		(0x10000000UL)
+	#define MAC_CR_RCVOWN_		(0x00800000UL)
+	#define MAC_CR_LOOPBK_		(0x00200000UL)
+	#define MAC_CR_FDPX_		(0x00100000UL)
+	#define MAC_CR_MCPAS_		(0x00080000UL)
+	#define MAC_CR_PRMS_		(0x00040000UL)
+	#define MAC_CR_INVFILT_		(0x00020000UL)
+	#define MAC_CR_PASSBAD_		(0x00010000UL)
+	#define MAC_CR_HFILT_		(0x00008000UL)
+	#define MAC_CR_HPFILT_		(0x00002000UL)
+	#define MAC_CR_LCOLL_		(0x00001000UL)
+	#define MAC_CR_BCAST_		(0x00000800UL)
+	#define MAC_CR_DISRTY_		(0x00000400UL)
+	#define MAC_CR_PADSTR_		(0x00000100UL)
+	#define MAC_CR_BOLMT_MASK_	(0x000000C0UL)
+	#define MAC_CR_DFCHK_		(0x00000020UL)
+	#define MAC_CR_TXEN_		(0x00000008UL)
+	#define MAC_CR_RXEN_		(0x00000004UL)
+
+#define ADDRH				(0x02UL)	// R/W mask 0x0000FFFFUL
+#define ADDRL				(0x03UL)	// R/W mask 0xFFFFFFFFUL
+#define HASHH				(0x04UL)	// R/W
+#define HASHL				(0x05UL)	// R/W
+
+#define MII_ACC				(0x06UL)	// R/W
+	#define MII_ACC_PHY_ADDR_	(0x0000F800UL)
+	#define MII_ACC_MIIRINDA_	(0x000007C0UL)
+	#define MII_ACC_MII_WRITE_	(0x00000002UL)
+	#define MII_ACC_MII_BUSY_	(0x00000001UL)
+
+#define MII_DATA			(0x07UL)	// R/W mask 0x0000FFFFUL
+
+#define FLOW				(0x08UL)	// R/W
+	#define FLOW_FCPT_			(0xFFFF0000UL)
+	#define FLOW_FCPASS_		(0x00000004UL)
+	#define FLOW_FCEN_			(0x00000002UL)
+	#define FLOW_FCBSY_			(0x00000001UL)
+
+#define VLAN1				(0x09UL)	// R/W mask 0x0000FFFFUL
+#define VLAN2				(0x0AUL)	// R/W mask 0x0000FFFFUL
+
+#define WUFF				(0x0BUL)	// WO
+
+#define WUCSR				(0x0CUL)	// R/W
+	#define WUCSR_GUE_			(0x00000200UL)
+	#define WUCSR_WUFR_			(0x00000040UL)
+	#define WUCSR_MPR_			(0x00000020UL)
+	#define WUCSR_WAKE_EN_		(0x00000004UL)
+	#define WUCSR_MPEN_			(0x00000002UL)
+
+BOOLEAN Mac_Initialize(PPRIVATE_DATA privateData);
+static BOOLEAN MacNotBusy(PPRIVATE_DATA privateData,VL_KEY keyCode);
+DWORD Mac_GetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,VL_KEY keyCode);
+void Mac_SetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,DWORD dwVal,VL_KEY keyCode);
+
+/*
+ ****************************************************************************
+ *	Chip Specific MII Defines
+ ****************************************************************************
+ *
+ *	Phy register offsets and bit definitions
+ *
+ */
+#define LAN9118_PHY_ID	(0x00C0001C)
+
+#define PHY_BCR		((DWORD)0U)
+#define PHY_BCR_RESET_					((WORD)0x8000U)
+#define PHY_BCR_LOOPBACK_			((WORD)0x4000U)
+#define PHY_BCR_SPEED_SELECT_		((WORD)0x2000U)
+#define PHY_BCR_AUTO_NEG_ENABLE_	((WORD)0x1000U)
+#define PHY_BCR_RESTART_AUTO_NEG_	((WORD)0x0200U)
+#define PHY_BCR_DUPLEX_MODE_		((WORD)0x0100U)
+
+#define PHY_BSR		((DWORD)1U)
+	#define PHY_BSR_LINK_STATUS_	((WORD)0x0004U)
+	#define PHY_BSR_REMOTE_FAULT_	((WORD)0x0010U)
+	#define PHY_BSR_AUTO_NEG_COMP_	((WORD)0x0020U)
+
+#define PHY_ID_1	((DWORD)2U)
+#define PHY_ID_2	((DWORD)3U)
+
+#define PHY_ANEG_ADV    ((DWORD)4U)
+#define PHY_ANEG_ADV_PAUSE_ ((WORD)0x0C00)
+#define PHY_ANEG_ADV_ASYMP_	((WORD)0x0800)
+#define PHY_ANEG_ADV_SYMP_	((WORD)0x0400)
+#define PHY_ANEG_ADV_10H_	((WORD)0x20)
+#define PHY_ANEG_ADV_10F_	((WORD)0x40)
+#define PHY_ANEG_ADV_100H_	((WORD)0x80)
+#define PHY_ANEG_ADV_100F_	((WORD)0x100)
+#define PHY_ANEG_ADV_SPEED_	((WORD)0x1E0)
+
+#define PHY_ANEG_LPA	((DWORD)5U)
+#define PHY_ANEG_LPA_ASYMP_		((WORD)0x0800)
+#define PHY_ANEG_LPA_SYMP_		((WORD)0x0400)
+#define PHY_ANEG_LPA_100FDX_	((WORD)0x0100)
+#define PHY_ANEG_LPA_100HDX_	((WORD)0x0080)
+#define PHY_ANEG_LPA_10FDX_		((WORD)0x0040)
+#define PHY_ANEG_LPA_10HDX_		((WORD)0x0020)
+
+#define PHY_MODE_CTRL_STS		((DWORD)17)	// Mode Control/Status Register
+	#define MODE_CTRL_STS_FASTRIP_		((WORD)0x4000U)
+	#define MODE_CTRL_STS_EDPWRDOWN_	((WORD)0x2000U)
+	#define MODE_CTRL_STS_LOWSQEN_		((WORD)0x0800U)
+	#define MODE_CTRL_STS_MDPREBP_		((WORD)0x0400U)
+	#define MODE_CTRL_STS_FARLOOPBACK_	((WORD)0x0200U)
+	#define MODE_CTRL_STS_FASTEST_		((WORD)0x0100U)
+	#define MODE_CTRL_STS_REFCLKEN_		((WORD)0x0010U)
+	#define MODE_CTRL_STS_PHYADBP_		((WORD)0x0008U)
+	#define MODE_CTRL_STS_FORCE_G_LINK_	((WORD)0x0004U)
+	#define MODE_CTRL_STS_ENERGYON_		((WORD)0x0002U)
+
+#define PHY_INT_SRC			((DWORD)29)
+#define PHY_INT_SRC_ENERGY_ON_			((WORD)0x0080U)
+#define PHY_INT_SRC_ANEG_COMP_			((WORD)0x0040U)
+#define PHY_INT_SRC_REMOTE_FAULT_		((WORD)0x0020U)
+#define PHY_INT_SRC_LINK_DOWN_			((WORD)0x0010U)
+
+#define PHY_INT_MASK		((DWORD)30)
+#define PHY_INT_MASK_ENERGY_ON_		((WORD)0x0080U)
+#define PHY_INT_MASK_ANEG_COMP_		((WORD)0x0040U)
+#define PHY_INT_MASK_REMOTE_FAULT_	((WORD)0x0020U)
+#define PHY_INT_MASK_LINK_DOWN_		((WORD)0x0010U)
+
+#define PHY_SPECIAL			((DWORD)31)
+#define PHY_SPECIAL_SPD_	((WORD)0x001CU)
+#define PHY_SPECIAL_SPD_10HALF_		((WORD)0x0004U)
+#define PHY_SPECIAL_SPD_10FULL_		((WORD)0x0014U)
+#define PHY_SPECIAL_SPD_100HALF_	((WORD)0x0008U)
+#define PHY_SPECIAL_SPD_100FULL_	((WORD)0x0018U)
+
+BOOLEAN Phy_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwPhyAddress,
+	DWORD dwLinkMode);
+void Phy_SetLink(PPRIVATE_DATA privateData,
+				 DWORD dwLinkRequest);
+WORD Phy_GetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	VL_KEY keyCode);
+void Phy_SetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	WORD wVal,
+	VL_KEY keyCode);
+void Phy_UpdateLinkMode(
+	PPRIVATE_DATA privateData);
+void Phy_GetLinkMode(
+	PPRIVATE_DATA privateData,
+	VL_KEY keyCode);
+void Phy_CheckLink(unsigned long ptr);
+
+TIME_SPAN Gpt_FreeRunCompare(DWORD time1,DWORD time2);
+void Gpt_ScheduleInterrupt(PPRIVATE_DATA privateData,TIME_SPAN timeSpan);
+void Gpt_CancelInterrupt(PPRIVATE_DATA privateData);
+void Gpt_CancelCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData));
+void Gpt_ScheduleCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData),
+	DWORD callBackTime);//100uS units relative to now
+BOOLEAN Gpt_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts);
+void GptCB_RxCompleteMulticast(PPRIVATE_DATA privateData);
+void GptCB_RestartBurst(PPRIVATE_DATA privateData);
+void GptCB_MeasureRxThroughput(PPRIVATE_DATA privateData);
+
+void Tx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwTxDmaCh,
+	DWORD dwTxDmaThreshold);
+void Tx_SendSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb);
+BOOLEAN Tx_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts);
+
+void Tx_StopQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource);
+void Tx_WakeQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource);
+
+static DWORD Tx_GetTxStatusCount(
+	PPRIVATE_DATA privateData);
+static void Tx_DmaCompletionCallback(void* param);
+static DWORD Tx_CompleteTx(
+	PPRIVATE_DATA privateData);
+void Tx_UpdateTxCounters(
+	PPRIVATE_DATA privateData);
+
+void Tx_CompleteDma(
+	PPRIVATE_DATA privateData);
+
+void Rx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwRxDmaCh,
+	DWORD dwDmaThreshold);
+
+void Rx_CompleteMulticastUpdate (PPRIVATE_DATA privateData);
+static void Rx_HandleOverrun(PPRIVATE_DATA privateData);
+static void Rx_HandOffSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb);
+static DWORD Rx_PopRxStatus(
+	PPRIVATE_DATA privateData);
+void Rx_CountErrors(PPRIVATE_DATA privateData,DWORD dwRxStatus);
+void Rx_FastForward(PPRIVATE_DATA privateData,DWORD dwDwordCount);
+void Rx_ProcessPackets(PPRIVATE_DATA privateData);
+void Rx_BeginMulticastUpdate (PPRIVATE_DATA privateData);
+
+unsigned long Rx_TaskletParameter=0;
+
+void Rx_ProcessPacketsTasklet(unsigned long data);
+DECLARE_TASKLET(Rx_Tasklet,Rx_ProcessPacketsTasklet,0);
+
+static void Rx_DmaCompletionCallback(void* param);
+
+BOOLEAN RxStop_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts);
+BOOLEAN Rx_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts);
+static DWORD Rx_Hash(BYTE addr[6]);
+
+void Rx_SetMulticastList(
+	struct net_device *dev);
+void Rx_ReceiverOff(
+	PPRIVATE_DATA privateData);
+void Rx_ReceiverOn(
+	PPRIVATE_DATA privateData, VL_KEY callerKeyCode);
+
+
+void Eeprom_EnableAccess(PPRIVATE_DATA privateData);
+void Eeprom_DisableAccess(PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_IsMacAddressLoaded(PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_IsBusy(PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_Timeout(PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_ReadLocation(
+	PPRIVATE_DATA privateData,BYTE address, BYTE * data);
+BOOLEAN Eeprom_EnableEraseAndWrite(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_DisableEraseAndWrite(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_WriteLocation(
+	PPRIVATE_DATA privateData,BYTE address,BYTE data);
+BOOLEAN Eeprom_EraseAll(
+	PPRIVATE_DATA privateData);
+BOOLEAN Eeprom_Reload(
+	PPRIVATE_DATA privateData);
+
+BOOLEAN Eeprom_SaveMacAddress(
+	PPRIVATE_DATA privateData,
+	DWORD dwHi16,DWORD dwLo32);
+
+
+#define OLD_REGISTERS(privData) (((privData->dwIdRev&0x0000FFFFUL)==0UL)&& \
+								 ((privData->dwFpgaRev)>=0x01)&& \
+								 ((privData->dwFpgaRev)<=0x25))
+
+#define IS_REV_A(privData)	((privData->dwIdRev&0x0000FFFFUL)==0UL)
+
+extern volatile DWORD g_GpioSetting;
+extern DWORD debug_mode;
+#define GP_0	(0x01UL)
+#define GP_1	(0x02UL)
+#define GP_2	(0x04UL)
+#define GP_3	(0x08UL)
+#define GP_4	(0x10UL)
+#define GP_ISR	GP_0
+#define GP_RX	GP_1
+#define GP_TX	GP_2
+
+#define SET_GPIO(gpioBit)					\
+if(debug_mode&0x04UL) {						\
+	g_GpioSetting|=gpioBit;					\
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);	\
+}
+
+#define CLEAR_GPIO(gpioBit)					\
+if(debug_mode&0x04UL) {						\
+	g_GpioSetting&=(~gpioBit);				\
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);	\
+}
+
+#define PULSE_GPIO(gpioBit,count)	\
+if(debug_mode&0x04UL) {				\
+	DWORD pulseNum=0;				\
+	/*make first pulse longer */	\
+	SET_GPIO(gpioBit);				\
+	while(pulseNum<count) {			\
+		SET_GPIO(gpioBit);			\
+		CLEAR_GPIO(gpioBit);		\
+		pulseNum++;					\
+	}								\
+}
+#ifdef USE_LED1_WORK_AROUND
+volatile DWORD g_GpioSettingOriginal;
+#endif
+
+BOOLEAN Lan_Initialize(
+	PPRIVATE_DATA privateData,DWORD dwIntCfg,
+	DWORD dwTxFifSz,DWORD dwAfcCfg);
+void Lan_EnableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask);
+void Lan_DisableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask);
+void Lan_EnableIRQ(PPRIVATE_DATA privateData);
+void Lan_DisableIRQ(PPRIVATE_DATA privateData);
+void Lan_SetIntDeas(PPRIVATE_DATA privateData,DWORD dwIntDeas);
+void Lan_SetTDFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetTSFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetRDFL(PPRIVATE_DATA privateData,BYTE level);
+void Lan_SetRSFL(PPRIVATE_DATA privateData,BYTE level);
+
+void Lan_SignalSoftwareInterrupt(PPRIVATE_DATA privateData);
+BOOLEAN Lan_HandleSoftwareInterrupt(PPRIVATE_DATA privateData,DWORD dwIntSts);
+
+void Lan_ShowRegs(PPRIVATE_DATA privateData);
+
+#include "ioctl_11x.h"
+
+DWORD lan_base=0x0UL;
+module_param(lan_base,ulong,0);
+MODULE_PARM_DESC(lan_base,"Base Address of LAN911x, (default: choosen by platform code)");
+
+DWORD bus_width=0UL;
+module_param(bus_width,ulong,0);
+MODULE_PARM_DESC(bus_width,"Force bus width of 16 or 32 bits, default: autodetect");
+
+DWORD link_mode=0x7FUL;
+module_param(link_mode,ulong,0);
+MODULE_PARM_DESC(link_mode,"Set Link speed and Duplex, 1=10HD,2=10FD,4=100HD,8=100FD,default=0xF");
+
+DWORD irq=PLATFORM_IRQ;
+module_param(irq,ulong,0);
+MODULE_PARM_DESC(irq,"Force use of specific IRQ, (default: choosen by platform code)");
+
+DWORD int_deas=0xFFFFFFFFUL;
+module_param(int_deas,ulong,0);
+MODULE_PARM_DESC(int_deas,"Interrupt Deassertion Interval in 10uS units");
+
+DWORD irq_pol=PLATFORM_IRQ_POL;
+module_param(irq_pol,ulong,0);
+MODULE_PARM_DESC(irq_pol,"IRQ Polarity bit, see definition of INT_CFG register");
+
+DWORD irq_type=PLATFORM_IRQ_TYPE;
+module_param(irq_type,ulong,0);
+MODULE_PARM_DESC(irq_type,"IRQ Buffer Type bit, see definition of INT_CFG register");
+
+DWORD rx_dma=PLATFORM_RX_DMA;
+module_param(rx_dma,ulong,0);
+MODULE_PARM_DESC(rx_dma,"Receiver DMA Channel, 255=find available channel, 256=use PIO");
+
+DWORD tx_dma=PLATFORM_TX_DMA;
+module_param(tx_dma,ulong,0);
+MODULE_PARM_DESC(tx_dma,"Transmitter DMA Channel, 255=find available channel, 256=use PIO");
+
+DWORD dma_threshold=PLATFORM_DMA_THRESHOLD;
+module_param(dma_threshold,ulong,0);
+MODULE_PARM_DESC(dma_threshold,"Specifies the minimum packet size for DMA to be used.");
+
+DWORD mac_addr_hi16=0xFFFFFFFFUL;
+module_param(mac_addr_hi16,ulong,0);
+MODULE_PARM_DESC(mac_addr_hi16,"Specifies the high 16 bits of the mac address");
+
+DWORD mac_addr_lo32=0xFFFFFFFFUL;
+module_param(mac_addr_lo32,ulong,0);
+MODULE_PARM_DESC(mac_addr_lo32,"Specifies the low 32 bits of the mac address");
+
+#ifdef USE_DEBUG
+DWORD debug_mode=0x7UL;
+#else
+DWORD debug_mode=0x0UL;
+#endif
+module_param(debug_mode,ulong,0);
+MODULE_PARM_DESC(debug_mode,"bit 0 enables trace points, bit 1 enables warning points, bit 2 enables gpios");
+
+DWORD tx_fif_sz=0x00050000UL;
+module_param(tx_fif_sz,ulong,0);
+MODULE_PARM_DESC(tx_fif_sz,"Specifies TX_FIF_SZ of the HW_CFG register");
+
+DWORD afc_cfg=0xFFFFFFFFUL;
+module_param(afc_cfg,ulong,0);
+MODULE_PARM_DESC(afc_cfg,"Specifies the setting for the AFC_CFG register");
+
+DWORD tasklets=1UL;
+module_param(tasklets,ulong,0);
+MODULE_PARM_DESC(tasklets,"non-zero== use tasklets for receiving packets, zero==receive packets in ISR");
+
+DWORD phy_addr=0xFFFFFFFFUL;
+module_param(phy_addr,ulong,0);
+MODULE_PARM_DESC(phy_addr,"phy_addr, 0xFFFFFFFF=use interal phy, 0-31=use external phy with specified address, else autodetect external phy addr");
+
+DWORD max_throughput=0xFFFFFFFFUL;
+module_param(max_throughput,ulong,0);
+MODULE_PARM_DESC(max_throughput,"See readme.txt");
+
+DWORD max_packet_count=0xFFFFFFFFUL;
+module_param(max_packet_count,ulong,0);
+MODULE_PARM_DESC(max_packet_count,"See Readme.txt");
+
+DWORD packet_cost=0xFFFFFFFFUL;
+module_param(packet_cost,ulong,0);
+MODULE_PARM_DESC(packet_cost,"See Readme.txt");
+
+DWORD burst_period=0xFFFFFFFFUL;
+module_param(burst_period,ulong,0);
+MODULE_PARM_DESC(burst_period,"See Readme.txt");
+
+DWORD max_work_load=0xFFFFFFFFUL;
+module_param(max_work_load,ulong,0);
+MODULE_PARM_DESC(max_work_load,"See Readme.txt");
+
+MODULE_LICENSE("GPL");
+
+int Smsc911x_init_module(void);
+void Smsc911x_cleanup_module(void);
+int Smsc911x_init(struct net_device *dev);
+int Smsc911x_open(struct net_device *dev);
+int Smsc911x_stop(struct net_device *dev);
+int Smsc911x_hard_start_xmit(struct sk_buff *skb, struct net_device *dev);
+struct net_device_stats * Smsc911x_get_stats(struct net_device *dev);
+void Smsc911x_set_multicast_list(struct net_device *dev);
+int Smsc911x_do_ioctl(struct net_device *dev, struct ifreq *ifr,int cmd);
+irqreturn_t Smsc911x_ISR(int irq,void *dev_id,struct pt_regs *regs);
+
+#ifdef USING_LINT
+struct net_device SMSC911x;
+#else //not USING_LINT
+struct net_device SMSC911x = {init: Smsc911x_init,};
+#endif //not USING_LINT
+
+int Smsc911x_init_module(void)
+{
+	int result=0;
+	int device_present=0;
+	SMSC_TRACE("--> init_module()");
+	SMSC_TRACE("Driver Version = %lX.%02lX",
+		(DRIVER_VERSION>>8),(DRIVER_VERSION&0xFFUL));
+	SMSC_TRACE("Compiled: %s, %s",__DATE__,__TIME__);
+	SMSC_TRACE("Platform: %s",PLATFORM_NAME);
+	SMSC_TRACE("Driver Parameters");
+	if(lan_base==0UL) {
+		SMSC_TRACE("  lan_base         = 0x%08lX, driver will decide",lan_base);
+	} else {
+		SMSC_TRACE("  lan_base         = 0x%08lX",lan_base);
+	}
+	if((bus_width==16UL)||(bus_width==32UL)) {
+		SMSC_TRACE("  bus_width        = %ld",bus_width);
+	} else {
+		SMSC_TRACE("  bus_width        = %ld, driver will autodetect",bus_width);
+	}
+	if(link_mode>0x7FUL) {
+		SMSC_WARNING("  link_mode     = %ld, Unknown",link_mode);
+		link_mode=0x7FUL;
+		SMSC_WARNING("    resetting link_mode to %ld, 100FD,100HD,10FD,10HD,ASYMP,SYMP,ANEG",link_mode);
+	} else if(link_mode==0UL) {
+		SMSC_TRACE("  link_mode        = %ld, LINK_OFF",link_mode);
+	} else {
+		SMSC_TRACE("  link_mode        = 0x%lX, %s,%s,%s,%s,%s,%s,%s",
+			link_mode,
+			(link_mode&LINK_SPEED_10HD)?"10HD":"",
+			(link_mode&LINK_SPEED_10FD)?"10FD":"",
+			(link_mode&LINK_SPEED_100HD)?"100HD":"",
+			(link_mode&LINK_SPEED_100FD)?"100FD":"",
+			(link_mode&LINK_ASYMMETRIC_PAUSE)?"ASYMP":"",
+			(link_mode&LINK_SYMMETRIC_PAUSE)?"SYMP":"",
+			(link_mode&LINK_AUTO_NEGOTIATE)?"ANEG":"");
+	}
+	SMSC_TRACE(    "  irq              = %ld",irq);
+	if(int_deas!=0xFFFFFFFFUL) {
+		if(int_deas>0xFFUL) {
+			SMSC_WARNING("  int_deas     = %ld, too high",int_deas);
+			int_deas=0xFFFFFFFFUL;
+			SMSC_WARNING("    resetting int_deas to %ld",int_deas);
+		}
+	}
+	if(int_deas==0xFFFFFFFFUL) {
+		SMSC_TRACE(    "  int_deas         = 0x%08lX, use platform default",int_deas);
+	} else {
+		SMSC_TRACE(    "  int_deas         = %ld, %lduS",int_deas,10UL*int_deas);
+	}
+	if(irq_pol) {
+		SMSC_TRACE("  irq_pol          = %ld, IRQ output is active high",irq_pol);
+	} else {
+		SMSC_TRACE("  irq_pol          = %ld, IRQ output is active low",irq_pol);
+	}
+	if(irq_type) {
+		SMSC_TRACE("  irq_type         = %ld, IRQ output is Push-Pull driver",irq_type);
+	} else {
+		SMSC_TRACE("  irq_type         = %ld, IRQ output is Open-Drain buffer",irq_type);
+	}
+	if(rx_dma<TRANSFER_REQUEST_DMA) {
+		if(Platform_IsValidDmaChannel(rx_dma)) {
+			SMSC_TRACE(
+				   "  rx_dma           = %ld, DMA Channel %ld",rx_dma,rx_dma);
+		} else {
+			SMSC_WARNING("  rx_dma        = %ld, Invalid Dma Channel",rx_dma);
+			rx_dma=TRANSFER_PIO;
+			SMSC_WARNING("    resetting rx_dma to %ld, RX will use PIO",rx_dma);
+		}
+	} else if(rx_dma==TRANSFER_REQUEST_DMA) {
+		SMSC_TRACE("  rx_dma           = %ld, RX will try to find available channel",rx_dma);
+	} else {
+		SMSC_TRACE("  rx_dma           = %ld, RX will use PIO",rx_dma);
+	}
+	if(tx_dma<TRANSFER_REQUEST_DMA) {
+		if(Platform_IsValidDmaChannel(tx_dma)) {
+			if(tx_dma!=rx_dma) {
+				SMSC_TRACE(
+				   "  tx_dma           = %ld, DMA Channel %ld",tx_dma,tx_dma);
+			} else {
+				SMSC_WARNING("  tx_dma == rx_dma");
+				tx_dma=TRANSFER_PIO;
+				SMSC_WARNING("    resetting tx_dma to %ld, TX will use PIO",tx_dma);
+			}
+		} else {
+			SMSC_WARNING("  tx_dma        = %ld, Invalid Dma Channel",tx_dma);
+			tx_dma=TRANSFER_PIO;
+			SMSC_WARNING("    resetting tx_dma to %ld, TX will use PIO",tx_dma);
+		}
+	} else if(tx_dma==TRANSFER_REQUEST_DMA) {
+		SMSC_TRACE("  tx_dma           = %ld, TX will try to find available channel",tx_dma);
+	} else {
+		SMSC_TRACE("  tx_dma           = %ld, TX will use PIO",tx_dma);
+	}
+	SMSC_TRACE(    "  dma_threshold    = %ld",dma_threshold);
+
+	if(mac_addr_hi16==0xFFFFFFFFUL) {
+		SMSC_TRACE("  mac_addr_hi16    = 0x%08lX, will attempt to read from LAN911x",mac_addr_hi16);
+		SMSC_TRACE("  mac_addr_lo32    = 0x%08lX, will attempt to read from LAN911x",mac_addr_lo32);
+	} else {
+		if(mac_addr_hi16&0xFFFF0000UL) {
+			//The high word is reserved
+			SMSC_WARNING("  mac_addr_hi16 = 0x%08lX, reserved bits are high.",mac_addr_hi16);
+			mac_addr_hi16&=0x0000FFFFUL;
+			SMSC_WARNING("    reseting to mac_addr_hi16 = 0x%08lX",mac_addr_hi16);
+		}
+		if(mac_addr_lo32&0x00000001UL) {
+			//bit 0 is the I/G bit
+			SMSC_WARNING("  mac_addr_lo32 = 0x%08lX, I/G bit is set.",mac_addr_lo32);
+			mac_addr_lo32&=0xFFFFFFFEUL;
+			SMSC_WARNING("    reseting to mac_addr_lo32 = 0x%08lX",mac_addr_lo32);
+		}
+		SMSC_TRACE("  mac_addr_hi16    = 0x%08lX",mac_addr_hi16);
+		SMSC_TRACE("  mac_addr_lo32    = 0x%08lX",mac_addr_lo32);
+	}
+	SMSC_TRACE(    "  debug_mode       = 0x%08lX",debug_mode);
+	if(tx_fif_sz&(~HW_CFG_TX_FIF_SZ_)) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is invalid",tx_fif_sz);
+		tx_fif_sz&=HW_CFG_TX_FIF_SZ_;
+		SMSC_WARNING("  resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	if(tx_fif_sz>0x000E0000UL) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is too high",tx_fif_sz);
+		tx_fif_sz=0x000E0000UL;
+		SMSC_WARNING(" resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	if(tx_fif_sz<0x00020000UL) {
+		SMSC_WARNING("tx_fif_sz = 0x%08lX is too low",tx_fif_sz);
+		tx_fif_sz=0x00020000UL;
+		SMSC_WARNING(" resetting tx_fif_sz to 0x%08lX",tx_fif_sz);
+	}
+	SMSC_TRACE(    "  tx_fif_sz        = 0x%08lX",tx_fif_sz);
+	if(afc_cfg==0xFFFFFFFFUL) {
+		SMSC_TRACE("  afc_cfg          = 0x%08lX, driver will decide",afc_cfg);
+	} else {
+		if(afc_cfg&0xFF000000UL) {
+			SMSC_WARNING("afc_cfg = 0x%08lX is invalid",afc_cfg);
+			afc_cfg&=0xFFFFFFFFUL;
+			SMSC_WARNING(" resetting to afc_cfg = 0x%08lX, driver will decide",afc_cfg);
+		} else {
+			SMSC_TRACE(
+				   "  afc_cfg          = 0x%08lX",afc_cfg);
+		}
+	}
+	if(tasklets) {
+		SMSC_TRACE("  tasklets         = 0x%08lX, Tasklets enabled",tasklets);
+	} else {
+		SMSC_TRACE("  tasklets         = 0, Tasklets disabled");
+	}
+	if(phy_addr==0xFFFFFFFFUL) {
+		SMSC_TRACE("  phy_addr         = 0xFFFFFFFF, Use internal phy");
+	} else if(phy_addr<=31UL) {
+		SMSC_TRACE("  phy_addr         = 0x%08lX, use this address for external phy",phy_addr);
+	} else {
+		SMSC_TRACE("  phy_addr         = 0x%08lX, auto detect external phy",phy_addr);
+	}
+	if(max_throughput) {
+		SMSC_TRACE("  max_throughput   = 0x%08lX, Use platform default",max_throughput);
+	} else {
+		SMSC_TRACE("  max_throughput   = 0x%08lX",max_throughput);
+	}
+	if(max_packet_count) {
+		SMSC_TRACE("  max_packet_count = 0x%08lX, Use platform default",max_packet_count);
+	} else {
+		SMSC_TRACE("  max_packet_count = 0x%08lX",max_packet_count);
+	}
+	if(packet_cost) {
+		SMSC_TRACE("  packet_cost      = 0x%08lX, Use platform default",packet_cost);
+	} else {
+		SMSC_TRACE("  packet_cost      = 0x%08lX",packet_cost);
+	}
+	if(burst_period) {
+		SMSC_TRACE("  burst_period     = 0x%08lX, Use platform default",burst_period);
+	} else {
+		SMSC_TRACE("  burst_period     = 0x%08lX",burst_period);
+	}
+	if(max_work_load) {
+		SMSC_TRACE("  max_work_load    = 0x%08lX, Use platform default",max_work_load);
+	} else {
+		SMSC_TRACE("  max_work_load    = 0x%08lX",max_work_load);
+	}
+
+	strcpy(SMSC911x.name,"eth%d");
+
+	result=register_netdev(&SMSC911x);
+	if(result) {
+		SMSC_WARNING("error %i registering device",result);
+	} else {
+		device_present=1;
+		SMSC_TRACE("  Interface Name = \"%s\"",SMSC911x.name);
+	}
+	result=result;//make lint happy
+	SMSC_TRACE("<-- init_module()");
+	return device_present ? 0 : -ENODEV;
+}
+
+void Smsc911x_cleanup_module(void)
+{
+	SMSC_TRACE("--> cleanup_module()");
+	if(SMSC911x.priv!=NULL) {
+		PPRIVATE_DATA privateData=(PPRIVATE_DATA)SMSC911x.priv;
+		PPLATFORM_DATA platformData=(PPLATFORM_DATA)&(privateData->PlatformData);
+		Platform_CleanUp(platformData);
+		kfree(SMSC911x.priv);
+		SMSC911x.priv=NULL;
+	}
+	unregister_netdev(&SMSC911x);
+	SMSC_TRACE("<-- cleanup_module()");
+}
+
+int Smsc911x_init(struct net_device *dev)
+{
+	DWORD dwLanBase=0UL;
+	DWORD dwIdRev=0UL;
+	DWORD dwFpgaRev=0UL;
+	PPRIVATE_DATA privateData=NULL;
+	PPLATFORM_DATA platformData=NULL;
+	BOOLEAN platformInitialized=FALSE;
+	int result=-ENODEV;
+	SMSC_TRACE("-->Smsc911x_init(dev=0x%08lX)",(DWORD)dev);
+
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc911x_init(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+
+	if(dev->priv!=NULL) {
+		SMSC_WARNING("dev->priv!=NULL, going to overwrite pointer");
+	}
+	dev->priv=kmalloc(sizeof(PRIVATE_DATA),GFP_KERNEL);
+	if(dev->priv==NULL) {
+		SMSC_WARNING("Unable to allocate PRIVATE_DATA");
+		result=-ENOMEM;
+		goto DONE;
+	}
+	memset(dev->priv,0,sizeof(PRIVATE_DATA));
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	platformData=&(privateData->PlatformData);
+
+	dwLanBase=Platform_Initialize(
+		platformData,
+		lan_base,bus_width);
+
+	if(dwLanBase==0UL) {
+		SMSC_WARNING("dwLanBase==0x00000000");
+		result=-ENODEV;
+		goto DONE;
+	}
+	platformInitialized=TRUE;
+	SMSC_TRACE("dwLanBase=0x%08lX",dwLanBase);
+
+	if(check_mem_region(dwLanBase,LAN_REGISTER_EXTENT)!=0) {
+		SMSC_WARNING("  Memory Region specified (0x%08lX to 0x%08lX) is not available.",
+			dwLanBase,dwLanBase+LAN_REGISTER_EXTENT-1UL);
+		result=-ENOMEM;
+		goto DONE;
+	}
+
+	privateData->dwLanBase=dwLanBase;
+	dwIdRev=Lan_GetRegDW(ID_REV);
+	if(HIWORD(dwIdRev)==LOWORD(dwIdRev)) {
+		//this may mean the chip is set for 32 bit
+		//  while the bus is reading as 16 bit
+UNKNOWN_CHIP:
+		SMSC_WARNING("  LAN911x NOT Identified, dwIdRev==0x%08lX",dwIdRev);
+		result=-ENODEV;
+		goto DONE;
+	}
+	switch(dwIdRev&0xFFFF0000UL) {
+	case 0x01180000UL:
+		SMSC_TRACE("  LAN9118 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01170000UL:
+		SMSC_TRACE("  LAN9117 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01160000UL:
+		SMSC_TRACE("  LAN9116 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01150000UL:
+		SMSC_TRACE("  LAN9115 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01120000UL:
+		SMSC_TRACE("  LAN9112 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	default:
+		goto UNKNOWN_CHIP;
+	}
+	dwFpgaRev=Lan_GetRegDW(FPGA_REV);
+	SMSC_TRACE("  FPGA_REV == 0x%08lX",dwFpgaRev);
+
+	ether_setup(dev);
+	dev->open=				Smsc911x_open;
+	dev->stop=				Smsc911x_stop;
+	dev->hard_start_xmit=	Smsc911x_hard_start_xmit;
+	dev->get_stats=			Smsc911x_get_stats;
+	dev->do_ioctl=			Smsc911x_do_ioctl;
+	dev->set_multicast_list=Smsc911x_set_multicast_list;
+	dev->flags|=IFF_MULTICAST;
+
+	// set an invalid MAC address (so we can observe if its value is changed)
+	memset(dev->dev_addr, 0xff, 6);
+
+	SET_MODULE_OWNER(dev);
+
+	privateData->dwIdRev=dwIdRev;
+	privateData->dwFpgaRev=dwFpgaRev&(0x000000FFUL);
+	privateData->dev=dev;
+
+	sprintf(privateData->ifName,"%s",dev->name);
+	result=0;
+
+DONE:
+	if(result!=0) {
+		if(dev!=NULL) {
+			if(dev->priv!=NULL) {
+				if(platformInitialized) {
+					Platform_CleanUp(platformData);
+				}
+				kfree(dev->priv);
+				dev->priv=NULL;
+			}
+		}
+	}
+	SMSC_TRACE("<--Smsc911x_init(), result=%d",result);
+	return result;
+}
+
+int Smsc911x_open(struct net_device *dev)
+{
+	int i;
+	int result=-ENODEV;
+	PPRIVATE_DATA privateData=NULL;
+	PPLATFORM_DATA platformData=NULL;
+	BOOLEAN acquired_mem_region=FALSE;
+	BOOLEAN acquired_isr=FALSE;
+	SMSC_TRACE("-->Smsc911x_open(dev=0x%08lX)",(DWORD)dev);
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc911x_open(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc911x_open(privateData==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	platformData=&(privateData->PlatformData);
+
+	for (i = 0; i < GPT_SCHEDULE_DEPTH; i++) {
+		privateData->GptFunction [i] = NULL;
+	}
+	privateData->Gpt_scheduled_slot_index = GPT_SCHEDULE_DEPTH;
+
+	//get memory region
+	if(check_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT)!=0)
+	{
+		SMSC_WARNING("Device memory is already in use.");
+		result=-ENOMEM;
+		goto DONE;
+	}
+	request_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT,"SMSC_LAN911x");
+	acquired_mem_region=TRUE;
+
+	//initialize the LAN911x
+	{
+		DWORD dwIntCfg=0;
+		if(irq_pol) {
+			dwIntCfg|=INT_CFG_IRQ_POL_;
+		}
+		if(irq_type) {
+			dwIntCfg|=INT_CFG_IRQ_TYPE_;
+		}
+		if(!Lan_Initialize(privateData,dwIntCfg,tx_fif_sz,afc_cfg))
+		{
+			SMSC_WARNING("Failed Lan_Initialize");
+			result=-ENODEV;
+			goto DONE;
+		}
+	}
+
+	spin_lock_init(&(privateData->GpTimerLock));
+
+	if(!Platform_RequestIRQ(platformData,irq,Smsc911x_ISR,privateData)) {
+		result=-ENODEV;
+		goto DONE;
+	}
+	acquired_isr=TRUE;
+
+	//must now test the IRQ connection to the ISR
+	SMSC_TRACE("Testing ISR using IRQ %ld",Platform_CurrentIRQ(platformData));
+	{
+		DWORD dwTimeOut=100000;
+		Lan_SignalSoftwareInterrupt(privateData);
+		do {
+			udelay(10);
+			dwTimeOut--;
+		} while((dwTimeOut)&&(!(privateData->SoftwareInterruptSignal)));
+		if(!(privateData->SoftwareInterruptSignal)) {
+			SMSC_WARNING("ISR failed signaling test");
+			result=-ENODEV;
+			goto DONE;
+		}
+	}
+	SMSC_TRACE("ISR passed test using IRQ %ld",Platform_CurrentIRQ(platformData));
+
+	if(!Mac_Initialize(privateData)) {
+		SMSC_WARNING("Failed Mac_Initialize");
+		result=-ENODEV;
+		goto DONE;
+	}
+	{//get mac address
+		DWORD dwHigh16=0;
+		DWORD dwLow32=0;
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode;
+
+		// if the dev_addr has been set use via set_mac_address then let this override everything
+		if (!(dev->dev_addr[0] == 0xff && dev->dev_addr[1] == 0xff &&
+		      dev->dev_addr[2] == 0xff && dev->dev_addr[3] == 0xff &&
+		      dev->dev_addr[4] == 0xff && dev->dev_addr[5] == 0xff)) {
+			mac_addr_lo32 = dev->dev_addr[0]       | dev->dev_addr[1] <<  8 |
+			                dev->dev_addr[2] << 16 | dev->dev_addr[3] << 24;
+			mac_addr_hi16 = dev->dev_addr[4]       | dev->dev_addr[5] <<  8;
+		}
+
+		keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		if(mac_addr_hi16==0xFFFFFFFF) {
+			dwHigh16=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			dwLow32=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			if((dwHigh16==0x0000FFFFUL)&&(dwLow32==0xFFFFFFFF))
+			{
+				dwHigh16=0x00000070UL;
+				dwLow32=0x110F8000UL;
+				Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+				Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+				SMSC_TRACE("Mac Address is set by default to 0x%04lX%08lX",
+					dwHigh16,dwLow32);
+			} else {
+				SMSC_TRACE("Mac Address is read from LAN911x as 0x%04lX%08lX",
+					dwHigh16,dwLow32);
+			}
+		} else {
+			//SMSC_ASSERT((mac_addr_hi16&0xFFFF8000UL)==0);
+			dwHigh16=mac_addr_hi16;
+			dwLow32=mac_addr_lo32;
+			Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+			Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+			SMSC_TRACE("Mac Address is set by parameter to 0x%04lX%08lX",
+				dwHigh16,dwLow32);
+		}
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+		dev->dev_addr[0]=LOBYTE(LOWORD(dwLow32));
+		dev->dev_addr[1]=HIBYTE(LOWORD(dwLow32));
+		dev->dev_addr[2]=LOBYTE(HIWORD(dwLow32));
+		dev->dev_addr[3]=HIBYTE(HIWORD(dwLow32));
+		dev->dev_addr[4]=LOBYTE(LOWORD(dwHigh16));
+		dev->dev_addr[5]=HIBYTE(LOWORD(dwHigh16));
+	}
+
+	privateData->MulticastUpdatePending = FALSE;
+
+#ifdef USE_PHY_WORK_AROUND
+	netif_carrier_off(dev);
+	if(!Phy_Initialize(
+		privateData,
+		phy_addr,
+		link_mode))
+	{
+		SMSC_WARNING("Failed to initialize Phy");
+		result=-ENODEV;
+		goto DONE;
+	}
+#endif
+
+	{
+		DWORD dwRxDmaCh=rx_dma;
+		DWORD dwTxDmaCh=tx_dma;
+		privateData->RxDmaChReserved=FALSE;
+
+
+		if(rx_dma==TRANSFER_REQUEST_DMA) {
+			dwRxDmaCh=Platform_RequestDmaChannel(&(privateData->PlatformData));
+			SMSC_ASSERT(dwRxDmaCh!=TRANSFER_REQUEST_DMA);
+			if(dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->RxDmaChReserved=TRUE;
+			}
+		}
+		privateData->TxDmaChReserved=FALSE;
+		if(tx_dma==TRANSFER_REQUEST_DMA) {
+			dwTxDmaCh=Platform_RequestDmaChannel(&(privateData->PlatformData));
+			SMSC_ASSERT(dwTxDmaCh!=TRANSFER_REQUEST_DMA);
+			if(dwTxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->TxDmaChReserved=TRUE;
+			}
+		}
+		Tx_Initialize(privateData,dwTxDmaCh,dma_threshold);
+		Rx_Initialize(privateData,dwRxDmaCh,dma_threshold);
+	}
+
+#ifndef LINUX_2_6_OR_NEWER
+	MOD_INC_USE_COUNT;
+#endif
+	privateData->Running=TRUE;
+	netif_start_queue(dev);
+	Tx_StopQueue(privateData,0x01UL);
+
+
+	Lan_EnableInterrupt(privateData,INT_EN_GPT_INT_EN_);
+#ifndef USE_PHY_WORK_AROUND
+	netif_carrier_off(dev);
+	if(!Phy_Initialize(
+		privateData,
+		phy_addr,
+		link_mode))
+	{
+		SMSC_WARNING("Failed to initialize Phy");
+		result=-ENODEV;
+		goto DONE;
+	}
+#endif
+
+	result=0;
+
+DONE:
+	if(result!=0) {
+#ifndef LINUX_2_6_OR_NEWER
+		MOD_DEC_USE_COUNT;
+#endif
+		if(privateData!=NULL) {
+			if(privateData->TxDmaChReserved) {
+				Platform_ReleaseDmaChannel(platformData,
+					privateData->dwTxDmaCh);
+				privateData->TxDmaChReserved=FALSE;
+			}
+			if(privateData->RxDmaChReserved) {
+				Platform_ReleaseDmaChannel(platformData,
+					privateData->dwRxDmaCh);
+				privateData->RxDmaChReserved=FALSE;
+			}
+			if(acquired_isr) {
+				Platform_FreeIRQ(platformData);
+			}
+			if(acquired_mem_region) {
+				release_mem_region(
+					privateData->dwLanBase,
+					LAN_REGISTER_EXTENT);
+			}
+		}
+	}
+	SMSC_TRACE("<--Smsc911x_open, result=%d",result);
+	return result;
+}
+
+int Smsc911x_stop(struct net_device *dev)
+{
+	int result=0;
+	PPRIVATE_DATA privateData=NULL;
+	SMSC_TRACE("-->Smsc911x_stop(dev=0x%08lX)",(DWORD)dev);
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc911x_stop(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc911x_stop(privateData==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+
+	privateData->StopLinkPolling=TRUE;
+	del_timer_sync(&(privateData->LinkPollingTimer));
+
+	Lan_DisableInterrupt(privateData,INT_EN_GPT_INT_EN_);
+
+	Tx_UpdateTxCounters(privateData);
+	privateData->Running=FALSE;
+	Lan_DisableIRQ(privateData);
+
+	Tx_CompleteDma(privateData);
+
+	Tx_StopQueue(privateData,0x01UL);
+
+#ifndef LINUX_2_6_OR_NEWER
+	MOD_DEC_USE_COUNT;
+#endif
+
+	if(privateData->TxDmaChReserved) {
+		Platform_ReleaseDmaChannel(
+			&(privateData->PlatformData),
+			privateData->dwTxDmaCh);
+		privateData->TxDmaChReserved=FALSE;
+	}
+	if(privateData->RxDmaChReserved) {
+		Platform_ReleaseDmaChannel(
+			&(privateData->PlatformData),
+			privateData->dwRxDmaCh);
+		privateData->RxDmaChReserved=FALSE;
+	}
+
+	Platform_FreeIRQ(&(privateData->PlatformData));
+	release_mem_region(privateData->dwLanBase,LAN_REGISTER_EXTENT);
+
+	{
+		const DWORD dwLanBase=privateData->dwLanBase;
+		const DWORD dwIdRev=privateData->dwIdRev;
+		const DWORD dwFpgaRev=privateData->dwFpgaRev;
+		struct net_device * const tempDev=privateData->dev;
+		char ifName[SMSC_IF_NAME_SIZE];
+		PLATFORM_DATA platformDataBackup;
+		memcpy(ifName,privateData->ifName,SMSC_IF_NAME_SIZE);
+		memcpy(&platformDataBackup,&(privateData->PlatformData),sizeof(PLATFORM_DATA));
+
+		memset(privateData,0,sizeof(PRIVATE_DATA));
+
+		privateData->dwLanBase=dwLanBase;
+		privateData->dwIdRev=dwIdRev;
+		privateData->dwFpgaRev=dwFpgaRev;
+		privateData->dev=tempDev;
+		memcpy(privateData->ifName,ifName,SMSC_IF_NAME_SIZE);
+		memcpy(&(privateData->PlatformData),&platformDataBackup,sizeof(PLATFORM_DATA));
+	}
+
+DONE:
+	SMSC_TRACE("<--Smsc911x_stop, result=%d",result);
+	return result;
+}
+
+int Smsc911x_hard_start_xmit(
+	struct sk_buff *skb, struct net_device * const dev)
+{
+	int result=0;
+	PPRIVATE_DATA privateData=NULL;
+//	SMSC_TRACE("-->Smsc911x_hard_start_xmit(skb=0x%08lX,dev=0x%08lX)",(DWORD)skb,(DWORD)dev);
+	if(skb==NULL) {
+		SMSC_WARNING("Smsc911x_hard_start_xmit(skb==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc911x_hard_start_xmit(dev==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	if(dev->priv==NULL) {
+		SMSC_WARNING("Smsc911x_hard_start_xmit(dev->priv==NULL)");
+		result=-EFAULT;
+		goto DONE;
+	}
+	privateData=(PPRIVATE_DATA)(dev->priv);
+//	SET_GPIO(GP_TX);
+
+	Tx_SendSkb(privateData,skb);
+
+//	CLEAR_GPIO(GP_TX);
+DONE:
+//	SMSC_TRACE("<--Smsc911x_hard_start_xmit, result=%d",result);
+	return result;
+}
+
+struct net_device_stats * Smsc911x_get_stats(struct net_device * const dev)
+{
+	PPRIVATE_DATA privateData=NULL;
+	if(dev==NULL) {
+		SMSC_WARNING("Smsc911x_get_stats(dev==NULL)");
+		return NULL;
+	}
+	if(dev->priv==NULL) {
+		SMSC_WARNING("Smsc911x_get_stats(dev->priv==NULL)");
+		return NULL;
+	}
+
+	privateData=(PPRIVATE_DATA)(dev->priv);
+	if(privateData->Running) {
+		privateData->stats.rx_dropped+=Lan_GetRegDW(RX_DROP);
+		Tx_UpdateTxCounters(privateData);
+	}
+	return &(privateData->stats);
+}
+
+void Smsc911x_set_multicast_list(struct net_device *dev)
+{
+	SMSC_ASSERT(dev!=NULL);
+	Rx_SetMulticastList(dev);
+}
+
+int Smsc911x_do_ioctl(
+	struct net_device *dev,
+	struct ifreq *ifr,
+	int cmd)
+{
+	PPRIVATE_DATA privateData=NULL;
+	PSMSC911x_IOCTL_DATA ioctlData=NULL;
+	BOOLEAN success=FALSE;
+//	SMSC_TRACE("-->Smsc911x_do_ioctl");
+//	SMSC_TRACE("cmd=%d,SIOCGMIIPHY=%d,SIOCDEVPRIVATE=%d",
+//		cmd,SIOCGMIIPHY,SIOCDEVPRIVATE);
+	SMSC_ASSERT(dev!=NULL);
+	SMSC_ASSERT(dev->priv!=NULL);
+	privateData=((PPRIVATE_DATA)dev->priv);
+	if(ifr==NULL) {
+//		SMSC_WARNING("Smsc911x_do_ioctl(ifr==NULL)");
+		goto DONE;
+	}
+
+	if(privateData->LanInitialized) {
+		// standard MII IOC's
+		struct mii_ioctl_data * const data=
+			(struct mii_ioctl_data *) & ifr->ifr_data;
+		switch(cmd) {
+		case SIOCGMIIPHY:
+
+		case SIOCDEVPRIVATE:
+			data->phy_id=1;
+//			SMSC_TRACE("SIOCGMIIPHY: phy_id set to 0x%04X",data->phy_id);
+			return 0;
+		case SIOCGMIIREG:
+		case SIOCDEVPRIVATE+1:
+			{
+				DWORD dwIntFlags=0;
+				VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+				data->val_out=Phy_GetRegW(
+					privateData,data->reg_num,keyCode);
+				Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			}
+//			SMSC_TRACE("SIOCGMIIREG: phy_id=0x%04X, reg_num=0x%04X, val_out set to 0x%04X",
+//				data->phy_id,data->reg_num,data->val_out);
+			return 0;
+		case SIOCSMIIREG:
+		case SIOCDEVPRIVATE+2:
+//			SMSC_TRACE("SIOCSMIIREG: phy_id=0x%04X, reg_num=0x%04X, val_in=0x%04X",
+//				data->phy_id,data->reg_num,data->val_in);
+			{
+				DWORD dwIntFlags=0;
+				VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+				Phy_SetRegW(
+					privateData,data->reg_num,((WORD)(data->val_in)),keyCode);
+				Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			}
+			return 0;
+		default:break;//make lint happy
+		}
+	}
+	if(ifr->ifr_data==NULL) {
+//		SMSC_WARNING("Smsc911x_do_ioctl(ifr->ifr_data==NULL)");
+		goto DONE;
+	}
+	if(cmd!=((int)SMSC911x_IOCTL)) goto DONE;
+	ioctlData=(PSMSC911x_IOCTL_DATA)(ifr->ifr_data);
+	if(ioctlData->dwSignature!=SMSC911x_APP_SIGNATURE) {
+		goto DONE;
+	}
+
+	switch(ioctlData->dwCommand) {
+	case COMMAND_GET_SIGNATURE:
+		success=TRUE;
+		break;
+	case COMMAND_GET_FLOW_PARAMS:
+		ioctlData->Data[0]=privateData->RxFlowMeasuredMaxThroughput;
+		ioctlData->Data[1]=privateData->RxFlowMeasuredMaxPacketCount;
+		ioctlData->Data[2]=privateData->RxFlowParameters.MaxThroughput;
+		ioctlData->Data[3]=privateData->RxFlowParameters.MaxPacketCount;
+		ioctlData->Data[4]=privateData->RxFlowParameters.PacketCost;
+		ioctlData->Data[5]=privateData->RxFlowParameters.BurstPeriod;
+		ioctlData->Data[6]=privateData->RxFlowMaxWorkLoad;
+		ioctlData->Data[7]=Lan_GetRegDW(INT_CFG)>>24;
+		privateData->RxFlowMeasuredMaxThroughput=0;
+		privateData->RxFlowMeasuredMaxPacketCount=0;
+		success=TRUE;
+		break;
+	case COMMAND_SET_FLOW_PARAMS:
+		if(!(privateData->RxFlowControlActive)) {
+			privateData->RxFlowParameters.MaxThroughput=ioctlData->Data[2];
+			privateData->RxFlowParameters.MaxPacketCount=ioctlData->Data[3];
+			privateData->RxFlowParameters.PacketCost=ioctlData->Data[4];
+			privateData->RxFlowParameters.BurstPeriod=ioctlData->Data[5];
+			if(ioctlData->Data[6]==0xFFFFFFFFUL) {
+				privateData->RxFlowMaxWorkLoad=
+					privateData->RxFlowParameters.MaxThroughput+
+					(privateData->RxFlowParameters.MaxPacketCount*
+					privateData->RxFlowParameters.PacketCost);
+			} else {
+				privateData->RxFlowMaxWorkLoad=ioctlData->Data[6];
+			}
+			Lan_SetIntDeas(privateData,ioctlData->Data[7]);
+			privateData->RxFlowBurstMaxWorkLoad=
+				(privateData->RxFlowMaxWorkLoad*
+				privateData->RxFlowParameters.BurstPeriod)/1000;
+			success=TRUE;
+		};break;
+	case COMMAND_GET_CONFIGURATION:
+		ioctlData->Data[0]=DRIVER_VERSION;
+		ioctlData->Data[1]=lan_base;
+		ioctlData->Data[2]=bus_width;
+		ioctlData->Data[3]=link_mode;
+		ioctlData->Data[4]=irq;
+		ioctlData->Data[5]=int_deas;
+		ioctlData->Data[6]=irq_pol;
+		ioctlData->Data[7]=irq_type;
+		ioctlData->Data[8]=rx_dma;
+		ioctlData->Data[9]=tx_dma;
+		ioctlData->Data[10]=dma_threshold;
+		ioctlData->Data[11]=mac_addr_hi16;
+		ioctlData->Data[12]=mac_addr_lo32;
+		ioctlData->Data[13]=debug_mode;
+		ioctlData->Data[14]=tx_fif_sz;
+		ioctlData->Data[15]=afc_cfg;
+		ioctlData->Data[16]=tasklets;
+		ioctlData->Data[17]=max_throughput;
+		ioctlData->Data[18]=max_packet_count;
+		ioctlData->Data[19]=packet_cost;
+		ioctlData->Data[20]=burst_period;
+		ioctlData->Data[21]=max_work_load;
+		ioctlData->Data[22]=privateData->dwIdRev;
+		ioctlData->Data[23]=privateData->dwFpgaRev;
+		ioctlData->Data[24]=1;
+		ioctlData->Data[25]=privateData->dwPhyId;
+		ioctlData->Data[26]=privateData->bPhyModel;
+		ioctlData->Data[27]=privateData->bPhyRev;
+		ioctlData->Data[28]=privateData->dwLinkSpeed;
+		ioctlData->Data[29]=privateData->RxFlowMeasuredMaxThroughput;
+		ioctlData->Data[30]=privateData->RxFlowMeasuredMaxPacketCount;
+		ioctlData->Data[31]=privateData->RxFlowParameters.MaxThroughput;
+		ioctlData->Data[32]=privateData->RxFlowParameters.MaxPacketCount;
+		ioctlData->Data[33]=privateData->RxFlowParameters.PacketCost;
+		ioctlData->Data[34]=privateData->RxFlowParameters.BurstPeriod;
+		ioctlData->Data[35]=privateData->RxFlowMaxWorkLoad;
+		sprintf(ioctlData->Strng1,"%s, %s",__DATE__,__TIME__);
+		sprintf(ioctlData->Strng2,"%s",privateData->ifName);
+		privateData->RxFlowMeasuredMaxThroughput=0;
+		privateData->RxFlowMeasuredMaxPacketCount=0;
+		success=TRUE;
+		break;
+	case COMMAND_LAN_GET_REG:
+		if((ioctlData->Data[0]<LAN_REGISTER_EXTENT)&&
+			((ioctlData->Data[0]&0x3UL)==0))
+		{
+			ioctlData->Data[1]=
+				(*((volatile DWORD *)(privateData->dwLanBase+
+						ioctlData->Data[0])));
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading LAN911x Mem Map Failed");
+			goto MEM_MAP_ACCESS_FAILED;
+		}
+		break;
+	case COMMAND_LAN_SET_REG:
+		if((ioctlData->Data[0]<LAN_REGISTER_EXTENT)&&
+			((ioctlData->Data[0]&0x3UL)==0))
+		{
+			(*((volatile DWORD *)(privateData->dwLanBase+
+						ioctlData->Data[0])))=ioctlData->Data[1];
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading LAN911x Mem Map Failed");
+MEM_MAP_ACCESS_FAILED:
+			SMSC_WARNING("  Invalid offset == 0x%08lX",ioctlData->Data[0]);
+			if(ioctlData->Data[0]>=LAN_REGISTER_EXTENT) {
+				SMSC_WARNING("    Out of range");
+			}
+			if(ioctlData->Data[0]&0x3UL) {
+				SMSC_WARNING("    Not DWORD aligned");
+			}
+		}
+		break;
+	case COMMAND_MAC_GET_REG:
+		if((ioctlData->Data[0]<=0xC)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[1]=
+				Mac_GetRegDW(privateData,ioctlData->Data[0],keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading Mac Register Failed");
+			goto MAC_ACCESS_FAILURE;
+		}
+		break;
+	case COMMAND_MAC_SET_REG:
+		if((ioctlData->Data[0]<=0xC)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Mac_SetRegDW(
+				privateData,
+				ioctlData->Data[0],
+				ioctlData->Data[1],
+				keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Writing Mac Register Failed");
+MAC_ACCESS_FAILURE:
+			if(!(privateData->LanInitialized)) {
+
+				SMSC_WARNING("  LAN Not Initialized,");
+				SMSC_WARNING("    Use ifconfig to bring interface UP");
+			}
+			if(!(ioctlData->Data[0]<=0xC)) {
+				SMSC_WARNING("  Invalid index == 0x%08lX",ioctlData->Data[0]);
+			}
+		}
+		break;
+	case COMMAND_PHY_GET_REG:
+		if((ioctlData->Data[0]<32)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[1]=((DWORD)
+				Phy_GetRegW(privateData,ioctlData->Data[0],keyCode));
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Reading Phy Register Failed");
+			goto PHY_ACCESS_FAILURE;
+		}
+		break;
+	case COMMAND_PHY_SET_REG:
+		if((ioctlData->Data[0]<32)&&(privateData->LanInitialized)) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Phy_SetRegW(
+				privateData,
+				ioctlData->Data[0],
+				((WORD)(ioctlData->Data[1])),
+				keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Writing Phy Register Failed");
+PHY_ACCESS_FAILURE:
+			if(!(privateData->LanInitialized)) {
+				SMSC_WARNING("  Lan Not Initialized,");
+				SMSC_WARNING("    Use ifconfig to bring interface UP");
+			}
+			if(!(ioctlData->Data[0]<32)) {
+				SMSC_WARNING("  Invalid index == 0x%ld",ioctlData->Data[0]);
+			}
+		}
+		break;
+//	case COMMAND_DUMP_TEMP:
+//		{
+//			DWORD c=0;
+//			for(c=0;c<0x40;c++)
+//				ioctlData->Data[c]=privateData->temp[c];
+//		}
+//		success=TRUE;
+//		break;
+	case COMMAND_DUMP_LAN_REGS:
+		ioctlData->Data[LAN_REG_ID_REV]=Lan_GetRegDW(ID_REV);
+		ioctlData->Data[LAN_REG_INT_CFG]=Lan_GetRegDW(INT_CFG);
+		ioctlData->Data[LAN_REG_INT_STS]=Lan_GetRegDW(INT_STS);
+		ioctlData->Data[LAN_REG_INT_EN]=Lan_GetRegDW(INT_EN);
+		ioctlData->Data[LAN_REG_BYTE_TEST]=Lan_GetRegDW(BYTE_TEST);
+		ioctlData->Data[LAN_REG_FIFO_INT]=Lan_GetRegDW(FIFO_INT);
+		ioctlData->Data[LAN_REG_RX_CFG]=Lan_GetRegDW(RX_CFG);
+		ioctlData->Data[LAN_REG_TX_CFG]=Lan_GetRegDW(TX_CFG);
+		ioctlData->Data[LAN_REG_HW_CFG]=Lan_GetRegDW(HW_CFG);
+		ioctlData->Data[LAN_REG_RX_DP_CTRL]=Lan_GetRegDW(RX_DP_CTRL);
+		ioctlData->Data[LAN_REG_RX_FIFO_INF]=Lan_GetRegDW(RX_FIFO_INF);
+		ioctlData->Data[LAN_REG_TX_FIFO_INF]=Lan_GetRegDW(TX_FIFO_INF);
+		ioctlData->Data[LAN_REG_PMT_CTRL]=Lan_GetRegDW(PMT_CTRL);
+		ioctlData->Data[LAN_REG_GPIO_CFG]=Lan_GetRegDW(GPIO_CFG);
+		ioctlData->Data[LAN_REG_GPT_CFG]=Lan_GetRegDW(GPT_CFG);
+		ioctlData->Data[LAN_REG_GPT_CNT]=Lan_GetRegDW(GPT_CNT);
+		ioctlData->Data[LAN_REG_FPGA_REV]=Lan_GetRegDW(FPGA_REV);
+		ioctlData->Data[LAN_REG_ENDIAN]=Lan_GetRegDW(ENDIAN);
+		ioctlData->Data[LAN_REG_FREE_RUN]=Lan_GetRegDW(FREE_RUN);
+		ioctlData->Data[LAN_REG_RX_DROP]=Lan_GetRegDW(RX_DROP);
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[LAN_REG_MAC_CSR_CMD]=Lan_GetRegDW(MAC_CSR_CMD);
+			ioctlData->Data[LAN_REG_MAC_CSR_DATA]=Lan_GetRegDW(MAC_CSR_DATA);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+		} else {
+			ioctlData->Data[LAN_REG_MAC_CSR_CMD]=Lan_GetRegDW(MAC_CSR_CMD);
+			ioctlData->Data[LAN_REG_MAC_CSR_DATA]=Lan_GetRegDW(MAC_CSR_DATA);
+		}
+		ioctlData->Data[LAN_REG_AFC_CFG]=Lan_GetRegDW(AFC_CFG);
+		ioctlData->Data[LAN_REG_E2P_CMD]=Lan_GetRegDW(E2P_CMD);
+		ioctlData->Data[LAN_REG_E2P_DATA]=Lan_GetRegDW(E2P_DATA);
+		success=TRUE;
+		break;
+	case COMMAND_DUMP_MAC_REGS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[MAC_REG_MAC_CR]=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			ioctlData->Data[MAC_REG_ADDRH]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			ioctlData->Data[MAC_REG_ADDRL]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			ioctlData->Data[MAC_REG_HASHH]=Mac_GetRegDW(privateData,HASHH,keyCode);
+			ioctlData->Data[MAC_REG_HASHL]=Mac_GetRegDW(privateData,HASHL,keyCode);
+			ioctlData->Data[MAC_REG_MII_ACC]=Mac_GetRegDW(privateData,MII_ACC,keyCode);
+			ioctlData->Data[MAC_REG_MII_DATA]=Mac_GetRegDW(privateData,MII_DATA,keyCode);
+			ioctlData->Data[MAC_REG_FLOW]=Mac_GetRegDW(privateData,FLOW,keyCode);
+			ioctlData->Data[MAC_REG_VLAN1]=Mac_GetRegDW(privateData,VLAN1,keyCode);
+			ioctlData->Data[MAC_REG_VLAN2]=Mac_GetRegDW(privateData,VLAN2,keyCode);
+			ioctlData->Data[MAC_REG_WUFF]=Mac_GetRegDW(privateData,WUFF,keyCode);
+			ioctlData->Data[MAC_REG_WUCSR]=Mac_GetRegDW(privateData,WUCSR,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Mac Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+	case COMMAND_DUMP_PHY_REGS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[PHY_REG_0]=Phy_GetRegW(privateData,0,keyCode);
+			ioctlData->Data[PHY_REG_1]=Phy_GetRegW(privateData,1,keyCode);
+			ioctlData->Data[PHY_REG_2]=Phy_GetRegW(privateData,2,keyCode);
+			ioctlData->Data[PHY_REG_3]=Phy_GetRegW(privateData,3,keyCode);
+			ioctlData->Data[PHY_REG_4]=Phy_GetRegW(privateData,4,keyCode);
+			ioctlData->Data[PHY_REG_5]=Phy_GetRegW(privateData,5,keyCode);
+			ioctlData->Data[PHY_REG_6]=Phy_GetRegW(privateData,6,keyCode);
+			ioctlData->Data[PHY_REG_16]=Phy_GetRegW(privateData,16,keyCode);
+			ioctlData->Data[PHY_REG_17]=Phy_GetRegW(privateData,17,keyCode);
+			ioctlData->Data[PHY_REG_18]=Phy_GetRegW(privateData,18,keyCode);
+			ioctlData->Data[PHY_REG_20]=Phy_GetRegW(privateData,20,keyCode);
+			ioctlData->Data[PHY_REG_21]=Phy_GetRegW(privateData,21,keyCode);
+			ioctlData->Data[PHY_REG_22]=Phy_GetRegW(privateData,22,keyCode);
+			ioctlData->Data[PHY_REG_23]=Phy_GetRegW(privateData,23,keyCode);
+			ioctlData->Data[PHY_REG_27]=Phy_GetRegW(privateData,27,keyCode);
+			ioctlData->Data[PHY_REG_28]=Phy_GetRegW(privateData,28,keyCode);
+			ioctlData->Data[PHY_REG_29]=Phy_GetRegW(privateData,29,keyCode);
+			ioctlData->Data[PHY_REG_30]=Phy_GetRegW(privateData,30,keyCode);
+			ioctlData->Data[PHY_REG_31]=Phy_GetRegW(privateData,31,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Phy Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+	case COMMAND_DUMP_EEPROM:
+		{
+			BYTE data=0;
+			BYTE index=0;
+			Eeprom_EnableAccess(privateData);
+			success=TRUE;
+			for(index=0;index<8;index++) {
+				if(Eeprom_ReadLocation(privateData,index,&data)) {
+					ioctlData->Data[index]=(DWORD)data;
+				} else {
+					success=FALSE;
+					break;
+				}
+			}
+			Eeprom_DisableAccess(privateData);
+		};break;
+	case COMMAND_GET_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			ioctlData->Data[0]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+			ioctlData->Data[1]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		}
+		break;
+
+	case COMMAND_SET_MAC_ADDRESS:
+		if(privateData->LanInitialized)
+		{
+			DWORD dwLow32=ioctlData->Data[1];
+			DWORD dwHigh16=ioctlData->Data[0];
+			DWORD dwIntFlags=0;
+			VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+			Mac_SetRegDW(privateData,ADDRH,dwHigh16,keyCode);
+			Mac_SetRegDW(privateData,ADDRL,dwLow32,keyCode);
+			Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+			success=TRUE;
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_LOAD_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			Eeprom_EnableAccess(privateData);
+			if(Eeprom_Reload(privateData)) {
+				if(Eeprom_IsMacAddressLoaded(privateData)) {
+					DWORD dwIntFlags=0;
+					VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+					ioctlData->Data[0]=Mac_GetRegDW(privateData,ADDRH,keyCode);
+					ioctlData->Data[1]=Mac_GetRegDW(privateData,ADDRL,keyCode);
+					Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+					success=TRUE;
+				} else {
+					SMSC_WARNING("Failed to Load Mac Address(1)");
+				}
+			} else {
+				SMSC_WARNING("Failed to Load Mac Address(2)");
+			}
+			Eeprom_DisableAccess(privateData);
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_SAVE_MAC_ADDRESS:
+		if(privateData->LanInitialized) {
+			if(Eeprom_SaveMacAddress(privateData,
+				ioctlData->Data[0],ioctlData->Data[1])) {
+				success=TRUE;
+			}
+		} else {
+			SMSC_WARNING("Lan Not Initialized,");
+			SMSC_WARNING("  Use ifconfig to bring interface UP");
+		};break;
+	case COMMAND_SET_DEBUG_MODE:
+		debug_mode=ioctlData->Data[0];
+		if(debug_mode&0x04UL) {
+			if(OLD_REGISTERS(privateData))
+			{
+				g_GpioSetting=0x00270700UL;
+			} else {
+				g_GpioSetting=0x00670700UL;
+			}
+			Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+		} else {
+			Lan_SetRegDW(GPIO_CFG,0x70070000);
+		}
+		success=TRUE;
+		break;
+	case COMMAND_SET_LINK_MODE:
+		link_mode=(ioctlData->Data[0]&0x7FUL);
+		if(privateData->LanInitialized) {
+			Phy_SetLink(privateData,link_mode);
+		}
+		success=TRUE;
+		break;
+	case COMMAND_GET_LINK_MODE:
+		ioctlData->Data[0]=link_mode;
+		success=TRUE;
+		break;
+	case COMMAND_CHECK_LINK:
+		Phy_UpdateLinkMode(privateData);
+		success=TRUE;
+		break;
+	case COMMAND_READ_BYTE:
+		ioctlData->Data[1]=(*((volatile BYTE *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_READ_WORD:
+		ioctlData->Data[1]=(*((volatile WORD *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_READ_DWORD:
+		ioctlData->Data[1]=(*((volatile DWORD *)(ioctlData->Data[0])));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_BYTE:
+		(*((volatile BYTE *)(ioctlData->Data[0])))=
+			((BYTE)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_WORD:
+		(*((volatile WORD *)(ioctlData->Data[0])))=
+			((WORD)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	case COMMAND_WRITE_DWORD:
+		(*((volatile DWORD *)(ioctlData->Data[0])))=
+			((DWORD)(ioctlData->Data[1]));
+		success=TRUE;
+		break;
+	default:break;//make lint happy
+	}
+
+DONE:
+	if((success)&&(ioctlData!=NULL)) {
+		ioctlData->dwSignature=SMSC911x_DRIVER_SIGNATURE;
+		return 0;
+	}
+//	SMSC_TRACE("<--Smsc911x_do_ioctl");
+	return -1;
+}
+
+//returns time1-time2;
+TIME_SPAN Gpt_FreeRunCompare(DWORD time1,DWORD time2)
+{
+	return ((TIME_SPAN)(time1-time2));
+}
+void Gpt_ScheduleInterrupt(PPRIVATE_DATA privateData,TIME_SPAN timeSpan)
+{
+	DWORD timerValue=0;
+	if(timeSpan<0) timeSpan=0;
+	timerValue=(DWORD)timeSpan;
+	if((timerValue%2500)>=1250) {
+		timerValue=(timerValue/2500)+1;
+	} else {
+		timerValue=(timerValue/2500);
+	}
+	if(timerValue>0x0000FFFFUL) {
+		timerValue=0x0000FFFF;
+	}
+	Lan_SetRegDW(GPT_CFG,(timerValue|GPT_CFG_TIMER_EN_));
+	Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+}
+
+void Gpt_CancelInterrupt(PPRIVATE_DATA privateData)
+{
+	Lan_SetRegDW(GPT_CFG,0UL);
+	Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+}
+
+void Gpt_ScheduleCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData),
+	DWORD callBackTime)
+{
+	DWORD slot_index=GPT_SCHEDULE_DEPTH;
+	BOOLEAN result=FALSE;
+	if((callBackFunction!=NULL)&&(callBackTime!=0)) {
+		DWORD dwIntFlags=0;
+		SMSC_ASSERT(privateData!=NULL);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]==NULL) {
+					if(!result) {
+						result=TRUE;
+						//lint -save
+						//lint -e611 //suspicious cast
+						privateData->GptFunction[index]=(void *)callBackFunction;
+						//lint -restore_
+						privateData->GptCallTime[index]=currentTime+(2500*callBackTime);
+						timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+						if(nextCallTime>timeSpan) {
+							nextCallTime=timeSpan;
+							rescheduleRequired=TRUE;
+							slot_index = index;
+						}
+					}
+				} else {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(nextCallTime>=timeSpan) {
+						nextCallTime=timeSpan;
+						rescheduleRequired=FALSE;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				privateData->Gpt_scheduled_slot_index = slot_index;
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+	}
+	if(!result) {
+		SMSC_WARNING("Gpt_ScheduleCallBack: Failed");
+	}
+}
+
+void Gpt_CancelCallBack(
+	PPRIVATE_DATA privateData,
+	void (*callBackFunction)(PPRIVATE_DATA privateData))
+{
+	BOOLEAN result=FALSE;
+	if(callBackFunction!=NULL) {
+		DWORD dwIntFlags=0;
+		SMSC_ASSERT(privateData!=NULL);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]==callBackFunction) {
+					result=TRUE;
+					//lint -save
+					//lint -e611 //suspicious cast
+					privateData->GptFunction[index]=(void *)NULL;
+					// cancelled time will not need a
+					// re-scheduled
+
+					// re-scheduled is done at other
+					// non-null slots
+				}
+				else if(privateData->GptFunction[index]!=NULL) {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					// if this scheduled time is earlier
+					// than current scheduled time
+					// AND not a duplicated one
+					if(nextCallTime>=timeSpan && privateData->Gpt_scheduled_slot_index != index) {
+						nextCallTime=timeSpan;
+						rescheduleRequired=TRUE;
+						privateData->Gpt_scheduled_slot_index = index;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+			else if (privateData->Gpt_scheduled_slot_index==GPT_SCHEDULE_DEPTH) {
+				Gpt_CancelInterrupt(privateData);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+	}
+	if(!result) {
+		SMSC_WARNING("Gpt_CancelCallBack: Failed");
+	}
+}
+
+BOOLEAN Gpt_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(dwIntSts&INT_STS_GPT_INT_)
+	{
+		DWORD dwIntFlags=0;
+		Lan_SetRegDW(INT_STS,INT_STS_GPT_INT_);
+		spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+		{
+			DWORD index=0;
+			DWORD currentTime=Lan_GetRegDW(FREE_RUN);
+			TIME_SPAN timeSpan=MAX_TIME_SPAN;
+			TIME_SPAN nextCallTime=MAX_TIME_SPAN;
+			BOOLEAN rescheduleRequired=FALSE;
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]!=NULL) {
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(timeSpan<1250) {
+						void (*callBackFunction)(PPRIVATE_DATA privateData);
+						callBackFunction=privateData->GptFunction[index];
+						privateData->GptFunction[index]=NULL;
+						spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+						privateData->Gpt_scheduled_slot_index = GPT_SCHEDULE_DEPTH;
+						callBackFunction(privateData);
+						spin_lock_irqsave(&(privateData->GpTimerLock),dwIntFlags);
+					}
+				}
+			}
+			for(index=0;index<GPT_SCHEDULE_DEPTH;index++) {
+				if(privateData->GptFunction[index]!=NULL) {
+					rescheduleRequired=TRUE;
+					timeSpan=Gpt_FreeRunCompare(privateData->GptCallTime[index],currentTime);
+					if(nextCallTime>timeSpan) {
+						nextCallTime=timeSpan;
+						privateData->Gpt_scheduled_slot_index = index;
+					}
+				}
+			}
+			if(rescheduleRequired) {
+				Gpt_ScheduleInterrupt(privateData,nextCallTime);
+			}
+		}
+		spin_unlock_irqrestore(&(privateData->GpTimerLock),dwIntFlags);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+void GptCB_RxCompleteMulticast(PPRIVATE_DATA privateData)
+{
+	Rx_CompleteMulticastUpdate (privateData);
+}
+
+void GptCB_RestartBurst(PPRIVATE_DATA privateData)
+{
+	if(privateData->RxFlowControlActive) {
+		privateData->RxFlowBurstActive=TRUE;
+		if(privateData->RxFlowBurstWorkLoad>privateData->RxFlowBurstMaxWorkLoad) {
+			privateData->RxFlowBurstWorkLoad-=privateData->RxFlowBurstMaxWorkLoad;
+		} else {
+			privateData->RxFlowBurstWorkLoad=0;
+		}
+		Gpt_ScheduleCallBack(privateData,GptCB_RestartBurst,
+				privateData->RxFlowParameters.BurstPeriod);
+	}
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+void GptCB_MeasureRxThroughput(PPRIVATE_DATA privateData)
+{
+	if(privateData->RxFlowMeasuredMaxThroughput<privateData->RxFlowCurrentThroughput) {
+		privateData->RxFlowMeasuredMaxThroughput=privateData->RxFlowCurrentThroughput;
+	}
+	if(privateData->RxFlowMeasuredMaxPacketCount<privateData->RxFlowCurrentPacketCount) {
+		privateData->RxFlowMeasuredMaxPacketCount=privateData->RxFlowCurrentPacketCount;
+	}
+	if(privateData->RxFlowCurrentThroughput!=0) {
+		if(privateData->RxFlowMaxWorkLoad!=0) {
+			if(!(privateData->RxFlowControlActive)) {
+				DWORD activationLevel=
+					(privateData->RxFlowMaxWorkLoad*(100+RX_FLOW_ACTIVATION))/100;
+				if(privateData->RxFlowCurrentWorkLoad>=activationLevel) {
+					privateData->RxFlowControlActive=TRUE;
+					privateData->RxFlowBurstActive=TRUE;
+					privateData->RxFlowBurstWorkLoad=0;
+					Gpt_ScheduleCallBack(privateData,GptCB_RestartBurst,
+							privateData->RxFlowParameters.BurstPeriod);
+					//SET_GPIO(GP_TX);
+				}
+			} else {
+				DWORD deactivationLevel=
+					(privateData->RxFlowMaxWorkLoad*(100-RX_FLOW_DEACTIVATION))/100;
+				if(privateData->RxFlowCurrentWorkLoad<=deactivationLevel) {
+					privateData->RxFlowControlActive=FALSE;
+					//CLEAR_GPIO(GP_TX);
+				}
+			}
+		}
+		privateData->RxFlowCurrentThroughput=0;
+		privateData->RxFlowCurrentPacketCount=0;
+		privateData->RxFlowCurrentWorkLoad=0;
+		Gpt_ScheduleCallBack(privateData,GptCB_MeasureRxThroughput,1000);
+	} else {
+		if(privateData->RxFlowMaxWorkLoad!=0) {
+			if(privateData->RxFlowControlActive) {
+				privateData->RxFlowControlActive=FALSE;
+				//CLEAR_GPIO(GP_TX);
+			}
+		}
+		privateData->MeasuringRxThroughput=FALSE;
+	}
+}
+
+irqreturn_t Smsc911x_ISR(int Irq, void *dev_id, struct pt_regs *regs)
+{
+	DWORD dwIntCfg=0;
+	DWORD dwIntSts=0;
+	PPRIVATE_DATA privateData=(PPRIVATE_DATA)dev_id;
+	BOOLEAN serviced=FALSE;
+
+	regs=regs;//make lint happy
+	Irq=Irq;//make lint happy
+
+	if(privateData==NULL) {
+		SMSC_WARNING("Smsc911x_ISR(privateData==NULL)");
+		goto DONE;
+	}
+	if(privateData->dwLanBase==0) {
+		SMSC_WARNING("Smsc911x_ISR(dwLanBase==0)");
+		goto DONE;
+	}
+	SET_GPIO(GP_ISR);
+	dwIntCfg=Lan_GetRegDW(INT_CFG);
+	if((dwIntCfg&0x00001100)!=0x00001100) {
+		SMSC_TRACE("In ISR, not my interrupt, dwIntCfg=0x%08lX",
+			dwIntCfg);
+		goto ALMOST_DONE;
+	}
+
+	{
+		DWORD reservedBits;
+		if(OLD_REGISTERS(privateData)) {
+			reservedBits=0x00FFEEEEUL;
+		} else {
+			reservedBits=0x00FFCEEEUL;
+		}
+		if(dwIntCfg&reservedBits) {
+			SMSC_WARNING("In ISR, reserved bits are high.");
+			//this could mean surprise removal
+			goto ALMOST_DONE;
+		}
+	}
+
+	dwIntSts=Lan_GetRegDW(INT_STS);
+	privateData->LastIntStatus3=privateData->LastIntStatus2;
+	privateData->LastIntStatus2=privateData->LastIntStatus1;
+	privateData->LastIntStatus1=dwIntSts;
+	if(Lan_HandleSoftwareInterrupt(privateData,dwIntSts)) {
+		serviced=TRUE;
+	}
+	if(Gpt_HandleInterrupt(privateData,dwIntSts)) {
+		serviced=TRUE;
+	}
+	if(Tx_HandleInterrupt(privateData,dwIntSts)) {
+		serviced=TRUE;
+	}
+	if(RxStop_HandleInterrupt(privateData,dwIntSts)) {
+		serviced=TRUE;
+	}
+	if(Rx_HandleInterrupt(privateData,dwIntSts)) {
+		serviced=TRUE;
+	}
+
+	if(!serviced) {
+		SMSC_WARNING("unserviced interrupt dwIntCfg=0x%08lX,dwIntSts=0x%08lX,INT_EN=0x%08lX",
+			dwIntCfg,dwIntSts,Lan_GetRegDW(INT_EN));
+	}
+
+ALMOST_DONE:
+	CLEAR_GPIO(GP_ISR);
+DONE:
+	return IRQ_RETVAL(serviced);
+}
+
+#ifdef USE_PHY_WORK_AROUND
+BOOLEAN Phy_Reset(PPRIVATE_DATA privateData,VL_KEY keyCode)
+{
+	BOOLEAN result=FALSE;
+	WORD wTemp=0;
+	DWORD dwLoopCount=100000;
+	SMSC_TRACE("Performing PHY BCR Reset");
+	Phy_SetRegW(privateData,PHY_BCR,PHY_BCR_RESET_,keyCode);
+	do {
+		udelay(10);
+		wTemp=Phy_GetRegW(privateData,PHY_BCR,keyCode);
+		dwLoopCount--;
+	} while((dwLoopCount>0)&&(wTemp&PHY_BCR_RESET_));
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("Phy Reset failed to complete.");
+		goto DONE;
+	}
+	//extra delay required because the phy may not be completed with its reset
+	//  when PHY_BCR_RESET_ is cleared.
+	//  They say 256 uS is enough delay but I'm using 500 here to be safe
+	udelay(500);
+	result=TRUE;
+DONE:
+	return result;
+}
+
+DWORD Phy_LBT_GetTxStatus(PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		if(result!=0x00800000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		if(result!=0x00000000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	}
+	return result;
+}
+
+DWORD Phy_LBT_GetRxStatus(PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(RX_FIFO_INF);
+	if(result&0x00FF0000UL) {
+		//Rx status is available, read it
+		result=Lan_GetRegDW(RX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+	return result;
+}
+
+BOOLEAN Phy_TransmitTestPacket(PPRIVATE_DATA privateData)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwLoopCount=0;
+	DWORD dwTxCmdA=0;
+	DWORD dwTxCmdB=0;
+	DWORD dwStatus=0;
+
+	//write Tx Packet to 118
+	dwTxCmdA=
+		((((DWORD)(privateData->LoopBackTxPacket))&0x03UL)<<16) | //DWORD alignment adjustment
+		TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+		((DWORD)(MIN_PACKET_SIZE));
+	dwTxCmdB=
+		(((DWORD)(MIN_PACKET_SIZE))<<16) |
+		((DWORD)(MIN_PACKET_SIZE));
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+	Platform_WriteFifo(
+		privateData->dwLanBase,
+		(DWORD *)(((DWORD)(privateData->LoopBackTxPacket))&0xFFFFFFFCUL),
+		(((DWORD)(MIN_PACKET_SIZE))+3+
+		(((DWORD)(privateData->LoopBackTxPacket))&0x03UL))>>2);
+
+	//wait till transmit is done
+	dwLoopCount=60;
+	while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetTxStatus(privateData))==0)) {
+		udelay(5);
+		dwLoopCount--;
+	}
+	if(dwStatus==0) {
+		SMSC_WARNING("Failed to Transmit during Packet Test");
+		goto DONE;
+	}
+	if(dwStatus&0x00008000UL) {
+		SMSC_WARNING("Transmit encountered errors during Packet Test");
+		goto DONE;
+	}
+DONE:
+	return result;
+}
+
+BOOLEAN Phy_CheckLoopBackPacket(PPRIVATE_DATA privateData)
+
+{
+	BOOLEAN result=FALSE;
+	DWORD tryCount=0;
+	DWORD dwLoopCount=0;
+	for(tryCount=0;tryCount<10;tryCount++)
+	{
+		DWORD dwTxCmdA=0;
+		DWORD dwTxCmdB=0;
+		DWORD dwStatus=0;
+		DWORD dwPacketLength=0;
+
+		//zero-out Rx Packet memory
+		memset(privateData->LoopBackRxPacket,0,MIN_PACKET_SIZE);
+
+		//write Tx Packet to 118
+		dwTxCmdA=
+			((((DWORD)(privateData->LoopBackTxPacket))&0x03UL)<<16) | //DWORD alignment adjustment
+			TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+			((DWORD)(MIN_PACKET_SIZE));
+		dwTxCmdB=
+			(((DWORD)(MIN_PACKET_SIZE))<<16) |
+			((DWORD)(MIN_PACKET_SIZE));
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+		Platform_WriteFifo(
+			privateData->dwLanBase,
+			(DWORD *)(((DWORD)(privateData->LoopBackTxPacket))&0xFFFFFFFCUL),
+			(((DWORD)(MIN_PACKET_SIZE))+3+
+			(((DWORD)(privateData->LoopBackTxPacket))&0x03UL))>>2);
+
+		//wait till transmit is done
+		dwLoopCount=60;
+		while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetTxStatus(privateData))==0)) {
+			udelay(5);
+			dwLoopCount--;
+		}
+		if(dwStatus==0) {
+			SMSC_WARNING("Failed to Transmit during Loop Back Test");
+			continue;
+		}
+		if(dwStatus&0x00008000UL) {
+			SMSC_WARNING("Transmit encountered errors during Loop Back Test");
+			continue;
+		}
+
+		//wait till receive is done
+		dwLoopCount=60;
+		while((dwLoopCount>0)&&((dwStatus=Phy_LBT_GetRxStatus(privateData))==0))
+		{
+	         udelay(5);
+	         dwLoopCount--;
+		}
+		if(dwStatus==0) {
+			SMSC_WARNING("Failed to Receive during Loop Back Test");
+			continue;
+		}
+		if(dwStatus&RX_STS_ES_)
+		{
+			SMSC_WARNING("Receive encountered errors during Loop Back Test");
+			continue;
+		}
+
+		dwPacketLength=((dwStatus&0x3FFF0000UL)>>16);
+
+		Platform_ReadFifo(
+			privateData->dwLanBase,
+			((DWORD *)(privateData->LoopBackRxPacket)),
+			(dwPacketLength+3+(((DWORD)(privateData->LoopBackRxPacket))&0x03UL))>>2);
+
+		if(dwPacketLength!=(MIN_PACKET_SIZE+4)) {
+			SMSC_WARNING("Unexpected packet size during loop back test, size=%ld, will retry",dwPacketLength);
+		} else {
+			DWORD byteIndex=0;
+			BOOLEAN foundMissMatch=FALSE;
+			for(byteIndex=0;byteIndex<MIN_PACKET_SIZE;byteIndex++) {
+				if(privateData->LoopBackTxPacket[byteIndex]!=privateData->LoopBackRxPacket[byteIndex])
+				{
+					foundMissMatch=TRUE;
+					break;
+				}
+			}
+			if(!foundMissMatch) {
+				SMSC_TRACE("Successfully Verified Loop Back Packet");
+				result=TRUE;
+				goto DONE;
+			} else {
+				SMSC_WARNING("Data miss match during loop back test, will retry.");
+			}
+		}
+	}
+DONE:
+	return result;
+}
+
+BOOLEAN Phy_LoopBackTest(PPRIVATE_DATA privateData)
+{
+	BOOLEAN result=FALSE;
+	DWORD byteIndex=0;
+	DWORD tryCount=0;
+//	DWORD failed=0;
+	//Initialize Tx Packet
+	for(byteIndex=0;byteIndex<6;byteIndex++) {
+		//use broadcast destination address
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)0xFF;
+	}
+	for(byteIndex=6;byteIndex<12;byteIndex++) {
+		//use incrementing source address
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)byteIndex;
+	}
+	//Set length type field
+	privateData->LoopBackTxPacket[12]=0x00;
+	privateData->LoopBackTxPacket[13]=0x00;
+	for(byteIndex=14;byteIndex<MIN_PACKET_SIZE;byteIndex++)
+	{
+		privateData->LoopBackTxPacket[byteIndex]=(BYTE)byteIndex;
+	}
+//TRY_AGAIN:
+	{
+		DWORD dwRegVal=Lan_GetRegDW(HW_CFG);
+		dwRegVal&=(HW_CFG_TX_FIF_SZ_|0x00000FFFUL);
+		dwRegVal|=HW_CFG_SF_;
+		Lan_SetRegDW(HW_CFG,dwRegVal);
+	}
+	Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+
+	Lan_SetRegDW(RX_CFG,(((DWORD)(privateData->LoopBackRxPacket))&0x03)<<8);
+
+	{
+
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	//Set Phy to 10/FD, no ANEG,
+	Phy_SetRegW(privateData,PHY_BCR,0x0100,keyCode);
+
+	//enable MAC Tx/Rx, FD
+	Mac_SetRegDW(privateData,MAC_CR,MAC_CR_FDPX_|MAC_CR_TXEN_|MAC_CR_RXEN_,keyCode);
+
+//	Phy_TransmitTestPacket(privateData);
+
+	//set Phy to loopback mode
+	Phy_SetRegW(privateData,PHY_BCR,0x4100,keyCode);
+
+	for(tryCount=0;tryCount<10;tryCount++) {
+		if(Phy_CheckLoopBackPacket(privateData))
+		{
+			result=TRUE;
+			goto DONE;
+		}
+		privateData->dwResetCount++;
+		//disable MAC rx
+		Mac_SetRegDW(privateData,MAC_CR,0UL,keyCode);
+		Phy_Reset(privateData,keyCode);
+
+		//Set Phy to 10/FD, no ANEG, and Loopbackmode
+		Phy_SetRegW(privateData,PHY_BCR,0x4100,keyCode);
+
+		//enable MAC Tx/Rx, FD
+		Mac_SetRegDW(privateData,MAC_CR,MAC_CR_FDPX_|MAC_CR_TXEN_|MAC_CR_RXEN_,keyCode);
+	}
+//	if(failed<2) {
+//		if(tryCount>=10) {
+//			DWORD timeOut=10000;
+//			Lan_ShowRegs(privateData);
+//			SMSC_TRACE("Performing full reset");
+//			privateData->Lan9118->HW_CFG=HW_CFG_SRST_;
+//			while((timeOut>0)&&(privateData->Lan9118->HW_CFG&HW_CFG_SRST_)) {
+//				udelay(1);
+//				timeOut--;
+//			}
+//			failed++;
+//			goto TRY_AGAIN;
+//		}
+//	}
+DONE:
+	//disable MAC
+	Mac_SetRegDW(privateData,MAC_CR,0UL,keyCode);
+	//Cancel Phy loopback mode
+	Phy_SetRegW(privateData,PHY_BCR,0U,keyCode);
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	Lan_SetRegDW(TX_CFG,0UL);
+	Lan_SetRegDW(RX_CFG,0UL);
+
+	return result;
+}
+
+#endif //USE_PHY_WORK_AROUND
+void Phy_SetLink(PPRIVATE_DATA privateData,
+				 DWORD dwLinkRequest)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if(dwLinkRequest&LINK_AUTO_NEGOTIATE) {
+		WORD wTemp;
+		wTemp=Phy_GetRegW(privateData,
+			PHY_ANEG_ADV,keyCode);
+		wTemp&=~PHY_ANEG_ADV_PAUSE_;
+		if(dwLinkRequest&LINK_ASYMMETRIC_PAUSE) {
+			wTemp|=PHY_ANEG_ADV_ASYMP_;
+		}
+		if(dwLinkRequest&LINK_SYMMETRIC_PAUSE) {
+			wTemp|=PHY_ANEG_ADV_SYMP_;
+		}
+		wTemp&=~PHY_ANEG_ADV_SPEED_;
+		if(dwLinkRequest&LINK_SPEED_10HD) {
+			wTemp|=PHY_ANEG_ADV_10H_;
+		}
+		if(dwLinkRequest&LINK_SPEED_10FD) {
+			wTemp|=PHY_ANEG_ADV_10F_;
+		}
+		if(dwLinkRequest&LINK_SPEED_100HD) {
+			wTemp|=PHY_ANEG_ADV_100H_;
+		}
+		if(dwLinkRequest&LINK_SPEED_100FD) {
+			wTemp|=PHY_ANEG_ADV_100F_;
+		}
+		Phy_SetRegW(privateData,PHY_ANEG_ADV,wTemp,keyCode);
+
+		// begin to establish link
+		privateData->dwRemoteFaultCount=0;
+		Phy_SetRegW(privateData,
+			PHY_BCR,
+			PHY_BCR_AUTO_NEG_ENABLE_|
+			PHY_BCR_RESTART_AUTO_NEG_,
+			keyCode);
+	} else {
+		WORD wTemp=0;
+		if(dwLinkRequest&(LINK_SPEED_100FD)) {
+			dwLinkRequest=LINK_SPEED_100FD;
+		} else if(dwLinkRequest&(LINK_SPEED_100HD)) {
+			dwLinkRequest=LINK_SPEED_100HD;
+		} else if(dwLinkRequest&(LINK_SPEED_10FD)) {
+			dwLinkRequest=LINK_SPEED_10FD;
+		} else if(dwLinkRequest&(LINK_SPEED_10HD)) {
+			dwLinkRequest=LINK_SPEED_10HD;
+		}
+		if(dwLinkRequest&(LINK_SPEED_10FD|LINK_SPEED_100FD)) {
+			wTemp|=PHY_BCR_DUPLEX_MODE_;
+		}
+		if(dwLinkRequest&(LINK_SPEED_100HD|LINK_SPEED_100FD)) {
+			wTemp|=PHY_BCR_SPEED_SELECT_;
+		}
+		Phy_SetRegW(privateData,PHY_BCR,wTemp,keyCode);
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+BOOLEAN Phy_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwPhyAddr,
+	DWORD dwLinkRequest)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwTemp=0;
+	WORD wTemp=0;
+	DWORD dwLoopCount=0;
+
+	SMSC_TRACE("-->Phy_Initialize");
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	SMSC_ASSERT(dwLinkRequest<=0x7FUL);
+
+	if(dwPhyAddr!=0xFFFFFFFFUL) {
+		switch(privateData->dwIdRev&0xFFFF0000) {
+		case 0x01170000UL:
+		case 0x01150000UL:
+			if(privateData->dwIdRev&0x0000FFFF) {
+				DWORD dwHwCfg=Lan_GetRegDW(HW_CFG);
+				if(dwHwCfg&HW_CFG_EXT_PHY_DET_) {
+                    //External phy is requested, supported, and detected
+					//Attempt to switch
+					//NOTE: Assuming Rx and Tx are stopped
+					//  because Phy_Initialize is called before
+					//  Rx_Initialize and Tx_Initialize
+					WORD wPhyId1=0;
+					WORD wPhyId2=0;
+
+					//Disable phy clocks to the mac
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);//wait for clocks to acutally stop
+
+					dwHwCfg|=HW_CFG_EXT_PHY_EN_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_EXT_PHY_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);//wait for clocks to actually start
+
+					dwHwCfg|=HW_CFG_SMI_SEL_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					{
+						DWORD dwIntFlags=0;
+						VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+						if(dwPhyAddr<=31) {
+							//only check the phy address specified
+							privateData->dwPhyAddress=dwPhyAddr;
+							wPhyId1=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+							wPhyId2=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+						} else {
+							//auto detect phy
+							DWORD address=0;
+							for(address=0;address<=31;address++) {
+								privateData->dwPhyAddress=address;
+								wPhyId1=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+								wPhyId2=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+								if((wPhyId1!=0xFFFFU)||(wPhyId2!=0xFFFFU)) {
+									SMSC_TRACE("Detected Phy at address = 0x%02lX = %ld",
+										address,address);
+									break;
+								}
+							}
+							if(address>=32) {
+								SMSC_WARNING("Failed to auto detect external phy");
+							}
+						}
+						Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+					}
+					if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+						SMSC_WARNING("External Phy is not accessable");
+						SMSC_WARNING("  using internal phy instead");
+						//revert back to interal phy settings.
+
+						//Disable phy clocks to the mac
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);//wait for clocks to actually stop
+
+						dwHwCfg&=(~HW_CFG_EXT_PHY_EN_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_INT_PHY_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);//wait for clocks to actually start
+
+						dwHwCfg&=(~HW_CFG_SMI_SEL_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						goto USE_INTERNAL_PHY;
+					} else {
+						SMSC_TRACE("Successfully switched to external phy");
+#ifdef USE_LED1_WORK_AROUND
+						privateData->NotUsingExtPhy=0;
+#endif
+					}
+				} else {
+					SMSC_WARNING("No External Phy Detected");
+					SMSC_WARNING("  using internal phy instead");
+					goto USE_INTERNAL_PHY;
+				}
+			} else {
+				SMSC_WARNING("External Phy is not supported");
+				SMSC_WARNING("  using internal phy instead");
+				goto USE_INTERNAL_PHY;
+			};break;
+		default:
+			SMSC_WARNING("External Phy is not supported");
+			SMSC_WARNING("  using internal phy instead");
+			goto USE_INTERNAL_PHY;
+		}
+	} else {
+USE_INTERNAL_PHY:
+		privateData->dwPhyAddress=1;
+#ifdef USE_LED1_WORK_AROUND
+		privateData->NotUsingExtPhy=1;
+#endif
+	}
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		dwTemp=Phy_GetRegW(privateData,PHY_ID_2,keyCode);
+		privateData->bPhyRev=((BYTE)(dwTemp&(0x0FUL)));
+		privateData->bPhyModel=((BYTE)((dwTemp>>4)&(0x3FUL)));
+		privateData->dwPhyId=((dwTemp&(0xFC00UL))<<8);
+		dwTemp=Phy_GetRegW(privateData,PHY_ID_1,keyCode);
+		privateData->dwPhyId|=((dwTemp&(0x0000FFFFUL))<<2);
+
+		SMSC_TRACE("dwPhyId==0x%08lX,bPhyModel==0x%02X,bPhyRev==0x%02X",
+			privateData->dwPhyId,
+			privateData->bPhyModel,
+			privateData->bPhyRev);
+
+		privateData->dwLinkSpeed=LINK_OFF;
+		privateData->dwLinkSettings=LINK_OFF;
+		//reset the PHY
+		Phy_SetRegW(privateData,PHY_BCR,PHY_BCR_RESET_,keyCode);
+	    dwLoopCount=100000;
+		do {
+
+			udelay(10);
+			wTemp=Phy_GetRegW(privateData,PHY_BCR,keyCode);
+			dwLoopCount--;
+		} while((dwLoopCount>0) && (wTemp&PHY_BCR_RESET_));
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("PHY reset failed to complete.");
+		goto DONE;
+	}
+
+#ifdef USE_PHY_WORK_AROUND
+	if(!Phy_LoopBackTest(privateData)) {
+		SMSC_WARNING("Failed Loop back test");
+		goto DONE;
+	} else {
+		SMSC_TRACE("Passed Loop Back Test");
+	}
+#endif
+	Phy_SetLink(privateData,dwLinkRequest);
+
+	init_timer(&(privateData->LinkPollingTimer));
+	privateData->LinkPollingTimer.function=Phy_CheckLink;
+	privateData->LinkPollingTimer.data=(unsigned long)privateData;
+	privateData->LinkPollingTimer.expires=jiffies+HZ;
+	add_timer(&(privateData->LinkPollingTimer));
+
+	result=TRUE;
+DONE:
+	SMSC_TRACE("<--Phy_Initialize, result=%s",result?"TRUE":"FALSE");
+	return result;
+}
+
+WORD Phy_GetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,
+	VL_KEY keyCode)
+{
+	DWORD dwAddr=0;
+	int i=0;
+	WORD result=0xFFFFU;
+
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+
+	// confirm MII not busy
+	if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_GetRegW???");
+		result=0;
+		goto DONE;
+	}
+
+	// set the address, index & direction (read from PHY)
+	dwAddr = ((privateData->dwPhyAddress&0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6);
+	Mac_SetRegDW(privateData, MII_ACC, dwAddr,keyCode);
+
+	// wait for read to complete w/ timeout
+	for(i=0;i<100;i++) {
+		// see if MII is finished yet
+		if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			// get the read data from the MAC & return i
+			result=((WORD)Mac_GetRegDW(privateData, MII_DATA,keyCode));
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+
+DONE:
+	return result;
+}
+
+void Phy_SetRegW(
+	PPRIVATE_DATA privateData,
+	DWORD dwRegIndex,WORD wVal,
+	VL_KEY keyCode)
+{
+	DWORD dwAddr=0;
+	int i=0;
+
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+
+	if(dwRegIndex==0) {
+		if((wVal&0x1200)==0x1200) {
+			privateData->wLastADVatRestart=privateData->wLastADV;
+		}
+	}
+	if(dwRegIndex==4) {
+		privateData->wLastADV=wVal;
+	}
+
+	// confirm MII not busy
+	if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_SetRegW???");
+		goto DONE;
+	}
+
+	// put the data to write in the MAC
+	Mac_SetRegDW(privateData, MII_DATA, (DWORD)wVal,keyCode);
+
+	// set the address, index & direction (write to PHY)
+	dwAddr = ((privateData->dwPhyAddress&0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6) | MII_ACC_MII_WRITE_;
+	Mac_SetRegDW(privateData, MII_ACC, dwAddr,keyCode);
+
+	// wait for write to complete w/ timeout
+	for(i=0;i<100;i++) {
+		// see if MII is finished yet
+		if ((Mac_GetRegDW(privateData, MII_ACC,keyCode) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+DONE:
+	return;
+}
+
+void Phy_UpdateLinkMode(PPRIVATE_DATA privateData)
+{
+	DWORD dwOldLinkSpeed=privateData->dwLinkSpeed;
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+
+	Phy_GetLinkMode(privateData,keyCode);
+
+	if(dwOldLinkSpeed!=(privateData->dwLinkSpeed)) {
+		if(privateData->dwLinkSpeed!=LINK_OFF) {
+			DWORD dwRegVal=0;
+			switch(privateData->dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+				SMSC_TRACE("Link is now UP at 10Mbps HD");
+				break;
+			case LINK_SPEED_10FD:
+				SMSC_TRACE("Link is now UP at 10Mbps FD");
+				break;
+			case LINK_SPEED_100HD:
+				SMSC_TRACE("Link is now UP at 100Mbps HD");
+				break;
+			case LINK_SPEED_100FD:
+				SMSC_TRACE("Link is now UP at 100Mbps FD");
+				break;
+			default:
+				SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					privateData->dwLinkSpeed);
+				break;
+			}
+
+			dwRegVal=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			dwRegVal&=~(MAC_CR_FDPX_|MAC_CR_RCVOWN_);
+			switch(privateData->dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+			case LINK_SPEED_100HD:
+				dwRegVal|=MAC_CR_RCVOWN_;
+				break;
+			case LINK_SPEED_10FD:
+			case LINK_SPEED_100FD:
+				dwRegVal|=MAC_CR_FDPX_;
+				break;
+			default:break;//make lint happy
+			}
+
+			Mac_SetRegDW(privateData,
+				MAC_CR,dwRegVal,keyCode);
+
+			if(privateData->dwLinkSettings&LINK_AUTO_NEGOTIATE) {
+				WORD linkPartner=0;
+				WORD localLink=0;
+				localLink=Phy_GetRegW(privateData,4,keyCode);
+				linkPartner=Phy_GetRegW(privateData,5,keyCode);
+				switch(privateData->dwLinkSpeed) {
+				case LINK_SPEED_10FD:
+				case LINK_SPEED_100FD:
+					if(((localLink&linkPartner)&((WORD)0x0400U)) != ((WORD)0U)) {
+						//Enable PAUSE receive and transmit
+						Mac_SetRegDW(privateData,FLOW,0xFFFF0002UL,keyCode);
+						Lan_SetBitsDW(AFC_CFG,(afc_cfg&0x0000000FUL));
+					} else if(((localLink&((WORD)0x0C00U))==((WORD)0x0C00U)) &&
+							((linkPartner&((WORD)0x0C00U))==((WORD)0x0800U)))
+					{
+						//Enable PAUSE receive, disable PAUSE transmit
+						Mac_SetRegDW(privateData,FLOW,0xFFFF0002UL,keyCode);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					} else {
+						//Disable PAUSE receive and transmit
+						Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					};break;
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:break;//make lint happy
+				}
+				SMSC_TRACE("LAN911x: %s,%s,%s,%s,%s,%s",
+					(localLink&PHY_ANEG_ADV_ASYMP_)?"ASYMP":"     ",
+					(localLink&PHY_ANEG_ADV_SYMP_)?"SYMP ":"     ",
+					(localLink&PHY_ANEG_ADV_100F_)?"100FD":"     ",
+					(localLink&PHY_ANEG_ADV_100H_)?"100HD":"     ",
+					(localLink&PHY_ANEG_ADV_10F_)?"10FD ":"     ",
+					(localLink&PHY_ANEG_ADV_10H_)?"10HD ":"     ");
+
+				SMSC_TRACE("Partner: %s,%s,%s,%s,%s,%s",
+					(linkPartner&PHY_ANEG_LPA_ASYMP_)?"ASYMP":"     ",
+					(linkPartner&PHY_ANEG_LPA_SYMP_)?"SYMP ":"     ",
+					(linkPartner&PHY_ANEG_LPA_100FDX_)?"100FD":"     ",
+					(linkPartner&PHY_ANEG_LPA_100HDX_)?"100HD":"     ",
+					(linkPartner&PHY_ANEG_LPA_10FDX_)?"10FD ":"     ",
+					(linkPartner&PHY_ANEG_LPA_10HDX_)?"10HD ":"     ");
+			} else {
+				switch(privateData->dwLinkSpeed) {
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(privateData,FLOW,0x0UL,keyCode);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					Mac_SetRegDW(privateData,FLOW,0x0UL,keyCode);
+					Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				}
+			}
+			netif_carrier_on(privateData->dev);
+			Tx_WakeQueue(privateData,0x01);
+#ifdef USE_LED1_WORK_AROUND
+			if ((g_GpioSettingOriginal & GPIO_CFG_LED1_EN_) &&
+				privateData->NotUsingExtPhy)
+			{
+				// Restore orginal GPIO configuration
+				g_GpioSetting = g_GpioSettingOriginal;
+				Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+			}
+#endif // USE_LED1_WORK_AROUND
+		} else {
+			SMSC_TRACE("Link is now DOWN");
+			Tx_StopQueue(privateData,0x01);
+			netif_carrier_off(privateData->dev);
+			Mac_SetRegDW(privateData,FLOW,0UL,keyCode);
+			Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+#ifdef USE_LED1_WORK_AROUND
+			// Check global setting that LED1 usage is 10/100 indicator
+//			g_GpioSetting = Lan_GetRegDW(GPIO_CFG);
+			if ((g_GpioSetting & GPIO_CFG_LED1_EN_) &&
+				privateData->NotUsingExtPhy)
+			{
+				//Force 10/100 LED off, after saving orginal GPIO configuration
+				g_GpioSettingOriginal = g_GpioSetting;
+
+				g_GpioSetting &= ~GPIO_CFG_LED1_EN_;
+				g_GpioSetting |=
+					(GPIO_CFG_GPIOBUF0_|GPIO_CFG_GPIODIR0_|GPIO_CFG_GPIOD0_);
+				Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+			}
+#endif // USE_LED1_WORK_AROUND
+		}
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+void Phy_CheckLink(unsigned long ptr)
+{
+	PPRIVATE_DATA privateData=(PPRIVATE_DATA)ptr;
+	if(privateData==NULL) {
+		SMSC_WARNING("Phy_CheckLink(ptr==0)");
+		return;
+	}
+
+	//must call this twice
+	Phy_UpdateLinkMode(privateData);
+	Phy_UpdateLinkMode(privateData);
+
+	if(!(privateData->StopLinkPolling)) {
+		privateData->LinkPollingTimer.expires=jiffies+HZ;
+		add_timer(&(privateData->LinkPollingTimer));
+	}
+}
+
+void Phy_GetLinkMode(
+	PPRIVATE_DATA privateData,
+	VL_KEY keyCode)
+{
+	DWORD result=LINK_OFF;
+	WORD wRegVal=0;
+	WORD wRegBSR=Phy_GetRegW(
+		privateData,
+		PHY_BSR,keyCode);
+	privateData->dwLinkSettings=LINK_OFF;
+	if(wRegBSR&PHY_BSR_LINK_STATUS_) {
+		wRegVal=Phy_GetRegW(
+			privateData,
+			PHY_BCR,keyCode);
+		if(wRegVal&PHY_BCR_AUTO_NEG_ENABLE_) {
+			DWORD linkSettings=LINK_AUTO_NEGOTIATE;
+			WORD wRegADV=privateData->wLastADVatRestart;
+//					Phy_GetRegW(
+//						privateData,
+//						PHY_ANEG_ADV,keyCode);
+			WORD wRegLPA=Phy_GetRegW(
+				privateData,
+				PHY_ANEG_LPA,keyCode);
+			if(wRegADV&PHY_ANEG_ADV_ASYMP_) {
+				linkSettings|=LINK_ASYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_ADV_SYMP_) {
+				linkSettings|=LINK_SYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100FDX_) {
+				linkSettings|=LINK_SPEED_100FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100HDX_) {
+				linkSettings|=LINK_SPEED_100HD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10FDX_) {
+				linkSettings|=LINK_SPEED_10FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10HDX_) {
+				linkSettings|=LINK_SPEED_10HD;
+			}
+			privateData->dwLinkSettings=linkSettings;
+			wRegLPA&=wRegADV;
+			if(wRegLPA&PHY_ANEG_LPA_100FDX_) {
+				result=LINK_SPEED_100FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_100HDX_) {
+				result=LINK_SPEED_100HD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10FDX_) {
+				result=LINK_SPEED_10FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10HDX_) {
+				result=LINK_SPEED_10HD;
+			}
+		} else {
+			if(wRegVal&PHY_BCR_SPEED_SELECT_) {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					privateData->dwLinkSettings=result=LINK_SPEED_100FD;
+				} else {
+					privateData->dwLinkSettings=result=LINK_SPEED_100HD;
+				}
+			} else {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					privateData->dwLinkSettings=result=LINK_SPEED_10FD;
+				} else {
+					privateData->dwLinkSettings=result=LINK_SPEED_10HD;
+				}
+			}
+		}
+	}
+	privateData->dwLinkSpeed=result;
+}
+
+BOOLEAN Mac_Initialize(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	//This function is kept only as a place holder
+
+	return TRUE;
+}
+
+static BOOLEAN MacNotBusy(PPRIVATE_DATA privateData, VL_KEY keyCode)
+{
+	int i=0;
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	// wait for MAC not busy, w/ timeout
+	for(i=0;i<40;i++)
+	{
+		if((Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)==(0UL)) {
+			return TRUE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MAC not BUSY. MAC_CSR_CMD = 0x%08lX",
+		Lan_GetRegDW(MAC_CSR_CMD));
+	return FALSE;
+}
+
+DWORD Mac_GetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,VL_KEY keyCode)
+{
+	DWORD result=0xFFFFFFFFUL;
+	DWORD dwTemp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	// wait until not busy
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	// send the MAC Cmd w/ offset
+	Lan_SetRegDW(MAC_CSR_CMD,
+		((dwRegOffset & 0x000000FFUL) |
+		MAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);//to flush previous write
+	dwTemp=dwTemp;
+
+	// wait for the read to happen, w/ timeout
+	if (!MacNotBusy(privateData,keyCode))
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, waiting for MAC not busy after read");
+		goto DONE;
+	} else {
+		// finally, return the read data
+		result=Lan_GetRegDW(MAC_CSR_DATA);
+	}
+DONE:
+	return result;
+}
+
+void Mac_SetRegDW(PPRIVATE_DATA privateData,DWORD dwRegOffset,DWORD dwVal,VL_KEY keyCode)
+{
+	DWORD dwTemp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),keyCode));
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	// send the data to write
+	Lan_SetRegDW(MAC_CSR_DATA,dwVal);
+
+	// do the actual write
+	Lan_SetRegDW(MAC_CSR_CMD,((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);//force flush of previous write
+	dwTemp=dwTemp;
+
+	// wait for the write to complete, w/ timeout
+	if (!MacNotBusy(privateData,keyCode))
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, waiting for MAC not busy after write");
+	}
+DONE:
+	return;
+}
+
+#define TX_FIFO_LOW_THRESHOLD	(1600)
+
+void Tx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwTxDmaCh,
+	DWORD dwDmaThreshold)
+{
+	DWORD dwRegVal=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+
+	dwRegVal=Lan_GetRegDW(HW_CFG);
+	dwRegVal&=(HW_CFG_TX_FIF_SZ_|0x00000FFFUL);
+	dwRegVal|=HW_CFG_SF_;
+	Lan_SetRegDW(HW_CFG,dwRegVal);
+
+	Lan_SetTDFL(privateData,0xFF);
+	Lan_EnableInterrupt(privateData,INT_EN_TDFA_EN_);
+
+	privateData->dwTxDmaThreshold=dwDmaThreshold;
+	privateData->dwTxDmaCh=dwTxDmaCh;
+	if(dwTxDmaCh>=TRANSFER_PIO) {
+		SMSC_TRACE("Tx will use PIO");
+	} else {
+		SMSC_TRACE("Tx will use DMA channel %ld",dwTxDmaCh);
+		SMSC_ASSERT(Platform_IsValidDmaChannel(dwTxDmaCh));
+		if(!Platform_DmaInitialize(
+			&(privateData->PlatformData),
+			dwTxDmaCh))
+		{
+			SMSC_WARNING("Failed Platform_DmaInitialize, dwTxDmaCh=%lu",dwTxDmaCh);
+		}
+		privateData->TxDmaXfer.dwLanReg=privateData->dwLanBase+TX_DATA_FIFO;
+		privateData->TxDmaXfer.pdwBuf=NULL;//this will be reset per dma request
+		privateData->TxDmaXfer.dwDmaCh=privateData->dwTxDmaCh;
+		privateData->TxDmaXfer.dwDwCnt=0;//this will be reset per dma request
+		privateData->TxDmaXfer.fMemWr=FALSE;
+	}
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		dwMacCr|=(MAC_CR_TXEN_|MAC_CR_HBDIS_);
+		Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+		Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+
+	privateData->TxSkb=NULL;
+	spin_lock_init(&(privateData->TxSkbLock));
+	privateData->dwTxQueueDisableMask=0;
+	spin_lock_init(&(privateData->TxQueueLock));
+	spin_lock_init(&(privateData->TxCounterLock));
+	privateData->TxInitialized=TRUE;
+}
+
+BOOLEAN Tx_HandleInterrupt(
+	PPRIVATE_DATA privateData,DWORD dwIntSts)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(dwIntSts&INT_STS_TDFA_)
+	{
+		Lan_SetTDFL(privateData,0xFF);
+		Lan_SetRegDW(INT_STS,INT_STS_TDFA_);
+		Tx_WakeQueue(privateData,0x02UL);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+void Tx_StopQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource)
+{
+	DWORD intFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dev!=NULL);
+	SMSC_ASSERT(privateData->TxInitialized);
+	spin_lock_irqsave(&(privateData->TxQueueLock),intFlags);
+	if(privateData->dwTxQueueDisableMask==0) {
+		netif_stop_queue(privateData->dev);
+	}
+	privateData->dwTxQueueDisableMask|=dwSource;
+	spin_unlock_irqrestore(&(privateData->TxQueueLock),intFlags);
+}
+
+void Tx_WakeQueue(
+	PPRIVATE_DATA privateData,DWORD dwSource)
+{
+	DWORD intFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dev!=NULL);
+	SMSC_ASSERT(privateData->TxInitialized);
+	spin_lock_irqsave(&(privateData->TxQueueLock),intFlags);
+	privateData->dwTxQueueDisableMask&=(~dwSource);
+	if(privateData->dwTxQueueDisableMask==0) {
+		netif_wake_queue(privateData->dev);
+	}
+	spin_unlock_irqrestore(&(privateData->TxQueueLock),intFlags);
+}
+
+static DWORD Tx_GetTxStatusCount(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		result>>=16;
+		if(result>0x80) {
+			SMSC_WARNING("TX_FIFO_INF_TSFREE_>0x80");
+			result=0x80;
+		}
+		result=0x80-result;
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		result>>=16;
+	}
+	return result;
+}
+
+void Tx_SendSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb)
+{
+	DWORD dwFreeSpace=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	if(privateData->dwTxDmaCh>=TRANSFER_PIO)
+	{
+		//Use PIO only
+		DWORD dwTxCmdA=0;
+		DWORD dwTxCmdB=0;
+		dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+		dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+		if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+			SMSC_WARNING("Tx Data Fifo Low, space available = %ld",dwFreeSpace);
+		}
+		dwTxCmdA=
+			((((DWORD)(skb->data))&0x03UL)<<16) | //DWORD alignment adjustment
+			TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+			((DWORD)(skb->len));
+		dwTxCmdB=
+			(((DWORD)(skb->len))<<16) |
+			((DWORD)(skb->len));
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+		Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+		Platform_WriteFifo(
+			privateData->dwLanBase,
+			(DWORD *)(((DWORD)(skb->data))&0xFFFFFFFCUL),
+			(((DWORD)(skb->len))+3+
+			(((DWORD)(skb->data))&0x03UL))>>2);
+		dwFreeSpace-=(skb->len+32);
+		dev_kfree_skb(skb);
+	}
+	else
+	{
+		//Use DMA and PIO
+		PPLATFORM_DATA platformData=&(privateData->PlatformData);
+		SMSC_ASSERT(TX_FIFO_LOW_THRESHOLD>(skb->len+32));
+
+		BUG_ON((privateData->dwTxQueueDisableMask & 0x04UL) != 0);
+		BUG_ON(privateData->TxSkb != NULL);
+
+		if(skb->len>=privateData->dwTxDmaThreshold)
+		{
+			//use DMA
+			DWORD dwTxCmdA;
+			DWORD dwTxCmdB;
+
+			//prepare for 16 byte alignment
+			dwTxCmdA=
+#if (PLATFORM_CACHE_LINE_BYTES == 16)
+				(0x01UL<<24)|//16 byte end alignment
+#endif
+#if (PLATFORM_CACHE_LINE_BYTES == 32)
+				(0x02UL<<24)|//32 byte end alignment
+#endif
+				((((DWORD)(skb->data))&(PLATFORM_CACHE_LINE_BYTES-1))<<16) |//16 Byte start alignment
+				TX_CMD_A_INT_FIRST_SEG_ |
+				TX_CMD_A_INT_LAST_SEG_ |
+				((DWORD)(skb->len));//buffer length
+			dwTxCmdB=
+				(((DWORD)(skb->len))<<16)|
+				((DWORD)(skb->len)&0x7FFUL);
+			privateData->TxDmaXfer.pdwBuf=
+				(DWORD *)(((DWORD)(skb->data))&
+					(~(PLATFORM_CACHE_LINE_BYTES-1)));
+			privateData->TxDmaXfer.dwDwCnt=
+				((((DWORD)(skb->len))+
+				(PLATFORM_CACHE_LINE_BYTES-1)+
+				(((DWORD)(skb->data))&
+					(PLATFORM_CACHE_LINE_BYTES-1)))&
+					(~(PLATFORM_CACHE_LINE_BYTES-1)))>>2;
+			Platform_CachePurge(
+				platformData,
+				privateData->TxDmaXfer.pdwBuf,
+				(privateData->TxDmaXfer.dwDwCnt)<<2);
+
+			spin_lock(&(privateData->TxSkbLock));
+			{
+				dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+				dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+				if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+					SMSC_WARNING("Tx DATA FIFO LOW, space available = %ld",dwFreeSpace);
+				}
+
+				Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+				Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+				if(!Platform_DmaStartXfer(platformData,&(privateData->TxDmaXfer), Tx_DmaCompletionCallback, privateData))
+				{
+					SMSC_WARNING("Failed Platform_DmaStartXfer");
+				}
+
+				dwFreeSpace-=(skb->len+32);
+				privateData->TxSkb=skb;
+			}
+			spin_unlock(&(privateData->TxSkbLock));
+
+			Tx_StopQueue(privateData,0x04UL);
+		}
+		else
+		{
+			//use PIO
+			DWORD dwTxCmdA=0;
+			DWORD dwTxCmdB=0;
+			dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+			dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+			if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+				SMSC_WARNING("Tx DATA FIFO LOW, space available = %ld",dwFreeSpace);
+			}
+			dwTxCmdA=
+				((((DWORD)(skb->data))&0x03UL)<<16) | //DWORD alignment adjustment
+				TX_CMD_A_INT_FIRST_SEG_ | TX_CMD_A_INT_LAST_SEG_ |
+				((DWORD)(skb->len));
+			dwTxCmdB=
+				(((DWORD)(skb->len))<<16) |
+				((DWORD)(skb->len));
+			Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+			Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+			Platform_WriteFifo(
+				privateData->dwLanBase,
+				(DWORD *)(((DWORD)(skb->data))&0xFFFFFFFCUL),
+				(((DWORD)(skb->len))+3+
+				(((DWORD)(skb->data))&0x03UL))>>2);
+
+			dwFreeSpace-=(skb->len+32);
+			dev_kfree_skb(skb);
+		}
+	}
+	if(Tx_GetTxStatusCount(privateData)>=30)
+	{
+		Tx_UpdateTxCounters(privateData);
+	}
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		Tx_StopQueue(privateData,0x02UL);
+		Lan_SetTDFL(privateData,0x32);
+	}
+}
+
+static void Tx_DmaCompletionCallback(void* param)
+{
+	PPRIVATE_DATA privateData = param;
+
+	BUG_ON(privateData->TxSkb == NULL);
+	dev_kfree_skb(privateData->TxSkb);
+	privateData->TxSkb = NULL;
+	Tx_WakeQueue(privateData,0x04UL);
+}
+
+static DWORD Tx_CompleteTx(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	SMSC_ASSERT(privateData->TxInitialized==TRUE);
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	if(OLD_REGISTERS(privateData)) {
+		result&=TX_FIFO_INF_TSFREE_;
+		if(result!=0x00800000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	} else {
+		result&=TX_FIFO_INF_TSUSED_;
+		if(result!=0x00000000UL) {
+			result=Lan_GetRegDW(TX_STATUS_FIFO);
+		} else {
+			result=0;
+		}
+	}
+	return result;
+}
+
+void Tx_UpdateTxCounters(
+	PPRIVATE_DATA privateData)
+{
+
+	DWORD dwTxStatus=0;
+	SMSC_ASSERT(privateData!=NULL);
+	spin_lock(&(privateData->TxCounterLock));
+	while((dwTxStatus=Tx_CompleteTx(privateData))!=0)
+	{
+		if(dwTxStatus&0x80000000UL) {
+			SMSC_WARNING("Packet tag reserved bit is high");
+			privateData->stats.tx_errors++;
+		} else if(dwTxStatus&0x00007080UL) {
+			SMSC_WARNING("Tx Status reserved bits are high");
+			privateData->stats.tx_errors++;
+		} else {
+			if(dwTxStatus&0x00008000UL) {
+				privateData->stats.tx_errors++;
+			} else {
+				privateData->stats.tx_packets++;
+				privateData->stats.tx_bytes+=(dwTxStatus>>16);
+			}
+			if(dwTxStatus&0x00000100UL) {
+				privateData->stats.collisions+=16;
+				privateData->stats.tx_aborted_errors+=1;
+			} else {
+				privateData->stats.collisions+=
+					((dwTxStatus>>3)&0xFUL);
+			}
+			if(dwTxStatus&0x00000800UL) {
+				privateData->stats.tx_carrier_errors+=1;
+			}
+			if(dwTxStatus&0x00000200UL) {
+				privateData->stats.collisions++;
+				privateData->stats.tx_aborted_errors++;
+			}
+		}
+	}
+	spin_unlock(&(privateData->TxCounterLock));
+}
+
+void Tx_CompleteDma(
+	PPRIVATE_DATA privateData)
+{
+	DWORD dwTimeOut=100000;
+
+	SMSC_ASSERT(privateData!=NULL);
+
+	while ((privateData->TxSkb) && (dwTimeOut)) {
+		udelay(10);
+		dwTimeOut--;
+	}
+	if (dwTimeOut == 0)
+		SMSC_WARNING("Timed out waiting for Tx DMA complete");
+}
+
+void Rx_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwRxDmaCh,
+	DWORD dwDmaThreshold)
+{
+	SMSC_ASSERT(privateData!=NULL);
+
+	privateData->dwRxDmaCh=dwRxDmaCh;
+	if(dwRxDmaCh>=TRANSFER_PIO) {
+		SMSC_TRACE("Rx will use PIO");
+		Platform_GetFlowControlParameters(
+			&(privateData->PlatformData),
+			&(privateData->RxFlowParameters),
+			FALSE);
+	} else {
+		SMSC_TRACE("Rx will use DMA Channel %ld",dwRxDmaCh);
+		SMSC_ASSERT(Platform_IsValidDmaChannel(dwRxDmaCh));
+		if(!Platform_DmaInitialize(
+			&(privateData->PlatformData),
+			dwRxDmaCh))
+		{
+			SMSC_WARNING("Failed Platform_DmaInitialize, dwRxDmaCh=%lu",dwRxDmaCh);
+		}
+		Platform_GetFlowControlParameters(
+			&(privateData->PlatformData),
+			&(privateData->RxFlowParameters),
+			TRUE);
+	}
+	if(max_throughput!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.MaxThroughput=max_throughput;
+	}
+	if(max_packet_count!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.MaxPacketCount=max_packet_count;
+	}
+	if(packet_cost!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.PacketCost=packet_cost;
+	}
+	if(burst_period!=0xFFFFFFFFUL) {
+		privateData->RxFlowParameters.BurstPeriod=burst_period;
+	}
+	if(privateData->RxFlowParameters.BurstPeriod==0) {
+		SMSC_WARNING("burst_period of 0 is not allowed");
+		SMSC_WARNING(" resetting burst_period to 100");
+		privateData->RxFlowParameters.BurstPeriod=100;
+	}
+	if(max_work_load!=0xFFFFFFFFUL) {
+		privateData->RxFlowMaxWorkLoad=max_work_load;
+	} else {
+		privateData->RxFlowMaxWorkLoad=
+			privateData->RxFlowParameters.MaxThroughput+
+			(privateData->RxFlowParameters.MaxPacketCount*
+			privateData->RxFlowParameters.PacketCost);
+	}
+	privateData->RxFlowBurstMaxWorkLoad=
+			(privateData->RxFlowMaxWorkLoad*
+			privateData->RxFlowParameters.BurstPeriod)/1000;
+	if(int_deas!=0xFFFFFFFFUL) {
+		Lan_SetIntDeas(privateData,int_deas);
+	} else {
+		Lan_SetIntDeas(privateData,privateData->RxFlowParameters.IntDeas);
+	}
+
+	//initially the receiver is off
+	//  a following link up detection will turn the receiver on
+	privateData->dwRxOffCount=1;
+	Lan_SetRegDW(RX_CFG,0x00000200UL);
+	Rx_ReceiverOn(privateData, 0);
+
+	privateData->dwRxDmaThreshold=dwDmaThreshold;
+	Lan_SetRDFL(privateData,0x01);
+	Lan_SetRSFL(privateData,0x00);
+	privateData->RxInterrupts=INT_EN_RSFL_EN_;
+	privateData->RxInterrupts|=INT_EN_RXE_EN_;
+	if(IS_REV_A(privateData)) {
+		privateData->RxInterrupts|=INT_EN_RDFL_EN_;
+	} else {
+		privateData->RxInterrupts|=INT_EN_RDFO_EN_;
+	}
+	privateData->RxInterrupts|=INT_EN_RXDFH_INT_EN_;
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+static void Rx_HandleOverrun(PPRIVATE_DATA privateData)
+{
+	if(IS_REV_A(privateData)) {
+		if(privateData->RxOverrun==FALSE) {
+			Rx_ReceiverOff(privateData);
+			privateData->RxUnloadProgress=
+					(((((privateData->LastRxStatus1)&0x3FFF0000UL)>>16)+2+3)&0xFFFFFFFCUL);
+			if(privateData->dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+				privateData->RxUnloadProgress+=
+					(((((privateData->LastRxStatus2)&0x3FFF0000UL)>>16)+2+3)&0xFFFFFFFCUL);
+			}
+			privateData->RxUnloadPacketProgress=0;
+			privateData->RxOverrun=TRUE;
+			privateData->RxOverrunCount++;
+		}
+	} else {
+		privateData->RxOverrunCount++;
+	}
+}
+
+static void Rx_HandOffSkb(
+	PPRIVATE_DATA privateData,
+	struct sk_buff *skb)
+{
+	int result=0;
+
+
+	skb->dev=privateData->dev;
+	skb->protocol= eth_type_trans(skb,privateData->dev);
+	skb->ip_summed = CHECKSUM_NONE;
+
+	result=netif_rx(skb);
+
+	switch(result)
+	{
+	case NET_RX_SUCCESS:
+		break;
+	case NET_RX_CN_LOW:
+	case NET_RX_CN_MOD:
+	case NET_RX_CN_HIGH:
+	case NET_RX_DROP:
+		privateData->RxCongested=TRUE;
+		privateData->RxCongestedCount++;
+		break;
+	default:
+		privateData->RxCongested=TRUE;
+		privateData->RxCongestedCount++;
+		SMSC_WARNING("Unknown return value from netif_rx, result=%d",result);
+		break;
+	}
+}
+
+void Rx_CompleteMulticastUpdate (PPRIVATE_DATA privateData)
+{
+	DWORD local_MACCR;
+	VL_KEY keyCode=0;
+	DWORD dwIntFlags=0;
+
+	keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if (privateData->MulticastUpdatePending) {
+		Mac_SetRegDW(privateData,HASHH,privateData->HashHi,keyCode);
+		Mac_SetRegDW(privateData,HASHL,privateData->HashLo,keyCode);
+		local_MACCR = Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		local_MACCR |= privateData->set_bits_mask;
+		local_MACCR &= ~(privateData->clear_bits_mask);
+		Mac_SetRegDW(privateData,MAC_CR,local_MACCR,keyCode);
+		Rx_ReceiverOn(privateData, keyCode);
+		privateData->MulticastUpdatePending = FALSE;
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+void Rx_BeginMulticastUpdate (PPRIVATE_DATA privateData)
+{
+	DWORD startTime, currentTime;
+	DWORD timeout;
+	DWORD flags;
+
+	if (privateData->dwLinkSpeed == LINK_SPEED_100HD ||
+		privateData->dwLinkSpeed == LINK_SPEED_100FD) {
+
+		// this assure our driver is not interrupted by other drivers
+		// turn off local cpu interrupts
+		local_irq_save (flags);
+		Rx_ReceiverOff (privateData);
+		if(!IS_REV_A(privateData)) {
+			// since this is concord or later there is no
+			// overrun processing that might turn off the receiver.
+			// there for we can rely on RxStop Int.
+
+			/* poll for MAC RX to stop */
+			timeout = 200UL;
+			while (!(Lan_GetRegDW(INT_STS)&(INT_STS_RXSTOP_INT_))) {
+
+				// wait 1 uSec
+				startTime=Lan_GetRegDW(FREE_RUN);
+				while (1) {
+					currentTime=Lan_GetRegDW(FREE_RUN);
+					if (currentTime-startTime >= 25UL)
+						break;
+				}
+				if (timeout == 0UL) {
+					SMSC_TRACE("timeout waiting for RXSTOP INT");
+					break;
+				}
+				timeout--;
+			}
+			Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);
+		}
+		else {
+			// for rev A we cant rely on Rx stop because
+			// the receiver may have already been stopped due to
+			// overflow processing
+			// wait 200 uS
+			udelay (200);
+		}
+		Rx_CompleteMulticastUpdate (privateData);
+		local_irq_restore (flags);
+	}
+	else if (privateData->dwLinkSpeed == LINK_SPEED_10HD ||
+		privateData->dwLinkSpeed == LINK_SPEED_10FD) {
+		if(!IS_REV_A(privateData)) {
+			// prepare RxStop interrupt
+			Lan_EnableInterrupt(privateData,INT_EN_RXSTOP_INT_EN_);
+			if (privateData->dwLinkSpeed == LINK_SPEED_10HD) {
+				// 10Mbps half duplex is 99.6% reliable,
+				// in the event that is not reliable
+				// prepare GPT callback
+				// prepare GPT callback 2mS
+				Gpt_ScheduleCallBack(privateData,GptCB_RxCompleteMulticast, 20UL);
+			}
+		}
+		else {
+			// we can't rely on Rx stop because the
+			// receiver may have already been stopped
+			// due to overflow processing
+			// the simplest solution is to use the
+			// GPT callback
+			// prepare GPT callback 2mS
+			Gpt_ScheduleCallBack(privateData,GptCB_RxCompleteMulticast, 20UL);
+		}
+		Rx_ReceiverOff (privateData);
+	}
+	else {
+		// assume link is down so do update immediately
+		Rx_ReceiverOff (privateData);
+		Rx_CompleteMulticastUpdate (privateData);
+	}
+}
+
+static DWORD Rx_PopRxStatus(
+	PPRIVATE_DATA privateData)
+{
+	DWORD result=Lan_GetRegDW(RX_FIFO_INF);
+	if((privateData->RxCongested==FALSE)||
+		((privateData->RxCongested==TRUE)&&((result&0x00FF0000UL)==0UL)))
+	{
+		if(result&0x00FF0000UL) {
+			DWORD dwIntSts=Lan_GetRegDW(INT_STS);
+			if(IS_REV_A(privateData)) {
+				if(dwIntSts&INT_STS_RDFL_) {
+					Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+					Rx_HandleOverrun(privateData);
+				}
+			} else {
+				if(dwIntSts&INT_STS_RDFO_) {
+
+					Lan_SetRegDW(INT_STS,INT_STS_RDFO_);
+					Rx_HandleOverrun(privateData);
+				}
+			}
+			if((privateData->RxFlowControlActive==FALSE)||
+				((privateData->RxFlowControlActive==TRUE)&&
+				 (privateData->RxFlowBurstActive==TRUE)))
+			{
+				//Rx status is available, read it
+				result=Lan_GetRegDW(RX_STATUS_FIFO);
+				privateData->RxStatusDWReadCount++;
+				privateData->LastRxStatus3=
+					privateData->LastRxStatus2;
+				privateData->LastRxStatus2=
+					privateData->LastRxStatus1;
+				privateData->LastRxStatus1=result;
+
+				if(privateData->RxOverrun) {
+					DWORD dwPacketLength=((result&0x3FFF0000UL)>>16);
+					DWORD dwByteCount=((dwPacketLength+2+3)&0xFFFFFFFCUL);
+					if((privateData->RxUnloadProgress+dwByteCount)>=
+						((privateData->RxMaxDataFifoSize)-16))
+					{
+						//This is the packet that crosses the corruption point
+						//  so just ignore it and complete the overrun processing.
+						result=0;
+						goto FINISH_OVERRUN_PROCESSING;
+					}
+					privateData->RxUnloadProgress+=dwByteCount;
+					privateData->RxUnloadPacketProgress++;
+				}
+
+				privateData->RxFlowCurrentThroughput+=
+						((((result&0x3FFF0000UL)>>16)-4UL));
+				privateData->RxFlowCurrentPacketCount++;
+				privateData->RxFlowCurrentWorkLoad+=
+						((((result&0x3FFF0000UL)>>16)-4UL)+privateData->RxFlowParameters.PacketCost);
+				if(privateData->RxFlowControlActive) {
+					privateData->RxFlowBurstWorkLoad+=
+						((((result&0x3FFF0000UL)>>16)-4UL)+privateData->RxFlowParameters.PacketCost);
+					if(privateData->RxFlowBurstWorkLoad>=
+						privateData->RxFlowBurstMaxWorkLoad)
+					{
+						privateData->RxFlowBurstActive=FALSE;
+						Lan_DisableInterrupt(privateData,privateData->RxInterrupts);
+					}
+				}
+			} else {
+				result=0;
+			}
+		}
+		else
+		{
+			if(privateData->RxOverrun) {
+				DWORD timeOut;
+				DWORD temp;
+FINISH_OVERRUN_PROCESSING:
+				temp=0;
+				{
+					timeOut=2000;
+					while((timeOut>0)&&(!(Lan_GetRegDW(INT_STS)&(INT_STS_RXSTOP_INT_)))) {
+						udelay(1);
+						timeOut--;
+					}
+					if(timeOut==0) {
+//						privateData->RxStopTimeOutCount++;
+//						PULSE_GPIO(GP_TX,1);
+						SMSC_WARNING("Timed out waiting for Rx to Stop\n");
+					}
+					Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);
+				}
+
+				if(privateData->dwRxDmaCh<TRANSFER_REQUEST_DMA) {
+					//make sure DMA has stopped before doing RX Dump
+					DWORD dwTimeOut=100000;
+
+					while ((privateData->RxSkb) && (dwTimeOut)) {
+						udelay(10);
+						timeOut--;
+					}
+					if (dwTimeOut == 0)
+						SMSC_WARNING("Timed out waiting for Rx DMA complete");
+				}
+
+				temp=Lan_GetRegDW(RX_CFG);
+				Lan_SetRegDW(RX_CFG,(temp&0x3FFFFFFFUL));
+				timeOut=10000000;
+				Lan_SetBitsDW(RX_CFG,RX_CFG_RX_DUMP_);
+				while((timeOut>0)&&(Lan_GetRegDW(RX_CFG)&(RX_CFG_RX_DUMP_))) {
+					udelay(1);
+					timeOut--;
+				}
+				if(timeOut==0) {
+					SMSC_WARNING("Timed out waiting for Rx Dump to complete\n");
+				}
+				Lan_SetRegDW(RX_CFG,temp);
+
+				privateData->RxDumpCount++;
+				Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+				Rx_ReceiverOn(privateData, 0);
+				privateData->RxOverrun=FALSE;
+			}
+			result=0;
+			privateData->LastReasonForReleasingCPU=1;//Status FIFO Empty
+		}
+	} else {
+		//disable and reenable the INT_EN
+		//  This will allow the deassertion interval to begin
+		DWORD temp=Lan_GetRegDW(INT_EN);
+		Lan_SetRegDW(INT_EN,0);
+		Lan_SetRegDW(INT_EN,temp);
+		result=0;
+		privateData->LastReasonForReleasingCPU=2;//High Congestion
+	}
+	return result;
+}
+
+void Rx_CountErrors(PPRIVATE_DATA privateData,DWORD dwRxStatus)
+{
+	BOOLEAN crcError=FALSE;
+	if(dwRxStatus&0x00008000UL) {
+		privateData->stats.rx_errors++;
+		if(dwRxStatus&0x00000002UL) {
+			privateData->stats.rx_crc_errors++;
+			crcError=TRUE;
+		}
+	}
+	if(!crcError) {
+		if((dwRxStatus&0x00001020UL)==0x00001020UL) {
+			//Frame type indicates length, and length error is set
+			privateData->stats.rx_length_errors++;
+		}
+		if(dwRxStatus&RX_STS_MCAST_) {
+			privateData->stats.multicast++;
+		}
+	}
+}
+
+void Rx_FastForward(PPRIVATE_DATA privateData,DWORD dwDwordCount)
+{
+	privateData->RxFastForwardCount++;
+	if((dwDwordCount>=4)
+		&& (
+			(((privateData->dwIdRev&0x0000FFFFUL)==0x00000000UL)
+				&& (privateData->dwFpgaRev>=0x36))
+			||
+			((privateData->dwIdRev&0x0000FFFFUL)!=0UL)
+			)
+		)
+	{
+		DWORD dwTimeOut=500;
+		Lan_SetRegDW(RX_DP_CTRL,(dwDwordCount|RX_DP_CTRL_FFWD_BUSY_));
+		while((dwTimeOut)&&(Lan_GetRegDW(RX_DP_CTRL)&
+				RX_DP_CTRL_FFWD_BUSY_))
+		{
+			udelay(1);
+			dwTimeOut--;
+		}
+		if(dwTimeOut==0) {
+
+			SMSC_WARNING("timed out waiting for RX FFWD to finish, RX_DP_CTRL=0x%08lX",
+				Lan_GetRegDW(RX_DP_CTRL));
+		}
+	} else {
+		while(dwDwordCount) {
+			DWORD dwTemp=Lan_GetRegDW(RX_DATA_FIFO);
+			dwTemp=dwTemp;
+			dwDwordCount--;
+		}
+	}
+}
+
+//Rx_ReceiverOff, and Rx_ReceiverOn use a reference counter
+//  because they are used in both the Rx code and the link management count
+void Rx_ReceiverOff(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	if(privateData->dwRxOffCount==0) {
+		DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+		if(!(dwMacCr&MAC_CR_RXEN_)) {
+			SMSC_WARNING("Rx_ReceiverOff: Receiver is already Off");
+		}
+		dwMacCr&=(~MAC_CR_RXEN_);
+		Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+		//CLEAR_GPIO(GP_RX);
+	}
+	privateData->dwRxOffCount++;
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+}
+
+//Rx_ReceiverOff, and Rx_ReceiverOn use a reference counter
+//  because they are used in both the Rx code and the link management count
+void Rx_ReceiverOn(PPRIVATE_DATA privateData, VL_KEY callerKeyCode)
+{
+	DWORD dwIntFlags=0;
+	VL_KEY keyCode=0;
+
+	if (callerKeyCode == 0) {
+		keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+	}
+	else {
+		SMSC_ASSERT(Vl_CheckLock(&(privateData->MacPhyLock),callerKeyCode));
+		keyCode = callerKeyCode;
+	}
+	if(privateData->dwRxOffCount>0) {
+		privateData->dwRxOffCount--;
+		if(privateData->dwRxOffCount==0) {
+			DWORD dwMacCr=Mac_GetRegDW(privateData,MAC_CR,keyCode);
+			if(dwMacCr&MAC_CR_RXEN_) {
+				SMSC_WARNING("Rx_ReceiverOn: Receiver is already on");
+			}
+			dwMacCr|=MAC_CR_RXEN_;
+			Mac_SetRegDW(privateData,MAC_CR,dwMacCr,keyCode);
+			//SET_GPIO(GP_RX);
+		}
+	} else {
+		SMSC_ASSERT(FALSE);
+	}
+	if (callerKeyCode == 0) {
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+}
+
+void Rx_ProcessPackets(PPRIVATE_DATA privateData)
+{
+	DWORD dwRxStatus=0;
+	PPLATFORM_DATA platformData=NULL;
+//	SET_GPIO(GP_RX);
+	privateData->RxCongested=FALSE;
+	platformData=&(privateData->PlatformData);
+	if(privateData->dwRxDmaCh>=TRANSFER_PIO) {
+		//Use PIO only
+		Lan_SetRegDW(RX_CFG,0x00000200UL);
+		while((dwRxStatus=Rx_PopRxStatus(privateData))!=0)
+		{
+			DWORD dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+			Rx_CountErrors(privateData,dwRxStatus);
+			if((dwRxStatus&RX_STS_ES_)==0) {
+				struct sk_buff *skb=NULL;
+				skb=dev_alloc_skb(dwPacketLength+2);
+				if(skb!=NULL) {
+					skb->data=skb->head;
+					skb->tail=skb->head;
+					skb_reserve(skb,2); // align IP on 16B boundary
+					skb_put(skb,dwPacketLength-4UL);
+
+					//update counters
+					privateData->stats.rx_packets++;
+					privateData->stats.rx_bytes+=(dwPacketLength-4);
+
+					privateData->RxPacketReadCount++;
+					privateData->RxPioReadCount++;
+					privateData->RxDataDWReadCount+=
+						(dwPacketLength+2+3)>>2;
+
+					Platform_ReadFifo(
+						privateData->dwLanBase,
+						((DWORD *)(skb->head)),
+						(dwPacketLength+2+3)>>2);
+
+					Rx_HandOffSkb(privateData,skb);
+					continue;
+				} else {
+					SMSC_WARNING("Unable to allocate sk_buff for RX Packet, in PIO path");
+					privateData->stats.rx_dropped++;
+				}
+			}
+			//if we get here then the packet is to be read
+			//  out of the fifo and discarded
+			dwPacketLength+=(2+3);
+			dwPacketLength>>=2;
+			Rx_FastForward(privateData,dwPacketLength);
+		}
+	} else {
+		//Use DMA and PIO
+		DWORD dwDmaCh=privateData->dwRxDmaCh;
+		//struct sk_buff *dmaSkb=NULL;//use privateData->RxDmaSkb
+		DMA_XFER dmaXfer;
+		dmaXfer.dwLanReg=privateData->dwLanBase+RX_DATA_FIFO;
+		dmaXfer.pdwBuf=NULL;// this will be reset per dma request
+		dmaXfer.dwDmaCh=dwDmaCh;
+		dmaXfer.dwDwCnt=0;// this will be reset per dma request
+		dmaXfer.fMemWr=TRUE;
+		while((dwRxStatus=Rx_PopRxStatus(privateData))!=0)
+		{
+			DWORD dwPacketLength;
+
+			BUG_ON(privateData->RxSkb != NULL);
+
+			Rx_CountErrors(privateData,dwRxStatus);
+			dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+			if((dwRxStatus&RX_STS_ES_)==0)
+			{
+				struct sk_buff *skb=dev_alloc_skb(dwPacketLength+2*PLATFORM_CACHE_LINE_BYTES);
+				if(skb!=NULL)
+				{
+					skb->data=skb->head;
+					skb->tail=skb->head;
+
+					//align IP on cache line boundary
+					privateData->stats.rx_packets++;
+					privateData->stats.rx_bytes+=(dwPacketLength-4UL);
+					if(dwPacketLength>=privateData->dwRxDmaThreshold)
+					{
+						//use DMA
+						DWORD dwDwordCount;
+						skb_reserve(skb,PLATFORM_CACHE_LINE_BYTES-14);
+						skb_put(skb,dwPacketLength-4UL);
+						dwDwordCount=((dwPacketLength+
+							(PLATFORM_CACHE_LINE_BYTES-14)+
+							PLATFORM_CACHE_LINE_BYTES-1)&
+							(~(PLATFORM_CACHE_LINE_BYTES-1)))>>2;
+						Platform_CacheInvalidate(
+							platformData,
+							skb->head,dwDwordCount<<2);
+						dmaXfer.pdwBuf=(DWORD *)(skb->head);
+						dmaXfer.dwDwCnt=dwDwordCount;
+						privateData->RxDataDWReadCount+=dwDwordCount;
+						privateData->RxPacketReadCount++;
+						privateData->RxDmaReadCount++;
+
+						//set end alignment and offset
+						switch(PLATFORM_CACHE_LINE_BYTES)
+						{
+						//case 4: Lan_SetRegDW(RX_CFG,0x00000200UL);break;
+						case 16:Lan_SetRegDW(RX_CFG,0x40000200UL);break;
+						case 32:Lan_SetRegDW(RX_CFG,0x80001200UL);break;
+						default:SMSC_ASSERT(FALSE);
+						}
+						if(!Platform_DmaStartXfer(platformData,&dmaXfer, Rx_DmaCompletionCallback, privateData)) {
+							SMSC_WARNING("Failed Platform_DmaStartXfer");
+						}
+						privateData->RxSkb=skb;
+						Lan_DisableInterrupt(privateData,privateData->RxInterrupts);
+						goto FINISH;
+					}
+					else
+					{
+						//use PIO
+						skb_reserve(skb,2);
+						skb_put(skb,dwPacketLength-4UL);
+						//set end alignment and offset
+						Lan_SetRegDW(RX_CFG,0x00000200UL);//4 byte end alignment
+						privateData->RxPacketReadCount++;
+						privateData->RxPioReadCount++;
+						privateData->RxDataDWReadCount+=
+							((dwPacketLength+2+3)>>2);
+						Platform_ReadFifo(
+							privateData->dwLanBase,
+							((DWORD *)(skb->head)),
+							(dwPacketLength+2+3)>>2);
+						Rx_HandOffSkb(privateData,skb);
+					}
+					continue;
+				}
+				else
+				{
+					SMSC_WARNING("Unable to allocate sk_buff for RX Packet, in DMA path");
+					privateData->stats.rx_dropped++;
+				}
+			}
+			//if we get here then the packet is to be read
+			//  out of the fifo and discarded
+			{
+				DWORD dwTimeOut=100000;
+
+				while ((privateData->RxSkb) && (dwTimeOut)) {
+					udelay(10);
+					dwTimeOut--;
+				}
+				if (dwTimeOut == 0)
+					SMSC_WARNING("Timed out waiting for Rx DMA complete");
+			}
+
+			//delay returning the dmaSkb to OS till later
+			dwPacketLength+=(2+3);
+			dwPacketLength>>=2;
+			Lan_SetRegDW(RX_CFG,0x00000200UL);//4 byte end alignment
+			Rx_FastForward(privateData,dwPacketLength);
+		}
+	}
+FINISH:
+	Lan_SetRegDW(INT_STS,INT_STS_RSFL_);
+//	CLEAR_GPIO(GP_RX);
+}
+
+void Rx_ProcessPacketsTasklet(unsigned long data)
+{
+    PPRIVATE_DATA privateData=(PPRIVATE_DATA)Rx_TaskletParameter;
+	data=data;//make lint happy
+	if(privateData==NULL) {
+		SMSC_WARNING("Rx_ProcessPacketsTasklet(privateData==NULL)");
+		return;
+	}
+	Rx_ProcessPackets(privateData);
+	Lan_EnableIRQ(privateData);
+}
+
+static void Rx_DmaCompletionCallback(void* param)
+{
+	PPRIVATE_DATA privateData = param;
+
+	BUG_ON(privateData->RxSkb == NULL);
+	Rx_HandOffSkb(privateData,privateData->RxSkb);
+	privateData->RxSkb = NULL;
+	Lan_EnableInterrupt(privateData,privateData->RxInterrupts);
+}
+
+BOOLEAN Rx_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+
+	privateData->LastReasonForReleasingCPU=0;
+
+	if(dwIntSts&INT_STS_RXE_) {
+		SMSC_TRACE("Rx_HandleInterrupt: RXE signalled");
+		privateData->stats.rx_errors++;
+		Lan_SetRegDW(INT_STS,INT_STS_RXE_);
+		result=TRUE;
+	}
+
+	if(dwIntSts&INT_STS_RXDFH_INT_) {
+		privateData->stats.rx_dropped+=Lan_GetRegDW(RX_DROP);
+		Lan_SetRegDW(INT_STS,INT_STS_RXDFH_INT_);
+		result=TRUE;
+	}
+
+	if(IS_REV_A(privateData)) {
+		if(dwIntSts&(INT_STS_RDFL_)) {
+			Lan_SetRegDW(INT_STS,INT_STS_RDFL_);
+			Rx_HandleOverrun(privateData);
+			result=TRUE;
+		}
+	} else {
+		if(dwIntSts&(INT_STS_RDFO_)) {
+			Lan_SetRegDW(INT_STS,INT_STS_RDFO_);
+			Rx_HandleOverrun(privateData);
+			result=TRUE;
+		}
+	}
+
+	if((!(dwIntSts&INT_STS_RSFL_))&&(privateData->RxOverrun==FALSE)) {
+		return result;
+	}
+	if (privateData->RxSkb) {
+		/* We are still DMAing the previous packet from the RX
+		 * FIFO, and waiting for the DMA completion callback.
+		 * We got here because another interrupt was active,
+		 * even though Rx interrupts are disabled.
+		 */
+		return result;
+	}
+
+	result=TRUE;
+
+	if(privateData->MeasuringRxThroughput==FALSE) {
+		privateData->MeasuringRxThroughput=TRUE;
+		Gpt_ScheduleCallBack(privateData,GptCB_MeasureRxThroughput,1000);
+		privateData->RxFlowCurrentThroughput=0;
+		privateData->RxFlowCurrentPacketCount=0;
+		privateData->RxFlowCurrentWorkLoad=0;
+	}
+	if(tasklets) {
+		Lan_DisableIRQ(privateData);
+		Rx_TaskletParameter=(unsigned long)privateData;
+		tasklet_schedule(&Rx_Tasklet);
+	} else {
+		Rx_ProcessPackets(privateData);
+	}
+	return result;
+}
+
+BOOLEAN RxStop_HandleInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+
+	if(dwIntSts&INT_STS_RXSTOP_INT_) {
+		result=TRUE;
+
+		Gpt_CancelCallBack (privateData, GptCB_RxCompleteMulticast);
+		Rx_CompleteMulticastUpdate (privateData);
+		Lan_SetRegDW(INT_STS,INT_STS_RXSTOP_INT_);
+		Lan_DisableInterrupt(privateData,INT_EN_RXSTOP_INT_EN_);
+	}
+	return result;
+}
+
+//returns hash bit number for given MAC address
+//example:
+//   01 00 5E 00 00 01 -> returns bit number 31
+static DWORD Rx_Hash(BYTE addr[6])
+{
+	int i;
+	DWORD crc=0xFFFFFFFFUL;
+	DWORD poly=0xEDB88320UL;
+	DWORD result=0;
+	for(i=0;i<6;i++)
+	{
+		int bit;
+		DWORD data=((DWORD)addr[i]);
+		for(bit=0;bit<8;bit++)
+		{
+			DWORD p = (crc^((DWORD)data))&1UL;
+			crc >>= 1;
+			if(p!=0) crc ^= poly;
+			data >>=1;
+		}
+	}
+	result=((crc&0x01UL)<<5)|
+		((crc&0x02UL)<<3)|
+		((crc&0x04UL)<<1)|
+		((crc&0x08UL)>>1)|
+		((crc&0x10UL)>>3)|
+		((crc&0x20UL)>>5);
+	return result;
+}
+
+void Rx_SetMulticastList(
+	struct net_device *dev)
+{
+	PPRIVATE_DATA privateData=NULL;
+	VL_KEY keyCode=0;
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(dev!=NULL);
+
+	privateData=((PPRIVATE_DATA)(dev->priv));
+    	SMSC_ASSERT(privateData!=NULL);
+	keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+
+	if(dev->flags & IFF_PROMISC) {
+//		SMSC_TRACE("Promiscuous Mode Enabled");
+		privateData->set_bits_mask = MAC_CR_PRMS_;
+		privateData->clear_bits_mask = (MAC_CR_MCPAS_ | MAC_CR_HPFILT_);
+
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+		goto PREPARE;
+	}
+
+	if(dev->flags & IFF_ALLMULTI) {
+//		SMSC_TRACE("Receive all Multicast Enabled");
+		privateData->set_bits_mask = MAC_CR_MCPAS_;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_HPFILT_);
+
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+		goto PREPARE;
+	}
+
+
+	if(dev->mc_count>0) {
+		DWORD dwHashH=0;
+		DWORD dwHashL=0;
+		DWORD dwCount=0;
+		struct dev_mc_list *mc_list=dev->mc_list;
+
+		privateData->set_bits_mask = MAC_CR_HPFILT_;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_);
+
+		while(mc_list!=NULL) {
+			dwCount++;
+			if((mc_list->dmi_addrlen)==6) {
+				DWORD dwMask=0x01UL;
+				DWORD dwBitNum=Rx_Hash(mc_list->dmi_addr);
+				SMSC_TRACE("Multicast: enable dwBitNum=%ld,addr=%02X %02X %02X %02X %02X %02X",
+					dwBitNum,
+					((BYTE *)(mc_list->dmi_addr))[0],
+					((BYTE *)(mc_list->dmi_addr))[1],
+					((BYTE *)(mc_list->dmi_addr))[2],
+					((BYTE *)(mc_list->dmi_addr))[3],
+					((BYTE *)(mc_list->dmi_addr))[4],
+					((BYTE *)(mc_list->dmi_addr))[5]);
+				dwMask<<=(dwBitNum&0x1FUL);
+				if(dwBitNum&0x20UL) {
+					dwHashH|=dwMask;
+				} else {
+					dwHashL|=dwMask;
+				}
+			} else {
+				SMSC_WARNING("dmi_addrlen!=6");
+			}
+			mc_list=mc_list->next;
+		}
+		if(dwCount!=((DWORD)(dev->mc_count))) {
+			SMSC_WARNING("dwCount!=dev->mc_count");
+		}
+		// SMSC_TRACE("Multicast: HASHH=0x%08lX,HASHL=0x%08lX",dwHashH,dwHashL);
+		privateData->HashHi = dwHashH;
+		privateData->HashLo = dwHashL;
+	}
+	else
+	{
+		privateData->set_bits_mask = 0L;
+		privateData->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);
+
+		// SMSC_TRACE("Receive own packets only.");
+		privateData->HashHi = 0UL;
+		privateData->HashLo = 0UL;
+	}
+
+PREPARE:
+	if (privateData->MulticastUpdatePending == FALSE) {
+		privateData->MulticastUpdatePending = TRUE;
+		// prepare to signal software interrupt
+		Lan_SignalSoftwareInterrupt(privateData);
+	}
+	else {
+		// Rx_CompleteMulticastUpdate has not yet been called
+		// therefore these latest settings will be used instead
+	}
+	Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	return;
+}
+
+void Eeprom_EnableAccess(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(debug_mode&0x04UL) {
+		Lan_SetRegDW(GPIO_CFG,(g_GpioSetting&0xFF0FFFFFUL));
+	} else {
+		Lan_ClrBitsDW(GPIO_CFG,0x00F00000UL);
+	}
+	udelay(100);
+}
+
+void Eeprom_DisableAccess(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	if(debug_mode&0x04UL) {
+		Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+	}
+}
+
+BOOLEAN Eeprom_IsMacAddressLoaded(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_MAC_ADDR_LOADED_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_IsBusy(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_EPC_BUSY_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_Timeout(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	return (Lan_GetRegDW(E2P_CMD)&
+		E2P_CMD_EPC_TIMEOUT_)?TRUE:FALSE;
+}
+
+BOOLEAN Eeprom_ReadLocation(
+	PPRIVATE_DATA privateData,
+	BYTE address, BYTE * data)
+{
+	DWORD timeout=100000;
+	DWORD temp=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(data!=NULL);
+	if((temp=Lan_GetRegDW(E2P_CMD))&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_ReadLocation: Busy at start, E2P_CMD=0x%08lX",temp);
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_READ_|((DWORD)address)));
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	(*data)=(BYTE)(Lan_GetRegDW(E2P_DATA));
+	return TRUE;
+}
+
+BOOLEAN Eeprom_EnableEraseAndWrite(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_EnableEraseAndWrite: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_EWEN_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_DisableEraseAndWrite(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_DisableEraseAndWrite: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_EWDS_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_WriteLocation(
+	PPRIVATE_DATA privateData,BYTE address,BYTE data)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_WriteLocation: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_DATA,((DWORD)data));
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_WRITE_|((DWORD)address)));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_EraseAll(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_EraseAll: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_ERAL_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_Reload(
+	PPRIVATE_DATA privateData)
+{
+	DWORD timeout=100000;
+	SMSC_ASSERT(privateData!=NULL);
+	if(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_) {
+		SMSC_WARNING("Eeprom_Reload: Busy at start");
+		return FALSE;
+	}
+	Lan_SetRegDW(E2P_CMD,
+		(E2P_CMD_EPC_BUSY_|E2P_CMD_EPC_CMD_RELOAD_));
+
+	while((timeout>0)&&
+		(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_))
+	{
+		udelay(10);
+		timeout--;
+	}
+	if(timeout==0) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOLEAN Eeprom_SaveMacAddress(
+	PPRIVATE_DATA privateData,
+	DWORD dwHi16,DWORD dwLo32)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(privateData!=NULL);
+	Eeprom_EnableAccess(privateData);
+	if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+	if(!Eeprom_EraseAll(privateData)) goto DONE;
+	if(IS_REV_A(privateData)) {
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,0,0xA5)) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,1,LOBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,2,HIBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,3,LOBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,4,HIBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,5,LOBYTE(LOWORD(dwHi16)))) goto DONE;
+		if(!Eeprom_EnableEraseAndWrite(privateData)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,6,HIBYTE(LOWORD(dwHi16)))) goto DONE;
+	} else {
+		if(!Eeprom_WriteLocation(privateData,0,0xA5)) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,1,LOBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,2,HIBYTE(LOWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,3,LOBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,4,HIBYTE(HIWORD(dwLo32)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,5,LOBYTE(LOWORD(dwHi16)))) goto DONE;
+		if(!Eeprom_WriteLocation(privateData,6,HIBYTE(LOWORD(dwHi16)))) goto DONE;
+	}
+	if(!Eeprom_DisableEraseAndWrite(privateData)) goto DONE;
+
+	if(!Eeprom_Reload(privateData)) goto DONE;
+	if(!Eeprom_IsMacAddressLoaded(privateData)) goto DONE;
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		if(dwHi16!=Mac_GetRegDW(privateData,ADDRH,keyCode)) goto DONE;
+		if(dwLo32!=Mac_GetRegDW(privateData,ADDRL,keyCode)) goto DONE;
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+	result=TRUE;
+DONE:
+	Eeprom_DisableAccess(privateData);
+	return result;
+}
+
+volatile DWORD g_GpioSetting=0x00000000UL;
+#ifdef USE_LED1_WORK_AROUND
+volatile DWORD g_GpioSettingOriginal=0x00000000UL;
+#endif
+
+BOOLEAN Lan_Initialize(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntCfg,
+	DWORD dwTxFifSz,
+	DWORD dwAfcCfg)
+{
+	BOOLEAN result=FALSE;
+	DWORD dwTimeOut=0;
+	DWORD dwTemp=0;
+	DWORD dwResetCount=3;
+
+    SMSC_TRACE("-->Lan_Initialize(dwIntCfg=0x%08lX)",dwIntCfg);
+	SMSC_ASSERT(privateData!=NULL);
+
+	//Reset the LAN911x
+	if(!IS_REV_A(privateData)) {
+		dwResetCount=1;
+	}
+	while(dwResetCount>0) {
+		Lan_SetRegDW(HW_CFG,HW_CFG_SRST_);
+		dwTimeOut=1000000;
+		do {
+			udelay(10);
+			dwTemp=Lan_GetRegDW(HW_CFG);
+			dwTimeOut--;
+		} while((dwTimeOut>0)&&(dwTemp&HW_CFG_SRST_));
+		if(dwTemp&HW_CFG_SRST_) {
+			SMSC_WARNING("  Failed to complete reset.");
+			goto DONE;
+		}
+		dwResetCount--;
+	}
+
+	SMSC_ASSERT(dwTxFifSz>=0x00020000UL);
+	SMSC_ASSERT(dwTxFifSz<=0x000E0000UL);
+	SMSC_ASSERT((dwTxFifSz&(~HW_CFG_TX_FIF_SZ_))==0);
+	Lan_SetRegDW(HW_CFG,dwTxFifSz);
+	privateData->RxMaxDataFifoSize=0;
+	switch(dwTxFifSz>>16) {
+	case 2:privateData->RxMaxDataFifoSize=13440;break;
+	case 3:privateData->RxMaxDataFifoSize=12480;break;
+	case 4:privateData->RxMaxDataFifoSize=11520;break;
+	case 5:privateData->RxMaxDataFifoSize=10560;break;
+	case 6:privateData->RxMaxDataFifoSize=9600;break;
+	case 7:privateData->RxMaxDataFifoSize=8640;break;
+	case 8:privateData->RxMaxDataFifoSize=7680;break;
+	case 9:privateData->RxMaxDataFifoSize=6720;break;
+	case 10:privateData->RxMaxDataFifoSize=5760;break;
+	case 11:privateData->RxMaxDataFifoSize=4800;break;
+	case 12:privateData->RxMaxDataFifoSize=3840;break;
+	case 13:privateData->RxMaxDataFifoSize=2880;break;
+	case 14:privateData->RxMaxDataFifoSize=1920;break;
+	default:SMSC_ASSERT(FALSE);break;
+	}
+
+	if(dwAfcCfg==0xFFFFFFFF) {
+		switch(dwTxFifSz) {
+
+		//AFC_HI is about ((Rx Data Fifo Size)*2/3)/64
+		//AFC_LO is AFC_HI/2
+		//BACK_DUR is about 5uS*(AFC_LO) rounded down
+		case 0x00020000UL://13440 Rx Data Fifo Size
+			dwAfcCfg=0x008C46AF;break;
+		case 0x00030000UL://12480 Rx Data Fifo Size
+			dwAfcCfg=0x0082419F;break;
+		case 0x00040000UL://11520 Rx Data Fifo Size
+
+			dwAfcCfg=0x00783C9F;break;
+		case 0x00050000UL://10560 Rx Data Fifo Size
+//			dwAfcCfg=0x006E378F;break;
+			dwAfcCfg=0x006E374F;break;
+		case 0x00060000UL:// 9600 Rx Data Fifo Size
+			dwAfcCfg=0x0064328F;break;
+		case 0x00070000UL:// 8640 Rx Data Fifo Size
+			dwAfcCfg=0x005A2D7F;break;
+		case 0x00080000UL:// 7680 Rx Data Fifo Size
+			dwAfcCfg=0x0050287F;break;
+		case 0x00090000UL:// 6720 Rx Data Fifo Size
+			dwAfcCfg=0x0046236F;break;
+		case 0x000A0000UL:// 5760 Rx Data Fifo Size
+			dwAfcCfg=0x003C1E6F;break;
+		case 0x000B0000UL:// 4800 Rx Data Fifo Size
+			dwAfcCfg=0x0032195F;break;
+
+		//AFC_HI is ~1520 bytes less than RX Data Fifo Size
+		//AFC_LO is AFC_HI/2
+		//BACK_DUR is about 5uS*(AFC_LO) rounded down
+		case 0x000C0000UL:// 3840 Rx Data Fifo Size
+			dwAfcCfg=0x0024124F;break;
+		case 0x000D0000UL:// 2880 Rx Data Fifo Size
+			dwAfcCfg=0x0015073F;break;
+		case 0x000E0000UL:// 1920 Rx Data Fifo Size
+			dwAfcCfg=0x0006032F;break;
+		default:SMSC_ASSERT(FALSE);break;
+		}
+	}
+	Lan_SetRegDW(AFC_CFG,(dwAfcCfg&0xFFFFFFF0UL));
+
+	//make sure EEPROM has finished loading before setting GPIO_CFG
+	dwTimeOut=1000;
+	while((dwTimeOut>0)&&(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_)) {
+		udelay(5);
+		dwTimeOut--;
+	}
+	if(dwTimeOut==0) {
+		SMSC_WARNING("Lan_Initialize: Timed out waiting for EEPROM busy bit to clear\n");
+	}
+
+	if(debug_mode&0x04UL) {
+		if(OLD_REGISTERS(privateData))
+		{
+			g_GpioSetting=0x00270700UL;
+		} else {
+			g_GpioSetting=0x00670700UL;
+		}
+	} else {
+		g_GpioSetting = 0x70070000UL;
+	}
+	Lan_SetRegDW(GPIO_CFG,g_GpioSetting);
+	SMSC_TRACE("<--g_GpioSetting set");
+
+	//initialize interrupts
+	Lan_SetRegDW(INT_EN,0);
+	Lan_SetRegDW(INT_STS,0xFFFFFFFFUL);
+	dwIntCfg|=INT_CFG_IRQ_EN_;
+	Lan_SetRegDW(INT_CFG,dwIntCfg);
+
+	Vl_InitLock(&(privateData->MacPhyLock));
+	spin_lock_init(&(privateData->IntEnableLock));
+	privateData->LanInitialized=TRUE;
+
+	result=TRUE;
+
+DONE:
+	SMSC_TRACE("<--Lan_Initialize");
+	return result;
+}
+
+void Lan_EnableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask)
+{
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	Lan_SetBitsDW(INT_EN,dwIntEnMask);
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_DisableInterrupt(PPRIVATE_DATA privateData,DWORD dwIntEnMask)
+{
+	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	Lan_ClrBitsDW(INT_EN,dwIntEnMask);
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+//Spin locks for the following functions have been commented out
+//  because at this time they are not necessary.
+//These function are
+//  Lan_SetTDFL
+//  Lan_SetTSFL
+//  Lan_SetRDFL
+//  Lan_SetRSFL
+//Both the Rx and Tx side of the driver use the FIFO_INT,
+//  but the Rx side only touches is during initialization,
+//  so it is sufficient that Tx side simple preserve the Rx setting
+
+void Lan_SetTDFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0x00FFFFFFUL;
+		temp|=((DWORD)level)<<24;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetTSFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFF00FFFFUL;
+		temp|=((DWORD)level)<<16;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetRDFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFFFF00FFUL;
+		temp|=((DWORD)level)<<8;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetRSFL(PPRIVATE_DATA privateData,BYTE level) {
+//	DWORD dwIntFlags=0;
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->LanInitialized==TRUE);
+//	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		DWORD temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0xFFFFFF00UL;
+		temp|=((DWORD)level);
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+//	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_EnableIRQ(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_SetBitsDW(INT_CFG,INT_CFG_IRQ_EN_);
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_DisableIRQ(PPRIVATE_DATA privateData)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_ClrBitsDW(INT_CFG,INT_CFG_IRQ_EN_);
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SetIntDeas(PPRIVATE_DATA privateData, DWORD dwIntDeas)
+{
+	DWORD dwIntFlags=0;
+	spin_lock_irqsave(&(privateData->IntEnableLock),dwIntFlags);
+	{
+		Lan_ClrBitsDW(INT_CFG,INT_CFG_INT_DEAS_);
+		Lan_SetBitsDW(INT_CFG,(dwIntDeas<<24));
+	}
+	spin_unlock_irqrestore(&(privateData->IntEnableLock),dwIntFlags);
+}
+
+void Lan_SignalSoftwareInterrupt(PPRIVATE_DATA privateData)
+{
+	SMSC_ASSERT(privateData!=NULL);
+	SMSC_ASSERT(privateData->dwLanBase!=0);
+	privateData->SoftwareInterruptSignal=FALSE;
+	Lan_EnableInterrupt(privateData,INT_EN_SW_INT_EN_);
+}
+
+BOOLEAN Lan_HandleSoftwareInterrupt(
+	PPRIVATE_DATA privateData,
+	DWORD dwIntSts)
+{
+	if(dwIntSts&INT_STS_SW_INT_) {
+		SMSC_ASSERT(privateData!=NULL);
+		Lan_DisableInterrupt(privateData,INT_EN_SW_INT_EN_);
+		Lan_SetRegDW(INT_STS,INT_STS_SW_INT_);
+		privateData->SoftwareInterruptSignal=TRUE;
+		if (privateData->MulticastUpdatePending) {
+			Rx_BeginMulticastUpdate (privateData);
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+typedef struct _SHOW_REG
+{
+	char  szName[20];
+	DWORD dwOffset;
+} SHOW_REG;
+/*
+FUNCTION: Lan_ShowRegs
+    This function is used to display the registers.
+	Except the phy.
+*/
+void Lan_ShowRegs(PPRIVATE_DATA privateData)
+{
+	//	Make these const struct's static to keep them off the stack.
+	//	Otherwise, gcc will try to use _memcpy() to initialize them,
+	//	which will *NOT* work in our RunTime environment.
+	static const SHOW_REG sysCsr[] = {
+		{ "ID_REV",			0x50UL		},
+		{ "INT_CFG",		0x54UL		},
+		{ "INT_STS",		0x58UL		},
+		{ "INT_EN",			0x5CUL		},
+		{ "DMA_CFG",		0x60UL		},
+		{ "BYTE_TEST",		0x64UL		},
+		{ "FIFO_INT",		0x68UL		},
+		{ "RX_CFG",			0x6CUL		},
+		{ "TX_CFG",			0x70UL		},
+		{ "HW_CFG",			0x74UL		},
+		{ "RX_DP_CTRL",		0x78UL		},
+		{ "RX_FIFO_INF",	0x7CUL		},
+		{ "TX_FIFO_INF",	0x80UL		},
+		{ "PMT_CTRL",		0x84UL		},
+		{ "GPIO_CFG",		0x88UL		},
+		{ "GPT_CFG",		0x8CUL		},
+		{ "GPT_CNT",		0x90UL		},
+		{ "FPGA_REV",		0x94UL		},
+		{ "ENDIAN",			0x98UL		},
+		{ "FREE_RUN",		0x9CUL		},
+		{ "RX_DROP",		0xA0UL		},
+		{ "MAC_CSR_CMD",	0xA4UL		},
+		{ "MAC_CSR_DATA",	0xA8UL		},
+		{ "AFC_CFG",		0xACUL		},
+		{ "E2P_CMD",		0xB0UL		},
+		{ "E2P_DATA",		0xB4UL		},
+		{ "TEST_REG_A",		0xC0UL		}};
+
+	static const SHOW_REG macCsr[] = {
+		{ "MAC_CR",		MAC_CR		},
+		{ "ADDRH",		ADDRH		},
+		{ "ADDRL",		ADDRL		},
+		{ "HASHH",		HASHH		},
+		{ "HASHL",		HASHL		},
+		{ "MII_ACC",	MII_ACC		},
+		{ "MII_DATA",	MII_DATA	},
+		{ "FLOW",		FLOW		},
+		{ "VLAN1",		VLAN1		},
+		{ "VLAN2",		VLAN2		},
+		{ "WUFF",		WUFF		},
+		{ "WUCSR",		WUCSR		}};
+
+	int i, iNumSysRegs, iNumMacRegs;
+	DWORD dwOldMacCmdReg, dwOldMacDataReg;
+
+	iNumSysRegs = (int)(sizeof(sysCsr) / sizeof(SHOW_REG));
+	iNumMacRegs = (int)(sizeof(macCsr) / sizeof(SHOW_REG));
+
+	// preserve MAC cmd/data reg's
+	dwOldMacCmdReg = Lan_GetRegDW(MAC_CSR_CMD);
+	dwOldMacDataReg = Lan_GetRegDW(MAC_CSR_DATA);
+
+	SMSC_TRACE("");
+	SMSC_TRACE("               LAN91C11x CSR's");
+	SMSC_TRACE("                     SYS CSR's                     MAC CSR's");
+
+	{
+		DWORD dwIntFlags=0;
+		VL_KEY keyCode=Vl_WaitForLock(&(privateData->MacPhyLock),&dwIntFlags);
+		for (i=0; i<iNumMacRegs; i++)
+		{
+			SMSC_TRACE(
+				"%16s (0x%02lX) = 0x%08lX, %8s (0x%02lX) + 0x%08lX",
+				sysCsr[i].szName,
+				sysCsr[i].dwOffset,
+				*((volatile DWORD *)(privateData->dwLanBase+sysCsr[i].dwOffset)),
+				macCsr[i].szName,
+				macCsr[i].dwOffset,
+				Mac_GetRegDW(privateData,macCsr[i].dwOffset,keyCode));
+
+			// restore original mac cmd/data reg's after each usage
+			Lan_SetRegDW(MAC_CSR_CMD,dwOldMacCmdReg);
+			Lan_SetRegDW(MAC_CSR_DATA,dwOldMacDataReg);
+		}
+		Vl_ReleaseLock(&(privateData->MacPhyLock),keyCode,&dwIntFlags);
+	}
+	for (i=iNumMacRegs; i<iNumSysRegs; i++)
+	{
+		SMSC_TRACE("%16s (0x%02lX) = 0x%08lX",
+			sysCsr[i].szName,
+			sysCsr[i].dwOffset,
+			*((volatile DWORD *)(privateData->dwLanBase+sysCsr[i].dwOffset)));
+	}
+}
+
+void Vl_InitLock(PVERIFIABLE_LOCK pVl)
+{
+	SMSC_ASSERT(pVl!=NULL);
+	spin_lock_init(&(pVl->Lock));
+	pVl->KeyCode=0;
+}
+
+BOOLEAN Vl_CheckLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode)
+{
+	BOOLEAN result=FALSE;
+	SMSC_ASSERT(pVl!=NULL);
+	if(keyCode==pVl->KeyCode)
+		result=TRUE;
+	return result;
+}
+
+VL_KEY Vl_WaitForLock(PVERIFIABLE_LOCK pVl,DWORD *pdwIntFlags)
+{
+	VL_KEY result=0;
+	SMSC_ASSERT(pVl!=NULL);
+	spin_lock_irqsave(
+		&(pVl->Lock),
+		(*pdwIntFlags));
+	pVl->KeyCode++;
+	if(pVl->KeyCode>0x80000000UL) {
+		pVl->KeyCode=1;
+	}
+	result=pVl->KeyCode;
+	return result;
+}
+
+void Vl_ReleaseLock(PVERIFIABLE_LOCK pVl,VL_KEY keyCode,DWORD *pdwIntFlags)
+{
+	SMSC_ASSERT(pVl!=NULL);
+	SMSC_ASSERT(pVl->KeyCode==keyCode);
+	spin_unlock_irqrestore(&(pVl->Lock),(*pdwIntFlags));
+}
+
+#ifndef USING_LINT
+module_init(Smsc911x_init_module);
+module_exit(Smsc911x_cleanup_module);
+#endif
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/st40.c linux-2.6.17.8-sh/drivers/net/smsc_911x/st40.c
--- linux-2.6.17.8/drivers/net/smsc_911x/st40.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/st40.c	2006-08-23 13:29:45.351761000 +0100
@@ -0,0 +1,449 @@
+/***************************************************************************
+ *
+ * Copyright (C) 2004-2005  SMSC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***************************************************************************
+ * File: st40.c
+ *
+ * 03/18/2005 Phong Le, rev 1
+ * Make this driver to work with Lan911x driver Version 1.13
+ *
+ * 03/22/2005 Bryan Whitehead, rev 2
+ * Added support for 16/32 bit autodetect
+ *
+ * 04/11/2005 Bryan Whitehead, rev 3
+ *    updated platform code to support version 1.14 platform changes
+ *
+ * 05/02/2005 Phong Le, rev 4
+ * Make this driver to work with Lan911x driver Version 1.15
+ *
+ ***************************************************************************
+ * NOTE: When making changes to platform specific code please remember to
+ *   update the revision number in the PLATFORM_NAME macro. This is a
+ *   platform specific version number and independent of the
+ *   common code version number. The PLATFORM_NAME macro should be found in
+ *   your platforms ".h" file.
+ */
+
+#ifndef ST40_H
+#define ST40_H
+
+#ifndef USE_ST40_STMICRO
+#error USE_ST40_STMICRO
+#endif
+
+//for a description of these MACROs see readme.txt
+
+#define PLATFORM_IRQ_POL	(0UL)
+#define PLATFORM_IRQ_TYPE	(0UL)
+
+#define DB641_USE_PORT0
+#if defined(CONFIG_SH_STI5528_EVAL)
+/* db641 STEM card plugged into mb376 */
+#ifdef DB641_USE_PORT0
+/* STEM CS0 = BANK3 */
+#define PLATFORM_CSBASE		(0xA3000000UL)
+#define PLATFORM_IRQ		(10UL)
+#else
+/* STEM CS1 = BANK4 */
+#define PLATFORM_CSBASE		(0xA3400000UL)
+#define PLATFORM_IRQ		(9UL)
+#endif
+#elif defined(CONFIG_SH_STB7100_MBOARD)
+/* db641 STEM card plugged into mb376 */
+#ifdef DB641_USE_PORT0
+/* STEM CS0 = BankB, A23=0 */
+#define PLATFORM_CSBASE		(0xA1000000UL)
+#define PLATFORM_IRQ		(12UL)
+#else
+/* STEM CS1 = BankB, A23=1 */
+#define PLATFORM_CSBASE		(0xA1800000UL)
+#define PLATFORM_IRQ		(11UL)
+#endif
+#else
+#error Unknown board
+#endif
+
+#define PLATFORM_CACHE_LINE_BYTES (32UL)
+#ifdef CONFIG_SMSC911x_DMA
+#define PLATFORM_RX_DMA	(TRANSFER_REQUEST_DMA)
+#define PLATFORM_TX_DMA	(TRANSFER_REQUEST_DMA)
+#else
+#define PLATFORM_RX_DMA	(TRANSFER_PIO)
+#define PLATFORM_TX_DMA	(TRANSFER_PIO)
+#endif
+#define PLATFORM_NAME		"ST40 STMICRO r3"
+
+//the dma threshold has not been thoroughly tuned but it is
+//  slightly better than using zero
+#define PLATFORM_DMA_THRESHOLD (200)
+
+typedef struct _PLATFORM_DATA {
+	DWORD dwBitWidth;
+	DWORD dwIdRev;
+	DWORD dwIrq;
+	void * dev_id;
+} PLATFORM_DATA, *PPLATFORM_DATA;
+
+inline void Platform_SetRegDW(
+		DWORD dwLanBase,
+		DWORD dwOffset,
+		DWORD dwVal)
+{
+	(*(volatile DWORD *)(dwLanBase+dwOffset))=dwVal;
+}
+
+inline DWORD Platform_GetRegDW(
+	DWORD dwLanBase,
+	DWORD dwOffset)
+{
+	return (*(volatile DWORD *)(dwLanBase+dwOffset));
+}
+
+//See readme.txt for a description of how these
+//functions must be implemented
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase,
+	DWORD dwBusWidth);
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int irq,void *dev_id,struct pt_regs *regs),
+	void *dev_id);
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData);
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData);
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh);
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh);
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes);
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData);
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel);
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*), void* pCallbackData);
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh);
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma);
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount);
+
+
+#endif
+#ifndef USE_ST40_STMICRO
+#error Must define USE_ST40_STMICRO
+#endif
+
+static const char date_code[] = "072605";
+
+/* SMSC LAN9118 Byte ordering test register offset */
+#define BYTE_TEST_OFFSET	(0x64UL)
+#define ID_REV_OFFSET		(0x50UL)
+
+#define CpuToPhysicalAddr(cpuAddr) ((DWORD)cpuAddr)
+
+DWORD Platform_Initialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwLanBase, DWORD dwBusWidth)
+{
+	DWORD dwIdRev=0;
+	SMSC_TRACE("--> Platform_Initialize");
+	SMSC_ASSERT(platformData!=NULL);
+	platformData->dwBitWidth=0;
+
+	if(dwLanBase==0x0UL) {
+		dwLanBase=PLATFORM_CSBASE;
+	}
+
+	SMSC_TRACE("Lan Base at 0x%08lX",dwLanBase);
+
+	platformData->dwBitWidth=16;
+
+	dwIdRev=(*(volatile unsigned long *)(dwLanBase+ID_REV_OFFSET));
+	platformData->dwIdRev = dwIdRev;
+
+	SMSC_TRACE("<-- Platform_Initialize");
+	return dwLanBase;
+}
+
+void Platform_CleanUp(
+	PPLATFORM_DATA platformData)
+{
+}
+
+BOOLEAN Platform_Is16BitMode(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	if (platformData->dwBitWidth == 16) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+BOOLEAN Platform_RequestIRQ(
+	PPLATFORM_DATA platformData,
+	DWORD dwIrq,
+	irqreturn_t (*pIsr)(int,void *,struct pt_regs *),
+	void * dev_id)
+{
+	SMSC_ASSERT(platformData != NULL);
+	SMSC_ASSERT(platformData->dev_id == NULL);
+	if (request_irq(
+		dwIrq,
+		pIsr,
+		SA_INTERRUPT,
+		"SMSC_LAN9118_ISR",
+		dev_id) != 0)
+	{
+		SMSC_WARNING("Unable to use IRQ = %ld", dwIrq);
+		return FALSE;
+	}
+	platformData->dwIrq = dwIrq;
+	platformData->dev_id = dev_id;
+	return TRUE;
+}
+
+DWORD Platform_CurrentIRQ(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	return platformData->dwIrq;
+}
+
+void Platform_FreeIRQ(
+	PPLATFORM_DATA platformData)
+{
+	SMSC_ASSERT(platformData != NULL);
+	SMSC_ASSERT(platformData->dev_id != NULL);
+
+	free_irq(platformData->dwIrq, platformData->dev_id);
+
+	platformData->dwIrq = 0;
+	platformData->dev_id = NULL;
+}
+
+void Platform_CacheInvalidate(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes)
+{
+	__flush_invalidate_region((void *)pStartAddress, (dwLengthInBytes));
+}
+
+void Platform_CachePurge(
+	PPLATFORM_DATA platformData,
+	const void * const pStartAddress,
+	const DWORD dwLengthInBytes)
+{
+	__flush_purge_region((void *)pStartAddress, (dwLengthInBytes));
+}
+
+void Platform_GetFlowControlParameters(
+	PPLATFORM_DATA platformData,
+	PFLOW_CONTROL_PARAMETERS flowControlParameters,
+	BOOLEAN useDma)
+{
+	memset(flowControlParameters,0,sizeof(FLOW_CONTROL_PARAMETERS));
+	flowControlParameters->BurstPeriod=100;
+	flowControlParameters->IntDeas=0;
+	if(useDma) {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,16 bit,DMA
+				flowControlParameters->MaxThroughput=(0xEAF0CUL);
+				flowControlParameters->MaxPacketCount=(0x282UL);
+				flowControlParameters->PacketCost=(0xC2UL);
+				flowControlParameters->BurstPeriod=(0x66UL);
+				flowControlParameters->IntDeas=(40UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,16 bit,DMA
+				flowControlParameters->MaxThroughput=0xB3A3CUL;
+				flowControlParameters->MaxPacketCount=0x1E6UL;
+				flowControlParameters->PacketCost=0xF4UL;
+				flowControlParameters->BurstPeriod=0x26UL;
+				flowControlParameters->IntDeas=40UL;
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			/* st40 DMA now only support 16-bit, not 32-bit */
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,32 bit,DMA
+				flowControlParameters->MaxThroughput=(0xC7F82UL);
+				flowControlParameters->MaxPacketCount=(0x21DUL);
+				flowControlParameters->PacketCost=(0x17UL);
+				flowControlParameters->BurstPeriod=(0x1EUL);
+				flowControlParameters->IntDeas=(0x17UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,32 bit,DMA
+				flowControlParameters->MaxThroughput=0xABE0AUL;
+				flowControlParameters->MaxPacketCount=0x1D1UL;
+				flowControlParameters->PacketCost=0x00UL;
+				flowControlParameters->BurstPeriod=0x30UL;
+				flowControlParameters->IntDeas=0x0A;
+				break;
+			default:break;//make lint happy
+			}
+		}
+	} else {
+		if(Platform_Is16BitMode(platformData)) {
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,16 bit,PIO
+				flowControlParameters->MaxThroughput=(0xA0C9EUL);
+				flowControlParameters->MaxPacketCount=(0x1B3UL);
+				flowControlParameters->PacketCost=(0x1C4UL);
+				flowControlParameters->BurstPeriod=(0x5CUL);
+				flowControlParameters->IntDeas=(60UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,16 bit,PIO
+				flowControlParameters->MaxThroughput=(0x76A6AUL);
+				flowControlParameters->MaxPacketCount=(0x141UL);
+				flowControlParameters->PacketCost=(0x11AUL);
+				flowControlParameters->BurstPeriod=(0x77UL);
+				flowControlParameters->IntDeas=(70UL);
+				break;
+			default:break;//make lint happy
+			}
+		} else {
+			/* st40 PIO now only support 16-bit, not 32-bit */
+			switch(platformData->dwIdRev&0xFFFF0000) {
+			case 0x01180000UL:
+			case 0x01170000UL:
+			case 0x01120000UL:
+				//117/118,32 bit,PIO
+				flowControlParameters->MaxThroughput=(0xAE5C8UL);
+				flowControlParameters->MaxPacketCount=(0x1D8UL);
+				flowControlParameters->PacketCost=(0UL);
+				flowControlParameters->BurstPeriod=(0x57UL);
+				flowControlParameters->IntDeas=(0x14UL);
+				break;
+			case 0x01160000UL:
+			case 0x01150000UL:
+				//115/116,32 bit,PIO
+				flowControlParameters->MaxThroughput=(0x9E338UL);
+				flowControlParameters->MaxPacketCount=(0x1ACUL);
+				flowControlParameters->PacketCost=(0xD2UL);
+				flowControlParameters->BurstPeriod=(0x60UL);
+				flowControlParameters->IntDeas=(0x0EUL);
+				break;
+			default:break;//make lint happy
+			}
+		}
+	}
+}
+
+#if 0
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	volatile DWORD *pdwReg;
+	pdwReg = (volatile DWORD *)(dwLanBase+TX_DATA_FIFO);
+	while(dwDwordCount)
+	{
+		*pdwReg = *pdwBuf++;
+		dwDwordCount--;
+	}
+}
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	const volatile DWORD * const pdwReg =
+		(const volatile DWORD * const)(dwLanBase+RX_DATA_FIFO);
+
+	while (dwDwordCount)
+	{
+		*pdwBuf++ = *pdwReg;
+		dwDwordCount--;
+	}
+}
+#else
+#include <asm/io.h>
+void Platform_WriteFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	writesl(dwLanBase+TX_DATA_FIFO, pdwBuf, dwDwordCount);
+}
+void Platform_ReadFifo(
+	DWORD dwLanBase,
+	DWORD *pdwBuf,
+	DWORD dwDwordCount)
+{
+	readsl(dwLanBase+RX_DATA_FIFO, pdwBuf, dwDwordCount);
+}
+#endif
+
+#ifdef CONFIG_STB7100_FDMA
+#include "st40-shdma.c"
+#else
+#include "st40-gpdma.c"
+#endif
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/st40-gpdma.c linux-2.6.17.8-sh/drivers/net/smsc_911x/st40-gpdma.c
--- linux-2.6.17.8/drivers/net/smsc_911x/st40-gpdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/st40-gpdma.c	2006-08-23 13:29:45.331760000 +0100
@@ -0,0 +1,246 @@
+/*********/
+/* GPDMA */
+/*********/
+#define DMA_BASE_ADDR		0xB9161000UL
+#define DMA_CHAN_BASE_ADDR(n)	(DMA_BASE_ADDR + ((n + 1) * 0x100UL))
+#define DMA_VCR_STATUS		(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x00UL))
+#define DMA_VCR_VERSION		(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x08UL))
+#define DMA_GLOBAL_ENABLE	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x10UL))
+#define DMA_GLOBAL_DISABLE	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x18UL))
+#define DMA_GLOBAL_STATUS	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x20UL))
+#define DMA_GLOBAL_INTERRUPT	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x28UL))
+#define DMA_GLOBAL_ERROR	(*(volatile unsigned long *)(DMA_BASE_ADDR + 0x30UL))
+#define DMA_CHAN_ID(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n)))
+#define DMA_CHAN_ENABLE(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x08UL))
+#define DMA_CHAN_DISABLE(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x10UL))
+#define DMA_CHAN_STATUS(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x18UL))
+#define DMA_CHAN_ACTION(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x20UL))
+#define DMA_CHAN_POINTER(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x28UL))
+#define DMA_CHAN_REQUEST(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x30UL))
+#define DMA_CHAN_CONTROL(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x80UL))
+#define DMA_CHAN_COUNT(n)	(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x88UL))
+#define DMA_CHAN_SAR(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x90UL))
+#define DMA_CHAN_DAR(n)		(*(volatile unsigned long *)(DMA_CHAN_BASE_ADDR(n) + 0x98UL))
+
+/* DMAC bitmasks */
+#define DMA_GLOBAL_ENABLE_CHAN_(n)		(0x00000001UL << n)
+#define DMA_GLOBAL_DISABLE_CHAN_(n)		(0x00000001UL << n)
+#define DMA_CHAN_ENABLE_CHAN_			0x00000001UL
+#define DMA_CHAN_DISABLE_ALL_			0x0000003FUL
+#define DMA_CHAN_CONTROL_FREE_RUNNING_		0x00000000UL
+#define DMA_CHAN_CONTROL_TRIGGER_		0x00000001UL
+#define DMA_CHAN_CONTROL_PACED_SOURCE_		0x00000002UL
+#define DMA_CHAN_CONTROL_PACED_DESTINATION_	0x00000003UL
+#define DMA_CHAN_CONTROL_NO_LINK_LIST_		0x00000000UL
+#define DMA_CHAN_CONTROL_FINAL_LINK_ELEM_	0x00000000UL
+#define DMA_CHAN_CONTROL_LINK_ELEM_		0x00000080UL
+#define DMA_CHAN_CONTROL_SRC_TYPE_CONST_	0x00000000UL
+#define DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_	0x00010000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_2BYTES_	0x00080000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_4BYTES_	0x00100000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_	0x00280000UL
+#define DMA_CHAN_CONTROL_DST_TYPE_CONST_	0x00000000UL
+#define DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_	0x01000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_2BYTES_	0x08000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_4BYTES_	0x10000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_32BYTES_	0x28000000UL
+#define DMA_CHAN_ACTION_COMPLETE_ACK_		0x00000002UL
+#define DMA_CHAN_STATUS_COMPLETE_		0x00000002UL
+#define DMA_CHAN_REQUEST0			0x0
+#define DMA_CHAN_REQUEST1			0x1
+#define DMA_CHAN_REQUEST2			0x2
+#define DMA_CHAN_REQUEST3			0x3
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{
+	/* for sh4/st40 only use channels 1-4, do not use channel 0 */
+	if((dwDmaCh >= 1) && (dwDmaCh <= 4)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+BOOLEAN Platform_DmaDisable(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	DMA_CHAN_ACTION(dwDmaCh) = DMA_CHAN_ACTION_COMPLETE_ACK_;
+
+	// Disable DMA controller
+	DMA_CHAN_DISABLE(dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+	return TRUE;
+}
+
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData)
+{
+	return TRANSFER_PIO;
+}
+
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel)
+{
+	//since Platform_RequestDmaChannel
+	//  never returns a dma channel
+	//  then this function should never be called
+	SMSC_ASSERT(FALSE);
+}
+
+BOOLEAN Platform_IsDmaComplete(
+	const DWORD dwDmaCh)
+{
+	// channel is disable
+	if ((DMA_CHAN_ENABLE(dwDmaCh) &  DMA_CHAN_ENABLE_CHAN_) == 0UL)
+		return TRUE;
+	if ((DMA_CHAN_STATUS(dwDmaCh) & DMA_CHAN_STATUS_COMPLETE_) != 0UL) {
+		Platform_DmaDisable ((PPLATFORM_DATA) 0, dwDmaCh);
+		return TRUE;
+	}
+	else
+		return FALSE;
+}
+
+void Platform_DmaComplete(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	DWORD dwTimeOut = 1000000;
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	// channel is disable
+	if ((DMA_CHAN_ENABLE(dwDmaCh) &  DMA_CHAN_ENABLE_CHAN_) == 0UL)
+		return;
+
+	while((dwTimeOut) && ((DMA_CHAN_STATUS(dwDmaCh) & DMA_CHAN_STATUS_COMPLETE_) == 0UL))
+	{
+		udelay(1);
+		dwTimeOut--;
+	}
+	Platform_DmaDisable(platformData, dwDmaCh);
+	if(dwTimeOut == 0)
+	{
+		SMSC_WARNING("Platform_DmaComplete: Timed out");
+	}
+}
+
+DWORD Platform_DmaGetDwCnt(
+	PPLATFORM_DATA platformData,
+	const DWORD dwDmaCh)
+{
+	DWORD dwCount;
+
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh));
+	if (Platform_IsDmaComplete(dwDmaCh) == TRUE)
+		return 0UL;
+	else {
+		dwCount = DMA_CHAN_COUNT(dwDmaCh);
+		if (dwCount)
+			return dwCount;
+		else
+			return 1UL;
+	}
+}
+
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh)
+{
+	SMSC_ASSERT(Platform_IsValidDmaChannel(dwDmaCh))
+
+	DMA_CHAN_DISABLE(dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+	DMA_CHAN_COUNT(dwDmaCh) = 0;
+	DMA_GLOBAL_ENABLE = DMA_GLOBAL_ENABLE_CHAN_(dwDmaCh);
+	DMA_CHAN_STATUS(dwDmaCh) = 0UL;		/* no request outstanding */
+	DMA_CHAN_ACTION(dwDmaCh) = DMA_CHAN_ACTION_COMPLETE_ACK_;
+	DMA_CHAN_REQUEST(dwDmaCh) = (dwDmaCh & 3);	/* req# == chan# */
+
+	SMSC_TRACE("Platform_DmaInitialize -- initialising channel %ld", dwDmaCh);
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_CHANn_ENABLE=0x%08lX", DMA_CHAN_ENABLE(dwDmaCh));
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_CHANn_COUNT=0x%08lX", DMA_CHAN_COUNT(dwDmaCh));
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_GLOBAL_ENABLE=0x%08lX", DMA_GLOBAL_ENABLE);
+	SMSC_TRACE("Platform_DmaInitialize -- DMA_ERROR=0x%08lX", DMA_GLOBAL_ERROR);
+
+	return TRUE;
+}
+
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwSrcAddr, dwDestAddr;
+	DWORD dwAlignMask, dwControlRegister;
+	DWORD dwLanPhysAddr, dwMemPhysAddr;
+
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// 2. make sure the channel's not already running
+	if (DMA_CHAN_COUNT(pDmaXfer->dwDmaCh) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg);
+	dwMemPhysAddr = 0x1fffffffUL & CpuToPhysicalAddr((void *)pDmaXfer->pdwBuf);
+
+	// 4. validate the address alignments
+	// need CL alignment for CL bursts
+	dwAlignMask = (PLATFORM_CACHE_LINE_BYTES - 1UL);
+
+	if ((dwLanPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwLanPhysAddr (0x%08lX) alignment", dwLanPhysAddr);
+		return FALSE;
+	}
+
+	if ((dwMemPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwMemPhysAddr (0x%08lX) alignment", dwMemPhysAddr);
+		return FALSE;
+	}
+
+	// 6. Config Control reg
+	// Disable the selected channel first
+	DMA_CHAN_DISABLE(pDmaXfer->dwDmaCh) = DMA_CHAN_DISABLE_ALL_;
+
+	// Select correct ch and set SRC, DST and counter
+	dwControlRegister = DMA_CHAN_CONTROL_FREE_RUNNING_ |
+		DMA_CHAN_CONTROL_NO_LINK_LIST_ |
+		DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_ |
+		DMA_CHAN_CONTROL_DST_UNIT_32BYTES_;
+
+	if (pDmaXfer->fMemWr == TRUE)
+	{
+		dwSrcAddr = dwLanPhysAddr;
+		dwDestAddr = dwMemPhysAddr;
+		dwControlRegister |= (DMA_CHAN_CONTROL_SRC_TYPE_CONST_ | DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_);
+	}
+	else
+	{
+		dwSrcAddr = dwMemPhysAddr;
+		dwDestAddr = dwLanPhysAddr;
+		dwControlRegister |= (DMA_CHAN_CONTROL_DST_TYPE_CONST_ | DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_);
+	}
+
+	// Set Source and destination addresses
+	DMA_CHAN_SAR(pDmaXfer->dwDmaCh) = dwSrcAddr;
+	DMA_CHAN_DAR(pDmaXfer->dwDmaCh) = dwDestAddr;
+
+	// Set the transmit size in terms of the xfer mode
+	DMA_CHAN_CONTROL(pDmaXfer->dwDmaCh) = dwControlRegister;
+	DMA_CHAN_COUNT(pDmaXfer->dwDmaCh) = (pDmaXfer->dwDwCnt << 2);
+
+	// Enable DMA controller ch x
+	DMA_CHAN_ENABLE(pDmaXfer->dwDmaCh) = DMA_CHAN_ENABLE_CHAN_;
+
+	// DMA Transfering....
+	return TRUE;
+}
+
diff -Naur linux-2.6.17.8/drivers/net/smsc_911x/st40-shdma.c linux-2.6.17.8-sh/drivers/net/smsc_911x/st40-shdma.c
--- linux-2.6.17.8/drivers/net/smsc_911x/st40-shdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/smsc_911x/st40-shdma.c	2006-08-23 13:29:46.781783000 +0100
@@ -0,0 +1,117 @@
+#include <asm/dma.h>
+
+BOOLEAN Platform_IsValidDmaChannel(DWORD dwDmaCh)
+{
+	if ((dwDmaCh >= 0) && (dwDmaCh < TRANSFER_PIO))
+		return TRUE;
+	return FALSE;
+}
+
+DWORD Platform_RequestDmaChannel(
+	PPLATFORM_DATA platformData)
+{
+	int chan;
+	chan = request_dma(ANY_CHANNEL, "smsc911x");
+	if (chan < 0)
+		return TRANSFER_PIO;
+	return chan;
+}
+
+void Platform_ReleaseDmaChannel(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaChannel)
+{
+	free_dma(dwDmaChannel);
+}
+
+BOOLEAN Platform_DmaInitialize(
+	PPLATFORM_DATA platformData,
+	DWORD dwDmaCh)
+{
+	return TRUE;
+}
+
+static void err_cb(void* x)
+{
+	SMSC_TRACE("DMA completion callback");
+}
+
+BOOLEAN Platform_DmaStartXfer(
+	PPLATFORM_DATA platformData,
+	const DMA_XFER * const pDmaXfer,
+	void (*pCallback)(void*),
+	void* pCallbackData)
+{
+	DWORD dwAlignMask;
+	DWORD dwLanPhysAddr, dwMemPhysAddr;
+        struct dma_channel *chan;
+	int res;
+
+
+	// 1. validate the requested channel #
+	SMSC_ASSERT(Platform_IsValidDmaChannel(pDmaXfer->dwDmaCh))
+
+	// 2. make sure the channel's not already running
+	if (get_dma_residue(pDmaXfer->dwDmaCh) != 0)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- requested channel (%ld) is still running", pDmaXfer->dwDmaCh);
+		return FALSE;
+	}
+
+	// 3. calculate the physical transfer addresses
+	dwLanPhysAddr = CpuToPhysicalAddr((void *)pDmaXfer->dwLanReg);
+	dwMemPhysAddr = 0x1fffffffUL & CpuToPhysicalAddr((void *)pDmaXfer->pdwBuf);
+
+	// 4. validate the address alignments
+	// need CL alignment for CL bursts
+	dwAlignMask = (PLATFORM_CACHE_LINE_BYTES - 1UL);
+
+	if ((dwLanPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwLanPhysAddr (0x%08lX) alignment", dwLanPhysAddr);
+		return FALSE;
+	}
+
+	if ((dwMemPhysAddr & dwAlignMask) != 0UL)
+	{
+		SMSC_WARNING("Platform_DmaStartXfer -- bad dwMemPhysAddr (0x%08lX) alignment", dwMemPhysAddr);
+		return FALSE;
+	}
+
+	// 5. Prepare the DMA channel structure
+	chan = get_dma_channel(pDmaXfer->dwDmaCh);
+	BUG_ON(IS_ERR(chan));
+
+	chan->mode = MODE_FREERUNNING;
+	chan->count = pDmaXfer->dwDwCnt << 2;
+	chan->comp_callback = pCallback;
+	chan->comp_callback_param = pCallbackData;
+	chan->err_callback = err_cb;
+	chan->flags = LIST_TYPE_UNLINKED | DMA_SETUP_NOBLOCK; //  | NODE_DONE_ISR;
+	chan->list_len = 1;
+
+        if (pDmaXfer->fMemWr) {
+		/* From LAN to memory */
+                chan->flags |= DIM_2_x_1;
+                chan->sar = PHYSADDR(dwLanPhysAddr);
+		chan->dar = PHYSADDR(dwMemPhysAddr);
+                chan->src_sz = 0x20;
+                chan->sstride = 0;
+        } else {
+		/* From memory to LAN */
+                chan->flags |= DIM_1_x_2;
+		chan->sar = PHYSADDR(dwMemPhysAddr);
+                chan->dar = PHYSADDR(dwLanPhysAddr);
+                chan->dst_sz = 0x20;
+                chan->dstride = 0;
+        }
+
+	res = dma_configure_channel(chan);
+	BUG_ON(res != 0);
+
+	// 6. Start the transfer
+	dma_xfer(pDmaXfer->dwDmaCh);
+
+	// DMA Transfering....
+	return TRUE;
+}
diff -Naur linux-2.6.17.8/drivers/net/stb7109eth.c linux-2.6.17.8-sh/drivers/net/stb7109eth.c
--- linux-2.6.17.8/drivers/net/stb7109eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/stb7109eth.c	2006-08-23 13:29:50.455875000 +0100
@@ -0,0 +1,1935 @@
+/* ============================================================================
+ * This is a driver for the STB7109 on-chip Ethernet controller.
+ *
+ * Copyright (C) 2006 by  Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * ----------------------------------------------------------------------------
+ * Driver internals:
+ *	The driver is initialized through the platform_device mechanism.
+ *	Structures which define the configuration needed by the board
+ *	are defined in a internal structure (for example in the
+ *	"arch/sh/boards/st/stb7100mboard/setup.c" file).
+ *
+ *	The STb7109 Ethernet Controller uses two ring of buffer
+ * 	descriptors for handling the transmission and the reception processes.
+ *
+ *	Receive process:
+ *  		When one or more packets are received, an interrupt
+ *  		happens. Note that the interrupts are not queued so the driver
+ *		must scan all the descriptors, from the last recorded to the
+ *		first one owned by the DMA controller.
+ *  		In NAPI, the interrupt handler will signal there is work to be
+ *		done, and exit.  Without NAPI, the packet(s) will be handled
+ *  		at once.
+ *  		The incoming packets are stored, by the DMA, in a big chunk of
+ *  		pre-allocated memory. Finally, a new skb is allocated and
+ *		the frame is sent to the kernel.
+ *
+ *	Transmit process:
+ *		When the kernel requests that a packet be transmitted, the
+ *  		the xmit function is invoked by the kernel. The skb is
+ *		copied in the socket buffer list. Then the relative descriptor
+ *		fields in the DMA tx ring is set. Finally, the driver
+ *  		informs the DMA engine that there are packets ready to
+ *  		be transmitted.  Once the controller is finished transmitting
+ *  		the packet, an interrupt is triggered so the driver will be
+ *  		able to clean the descriptor used and releas the socket buffer
+ *		allocated.
+ *
+ * ----------------------------------------------------------------------------
+ * Kernel Command line arguments:
+ *	- stb7109eth=<msg_level>,<watchdog>,<pause_time>
+ *		where:
+ *		 - <msg_level>: message level (0: no output, 16:  all).
+ *		 - <watchdog>:  transmit timeout (in milliseconds).
+ *		 - <pause_time>: flow-control pause time (0-65535).
+ *		NOTE: you must use the , as delimiter.
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *   June 2006:
+ *	- Reviewed and improved the transmit algorithm.
+ *	- Added the NAPI support (as experimental code).
+ * 	- Added a new debug option. Now during the kernel configuration phase
+ * 	  you can enable the complete debug level for the driver
+ *	  (including the debug messages for the critical functions i.e. the
+ *	  interrupt handler).
+ *   May 2006:
+ * 	- Separated out the PHY code.
+ *   April 2006:
+ *	- Partially removed the STe101p MII interface code.
+ *	- The DMA Rx/Tx functions has been re-written.
+ *	- Removed the PnSEGADDR and PHYSADDR SH4 macros and added the
+ *	  Dynamic DMA mapping support.
+ *	- Removed the DMA buffer size parameter. It has been fixed to the
+ *	  maximum value. Moreover, the driver will only use a single buffer
+ *	  in the DMA because an ethernet frame can be stored in it.
+ *	- Fixed some part in the ethtool support.
+ *	- Added the 802.1q VLAN support.
+ *   March 2006:
+ * 	- First release of the driver.
+ * ----------------------------------------------------------------------------
+ * Known bugs:
+ *	- The two-level VLAN tag is not supported yet.
+ *	- The NETPOLL support is not fully tested.
+ * ---
+ *	https://bugzilla.stlinux.com
+ * ===========================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+#include <linux/dma-mapping.h>
+
+#include "stb7109eth.h"
+
+/* Generic defines */
+#define RESOURCE_NAME	"stb7109eth"
+#ifdef CONFIG_7109ETH_DEBUG
+#define ETHPRINTK(nlevel, klevel, fmt, args...) \
+		(void)(netif_msg_##nlevel(lp) && \
+		printk(KERN_##klevel fmt, ## args))
+#else
+#define ETHPRINTK(nlevel, klevel, fmt, args...)  do { } while(0)
+#endif
+
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#define SYSCONF_BASE 		0xb9001000
+#define SYSCONF_DEVICEID        (SYSCONF_BASE + 0x000)
+#endif
+#define DEFAULT_PBL_VALUE	32
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame. */
+struct synopsys_dma_des_t {
+	unsigned int  des0; /* Status */
+	unsigned int  des1; /* Ctrl bits, Buffer 2 length, Buffer 1 length */
+	void *des2; /* Buffer 1 Address Pointer */
+	void *des3; /* Buffer 2 Address Pointer or the next Descriptor*/
+};
+
+typedef struct synopsys_dma_des_t synopsys_dma_des;
+
+#define DMA_BUFFER_SIZE	0x800
+
+struct eth_driver_local {
+        int speed;
+	unsigned int mac_enable;
+	unsigned int ip_header_len;
+        struct mii_if_info mii;
+	struct dev_mc_list *dmi;
+	struct net_device_stats stats;
+	u32 msg_enable;
+        spinlock_t lock;
+	synopsys_dma_des *dma_tx; /* virtual DMA TX addr */
+	synopsys_dma_des *cur_tx; /* next free descriptor in the DMA ring */
+	synopsys_dma_des *dirty_tx;/* Tx entry to be freed. */
+	unsigned int skb_curtx;	/* next skb free */
+	unsigned int skb_dirtytx; /* socket buffer to be freed at interrupt
+				     time*/
+	dma_addr_t dma_tx_phy;	   /* bus DMA TX addr */
+	struct sk_buff *tx_skb[CONFIG_DMA_TX_SIZE];
+  	synopsys_dma_des *dma_rx; /* virtual DMA RX addr */
+	dma_addr_t dma_rx_phy;	  /* bus DMA RX addr */
+	dma_addr_t rx_mem_phy;
+	int rx_pos; /* last position of the frame recorded the Rx dma ring*/
+	unsigned int rx_buff; /*it contains the last rx buf owned by the DMA*/
+	void *rx_mem;
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	struct vlan_group *vlgrp;
+#endif
+};
+
+/* Module Arguments */
+#define TX_TIMEO (5*HZ)
+static int watchdog = TX_TIMEO;
+module_param(watchdog, int, S_IRUGO);
+MODULE_PARM_DESC(watchdog, "Transmit Timeout (in milliseconds)");
+
+static int debug = -1; /* -1: use default, 0: no output, 16:  all */
+module_param(debug, int, S_IRUGO|S_IWUGO);
+MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
+
+#define MAX_PAUSE_TIME (MAC_FLOW_CONTROL_PT_MASK>>MAC_FLOW_CONTROL_PT_SHIFT)
+static int pause_time = MAX_PAUSE_TIME;
+module_param(pause_time, int, S_IRUGO|S_IWUGO);
+MODULE_PARM_DESC(flowctrl, "pause time");
+
+static const char version[] = "stb7109eth - (C) STM 2006\n";
+
+static const u32 default_msg_level = NETIF_MSG_DRV |NETIF_MSG_PROBE|
+				     NETIF_MSG_LINK |NETIF_MSG_IFUP|
+				     NETIF_MSG_IFDOWN|NETIF_MSG_TIMER;
+
+static irqreturn_t stb7109eth_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs);
+#ifndef CONFIG_7109ETH_NAPI
+static int stb7109eth_rx (struct net_device *dev);
+#else
+static int stb7109eth_poll(struct net_device *dev, int *budget);
+#endif
+
+static void stb7109eth_check_mod_params(struct net_device *dev)
+{
+	if (watchdog < 0) {
+		watchdog = TX_TIMEO;
+		printk (KERN_WARNING "\tWARNING: invalid tx timeout "
+				     "(default is %d)\n", watchdog);
+	}
+
+	if ((pause_time <= 0) || (pause_time >= MAX_PAUSE_TIME))
+		pause_time = MAX_PAUSE_TIME;
+
+	return;
+}
+
+static inline void print_mac_addr(u8 addr[6])
+{
+	int i;
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", addr[i]);
+	printk("%2.2x\n", addr[5]);
+	return;
+}
+
+#ifdef CONFIG_7109ETH_DEBUG
+static void print_pkt(unsigned char *buf, int len)
+{
+	int j;
+	printk("len = %d byte, buf addr: 0x%p", len, buf);
+	for (j=0; j<len; j++) {
+		if ((j%16) == 0)
+			printk("\n %03x:", j);
+		printk(" %02x", buf[j]);
+	}
+	printk("\n");
+	return;
+}
+#endif
+
+/* The PBL indicates the maximum number of DWORDs to be transferred in one DMA
+ * transaction.
+ * It seems that the Programmable Burst Length bit in the CSR0 must be set to 1
+ * for the Stb7109 CUT 1.x and to 32 for the CUT 2.x. */
+static int fix_pbl_value(void)
+{
+	unsigned long sysconf;
+
+	sysconf = ctrl_inl(SYSCONF_DEVICEID);
+	if (((sysconf >> 28) & 0xF) == 0)
+		return (1);
+	else if (((sysconf >> 28) & 0xF) == 1)
+		return (DEFAULT_PBL_VALUE);
+}
+
+#define SYSCONF_SYS_CFG(n)      (SYSCONF_BASE + 0x100 + ((n) * 4))
+#define MAC_SPEED_SEL		0x00100000 /* MAC is running at 100 Mbps */
+void fix_mac_speed(unsigned int speed)
+{
+#ifdef CONFIG_STE101P_RMII
+        unsigned long sysconf = ctrl_inl(SYSCONF_SYS_CFG(7));
+
+        if (speed == SPEED_100)
+                sysconf |= MAC_SPEED_SEL;
+        else if (speed == SPEED_10)
+                sysconf &= ~MAC_SPEED_SEL;
+
+	printk (KERN_DEBUG  "fix_mac_speed: speed = %d, sysconf7 = 0x%x\n",
+				           speed, (unsigned int) sysconf);
+
+	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
+#endif
+        return;
+}
+
+/* ----------------------------------------------------------------------------
+				 MII Interface
+   ---------------------------------------------------------------------------*/
+/*  Read data from the MII register from within the specified phy device,
+ *  arguments:
+ *	phyaddr: MII addr reg bits 15-11
+ *	phyreg: MII addr reg bits 10-6
+ */
+int stb7109_mii_read (struct net_device *dev, int phyaddr, int phyreg)
+{
+	unsigned long ioaddr=dev->base_addr;
+	u16 regValue=(((phyaddr << 11)&(0x0000F800))|
+		      ((phyreg<<6)&(0x000007C0)));
+
+	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	writel(regValue, ioaddr+MAC_MII_ADDR);
+
+	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* Read the data from the MII data register */
+	return ((u16)(readl(ioaddr+MAC_MII_DATA) & 0xFFFF));
+}
+
+/* Writes the data intto the MII register from within the specified device */
+void stb7109_mii_write(struct net_device *dev, int phyaddr, int phyreg,
+		       int phydata)
+{
+	unsigned long ioaddr=dev->base_addr;
+	u16 value=(((phyaddr<<11)&(0x0000F800))|((phyreg<<6)&(0x000007C0)))|
+			MAC_MII_ADDR_WRITE;
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* Set the MII address register to write */
+	writel(phydata, ioaddr+MAC_MII_DATA);
+	writel(value, ioaddr+MAC_MII_ADDR);
+
+	/* Wait until any existing MII operation is complete */
+	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+
+	/* NOTE: we need to perform this "extra" read in order to fix an error
+	 * during the write operation */
+	stb7109_mii_read(dev, phyaddr, phyreg);
+	return;
+}
+
+void stb7109eth_set_mac_mii_cap(struct mii_if_info mii, unsigned int speed,
+				struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int flow=(unsigned int) readl(ioaddr+MAC_FLOW_CONTROL),
+		     ctrl=(unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	printk (KERN_DEBUG "%s\n", __FUNCTION__);
+
+	lp->mii = mii;
+	lp->speed = speed;
+
+	if (!(mii.full_duplex)) { /* Half Duplex */
+		flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
+			  MAC_FLOW_CONTROL_PCF);
+		ctrl &= ~MAC_CONTROL_F;
+		ctrl |= MAC_CONTROL_DRO;
+
+	} else {  /* Full Duplex */
+		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
+			(pause_time << MAC_FLOW_CONTROL_PT_SHIFT);
+		ctrl |= MAC_CONTROL_F;
+		ctrl &= ~MAC_CONTROL_DRO;
+	}
+
+	writel(flow, ioaddr+MAC_FLOW_CONTROL);
+	writel(ctrl, ioaddr+MAC_CONTROL);
+
+	fix_mac_speed(lp->speed);
+
+	return;
+}
+
+EXPORT_SYMBOL(stb7109eth_set_mac_mii_cap);
+EXPORT_SYMBOL(stb7109_mii_read);
+EXPORT_SYMBOL(stb7109_mii_write);
+
+/* ----------------------------------------------------------------------------
+				 MAC CORE Interface
+   ---------------------------------------------------------------------------*/
+/* Print the MAC CSR registers */
+static inline void dump_synopsys_mac_csr(unsigned long ioaddr)
+{
+	printk ("\t----------------------------------------------\n"
+		"\t STb7109eth MAC CSR (base addr = 0x%8x)\n"
+		"\t----------------------------------------------\n",
+		(unsigned int)ioaddr);
+	printk ("\tcontrol reg (offset 0x%x): 0x%lx\n", MAC_CONTROL,
+			readl(ioaddr+MAC_CONTROL));
+	printk ("\taddr HI (offset 0x%x): 0x%lx\n ", MAC_ADDR_HIGH,
+			readl(ioaddr+MAC_ADDR_HIGH));
+	printk ("\taddr LO (offset 0x%x): 0x%lx\n", MAC_ADDR_LOW,
+			readl(ioaddr+MAC_ADDR_LOW));
+	printk ("\tmulticast hash HI (offset 0x%x): 0x%lx\n", MAC_HASH_HIGH,
+			readl(ioaddr+MAC_HASH_HIGH));
+	printk ("\tmulticast hash LO (offset 0x%x): 0x%lx\n", MAC_HASH_LOW,
+			readl(ioaddr+MAC_HASH_LOW));
+	printk ("\tflow control (offset 0x%x): 0x%lx\n", MAC_FLOW_CONTROL,
+			readl(ioaddr+MAC_FLOW_CONTROL));
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	printk ("\tVLAN1 tag (offset 0x%x): 0x%lx\n", MAC_VLAN1,
+			readl(ioaddr+MAC_VLAN1));
+	printk ("\tVLAN2 tag (offset 0x%x): 0x%lx\n", MAC_VLAN2,
+			readl(ioaddr+MAC_VLAN2));
+#endif
+	printk ("\tmac wakeup frame (offset 0x%x): 0x%lx\n", MAC_WAKEUP_FILTER,
+			readl(ioaddr+MAC_WAKEUP_FILTER));
+	printk ("\tmac wakeup crtl (offset 0x%x): 0x%lx\n",
+			MAC_WAKEUP_CONTROL_STATUS,
+			readl(ioaddr+MAC_WAKEUP_CONTROL_STATUS));
+
+	printk ("\n\tMAC management counter registers\n");
+	printk ("\t MMC crtl (offset 0x%x): 0x%lx\n",
+			MMC_CONTROL, readl(ioaddr+MMC_CONTROL));
+	printk ("\t MMC High Interrupt (offset 0x%x): 0x%lx\n",
+			MMC_HIGH_INTR, readl(ioaddr+MMC_HIGH_INTR));
+	printk ("\t MMC Low Interrupt (offset 0x%x): 0x%lx\n",
+			MMC_LOW_INTR, readl(ioaddr+MMC_LOW_INTR));
+	printk ("\t MMC High Interrupt Mask (offset 0x%x): 0x%lx\n",
+			MMC_HIGH_INTR_MASK, readl(ioaddr+MMC_HIGH_INTR_MASK));
+	printk ("\t MMC Low Interrupt Mask (offset 0x%x): 0x%lx\n",
+			MMC_LOW_INTR_MASK, readl(ioaddr+MMC_LOW_INTR_MASK));
+	return;
+}
+
+/* Set the hardware MAC address */
+static void set_synopsys_mac_addr(unsigned long ioaddr, u8 Addr[6])
+{
+	unsigned long data;
+
+	data = (Addr[5]<<8) | Addr[4];
+        writel(data, ioaddr+MAC_ADDR_HIGH );
+        data = (Addr[3]<<24) | (Addr[2]<<16) | (Addr[1]<<8) | Addr[0];
+        writel(data, ioaddr+MAC_ADDR_LOW);
+
+	return;
+}
+
+/* Get the hardware MAC address  */
+static void get_synopsys_mac_address(unsigned long ioaddr, unsigned char *addr)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = (unsigned int) readl(ioaddr+MAC_ADDR_HIGH);
+	lo_addr = (unsigned int) readl(ioaddr+MAC_ADDR_LOW);
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xff;
+	addr[1] = (lo_addr >>  8) & 0xff;
+	addr[2] = (lo_addr >> 16) & 0xff;
+	addr[3] = (lo_addr >> 24) & 0xff;
+	addr[4] = hi_addr & 0xff;
+	addr[5] = (hi_addr >>  8) & 0xff;
+
+	return;
+}
+
+static void synopsys_mac_enable(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	ETHPRINTK(probe, DEBUG, "%s: MAC RX/TX enabled\n", RESOURCE_NAME);
+
+	/* set: TE (transmitter enable, bit 3), RE (receive enable, bit 2)
+	   and RA (receive all mode, bit 31) */
+	value |= (MAC_CONTROL_RA|MAC_CONTROL_TE|MAC_CONTROL_RE);
+	writel(value, ioaddr+MAC_CONTROL);
+	lp->mac_enable = 1;
+	return;
+}
+
+static void synopsys_mac_disable(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned long ioaddr=dev->base_addr;
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+
+	ETHPRINTK(probe, DEBUG, "%s: MAC RX/TX disabled\n", RESOURCE_NAME);
+
+	value &= ~(MAC_CONTROL_RA|MAC_CONTROL_TE|MAC_CONTROL_RE);
+	writel(value, ioaddr+MAC_CONTROL);
+	lp->mac_enable = 0;
+	return;
+}
+
+/* This function provides the initial setup of the MAC controller */
+static void synopsys_mac_core_init(struct net_device *dev)
+{
+	unsigned int value = 0;
+	unsigned long ioaddr=dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	/* Set the MAC control register with our default value */
+        value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+        value |= MAC_CONTROL_HBD | MAC_CONTROL_PM;
+        writel(value, ioaddr+MAC_CONTROL);
+
+	/* Check the MAC address*/
+	printk(KERN_INFO "STb7109eth: MAC Core setup:\n"
+			      "\tHW MAC address: ");
+	get_synopsys_mac_address(ioaddr, dev->dev_addr);
+	print_mac_addr(dev->dev_addr);
+
+        if (!is_valid_ether_addr(dev->dev_addr)) {
+                printk (KERN_WARNING "\tno valid MAC address; "
+				    "please, set using ifconfig!\n");
+        }
+
+	/* Change the MAX_FRAME bits in the MMC control register. */
+	value = dev->mtu + lp->ip_header_len + 4 /*fsc*/;
+	writel(((value << MMC_CONTROL_MAX_FRM_SHIFT) &
+		MMC_CONTROL_MAX_FRM_MASK), dev->base_addr+MMC_CONTROL);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	writel(ETH_P_8021Q, dev->base_addr+MAC_VLAN1);
+#endif
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+ *  			DESCRIPTORS functions
+ * ---------------------------------------------------------------------------*/
+static void display_dma_desc_ring(synopsys_dma_des *p, int size)
+{
+	int i;
+	for (i=0; i<size; i++)
+		printk ("\t%d [0x%x]: "
+			"desc0=0x%x desc1=0x%x buffer1=0x%x\n", i,
+			(unsigned int) virt_to_phys(&p[i].des0), p[i].des0,
+			p[i].des1, (unsigned int)p[i].des2);
+}
+
+static void init_desc_owner (synopsys_dma_des *head, unsigned int size,
+			    unsigned int owner)
+{
+	int i;
+	synopsys_dma_des *p = head;
+
+	for (i=0; i<size; i++) {
+		p->des0 = owner;
+		p++;
+	}
+	return;
+}
+
+static void init_dma_ring(synopsys_dma_des *p, dma_addr_t phy,
+			  unsigned int ring_size, unsigned int own_bit)
+{
+	int i;
+	for (i=0; i<ring_size; i++) {
+		p->des0 = own_bit;
+		p->des1 = (!(own_bit) ? 0 :
+			  ((DMA_BUFFER_SIZE-1)<<DES1_RBS1_SIZE_SHIFT));
+		if (i == ring_size-1) {
+			p->des1 |= DES1_CONTROL_TER;
+		}
+		p->des2 = (!(own_bit)?0:((void *)(phy+(i*DMA_BUFFER_SIZE))));
+		p->des3 = NULL;
+		p++;
+	}
+	return;
+}
+
+/* Allocate and init the TX and RX descriptors rings.
+ * The driver uses the 'implicit' scheme for implementing the TX/RX DMA
+ * linked lists. */
+static void init_dma_desc_rings(struct net_device *dev)
+{
+	int i;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int rx_mem_size = (CONFIG_DMA_RX_SIZE*DMA_BUFFER_SIZE);
+
+	ETHPRINTK(probe, DEBUG,"%s: allocate and init the DMA RX/TX lists\n",
+			    RESOURCE_NAME);
+
+	/* Allocate memory for the DMA RX/TX buffer descriptors */
+	lp->dma_rx = (synopsys_dma_des *) dma_alloc_coherent(NULL,
+		 CONFIG_DMA_RX_SIZE*sizeof(struct synopsys_dma_des_t),
+		 &lp->dma_rx_phy, GFP_KERNEL);
+
+	lp->dma_tx = (synopsys_dma_des *) dma_alloc_coherent(NULL,
+		 CONFIG_DMA_TX_SIZE*sizeof(struct synopsys_dma_des_t),
+		 &lp->dma_tx_phy, GFP_KERNEL);
+
+	if ((lp->dma_rx == NULL)||(lp->dma_tx == NULL)) {
+		printk(KERN_ERR "%s:ERROR allocating the DMA Tx/Rx desc\n",
+			__FUNCTION__);
+		return;
+	}
+
+	ETHPRINTK(probe, DEBUG, "%s: DMA desc rings: virt addr (Rx 0x%08x, "
+		"Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
+		dev->name, (unsigned int)lp->dma_rx ,(unsigned int)lp->dma_tx,
+		(unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
+
+	/* The frames received will be put in 'lp->rx_mem'. In fact the
+	 * buffer in each descriptor will point to the relative position
+	 * in this chunk of memory. */
+	lp->rx_mem = (void *) dma_alloc_coherent(NULL,rx_mem_size,
+		 &lp->rx_mem_phy, GFP_KERNEL);
+
+	memset(lp->rx_mem, 0, rx_mem_size);
+
+	ETHPRINTK(probe, DEBUG, "%s: DMA RX mem: virt addr=0x%08x, "
+			        "phy addr=0x%08x, len=%d\n",
+				 __FUNCTION__, (unsigned int)lp->rx_mem,
+				 (unsigned int)lp->rx_mem_phy, rx_mem_size);
+
+	init_dma_ring(lp->dma_rx, lp->rx_mem_phy, CONFIG_DMA_RX_SIZE, OWN_BIT);
+	init_dma_ring(lp->dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
+
+	if (netif_msg_hw(lp)) {
+		printk (" - RX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
+		printk (" - TX descriptor ring:\n");
+		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+	}
+
+	/* Init the transmit socket buffers */
+	for (i=0;i < CONFIG_DMA_TX_SIZE;i++)
+		lp->tx_skb[i] = NULL;
+
+	/* Initialize some TX variables */
+        lp->dirty_tx = lp->cur_tx = lp->dma_tx;
+        lp->skb_curtx = lp->skb_dirtytx = 0;
+    return;
+}
+
+/* Release and free the descriptor resources. */
+static void free_dma_desc_resources(struct net_device *dev)
+{
+	unsigned int rx_mem_size = (CONFIG_DMA_RX_SIZE*DMA_BUFFER_SIZE);
+
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	dma_free_coherent(NULL,
+		CONFIG_DMA_TX_SIZE*sizeof(struct synopsys_dma_des_t),
+		lp->dma_tx, lp->dma_tx_phy);
+	dma_free_coherent(NULL,
+		CONFIG_DMA_RX_SIZE*sizeof(struct synopsys_dma_des_t),
+		lp->dma_rx, lp->dma_rx_phy);
+	dma_free_coherent(NULL, rx_mem_size, lp->rx_mem, lp->rx_mem_phy);
+
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+				DMA FUNCTIONS
+ * ---------------------------------------------------------------------------*/
+static inline void dump_dma_csr(unsigned long ioaddr)
+{
+	int i;
+	printk ("\t--------------------\n"
+		"\t STb7109eth DMA CSR \n"
+		"\t--------------------\n");
+	for (i = 0; i<9; i++) {
+		printk ("\t CSR%d (offset 0x%x): 0x%lx\n", i,
+			(DMA_BUS_MODE + i*4), readl(ioaddr+DMA_BUS_MODE + i*4));
+	}
+	printk ("\t CSR20 (offset 0x%x): 0x%lx\n",
+		DMA_CUR_TX_BUF_ADDR, readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
+	printk ("\t CSR21 (offset 0x%x): 0x%lx\n",
+		DMA_CUR_RX_BUF_ADDR, readl(ioaddr+DMA_CUR_RX_BUF_ADDR));
+	return;
+}
+
+/* DMA SW reset.
+ *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
+ *	   SW reset otherwise the MAC core won't exit the reset state.
+ *  NOTE2: after a SW reset all interrupts are disabled */
+static void synopsys_dma_reset(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value=(unsigned int)readl(ioaddr+DMA_BUS_MODE);
+	value|= DMA_BUS_MODE_SFT_RESET;
+
+	writel(value, ioaddr+DMA_BUS_MODE);
+
+	while ((readl(ioaddr+DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {}
+
+	return;
+}
+
+/* START/STOP the DMA TX/RX processes */
+static void synopsys_dma_start_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |= DMA_CONTROL_ST ;
+	writel(value, ioaddr+DMA_CONTROL);
+
+	return;
+}
+
+static void synopsys_dma_stop_tx(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |=  ~DMA_CONTROL_ST;
+	writel(value, ioaddr+DMA_CONTROL);
+
+	return;
+}
+
+static void stb7109eth_stop_tx(struct net_device *dev)
+{
+	int i;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	synopsys_dma_stop_tx(dev->base_addr);
+
+	for (i=0;i < CONFIG_DMA_TX_SIZE;i++)
+		if (lp->tx_skb[i] != NULL)
+			dev_kfree_skb_any(lp->tx_skb[i]);
+
+	init_desc_owner(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
+
+	return;
+}
+
+static void synopsys_dma_start_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |= DMA_CONTROL_SR ;
+	writel(value, ioaddr+DMA_CONTROL);
+
+	return;
+}
+
+static void synopsys_dma_stop_rx(unsigned long ioaddr)
+{
+	unsigned int value;
+
+	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value |=  ~DMA_CONTROL_SR;
+	writel(value, ioaddr+DMA_CONTROL);
+
+	return;
+}
+
+/* The DMA init function performs:
+ * - the DMA RX/TX SW descriptors initialization
+ * - the DMA HW controller initialization
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
+static int synopsys_dma_init(struct net_device *dev)
+{
+	unsigned int value;
+	unsigned long ioaddr = dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ETHPRINTK(probe, DEBUG, "STb7109eth: DMA Core setup\n");
+
+	/* DMA SW reset */
+	synopsys_dma_reset(ioaddr);
+
+	/* Enable Application Access by writing to DMA CSR0 */
+	value = fix_pbl_value();
+	writel(DMA_BUS_MODE_DEFAULT | (value << DMA_BUS_MODE_PBL_SHIFT) ,
+	       ioaddr+DMA_BUS_MODE);
+
+	/* Mask interrupts by writing to CSR7 */
+	writel(DMA_INTR_DEFAULT_MASK, ioaddr+DMA_INTR_ENA);
+
+	/* The base address of the RX/TX descriptor lists must be written into
+	 * DMA CSR3 and CSR4, respectively. */
+	writel((unsigned long)lp->dma_tx_phy,ioaddr+DMA_TX_BASE_ADDR);
+	writel((unsigned long)lp->dma_rx_phy,ioaddr+DMA_RCV_BASE_ADDR);
+
+	if (netif_msg_hw(lp))
+		dump_dma_csr(ioaddr);
+
+	return (0);
+}
+
+#ifdef CONFIG_7109ETH_DEBUG
+/* Transmit Process State for CSR5[22:20] */
+static void show_tx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
+
+	printk(KERN_DEBUG" DMA tx status: \n");
+	switch (state) {
+	   case 0: printk(KERN_DEBUG " -TX (Stopped): Reset or Stop command\n");
+	   	   break;
+	   case 1: printk(KERN_DEBUG " -TX (Running):Fetching the Tx desc\n");
+	   	   break;
+	   case 2: printk(KERN_DEBUG " -TX (Running): Waiting for end of tx\n");
+	   	   break;
+	   case 3: printk(KERN_DEBUG " -TX (Running): Reading the data "
+				    "and queuing the data into the Tx buf\n");
+	   	   break;
+	   case 6: printk(KERN_DEBUG " -TX (Suspended): Tx Buff Underflow "
+				    "or an unavailable Transmit descriptor\n");
+	   	   break;
+	   case 7: printk(KERN_DEBUG " -TX (Running): Closing Tx descriptor\n");
+	   	   break;
+	   default:
+	   	   break;
+	   }
+	return;
+}
+
+/* Receive Process State for CSR5[19:17] */
+static void show_rx_process_state(unsigned int status)
+{
+	unsigned int state;
+	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
+
+	printk(KERN_DEBUG" DMA rx status: \n");
+	switch (state) {
+	   case 0: printk(KERN_DEBUG " -RX (Stopped): Reset or Stop command\n");
+	   	   break;
+	   case 1: printk(KERN_DEBUG " -RX (Running): Fetching the Rx desc\n");
+	   	   break;
+	   case 2: printk(KERN_DEBUG" -RX (Running):Checking for end of pkt\n");
+	   	   break;
+	   case 3: printk(KERN_DEBUG " -RX (Running): Waiting for Rx pkt\n");
+	   	   break;
+	   case 4: printk(KERN_DEBUG " -RX (Suspended): Unavailable Rx buf\n");
+	   	   break;
+	   case 5: printk(KERN_DEBUG " -RX (Running): Closing Rx descriptor\n");
+	   	   break;
+	   case 6: printk(KERN_DEBUG" - RX(Running): Flushing the current frame"
+				    " from the Rx buf\n");
+	   	   break;
+	   case 7: printk(KERN_DEBUG " -RX (Running): Queuing the Rx frame"
+				    " from the Rx buf into memory\n");
+	   	   break;
+	   default:
+	   	   break;
+	}
+	return;
+}
+#endif
+
+/* When the transmission is completed the frame status is written into
+ * TDESC0 of the descriptor having the LS bit set.
+ * This function returns zero if no error is happened during the transmission.*/
+static int check_tx_error_summary(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	synopsys_dma_des *p = lp->dirty_tx;
+
+	/* The TDES0 of the LS segment will contain the frame
+	   status */
+	while (!(p->des1 & TDES1_CONTROL_LS))
+		p++;
+
+	ETHPRINTK(intr, INFO,"[0x%x] TDES0: 0x%x\n", (unsigned int)p, p->des0);
+
+	if (p->des0 & TDES0_STATUS_DF) {
+		ETHPRINTK(tx_err, WARNING,"%s: DMA tx: deferred error\n",
+				RESOURCE_NAME);
+		goto out_error;
+	}
+	if (p->des0 & TDES0_STATUS_HRTBT_FAIL) {
+		ETHPRINTK(tx_err, WARNING, "%s: DMA tx: Heartbeat Fail\n",
+					RESOURCE_NAME);
+		lp->stats.tx_heartbeat_errors++;
+		goto out_error;
+	}
+
+	if (p->des0 & TDES0_STATUS_ES) {
+		ETHPRINTK(tx_err, ERR,  "%s: DMA tx ERROR: ", RESOURCE_NAME);
+
+		if (p->des0 & TDES0_STATUS_UF) {
+			ETHPRINTK(tx_err, ERR, "Underflow Error\n");
+			goto out_error;
+		}
+		if (p->des0 & TDES0_STATUS_EX_DEF){
+			ETHPRINTK(tx_err, ERR, "Ex Deferrals\n");
+			goto set_collision;
+		}
+		if (p->des0 & TDES0_STATUS_EX_COL) {
+			ETHPRINTK(tx_err, ERR, "Ex Collisions\n");
+			goto set_collision;
+		}
+		if (p->des0 & TDES0_STATUS_LATE_COL) {
+			ETHPRINTK(tx_err, ERR, "Late Collision\n");
+			goto set_collision;
+		}
+		if (p->des0 & TDES0_STATUS_NO_CARRIER){
+			ETHPRINTK(tx_err, ERR, "No Carrier\n");
+			goto out_error;
+		}
+		if (p->des0 & TDES0_STATUS_LOSS_CARRIER) {
+			ETHPRINTK(tx_err, ERR, "Loss of Carrier\n");
+			goto out_error;
+		}
+	}
+
+	return (0);
+
+set_collision:
+	lp->stats.collisions +=((p->des0 & TDES0_STATUS_COLCNT_MASK)>>
+		TDES0_STATUS_COLCNT_SHIFT);
+out_error:
+	lp->stats.tx_errors++;
+
+	return (-1);
+}
+
+/* When a frame is received the status is written into TDESC0 of the descriptor
+ * having the LS bit set. */
+static int check_rx_error_summary(struct eth_driver_local *lp,
+			          unsigned int status)
+{
+	if (status & RDES0_STATUS_ES) {
+		ETHPRINTK(rx_err, ERR, "%s: DMA rx ERROR: ", RESOURCE_NAME);
+		if (status & RDES0_STATUS_DE)
+			ETHPRINTK(rx_err, ERR, "descriptor error\n");
+		if (status & RDES0_STATUS_PFE)
+			ETHPRINTK(rx_err, ERR, "partial frame error\n");
+		if (status & RDES0_STATUS_RUNT_FRM)
+			ETHPRINTK(rx_err, ERR, "runt Frame\n");
+		if (status & RDES0_STATUS_TL)
+			ETHPRINTK(rx_err, ERR, "frame too long\n");
+		if (status & RDES0_STATUS_COL_SEEN) {
+			ETHPRINTK(rx_err, ERR, "collision seen\n");
+			lp->stats.collisions++;
+		}
+		if (status & RDES0_STATUS_CE)
+			ETHPRINTK(rx_err, ERR, "CRC Error\n");
+
+		lp->stats.rx_errors++;
+
+		return (-EINVAL);
+	}
+	return (0);
+}
+
+/* Get the last frame position in the Rx DMA ring */
+static inline void get_rx_last_frame_pos(struct  eth_driver_local *lp)
+{
+	lp->rx_pos = ((lp->rx_buff-lp->rx_mem_phy)/(DMA_BUFFER_SIZE))-1;
+	return;
+}
+
+
+static void synopsys_dma_tx_irq(struct net_device *dev)
+{
+	struct  eth_driver_local *lp = netdev_priv(dev);
+
+#ifdef CONFIG_7109ETH_DEBUG
+        if (netif_msg_tx_done(lp)) {
+                printk(">> TX done: next tx desc=0x%x, desc used=0x%x "
+                  "(free the skb #%d, next skb free #%d)\n",
+                  (unsigned int)lp->cur_tx, (unsigned int)lp->dirty_tx,
+                  lp->skb_dirtytx, lp->skb_curtx);
+                printk ("    TX descriptor ring:\n");
+                display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+        }
+#endif
+
+	/* If the lp->dirty_tx and the lp->cur_tx are the same, the Tx ring
+	 * could be either empty or full (only in the beginning).  */
+	if ((lp->dirty_tx == lp->cur_tx) && (netif_queue_stopped(dev) == 0))
+                        return;
+
+	check_tx_error_summary(dev);
+	lp->stats.tx_packets++;
+
+	/* Release the Tx resources */
+	(lp->dirty_tx)->des1 =
+                   ((lp->dirty_tx)->des1 & DES1_CONTROL_TER)?DES1_CONTROL_TER:0;
+	dma_unmap_single(NULL, (lp->dirty_tx)->des2,
+                         lp->tx_skb[lp->skb_dirtytx]->len, DMA_TO_DEVICE);
+	(lp->dirty_tx)->des2 = NULL;
+
+	/* Free the sk buffer associated with this descriptor */
+	if (lp->tx_skb[lp->skb_dirtytx] != NULL) {
+	        dev_kfree_skb_irq(lp->tx_skb[lp->skb_dirtytx]);
+	        lp->tx_skb[lp->skb_dirtytx] = NULL;
+	}
+
+        lp->skb_dirtytx = (lp->skb_dirtytx + 1) % CONFIG_DMA_TX_SIZE;
+	if ((lp->dirty_tx)->des1 & DES1_CONTROL_TER)
+		lp->dirty_tx = lp->dma_tx;
+	else
+		lp->dirty_tx++;
+
+	/* We freed a buffer, so now we can restart transmission */
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	return;
+}
+
+/*
+ *  --- Interrupt handler for the MAC110 DMA
+ *
+ * It determines if we have to call either the Rx or the Tx interrupt handler.
+ * Numerous events can cause an interrupt: a new packet has arrived
+ * or transmission is completed or an error occurred).
+ * The CSR5 contains all the bits can cause an interrupt while the CSR7
+ * contains an enable bit for each of them. There are two groups of interrupts:
+ *  - normal
+ *  - abnormal (as outlined in the CSR5)
+ *  Note: we won't use the Early interrupts (disabled in the DMA_INTR_ENA). */
+static void synopsys_dma_interrupt(struct net_device *dev)
+{
+	unsigned int status;
+	struct  eth_driver_local *lp = netdev_priv(dev);
+
+	/* read the status register (CSR5) */
+	status = (unsigned int)readl(dev->base_addr+DMA_STATUS);
+	lp->rx_buff = (unsigned int)readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
+
+	ETHPRINTK(intr, INFO, "%s: (%s) [CSR5: 0x%08x]\n", RESOURCE_NAME,
+			      "DMA IRQ", status);
+
+#ifdef CONFIG_7109ETH_DEBUG
+	if (netif_msg_tx_done(lp))
+		show_tx_process_state(status);
+	if (netif_msg_rx_status(lp))
+		show_rx_process_state(status);
+#endif
+	/* Process the NORMAL interrupts */
+	if (status & DMA_STATUS_NIS) {
+		ETHPRINTK(intr, INFO, " CSR5[16]: DMA NORMAL IRQ: ");
+		if (status & DMA_STATUS_TI) {
+			ETHPRINTK(tx_done, INFO, "CSR5[0] Transmit interrupt"
+			" [next buf: %lx]\n",
+	          	readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR));
+			synopsys_dma_tx_irq(dev);
+		}
+		/*  CSR5[2] Transmit Buffer Unavailable the next desc in the TX
+		    list cannot be aquired by the DMA controller */
+		if (status & DMA_STATUS_TU) {
+			ETHPRINTK (intr, INFO, "Transmit Buffer Unavailable\n");
+		/*	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);*/
+		}
+		/* CSR5[6] Receive interrupt: it indicates the completition
+		   of the frame reception. */
+		if (status & DMA_STATUS_RI) {
+			lp->rx_buff = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
+			ETHPRINTK(intr,INFO,"Receive Interrupt [buf: 0x%08x\n]",
+					     lp->rx_buff);
+
+#ifndef CONFIG_7109ETH_NAPI
+			stb7109eth_rx(dev);
+#else
+			/* scheduling dev->poll */
+			synopsys_dma_stop_rx(dev->base_addr);
+			if (netif_rx_schedule_prep(dev)) {
+				get_rx_last_frame_pos(lp);
+	                	__netif_rx_schedule(dev);
+	        	} else {
+				ETHPRINTK (intr, DEBUG,"%s: bug!!! "
+				  "interrupt while in poll.\n", __FUNCTION__);
+        		}
+#endif
+		}
+		if (status & DMA_STATUS_ERI) {
+#if 0
+			ETHPRINTK(intr,INFO,"Early Receive Interrupt\n");
+			status |= DMA_STATUS_RI;
+			stb7109eth_rx(dev);
+#endif
+		}
+	}
+	/* Process the ABNORMAL interrupts */
+	if (status & DMA_STATUS_AIS) {
+		ETHPRINTK (intr, INFO,"CSR5[15] DMA ABNORMAL IRQ: ");
+		if (status & DMA_STATUS_TPS) {
+			ETHPRINTK (intr, INFO,"Transmit Process Stopped \n");
+			synopsys_dma_start_tx(dev->base_addr);
+		}
+		if (status & DMA_STATUS_TJT){
+			ETHPRINTK (intr, INFO,"Transmit Jabber Timeout\n");
+			synopsys_dma_start_tx(dev->base_addr);
+		}
+		if (status & DMA_STATUS_OVF) {
+			ETHPRINTK (intr, INFO,"Receive Overflow\n");
+		}
+		if (status & DMA_STATUS_UNF) {
+			ETHPRINTK (intr, INFO,"Transmit Underflow\n");
+			writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
+		}
+		if (status & DMA_STATUS_RU){
+			ETHPRINTK (intr, INFO,"Rx Buffer Unavailable\n");
+#if 0
+			init_desc_owner(lp->dma_rx, CONFIG_DMA_RX_SIZE,OWN_BIT);
+			writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
+#endif
+		}
+		if (status & DMA_STATUS_RPS){
+			ETHPRINTK (intr, INFO,"Receive Process Stopped\n");
+			synopsys_dma_start_rx(dev->base_addr);
+		}
+		if (status & DMA_STATUS_RWT){
+			ETHPRINTK (intr, INFO,"Rx Watchdog Timeout\n");
+		}
+		if (status & DMA_STATUS_ETI){
+			ETHPRINTK (intr, INFO,"Early Tx Interrupt\n");
+			/*status |= DMA_STATUS_TI;*/
+		}
+		if (status & DMA_STATUS_FBI){
+			ETHPRINTK (intr, INFO,"Fatal Bus Error Interrupt\n");
+		}
+	}
+	ETHPRINTK (intr, INFO,"\n\n");
+
+	/* Clear the interrupt by writing a logic 1 to the relative bits */
+	writel(status, dev->base_addr+DMA_STATUS);
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+			      DEVICE METHODS
+   ---------------------------------------------------------------------------*/
+int stb7109eth_open(struct net_device *dev)
+{
+	struct  eth_driver_local *lp = netdev_priv(dev);
+	int ret;
+
+       /* Request the IRQ lines */
+        if ( (ret = request_irq(dev->irq, &stb7109eth_interrupt,
+				SA_SHIRQ, dev->name, dev)) < 0 ) {
+		printk(KERN_ERR "%s: ERROR: allocating the IRQ %d "
+				"(return error: %d)\n", __FUNCTION__,
+							dev->irq, ret);
+                return (ret);
+	}
+
+	/* Check that the MAC address is valid.  If its not, refuse
+         * to bring the device up. The user must specify an
+         * address using the following linux command:
+	 * 	ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+        if (!is_valid_ether_addr(dev->dev_addr)) {
+                ETHPRINTK(probe, ERR, "%s: no valid eth hw addr\n",
+					__FUNCTION__);
+                return (-EINVAL);
+        }
+
+	/* Copy the MAC addr into the HW */
+	set_synopsys_mac_addr(dev->base_addr, dev->dev_addr);
+
+	/* Initialize the MAC110 Core */
+	synopsys_mac_core_init(dev);
+
+	/* Enable the MAC/DMA */
+	if (!lp->mac_enable)
+		synopsys_mac_enable(dev);
+
+	if (netif_msg_hw(lp))
+		dump_synopsys_mac_csr((unsigned int)dev->base_addr);
+
+	ETHPRINTK(probe, DEBUG, "%s: DMA RX/TX processes started...\n",
+				RESOURCE_NAME);
+
+	synopsys_dma_start_rx(dev->base_addr);
+	synopsys_dma_start_tx(dev->base_addr);
+
+	netif_start_queue(dev);
+	return (0);
+}
+
+int stb7109eth_release(struct net_device *dev)
+{
+	struct  eth_driver_local *lp = netdev_priv(dev);
+
+	printk (KERN_DEBUG "%s\n", __FUNCTION__);
+
+	/* Free the IRQ lines */
+	free_irq(dev->irq, dev);
+
+	/* Reset the TX/RX processes */
+	synopsys_dma_stop_rx(dev->base_addr);
+	stb7109eth_stop_tx(dev);
+
+	/* Disable the MAC core */
+	if (lp->mac_enable)
+		synopsys_mac_disable(dev);
+
+	/* Change the link status */
+        netif_carrier_off(dev);
+
+	return (0);
+}
+
+int stb7109eth_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	/* Point at the first free tx descriptor */
+	synopsys_dma_des *p = lp->cur_tx;
+
+	if (skb->len< ETH_ZLEN) {
+		skb = skb_padto(skb, ETH_ZLEN);
+		skb->len = ETH_ZLEN;
+        }
+
+	/* Handle the DMA TX descriptors */
+	p->des1 =((TDES1_CONTROL_IC | TDES1_CONTROL_FS | TDES1_CONTROL_LS) |
+	  	 ((p->des1 & DES1_CONTROL_TER) ? DES1_CONTROL_TER : 0)|
+		 ((skb->len<<DES1_RBS1_SIZE_SHIFT) & DES1_RBS1_SIZE_MASK));
+	p->des0 = OWN_BIT;
+	p->des2 = (synopsys_dma_des *) dma_map_single(NULL,
+			skb->data, skb->len, DMA_TO_DEVICE);
+/*
+	if (lp->tx_skb[lp->skb_curtx] != NULL)
+	        dev_kfree_skb(lp->tx_skb[lp->skb_curtx]);
+*/
+	/* Save the skb pointer so we can free it later */
+	lp->tx_skb[lp->skb_curtx] = skb;
+
+	/* Update the current skb position */
+	lp->skb_curtx = (lp->skb_curtx + 1) % CONFIG_DMA_TX_SIZE;
+
+	if (p->des1 & DES1_CONTROL_TER)
+		p = lp->dma_tx;
+	else
+		p++;
+	/* We need to tell the kernel to stop the transmission. */
+	if (p == lp->dirty_tx) {
+                netif_stop_queue(dev);
+                lp->stats.tx_fifo_errors++;
+        }
+
+#ifdef CONFIG_7109ETH_DEBUG
+        if (netif_msg_pktdata(lp)) {
+                printk("%s: tx desc used=0x%x; skb used #%d\n", __FUNCTION__,
+                        (unsigned int)lp->cur_tx, lp->skb_curtx);
+                print_pkt(skb->data ,skb->len);
+                printk ("TX descriptor ring:\n");
+                display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+        }
+#endif
+
+	/* Update the current tx pointer to the next one */
+	lp->cur_tx = p;
+
+	/* Update transmit stats */
+        lp->stats.tx_bytes += skb->len;
+
+	dev->trans_start = jiffies;
+
+	/* CSR1 enables the transmit DMA to check for new descriptor */
+	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
+
+	return (0);
+}
+
+/* If the NAPI support is enable the stb7109eth_poll method will be
+ * scheduled at interrupt time.
+ * Otherwise, the stb7109eth_rx(...) is the receive function processed
+ * by the regular interrupt handle.  */
+#ifdef CONFIG_7109ETH_NAPI
+static int stb7109eth_poll(struct net_device *dev, int *budget)
+#else
+static int  stb7109eth_rx (struct net_device *dev)
+#endif
+{
+	struct sk_buff *skb;
+	int j=0, frame_len = 0, pos;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	synopsys_dma_des *drx;
+#ifdef CONFIG_7109ETH_NAPI
+	int npackets = 0, quota = min(dev->quota, *budget);
+#else
+	/* we can do that here! */
+	get_rx_last_frame_pos(lp);
+#endif
+	pos = (lp->rx_pos < 0) ? (CONFIG_DMA_RX_SIZE-1) : lp->rx_pos;
+
+        while (j<CONFIG_DMA_RX_SIZE) {
+                int prec=((pos!=0)?(pos-1):(CONFIG_DMA_RX_SIZE-1));
+                if ((lp->dma_rx+prec)->des0 & OWN_BIT)
+                        break;
+                pos = prec;
+                j++;
+        }
+
+	drx = lp->dma_rx + pos;
+
+	ETHPRINTK (rx_status,DEBUG ,"%s: [dma current pos = %d, drx = 0x%x, "
+		  		    "pos=%d]\n", __FUNCTION__, lp->rx_pos,
+				    (unsigned int)drx, pos);
+
+	while (!(drx->des0 & OWN_BIT)) {
+		unsigned int status = drx->des0;
+#ifdef CONFIG_7109ETH_DEBUG
+		if (netif_msg_rx_status(lp)) {
+			printk ("RX descriptor ring:\n");
+			display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
+		}
+#endif
+#ifdef CONFIG_7109ETH_NAPI
+		if (npackets >= quota){
+			ETHPRINTK(rx_status,ERR,"%s: ERROR: out of Quota\n" ,
+				   __FUNCTION__);
+			break;
+		}
+#endif
+		/* Check if the frame was not successfully received */
+		if (check_rx_error_summary(lp, status) < 0) {
+			drx->des0=OWN_BIT;
+			continue;
+		}
+
+		/* update multicast stats */
+		if (status & RDES0_STATUS_MULTICST_FRM)
+			lp->stats.multicast++;
+
+		/* FL (frame length) indicates the length in byte including
+		 * the CRC */
+		frame_len=(status&RDES0_STATUS_FL_MASK)>>RDES0_STATUS_FL_SHIFT;
+
+		/* Allocate the socket buffer */
+		skb = dev_alloc_skb(frame_len + 2);
+		if (!skb) {
+			if (printk_ratelimit())
+				printk(KERN_NOTICE "%s: low memory, packet "
+					"dropped.\n", dev->name);
+			lp->stats.rx_dropped++;
+			drx->des0=OWN_BIT;
+			continue;
+		}
+
+		/* Align IP on 16 byte boundaries */
+		skb_reserve(skb, 2);
+
+		eth_copy_and_sum(skb, lp->rx_mem+(pos*DMA_BUFFER_SIZE),
+				 frame_len, 0);
+
+		/* release the descriptor */
+		drx->des0=OWN_BIT;
+
+		if (drx->des1 & DES1_CONTROL_TER)
+			pos = 0;
+		else
+			pos++;
+		drx = lp->dma_rx + pos;
+
+#ifdef CONFIG_7109ETH_DEBUG
+		if (netif_msg_pktdata(lp)){
+			printk ("%s: frame received ", __FUNCTION__);
+			print_pkt(skb->data, frame_len);
+		}
+#endif
+		/* write metadata, and pass to the receive level */
+		skb->dev = dev;
+		skb_put(skb, frame_len);
+		skb->protocol = eth_type_trans(skb, dev);
+		skb->ip_summed = CHECKSUM_NONE;
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += frame_len;
+		dev->last_rx = jiffies;
+#ifdef CONFIG_7109ETH_NAPI
+		npackets++;
+		netif_receive_skb(skb);
+#else
+		netif_rx(skb);
+#endif
+	}
+#ifdef CONFIG_7109ETH_NAPI
+	 /* All the packets in the DMA have been processed so we can
+	  * reenable the RX interrupt. */
+	*budget -= npackets;
+        dev->quota -= npackets;
+        netif_rx_complete(dev);
+	synopsys_dma_start_rx(dev->base_addr);
+#else
+	writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
+#endif
+        return 0;
+}
+
+/* This function is called when a packet transmission fails to complete
+ * within a reasonable period. The driver will mark the error in the
+ * netdev structure and arrange for the device to be reset to a sane state
+ * in order to transmit a new packet. */
+void stb7109eth_tx_timeout (struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ETHPRINTK(timer, INFO, "%s: Tx timeout at %ld, latency %ld\n",
+		dev->name, jiffies, jiffies - dev->trans_start);
+
+        if (netif_msg_tx_queued(lp)) {
+		printk (KERN_INFO "%s: DMA TX (cur_tx = 0x%x):\n",
+				  __FUNCTION__, (unsigned int)lp->cur_tx);
+		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
+	}
+
+	netif_stop_queue(dev);
+	stb7109eth_stop_tx(dev);
+	init_dma_ring(lp->dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
+	synopsys_dma_start_tx(dev->base_addr);
+	lp->stats.tx_errors++;
+	netif_start_queue(dev);
+	dev->trans_start = jiffies;
+
+	return;
+}
+
+/* Return statistics to the caller application */
+struct net_device_stats *stb7109eth_stats(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+	return &lp->stats;
+}
+
+/* Configuration changes (passed on by ifconfig) */
+int stb7109eth_config(struct net_device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP) /* can't act on a running interface */
+                return -EBUSY;
+
+        /* Don't allow changing the I/O address */
+        if (map->base_addr != dev->base_addr) {
+                printk(KERN_WARNING "%s: can't change I/O address\n",dev->name);
+                return -EOPNOTSUPP;
+        }
+
+        /* Don't allow changing the IRQ */
+        if (map->irq != dev->irq) {
+                printk(KERN_WARNING "%s: can't change IRQ number %d\n",
+					 dev->name, dev->irq);
+                return -EOPNOTSUPP;
+        }
+
+        /* ignore other fields */
+        return (0);
+}
+
+/* ---------------------------------------------------------------------------
+			Address Filtering Method
+   ---------------------------------------------------------------------------*/
+static void stb7109eth_set_rx_mode(struct net_device *dev)
+{
+	unsigned long ioaddr=dev->base_addr;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	u32 mc_filter[2]; /* Multicast hash filter */
+
+	printk(KERN_DEBUG "%s: mc_list=0x%x, mc_count=0x%x\n", __FUNCTION__,
+			      (unsigned int)dev->mc_list, dev->mc_count);
+
+	if (dev->flags & IFF_PROMISC) {
+		printk(KERN_DEBUG"%s: promiscuous mode enabled.\n",dev->name);
+		/* Promiscuous mode: set th PR bit in order to indicate
+		 * that all incoming frame are valid regardless of the
+		 * destination address.  */
+		value |= MAC_CONTROL_PR;
+		value &= ~(MAC_CONTROL_IF|MAC_CONTROL_HO);
+	} else if (dev->flags & IFF_ALLMULTI) {
+		printk(KERN_DEBUG "%s: pass all multicast mode enabled.\n",
+				  dev->name);
+		value |= MAC_CONTROL_PM;
+		value &= ~(MAC_CONTROL_PR|MAC_CONTROL_IF|MAC_CONTROL_HO);
+	} else {
+		if (dev->mc_count == 0) {
+			printk(KERN_DEBUG "%s: perfect filtering mode.\n",
+					  dev->name);
+			value &= ~(MAC_CONTROL_PM|MAC_CONTROL_PR|MAC_CONTROL_IF|
+				   MAC_CONTROL_HO|MAC_CONTROL_HP);
+			writel(0x0, ioaddr+MAC_HASH_HIGH);
+			writel(0x0, ioaddr+MAC_HASH_LOW);
+		} else {
+			/* MAC Addr Perfect Filtering for physical addresses
+			 * and Hash Filtering for Multicast addresses;
+		         * Pass Multicast frames if enabled. */
+			int i;
+			printk(KERN_DEBUG "%s: set Hash table for multicast "
+					  "addresses\n", dev->name);
+			mc_filter[1] = mc_filter[0] = 0;
+			for (i = 0, lp->dmi = dev->mc_list;
+			     lp->dmi && i < dev->mc_count;
+			     i++, lp->dmi = lp->dmi->next) {
+				int bit_nr = ether_crc(ETH_ALEN,
+						lp->dmi->dmi_addr) >> 26;
+				mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			}
+			writel(mc_filter[0], ioaddr+MAC_HASH_HIGH);
+			writel(mc_filter[1], ioaddr+MAC_HASH_LOW);
+
+			value |= MAC_CONTROL_HP;
+			value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |
+				   MAC_CONTROL_IF| MAC_CONTROL_HO);
+		}
+	}
+
+	writel(value, ioaddr+MAC_CONTROL);
+
+	if (netif_msg_hw(lp))
+		dump_synopsys_mac_csr((unsigned int)dev->base_addr);
+	return;
+}
+
+/* The Maximum Transfer Unit (MTU) is used by the network layer to
+ * drive packet transmission. Ethernet has an MTU of 1500 octets (ETH_DATA_LEN).
+ * This value can be changed with ifconfig.  */
+static int stb7109eth_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (netif_running(dev)) {
+                printk (KERN_ERR "%s: must be stopped to change its MTU\n",
+				 dev->name);
+                return -EBUSY;
+        }
+
+	if (new_mtu > ETH_DATA_LEN)
+                return -EINVAL;
+        dev->mtu = new_mtu;
+
+        return (0);
+}
+
+/* ---------------------------------------------------------------------------
+			REGULAR INTERRUPT FUNCTION
+   ---------------------------------------------------------------------------*/
+static irqreturn_t stb7109eth_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs)
+{
+	struct eth_driver_local *lp;
+	struct net_device *dev = (struct net_device *)dev_id;
+
+	if (!dev) {
+		printk (KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
+		return IRQ_NONE;
+	}
+        lp = netdev_priv(dev);
+
+	synopsys_dma_interrupt(dev);
+
+	return IRQ_HANDLED;
+}
+
+/* ---------------------------------------------------------------------------
+	          		NETPOLL SUPPORT
+   ---------------------------------------------------------------------------*/
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling receive - used by NETCONSOLE and other diagnostic tools
+ * to allow network I/O with interrupts disabled. */
+static void stb7109eth_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+        stb7109eth_interrupt(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
+
+/* ----------------------------------------------------------------------------
+	          		ETHTOOL SUPPORT
+   ---------------------------------------------------------------------------*/
+static void stb7109eth_ethtool_getdrvinfo(struct net_device *dev,
+				   struct ethtool_drvinfo*info)
+{
+        strcpy(info->driver, RESOURCE_NAME);
+        strncpy(info->version, version, sizeof(version));
+	strcpy(info->bus_info, "STBUS");
+	info->fw_version[0] = '\0';
+	return;
+}
+
+/* Restart autonegotiation */
+static int stb7109eth_ethtool_nwayreset(struct net_device *dev)
+{
+        int ret = -EINVAL;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	spin_lock(&lp->lock);
+	ret = mii_nway_restart(&lp->mii);
+	spin_unlock(&lp->lock);
+        return ret;
+}
+
+static int stb7109eth_ethtool_getsettings(struct net_device *dev,
+					  struct ethtool_cmd *cmd)
+{
+        struct eth_driver_local *lp = netdev_priv(dev);
+
+	if (!netif_running(dev)) {
+                printk(KERN_ERR "%s: interface is disabled: we cannot track "
+				   "link speed / duplex setting\n", dev->name);
+        	return -EBUSY;
+        }
+
+	cmd->port = PORT_MII;
+
+	cmd->supported = (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+		SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+		SUPPORTED_Autoneg | SUPPORTED_MII);
+
+	if (lp->speed == SPEED_10)
+		cmd->speed = SPEED_10;
+	else if (lp->speed == SPEED_100)
+		cmd->speed = SPEED_100;
+
+	if (!lp->mii.force_media)
+		cmd->autoneg = AUTONEG_DISABLE;
+	else
+		cmd->autoneg = AUTONEG_ENABLE;
+
+	cmd->advertising = lp->mii.advertising;
+
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->duplex = lp->mii.full_duplex ? DUPLEX_FULL : DUPLEX_HALF;
+	cmd->phy_address = lp->mii.phy_id;
+
+        return (0);
+}
+
+static int stb7109eth_ethtool_setsettings(struct net_device *dev,
+					  struct ethtool_cmd *cmd)
+{
+        struct eth_driver_local *lp = dev->priv;
+
+	return (mii_ethtool_sset(&lp->mii, cmd));
+}
+
+static u32 stb7109eth_ethtool_getmsglevel(struct net_device *dev)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+        return lp->msg_enable;
+}
+
+static void stb7109eth_ethtool_setmsglevel(struct net_device *dev, u32 level)
+{
+	struct eth_driver_local *lp = netdev_priv(dev);
+        lp->msg_enable = level;
+
+}
+
+static int stb7109eth_check_if_running(struct net_device *dev)
+{
+        if (!netif_running(dev))
+                return -EBUSY;
+        return (0);
+}
+
+#define REGDUMP_LEN         (32 * 1024)
+int stb7109eth_ethtool_get_regs_len(struct net_device *dev)
+{
+        return (REGDUMP_LEN);
+}
+
+static void stb7109eth_ethtool_gregs(struct net_device *dev,
+                               	     struct ethtool_regs *regs, void *space)
+{
+        int i;
+        u32 reg;
+        u32 *reg_space = (u32 *) space;
+
+	memset(reg_space, 0x0, REGDUMP_LEN);
+
+	/* MAC registers */
+        for (i = 0; i < 11; i++) {
+		reg = readl(dev->base_addr + i*4);
+                memcpy((reg_space + i*4), &reg, sizeof(u32));
+        }
+
+	/* DMA registers */
+	for (i = 0; i<9; i++) {
+		reg = readl(dev->base_addr+(DMA_BUS_MODE+i*4));
+		memcpy((reg_space + (DMA_BUS_MODE+i*4)), &reg,
+			sizeof(u32));
+	}
+	reg = readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_TX_BUF_ADDR), &reg, sizeof(u32));
+	reg = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
+	memcpy((reg_space + DMA_CUR_RX_BUF_ADDR), &reg, sizeof(u32));
+
+	return;
+}
+
+static struct ethtool_ops stb7109eth_ethtool_ops = {
+	.begin 		= stb7109eth_check_if_running,
+	.get_drvinfo    = stb7109eth_ethtool_getdrvinfo,
+	.nway_reset     = stb7109eth_ethtool_nwayreset,
+	.get_settings   = stb7109eth_ethtool_getsettings,
+	.set_settings   = stb7109eth_ethtool_setsettings,
+	.get_msglevel   = stb7109eth_ethtool_getmsglevel,
+	.set_msglevel   = stb7109eth_ethtool_setmsglevel,
+	.get_regs 	= stb7109eth_ethtool_gregs,
+	.get_regs_len 	= stb7109eth_ethtool_get_regs_len,
+	.get_link       = ethtool_op_get_link,
+};
+
+/* ----------------------------------------------------------------------------
+	            		VLAN SUPPORT
+   ---------------------------------------------------------------------------*/
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+static void stb7109eth_vlan_rx_register(struct net_device *dev,
+				    struct vlan_group *grp)
+{
+        struct eth_driver_local *lp = netdev_priv(dev);
+
+        spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: setting vlgrp to %p\n", dev->name, grp);
+        lp->vlgrp = grp;
+        stb7109eth_set_rx_mode(dev);
+        spin_unlock(&lp->lock);
+}
+
+static void stb7109eth_vlan_rx_add_vid(struct net_device *dev,
+				       unsigned short vid)
+{
+        struct eth_driver_local *lp = netdev_priv(dev);
+
+        spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: adding VLAN ID %d to VLAN filter\n",
+			  dev->name, vid);
+        stb7109eth_set_rx_mode(dev);
+        spin_unlock(&lp->lock);
+}
+static void stb7109eth_vlan_rx_kill_vid(struct net_device *dev,
+					unsigned short vid)
+{
+        struct eth_driver_local *lp = netdev_priv(dev);
+
+        spin_lock(&lp->lock);
+	printk(KERN_DEBUG "%s: removing VLAN ID %d from VLAN filter\n",
+			  dev->name, vid);
+        if (lp->vlgrp)
+                lp->vlgrp->vlan_devices[vid] = NULL;
+        stb7109eth_set_rx_mode(dev);
+        spin_unlock(&lp->lock);
+}
+#endif
+
+/* ----------------------------------------------------------------------------
+	           DEVICE REGISTRATION, INITIALIZATION AND UNLOADING
+   ---------------------------------------------------------------------------*/
+static int stb7109eth_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	int ret = 0;
+	struct eth_driver_local *lp = netdev_priv(dev);
+
+	ether_setup(dev);
+
+	dev->open = stb7109eth_open;
+	dev->stop = stb7109eth_release;
+	dev->set_config	= stb7109eth_config;
+	dev->hard_start_xmit = stb7109eth_hard_start_xmit;
+	dev->get_stats = stb7109eth_stats;
+	dev->tx_timeout	= stb7109eth_tx_timeout;
+	dev->watchdog_timeo = msecs_to_jiffies(watchdog);;
+	dev->set_multicast_list	= stb7109eth_set_rx_mode,
+	dev->change_mtu	= stb7109eth_change_mtu;
+        dev->ethtool_ops = &stb7109eth_ethtool_ops;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        dev->poll_controller = stb7109eth_poll_controller;
+#endif
+#ifdef CONFIG_7109ETH_NAPI
+	dev->poll = stb7109eth_poll;
+	dev->weight = CONFIG_DMA_RX_SIZE;
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+        dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
+        dev->vlan_rx_register = stb7109eth_vlan_rx_register;
+        dev->vlan_rx_add_vid  = stb7109eth_vlan_rx_add_vid;
+        dev->vlan_rx_kill_vid = stb7109eth_vlan_rx_kill_vid;
+#endif
+	/* network local structure default */
+        lp->mii.dev = dev;
+	lp->mii.force_media = 1;
+        lp->mii.full_duplex = 0;
+        lp->mii.mdio_read = stb7109_mii_read;
+        lp->mii.mdio_write = stb7109_mii_write;
+	lp->mii.advertising = 0;
+	lp->mac_enable = 0;
+	lp->msg_enable = netif_msg_init(debug, default_msg_level);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	lp->ip_header_len = VLAN_ETH_HLEN;
+#else
+	lp->ip_header_len = ETH_HLEN;
+#endif
+	/* Check the module arguments */
+	stb7109eth_check_mod_params(dev);
+
+	/* Set the I/O base addr */
+        dev->base_addr = ioaddr;
+	printk(KERN_INFO "\tI/O base addr: 0x%lx\n", dev->base_addr);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR "%s: ERROR %i registering the device\n",
+				__FUNCTION__, ret);
+		return (-ENODEV);
+	}
+
+	/* Create and initialize the TX/RX descriptors rings */
+	init_dma_desc_rings(dev);
+
+	/* Intialize the DMA controller and send the SW reset */
+	if (synopsys_dma_init(dev) < 0 ) {
+		ETHPRINTK(probe, ERR, "%s: DMA initialization failed\n",
+				__FUNCTION__);
+		return (-1);
+	}
+
+        spin_lock_init(&lp->lock);
+
+	return (ret);
+}
+
+static int stb7109eth_dvr_probe(struct device *dev)
+{
+	int ret = 0;
+        struct resource *res;
+	unsigned int *addr = NULL;
+	struct net_device *ndev = NULL;
+        struct platform_device *pdev = to_platform_device(dev);
+
+	printk(KERN_INFO "%s:\n\tplatform registration... ", __FUNCTION__);
+        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+                ret = -ENODEV;
+		goto out;
+        }
+	printk(KERN_INFO "done!\n");
+
+        if (!request_mem_region(res->start, (res->end - res->start),
+				RESOURCE_NAME)) {
+		printk(KERN_ERR "%s: ERROR: memory allocation failed"
+				"cannot get the I/O addr 0x%x\n",
+				__FUNCTION__, (unsigned int)res->start);
+                ret = -EBUSY;
+		goto out;
+        }
+
+	printk(KERN_INFO "\tmapping the I/O space (start=0x%x, size=0x%x)\n",
+			 (unsigned int)res->start,
+			 (unsigned int)(res->end - res->start));
+	addr = ioremap(res->start, (res->end - res->start));
+        if (!addr) {
+		printk(KERN_ERR "%s: ERROR: memory mapping failed \n",
+					__FUNCTION__);
+                ret = -ENOMEM;
+		goto out;
+        }
+
+	printk(KERN_INFO "\tnetwork device initialization... ");
+	ndev = alloc_etherdev(sizeof(struct eth_driver_local));
+	if (!ndev ) {
+		printk(KERN_ERR "%s: ERROR: allocating the device\n",
+					__FUNCTION__);
+		ret = -ENOMEM;
+		goto out;
+	}
+	printk(KERN_INFO "done!\n");
+
+	/* Get the IRQ number */
+	if ((ndev->irq = platform_get_irq(pdev,0)) == 0){
+		printk(KERN_ERR "%s: ERROR: IRQ configuration "
+				"information not found\n",__FUNCTION__);
+		ret = -ENODEV;
+		goto out;
+	}
+	printk(KERN_INFO "\tMAC IRQ number: %d\n", ndev->irq);
+	dev_set_drvdata(dev, ndev);
+
+	/* Network Device Registration */
+	ret = stb7109eth_probe(ndev, (unsigned long)addr);
+out:
+	if (ret < 0) {
+		dev_set_drvdata(dev, NULL);
+		release_mem_region(res->start, (res->end - res->start));
+		if (addr != NULL)
+			iounmap(addr);
+	}
+	return (ret);
+}
+
+static int stb7109eth_dvr_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct eth_driver_local *lp = netdev_priv(ndev);
+	struct resource *res;
+
+	/* Reset the TX/RX processes */
+	synopsys_dma_stop_rx(ndev->base_addr);
+	stb7109eth_stop_tx(ndev);
+
+	/* Disable the MAC core */
+	if (lp->mac_enable)
+		synopsys_mac_disable(ndev);
+
+	/* Change the link status */
+        netif_carrier_off(ndev);
+
+	/* Free the DMA descriptor rings */
+	free_dma_desc_resources(ndev);
+
+	dev_set_drvdata(dev, NULL);
+	unregister_netdev(ndev);
+
+	iounmap((void *)ndev->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, (res->end - res->start));
+
+	free_netdev(ndev);
+
+	return (0);
+}
+
+static struct device_driver stb7109eth_driver = {
+        .name           = RESOURCE_NAME,
+        .bus            = &platform_bus_type,
+        .probe          = stb7109eth_dvr_probe,
+        .remove         = stb7109eth_dvr_remove,
+};
+
+static int __init stb7109eth_init_module(void)
+{
+        printk(KERN_DEBUG "%s: register the device driver\n", __FUNCTION__);
+        return driver_register(&stb7109eth_driver);
+}
+
+static void __exit stb7109eth_cleanup_module(void)
+{
+        printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
+        driver_unregister(&stb7109eth_driver);
+}
+
+module_init(stb7109eth_init_module);
+module_exit(stb7109eth_cleanup_module);
+
+MODULE_DESCRIPTION("stb7109 Ethernet driver");
+MODULE_AUTHOR("Giuseppe Cavallaro");
+MODULE_LICENSE("GPL");
+
+/* --------------------------------------------------------------------------
+ * 		Parse the optional command line arguments
+ * --------------------------------------------------------------------------*/
+static int __init stb7109eth_parse_options(char *str)
+{
+	if (!str || !*str)
+		goto errout;
+
+	debug = simple_strtoul(str, &str, 10);
+	if (*str != ',')
+		goto out;
+
+	str++;
+	watchdog = simple_strtoul(str, &str, 10);
+	if (*str != ',')
+		goto out;
+
+        str++;
+        pause_time = simple_strtoul(str, &str, 10);
+        if (*str != ',')
+                goto out;
+
+out:
+	printk(KERN_DEBUG "%s: debug=%d, watchdog=%d, pause_time = %d\n",
+			  __FUNCTION__, debug, watchdog, pause_time);
+        return (0);
+
+errout:
+	return -EINVAL;
+}
+__setup("stb7109eth=", stb7109eth_parse_options);
diff -Naur linux-2.6.17.8/drivers/net/stb7109eth.h linux-2.6.17.8-sh/drivers/net/stb7109eth.h
--- linux-2.6.17.8/drivers/net/stb7109eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/stb7109eth.h	2006-08-23 13:29:48.630829000 +0100
@@ -0,0 +1,219 @@
+
+/*----------------------------------------------------------------------------
+ *	 			MAC BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* MAC CSR offset */
+#define MAC_CONTROL               0x00000000  /* MAC Control */
+#define MAC_ADDR_HIGH             0x00000004  /* MAC Address High */
+#define MAC_ADDR_LOW              0x00000008  /* MAC Address Low */
+#define MAC_HASH_HIGH             0x0000000c  /* Multicast Hash Table High */
+#define MAC_HASH_LOW              0x00000010  /* Multicast Hash Table Low */
+#define MAC_MII_ADDR              0x00000014  /* MII Address */
+#define MAC_MII_DATA              0x00000018  /* MII Data */
+#define MAC_FLOW_CONTROL          0x0000001c  /* Flow Control */
+#define MAC_VLAN1                 0x00000020  /* VLAN1 Tag */
+#define MAC_VLAN2                 0x00000024  /* VLAN2 Tag */
+#define MAC_WAKEUP_FILTER         0x00000028  /* Wake-up Frame Filter */
+#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c  /* Wake-up Control And Status */
+
+/* MAC CTRL defines */
+#define MAC_CONTROL_RA            0x80000000  /* Receive All Mode */
+#define MAC_CONTROL_BLE           0x40000000  /* Endian Mode */
+#define MAC_CONTROL_HBD           0x10000000  /* Heartbeat Disable */
+#define MAC_CONTROL_PS            0x08000000  /* Port Select */
+#define MAC_CONTROL_DRO           0x00800000  /* Disable Receive Own */
+#define MAC_CONTROL_EXT_LOOPBACK  0x00400000  /* Reserved (ext loopback?) */
+#define MAC_CONTROL_OM            0x00200000  /* Loopback Operating Mode */
+#define MAC_CONTROL_F             0x00100000  /* Full Duplex Mode */
+#define MAC_CONTROL_PM            0x00080000  /* Pass All Multicast */
+#define MAC_CONTROL_PR            0x00040000  /* Promiscuous Mode */
+#define MAC_CONTROL_IF            0x00020000  /* Inverse Filtering */
+#define MAC_CONTROL_PB            0x00010000  /* Pass Bad Frames */
+#define MAC_CONTROL_HO            0x00008000  /* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP            0x00002000  /* Hash/Perfect Filtering Mode */
+#define MAC_CONTROL_LCC           0x00001000  /* Late Collision Control */
+#define MAC_CONTROL_DBF           0x00000800  /* Disable Broadcast Frames */
+#define MAC_CONTROL_DRTY          0x00000400  /* Disable Retry */
+#define MAC_CONTROL_ASTP          0x00000100  /* Automatic Pad Stripping */
+#define MAC_CONTROL_BOLMT_10      0x00000000  /* Back Off Limit 10 */
+#define MAC_CONTROL_BOLMT_8       0x00000040  /* Back Off Limit 8 */
+#define MAC_CONTROL_BOLMT_4       0x00000080  /* Back Off Limit 4 */
+#define MAC_CONTROL_BOLMT_1       0x000000c0  /* Back Off Limit 1 */
+#define MAC_CONTROL_DC            0x00000020  /* Deferral Check */
+#define MAC_CONTROL_TE            0x00000008  /* Transmitter Enable */
+#define MAC_CONTROL_RE            0x00000004  /* Receiver Enable */
+
+/* MAC FLOW CTRL defines */
+#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000  /* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT 16
+#define MAC_FLOW_CONTROL_PCF      0x00000004  /* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE      0x00000002  /* Flow Control Enable */
+#define MAC_FLOW_CONTROL_PAUSE    0x00000001  /* Flow Control Busy ... */
+
+/* MII ADDR  defines */
+#define MAC_MII_ADDR_WRITE        0x00000002  /* MII Write */
+#define MAC_MII_ADDR_BUSY         0x00000001  /* MII Busy */
+
+/* MAC Management Counters register */
+#define MMC_CONTROL               0x00000100  /* MMC Control */
+#define MMC_HIGH_INTR             0x00000104  /* MMC High Interrupt */
+#define MMC_LOW_INTR              0x00000108  /* MMC Low Interrupt */
+#define MMC_HIGH_INTR_MASK        0x0000010c  /* MMC High Interrupt Mask */
+#define MMC_LOW_INTR_MASK         0x00000110  /* MMC Low Interrupt Mask */
+
+#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8   /* Maximum Frame Size */
+#define MMC_CONTROL_MAX_FRM_SHIFT 3
+#define MMC_CONTROL_MAX_FRAME 	  0x7FF
+
+/*----------------------------------------------------------------------------
+ * 				DMA BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* DMA CRS Control and Status Register Mapping */
+#define DMA_BUS_MODE              0x00001000  /* Bus Mode */
+#define DMA_XMT_POLL_DEMAND       0x00001004  /* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND       0x00001008  /* Received Poll Demand */
+#define DMA_RCV_BASE_ADDR         0x0000100c  /* Receive List Base */
+#define DMA_TX_BASE_ADDR          0x00001010  /* Transmit List Base */
+#define DMA_STATUS                0x00001014  /* Status Register */
+#define DMA_CONTROL               0x00001018  /* Control (Operational Mode) */
+#define DMA_INTR_ENA              0x0000101c  /* Interrupt Enable */
+#define DMA_MISSED_FRAME_CTR      0x00001020  /* Missed Frame Counter */
+#define DMA_CUR_TX_BUF_ADDR       0x00001050  /* Current Host Transmit Buffer */
+#define DMA_CUR_RX_BUF_ADDR       0x00001054  /* Current Host Receive Buffer */
+
+/*  DMA Bus Mode register defines */
+#define DMA_BUS_MODE_DBO          0x00100000  /* Descriptor Byte Ordering */
+#define DMA_BUS_MODE_PBL_MASK     0x00003f00  /* Programmable Burst Length */
+#define DMA_BUS_MODE_PBL_SHIFT    8
+#define DMA_BUS_MODE_BLE          0x00000080  /* Big Endian/Little Endian */
+#define DMA_BUS_MODE_DSL_MASK     0x0000007c  /* Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT    2           /*       (in DWORDS)      */
+#define DMA_BUS_MODE_BAR_BUS      0x00000002  /* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET    0x00000001  /* Software Reset */
+#define DMA_BUS_MODE_DEFAULT      0x00000000
+
+/* DMA Status register defines */
+#define DMA_STATUS_EB_MASK        0x00380000  /* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT    0x00080000  /* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT    0x00100000  /* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK        0x00700000  /* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT       20
+#define DMA_STATUS_RS_MASK        0x000e0000  /* Receive Process State */
+#define DMA_STATUS_RS_SHIFT       17
+#define DMA_STATUS_NIS            0x00010000  /* Normal Interrupt Summary */
+#define DMA_STATUS_AIS            0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI            0x00004000  /* Early Receive Interrupt */
+#define DMA_STATUS_FBI            0x00002000  /* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI            0x00000400  /* Early Transmit Interrupt */
+#define DMA_STATUS_RWT            0x00000200  /* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS            0x00000100  /* Receive Process Stopped */
+#define DMA_STATUS_RU             0x00000080  /* Receive Buffer Unavailable */
+#define DMA_STATUS_RI             0x00000040  /* Receive Interrupt */
+#define DMA_STATUS_UNF            0x00000020  /* Transmit Underflow */
+#define DMA_STATUS_OVF            0x00000010  /* Receive Overflow */
+#define DMA_STATUS_TJT            0x00000008  /* Transmit Jabber Timeout */
+#define DMA_STATUS_TU             0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS            0x00000002  /* Transmit Process Stopped */
+#define DMA_STATUS_TI             0x00000001  /* Transmit Interrupt */
+
+/* DMA Control register defines */
+#define DMA_CONTROL_SF            0x00200000  /* Store And Forward */
+#define DMA_CONTROL_TTC_MASK      0x0001c000  /* Transmit Threshold Control */
+#define DMA_CONTROL_TTC_32        0x00000000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_64        0x00004000  /* Threshold is 64 DWORDS */
+#define DMA_CONTROL_TTC_128       0x00008000  /* Threshold is 128 DWORDS */
+#define DMA_CONTROL_TTC_256       0x0000c000  /* Threshold is 256 DWORDS */
+#define DMA_CONTROL_TTC_18        0x00010000  /* Threshold is 18 DWORDS */
+#define DMA_CONTROL_TTC_24        0x00014000  /* Threshold is 24 DWORDS */
+#define DMA_CONTROL_TTC__32_      0x00018000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_40        0x0001c000  /* Threshold is 40 DWORDS */
+#define DMA_CONTROL_ST            0x00002000  /* Start/Stop Transmission */
+#define DMA_CONTROL_SE            0x00000008  /* Stop On Empty */
+#define DMA_CONTROL_OSF           0x00000004  /* Operate On 2nd Frame */
+#define DMA_CONTROL_SR            0x00000002  /* Start/Stop Receive */
+
+/* DMA Interrupt Enable register defines */
+#define DMA_INTR_ENA_NIE          0x00010000  /* Normal Interrupt Summary */
+#define DMA_INTR_ENA_AIE          0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_INTR_ENA_ERE          0x00004000  /* Early Receive */
+#define DMA_INTR_ENA_FBE          0x00002000  /* Fatal Bus Error */
+#define DMA_INTR_ENA_ETE          0x00000400  /* Early Transmit */
+#define DMA_INTR_ENA_RWE          0x00000200  /* Receive Watchdog */
+#define DMA_INTR_ENA_RSE          0x00000100  /* Receive Stopped */
+#define DMA_INTR_ENA_RUE          0x00000080  /* Receive Buffer Unavailable */
+#define DMA_INTR_ENA_RIE          0x00000040  /* Receive Interrupt */
+#define DMA_INTR_ENA_UNE          0x00000020  /* Underflow */
+#define DMA_INTR_ENA_OVE          0x00000010  /* Receive Overflow */
+#define DMA_INTR_ENA_TJE          0x00000008  /* Transmit Jabber */
+#define DMA_INTR_ENA_TUE          0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_INTR_ENA_TSE          0x00000002  /* Transmit Stopped */
+#define DMA_INTR_ENA_TIE          0x00000001  /* Transmit Interrupt */
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_AIE | \
+				DMA_INTR_ENA_FBE | DMA_INTR_ENA_RWE | \
+				DMA_INTR_ENA_RSE | DMA_INTR_ENA_RUE | \
+				DMA_INTR_ENA_RIE | DMA_INTR_ENA_UNE | \
+				DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
+				DMA_INTR_ENA_TUE | DMA_INTR_ENA_TSE | \
+				/*DMA_INTR_ENA_ERE | DMA_INTR_ENA_ETE | */ \
+				DMA_INTR_ENA_TIE)
+
+/* STMAC110 DMA Missed Frame Counter register defines */
+#define DMA_MISSED_FRAME_OVE      0x10000000  /* FIFO Overflow Overflow */
+#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000  /* Overflow Frame Counter */
+#define DMA_MISSED_FRAME_OVE_M    0x00010000  /* Missed Frame Overflow */
+#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff  /* Missed Frame Couinter */
+
+/*----------------------------------------------------------------------------
+ * 		    	    Descriptor defines
+ *---------------------------------------------------------------------------*/
+/* Common fields */
+#define OWN_BIT			0x80000000  /* Own Bit (owned by hardware) */
+#define DES1_CONTROL_CH		0x01000000  /* Second Address Chained */
+#define DES1_CONTROL_TER	0x02000000  /* End of Ring */
+#define DES1_RBS2_SIZE_MASK	0x003ff800  /* Buffer 2 Size Mask */
+#define DES1_RBS2_SIZE_SHIFT	11          /* Buffer 2 Size Shift */
+#define DES1_RBS1_SIZE_MASK	0x000007ff  /* Buffer 1 Size Mask */
+#define DES1_RBS1_SIZE_SHIFT	0           /* Buffer 1 Size Shift */
+
+/* Receive Descriptor */
+#define RDES0_STATUS_FILTER_FAIL  0x40000000  /* Filtering Fail */
+#define RDES0_STATUS_FL_MASK      0x3fff0000  /* Frame Length Mask */
+#define RDES0_STATUS_FL_SHIFT     16          /* Frame Length Shift */
+#define RDES0_STATUS_ES           0x00008000  /* Error Summary */
+#define RDES0_STATUS_DE           0x00004000  /* Descriptor Error */
+#define RDES0_STATUS_PFE          0x00002000  /* Partial Frame Error */
+#define RDES0_STATUS_LENGTH_ERROR 0x00001000  /* Length Error */
+#define RDES0_STATUS_RUNT_FRM     0x00000800  /* Runt Frame */
+#define RDES0_STATUS_MULTICST_FRM 0x00000400  /* Multicast Frame */
+#define RDES0_STATUS_FS           0x00000200  /* First Descriptor */
+#define RDES0_STATUS_LS           0x00000100  /* Last Descriptor */
+#define RDES0_STATUS_TL           0x00000080  /* Frame Too Long */
+#define RDES0_STATUS_COL_SEEN     0x00000040  /* Collision Seen */
+#define RDES0_STATUS_FRM_TYPE     0x00000020  /* Frame Type */
+#define RDES0_STATUS_RX_WATCHDOG  0x00000010  /* Receive Watchdog */
+#define RDES0_STATUS_MII_ERR      0x00000008  /* Report on MII Error */
+#define RDES0_STATUS_DRIBBLE      0x00000004  /* Dribbling Bit */
+#define RDES0_STATUS_CE           0x00000002  /* CRC Error */
+#define RDES0_STATUS_0            0x00000000  /* Always tied to zero */
+
+#define RDES1_CONTROL_DIOC        0x80000000  /* Disable Intr On Completion */
+
+/* Transmit Descriptor */
+#define TDES0_STATUS_ES		  0x00008000  /* Error Summary */
+#define TDES0_STATUS_LOSS_CARRIER 0x00000800  /* Loss of Carrier */
+#define TDES0_STATUS_NO_CARRIER   0x00000400  /* No Carrier */
+#define TDES0_STATUS_LATE_COL     0x00000200  /* Late Collision */
+#define TDES0_STATUS_EX_COL       0x00000100  /* Excessive Collisions */
+#define TDES0_STATUS_HRTBT_FAIL   0x00000080  /* Heartbeat Fail */
+#define TDES0_STATUS_COLCNT_MASK  0x00000078  /* Collision Count Mask */
+#define TDES0_STATUS_COLCNT_SHIFT 3           /* Collision Count Shift */
+#define TDES0_STATUS_EX_DEF       0x00000004  /* Excessive Deferrals */
+#define TDES0_STATUS_UF           0x00000002  /* Underflow Error */
+#define TDES0_STATUS_DF           0x00000001  /* Deferred */
+
+#define TDES1_CONTROL_IC          0x80000000  /* Interrupt on Completion */
+#define TDES1_CONTROL_LS          0x40000000  /* Last Segment */
+#define TDES1_CONTROL_FS          0x20000000  /* First Segment */
+#define TDES1_CONTROL_AC          0x04000000  /* Add CRC Disable */
+#define TDES1_CONTROL_DPD         0x00800000  /* Disable Padding */
diff -Naur linux-2.6.17.8/drivers/net/stnic.c linux-2.6.17.8-sh/drivers/net/stnic.c
--- linux-2.6.17.8/drivers/net/stnic.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/net/stnic.c	2006-08-23 13:29:18.579140000 +0100
@@ -20,7 +20,7 @@
 
 #include <asm/system.h>
 #include <asm/io.h>
-#include <asm/se/se.h>
+#include <asm/se.h>
 #include <asm/machvec.h>
 #ifdef CONFIG_SH_STANDARD_BIOS 
 #include <asm/sh_bios.h>
diff -Naur linux-2.6.17.8/drivers/pcmcia/hd64461_ss.c linux-2.6.17.8-sh/drivers/pcmcia/hd64461_ss.c
--- linux-2.6.17.8/drivers/pcmcia/hd64461_ss.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/pcmcia/hd64461_ss.c	2006-08-23 13:29:25.788300000 +0100
@@ -0,0 +1,679 @@
+/*
+ * drivers/pcmcia/hd64461_ss.c
+ *
+ * PCMCIA support for Hitachi HD64461 companion chip
+ * by Andriy Skulysh <askulysh@image.kiev.ua> 2002, 2003, 2004
+ *
+ *	based on hd64461_ss.c by Greg Banks <gbanks@pocketpenguins.com>
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include "cs_internal.h"
+#include <asm/io.h>
+#include <asm/hd64461.h>
+#include <asm/hp6xx/hp6xx.h>
+
+#define MODNAME "HD64461_ss"
+
+#ifdef DEBUG
+static int hd64461_pc_debug = 2;
+
+module_param_named(pc_debug, hd64461_pc_debug, int, 0644);
+
+#define DPRINTK(n, args...)		\
+do {					\
+	if (hd64461_pc_debug >= (n))	\
+		printk(args);		\
+} while (0)
+#else
+#define DPRINTK(n, args...)	do { } while (0)
+#endif
+
+#define HD64461_PCC(s,reg)						\
+	( CONFIG_HD64461_IOBASE-HD64461_STBCR+ ( (s) ? HD64461_PCC1##reg : \
+	HD64461_PCC0##reg ) )
+
+typedef struct hd64461_socket_t {
+	unsigned int irq;
+	unsigned long mem_base;
+	socket_state_t state;
+	pccard_mem_map mem_maps[MAX_WIN];
+	unsigned char IC_memory;
+	struct pcmcia_socket socket;
+ 	u8 cscier;
+} hd64461_socket_t;
+
+static hd64461_socket_t hd64461_sockets[CONFIG_HD64461_PCMCIA_SOCKETS];
+
+#define hd64461_sockno(sp)	(sp - hd64461_sockets)
+
+static void hd64461_enable_int(unsigned int irq)
+{
+	u8 cscier;
+	u32 cscier_reg = HD64461_PCC(0, CSCIER);
+
+	cscier = ctrl_inb(cscier_reg);
+	cscier &= ~HD64461_PCCCSCIER_IREQE_MASK;
+	cscier |= HD64461_PCCCSCIER_IREQE_LEVEL;
+	ctrl_outb(cscier, cscier_reg);
+}
+
+static void hd64461_disable_int(unsigned int irq)
+{
+	u8 cscier;
+	u32 cscier_reg = HD64461_PCC(0, CSCIER);
+
+	cscier = ctrl_inb(cscier_reg);
+	cscier &= ~HD64461_PCCCSCIER_IREQE_MASK;
+	ctrl_outb(cscier, cscier_reg);
+}
+
+static void hd64461_enable_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_enable_irq(irq=%d)\n", irq);
+	hd64461_enable_int(irq);
+}
+
+static void hd64461_disable_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_disable_irq(irq=%d)\n", irq);
+	hd64461_disable_int(irq);
+}
+
+static unsigned int hd64461_startup_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_startup_irq(irq=%d)\n", irq);
+	hd64461_enable_irq(irq);
+	return 0;
+}
+
+static void hd64461_shutdown_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_shutdown_irq(irq=%d)\n", irq);
+	hd64461_disable_irq(irq);
+}
+
+static void hd64461_mask_and_ack_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_mask_and_ack_irq(irq=%d)\n", irq);
+	hd64461_disable_irq(irq);
+}
+
+static void hd64461_end_irq(unsigned int irq)
+{
+	DPRINTK(3, "hd64461_end_irq(irq=%d)\n", irq);
+	hd64461_enable_irq(irq);
+}
+
+static struct hw_interrupt_type hd64461_ss_irq_type = {
+	.typename	= "HD64461_SS-IRQ",
+	.startup	= hd64461_startup_irq,
+	.shutdown	= hd64461_shutdown_irq,
+	.enable		= hd64461_enable_irq,
+	.disable	= hd64461_disable_irq,
+	.ack		= hd64461_mask_and_ack_irq,
+	.end		= hd64461_end_irq
+};
+
+static int hd64461_set_voltage(int sock, int Vcc, int Vpp)
+{
+	u8 gcr, scr;
+	u16 stbcr;
+	u32 gcr_reg = HD64461_PCC(sock, GCR);
+	u32 scr_reg = HD64461_PCC(sock, SCR);
+	DPRINTK(2, "hd64461_set_voltage(%d, %d, %d)\n", sock, Vcc, Vpp);
+
+	gcr = ctrl_inb(gcr_reg);
+	scr = ctrl_inb(scr_reg);
+
+	switch (Vcc) {
+	case 0:
+		gcr |= HD64461_PCCGCR_VCC0;
+		scr |= HD64461_PCCSCR_VCC1;
+		break;
+	case 33:
+		if (sock == 1) {
+			gcr &= ~HD64461_PCCGCR_VCC0;
+			scr &= ~HD64461_PCCSCR_VCC1;
+		} else {
+			gcr |= HD64461_PCCGCR_VCC0;
+			scr &= ~HD64461_PCCSCR_VCC1;
+		}
+		break;
+	case 50:
+		gcr &= ~HD64461_PCCGCR_VCC0;
+		scr &= ~HD64461_PCCSCR_VCC1;
+		break;
+	}
+
+	ctrl_outb(gcr, gcr_reg);
+	ctrl_outb(scr, scr_reg);
+
+	stbcr = inw(HD64461_STBCR);
+
+	if (Vcc > 0) {
+		stbcr &= ~(sock == 0 ? HD64461_STBCR_SPC0ST :
+			   HD64461_STBCR_SPC1ST);
+	} else {
+		stbcr |= (sock == 0 ? HD64461_STBCR_SPC0ST :
+			  HD64461_STBCR_SPC1ST);
+	}
+
+	outw(stbcr, HD64461_STBCR);
+
+	return 1;
+}
+
+static int hd64461_init(struct pcmcia_socket *s)
+{
+	u16 gpadr;
+	hd64461_socket_t *sp = container_of(s, struct hd64461_socket_t, socket);
+
+	DPRINTK(0, "hd64461_init(%d)\n", s->sock);
+
+	sp->state.Vcc = 0;
+	sp->state.Vpp = 0;
+	hd64461_set_voltage(s->sock, 0, 0);
+
+	if (mach_is_hp6xx() && s->sock == 0) {
+		gpadr = inw(HD64461_GPADR);
+		gpadr &= ~HD64461_GPADR_PCMCIA0;
+		outw(gpadr, HD64461_GPADR);
+	}
+
+	return 0;
+}
+
+static int hd64461_suspend(struct pcmcia_socket *s)
+{
+	u16 gpadr;
+	u8 gcr;
+	u32 gcr_reg = HD64461_PCC(s->sock, GCR);
+
+	DPRINTK(0, "hd64461_suspend(%d)\n", s->sock);
+
+	gcr = ctrl_inb(gcr_reg);
+	gcr &= ~HD64461_PCCGCR_DRVE;
+	ctrl_outb(gcr, gcr_reg);
+	hd64461_set_voltage(s->sock, 0, 0);
+
+	if ((mach_is_hp6xx())&&(s->sock == 0)) {
+		gpadr = inw(HD64461_GPADR);
+		gpadr |= HD64461_GPADR_PCMCIA0;
+		outw(gpadr, HD64461_GPADR);
+	}
+
+	return 0;
+}
+
+static int hd64461_get_status(struct pcmcia_socket *s, u32 * value)
+{
+	u8 isr;
+	u32 status = 0;
+	hd64461_socket_t *sp = container_of(s, struct hd64461_socket_t, socket);
+
+	isr = ctrl_inb(HD64461_PCC(s->sock, ISR));
+
+	if ((isr & HD64461_PCCISR_PCD_MASK) == 0) {
+		status |= SS_DETECT;
+
+		if (sp->IC_memory) {
+			switch (isr & HD64461_PCCISR_BVD_MASK) {
+			case HD64461_PCCISR_BVD_BATGOOD:
+				break;
+			case HD64461_PCCISR_BVD_BATWARN:
+				status |= SS_BATWARN;
+				break;
+			default:
+				status |= SS_BATDEAD;
+				break;
+			}
+
+			if (isr & HD64461_PCCISR_READY)
+				status |= SS_READY;
+			if (isr & HD64461_PCCISR_MWP)
+				status |= SS_WRPROT;
+		} else {
+			if (isr & HD64461_PCCISR_BVD1)
+				status |= SS_STSCHG;
+		}
+
+		switch (isr & (HD64461_PCCISR_VS2 | HD64461_PCCISR_VS1)) {
+		case HD64461_PCCISR_VS1:
+			printk(KERN_NOTICE MODNAME
+			       ": cannot handle X.XV card, ignored\n");
+			status = 0;
+			break;
+		case 0:
+		case HD64461_PCCISR_VS2:
+			status |= SS_3VCARD;
+			break;
+		case HD64461_PCCISR_VS2 | HD64461_PCCISR_VS1:
+			break;
+		}
+
+		if ((sp->state.Vcc != 0) || (sp->state.Vpp != 0))
+			status |= SS_POWERON;
+	}
+	DPRINTK(0, "hd64461_get_status(%d) = %x\n", s->sock, status);
+
+	*value = status;
+	return 0;
+}
+
+static int hd64461_set_socket(struct pcmcia_socket *s, socket_state_t * state)
+{
+	u32 flags;
+	u32 changed;
+	u8 gcr, cscier;
+	hd64461_socket_t *sp = container_of(s, struct hd64461_socket_t, socket);
+	u32 gcr_reg = HD64461_PCC(s->sock, GCR);
+	u32 cscier_reg = HD64461_PCC(s->sock, CSCIER);
+
+	DPRINTK(0, "%s(sock=%d, flags=%x, csc_mask=%x, Vcc=%d, Vpp=%d, io_irq=%d)\n",
+		__FUNCTION__, s->sock, state->flags, state->csc_mask, state->Vcc,
+		state->Vpp, state->io_irq);
+
+	local_irq_save(flags);
+
+	if (state->Vpp != sp->state.Vpp || state->Vcc != sp->state.Vcc) {
+		if (!hd64461_set_voltage(s->sock, state->Vcc, state->Vpp)) {
+    			local_irq_restore(flags);
+			return -EINVAL;
+		}
+	}
+
+	changed = sp->state.csc_mask ^ state->csc_mask;
+	cscier = ctrl_inb(cscier_reg);
+
+	if (changed & SS_DETECT) {
+		if (state->csc_mask & SS_DETECT)
+			cscier |= HD64461_PCCCSCIER_CDE;
+		else
+			cscier &= ~HD64461_PCCCSCIER_CDE;
+	}
+
+	if (changed & SS_READY) {
+		if (state->csc_mask & SS_READY)
+			cscier |= HD64461_PCCCSCIER_RE;
+		else
+			cscier &= ~HD64461_PCCCSCIER_RE;
+	}
+
+	if (changed & SS_BATDEAD) {
+		if (state->csc_mask & SS_BATDEAD)
+			cscier |= HD64461_PCCCSCIER_BDE;
+		else
+			cscier &= ~HD64461_PCCCSCIER_BDE;
+	}
+
+	if (changed & SS_BATWARN) {
+		if (state->csc_mask & SS_BATWARN)
+			cscier |= HD64461_PCCCSCIER_BWE;
+		else
+			cscier &= ~HD64461_PCCCSCIER_BWE;
+	}
+
+	if (changed & SS_STSCHG) {
+		if (state->csc_mask & SS_STSCHG)
+			cscier |= HD64461_PCCCSCIER_SCE;
+		else
+			cscier &= ~HD64461_PCCCSCIER_SCE;
+	}
+
+	ctrl_outb(cscier, cscier_reg);
+
+	changed = sp->state.flags ^ state->flags;
+
+	gcr = ctrl_inb(gcr_reg);
+
+	if (changed & SS_IOCARD) {
+		DPRINTK(0, "card type: %s\n",
+			(state->flags & SS_IOCARD ? "i/o" : "memory"));
+		if (state->flags & SS_IOCARD) {
+			if (s->sock == 1) {
+				printk(KERN_ERR
+				       "socket 1 can be only IC Memory card\n");
+			} else {
+				gcr |= HD64461_PCCGCR_PCCT;
+				sp->IC_memory = 0;
+			}
+		} else {
+			gcr &= ~HD64461_PCCGCR_PCCT;
+			sp->IC_memory = 1;
+		}
+	}
+
+	if (changed & SS_RESET) {
+		DPRINTK(0, "%s reset card\n",
+			(state->flags & SS_RESET ? "start" : "stop"));
+		if (state->flags & SS_RESET)
+			gcr |= HD64461_PCCGCR_PCCR;
+		else
+			gcr &= ~HD64461_PCCGCR_PCCR;
+	}
+
+	if (changed & SS_OUTPUT_ENA) {
+		DPRINTK(0, "%sabling card output\n",
+			(state->flags & SS_OUTPUT_ENA ? "en" : "dis"));
+		if (state->flags & SS_OUTPUT_ENA)
+			gcr |= HD64461_PCCGCR_DRVE;
+		else
+			gcr &= ~HD64461_PCCGCR_DRVE;
+	}
+
+	DPRINTK(2, "cscier=%02x ", cscier);
+	DPRINTK(2, "gcr=%02x\n", gcr);
+	ctrl_outb(gcr, gcr_reg);
+
+	sp->state = *state;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int hd64461_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)
+{
+	/* this is not needed due to static mappings */
+	DPRINTK(0, "hd64461_set_io_map(%d)\n", s->sock);
+
+	return 0;
+}
+
+static int hd64461_set_mem_map(struct pcmcia_socket *s,
+			       struct pccard_mem_map *mem)
+{
+	hd64461_socket_t *sp = container_of(s, struct hd64461_socket_t, socket);
+	struct pccard_mem_map *smem;
+	int map = mem->map;
+	unsigned long saddr;
+
+	DPRINTK(0, "%s(sock=%d, map=%d, flags=0x%x,static_start=0x%08lx, card_start=0x%08x)\n",
+		__FUNCTION__, s->sock, map, mem->flags, mem->static_start, mem->card_start);
+
+	if (map >= MAX_WIN)
+		return -EINVAL;
+
+	smem = &sp->mem_maps[map];
+	saddr = sp->mem_base + mem->card_start;
+
+	if (!(mem->flags & MAP_ATTRIB))
+		saddr += HD64461_PCC_WINDOW;
+
+	mem->static_start = saddr;
+	*smem = *mem;
+
+	return 0;
+}
+
+static int hd64461_pcmcia_irq_demux(int irq, void *dev)
+{
+	hd64461_socket_t *sp = (hd64461_socket_t *) dev;
+	unsigned char cscr;
+	unsigned cscr_reg = HD64461_PCC(0, CSCR);
+
+	DPRINTK(3, "hd64461_pcmcia_irq_demux(irq= %d - ", irq);
+
+	cscr = ctrl_inb(cscr_reg);
+	if (cscr & HD64461_PCCCSCR_IREQ) {
+		cscr &= ~HD64461_PCCCSCR_IREQ;
+		ctrl_outb(cscr, cscr_reg);
+		irq = sp->socket.pci_irq;
+	}
+
+	DPRINTK(3, "%d)\n", irq);
+
+	return irq;
+}
+
+static irqreturn_t hd64461_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	hd64461_socket_t *sp = (hd64461_socket_t *) dev;
+	unsigned events = 0;
+	unsigned char cscr;
+	unsigned cscr_reg = HD64461_PCC(hd64461_sockno(sp), CSCR);
+
+	cscr = ctrl_inb(cscr_reg);
+
+	DPRINTK(3, "hd64461_interrupt: cscr=%04x irq=%d\n", cscr, irq);
+
+	if (cscr & HD64461_PCCCSCR_CDC) {
+		cscr &= ~HD64461_PCCCSCR_CDC;
+		events |= SS_DETECT;
+
+		if ((ctrl_inb(HD64461_PCC(hd64461_sockno(sp), ISR)) &
+		     HD64461_PCCISR_PCD_MASK) != 0) {
+			cscr &= ~(HD64461_PCCCSCR_RC | HD64461_PCCCSCR_BW |
+				  HD64461_PCCCSCR_BD | HD64461_PCCCSCR_SC);
+		}
+	}
+
+	if (sp->IC_memory) {
+		if (cscr & HD64461_PCCCSCR_RC) {
+			cscr &= ~HD64461_PCCCSCR_RC;
+			events |= SS_READY;
+		}
+
+		if (cscr & HD64461_PCCCSCR_BW) {
+			cscr &= ~HD64461_PCCCSCR_BW;
+			events |= SS_BATWARN;
+		}
+
+		if (cscr & HD64461_PCCCSCR_BD) {
+			cscr &= ~HD64461_PCCCSCR_BD;
+			events |= SS_BATDEAD;
+		}
+	} else {
+		if (cscr & HD64461_PCCCSCR_SC) {
+			cscr &= ~HD64461_PCCCSCR_SC;
+			events |= SS_STSCHG;
+		}
+	}
+
+	ctrl_outb(cscr, cscr_reg);
+
+	if (events)
+		pcmcia_parse_events(&sp->socket, events);
+
+	return IRQ_HANDLED;
+}
+
+static struct pccard_operations hd64461_operations = {
+	.init = hd64461_init,
+	.suspend = hd64461_suspend,
+	.get_status = hd64461_get_status,
+	.set_socket = hd64461_set_socket,
+	.set_io_map = hd64461_set_io_map,
+	.set_mem_map = hd64461_set_mem_map,
+};
+
+int hd64461_init_socket(int sock, int irq, int io_irq, unsigned long mem_base,
+			unsigned short io_offset)
+{
+	hd64461_socket_t *sp = &hd64461_sockets[sock];
+	unsigned gcr_reg = HD64461_PCC(sock, GCR);
+	int irq_flags = (sock == 0) ? SA_INTERRUPT : SA_SHIRQ;
+	u8 gcr;
+	int i, err;
+
+	ctrl_outb(0, HD64461_PCC(sock, CSCIER));
+
+	memset(sp, 0, sizeof(*sp));
+	sp->IC_memory = 1;
+	sp->irq = irq;
+	sp->mem_base = mem_base;
+	sp->socket.features =
+	    SS_CAP_PCCARD | SS_CAP_STATIC_MAP | SS_CAP_PAGE_REGS;
+	sp->socket.resource_ops = &pccard_static_ops;
+	sp->socket.map_size = HD64461_PCC_WINDOW;	/* 16MB fixed window size */
+	sp->socket.pci_irq = io_irq;
+	sp->socket.io_offset = io_offset;
+	sp->socket.owner = THIS_MODULE;
+	sp->socket.ops = &hd64461_operations;
+
+	for (i = 0; i != MAX_WIN; i++)
+		sp->mem_maps[i].map = i;
+
+	if ((err =
+	     request_irq(irq, hd64461_interrupt, irq_flags, MODNAME, sp)) < 0) {
+		printk(KERN_ERR
+		       "HD64461 PCMCIA socket %d: can't request irq %d\n", sock,
+		       sp->irq);
+		return err;
+	}
+
+	if (sock == 0) {
+		irq_desc[io_irq].handler = &hd64461_ss_irq_type;
+		hd64461_register_irq_demux(sp->irq, hd64461_pcmcia_irq_demux,
+					   sp);
+	}
+
+	gcr = ctrl_inb(gcr_reg);
+	gcr |= HD64461_PCCGCR_PMMOD;	/* 16MB mapping mode */
+	gcr &= ~(HD64461_PCCGCR_PA25 | HD64461_PCCGCR_PA24);	/* lowest 16MB of Common */
+	ctrl_outb(gcr, gcr_reg);
+
+	return 0;
+}
+
+void hd64461_exit_socket(int sock)
+{
+	hd64461_socket_t *sp = &hd64461_sockets[sock];
+	unsigned cscier_reg = HD64461_PCC(sock, CSCIER);
+
+	ctrl_outb(0, cscier_reg);
+	hd64461_suspend(&sp->socket);
+
+	if (sp->irq) {
+		if (sock == 0)
+			hd64461_unregister_irq_demux(sp->irq);
+		free_irq(sp->irq, sp);
+		if (sock == 0)
+			irq_desc[sp->socket.pci_irq].handler = &no_irq_type;
+	}
+}
+
+static int __devexit hd64461_pcmcia_drv_remove(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i != CONFIG_HD64461_PCMCIA_SOCKETS; i++) {
+		pcmcia_unregister_socket(&hd64461_sockets[i].socket);
+		hd64461_exit_socket(i);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hd64461_pcmcia_drv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; i != CONFIG_HD64461_PCMCIA_SOCKETS; i++) {
+		u32 cscier_reg = HD64461_PCC(i, CSCIER);
+		hd64461_sockets[i].cscier = ctrl_inb(cscier_reg);
+		ctrl_outb(0, cscier_reg);
+		ret = pcmcia_socket_dev_suspend(&dev->dev, state);
+	}
+ 	return ret;
+ }
+
+static int hd64461_pcmcia_drv_resume(struct platform_device *dev)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; i != CONFIG_HD64461_PCMCIA_SOCKETS; i++) {
+		u32 cscier_reg = HD64461_PCC(i, CSCIER);
+		ctrl_outb(hd64461_sockets[i].cscier, cscier_reg);
+		ret = pcmcia_socket_dev_resume(&dev->dev);
+	}
+
+	return ret;
+}
+#endif
+
+static struct platform_driver hd64461_pcmcia_driver = {
+	.remove = __devexit_p(hd64461_pcmcia_drv_remove),
+#ifdef CONFIG_PM
+	.suspend = hd64461_pcmcia_drv_suspend,
+	.resume = hd64461_pcmcia_drv_resume,
+#endif
+	.driver		= {
+		.name	= "hd64461-pcmcia",
+	},
+};
+
+static struct platform_device *hd64461_pcmcia_device;
+
+static int __init init_hd64461_ss(void)
+{
+	int i;
+
+	printk(KERN_INFO "HD64461 PCMCIA bridge.\n");
+	if (platform_driver_register(&hd64461_pcmcia_driver))
+		return -EINVAL;
+
+	i = hd64461_init_socket(0, HD64461_IRQ_PCC0, HD64461_IRQ_PCC0 + 1,
+				HD64461_PCC0_BASE, 0xf000);
+	if (i < 0) {
+		platform_driver_unregister(&hd64461_pcmcia_driver);
+		return i;
+	}
+#if CONFIG_HD64461_PCMCIA_SOCKETS==2
+	i = hd64461_init_socket(1, HD64461_IRQ_PCC1, HD64461_IRQ_PCC1,
+				HD64461_PCC1_BASE, 0);
+	if (i < 0) {
+		platform_driver_unregister(&hd64461_pcmcia_driver);
+		return i;
+	}
+#endif
+
+	hd64461_pcmcia_device = platform_device_register_simple("hd64461-pcmcia", -1, NULL, 0);
+	if (IS_ERR(hd64461_pcmcia_device)) {
+		platform_driver_unregister(&hd64461_pcmcia_driver);
+		return PTR_ERR(hd64461_pcmcia_device);
+	}
+
+	for (i = 0; i != CONFIG_HD64461_PCMCIA_SOCKETS; i++) {
+		unsigned int ret;
+		hd64461_sockets[i].socket.dev.dev = &hd64461_pcmcia_device->dev;
+		ret = pcmcia_register_socket(&hd64461_sockets[i].socket);
+		if (ret && i)
+			pcmcia_unregister_socket(&hd64461_sockets[0].socket);
+	}
+
+	return 0;
+}
+
+static void __exit exit_hd64461_ss(void)
+{
+	platform_device_unregister(hd64461_pcmcia_device);
+	platform_driver_unregister(&hd64461_pcmcia_driver);
+}
+
+module_init(init_hd64461_ss);
+module_exit(exit_hd64461_ss);
+
+MODULE_AUTHOR("Andriy Skulysh <askulysh@gmail.com>");
+MODULE_DESCRIPTION("PCMCIA driver for Hitachi HD64461 companion chip");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/pcmcia/Kconfig linux-2.6.17.8-sh/drivers/pcmcia/Kconfig
--- linux-2.6.17.8/drivers/pcmcia/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/pcmcia/Kconfig	2006-08-23 13:29:07.460888000 +0100
@@ -179,6 +179,19 @@
 	  "Bridge" is the name used for the hardware inside your computer that
 	  PCMCIA cards are plugged into. If unsure, say N.
 
+config HD64461_PCMCIA
+	tristate "HD64461 host bridge support"
+	depends on HD64461 && PCMCIA
+
+config HD64461_PCMCIA_SOCKETS
+	int '     HD64461 PCMCIA sockets'
+	default 1
+	depends on HD64461_PCMCIA
+
+config HD64465_PCMCIA
+	tristate "HD64465 host bridge support"
+	depends on HD64465 && PCMCIA
+
 config PCMCIA_M8XX
         tristate "MPC8xx PCMCIA support"
         depends on PCMCIA && PPC && 8xx 
@@ -189,10 +202,6 @@
 
         This driver is also available as a module called m8xx_pcmcia.
 
-config HD64465_PCMCIA
-	tristate "HD64465 host bridge support"
-	depends on HD64465 && PCMCIA
-
 config PCMCIA_AU1X00
 	tristate "Au1x00 pcmcia support"
 	depends on SOC_AU1X00 && PCMCIA
diff -Naur linux-2.6.17.8/drivers/pcmcia/Makefile linux-2.6.17.8-sh/drivers/pcmcia/Makefile
--- linux-2.6.17.8/drivers/pcmcia/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/pcmcia/Makefile	2006-08-23 13:29:07.494886000 +0100
@@ -25,8 +25,9 @@
 obj-$(CONFIG_I82365)				+= i82365.o
 obj-$(CONFIG_I82092)				+= i82092.o
 obj-$(CONFIG_TCIC)				+= tcic.o
-obj-$(CONFIG_PCMCIA_M8XX)			+= m8xx_pcmcia.o
+obj-$(CONFIG_HD64461_PCMCIA)			+= hd64461_ss.o
 obj-$(CONFIG_HD64465_PCMCIA)			+= hd64465_ss.o
+obj-$(CONFIG_PCMCIA_M8XX)			+= m8xx_pcmcia.o
 obj-$(CONFIG_PCMCIA_SA1100)			+= sa11xx_core.o sa1100_cs.o
 obj-$(CONFIG_PCMCIA_SA1111)			+= sa11xx_core.o sa1111_cs.o
 obj-$(CONFIG_PCMCIA_PXA2XX)                     += pxa2xx_core.o pxa2xx_cs.o
diff -Naur linux-2.6.17.8/drivers/pcmcia/yenta_socket.c linux-2.6.17.8-sh/drivers/pcmcia/yenta_socket.c
--- linux-2.6.17.8/drivers/pcmcia/yenta_socket.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/pcmcia/yenta_socket.c	2006-08-23 13:29:20.025162000 +0100
@@ -49,6 +49,15 @@
 #define to_cycles(ns)	((ns)/120)
 #define to_ns(cycles)	((cycles)*120)
 
+#if defined(CONFIG_SH_HS7751RVOIP) || defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R7780RP)
+#define PCI_CB_SYSTEM_CONTROL	0x80	/* System Control Register */
+#define PCI_CB_MULTIFUNCTION	0x8c	/* Multifunction Routing Register */
+#define PCI_CB_RETRY_STATUS	0x90	/* Retry Status Register */
+#define PCI_CB_CARD_CONTROL	0x91	/* Card Control Register */
+#define PCI_CB_DEVICE_CONTROL	0x92	/* Device Control Register */
+#define PCI_CB_DIAGNOSTIC	0x93	/* Diagnostic Register */
+#endif
+
 /**
  * yenta PCI irq probing.
  * currently only used in the TI/EnE initialization code
@@ -511,7 +520,12 @@
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
 
+#if defined(CONFIG_SH_HS7751RVOIP) || defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R7780RP)
+	exca_writeb(socket, I365_GBLCTL, I365_GBL_CSC_LEV | I365_GBL_IRQ_0_LEV);
+	exca_writeb(socket, I365_INTCTL, I365_INTR_ENA);
+#else
 	exca_writeb(socket, I365_GBLCTL, 0x00);
+#endif
 	exca_writeb(socket, I365_GENCTL, 0x00);
 
 	/* Redo card voltage interrogation */
@@ -996,6 +1010,38 @@
 	bridge &= ~(CB_BRIDGE_CRST | CB_BRIDGE_PREFETCH1 | CB_BRIDGE_ISAEN | CB_BRIDGE_VGAEN);
 	bridge |= CB_BRIDGE_PREFETCH0 | CB_BRIDGE_POSTEN;
 	config_writew(socket, CB_BRIDGE_CONTROL, bridge);
+#if defined(CONFIG_SH_HS7751RVOIP) || defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_R7780RP)
+	/* System Contro Register
+	 *	SER_STEP=00, INTRTIE=1, RSVD=0, P2CCLK=1,
+	 *	SMIROUTE=0, SMISTATUS=0, SMIENB=0, RSVD=0,
+	 *	CBRSVD=0, VCCPROT=0, REDUCEZV=0, RSVD=0100,
+	 *	MRBURSTD=1, MRBURSTU=1, SOCACTIV=0, RSVD=1,
+	 *	PWRSTREAM=0, DELAYUP=0, DELAYCOWN=0, INTERROGATE=0,
+	 *	RSVD=0, PWRSAVINGS=1, SUBSYSRW=1, CB_DPAR=0,
+	 *	RSVD=0, EXCAPOWER=0, KEEPCLK=0, RIMUX=0
+	 */
+	config_writel(socket, PCI_CB_SYSTEM_CONTROL, 0x28449060);
+	/* Retry Status Register
+	 *	PCIRETRY=0, CBRETRY=0, TEXP_CBB=0, RSVD=0,
+	 *	TEXP_CBA=0, RSVD=0, TEXP_PCI=0, RSVD=0
+	 */
+	config_writeb(socket, PCI_CB_RETRY_STATUS, 0x00);
+	/* Device Control Register
+	 *	SKTPWR_LOCK=0, 3VCAPABLE=1, IO16V2=1, RSVD=0,
+	 *	TEST=0, INTMODE=01, RSVD=0
+	 */
+	config_writeb(socket, PCI_CB_DEVICE_CONTROL, 0x62);
+	/* Siagnostic Register
+	 *	TRUE_VAL=0, RSVD=1, CSC=0, DIAG4=0,
+	 *	DIAG3=0, DIAG2=0, DIAG1=0, STDZVEN=0
+	 */
+	config_writeb(socket, PCI_CB_DIAGNOSTIC, 0x40);
+	/* Multifucntion Routing Register
+	 *	RSVD=0000, MFUNC6=0000, MFUNC5=0000, MFUNC4=0000,
+	 *	MFUNC3=0001, MFUNC2=0000, MFUNC1=0000, MFUNC0=0010
+	 */
+	config_writel(socket, PCI_CB_MULTIFUNCTION, 0x00001002);
+#endif
 }
 
 /*
diff -Naur linux-2.6.17.8/drivers/rtc/Kconfig linux-2.6.17.8-sh/drivers/rtc/Kconfig
--- linux-2.6.17.8/drivers/rtc/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/rtc/Kconfig	2006-08-23 13:29:27.485348000 +0100
@@ -147,6 +147,16 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rtc-sa1100.
 
+config RTC_DRV_SH
+	tristate "SuperH On-Chip RTC"
+	depends on RTC_CLASS && SUPERH
+	help
+	  Say Y here to enable support for the on-chip RTC found in
+	  most SuperH processors.
+
+ 	  To compile this driver as a module, choose M here: the
+	  module will be called rtc-sh.
+
 config RTC_DRV_VR41XX
 	tristate "NEC VR41XX"
 	depends on RTC_CLASS && CPU_VR41XX
diff -Naur linux-2.6.17.8/drivers/rtc/Makefile linux-2.6.17.8-sh/drivers/rtc/Makefile
--- linux-2.6.17.8/drivers/rtc/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/rtc/Makefile	2006-08-23 13:29:27.525346000 +0100
@@ -20,3 +20,4 @@
 obj-$(CONFIG_RTC_DRV_EP93XX)	+= rtc-ep93xx.o
 obj-$(CONFIG_RTC_DRV_SA1100)	+= rtc-sa1100.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
+obj-$(CONFIG_RTC_DRV_SH)	+= rtc-sh.o
diff -Naur linux-2.6.17.8/drivers/rtc/rtc-sh.c linux-2.6.17.8-sh/drivers/rtc/rtc-sh.c
--- linux-2.6.17.8/drivers/rtc/rtc-sh.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/rtc/rtc-sh.c	2006-08-23 13:29:27.539346000 +0100
@@ -0,0 +1,467 @@
+/*
+ * SuperH On-Chip RTC Support
+ *
+ * Copyright (C) 2006  Paul Mundt
+ *
+ * Based on the old arch/sh/kernel/cpu/rtc.c by:
+ *
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/bcd.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_CPU_SH3
+#define rtc_reg_size		sizeof(u16)
+#define RTC_BIT_INVERTED	0	/* No bug on SH7708, SH7709A */
+#elif defined(CONFIG_CPU_SH4)
+#define rtc_reg_size		sizeof(u32)
+#define RTC_BIT_INVERTED	0x40	/* bug on SH7750, SH7750S */
+#endif
+
+#define RTC_REG(r)	((r) * rtc_reg_size)
+
+#define R64CNT  	RTC_REG(0)
+#define RSECCNT 	RTC_REG(1)
+#define RMINCNT 	RTC_REG(2)
+#define RHRCNT  	RTC_REG(3)
+#define RWKCNT  	RTC_REG(4)
+#define RDAYCNT 	RTC_REG(5)
+#define RMONCNT 	RTC_REG(6)
+#define RYRCNT  	RTC_REG(7)
+#define RSECAR  	RTC_REG(8)
+#define RMINAR  	RTC_REG(9)
+#define RHRAR   	RTC_REG(10)
+#define RWKAR   	RTC_REG(11)
+#define RDAYAR  	RTC_REG(12)
+#define RMONAR  	RTC_REG(13)
+#define RCR1    	RTC_REG(14)
+#define RCR2    	RTC_REG(15)
+
+/* RCR1 Bits */
+#define RCR1_CF		0x80	/* Carry Flag             */
+#define RCR1_CIE	0x10	/* Carry Interrupt Enable */
+#define RCR1_AIE	0x08	/* Alarm Interrupt Enable */
+#define RCR1_AF		0x01	/* Alarm Flag             */
+
+/* RCR2 Bits */
+#define RCR2_PEF	0x80	/* PEriodic interrupt Flag */
+#define RCR2_PESMASK	0x70	/* Periodic interrupt Set  */
+#define RCR2_RTCEN	0x08	/* ENable RTC              */
+#define RCR2_ADJ	0x04	/* ADJustment (30-second)  */
+#define RCR2_RESET	0x02	/* Reset bit               */
+#define RCR2_START	0x01	/* Start bit               */
+
+struct sh_rtc {
+	void __iomem *regbase;
+	unsigned long regsize;
+	struct resource *res;
+	unsigned int alarm_irq, periodic_irq, carry_irq;
+	struct rtc_device *rtc_dev;
+	spinlock_t lock;
+};
+
+static irqreturn_t sh_rtc_interrupt(int irq, void *id, struct pt_regs *regs)
+{
+	struct platform_device *pdev = id;
+	struct sh_rtc *rtc = platform_get_drvdata(pdev);
+	unsigned int tmp, events = 0;
+
+	spin_lock(&rtc->lock);
+
+	tmp = readb(rtc->regbase + RCR1);
+
+	if (tmp & RCR1_AF)
+		events |= RTC_AF | RTC_IRQF;
+
+	tmp &= ~(RCR1_CF | RCR1_AF);
+
+	writeb(tmp, rtc->regbase + RCR1);
+	
+	rtc_update_irq(&rtc->rtc_dev->class_dev, 1, events);
+
+	spin_unlock(&rtc->lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sh_rtc_periodic(int irq, void *id, struct pt_regs *regs)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(id);
+
+	spin_lock(&rtc->lock);
+
+	rtc_update_irq(&rtc->rtc_dev->class_dev, 1, RTC_PF | RTC_IRQF);
+
+	spin_unlock(&rtc->lock);
+
+	return IRQ_HANDLED;
+}
+
+static inline void sh_rtc_setpie(struct device *dev, unsigned int enable)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int tmp;
+
+	spin_lock_irq(&rtc->lock);
+
+	tmp = readb(rtc->regbase + RCR2);
+
+	if (enable) {
+		tmp &= ~RCR2_PESMASK;
+		tmp |= RCR2_PEF | (2 << 4);
+	} else
+		tmp &= ~(RCR2_PESMASK | RCR2_PEF);
+
+	writeb(tmp, rtc->regbase + RCR2);
+
+	spin_unlock_irq(&rtc->lock);
+}
+
+static inline void sh_rtc_setaie(struct device *dev, unsigned int enable)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int tmp;
+
+	spin_lock_irq(&rtc->lock);
+
+	tmp = readb(rtc->regbase + RCR1);
+
+	if (enable)
+		tmp |= RCR1_AIE;
+	else
+		tmp &= ~RCR1_AIE;
+
+	writeb(tmp, rtc->regbase + RCR1);
+
+	spin_unlock_irq(&rtc->lock);
+}
+
+static int sh_rtc_open(struct device *dev)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int tmp;
+	int ret;
+
+	tmp = readb(rtc->regbase + RCR1);
+	tmp &= ~RCR1_CF;
+	tmp |= RCR1_CIE;
+	writeb(tmp, rtc->regbase + RCR1);
+
+	ret = request_irq(rtc->periodic_irq, sh_rtc_periodic, SA_INTERRUPT,
+			  "sh-rtc period", dev);
+	if (unlikely(ret)) {
+		dev_err(dev, "request period IRQ failed with %d, IRQ %d\n",
+			ret, rtc->periodic_irq);
+		return ret;
+	}
+
+	ret = request_irq(rtc->carry_irq, sh_rtc_interrupt, SA_INTERRUPT,
+			  "sh-rtc carry", dev);
+	if (unlikely(ret)) {
+		dev_err(dev, "request carry IRQ failed with %d, IRQ %d\n",
+			ret, rtc->carry_irq);
+		free_irq(rtc->periodic_irq, dev);
+		goto err_bad_carry;
+	}
+
+	ret = request_irq(rtc->alarm_irq, sh_rtc_interrupt, SA_INTERRUPT,
+			  "sh-rtc alarm", dev);
+	if (unlikely(ret)) {
+		dev_err(dev, "request alarm IRQ failed with %d, IRQ %d\n",
+			ret, rtc->alarm_irq);
+		goto err_bad_alarm;
+	}
+	
+	return 0;
+
+err_bad_alarm:
+	free_irq(rtc->carry_irq, dev);
+err_bad_carry:
+	free_irq(rtc->periodic_irq, dev);
+
+	return ret;
+}
+
+static void sh_rtc_release(struct device *dev)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(dev);
+
+	sh_rtc_setpie(dev, 0);
+
+	free_irq(rtc->periodic_irq, dev);
+	free_irq(rtc->carry_irq, dev);
+	free_irq(rtc->alarm_irq, dev);
+}
+
+static int sh_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	struct sh_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int tmp;
+
+	tmp = readb(rtc->regbase + RCR1);
+	seq_printf(seq, "alarm_IRQ\t: %s\n",
+		   (tmp & RCR1_AIE) ? "yes" : "no");
+	seq_printf(seq, "carry_IRQ\t: %s\n",
+		   (tmp & RCR1_CIE) ? "yes" : "no");
+
+	tmp = readb(rtc->regbase + RCR2);
+	seq_printf(seq, "periodic_IRQ\t: %s\n",
+		   (tmp & RCR2_PEF) ? "yes" : "no");
+
+	return 0;
+}
+
+static int sh_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	unsigned int ret = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case RTC_PIE_OFF:
+	case RTC_PIE_ON:
+		sh_rtc_setpie(dev, cmd == RTC_PIE_ON);
+		ret = 0;
+		break;
+	case RTC_AIE_OFF:
+	case RTC_AIE_ON:
+		sh_rtc_setaie(dev, cmd == RTC_AIE_ON);
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static int sh_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sh_rtc *rtc = platform_get_drvdata(pdev);
+	unsigned int sec128, sec2, yr, yr100, cf_bit;
+
+	do {
+		unsigned int tmp;
+
+		spin_lock_irq(&rtc->lock);
+
+		tmp = readb(rtc->regbase + RCR1);
+		tmp &= ~RCR1_CF; /* Clear CF-bit */
+		tmp |= RCR1_CIE;
+		writeb(tmp, rtc->regbase + RCR1);
+
+		sec128 = readb(rtc->regbase + R64CNT);
+
+		tm->tm_sec	= BCD2BIN(readb(rtc->regbase + RSECCNT));
+		tm->tm_min	= BCD2BIN(readb(rtc->regbase + RMINCNT));
+		tm->tm_hour	= BCD2BIN(readb(rtc->regbase + RHRCNT));
+		tm->tm_wday	= BCD2BIN(readb(rtc->regbase + RWKCNT));
+		tm->tm_mday	= BCD2BIN(readb(rtc->regbase + RDAYCNT));
+		tm->tm_mon	= BCD2BIN(readb(rtc->regbase + RMONCNT));
+
+#if defined(CONFIG_CPU_SH4)
+		yr  = readw(rtc->regbase + RYRCNT);
+		yr100 = BCD2BIN(yr >> 8);
+		yr &= 0xff;
+#else
+		yr  = readb(rtc->regbase + RYRCNT);
+		yr100 = BCD2BIN((yr == 0x99) ? 0x19 : 0x20);
+#endif
+
+		tm->tm_year = (yr100 * 100 + BCD2BIN(yr)) - 1900;
+
+		sec2 = readb(rtc->regbase + R64CNT);
+		cf_bit = readb(rtc->regbase + RCR1) & RCR1_CF;
+
+		spin_unlock_irq(&rtc->lock);
+	} while (cf_bit != 0 || ((sec128 ^ sec2) & RTC_BIT_INVERTED) != 0);
+
+#if RTC_BIT_INVERTED != 0
+	if ((sec128 & RTC_BIT_INVERTED))
+		tm->tm_sec--;
+#endif
+
+	dev_dbg(&dev, "%s: tm is secs=%d, mins=%d, hours=%d, "
+		"mday=%d, mon=%d, year=%d, wday=%d\n",
+		__FUNCTION__,
+		tm->tm_sec, tm->tm_min, tm->tm_hour,
+		tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);
+
+	if (rtc_valid_tm(tm) < 0)
+		dev_err(dev, "invalid date\n");
+
+	return 0;
+}
+
+static int sh_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sh_rtc *rtc = platform_get_drvdata(pdev);
+	unsigned int tmp;
+	int year;
+
+	spin_lock_irq(&rtc->lock);
+
+	/* Reset pre-scaler & stop RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp |= RCR2_RESET;
+	writeb(tmp, rtc->regbase + RCR2);
+
+	writeb(BIN2BCD(tm->tm_sec),  rtc->regbase + RSECCNT);
+	writeb(BIN2BCD(tm->tm_min),  rtc->regbase + RMINCNT);
+	writeb(BIN2BCD(tm->tm_hour), rtc->regbase + RHRCNT);
+	writeb(BIN2BCD(tm->tm_wday), rtc->regbase + RWKCNT);
+	writeb(BIN2BCD(tm->tm_mday), rtc->regbase + RDAYCNT);
+	writeb(BIN2BCD(tm->tm_mon),  rtc->regbase + RMONCNT);
+
+#ifdef CONFIG_CPU_SH3
+	year = tm->tm_year % 100;
+	writeb(BIN2BCD(year), rtc->regbase + RYRCNT);
+#else
+	year = (BIN2BCD((tm->tm_year + 1900) / 100) << 8) |
+		BIN2BCD(tm->tm_year % 100);
+	writew(year, rtc->regbase + RYRCNT);
+#endif
+
+	/* Start RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp &= ~RCR2_RESET;
+	tmp |= RCR2_RTCEN | RCR2_START;
+	writeb(tmp, rtc->regbase + RCR2);
+
+	spin_unlock_irq(&rtc->lock);
+
+	return 0;
+}
+
+static struct rtc_class_ops sh_rtc_ops = {
+	.open		= sh_rtc_open,
+	.release	= sh_rtc_release,
+	.ioctl		= sh_rtc_ioctl,
+	.read_time	= sh_rtc_read_time,
+	.set_time	= sh_rtc_set_time,
+	.proc		= sh_rtc_proc,
+};
+
+static int __devinit sh_rtc_probe(struct platform_device *pdev)
+{
+	struct sh_rtc *rtc;
+	struct resource *res;
+	int ret = -ENOENT;
+
+	rtc = kzalloc(sizeof(struct sh_rtc), GFP_KERNEL);
+	if (unlikely(!rtc))
+		return -ENOMEM;
+
+	spin_lock_init(&rtc->lock);
+
+	rtc->periodic_irq = platform_get_irq(pdev, 0);
+	if (unlikely(rtc->periodic_irq < 0)) {
+		dev_err(&pdev->dev, "No IRQ for period\n");
+		goto err_badres;
+	}
+
+	rtc->carry_irq = platform_get_irq(pdev, 1);
+	if (unlikely(rtc->carry_irq < 0)) {
+		dev_err(&pdev->dev, "No IRQ for carry\n");
+		goto err_badres;
+	}
+
+	rtc->alarm_irq = platform_get_irq(pdev, 2);
+	if (unlikely(rtc->alarm_irq < 0)) {
+		dev_err(&pdev->dev, "No IRQ for alarm\n");
+		goto err_badres;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (unlikely(res == NULL)) {
+		dev_err(&pdev->dev, "No IO resource\n");
+		goto err_badres;
+	}
+
+	rtc->regsize = res->end - res->start + 1;
+
+	rtc->res = request_mem_region(res->start, rtc->regsize, pdev->name);
+	if (unlikely(!rtc->res)) {
+		ret = -EBUSY;
+		goto err_badres;
+	}
+
+	rtc->regbase = (void __iomem *)rtc->res->start;
+	if (unlikely(!rtc->regbase)) {
+		ret = -EINVAL;
+		goto err_badmap;
+	}
+
+	rtc->rtc_dev = rtc_device_register("sh", &pdev->dev,
+					   &sh_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc->rtc_dev);
+		goto err_badmap;
+	}
+
+	platform_set_drvdata(pdev, rtc);
+
+	return 0;
+
+err_badmap:
+	release_resource(rtc->res);
+err_badres:
+	kfree(rtc);
+
+	return ret;
+}
+
+static int __devexit sh_rtc_remove(struct platform_device *pdev)
+{
+	struct sh_rtc *rtc = platform_get_drvdata(pdev);
+	
+	if (likely(rtc->rtc_dev))
+		rtc_device_unregister(rtc->rtc_dev);
+
+	sh_rtc_setpie(&pdev->dev, 0);
+	sh_rtc_setaie(&pdev->dev, 0);
+
+	release_resource(rtc->res);
+
+	platform_set_drvdata(pdev, NULL);
+
+	kfree(rtc);
+
+	return 0;
+}
+static struct platform_driver sh_rtc_platform_driver = {
+	.driver		= {
+		.name	= "sh-rtc",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= sh_rtc_probe,
+	.remove		= __devexit_p(sh_rtc_remove),
+};
+
+static int __init sh_rtc_init(void)
+{
+	return platform_driver_register(&sh_rtc_platform_driver);
+}
+
+static void __exit sh_rtc_exit(void)
+{
+	platform_driver_unregister(&sh_rtc_platform_driver);
+}
+
+module_init(sh_rtc_init);
+module_exit(sh_rtc_exit);
+
+MODULE_DESCRIPTION("SuperH on-chip RTC driver");
+MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/scsi/Kconfig linux-2.6.17.8-sh/drivers/scsi/Kconfig
--- linux-2.6.17.8/drivers/scsi/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/scsi/Kconfig	2006-08-23 13:29:38.932599000 +0100
@@ -609,6 +609,15 @@
 	depends on IDE=y && !BLK_DEV_IDE_SATA && (SCSI_SATA_AHCI || SCSI_ATA_PIIX)
 	default y
 
+config SCSI_SATA_STM
+	tristate "STMicroelectronics SATA support"
+	depends on SCSI_SATA && (ARCH_ST200 || CPU_SUBTYPE_ST40)
+	help
+	  This option enables support for the on-chip SATA controller on
+	  some STMicroelectronics embedded processors.
+
+	  If unsure, say N.
+
 config SCSI_BUSLOGIC
 	tristate "BusLogic SCSI support"
 	depends on (PCI || ISA || MCA) && SCSI && ISA_DMA_API
diff -Naur linux-2.6.17.8/drivers/scsi/libata-core.c linux-2.6.17.8-sh/drivers/scsi/libata-core.c
--- linux-2.6.17.8/drivers/scsi/libata-core.c	2006-08-21 14:42:23.165771000 +0100
+++ linux-2.6.17.8-sh/drivers/scsi/libata-core.c	2006-08-23 13:29:47.696806000 +0100
@@ -54,8 +54,13 @@
 #include "scsi_priv.h"
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
-#include <linux/libata.h>
+// #include <linux/libata.h>
 #include <asm/io.h>
+
+
+// Moved from above so that it is after this munging.
+#include <linux/libata.h>
+
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
diff -Naur linux-2.6.17.8/drivers/scsi/Makefile linux-2.6.17.8-sh/drivers/scsi/Makefile
--- linux-2.6.17.8/drivers/scsi/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/scsi/Makefile	2006-08-23 13:29:38.960599000 +0100
@@ -136,6 +136,7 @@
 obj-$(CONFIG_SCSI_SATA_ULI)	+= libata.o sata_uli.o
 obj-$(CONFIG_SCSI_SATA_MV)	+= libata.o sata_mv.o
 obj-$(CONFIG_SCSI_PDC_ADMA)	+= libata.o pdc_adma.o
+obj-$(CONFIG_SCSI_SATA_STM)	+= libata.o sata_stm.o
 
 obj-$(CONFIG_ARM)		+= arm/
 
diff -Naur linux-2.6.17.8/drivers/scsi/sata_stm.c linux-2.6.17.8-sh/drivers/scsi/sata_stm.c
--- linux-2.6.17.8/drivers/scsi/sata_stm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/scsi/sata_stm.c	2006-08-23 13:29:50.814875000 +0100
@@ -0,0 +1,982 @@
+/*
+ *  sata_stm.c - STMicroelectronics SATA
+ *
+ *  Copyright 2005 STMicroelectronics Ltd.
+ *
+ *  The contents of this file are subject to the Open
+ *  Software License version 1.1 that can be found at
+ *  http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+ *  by reference.
+ *
+ *  Alternatively, the contents of this file may be used under the terms
+ *  of the GNU General Public License version 2 (the "GPL") as distributed
+ *  in the kernel source COPYING file, in which case the provisions of
+ *  the GPL are applicable instead of the above.  If you wish to allow
+ *  the use of your version of this file only under the terms of the
+ *  GPL and not to allow others to use your version of this file under
+ *  the OSL, indicate your decision by deleting the provisions above and
+ *  replace them with the notice and other provisions required by the GPL.
+ *  If you do not delete the provisions above, a recipient may use your
+ *  version of this file under either the OSL or the GPL.
+ */
+
+//#define ATA_DEBUG
+//#define ATA_VERBOSE_DEBUG
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+#include <linux/st_soc.h>
+
+#define DRV_NAME			"sata_stm"
+#define DRV_VERSION			"0.2"
+
+/* Offsets of the component blocks */
+#define SATA_AHB2STBUS_BASE			0x00000000
+#define SATA_AHBDMA_BASE			0x00000400
+#define SATA_AHBHOST_BASE			0x00000800
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x0000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x000c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x0010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x0014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x0018)
+
+/* AHB DMA controller */
+#define DMAC_SAR0				(SATA_AHBDMA_BASE + 0x00000000)
+#define DMAC_DAR0				(SATA_AHBDMA_BASE + 0x00000008)
+#define DMAC_LLP0				(SATA_AHBDMA_BASE + 0x00000010)
+#define DMAC_CTL0_0				(SATA_AHBDMA_BASE + 0x00000018)
+#define DMAC_CTL0_1				(SATA_AHBDMA_BASE + 0x0000001c)
+#define DMAC_SSTAT0				(SATA_AHBDMA_BASE + 0x00000020)
+#define DMAC_DSTAT0				(SATA_AHBDMA_BASE + 0x00000028)
+#define DMAC_SSTATAR0				(SATA_AHBDMA_BASE + 0x00000030)
+#define DMAC_DSTATAR0				(SATA_AHBDMA_BASE + 0x00000038)
+#define DMAC_CFG0_0				(SATA_AHBDMA_BASE + 0x00000040)
+#define DMAC_CFG0_1				(SATA_AHBDMA_BASE + 0x00000044)
+#define DMAC_SGR0				(SATA_AHBDMA_BASE + 0x00000048)
+#define DMAC_DSR0				(SATA_AHBDMA_BASE + 0x00000050)
+#define DMAC_RAWTFR				(SATA_AHBDMA_BASE + 0x000002c0)
+#define DMAC_RAWBLOCK				(SATA_AHBDMA_BASE + 0x000002c8)
+#define DMAC_RAWSRCTRAN				(SATA_AHBDMA_BASE + 0x000002d0)
+#define DMAC_RAWDSTTRAN				(SATA_AHBDMA_BASE + 0x000002d8)
+#define DMAC_RAWERR				(SATA_AHBDMA_BASE + 0x000002e0)
+#define DMAC_STATUSTFR				(SATA_AHBDMA_BASE + 0x000002e8)
+#define DMAC_STATUSBLOCK			(SATA_AHBDMA_BASE + 0x000002f0)
+#define DMAC_STATUSSRCTRAN			(SATA_AHBDMA_BASE + 0x000002f8)
+#define DMAC_STATUSDSTTRAN			(SATA_AHBDMA_BASE + 0x00000300)
+#define DMAC_STATUSERR				(SATA_AHBDMA_BASE + 0x00000308)
+#define DMAC_MASKTFR				(SATA_AHBDMA_BASE + 0x00000310)
+#define DMAC_MASKBLOCK				(SATA_AHBDMA_BASE + 0x00000318)
+#define DMAC_MASKSRCTRAN			(SATA_AHBDMA_BASE + 0x00000320)
+#define DMAC_MASKDSTTRAN			(SATA_AHBDMA_BASE + 0x00000328)
+#define DMAC_MASKERR				(SATA_AHBDMA_BASE + 0x00000330)
+#define DMAC_CLEARTFR				(SATA_AHBDMA_BASE + 0x00000338)
+#define DMAC_CLEARBLOCK				(SATA_AHBDMA_BASE + 0x00000340)
+#define DMAC_CLEARSRCTRAN			(SATA_AHBDMA_BASE + 0x00000348)
+#define DMAC_CLEARDSTTRAN			(SATA_AHBDMA_BASE + 0x00000350)
+#define DMAC_CLEARERR				(SATA_AHBDMA_BASE + 0x00000358)
+#define DMAC_STATUSINT				(SATA_AHBDMA_BASE + 0x00000360)
+#define DMAC_REQSRCREG				(SATA_AHBDMA_BASE + 0x00000368)
+#define DMAC_REQDSTREG				(SATA_AHBDMA_BASE + 0x00000370)
+#define DMAC_SGLREQSRCREG			(SATA_AHBDMA_BASE + 0x00000378)
+#define DMAC_SGLREQDSTREG			(SATA_AHBDMA_BASE + 0x00000380)
+#define DMAC_LSTSRCREG				(SATA_AHBDMA_BASE + 0x00000388)
+#define DMAC_LSTDSTREG				(SATA_AHBDMA_BASE + 0x00000390)
+#define DMAC_DmaCfgReg				(SATA_AHBDMA_BASE + 0x00000398)
+#define DMAC_ChEnReg				(SATA_AHBDMA_BASE + 0x000003a0)
+#define DMAC_DMAIDREG				(SATA_AHBDMA_BASE + 0x000003a8)
+#define DMAC_DMATESTREG				(SATA_AHBDMA_BASE + 0x000003b0)
+#define DMAC_DMA_COMP_VERSION			(SATA_AHBDMA_BASE + 0x000003b8)
+#define DMAC_COMP_PARAMS_2			(SATA_AHBDMA_BASE + 0x000003e8)
+#define DMAC_COMP_TYPE				(SATA_AHBDMA_BASE + 0x000003f8)
+#define DMAC_COMP_VERSION			(SATA_AHBDMA_BASE + 0x000003fc)
+
+#define DMAC_CTL_INT_EN			(1<<0)
+#define DMAC_CTL_DST_TR_WIDTH_32	(2<<1)
+#define DMAC_CTL_SRC_TR_WIDTH_32	(2<<4)
+#define DMAC_CTL_DINC_INC		(0<<7)
+#define DMAC_CTL_DINC_DEC		(1<<7)
+#define DMAC_CTL_DINC_NC		(2<<7)
+#define DMAC_CTL_SINC_INC		(0<<9)
+#define DMAC_CTL_SINC_DEC		(1<<9)
+#define DMAC_CTL_SINC_NC		(2<<9)
+#define DMAC_CTL_DEST_MSIZE_1		(0<<11)
+#define DMAC_CTL_DEST_MSIZE_4		(1<<11)
+#define DMAC_CTL_DEST_MSIZE_8		(2<<11)
+#define DMAC_CTL_DEST_MSIZE_16		(3<<11)
+#define DMAC_CTL_SRC_MSIZE_1		(0<<14)
+#define DMAC_CTL_SRC_MSIZE_4		(1<<14)
+#define DMAC_CTL_SRC_MSIZE_8		(2<<14)
+#define DMAC_CTL_SRC_MSIZE_16		(3<<14)
+#define DMAC_CTL_SRC_GATHER_EN		(1<<17)
+#define DMAC_CTL_DST_SCATTER_EN		(1<<18)
+#define DMAC_CTL_TT_FC_M2M_DMAC		(0<<20)	/* memory to memory | DMAC */
+#define DMAC_CTL_TT_FC_M2P_DMAC		(1<<20)	/* memory to periph | DMAC */
+#define DMAC_CTL_TT_FC_P2M_DMAC		(2<<20)	/* periph to memory | DMAC */
+#define DMAC_CTL_TT_FC_P2P_DMAC		(3<<20)	/* periph to periph | DMAC */
+#define DMAC_CTL_TT_FC_P2M_PER		(4<<20)	/* periph to memory | periph */
+#define DMAC_CTL_TT_FC_P2P_SPER		(5<<20)	/* periph to periph | src periph */
+#define DMAC_CTL_TT_FC_M2P_PER		(6<<20)	/* memory to periph | periph */
+#define DMAC_CTL_TT_FC_P2P_DPER		(7<<20)	/* periph to periph | dest periph */
+#define DMAC_CTL_DMS_1		(0<<23)
+#define DMAC_CTL_DMS_2		(1<<23)
+#define DMAC_CTL_SMS_1		(0<<25)
+#define DMAC_CTL_SMS_2		(1<<25)
+#define DMAC_CTL_LLP_DST_EN	(1<<27)
+#define DMAC_CTL_LLP_SRC_EN	(1<<28)
+
+#define DMAC_CTL_BLOCK_TS	(1<<32)
+#define DMAC_CTL_DONE		(1<<44)
+
+#define DMA_CFG_CH_PRIOR_0	(0<<5)
+#define DMA_CFG_CH_SUSP		(1<<8)
+#define DMA_CFG_FIFO_EMPTY	(1<<9)
+#define DMA_CFG_HS_SEL_DST_HW	(0<<10)
+#define DMA_CFG_HS_SEL_DST_SW	(1<<10)
+#define DMA_CFG_HS_SEL_SRC_HW	(0<<11)
+#define DMA_CFG_HS_SEL_SRC_SW	(1<<11)
+/*efine DMA_CFG_LOCK_CH_L	(1<<12) not in config */
+/*efine DMA_CFG_LOCK_B_L	(1<<14) not in config */
+/*efine DMA_CFG_LOCK_CH		(1<<16) not in config */
+/*efine DMA_CFG_LOCK_B		(1<<17) not in config */
+#define DMA_CFG_DST_HS_POL_HI	(0<<18)
+#define DMA_CFG_DST_HS_POL_LO	(1<<18)
+#define DMA_CFG_SRC_HS_POL_HI	(0<<19)
+#define DMA_CFG_SRC_HS_POL_LO	(1<<19)
+#define DMA_CFG_MAX_ABRST_UNLIMITED	(0<<20)
+#define DMA_CFG_RELOAD_SRC	(1<<30)
+#define DMA_CFG_RELOAD_DST	(1<<31)
+
+#define DMA_CFG_1_FCMODE		(1<<(32-32))
+#define DMA_CFG_1_FIFO_MODE		(1<<(33-32))
+#define DMA_CFG_1_PROTCTL		(1<<(34-32))
+#define DMA_CFG_1_DS_UPD_EN		(1<<(37-32))
+/*efine DMA_CFG_1_SS_UPD_EN		(1<<(38-32)) not in config */
+#define DMA_CFG_1_SRC_PER_0		(0<<(39-32))
+#define DMA_CFG_1_SRC_PER_1		(1<<(39-32))
+#define DMA_CFG_1_DEST_PER_0		(0<<(43-32))
+#define DMA_CFG_1_DEST_PER_1		(1<<(43-32))
+
+#define DMAC_DmaCfgReg_DMA_EN	(1<<0)
+
+#define DMAC_COMP_PARAMS_2_CH0_HC_LLP	(1<<13)
+
+/* AHB host controller */
+#define SATA_CDR0				(SATA_AHBHOST_BASE + 0x00000000)
+#define SATA_CDR1				(SATA_AHBHOST_BASE + 0x00000004)
+#define SATA_CDR2				(SATA_AHBHOST_BASE + 0x00000008)
+#define SATA_CDR3				(SATA_AHBHOST_BASE + 0x0000000c)
+#define SATA_CDR4				(SATA_AHBHOST_BASE + 0x00000010)
+#define SATA_CDR5				(SATA_AHBHOST_BASE + 0x00000014)
+#define SATA_CDR6				(SATA_AHBHOST_BASE + 0x00000018)
+#define SATA_CDR7				(SATA_AHBHOST_BASE + 0x0000001c)
+#define SATA_CLR0				(SATA_AHBHOST_BASE + 0x00000020)
+#define SATA_SCR0				(SATA_AHBHOST_BASE + 0x00000024)
+#define SATA_SCR1				(SATA_AHBHOST_BASE + 0x00000028)
+#define SATA_SCR2				(SATA_AHBHOST_BASE + 0x0000002c)
+#define SATA_SCR3				(SATA_AHBHOST_BASE + 0x00000030)
+#define SATA_SCR4				(SATA_AHBHOST_BASE + 0x00000034)
+#define SATA_FPTAGR				(SATA_AHBHOST_BASE + 0x00000064)
+#define SATA_FPBOR				(SATA_AHBHOST_BASE + 0x00000068)
+#define SATA_FPTCR				(SATA_AHBHOST_BASE + 0x0000006c)
+#define SATA_DMACR				(SATA_AHBHOST_BASE + 0x00000070)
+#define SATA_DBTSR				(SATA_AHBHOST_BASE + 0x00000074)
+#define SATA_INTPR				(SATA_AHBHOST_BASE + 0x00000078)
+#define SATA_INTMR				(SATA_AHBHOST_BASE + 0x0000007c)
+#define SATA_ERRMR				(SATA_AHBHOST_BASE + 0x00000080)
+#define SATA_LLCR				(SATA_AHBHOST_BASE + 0x00000084)
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x00000088)
+#define SATA_PHYSR				(SATA_AHBHOST_BASE + 0x0000008c)
+#define SATA_RXBISTPD				(SATA_AHBHOST_BASE + 0x00000090)
+#define SATA_RXBISTD1				(SATA_AHBHOST_BASE + 0x00000094)
+#define SATA_RXBISTD2				(SATA_AHBHOST_BASE + 0x00000098)
+#define SATA_TXBISTPD				(SATA_AHBHOST_BASE + 0x0000009c)
+#define SATA_TXBISTD1				(SATA_AHBHOST_BASE + 0x000000a0)
+#define SATA_TXBISTD2				(SATA_AHBHOST_BASE + 0x000000a4)
+#define SATA_BISTCR				(SATA_AHBHOST_BASE + 0x000000a8)
+#define SATA_BISTFCTR				(SATA_AHBHOST_BASE + 0x000000ac)
+#define SATA_BISTSR				(SATA_AHBHOST_BASE + 0x000000b0)
+#define SATA_BISTDECR				(SATA_AHBHOST_BASE + 0x000000b4)
+#define SATA_TESTR				(SATA_AHBHOST_BASE + 0x000000f4)
+#define SATA_VERSIONR				(SATA_AHBHOST_BASE + 0x000000f8)
+#define SATA_IDR				(SATA_AHBHOST_BASE + 0x000000fc)
+
+
+#define SATA_DMACR_TXCHEN	(1<<0)
+#define SATA_DMACR_RXCHEN	(1<<1)
+
+/* Bit values for SATA_INTPR and SATA_INTMR */
+#define SATA_INT_DMAT		(1<<0)
+#define SATA_INT_NEWFP		(1<<1)
+#define SATA_INT_PMABORT	(1<<2)
+#define SATA_INT_ERR		(1<<3)
+#define SATA_INT_NEWBIST	(1<<4)
+
+#define SERROR_ERR_T	(1<<8)
+#define SERROR_ERR_C	(1<<9)
+#define SERROR_ERR_P	(1<<10)
+#define SERROR_ERR_E	(1<<11)
+
+/*
+ * DMAH_CH0_MAX_BLK_SIZE is 4095, so with CTL0.DST_TR_WIDTH set to 32,
+ * we are limited to just under 16K. In practice this is 12K.
+ */
+#define DMAC_BLOCK_TS_MAX_BYTES (12*1024)
+
+/* Layout of a DMAC Linked List Item (LLI)
+ * DMAH_CH0_STAT_DST and DMAH_CH0_STAT_SRC are both 0 */
+struct stm_lli {
+	u32	sar;
+	u32	dar;
+	u32	llp;
+	u32	ctl0;
+	u32	ctl1;
+  u32 v1, v2;
+};
+
+struct stm_host_priv
+{
+	unsigned long phy_init;		/* Initial value for PHYCR */
+	int softsg;			/* If using softsg */
+};
+
+struct stm_port_priv
+{
+	struct stm_lli *lli;		/* Base of the allocated lli nodes */
+	dma_addr_t lli_dma;		/* Physical version of lli */
+	struct stm_lli *softsg_node;	/* Current softsg node */
+	struct stm_lli *softsg_end;	/* End of the softsg node */
+};
+
+#define STM_LLI_BYTES (LIBATA_MAX_PRD * sizeof(struct stm_lli))
+
+static void stm_phy_reset(struct ata_port *ap)
+{
+	void __iomem *mmio = (void __iomem *) ap->ioaddr.cmd_addr;
+	struct stm_host_priv *hpriv = ap->host_set->private_data;
+
+DPRINTK("ENTER\n");
+
+/* ST SATA 1.4 doc has a reference for what these bits mean */
+	writel(hpriv->phy_init, mmio + SATA_PHYCR);
+        mdelay(100);
+
+	sata_phy_reset(ap);
+}
+
+static void stm_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct stm_port_priv *pp = ap->private_data;
+	struct stm_host_priv *hpriv = ap->host_set->private_data;
+	void __iomem *mmio = (void __iomem *) ap->ioaddr.cmd_addr;
+	u32 cfg0, cfg1;
+
+	cfg0 =	DMA_CFG_CH_PRIOR_0		|
+		DMA_CFG_HS_SEL_DST_HW		|
+		DMA_CFG_HS_SEL_SRC_HW		|
+		DMA_CFG_DST_HS_POL_HI		|
+		DMA_CFG_SRC_HS_POL_HI		|
+		DMA_CFG_MAX_ABRST_UNLIMITED;
+
+	cfg1 =	DMA_CFG_1_FIFO_MODE		|
+		DMA_CFG_1_SRC_PER_0		| /* Used on reads */
+		DMA_CFG_1_DEST_PER_1;		  /* Used on writes */
+
+	writel(cfg0, mmio + DMAC_CFG0_0);
+	writel(cfg1, mmio + DMAC_CFG0_1);
+
+	/* These reads also have the side effect of flushing any posted
+	 * writes to the LLI's */
+	writel(pp->lli->ctl0, mmio + DMAC_CTL0_0);
+	writel(pp->lli->ctl1, mmio + DMAC_CTL0_1);
+
+	if (hpriv->softsg) {
+		/* Write the first node into the DMAC registers */
+		writel(pp->lli->sar, mmio + DMAC_SAR0);
+		writel(pp->lli->dar, mmio + DMAC_DAR0);
+
+		/* Clear interrupt from the final SG node of the
+		 * previous transfer */
+		writel(1<<0, mmio + DMAC_CLEARTFR);
+
+		/* If there are multiple nodes in the sg list, prepare
+		 * to set up subsequent ones in the interrupt handler.
+		 */
+		if (pp->softsg_node != pp->softsg_end) {
+			pp->softsg_node++;
+			writel(1<<8 | 1<<0, mmio + DMAC_MASKTFR);
+		}
+	} else {
+		writel(pp->lli_dma, mmio + DMAC_LLP0);
+	}
+
+	/* Enable DMA on the SATA host */
+	writel(SATA_DMACR_TXCHEN | SATA_DMACR_RXCHEN,
+	       mmio + SATA_DMACR);
+
+DPRINTK("SAR %08x, DAR %08x, CTL0 %08x CTL1 %08x\n",
+       readl(mmio + DMAC_SAR0),
+       readl(mmio + DMAC_DAR0),
+       readl(mmio + DMAC_CTL0_0),
+       readl(mmio + DMAC_CTL0_1));
+DPRINTK("CFG0 %08x CFG1 %08x\n",
+       readl(mmio + DMAC_CFG0_0),
+       readl(mmio + DMAC_CFG0_1));
+DPRINTK("ChEnReg %08x DmaCfgReg %08x\n",
+       readl(mmio + DMAC_ChEnReg),
+       readl(mmio + DMAC_DmaCfgReg));
+
+
+	/* Enable channel 0 */
+	wmb();
+	writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+
+	/* issue r/w command */
+	ata_exec_command(ap, &qc->tf);
+}
+
+static void stm_bmdma_start(struct ata_queued_cmd *qc)
+{
+
+#if 0
+	void __iomem *mmio = (void __iomem *) ap->ioaddr.cmd_addr;
+	struct ata_port *ap = qc->ap;
+	/* Enable channel 0 */
+	writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+#endif
+}
+
+static void stm_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *mmio = (void __iomem *) ap->ioaddr.cmd_addr;
+
+DPRINTK("ENTER\n");
+
+	/*
+	 * Chanel is automatically disabled on completion of DMA, however
+	 * this also gets called from the timeout handler.
+	 */
+
+	/* Disable channel 0 */
+	writel((1<<8) | (0<<0), mmio + DMAC_ChEnReg);
+
+	/* Disable DMA on the SATA host */
+	writel(0, mmio + SATA_DMACR);
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_altstatus(ap);        /* dummy read */
+}
+
+static u8 stm_bmdma_status(struct ata_port *ap)
+{
+	/* We should be checking here whether the current interrupt
+	 * was raised by this SATA host. Unfortuntaly we have no
+	 * visibility of the controller's Interrupt Pending Flag (IPF).
+	 */
+	return ATA_DMA_INTR;
+}
+
+static void stm_fill_sg(struct ata_queued_cmd *qc)
+{
+	struct scatterlist *sg;
+	struct ata_port *ap = qc->ap;
+	struct stm_host_priv *hpriv = ap->host_set->private_data;
+        struct stm_port_priv *pp = ap->private_data;
+        void *mmio = (void *) ap->ioaddr.cmd_addr;
+	unsigned int write = (qc->tf.flags & ATA_TFLAG_WRITE);
+	unsigned int idx;
+	u32 sar, dar, ctl0;
+
+	DPRINTK("ENTER\n");
+
+	WARN_ON(qc->__sg == NULL);
+	WARN_ON(qc->n_elem == 0 && qc->pad_len == 0);
+
+	ctl0 = 	DMAC_CTL_DST_TR_WIDTH_32	|
+		DMAC_CTL_SRC_TR_WIDTH_32	|
+		DMAC_CTL_DINC_INC		|
+		DMAC_CTL_SINC_INC;
+
+	if (write) {
+		/* memory (master1) to SATA host (master2) transfer */
+		ctl0 |= DMAC_CTL_DEST_MSIZE_4		|
+			DMAC_CTL_SRC_MSIZE_16		|
+			DMAC_CTL_TT_FC_M2P_DMAC		|
+			DMAC_CTL_DMS_2			|
+			DMAC_CTL_SMS_1;
+	} else {
+		/* SATA host (master2) to memory (master1) transfer */
+		ctl0 |= DMAC_CTL_DEST_MSIZE_16		|
+			DMAC_CTL_SRC_MSIZE_16		|
+			DMAC_CTL_TT_FC_P2M_DMAC		|
+			DMAC_CTL_DMS_1			|
+			DMAC_CTL_SMS_2;
+	}
+
+	if (! hpriv->softsg) {
+		ctl0 |= DMAC_CTL_LLP_DST_EN	|
+			DMAC_CTL_LLP_SRC_EN;
+	}
+
+	idx = 0;
+	ata_for_each_sg(sg, qc) {
+		u32 addr;
+		u32 sg_len, len;
+
+		addr = sg_dma_address(sg);
+		sg_len = sg_dma_len(sg);
+
+		while (sg_len) {
+			len = sg_len;
+			if (len > DMAC_BLOCK_TS_MAX_BYTES)
+				len = DMAC_BLOCK_TS_MAX_BYTES;
+
+			if (write) {
+				sar = addr;
+				dar = (u32)(mmio + SATA_AHBHOST_BASE);
+			} else {
+				sar = (u32)(mmio + SATA_AHBHOST_BASE);
+				dar = addr;
+			}
+
+			pp->lli[idx].sar = sar;
+			pp->lli[idx].dar = dar;
+			pp->lli[idx].llp = pp->lli_dma +
+				(sizeof(struct stm_lli) * (idx+1));
+			pp->lli[idx].ctl0 = ctl0;
+			pp->lli[idx].ctl1 = len >> 2;
+
+			DPRINTK("lli: %08x: SAR %08x, DAR %08x, CTL0 %08x CTL1 %08x\n",
+				&pp->lli[idx],
+				pp->lli[idx].sar, pp->lli[idx].dar,
+				pp->lli[idx].ctl0, pp->lli[idx].ctl1);
+
+			idx++;
+			sg_len -= len;
+			addr += len;
+		}
+	}
+
+	WARN_ON(idx == 0);
+	pp->lli[idx-1].llp = 0;
+	//	pp->lli[idx-1].ctl0 &= ~(DMAC_CTL_LLP_DST_EN | DMAC_CTL_LLP_SRC_EN);
+
+	if (hpriv->softsg) {
+		pp->softsg_node = pp->lli;
+		pp->softsg_end  = &pp->lli[idx-1];
+	}
+
+}
+
+static void stm_qc_prep(struct ata_queued_cmd *qc)
+{
+	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
+		return;
+
+	stm_fill_sg(qc);
+}
+
+static unsigned long error_count;
+static unsigned int print_error=0;
+
+static irqreturn_t stm_sata_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ata_host_set *host_set = dev_instance;
+	unsigned int handled = 0;
+	unsigned int i;
+	unsigned long flags;
+
+DPRINTK("ENTER\n");
+
+	spin_lock_irqsave(&host_set->lock, flags);
+
+	for (i = 0; i < host_set->n_ports; i++) {
+		struct ata_port *ap;
+		void *mmio;
+
+		ap = host_set->ports[i];
+
+		mmio = (void *) ap->ioaddr.cmd_addr;
+
+		if (readl(mmio + DMAC_STATUSTFR) & 1) {
+			/* DMA Transfer complete update soft S/G */
+			struct stm_port_priv *pp = ap->private_data;
+
+			/* Ack the interrupt */
+			writel(1<<0, mmio + DMAC_CLEARTFR);
+
+			DPRINTK("softsg_node %08x, end %08x\n", pp->softsg_node, pp->softsg_end);
+
+			writel(pp->softsg_node->sar, mmio + DMAC_SAR0);
+			writel(pp->softsg_node->dar, mmio + DMAC_DAR0);
+
+			writel(pp->softsg_node->ctl0, mmio + DMAC_CTL0_0);
+			writel(pp->softsg_node->ctl1, mmio + DMAC_CTL0_1);
+
+			if (pp->softsg_node != pp->softsg_end) {
+				pp->softsg_node++;
+			} else {
+				writel(1<<8 | 0<<0, mmio + DMAC_MASKTFR);
+			}
+
+			writel((1<<8) | (1<<0), mmio + DMAC_ChEnReg);
+		} else
+		if (readl(mmio + SATA_INTPR) & (SATA_INT_ERR)) {
+			/* Error code set in SError */
+			if (print_error) {
+				printk("%s: SStatus 0x%08x, SError 0x%08x\n", __FUNCTION__,
+				       scr_read(ap, SCR_STATUS),
+				       scr_read(ap, SCR_ERROR));
+			}
+			error_count++;
+			scr_write(ap, SCR_ERROR, -1);
+			handled = 1;
+		} else
+		if (ap && (!(ap->flags & ATA_FLAG_PORT_DISABLED))) {
+			struct ata_queued_cmd *qc;
+
+			qc = ata_qc_from_tag(ap, ap->active_tag);
+			if (qc && (!(qc->tf.ctl & ATA_NIEN)))
+				handled += ata_host_intr(ap, qc);
+		}
+
+	}
+
+	spin_unlock_irqrestore(&host_set->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static void stm_irq_clear(struct ata_port *ap)
+{
+	/* TODO */
+}
+
+
+static u32 stm_sata_scr_read (struct ata_port *ap, unsigned int sc_reg)
+{
+	//struct ata_host_set *host_set = ap->host_set;
+	void* mmio = (void *) ap->ioaddr.cmd_addr;
+	u32 val;
+
+	if (sc_reg > SCR_CONTROL)
+		return 0xffffffffU;
+
+	val = readl(mmio + SATA_SCR0 + (sc_reg * 4));
+	return val;
+}
+
+static void stm_sata_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val)
+{
+	//struct ata_host_set *host_set = ap->host_set;
+	void* mmio = (void *) ap->ioaddr.cmd_addr;
+
+DPRINTK("%d = %08x\n", sc_reg, val);
+	if (sc_reg > SCR_CONTROL)
+		return;
+
+	writel(val, mmio + SATA_SCR0 + (sc_reg * 4));
+}
+
+static int stm_port_start (struct ata_port *ap)
+{
+	struct device *dev = ap->host_set->dev;
+	struct stm_host_priv *hpriv = ap->host_set->private_data;
+	struct stm_port_priv *pp;
+	int result = 0;
+
+	pp = kcalloc(1, sizeof(*pp), GFP_KERNEL);
+        if (pp == NULL) {
+		result = -ENOMEM;
+		goto out;
+        }
+
+	if (hpriv->softsg) {
+		pp->lli = kmalloc(STM_LLI_BYTES, GFP_KERNEL);
+	} else {
+		pp->lli = dma_alloc_coherent(dev, STM_LLI_BYTES, &pp->lli_dma,
+					     GFP_KERNEL);
+	}
+
+	if (pp->lli == NULL) {
+		result = -ENOMEM;
+		goto out1;
+	}
+
+	ap->private_data = pp;
+	return result;
+
+out1:
+	kfree(pp);
+out:
+	ata_port_stop(ap);
+	return result;
+}
+
+static void stm_port_stop (struct ata_port *ap)
+{
+	struct device *dev = ap->host_set->dev;
+	struct stm_host_priv *hpriv = ap->host_set->private_data;
+	struct stm_port_priv *pp = ap->private_data;
+
+	if (pp != NULL) {
+		ap->private_data = NULL;
+		if (pp->lli != NULL) {
+			if (hpriv->softsg) {
+				kfree(pp->lli);
+			} else {
+				dma_free_coherent(dev, STM_LLI_BYTES, pp->lli,
+						  pp->lli_dma);
+			}
+		}
+		kfree(pp);
+	}
+	ata_port_stop(ap);
+}
+
+static ssize_t stm_show_serror(struct class_device *class_dev, char *buf)
+{
+	//struct Scsi_Host *host = class_to_shost(class_dev);
+	ssize_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%ld\n", error_count);
+	return len;
+}
+
+static ssize_t stm_store_serror(struct class_device * class_dev,
+			       const char * buf, size_t count)
+{
+	// struct Scsi_Host *host = class_to_shost(class_dev);
+
+	error_count = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+
+static struct class_device_attribute stm_host_stats_attr = {
+	.attr = {
+		.name =		"serror",
+		.mode =		S_IRUGO | S_IWUGO,
+	},
+	.show = stm_show_serror,
+	.store = stm_store_serror,
+};
+
+static ssize_t stm_show_printerror(struct class_device *class_dev, char *buf)
+{
+	//struct Scsi_Host *host = class_to_shost(class_dev);
+	ssize_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%d\n", print_error);
+	return len;
+}
+
+static ssize_t stm_store_printerror(struct class_device * class_dev,
+			       const char * buf, size_t count)
+{
+	// struct Scsi_Host *host = class_to_shost(class_dev);
+
+	print_error = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+
+static struct class_device_attribute stm_host_printerror_attr = {
+	.attr = {
+		.name =		"printerror",
+		.mode =		S_IRUGO | S_IWUGO,
+	},
+	.show = stm_show_printerror,
+	.store = stm_store_printerror,
+};
+
+/* Host attributes initializer */
+static struct class_device_attribute *stm_host_attrs[] = {
+	&stm_host_stats_attr,
+	&stm_host_printerror_attr,
+	NULL,
+};
+
+static struct scsi_host_template stm_sata_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.bios_param		= ata_std_bios_param,
+	.shost_attrs		= stm_host_attrs,
+};
+
+static struct ata_port_operations stm_sata_ops = {
+	.port_disable		= ata_port_disable,
+	.tf_load		= ata_tf_load,
+	.tf_read		= ata_tf_read,
+	.exec_command		= ata_exec_command,
+	.check_status		= ata_check_status,
+	.dev_select		= ata_noop_dev_select,
+	.phy_reset		= stm_phy_reset,
+	.bmdma_setup            = stm_bmdma_setup,
+	.bmdma_start            = stm_bmdma_start,
+	.bmdma_stop		= stm_bmdma_stop,
+	.bmdma_status		= stm_bmdma_status,
+	.qc_prep		= stm_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+	.eng_timeout		= ata_eng_timeout,
+	.irq_handler		= stm_sata_interrupt,
+	.irq_clear		= stm_irq_clear,
+	.scr_read		= stm_sata_scr_read,
+	.scr_write		= stm_sata_scr_write,
+	.port_start		= stm_port_start,
+	.port_stop		= stm_port_stop,
+};
+
+static unsigned char stm_readb(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static unsigned short stm_readw(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static void stm_writeb(unsigned char b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
+static void stm_writew(unsigned short b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
+static int __init stm_sata_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct plat_sata_data *sata_private_info = pdev->dev.platform_data;
+	struct resource *mem_res;
+	int retval = 0;
+	unsigned long phys_base, phys_size;
+	void* virt_base;
+	unsigned long mmio_base;
+	struct ata_probe_ent *probe_ent = NULL;
+	struct stm_host_priv *hpriv = NULL;
+	unsigned long sata_rev, dmac_rev;
+
+	printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	mem_res = platform_get_resource(pdev,IORESOURCE_MEM,0);
+	phys_base = mem_res->start;
+	phys_size = mem_res->end - mem_res->start + 1;
+
+	if (!request_mem_region(phys_base, phys_size, "STM SATA")) {
+		retval = -EBUSY;
+		return retval;
+	}
+
+	probe_ent = kmalloc(sizeof(*probe_ent), GFP_KERNEL);
+	if (probe_ent == NULL) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+	memset(probe_ent, 0, sizeof(*probe_ent));
+	probe_ent->dev = dev;
+	INIT_LIST_HEAD(&probe_ent->node);
+
+	virt_base = ioremap(phys_base, phys_size);
+	if (virt_base == NULL) {
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	mmio_base = (unsigned long)virt_base;
+
+	hpriv = kmalloc(sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv) {
+		retval = -ENOMEM;
+		goto err3;
+	}
+	memset(hpriv, 0, sizeof(*hpriv));
+
+	probe_ent->sht = &stm_sata_sht;
+	probe_ent->host_flags = ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
+				ATA_FLAG_MMIO | ATA_FLAG_SATA_RESET;
+	probe_ent->port_ops = &stm_sata_ops;
+	probe_ent->n_ports = 1;
+	probe_ent->irq = platform_get_irq(pdev, 0);
+	probe_ent->irq_flags = SA_SHIRQ;
+	probe_ent->mmio_base = virt_base;
+
+	/* We don't care much about the PIO/UDMA masks, but the core won't like us
+	 * if we don't fill these
+	 */
+	probe_ent->pio_mask = 0x1f;
+	probe_ent->mwdma_mask = 0x07;
+	probe_ent->udma_mask = 0x7f;
+
+	/* Set up the ports */
+	probe_ent->port[0].cmd_addr	= mmio_base;
+	probe_ent->port[0].data_addr	= mmio_base + SATA_CDR0;
+	probe_ent->port[0].error_addr	= mmio_base + SATA_CDR1;
+	probe_ent->port[0].feature_addr	= mmio_base + SATA_CDR1;
+	probe_ent->port[0].nsect_addr	= mmio_base + SATA_CDR2;
+	probe_ent->port[0].lbal_addr	= mmio_base + SATA_CDR3;
+	probe_ent->port[0].lbam_addr	= mmio_base + SATA_CDR4;
+	probe_ent->port[0].lbah_addr	= mmio_base + SATA_CDR5;
+	probe_ent->port[0].device_addr	= mmio_base + SATA_CDR6;
+	probe_ent->port[0].status_addr	= mmio_base + SATA_CDR7;
+	probe_ent->port[0].command_addr	= mmio_base + SATA_CDR7;
+
+	probe_ent->port[0].altstatus_addr	= mmio_base + SATA_CLR0;
+	probe_ent->port[0].ctl_addr		= mmio_base + SATA_CLR0;
+	probe_ent->port[0].bmdma_addr		= 0; // FIXME
+	probe_ent->port[0].scr_addr		= 0; // FIXME
+
+	probe_ent->private_data = hpriv;
+
+	hpriv->phy_init = sata_private_info->phy_init;
+	hpriv->softsg = readl(mmio_base + DMAC_COMP_PARAMS_2) &
+		DMAC_COMP_PARAMS_2_CH0_HC_LLP;
+	//hpriv->softsg = 1;
+
+	printk(KERN_DEBUG DRV_NAME " using %sware scatter/gather\n",
+	       hpriv->softsg ? "soft" : "hard");
+
+	if (sata_private_info->only_32bit) {
+		printk(KERN_DEBUG DRV_NAME " forcing all byte/word ops to long\n");
+		stm_sata_ops.readb = stm_readb;
+		stm_sata_ops.readw = stm_readw;
+		stm_sata_ops.writeb = stm_writeb;
+		stm_sata_ops.writew = stm_writew;
+	}
+
+	sata_rev = readl(mmio_base + SATA_VERSIONR);
+	dmac_rev = readl(mmio_base + DMAC_COMP_VERSION);
+	printk(KERN_DEBUG DRV_NAME " SATA version %c.%c%c DMA version %c.%c%c\n",
+	       (int)(sata_rev >> 24) & 0xff,
+	       (int)(sata_rev >> 16) & 0xff,
+	       (int)(sata_rev >>  8) & 0xff,
+	       (int)(dmac_rev >> 24) & 0xff,
+	       (int)(dmac_rev >> 16) & 0xff,
+	       (int)(dmac_rev >>  8) & 0xff);
+
+	/* AHB bus wrapper setup */
+
+        // SATA_AHB2STBUS_STBUS_OPC
+        // 2:0  -- 100 = Store64/Load64
+        // 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	/* opcode = Load4 |Store 4*/
+	writel(3, mmio_base + SATA_AHB2STBUS_STBUS_OPC);
+
+        // SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+        // 3:0  -- 0111 = 128 Packets
+        // 3:0  -- 0110 =  64 Packets
+	/* WAS: Message size = 64 packet when 6 now 3*/
+	writel(3, mmio_base + SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+        // SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+        // 3:0  -- 0110 = 64 Packets
+        // 3:0  -- 0001 =  2 Packets
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(2, mmio_base + SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+        // PC_GLUE_LOGIC
+        // 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+        // 8    -- 1  = Time out enabled
+	// (has bit 8 moved to bit 16 on 7109 cut2?)
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+	writel(sata_private_info->pc_glue_logic_init,
+		mmio_base + SATA_PC_GLUE_LOGIC);
+
+	/* DMA controller set up */
+
+	/* Enable DMA controller */
+	writel(DMAC_DmaCfgReg_DMA_EN, mmio_base + DMAC_DmaCfgReg);
+
+	if (ata_device_add(probe_ent) == 0) {
+		retval = -ENODEV;
+		goto err4;
+	}
+
+	/* SATA host controller set up */
+
+	/* Clear serror register following probe, and before we enable
+	 * interrupts! */
+	/* scr_write(ap, SCR_ERROR, -1); */
+	writel(-1, mmio_base + SATA_SCR1);
+
+	/* Set Rx and Tx FIFO threshholds to 16 DWORDS */
+	/* Note Validation code refers to "Anupam JAIN's document" where this
+	 * is set to 0x70002 for writes (0x100010 for reads).
+	 */
+	writel((0x10 << 16) | (0x10 << 0), mmio_base + SATA_DBTSR);
+
+	/* Enable notification of errors */
+	writel(0xffffffff, mmio_base + SATA_ERRMR);
+	writel(SATA_INT_ERR, mmio_base + SATA_INTMR);
+
+	kfree(probe_ent);
+
+	return 0;
+
+err4:
+	kfree(hpriv);
+err3:
+	iounmap(virt_base);
+err2:
+	kfree(probe_ent);
+err1:
+	release_mem_region(phys_base, phys_size);
+
+	return retval;
+}
+
+static int stm_sata_remove(struct device *dev)
+{
+	return 0;
+}
+
+static struct device_driver stm_sata_driver = {
+	.name = "stm-sata",
+	.bus  = &platform_bus_type,
+	.probe = stm_sata_probe,
+	.remove = stm_sata_remove,
+};
+
+static int __init stm_sata_init(void)
+{
+	return driver_register(&stm_sata_driver);
+}
+
+static void __exit stm_sata_exit(void)
+{
+	driver_unregister(&stm_sata_driver);
+}
+
+module_init(stm_sata_init);
+module_exit(stm_sata_exit);
diff -Naur linux-2.6.17.8/drivers/serial/8250.c linux-2.6.17.8-sh/drivers/serial/8250.c
--- linux-2.6.17.8/drivers/serial/8250.c	2006-08-21 14:42:23.187771000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/8250.c	2006-08-23 13:29:07.902886000 +0100
@@ -193,6 +193,9 @@
 		.fifo_size	= 32,
 		.tx_loadsz	= 16,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
+#ifdef CONFIG_SH_RTS7751R2D
+				  UART_FCR_TRIGGER_14 |
+#endif
 				  UART_FCR_T_TRIG_00,
 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
 	},
@@ -440,8 +443,13 @@
 {
 	if (p->capabilities & UART_CAP_SLEEP) {
 		if (p->capabilities & UART_CAP_EFR) {
+			int efr = UART_EFR_ECB;
+
 			serial_outp(p, UART_LCR, 0xBF);
-			serial_outp(p, UART_EFR, UART_EFR_ECB);
+#ifdef CONFIG_SH_RTS7751R2D
+			efr |= UART_EFR_CTS | UART_EFR_RTS;
+#endif
+			serial_outp(p, UART_EFR, efr);
 			serial_outp(p, UART_LCR, 0);
 		}
 		serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
@@ -672,10 +680,16 @@
 	 * since that's the technique that was sent to me in the
 	 * serial driver update, but I'm not convinced this works.
 	 * I've had problems doing this in the past.  -TYT
+	 *
+	 * No, this won't work for everyone. At least in the RTS7751R2D
+	 * case we have a '650 with a 64 byte FIFO, so this ends up breaking
+	 * there.  -PFM
 	 */
+#ifndef CONFIG_SH_RTS7751R2D
 	if (size_fifo(up) == 64)
 		up->port.type = PORT_16654;
 	else
+#endif
 		up->port.type = PORT_16650V2;
 }
 
diff -Naur linux-2.6.17.8/drivers/serial/Kconfig linux-2.6.17.8-sh/drivers/serial/Kconfig
--- linux-2.6.17.8/drivers/serial/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/Kconfig	2006-08-23 13:29:31.175438000 +0100
@@ -936,4 +936,17 @@
 	  If you have an SGI Altix with an IOC3 serial card,
 	  say Y or M.  Otherwise, say N.
 
+config SERIAL_ST_ASC
+	tristate "ST ASC serial port support"
+	depends on CPU_SUBTYPE_ST40
+	select SERIAL_CORE
+	help
+	  This driver is for the on-chip Asychronous Serial Controller on
+	  some STMicroelectronics system-on-chip devices.
+
+config SERIAL_ST_ASC_CONSOLE
+	bool "Support for console on ST ASC"
+	depends on SERIAL_ST_ASC=y
+	select SERIAL_CORE_CONSOLE
+
 endmenu
diff -Naur linux-2.6.17.8/drivers/serial/Makefile linux-2.6.17.8-sh/drivers/serial/Makefile
--- linux-2.6.17.8/drivers/serial/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/Makefile	2006-08-23 13:29:31.206438000 +0100
@@ -55,3 +55,4 @@
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
 obj-$(CONFIG_SERIAL_SGI_IOC3) += ioc3_serial.o
 obj-$(CONFIG_SERIAL_AT91) += at91_serial.o
+obj-$(CONFIG_SERIAL_ST_ASC) += stasc.o
diff -Naur linux-2.6.17.8/drivers/serial/sh-sci.c linux-2.6.17.8-sh/drivers/serial/sh-sci.c
--- linux-2.6.17.8/drivers/serial/sh-sci.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/sh-sci.c	2006-08-23 13:29:29.687392000 +0100
@@ -3,7 +3,7 @@
  *
  * SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
  *
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002 - 2006  Paul Mundt
  *
  * based off of the old drivers/char/sh-sci.c by:
  *
@@ -56,10 +56,8 @@
 
 #if defined(CONFIG_SUPERH) && !defined(CONFIG_SUPERH64)
 #include <asm/clock.h>
-#endif
-
-#ifdef CONFIG_SH_STANDARD_BIOS
 #include <asm/sh_bios.h>
+#include <asm/kgdb.h>
 #endif
 
 #if defined(CONFIG_SERIAL_SH_SCI_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
@@ -69,25 +67,15 @@
 #include "sh-sci.h"
 
 #ifdef CONFIG_SH_KGDB
-#include <asm/kgdb.h>
-
-static int kgdb_get_char(struct sci_port *port);
-static void kgdb_put_char(struct sci_port *port, char c);
-static void kgdb_handle_error(struct sci_port *port);
 static struct sci_port *kgdb_sci_port;
-#endif /* CONFIG_SH_KGDB */
+#endif
 
 #ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
-static struct sci_port *serial_console_port = 0;
-#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
+static struct sci_port *serial_console_port;
+#endif
 
 /* Function prototypes */
 static void sci_stop_tx(struct uart_port *port);
-static void sci_start_tx(struct uart_port *port);
-static void sci_start_rx(struct uart_port *port, unsigned int tty_start);
-static void sci_stop_rx(struct uart_port *port);
-static int sci_request_irq(struct sci_port *port);
-static void sci_free_irq(struct sci_port *port);
 
 static struct sci_port sci_ports[];
 static struct uart_driver sci_uart_driver;
@@ -95,9 +83,9 @@
 #define SCI_NPORTS sci_uart_driver.nr
 
 #if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
-
-static void handle_error(struct uart_port *port)
-{				/* Clear error flags */
+static inline void handle_error(struct uart_port *port)
+{
+	/* Clear error flags */
 	sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));
 }
 
@@ -122,28 +110,9 @@
 
 	return c;
 }
-
-/* Taken from sh-stub.c of GDB 4.18 */
-static const char hexchars[] = "0123456789abcdef";
-
-static __inline__ char highhex(int  x)
-{
-	return hexchars[(x >> 4) & 0xf];
-}
-
-static __inline__ char lowhex(int  x)
-{
-	return hexchars[x & 0xf];
-}
-
 #endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
 
-/*
- * Send the packet in buffer.  The host gets one chance to read it.
- * This routine does not wait for a positive acknowledge.
- */
-
-#ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
+#if defined(CONFIG_SERIAL_SH_SCI_CONSOLE) || defined(CONFIG_SH_KGDB)
 static void put_char(struct uart_port *port, char c)
 {
 	unsigned long flags;
@@ -161,7 +130,9 @@
 
 	local_irq_restore(flags);
 }
+#endif
 
+#ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
 static void put_string(struct sci_port *sci_port, const char *buffer, int count)
 {
 	struct uart_port *port = &sci_port->port;
@@ -214,96 +185,28 @@
 }
 #endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
 
-
 #ifdef CONFIG_SH_KGDB
-
-/* Is the SCI ready, ie is there a char waiting? */
-static int kgdb_is_char_ready(struct sci_port *port)
-{
-        unsigned short status = sci_in(port, SCxSR);
-
-        if (status & (SCxSR_ERRORS(port) | SCxSR_BRK(port)))
-                kgdb_handle_error(port);
-
-        return (status & SCxSR_RDxF(port));
-}
-
-/* Write a char */
-static void kgdb_put_char(struct sci_port *port, char c)
-{
-        unsigned short status;
-
-        do
-                status = sci_in(port, SCxSR);
-        while (!(status & SCxSR_TDxE(port)));
-
-        sci_out(port, SCxTDR, c);
-        sci_in(port, SCxSR);    /* Dummy read */
-        sci_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));
-}
-
-/* Get a char if there is one, else ret -1 */
-static int kgdb_get_char(struct sci_port *port)
-{
-        int c;
-
-        if (kgdb_is_char_ready(port) == 0)
-                c = -1;
-        else {
-                c = sci_in(port, SCxRDR);
-                sci_in(port, SCxSR);    /* Dummy read */
-                sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
-        }
-
-        return c;
-}
-
-/* Called from kgdbstub.c to get a character, i.e. is blocking */
 static int kgdb_sci_getchar(void)
 {
-        volatile int c;
+        int c;
 
         /* Keep trying to read a character, this could be neater */
-        while ((c = kgdb_get_char(kgdb_sci_port)) < 0);
+        while ((c = get_char(kgdb_sci_port)) < 0)
+		cpu_relax();
 
         return c;
 }
 
-/* Called from kgdbstub.c to put a character, just a wrapper */
-static void kgdb_sci_putchar(int c)
+static inline void kgdb_sci_putchar(int c)
 {
-
-        kgdb_put_char(kgdb_sci_port, c);
+        put_char(kgdb_sci_port, c);
 }
-
-/* Clear any errors on the SCI */
-static void kgdb_handle_error(struct sci_port *port)
-{
-        sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));  /* Clear error flags */
-}
-
-/* Breakpoint if there's a break sent on the serial port */
-static void kgdb_break_interrupt(int irq, void *ptr, struct pt_regs *regs)
-{
-        struct sci_port *port = ptr;
-        unsigned short status = sci_in(port, SCxSR);
-
-        if (status & SCxSR_BRK(port)) {
-
-                /* Break into the debugger if a break is detected */
-                BREAKPOINT();
-
-                /* Clear */
-                sci_out(port, SCxSR, SCxSR_BREAK_CLEAR(port));
-        }
-}
-
 #endif /* CONFIG_SH_KGDB */
 
 #if defined(__H8300S__)
 enum { sci_disable, sci_enable };
 
-static void h8300_sci_enable(struct uart_port* port, unsigned int ctrl)
+static void h8300_sci_config(struct uart_port* port, unsigned int ctrl)
 {
 	volatile unsigned char *mstpcrl=(volatile unsigned char *)MSTPCRL;
 	int ch = (port->mapbase  - SMR0) >> 3;
@@ -315,6 +218,16 @@
 		*mstpcrl &= ~mask;
 	}
 }
+
+static inline void h8300_sci_enable(struct uart_port *port)
+{
+	h8300_sci_config(port, sci_enable);
+}
+
+static inline void h8300_sci_disable(struct uart_port *port)
+{
+	h8300_sci_config(port, sci_disable);
+}
 #endif
 
 #if defined(SCI_ONLY) || defined(SCI_AND_SCIF)
@@ -324,8 +237,13 @@
 	int ch = (port->mapbase - SMR0) >> 3;
 
 	/* set DDR regs */
-	H8300_GPIO_DDR(h8300_sci_pins[ch].port,h8300_sci_pins[ch].rx,H8300_GPIO_INPUT);
-	H8300_GPIO_DDR(h8300_sci_pins[ch].port,h8300_sci_pins[ch].tx,H8300_GPIO_OUTPUT);
+	H8300_GPIO_DDR(h8300_sci_pins[ch].port,
+		       h8300_sci_pins[ch].rx,
+		       H8300_GPIO_INPUT);
+	H8300_GPIO_DDR(h8300_sci_pins[ch].port,
+		       h8300_sci_pins[ch].tx,
+		       H8300_GPIO_OUTPUT);
+
 	/* tx mark output*/
 	H8300_SCI_DR(ch) |= h8300_sci_pins[ch].tx;
 }
@@ -380,7 +298,6 @@
 }
 #endif
 #else
-
 /* For SH7750 */
 static void sci_init_pins_scif(struct uart_port *port, unsigned int cflag)
 {
@@ -397,10 +314,41 @@
 	}
 	sci_out(port, SCFCR, fcr_val);
 }
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7760) || defined(CONFIG_CPU_SUBTYPE_SH7780)
+static inline int scif_txroom(struct uart_port *port)
+{
+	return SCIF_TXROOM_MAX - (sci_in(port, SCTFDR) & 0x7f);
+}
+
+static inline int scif_rxroom(struct uart_port *port)
+{
+	return sci_in(port, SCRFDR) & 0x7f;
+}
+#else
+static inline int scif_txroom(struct uart_port *port)
+{
+	return SCIF_TXROOM_MAX - (sci_in(port, SCFDR) >> 8);
+}
 
+static inline int scif_rxroom(struct uart_port *port)
+{
+	return sci_in(port, SCFDR) & SCIF_RFDC_MASK;
+}
 #endif
 #endif /* SCIF_ONLY || SCI_AND_SCIF */
 
+static inline int sci_txroom(struct uart_port *port)
+{
+	return ((sci_in(port, SCxSR) & SCI_TDRE) != 0);
+}
+
+static inline int sci_rxroom(struct uart_port *port)
+{
+	return ((sci_in(port, SCxSR) & SCxSR_RDxF(port)) != 0);
+}
+
 /* ********************************************************************** *
  *                   the interrupt related routines                       *
  * ********************************************************************** */
@@ -412,7 +360,7 @@
 	unsigned long flags;
 	unsigned short status;
 	unsigned short ctrl;
-	int count, txroom;
+	int count;
 
 	status = sci_in(port, SCxSR);
 	if (!(status & SCxSR_TDxE(port))) {
@@ -428,21 +376,12 @@
 		return;
 	}
 
-#if !defined(SCI_ONLY)
-	if (port->type == PORT_SCIF) {
-#if defined(CONFIG_CPU_SUBTYPE_SH7760) || defined(CONFIG_CPU_SUBTYPE_SH7780)
-		txroom = SCIF_TXROOM_MAX - (sci_in(port, SCTFDR) & 0x7f);
-#else
-		txroom = SCIF_TXROOM_MAX - (sci_in(port, SCFDR)>>8);
-#endif
-	} else {
-		txroom = (sci_in(port, SCxSR) & SCI_TDRE)?1:0;
-	}
-#else
-	txroom = (sci_in(port, SCxSR) & SCI_TDRE)?1:0;
+#ifndef SCI_ONLY
+	if (port->type == PORT_SCIF)
+		count = scif_txroom(port);
+	else
 #endif
-
-	count = txroom;
+		count = sci_txroom(port);
 
 	do {
 		unsigned char c;
@@ -491,6 +430,7 @@
 static inline void sci_receive_chars(struct uart_port *port,
 				     struct pt_regs *regs)
 {
+	struct sci_port *sci_port = (struct sci_port *)port;
 	struct tty_struct *tty = port->info->tty;
 	int i, count, copied = 0;
 	unsigned short status;
@@ -502,18 +442,11 @@
 
 	while (1) {
 #if !defined(SCI_ONLY)
-		if (port->type == PORT_SCIF) {
-#if defined(CONFIG_CPU_SUBTYPE_SH7760) || defined(CONFIG_CPU_SUBTYPE_SH7780)
-			count = sci_in(port, SCRFDR) & 0x7f;
-#else
-			count = sci_in(port, SCFDR)&SCIF_RFDC_MASK ;
-#endif
-		} else {
-			count = (sci_in(port, SCxSR)&SCxSR_RDxF(port))?1:0;
-		}
-#else
-		count = (sci_in(port, SCxSR)&SCxSR_RDxF(port))?1:0;
+		if (port->type == PORT_SCIF)
+			count = scif_rxroom(port);
+		else
 #endif
+			count = sci_rxroom(port);
 
 		/* Don't copy more bytes than there is room for in the buffer */
 		count = tty_buffer_request_room(tty, count);
@@ -524,10 +457,9 @@
 
 		if (port->type == PORT_SCI) {
 			char c = sci_in(port, SCxRDR);
-                       if(((struct sci_port *)port)->break_flag
-			    || uart_handle_sysrq_char(port, c, regs)) {
+			if (uart_handle_sysrq_char(port, c, regs) || sci_port->break_flag)
 				count = 0;
-			} else {
+			else {
 			    tty_insert_flip_char(tty, c, TTY_NORMAL);
 			}
 		} else {
@@ -536,15 +468,17 @@
 				status = sci_in(port, SCxSR);
 #if defined(CONFIG_CPU_SH3)
 				/* Skip "chars" during break */
-				if (((struct sci_port *)port)->break_flag) {
+				if (sci_port->break_flag) {
 					if ((c == 0) &&
 					    (status & SCxSR_FER(port))) {
 						count--; i--;
 						continue;
 					}
+
 					/* Nonzero => end-of-break */
 					pr_debug("scif: debounce<%02x>\n", c);
-					((struct sci_port *)port)->break_flag = 0;
+					sci_port->break_flag = 0;
+
 					if (STEPFN(c)) {
 						count--; i--;
 						continue;
@@ -601,15 +535,17 @@
 /* Ensure that two consecutive samples find the break over. */
 static void sci_break_timer(unsigned long data)
 {
-    struct sci_port * port = (struct sci_port *)data;
-	if(sci_rxd_in(&port->port) == 0) {
+	struct sci_port *port = (struct sci_port *)data;
+
+	if (sci_rxd_in(&port->port) == 0) {
 		port->break_flag = 1;
-	    sci_schedule_break_timer(port);
-	} else if(port->break_flag == 1){
+		sci_schedule_break_timer(port);
+	} else if (port->break_flag == 1) {
 		/* break is over. */
 		port->break_flag = 2;
-	    sci_schedule_break_timer(port);
-	} else port->break_flag = 0;
+		sci_schedule_break_timer(port);
+	} else
+		port->break_flag = 0;
 }
 
 static inline int sci_handle_errors(struct uart_port *port)
@@ -618,29 +554,30 @@
 	unsigned short status = sci_in(port, SCxSR);
 	struct tty_struct *tty = port->info->tty;
 
-	if (status&SCxSR_ORER(port)) {
+	if (status & SCxSR_ORER(port)) {
 		/* overrun error */
 		if(tty_insert_flip_char(tty, 0, TTY_OVERRUN))
 			copied++;
 		pr_debug("sci: overrun error\n");
 	}
 
-	if (status&SCxSR_FER(port)) {
+	if (status & SCxSR_FER(port)) {
 		if (sci_rxd_in(port) == 0) {
 			/* Notify of BREAK */
-			struct sci_port * sci_port = (struct sci_port *)port;
-			if(!sci_port->break_flag) {
-	                	sci_port->break_flag = 1;
-	                	sci_schedule_break_timer((struct sci_port *)port);
+			struct sci_port *sci_port = (struct sci_port *)port;
+
+			if (!sci_port->break_flag) {
+				sci_port->break_flag = 1;
+				sci_schedule_break_timer(sci_port);
+
 				/* Do sysrq handling. */
-				if(uart_handle_break(port))
+				if (uart_handle_break(port))
 					return 0;
 			        pr_debug("sci: BREAK detected\n");
 			        if(tty_insert_flip_char(tty, 0, TTY_BREAK))
 				        copied++;
                        }
-		}
-		else {
+		} else {
 			/* frame error */
 			if(tty_insert_flip_char(tty, 0, TTY_FRAME))
 				copied++;
@@ -648,10 +585,10 @@
 		}
 	}
 
-	if (status&SCxSR_PER(port)) {
+	if (status & SCxSR_PER(port)) {
+		/* parity error */
 		if(tty_insert_flip_char(tty, 0, TTY_PARITY))
 			copied++;
-		/* parity error */
 		pr_debug("sci: parity error\n");
 	}
 
@@ -756,6 +693,12 @@
 
 	/* Handle BREAKs */
 	sci_handle_breaks(port);
+
+#ifdef CONFIG_SH_KGDB
+	/* Break into the debugger if a break is detected */
+	BREAKPOINT();
+#endif
+
 	sci_out(port, SCxSR, SCxSR_BREAK_CLEAR(port));
 
 	return IRQ_HANDLED;
@@ -964,9 +907,8 @@
 {
 	struct sci_port *s = &sci_ports[port->line];
 
-#if defined(__H8300S__)
-	h8300_sci_enable(port, sci_enable);
-#endif
+	if (s->enable)
+		s->enable(port);
 
 	sci_request_irq(s);
 	sci_start_tx(port);
@@ -983,9 +925,8 @@
 	sci_stop_tx(port);
 	sci_free_irq(s);
 
-#if defined(__H8300S__)
-	h8300_sci_enable(port, sci_disable);
-#endif
+	if (s->disable)
+		s->disable(port);
 }
 
 static void sci_set_termios(struct uart_port *port, struct termios *termios,
@@ -1335,7 +1276,7 @@
 		.irqs		= SH7760_SCIF2_IRQS,
 		.init_pins	= sci_init_pins_scif,
 	},
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
 	{
 		.port	= {
 			.membase	= (void *)0xffe00000,
@@ -1434,6 +1375,8 @@
 		.type		= PORT_SCI,
 		.irqs		= H8S_SCI_IRQS0,
 		.init_pins	= sci_init_pins_sci,
+		.enable		= h8300_sci_enable,
+		.disable	= h8300_sci_disable,
 	},
 	{
 		.port	= {
@@ -1448,6 +1391,8 @@
 		.type		= PORT_SCI,
 		.irqs		= H8S_SCI_IRQS1,
 		.init_pins	= sci_init_pins_sci,
+		.enable		= h8300_sci_enable,
+		.disable	= h8300_sci_disable,
 	},
 	{
 		.port	= {
@@ -1462,6 +1407,8 @@
 		.type		= PORT_SCI,
 		.irqs		= H8S_SCI_IRQS2,
 		.init_pins	= sci_init_pins_sci,
+		.enable		= h8300_sci_enable,
+		.disable	= h8300_sci_disable,
 	},
 #elif defined(CONFIG_CPU_SUBTYPE_SH7770)
 	{
@@ -1569,19 +1516,21 @@
 	sci_config_port(port, 0);
 #endif
 
+	if (serial_console_port->enable)
+		serial_console_port->enable(port);
+
 	/*
 	 * We need to set the initial uartclk here, since otherwise it will
 	 * only ever be setup at sci_init() time.
 	 */
 #if defined(__H8300H__) || defined(__H8300S__)
 	port->uartclk = CONFIG_CPU_CLOCK;
-
-#if defined(__H8300S__)
-	h8300_sci_enable(port, sci_enable);
-#endif
 #elif defined(CONFIG_SUPERH64)
 	port->uartclk = current_cpu_info.module_clock * 16;
 #else
+	/*
+	 * XXX: Use a proper clock for SCI/SCIF
+	 */
 	{
 		struct clk *clk = clk_get("module_clk");
 		port->uartclk = clk_get_rate(clk) * 16;
@@ -1726,6 +1675,7 @@
 #elif defined(CONFIG_SUPERH64)
 			sciport->port.uartclk = current_cpu_info.module_clock * 16;
 #else
+			/* XXX: We should use a proper SCI/SCIF clock */
 			struct clk *clk = clk_get("module_clk");
 			sciport->port.uartclk = clk_get_rate(clk) * 16;
 			clk_put(clk);
@@ -1762,3 +1712,4 @@
 module_init(sci_init);
 module_exit(sci_exit);
 
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/serial/sh-sci.h linux-2.6.17.8-sh/drivers/serial/sh-sci.h
--- linux-2.6.17.8/drivers/serial/sh-sci.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/sh-sci.h	2006-08-23 13:29:29.712392000 +0100
@@ -111,7 +111,7 @@
 # define SCIF_ORER 0x0001   /* overrun error bit */
 # define SCSCR_INIT(port) 0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
 # define SCIF_ONLY
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
 # define SCSPTR1 0xffe00020 /* 16 bit SCIF */
 # define SCSPTR2 0xffe80020 /* 16 bit SCIF */
 # define SCIF_ORER 0x0001   /* overrun error bit */
@@ -279,6 +279,8 @@
 	int type;
 	unsigned char irqs[4]; /* ERI, RXI, TXI, BRI */
 	void (*init_pins)(struct uart_port *port, unsigned int cflag);
+	void (*enable)(struct uart_port *port);
+	void (*disable)(struct uart_port *port);
 	int break_flag;
 	struct timer_list break_timer;
 };
@@ -505,7 +507,7 @@
 {
 	return ctrl_inb(SCPDR)&0x01 ? 1 : 0; /* SCIF0 */
 }
-#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#elif defined(CONFIG_CPU_SUBTYPE_ST40)
 static inline int sci_rxd_in(struct uart_port *port)
 {
 	if (port->mapbase == 0xffe00000)
diff -Naur linux-2.6.17.8/drivers/serial/stasc.c linux-2.6.17.8-sh/drivers/serial/stasc.c
--- linux-2.6.17.8/drivers/serial/stasc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/stasc.c	2006-08-23 13:29:50.879875000 +0100
@@ -0,0 +1,997 @@
+/*
+ *  drivers/serial/stasc.c
+ *  Asynchronous serial controller (ASC) driver
+ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_ST_ASC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/sysrq.h>
+#include <linux/serial.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/stpio.h>
+#include <linux/generic_serial.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/clock.h>
+
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+#endif
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+#include <asm/sh_bios.h>
+#endif
+
+#include "stasc.h"
+
+static struct asc_port asc_ports[ASC_NPORTS];
+
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+/* This is used as a system console, set by serial_console_setup */
+static struct console serial_console;
+static struct uart_port *serial_console_port = 0;
+#endif
+
+/*---- Forward function declarations---------------------------*/
+static int  asc_request_irq(struct uart_port *);
+static void asc_free_irq(struct uart_port *);
+static void asc_transmit_chars(struct uart_port *);
+static int asc_request_irq(struct uart_port *);
+void       asc_set_termios_cflag (struct asc_port *, int ,int);
+static inline void asc_receive_chars(struct uart_port *,
+				     struct pt_regs *);
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+static void serial_console_write (struct console *, const char *,
+				  unsigned );
+static int __init serial_console_setup (struct console *, char *);
+#endif
+
+#ifdef CONFIG_SH_KGDB
+int kgdb_asc_setup(void);
+static void kgdb_put_char(struct uart_port *port, char c);
+static struct asc_port *kgdb_asc_port;
+#ifdef CONFIG_SH_KGDB_CONSOLE
+static struct console kgdb_console;
+static struct tty_driver *kgdb_console_device(struct console *, int *);
+static int __init kgdb_console_setup(struct console *, char *);
+#endif
+#endif
+
+/*---- Inline function definitions ---------------------------*/
+
+/* Some simple utility functions to enable and disable interrupts.
+ * Note that these need to be called with interrupts disabled.
+ */
+
+static inline void asc_disable_tx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Clear TE (Transmitter empty) interrupt enable in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable &= ~ASC_INTEN_THE;
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_enable_tx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Set TE (Transmitter empty) interrupt enable in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable |= ASC_INTEN_THE;
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_disable_rx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Clear RBE (Receive Buffer Full Interrupt Enable) bit in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable &= ~ASC_INTEN_RBE;
+	asc_out(port, INTEN, intenable);
+}
+
+
+static inline void asc_enable_rx_interrupts(struct uart_port *port)
+{
+	unsigned long intenable;
+
+	/* Set RBE (Receive Buffer Full Interrupt Enable) bit in INTEN */
+	intenable = asc_in(port, INTEN);
+	intenable |= ASC_INTEN_RBE;
+	asc_out(port, INTEN, intenable);
+}
+
+/*----------------------------------------------------------------------*/
+/* UART Functions */
+static unsigned int asc_tx_empty(struct uart_port *port)
+{
+	unsigned long status;
+
+	status = asc_in(port, STA);
+	if (status & ASC_STA_TE)
+		return TIOCSER_TEMT;
+	return 0;
+}
+
+static void asc_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* This routine is used for seting signals of: DTR, DCD, CTS/RTS
+	 * We use ASC's hardware for CTS/RTS, so don't need any for that.
+	 * Some boards have DTR and DCD implemented using PIO pins,
+	 * code to do this should be hooked in here.
+	 */
+}
+
+static unsigned int asc_get_mctrl(struct uart_port *port)
+{
+	/* This routine is used for geting signals of: DTR, DCD, DSR, RI,
+	   and CTS/RTS */
+	return TIOCM_DTR | TIOCM_RTS | TIOCM_DSR;
+}
+
+/* There are probably characters waiting to be transmitted.
+   Start doing so. The port lock is held and interrupts are disabled. */
+static void asc_start_tx(struct uart_port *port)
+{
+	asc_transmit_chars(port);
+}
+
+static void asc_stop_tx(struct uart_port *port)
+{
+	asc_disable_tx_interrupts(port);
+}
+
+static void asc_stop_rx(struct uart_port *port)
+{
+	asc_disable_rx_interrupts(port);
+}
+
+static void asc_enable_ms(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+static void asc_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Nothing here yet .. */
+}
+
+/* Enable port for reception.
+ * port_sem held and interrupts disabled */
+static int asc_startup(struct uart_port *port)
+{
+	asc_request_irq(port);
+	asc_transmit_chars(port);
+	asc_enable_rx_interrupts(port);
+
+	return 0;
+}
+
+static void asc_shutdown(struct uart_port *port)
+{
+	asc_disable_tx_interrupts(port);
+	asc_disable_rx_interrupts(port);
+	asc_free_irq(port);
+}
+
+static void asc_set_termios(struct uart_port *port,
+			    struct termios *termios, struct termios *old)
+{
+	struct asc_port *ascport = &asc_ports[port->line];
+	unsigned int baud;
+
+	baud = uart_get_baud_rate(port, termios, old, 0,
+				  port->uartclk/16);
+
+	asc_set_termios_cflag(ascport, termios->c_cflag, baud);
+}
+static const char *asc_type(struct uart_port *port)
+{
+	return "asc";
+}
+
+static void asc_release_port(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+static int asc_request_port(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+	return 0;
+}
+
+/* Called when the port is opened, and UPF_BOOT_AUTOCONF flag is set */
+/* Set type field if successful */
+static void asc_config_port(struct uart_port *port, int flags)
+{
+	if (!port->membase)
+		port->membase = ioremap_nocache(port->mapbase,4096);
+	if (!port->membase)
+		return;
+
+	port->type = PORT_ASC;
+	port->fifosize = FIFO_SIZE;
+}
+
+static int
+asc_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	/* No user changeable parameters */
+	return -EINVAL;
+}
+
+/*----------------------------------------------------------------------*/
+static struct uart_ops asc_uart_ops = {
+	.tx_empty	= asc_tx_empty,
+	.set_mctrl	= asc_set_mctrl,
+	.get_mctrl	= asc_get_mctrl,
+	.start_tx	= asc_start_tx,
+	.stop_tx	= asc_stop_tx,
+	.stop_rx	= asc_stop_rx,
+	.enable_ms	= asc_enable_ms,
+	.break_ctl	= asc_break_ctl,
+	.startup	= asc_startup,
+	.shutdown	= asc_shutdown,
+	.set_termios	= asc_set_termios,
+	.type		= asc_type,
+	.release_port	= asc_release_port,
+	.request_port	= asc_request_port,
+	.config_port	= asc_config_port,
+	.verify_port	= asc_verify_port,
+};
+
+static struct asc_port asc_ports[ASC_NPORTS] = {
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+	{
+		/* UART3 */
+		.port	= {
+			.membase	= (void *)0xba033000,
+			.mapbase	= 0xba033000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 123,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 0,
+		},
+		.pio_port	= 5,
+		.pio_pin	= { 4, 5, 6, 7},
+	},
+	{
+		/* UART4 */
+		.port	= {
+			.membase	= (void *)0xba034000,
+			.mapbase	= 0xba034000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 119,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 1,
+		},
+		.pio_port	= 6,
+		.pio_pin	= { 0, 1, 2, 3},
+	},
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+	{
+		.port	= {
+			.membase	= (void *)0xb8330000,
+			.mapbase	= 0xb8330000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= ILC_FIRST_IRQ + 9,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 0,
+		},
+		.pio_port	= 5,
+		.pio_pin	= {4, 5, 6, 7},
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xb8331000,
+			.mapbase	= 0xb8331000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= ILC_FIRST_IRQ + 10,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 1,
+		},
+		.pio_port	= 5,
+		.pio_pin	= {0, 1, 2, 3},
+	},
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+	/* UART2 */
+	{
+		.port	= {
+			.membase	= (void *)0xb8032000,
+			.mapbase	= 0xb8032000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 121,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 0,
+		},
+		.pio_port	= 4,
+		.pio_pin	= {3, 2, 4, 5},
+	},
+	/* UART3 */
+	{
+		.port	= {
+			.membase	= (void *)0xb8033000,
+			.mapbase	= 0xb8033000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 120,
+			.ops		= &asc_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.fifosize	= FIFO_SIZE,
+			.line		= 1,
+		},
+		.pio_port	= 5,
+		.pio_pin	= {0, 1, 2, 3},
+	},
+#else
+#error "ASC error: CPU subtype not defined"
+#endif
+};
+
+static char banner[] __initdata =
+	KERN_INFO "STMicroelectronics ASC driver initialized\n";
+
+static struct uart_driver asc_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "asc",
+	.devfs_name	= "ttas/",
+	.dev_name	= "ttyAS",
+	.major		= ASC_MAJOR,
+	.minor		= ASC_MINOR_START,
+	.nr		= ASC_NPORTS,
+	.cons		= &serial_console,
+};
+
+#ifdef CONFIG_SERIAL_ST_ASC_CONSOLE
+static struct console serial_console = {
+	.name		= "ttyAS",
+	.device		= uart_console_device,
+	.write		= serial_console_write,
+	.setup		= serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &asc_uart_driver,
+};
+#endif
+
+#ifdef CONFIG_SH_KGDB
+#ifdef CONFIG_SH_KGDB_CONSOLE
+/* The console structure for KGDB */
+static struct console kgdb_console= {
+	.name		= "ttyAS",
+	.device		= kgdb_console_device,
+	.write		= kgdb_console_write,
+	.setup		= kgdb_console_setup,
+	.flags		= CON_PRINTBUFFER | CON_ENABLED,
+	.index		= -1,
+	.data		= &asc_uart_driver,
+};
+#endif
+#endif
+
+/*----------------------------------------------------------------------*/
+
+/* This sections contains code to support the use of the ASC as a
+ * generic serial port.
+ */
+
+static int asc_set_baud (struct uart_port *port, int baud)
+{
+	unsigned int t;
+	struct clk *clk;
+	unsigned long rate;
+
+	clk = clk_get("comms_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+
+	if (baud < 19200) {
+		t = BAUDRATE_VAL_M0(baud, rate);
+		asc_out (port, BAUDRATE, t);
+		return 0;
+	} else {
+		t = BAUDRATE_VAL_M1(baud, rate);
+		asc_out (port, BAUDRATE, t);
+		return ASC_CTL_BAUDMODE;
+	}
+}
+
+void
+asc_set_termios_cflag (struct asc_port *ascport, int cflag, int baud)
+{
+	struct uart_port *port = &ascport->port;
+	unsigned int ctrl_val;
+	unsigned long flags;
+
+	/* wait for end of current transmission */
+	local_irq_save(flags);
+	while (	! (asc_in(port, STA) & ASC_STA_TE) ) {
+		local_irq_restore(flags);
+	};
+
+	/* read control register */
+	ctrl_val = asc_in (port, CTL);
+
+	/* stop serial port and reset value */
+	asc_out (port, CTL, (ctrl_val & ~ASC_CTL_RUN));
+	ctrl_val = ASC_CTL_RXENABLE | ASC_CTL_FIFOENABLE;
+
+	/* reset fifo rx & tx */
+	asc_out (port, TXRESET, 1);
+	asc_out (port, RXRESET, 1);
+
+	/* Configure the PIO pins */
+	stpio_request_pin(ascport->pio_port, ascport->pio_pin[0],
+			  "ASC", STPIO_ALT_OUT); /* Tx */
+	stpio_request_pin(ascport->pio_port, ascport->pio_pin[1],
+			  "ASC", STPIO_IN);      /* Rx */
+	stpio_request_pin(ascport->pio_port, ascport->pio_pin[2],
+			  "ASC", STPIO_IN);      /* CTS */
+	stpio_request_pin(ascport->pio_port, ascport->pio_pin[3],
+			  "ASC", STPIO_ALT_OUT); /* RTS */
+
+	/* set character length */
+	if ((cflag & CSIZE) == CS7)
+		ctrl_val |= ASC_CTL_MODE_7BIT_PAR;
+	else {
+		if (cflag & PARENB)
+			ctrl_val |= ASC_CTL_MODE_8BIT_PAR;
+		else
+			ctrl_val |= ASC_CTL_MODE_8BIT;
+	}
+
+	/* set stop bit */
+	if (cflag & CSTOPB)
+		ctrl_val |= ASC_CTL_STOP_2BIT;
+	else
+		ctrl_val |= ASC_CTL_STOP_1BIT;
+
+	/* odd parity */
+	if (cflag & PARODD)
+		ctrl_val |= ASC_CTL_PARITYODD;
+
+	/* set speed and baud generator mode */
+	ctrl_val |= asc_set_baud (port, baud);
+	uart_update_timeout(port, cflag, baud);
+
+	/* Set the timeout */
+	asc_out(port, TIMEOUT, 16);
+
+	/* write final value and enable port */
+	asc_out (port, CTL, (ctrl_val | ASC_CTL_RUN));
+
+	local_irq_restore(flags);
+}
+
+
+static inline unsigned asc_hw_txroom(struct uart_port* port)
+{
+	unsigned long status;
+
+	status = asc_in(port, STA);
+	if (status & ASC_STA_THE) {
+		return FIFO_SIZE/2;
+	} else if (! (status & ASC_STA_TF)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * Start transmitting chars.
+ * This is called from both interrupt and task level.
+ * Either way interrupts are disabled.
+ */
+static void asc_transmit_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int txroom;
+	unsigned long intenable;
+	unsigned char c;
+
+	txroom = asc_hw_txroom(port);
+
+	if ((txroom != 0) && port->x_char) {
+		c = port->x_char;
+		port->x_char = 0;
+		asc_out (port, TXBUF, c);
+		port->icount.tx++;
+		txroom = asc_hw_txroom(port);
+	}
+
+	while (txroom > 0) {
+		if (uart_tx_stopped(port) || uart_circ_empty(xmit)) {
+			break;
+		}
+
+		do {
+			c = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			asc_out (port, TXBUF, c);
+			port->icount.tx++;
+			txroom--;
+		} while ((txroom > 0) && (!uart_circ_empty(xmit)));
+
+		txroom = asc_hw_txroom(port);
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(port);
+	}
+
+	intenable = asc_in(port, INTEN);
+	if (port->x_char || (!uart_circ_empty(xmit))) {
+		intenable |= ASC_INTEN_THE;
+	} else {
+		intenable &= ~ASC_INTEN_THE;
+	}
+	asc_out(port, INTEN, intenable);
+}
+
+static inline void asc_receive_chars(struct uart_port *port,
+				     struct pt_regs *regs)
+{
+	int count;
+	struct tty_struct *tty = port->info->tty;
+	int copied=0;
+	unsigned long status;
+	unsigned long c = 0;
+	char flag;
+	int overrun;
+
+	while (1) {
+		status = asc_in(port, STA);
+		if (status & ASC_STA_RHF) {
+			count = FIFO_SIZE / 2;
+		} else if (status & ASC_STA_RBF) {
+			count = 1;
+		} else {
+			count = 0;
+		}
+
+		/* Check for overrun before reading any data from the
+		 * RX FIFO, as this clears the overflow error condition. */
+		overrun = status & ASC_STA_OE;
+
+		/* Don't copy more bytes than there are room for in the buffer */
+		count = tty_buffer_request_room(tty, count);
+
+		/* If for any reason we can't copy more data, we're done! */
+		if (count == 0)
+			break;
+
+		for ( ; count != 0; count--) {
+			c = asc_in(port, RXBUF);
+			flag = TTY_NORMAL;
+			port->icount.rx++;
+
+			if (unlikely(c & ASC_RXBUF_FE)) {
+				if (c == ASC_RXBUF_FE) {
+					port->icount.brk++;
+					if (uart_handle_break(port))
+						continue;
+					flag = TTY_BREAK;
+				} else {
+					port->icount.frame++;
+					flag = TTY_FRAME;
+				}
+			} else if (unlikely(c & ASC_RXBUF_PE)) {
+				port->icount.parity++;
+				flag = TTY_PARITY;
+			}
+
+			if (uart_handle_sysrq_char(port, c, regs))
+				continue;
+			tty_insert_flip_char(tty, c & 0xff, flag);
+		}
+
+		if (overrun) {
+			port->icount.overrun++;
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}			
+
+		copied=1;
+	}
+
+	if (copied) {
+		/* Tell the rest of the system the news. New characters! */
+		tty_flip_buffer_push(tty);
+	}
+}
+
+static irqreturn_t asc_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+	struct uart_port *port = ptr;
+	unsigned long status;
+
+	status = asc_in (port, STA);
+	if (status & ASC_STA_RBF) {
+		/* Receive FIFO not empty */
+		asc_receive_chars(port, regs);
+	}
+
+	if ((status & ASC_STA_THE) && (asc_in(port, INTEN) & ASC_INTEN_THE)) {
+		/* Transmitter FIFO at least half empty */
+		asc_transmit_chars(port);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int asc_request_irq(struct uart_port *port)
+{
+	if (request_irq(port->irq, asc_interrupt, SA_INTERRUPT,
+			"asc", port)) {
+		printk(KERN_ERR "asc: cannot allocate irq.\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void asc_free_irq(struct uart_port *port)
+{
+	free_irq(port->irq, port);
+}
+
+/*
+ *  Main entry point for the serial console driver.
+ *  Called by console_init() in drivers/char/tty_io.c
+ *  register_console() is in kernel/printk.c
+ */
+
+static int __init
+asc_console_init (void)
+{
+	register_console (&serial_console);
+	return 0;
+}
+
+/*----------------------------------------------------------------------*/
+int __init asc_init(void)
+{
+	int line, ret;
+	struct clk *clk;
+	unsigned long rate;
+
+	clk = clk_get("comms_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+
+	printk("%s", banner);
+
+	ret = uart_register_driver(&asc_uart_driver);
+	if (ret == 0) {
+		for (line=0; line<ASC_NPORTS; line++) {
+			struct asc_port *ascport = &asc_ports[line];
+			ascport->port.uartclk = rate;
+			uart_add_one_port(&asc_uart_driver, &ascport->port);
+		}
+	}
+
+	return ret;
+}
+
+static void __exit asc_exit(void)
+{
+	int line;
+
+	for (line = 0; line < ASC_NPORTS; line++)
+		uart_remove_one_port(&asc_uart_driver, &asc_ports[line].port);
+
+	uart_unregister_driver(&asc_uart_driver);
+}
+
+module_init(asc_init);
+module_exit(asc_exit);
+
+/*----------------------------------------------------------------------*/
+
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+
+static int get_char(struct uart_port *port)
+{
+        int c;
+	unsigned long status;
+
+	do {
+		status = asc_in(port, STA);
+	} while (! (status & ASC_STA_RBF));
+
+	c = asc_in(port, RXBUF);
+
+        return c;
+}
+
+/* Taken from sh-stub.c of GDB 4.18 */
+static const char hexchars[] = "0123456789abcdef";
+
+static __inline__ char highhex(int  x)
+{
+	return hexchars[(x >> 4) & 0xf];
+}
+
+static __inline__ char lowhex(int  x)
+{
+	return hexchars[x & 0xf];
+}
+#endif
+
+static void
+put_char (struct uart_port *port, char c)
+{
+	unsigned long flags;
+	unsigned long status;
+
+	local_irq_save(flags);
+
+	do {
+		status = asc_in (port, STA);
+	} while (status & ASC_STA_TF);
+
+	asc_out (port, TXBUF, c);
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Send the packet in buffer.  The host gets one chance to read it.
+ * This routine does not wait for a positive acknowledge.
+ */
+
+static void
+put_string (struct uart_port *port, const char *buffer, int count)
+{
+	int i;
+	const unsigned char *p = buffer;
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+	int checksum;
+	int usegdb=0;
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+    	/* This call only does a trap the first time it is
+	 * called, and so is safe to do here unconditionally
+	 */
+	usegdb |= sh_bios_in_gdb_mode();
+#endif
+#ifdef CONFIG_SH_KGDB
+	usegdb |= (kgdb_in_gdb_mode && (port == &kgdb_asc_port->port));
+#endif
+
+	if (usegdb) {
+	    /*  $<packet info>#<checksum>. */
+	    do {
+		unsigned char c;
+		put_char(port, '$');
+		put_char(port, 'O'); /* 'O'utput to console */
+		checksum = 'O';
+
+		for (i=0; i<count; i++) { /* Don't use run length encoding */
+			int h, l;
+
+			c = *p++;
+			h = highhex(c);
+			l = lowhex(c);
+			put_char(port, h);
+			put_char(port, l);
+			checksum += h + l;
+		}
+		put_char(port, '#');
+		put_char(port, highhex(checksum));
+		put_char(port, lowhex(checksum));
+	    } while  (get_char(port) != '+');
+	} else
+#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+
+	for (i = 0; i < count; i++) {
+		if (*p == 10)
+			put_char (port, '\r');
+		put_char (port, *p++);
+	}
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ *  Setup initial baud/bits/parity. We do two things here:
+ *	- construct a cflag setting for the first rs_open()
+ *	- initialize the serial port
+ *  Return non-zero if we didn't find a serial port.
+ */
+
+static int __init
+serial_console_setup (struct console *co, char *options)
+{
+	struct asc_port *ascport;
+	int     baud = 9600;
+	int     bits = 8;
+	int     parity = 'n';
+	int     flow = 'n';
+	struct clk *clk;
+	unsigned long rate;
+
+	if (co->index < 0 || co->index >= ASC_NPORTS)
+		co->index = 0;
+
+	ascport = &asc_ports[co->index];
+
+	clk = clk_get("comms_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+	ascport->port.uartclk = rate;
+
+	serial_console_port = &ascport->port;
+
+	if (options) {
+                uart_parse_options(options, &baud, &parity, &bits, &flow);
+	}
+
+	return uart_set_options(&ascport->port, co, baud, parity, bits, flow);
+}
+
+/*
+ *  Print a string to the serial port trying not to disturb
+ *  any possible real use of the port...
+ */
+
+static void
+serial_console_write (struct console *co, const char *s, unsigned count)
+{
+	put_string (serial_console_port, s, count);
+}
+
+/*----------------------------------------------------------------------*/
+/* KGDB ASC functions */
+
+#ifdef CONFIG_SH_KGDB
+/* write a char */
+static void kgdb_put_char(struct uart_port *port, char c)
+{
+	unsigned long flags;
+	unsigned long status;
+
+	local_irq_save(flags);
+
+	do {
+		status = asc_in (port, STA);
+	} while (status & ASC_STA_TF);
+
+	asc_out (port, TXBUF, c);
+
+	local_irq_restore(flags);
+}
+
+/* Called from stub to put a character */
+static void kgdb_asc_putchar(int c)
+{
+        kgdb_put_char(&kgdb_asc_port->port, c);
+}
+
+/* Called from stub to get a character, i.e. is blocking */
+static int kgdb_asc_getchar(void)
+{
+	return get_char(&kgdb_asc_port->port);
+}
+
+/* Initialise the KGDB serial port.
+   Called from stub to setup the debug port
+*/
+int kgdb_asc_setup(void)
+{
+	int cflag = CREAD | HUPCL | CLOCAL | CSTOPB;
+
+	if ((kgdb_portnum < 0) || (kgdb_portnum >= ASC_NPORTS))
+	{
+		printk (KERN_ERR "%s invalid ASC port number\n", __FUNCTION__);
+		return -1;
+	}
+
+        kgdb_asc_port = &asc_ports[kgdb_portnum];
+
+	switch (kgdb_baud) {
+        case 115200:
+                cflag |= B115200;
+                break;
+	case 57600:
+                cflag |= B57600;
+                break;
+        case 38400:
+                cflag |= B38400;
+                break;
+        case 19200:
+                cflag |= B19200;
+                break;
+	case 9600:
+		cflag = B9600;
+		break;
+        default:
+                cflag |= B115200;
+                kgdb_baud = 115200;
+		printk (KERN_WARNING "%s: force the kgdb baud as %d\n",
+				      __FUNCTION__, kgdb_baud);
+                break;
+        }
+
+	switch (kgdb_bits) {
+        case '7':
+                cflag |= CS7;
+                break;
+        default:
+        case '8':
+                cflag |= CS8;
+                break;
+        }
+
+        switch (kgdb_parity) {
+        case 'O':
+                cflag |= PARODD;
+                break;
+        case 'E':
+                cflag |= PARENB;
+                break;
+        }
+        kgdb_cflag = cflag;
+        asc_set_termios_cflag(kgdb_asc_port, kgdb_cflag, kgdb_baud);
+
+	/* Setup complete: initialize function pointers */
+	kgdb_getchar = kgdb_asc_getchar;
+	kgdb_putchar = kgdb_asc_putchar;
+
+        return 0;
+}
+
+#ifdef CONFIG_SH_KGDB_CONSOLE
+/* Create a console device */
+static struct tty_driver *kgdb_console_device(struct console *co, int *index)
+{
+	struct uart_driver *p = co->data;
+	*index = co->index;
+	return p->tty_driver;
+}
+
+/* Set up the KGDB console */
+static int __init kgdb_console_setup(struct console *co, char *options)
+{
+        /* NB we ignore 'options' because we've already done the setup */
+        co->cflag = kgdb_cflag;
+        return 0;
+}
+
+#ifdef CONFIG_KGDB_DEFTYPE_ASC
+/* Register the KGDB console so we get messages (d'oh!) */
+int __init kgdb_console_init(void)
+{
+        register_console(&kgdb_console);
+	return 0;
+}
+console_initcall(kgdb_console_init);
+#endif
+#endif /* CONFIG_SH_KGDB_CONSOLE */
+#endif /* CONFIG_SH_KGDB */
+console_initcall(asc_console_init);
diff -Naur linux-2.6.17.8/drivers/serial/stasc.h linux-2.6.17.8-sh/drivers/serial/stasc.h
--- linux-2.6.17.8/drivers/serial/stasc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/serial/stasc.h	2006-08-23 13:29:50.897875000 +0100
@@ -0,0 +1,183 @@
+/*
+ *  drivers/char/stasc.h
+ *
+ *  ST40 Asynchronous serial controller (ASC) driver
+ *  Derived from sh-sci.h
+ *  Copyright (c) STMicroelectronics Limited
+ *  Author: Andrea Cisternino (March 2003)
+ *
+ *  Documentation for the Asynchronous Serial Controller in the STm8000 SoC
+ *  can be found in the following documents:
+ *
+ *    1) DVD Platform Architecture Volume 4: I/O Devices (ADCS: 7402381)
+ *    2) STm8000 Datasheet (ADCS: 7323276)
+ */
+
+#include <linux/config.h>
+#include <linux/serial_core.h>
+
+struct asc_port
+{
+	struct uart_port port;
+	unsigned char pio_port;
+	unsigned char pio_pin[4]; /* Tx, Rx, CTS, RTS */
+	int     break_flag;
+};
+
+#define ASC_MAJOR		204
+#define ASC_MINOR_START		40
+
+/* Generic serial flags */
+#define ASC_RX_THROTTLE		0x0000001
+
+#define FIFO_SIZE		16
+
+/*---- Chip specific values -----------------------------------*/
+
+#if defined(CONFIG_CPU_SUBTYPE_STM8000)
+# define ASC_NPORTS		2
+#elif defined(CONFIG_CPU_SUBTYPE_STI5528)
+#define ASC_NPORTS             2
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define ASC_NPORTS             2
+#else
+#error "Unknown CPU"
+#endif
+
+
+/*---- UART Register definitions ------------------------------*/
+
+/* Register offsets */
+
+#define ASC_BAUDRATE			0x00
+#define ASC_TXBUF			0x04
+#define ASC_RXBUF			0x08
+#define ASC_CTL				0x0C
+#define ASC_INTEN			0x10
+#define ASC_STA				0x14
+#define ASC_GUARDTIME			0x18
+#define ASC_TIMEOUT			0x1C
+#define ASC_TXRESET			0x20
+#define ASC_RXRESET			0x24
+#define ASC_RETRIES			0x28
+
+/* ASC_RXBUF */
+#define ASC_RXBUF_PE			0x100
+#define ASC_RXBUF_FE			0x200
+
+/* ASC_CTL */
+
+#define ASC_CTL_MODE_MSK		0x0007
+#define  ASC_CTL_MODE_8BIT		0x0001
+#define  ASC_CTL_MODE_7BIT_PAR		0x0003
+#define  ASC_CTL_MODE_9BIT		0x0004
+#define  ASC_CTL_MODE_8BIT_WKUP		0x0005
+#define  ASC_CTL_MODE_8BIT_PAR		0x0007
+#define ASC_CTL_STOP_MSK		0x0018
+#define  ASC_CTL_STOP_HALFBIT		0x0000
+#define  ASC_CTL_STOP_1BIT		0x0008
+#define  ASC_CTL_STOP_1_HALFBIT		0x0010
+#define  ASC_CTL_STOP_2BIT		0x0018
+#define ASC_CTL_PARITYODD		0x0020
+#define ASC_CTL_LOOPBACK		0x0040
+#define ASC_CTL_RUN			0x0080
+#define ASC_CTL_RXENABLE		0x0100
+#define ASC_CTL_SCENABLE		0x0200
+#define ASC_CTL_FIFOENABLE		0x0400
+#define ASC_CTL_CTSENABLE		0x0800
+#define ASC_CTL_BAUDMODE		0x1000
+
+/* ASC_GUARDTIME */
+
+#define ASC_GUARDTIME_MSK		0x00FF
+
+/* ASC_INTEN */
+
+#define ASC_INTEN_RBE			0x0001
+#define ASC_INTEN_TE			0x0002
+#define ASC_INTEN_THE			0x0004
+#define ASC_INTEN_PE			0x0008
+#define ASC_INTEN_FE			0x0010
+#define ASC_INTEN_OE			0x0020
+#define ASC_INTEN_TNE			0x0040
+#define ASC_INTEN_TOI			0x0080
+#define ASC_INTEN_RHF			0x0100
+
+/* ASC_RETRIES */
+
+#define ASC_RETRIES_MSK			0x00FF
+
+/* ASC_RXBUF */
+
+#define ASC_RXBUF_MSK			0x03FF
+
+/* ASC_STA */
+
+#define ASC_STA_RBF			0x0001
+#define ASC_STA_TE			0x0002
+#define ASC_STA_THE			0x0004
+#define ASC_STA_PE			0x0008
+#define ASC_STA_FE			0x0010
+#define ASC_STA_OE			0x0020
+#define ASC_STA_TNE			0x0040
+#define ASC_STA_TOI			0x0080
+#define ASC_STA_RHF			0x0100
+#define ASC_STA_TF			0x0200
+#define ASC_STA_NKD			0x0400
+
+/* ASC_TIMEOUT */
+
+#define ASC_TIMEOUT_MSK			0x00FF
+
+/* ASC_TXBUF */
+
+#define ASC_TXBUF_MSK			0x01FF
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+/*
+ * MODE 0
+ * recommended for low bit rates (below 19.2K)
+ *
+ *                       ICCLK
+ * ASCBaudRate =   ----------------
+ *                   baudrate * 16
+ *
+ * MODE 1
+ * recommended for high bit rates (above 19.2K)
+ *
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------
+ *                          ICCLK
+ */
+
+#define ADJ 1
+#define BAUDRATE_VAL_M0(bps, clk)	((clk) / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps, clk)	( ((bps * (1 << 14)) / ((clk) / (1 << 6)) ) + ADJ )
+
+/*---- Access macros ------------------------------------------*/
+
+#define ASC_FUNC(name, offset)		\
+  static inline unsigned int asc_ ## name ## _in (struct uart_port* port)	\
+  {										\
+    return (ctrl_inl (port->mapbase + (offset)));					\
+  }										\
+  static inline void asc_ ## name ## _out (struct uart_port* port, unsigned int value)	\
+  {										\
+    ctrl_outl (value, port->mapbase + (offset));					\
+  }
+
+ASC_FUNC(BAUDRATE,  ASC_BAUDRATE)
+ASC_FUNC(TXBUF,     ASC_TXBUF)
+ASC_FUNC(RXBUF,     ASC_RXBUF)
+ASC_FUNC(CTL,       ASC_CTL)
+ASC_FUNC(INTEN,     ASC_INTEN)
+ASC_FUNC(STA,       ASC_STA)
+ASC_FUNC(GUARDTIME, ASC_GUARDTIME)
+ASC_FUNC(TIMEOUT,   ASC_TIMEOUT)
+ASC_FUNC(TXRESET,   ASC_TXRESET)
+ASC_FUNC(RXRESET,   ASC_RXRESET)
+ASC_FUNC(RETRIES,   ASC_RETRIES)
+
+#define asc_in(port, reg)		asc_ ## reg ## _in (port)
+#define asc_out(port, reg, value)	asc_ ## reg ## _out ((port), (value))
diff -Naur linux-2.6.17.8/drivers/sh/Makefile linux-2.6.17.8-sh/drivers/sh/Makefile
--- linux-2.6.17.8/drivers/sh/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/sh/Makefile	2006-08-23 13:29:15.858070000 +0100
@@ -2,5 +2,5 @@
 # Makefile for the SuperH specific drivers.
 #
 
-obj-$(CONFIG_SUPERHYWAY) += superhyway/
+obj-$(CONFIG_SUPERHYWAY)	+= superhyway/
 
diff -Naur linux-2.6.17.8/drivers/stm/7100_fdma2.c linux-2.6.17.8-sh/drivers/stm/7100_fdma2.c
--- linux-2.6.17.8/drivers/stm/7100_fdma2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/7100_fdma2.c	2006-08-23 13:29:51.713899000 +0100
@@ -0,0 +1,1266 @@
+/*
+ *  STb7100 FDMA Driver
+ *  Copyright (c) Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+#include <asm/io.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#ifdef CONFIG_BIGPHYS_AREA
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/interrupt.h>
+
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+#include <asm/cacheflush.h>
+
+#include <linux/bigphysarea.h>
+#define STM_USE_BIGPHYS_AREA 1
+#include <linux/delay.h>
+#else
+
+/* Private dummy defines so we do not have to ifdef the code */
+static caddr_t  bigphysarea_alloc(int size) { return NULL; }
+static void     bigphysarea_free(caddr_t addr, int size) {}
+
+#endif
+
+#include <linux/stm/7100_fdma2.h>
+#include "7100_fdma2_firmware.h"
+#include <asm-sh/dma.h>
+
+#define STB7100_DMA_CHANNELS 16
+
+static struct tasklet_struct fdma_complete[STB7100_DMA_CHANNELS];
+static struct tasklet_struct fdma_error[STB7100_DMA_CHANNELS];
+
+typedef int (*fp)(struct dma_channel *,unsigned long);
+static fdma_llu_entry static_llu[STB7100_DMA_CHANNELS] __attribute__((__aligned__(32)));
+
+typedef struct channel_status{
+	char    locked;
+	pf 	comp_callback;
+	void   *comp_callback_param;
+	pf	err_callback;
+	void   *err_callback_param;
+	u32    *llu_virt_addr;
+	u32	llu_bus_addr;
+	u32	transfer_sz;
+	u32	alloc_mem_sz;/*number of bytes of dynamic mem alloced for llu*/
+	u32 	list_len;
+	char    cb_in_interrupt;
+	char	dynamic_mem;
+	char	ch_term;
+	char	ch_pause;
+	char	is_xferring;
+
+/*This must be the last structure member to prevent scribbling
+ * over the initialied queue * at the end of transfer*/
+/* This is done by the memset in free_fdma_channel() */
+	wait_queue_head_t cfg_blk;
+}channel_status;
+
+typedef struct fdma_chip{
+	channel_status channel[STB7100_DMA_CHANNELS];
+	spinlock_t fdma_lock;
+	spinlock_t channel_lock;
+	u32 	io_base;
+}fdma_chip;
+
+static fdma_chip chip;
+
+#define DUMP_FDMA_CHANNEL(chan)\
+	(printk("CHANNEL%d is \n CMD_STAT %x\n PTR %x\n CNT %x\n SADDR %x\n DADDR %x\n REQ_CTL %x\n", \
+		chan, \
+		(int)readl(chip.io_base + FDMA2_CMD_STATn + (chan * CMD_STAT_OFFSET)), \
+		(int)readl((chip.io_base + NODE_DATA_OFFSET * chan) + FDMA2_PTR_REG), \
+		(int)readl((chip.io_base + NODE_DATA_OFFSET * chan) + FDMA2_COUNT_REG), \
+		(int)readl((chip.io_base + NODE_DATA_OFFSET * chan) + FDMA2_SADDR_REG), \
+		(int)readl((chip.io_base + NODE_DATA_OFFSET * chan) + FDMA2_DADDR_REG), \
+		(int)readl((chip.io_base + CMD_STAT_OFFSET * chan) + FDMA2_REQ_CTL_REG)))
+
+#define DUMP_FDMA_INTERFACE()(\
+	printk(" FDMA_CMD_STA %x\n FDMA_CMD_SET %x\n FDMA_CMD_CLR %x\n FDMA_CMD_MASK FDMA_INT_STA %x\n FDMA_INT_SET %x\n FDMA_INT_CLR %x\n FDMA_INT_MASK %x\n", \
+		(int)readl(chip.io_base + FDMA2_CMD_MBOX_STAT_REG),\
+		(int)readl(chip.io_base + FDMA2_CMD_MBOX_SET_REG),\
+		(int)readl(chip.io_base + FDMA2_CMD_MBOX_CLR_REG),\
+		(int)readl(chip.io_base + FDMA2_CMD_MBOX_MASK_REG),\
+		(int)readl(chip.io_base + FDMA2_INT_STAT_REG),\
+		(int)readl(chip.io_base + FDMA2_INT_SET_REG),\
+		(int)readl(chip.io_base + FDMA2_INT_CLR_REG),\
+		(int)readl(chip.io_base + FDMA2_INT_MASK_REG)))
+
+
+#define DUMP_NODE_FROM_EXTMEM(addr)(\
+	printk("NODE @ %x\n NEXT %x\n CTL %x\n NBYTES %x\n SADDR %x\n DADDR %x\n\n",\
+		(int)virt_to_phys(addr), \
+		(int)readl(addr), \
+		(int)readl(addr+0x04),\
+		(int)readl(addr+0x08),\
+		(int)readl(addr+0xc),\
+		(int)readl(addr+0x10)))
+
+#define DUMP_SPDIF_NODE_DATA(addr)(\
+	printk(" PA_PB %x\n PC_PD %x\n BST_PER %x\n CHALO %x\n CHAHI %x\n CHBLO %x\n CHBHI%x\n\n", \
+		(int)readl(addr+0x14), \
+		(int)readl(addr+0x18),\
+		(int)readl(addr+0x1c),\
+		(int)readl(addr+0x20),\
+		(int)readl(addr+0x24),\
+		(int)readl(addr+0x28),\
+		(int)readl(addr+0x2c)))
+
+
+#define NUM_FDMA_REQ_LINES 32
+static fdmareq_RequestConfig_t fdmareq_RequestLines[NUM_FDMA_REQ_LINES] ={
+/*=========================== 7100 ============================================*/
+
+/*
+Req  RnW,    Opcode,  Transfer  Inc,       Hold_off  Initiator), */
+/*           1-32     count 1-4            On/Off       0-2     Used) */
+
+{0,   WRITE,  OPCODE_4,  1,     ENABLE_FLG,  0,     1 },/* SPDIF Testing */
+{1,   UNUSED, UNUSED,    1,     UNUSED,      0,     1 },/* NOT CONNECTED */
+{2,   UNUSED, UNUSED,    1,     UNUSED,      0,     1 },/* NOT CONNECTED */
+{3,   READ,   OPCODE_8,  1,     DISABLE_FLG, 0,     1 },/* Video HDMI */
+{4,   WRITE,  OPCODE_4,  2,     DISABLE_FLG, 0,     1 },/* DiseqC half empty */
+{5,   READ,   OPCODE_4,  2,     DISABLE_FLG, 0,     1 },/* DiseqC half full */
+{6,   READ,   OPCODE_4,  2,     DISABLE_FLG, 0,     1 },  /* SH4/SCIF */
+{7,   WRITE,  OPCODE_4,  2,     DISABLE_FLG, 0,     1 },  /* SH4/SCIF */
+{8,   READ,   OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 0 rxbuff full */
+{9,   READ,   OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 1 rxbuff full */
+{10,  READ,   OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 2 rxbuff full */
+{11,  WRITE,  OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 0 txbuff empty */
+{12,  WRITE,  OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 1 txbuff empty */
+{13,  WRITE,  OPCODE_2,  4,     DISABLE_FLG, 0,     1 },  /* SSC 1 txbuff empty */
+{14,  READ,   OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 0 rx half full */
+{15,  READ,   OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 1 rx half full */
+{16,  READ,   OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 2 rx half full */
+{17,  READ,   OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 3 rx half full */
+{18,  WRITE,  OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 0 tx half empty */
+{19,  WRITE,  OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 1 tx half empty */
+{20,  WRITE,  OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 2 tx half emtpy */
+{21,  WRITE,  OPCODE_1,  1,     DISABLE_FLG, 0,     1 },  /* UART 3 tx half empty */
+{22,  READ,   OPCODE_4,  1,     DISABLE_FLG, 0,     1 },  /* External 0 (PIO2bit5) hi priority */
+{23,  READ,   OPCODE_4,  1,     DISABLE_FLG, 0,     1 },  /* External 1 (PIO2bit6) hi priority */
+{24,  READ,   OPCODE_4,  4,     DISABLE_FLG, 0,     1 },  /* CPxM decrypted data request */
+{25,  WRITE,  OPCODE_4,  4,     DISABLE_FLG, 0,     1 },  /* CPxm encrypted data request */
+{26,  WRITE,  OPCODE_4,  1,     DISABLE_FLG, 1,     1 },  /* Audio PCM Player 0 */
+{27,  WRITE,  OPCODE_4,  1,     DISABLE_FLG, 1,     1 },  /* Audio PCM Player 1 */
+{28,  READ,   OPCODE_4,  1,     DISABLE_FLG, 0,     1 },  /* Audio PCM Reader */
+{29,  WRITE,  OPCODE_4,  2,     DISABLE_FLG, 0,     1 },  /* Audio SPDIF - 2xST4*/
+{30,  WRITE,  OPCODE_16, 1,     DISABLE_FLG, 0,     1 },  /* SWTS */
+{31,  UNUSED, UNUSED,    1,     UNUSED,      0,     1 },  /* Reserved */
+
+};
+
+int get_fdma_chan_status(int channel)
+{
+	return (readl(chip.io_base + FDMA2_CMD_STATn + (channel* CMD_STAT_OFFSET)) & 3);
+}
+
+typedef volatile unsigned long device_t;
+
+static void stb7100_bootload_fdma(void* addr)
+{
+
+	/*we need to load the IMEM & DMEM regions for the slim core*/
+	u32 unused_ibytes=IMEM_REGION_LENGTH - IMEM_FIRMWARE_SZ;
+	u32 unused_dbytes =DMEM_REGION_LENGTH - DMEM_FIRMWARE_SZ;
+
+	device_t* ptr=0;
+	printk("STB7100_FDMA Loading Firmaware Rev%s.....",FIRMWARE_REVISION);
+
+	spin_lock(&chip.fdma_lock);
+	ptr = (device_t*) ((char*) addr +DMEM_OFFSET);
+	memcpy((void*)ptr,&DATA_REGION[0],DMEM_FIRMWARE_SZ * sizeof(u32) );
+
+	if(unused_dbytes){
+		ptr =(device_t*) ((char*)addr +DMEM_OFFSET +(DMEM_FIRMWARE_SZ*
+							sizeof(u32)));
+		memset((void*)ptr ,0, (DMEM_REGION_LENGTH-DMEM_FIRMWARE_SZ));
+	}
+
+	ptr = (device_t*) ((char*) addr +IMEM_OFFSET);
+	memcpy((void*)ptr,&IMEM_REGION[0],IMEM_FIRMWARE_SZ* sizeof(u32));
+
+
+	if(unused_ibytes){
+		ptr =(device_t*) ((char*)addr +IMEM_OFFSET +(IMEM_FIRMWARE_SZ*
+								sizeof(u32)));
+		memset((void*)ptr,0, (IMEM_REGION_LENGTH-IMEM_FIRMWARE_SZ));
+	}
+	spin_unlock(&chip.fdma_lock);
+	printk("OK\n");
+}
+
+
+
+static void initialise_fdma2(void)
+{
+/*These pokes come from the current STAPI tree.
+ * The three magic vals are pokes to undocumented regs so
+ * we don't know what they mean.
+ *
+ * The effect is to turn on and initialise the clocks
+ * and set all channels off*/
+
+	/*clear the status regs MBOX & IRQ*/
+	writel(CLEAR_WORD, chip.io_base+FDMA2_INT_CLR_REG);
+	writel(CLEAR_WORD, chip.io_base+FDMA2_CMD_MBOX_CLR_REG);
+
+    /* Enable the FDMA block */
+	writel(1,chip.io_base+FDMA2_SYNCREG);
+	writel(5,chip.io_base+FDMA2_CLOCKGATE);
+	writel(0,chip.io_base+FDMA2_CLOCKGATE);
+
+}
+/*this function enables messaging and intr generation for all channels &
+ * starts the fdma running*/
+static int enable_all_channels(void){
+
+	writel(CLEAR_WORD,chip.io_base + FDMA2_INT_MASK_REG);
+	writel(CLEAR_WORD,chip.io_base + FDMA2_CMD_MBOX_MASK_REG);
+	writel(ENABLE_FLG ,chip.io_base +FDMA2_ENABLE_REG);
+	return (readl(chip.io_base + FDMA2_ENABLE_REG) &1);
+}
+
+static void reset_channels(void)
+{
+	int channel=0;
+	for(;channel <(STB7100_DMA_CHANNELS-1);channel++)
+		writel(0,chip.io_base+FDMA2_CMD_STATn+(channel*CMD_STAT_OFFSET));
+}
+
+static void initialise_req_ctl(void)
+{
+	unsigned long ReqC=0;
+	int i=0;
+	for(;i < 31;i++){
+
+	  	ReqC = (u32)(fdmareq_RequestLines[i].HoldOff   & 0x0f) <<  0;
+	  	 /* Bits 3...0 */
+        	ReqC |= (u32)(fdmareq_RequestLines[i].OpCode    & 0x0f) <<  4;
+        	/*  " 7...4 */
+        	ReqC |= (u32)(fdmareq_RequestLines[i].Access    & 0x01) << 14;
+        	 /*  " 14 */
+ 	        ReqC |= (u32)(fdmareq_RequestLines[i].Initiator & 0x03) << 22;
+ 	        /*  " 23...22 */
+       		ReqC |= (u32)((fdmareq_RequestLines[i].Count-1) & 0x1F) << 24;
+       		 /*  " 28...24 */
+        	ReqC|= (u32)(fdmareq_RequestLines[i].Increment & 0x01) << 29;
+        	/*  " 29 */
+            /* Write to device */
+
+        writel(ReqC,
+        	chip.io_base+FDMA2_REQ_CTL_REG+(fdmareq_RequestLines[i].Index *
+        						CMD_STAT_OFFSET));
+	}
+}
+
+static int claim_fdma_channel(int channel)
+{
+	spin_lock(&chip.channel_lock);
+
+	if(!chip.channel[channel].locked){
+		chip.channel[channel].locked=1;
+		spin_unlock(&chip.channel_lock);
+		return channel;
+	}
+	else{
+		spin_unlock(&chip.channel_lock);
+		return -ENODEV;
+	}
+}
+
+static void free_fdma_channel(int channel)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	if(chip.channel[channel].dynamic_mem){
+		bigphysarea_free((void*)chip.channel[channel].llu_virt_addr,
+			chip.channel[channel].alloc_mem_sz);
+	}
+	memset(&chip.channel[channel],0,sizeof(channel_status)-
+						sizeof(wait_queue_head_t));
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+}
+
+static int get_next_free_channel(void)
+{
+	unsigned long irqflags;
+	int channel=0;
+	do{
+		if(get_fdma_chan_status(channel) == FDMA_CHANNEL_IDLE)
+		{
+			spin_lock_irqsave(&chip.channel_lock, irqflags);
+
+			if(!chip.channel[channel].locked)
+			{
+				spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+				if(claim_fdma_channel(channel)<0)
+					return -ENODEV;
+				else return channel;
+			}
+			spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		}
+	}while(channel++ < STB7100_DMA_CHANNELS);
+	return -ENODEV;
+}
+
+
+/*will start an idle channel otherwise nothing
+ *channel must be 0-15
+ * start_addr must be 32 byte aligned and uncached
+ * */
+static int start_fdma_channel(int channel,unsigned long * start_addr)
+{
+/*first we must check if the sel channel is available*/
+	if((channel < 0) && (channel >15) )
+		return -EINVAL;
+
+	if(((u32)start_addr & 0x1F)!=0){
+		printk(KERN_CRIT"FDMA CH%d adr not aligned -transfer aborted \n"
+								,channel);
+		return -EINVAL;
+	}
+
+	spin_lock(&chip.fdma_lock);
+
+	writel((u32)start_addr  | CMDSTAT_FDMA_START_CHANNEL,
+		   chip.io_base+ FDMA2_CMD_STATn + (channel * CMD_STAT_OFFSET)
+		  );
+	/*start channel*/
+	writel((MBOX_CMD_START_CHANNEL << (channel*2)),chip.io_base +
+						FDMA2_CMD_MBOX_SET_REG);
+	spin_unlock(&chip.fdma_lock);
+	return 0;
+
+}
+
+
+static void setup_node_strides(fdma_llu_entry * node,
+				struct dma_channel * chan,
+				unsigned long flags)
+{
+	/*a flag value below the 1F range indicates a paced transfer is configured
+	 * so no notion of dimensionality is applied.  Therefore line length == total bytes*/
+	if(flags & 0x1F){
+		node->node_dstride	=0;
+		node->node_sstride	=0;
+		node->length 		= chan->count;
+	}
+	else {
+		/*source x Destination*/
+		if(flags & DIM_0_x_0){
+			node->node_sstride 	=0;
+			node->node_dstride 	=0;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_0_x_1){
+			node->node_sstride 	=0;
+			node->node_dstride 	=chan->src_sz;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_0_x_2){
+			node->node_sstride 	=0;
+			node->node_dstride 	=chan->dstride;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_1_x_0){
+			node->node_sstride 	= chan->src_sz;
+			node->node_dstride 	=0;
+			node->length 		= chan->src_sz;
+		}
+		else if(flags & DIM_1_x_1){
+			node->node_sstride 	=0;
+			node->node_dstride 	=0;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_1_x_2){
+			node->node_sstride 	=chan->dst_sz;
+			node->node_dstride 	=chan->dstride;
+			node->length		=chan->dst_sz;
+		}
+		else if(flags & DIM_2_x_0){
+			node->node_sstride 	=chan->sstride;
+			node->node_dstride 	=0;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_2_x_1){
+			node->node_sstride = chan->sstride;
+			node->node_dstride 	=chan->src_sz;
+			node->length 		=chan->src_sz;
+		}
+		else if(flags & DIM_2_x_2){
+			node->node_sstride 	=chan->sstride;
+			node->node_dstride 	=chan->dstride;
+			node->length 		=chan->dst_sz;
+		}
+		else{
+			printk(" NO stride setup specified-using def config\n");
+			node->node_sstride 	=0;
+			node->node_dstride 	=0;
+			node->length 		=chan->src_sz;
+			/*we take the default config -simple mem -> mem move 1x1 */
+		}
+	}
+}
+
+
+int setup_freerunning_nodelist(struct dma_channel *chan,unsigned long flags)
+{
+	unsigned long irqflags;
+	int i=0;
+	fdma_llu_entry llu[chan->list_len];
+	unsigned long current_addr=chip.channel[chan->chan].llu_bus_addr;
+	struct dma_channel * channel = chan;
+
+	memset(&llu[0],0,sizeof(fdma_llu_entry)* chan->list_len);
+	while(i++ < channel->list_len){
+
+		current_addr +=sizeof(fdma_llu_entry);
+
+		llu[i-1].next_item = (u32)virt_to_phys((u32*)current_addr);
+		llu[i-1].saddr = chan->sar;
+		llu[i-1].daddr = chan->dar;
+		llu[i-1].size_bytes = chan->count;
+
+		if(flags & NODE_PAUSE_ISR)
+			llu[i-1].control |=  SET_NODE_COMP_PAUSE;
+
+		if(flags  & NODE_DONE_ISR)
+			llu[i-1].control |= SET_NODE_COMP_IRQ;
+
+		/*FREERUNNING TRANSFER SELECTED*/
+		/*due to a wierdness in the FDMA design,
+		freerunning xfers must alwyas set increment
+		addr for source/dest. This is an overloaded
+		parameter for the slim core and will not actually
+		produce incrementing addresses !! :-\ */
+		llu[i-1].control |= 	NODE_ADDR_INCR <<SOURCE_ADDR;
+		llu[i-1].control |= 	NODE_ADDR_INCR <<DEST_ADDR;
+		setup_node_strides(&llu[i-1],chan,flags);
+		chan++;
+
+	}
+
+	if(flags & LIST_TYPE_LINKED)
+		llu[channel->list_len-1].next_item =
+		(u32)virt_to_phys((u32*)chip.channel[channel->chan].
+								llu_bus_addr);
+	else
+		llu[channel->list_len-1].next_item = 0;
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	memcpy_toio((volatile void __iomem *)chip.channel[channel->chan].llu_bus_addr,&llu[0],
+			sizeof(fdma_llu_entry)*channel->list_len);
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+
+
+	dma_cache_wback(chip.channel[channel->chan].llu_virt_addr,
+				(sizeof(fdma_llu_entry)*channel->list_len));
+
+	return 0;
+}
+
+
+int setup_spdif_nodelist(struct dma_channel *chan,unsigned long flags)
+{
+	unsigned long irqflags;
+	fdma_spdif_entry llu[chan->list_len];
+	unsigned long req_line = flags & REQ_LINE_MASK;
+	int i=0;
+	struct dma_channel * channel = chan;
+	unsigned long current_addr=chip.channel[chan->chan].llu_bus_addr;
+	memset(&llu[0],0,sizeof(fdma_llu_entry)* chan->list_len);
+
+	while(i++ < chan->list_len){
+
+		current_addr +=sizeof(fdma_spdif_entry);
+
+		llu[i-1].next_item = (u32)virt_to_phys((u32*)current_addr);
+		llu[i-1].saddr = ALIGN(chan->sar,32);
+		llu[i-1].daddr = chan->dar;
+		llu[i-1].size_bytes = chan->count;
+		llu[i-1].control  = EXTENDED_NODE_TYPE
+				    | NODE_TYPE_SPDIF
+				    | (req_line << 8);
+
+		if(flags & NODE_PAUSE_ISR)
+			llu[i-1].control |=  SET_NODE_COMP_PAUSE;
+
+		if(flags  & NODE_DONE_ISR)
+			llu[i-1].control |= SET_NODE_COMP_IRQ;
+
+		if(chan->spdif.valid)
+			llu[i-1].control |= SPDIF_NODE_VALID;
+
+		if(chan->spdif.burst_end)
+			llu[i-1].control |= SPDIF_BURST_END;
+
+		llu[i-1].control =(llu[i-1].control & ZERO_PAD_MASK);
+
+		llu[i-1].node_pa_pb = chan->spdif.pa_pb;
+		llu[i-1].node_pc_pd =chan->spdif.pc_pd;
+		llu[i-1].node_bst_prd= chan->spdif.bst_prd;
+		llu[i-1].node_chn0_sta_low=chan->spdif.chn0_sta_low;
+		llu[i-1].node_chn0_sta_high=
+			(chan->spdif.chn0_sta_high & CHHI_STA_ZERO_PAD_MASK);
+		llu[i-1].node_chn1_sta_low=chan->spdif.chn1_sta_low;
+		llu[i-1].node_chn1_sta_high=
+			(chan->spdif.chn1_sta_high & CHHI_STA_ZERO_PAD_MASK);
+		chan++;
+	}
+	if(flags & LIST_TYPE_LINKED)
+		llu[channel->list_len-1].next_item =
+		(u32)virt_to_phys((u32*)chip.channel
+				[channel->chan].llu_virt_addr);
+	else
+		llu[chan->list_len-1].next_item = 0;
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	memcpy_toio((volatile void __iomem *)chip.channel[channel->chan].llu_bus_addr,&llu[0],
+			sizeof(fdma_spdif_entry)*channel->list_len);
+
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+	dma_cache_wback(chip.channel[channel->chan].llu_virt_addr,
+					(sizeof(fdma_spdif_entry)*
+						channel->list_len));
+	return 0;
+}
+
+int setup_paced_nodelist(struct dma_channel *chan,unsigned long flags)
+{
+	unsigned long irqflags;
+	int i=0;
+	fdma_llu_entry llu[chan->list_len];
+	unsigned long req_line = flags & REQ_LINE_MASK;
+	unsigned long current_addr=chip.channel[chan->chan].llu_bus_addr;
+	struct dma_channel * channel = chan;
+
+	memset(&llu[0],0,sizeof(fdma_llu_entry)* chan->list_len);
+	while(i++ < channel->list_len){
+
+		current_addr +=sizeof(fdma_llu_entry);
+
+		llu[i-1].next_item = (u32)virt_to_phys((u32*)current_addr);
+		llu[i-1].saddr = chan->sar;
+		llu[i-1].daddr = chan->dar;
+		llu[i-1].size_bytes = chan->count;
+
+		if(flags & NODE_PAUSE_ISR)
+			llu[i-1].control |=  SET_NODE_COMP_PAUSE;
+
+		if(flags  & NODE_DONE_ISR)
+			llu[i-1].control |= SET_NODE_COMP_IRQ;
+
+
+		req_line = flags & REQ_LINE_MASK;
+		if(! req_line){
+			printk("STB7100 FDMA PACED MODE but no req config\n");
+			return -EINVAL;
+		}
+		/*PACED TRANSFER SELECTED*/
+		llu[i-1].control |= req_line;
+
+		if(flags & DIM_1_x_0 ){
+			llu[i-1].control |= 	NODE_ADDR_INCR <<SOURCE_ADDR;
+			llu[i-1].control |=     NODE_ADDR_STATIC <<DEST_ADDR;
+		}
+		else if(flags & DIM_0_x_1){
+			llu[i-1].control |= 	NODE_ADDR_STATIC <<SOURCE_ADDR;
+			llu[i-1].control |= 	NODE_ADDR_INCR <<DEST_ADDR;
+		}
+		else {
+			printk("STB7100 FDMA PACED MODE bad dimensionality \n");
+			return -EINVAL;
+		}
+
+		setup_node_strides(&llu[i-1],chan,flags);
+		chan++;
+	}
+
+	if(flags & LIST_TYPE_LINKED)
+		llu[channel->list_len-1].next_item =
+				(u32)virt_to_phys((u32*)chip.channel
+				[channel->chan].llu_virt_addr);
+
+	else
+	    llu[channel->list_len-1].next_item = 0;
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	memcpy_toio((volatile void __iomem *)chip.channel[channel->chan].llu_bus_addr,&llu[0],
+			sizeof(fdma_llu_entry)*channel->list_len);
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+
+	dma_cache_wback(chip.channel[channel->chan].llu_virt_addr,
+					(sizeof(fdma_llu_entry)*
+					channel->list_len));
+
+	return 0;
+}
+
+
+static int setup_sg_nodelist(struct dma_channel *chan,unsigned long flags)
+{
+	unsigned long irqflags;
+	int i=0;
+	unsigned long current_addr=chip.channel[chan->chan].llu_bus_addr;
+	struct dma_channel * channel = chan;
+	struct scatterlist * src_sg=chan->src_sg;
+	struct scatterlist * dst_sg= chan->dst_sg;
+	static u32 llu_len=0;
+
+	fdma_llu_entry llu[ flags & DIM_SG_x_0 ?
+				chan->src_sg_len:
+				chan->dst_sg_len  ];
+
+	if(flags & DIM_SG_x_0)
+		llu_len = chan->src_sg_len;
+	else if (flags & DIM_0_x_SG)
+		llu_len = chan->dst_sg_len;
+	else if (flags & DIM_SG_x_SG) {}
+
+
+	memset(&llu[0],0,sizeof(fdma_llu_entry)* llu_len);
+
+	while(i++ < llu_len){
+		current_addr +=sizeof(fdma_llu_entry);
+
+		llu[i-1].next_item = (u32)virt_to_phys((u32*)current_addr);
+		if(flags & DIM_0_x_SG){
+			if((!dst_sg->dma_address) || (! dst_sg->length))
+				return -EINVAL;
+
+			llu[i-1].node_sstride 	=0;
+			llu[i-1].node_dstride 	=channel->src_sz;
+			llu[i-1].length 	=channel->src_sz;
+			/*this is essentially a 0x1 xfer */
+			llu[i-1].saddr = 	channel->sar;
+			llu[i-1].daddr = 	dst_sg->dma_address;
+			llu[i-1].size_bytes	= dst_sg->length;
+			chip.channel[chan->chan].list_len = dst_sg->length;
+			dst_sg++;
+
+		}
+		else if(flags & DIM_SG_x_0){
+			/** 1x0*/
+			if((!src_sg->dma_address) || (! src_sg->length))
+				return -EINVAL;
+
+			llu[i-1].node_sstride 	= channel->src_sz;
+			llu[i-1].node_dstride 	=0;
+			llu[i-1].length 	= channel->src_sz;
+			llu[i-1].daddr = channel->dar;
+			llu[i-1].saddr = src_sg->dma_address;
+			llu[i-1].size_bytes	=src_sg->length;
+			chip.channel[chan->chan].list_len = dst_sg->length;
+			src_sg++;
+		}
+		else{
+			return -EINVAL;
+			printk(" bad ip flags specified\n");
+		}
+		if(flags & NODE_PAUSE_ISR)
+			llu[i-1].control |=  SET_NODE_COMP_PAUSE;
+
+		if(flags  & NODE_DONE_ISR)
+			llu[i-1].control |= SET_NODE_COMP_IRQ;
+
+		/*FREERUNNING TRANSFER SELECTED*/
+		/*due to a wierdness in the FDMA design,
+		freerunning xfers must alwyas set increment
+		addr for source/dest. This is an overloaded
+		parameter for the slim core and will not actually
+		produce incrementing addresses !! :-\ */
+		llu[i-1].control |= 	NODE_ADDR_INCR <<SOURCE_ADDR;
+		llu[i-1].control |= 	NODE_ADDR_INCR <<DEST_ADDR;
+	}
+	if(flags & LIST_TYPE_LINKED)
+		llu[llu_len-1].next_item =
+		(u32)virt_to_phys((u32*)chip.channel[channel->chan].
+								llu_bus_addr);
+	else
+		llu[llu_len-1].next_item = 0;
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	memcpy_toio((volatile void __iomem *)chip.channel[channel->chan].llu_bus_addr,&llu[0],
+			sizeof(fdma_llu_entry)*llu_len);
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+
+
+	dma_cache_wback(chip.channel[channel->chan].llu_virt_addr,
+					(sizeof(fdma_llu_entry)*llu_len));
+
+
+	return 0;
+}
+
+/*must only be called when channel is in pasued state*/
+static void stb7100_fdma_unpause(struct dma_channel * chan)
+{
+	if(chan->chan < 0 || chan->chan >15)return;
+
+	if(get_fdma_chan_status(chan->chan) == FDMA_CHANNEL_PAUSED){
+
+		spin_lock(&chip.fdma_lock);
+		/*x2 as two data bits per channel*/
+		/*we want ot continue the current transfer*/
+		writel(	MBOX_CMD_START_CHANNEL << (chan->chan*2),chip.io_base +
+					FDMA2_CMD_MBOX_SET_REG);
+		spin_unlock(&chip.fdma_lock);
+	}
+}
+
+int stb7100_fdma_pause(int flush,struct dma_channel * chan)
+{
+	if(chan->chan < 0 || chan->chan >15)return -EINVAL;
+
+	spin_lock(&chip.channel_lock);
+	chip.channel[chan->chan].ch_pause =1;
+	spin_unlock	(&chip.channel_lock);
+
+	spin_lock(&chip.fdma_lock);
+
+	if(get_fdma_chan_status(chan->chan) == FDMA_CHANNEL_RUNNING){
+		if(flush)
+			writel(MBOX_CMD_PAUSE_FLUSH_CHANNEL << (chan->chan*2),chip.io_base + FDMA2_CMD_MBOX_SET_REG);
+		else{
+			writel(MBOX_CMD_PAUSE_CHANNEL << (chan->chan*2),chip.io_base +FDMA2_CMD_MBOX_SET_REG);
+			spin_unlock(&chip.fdma_lock);
+			return (get_fdma_chan_status(chan->chan) == FDMA_CHANNEL_PAUSED) ? 0: -ENODEV;
+		}
+	}
+	else{
+		spin_unlock(&chip.fdma_lock);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+
+
+void completion_ok(int  channel)
+{
+	/* preserve the callback pointer which will be clobbered when we call
+	 * free_fdma_channel().
+	 */
+	void (*comp_callback)(void*) = (chip.channel[channel]).comp_callback;
+	void *comp_callback_param = (chip.channel[channel]).comp_callback_param;
+
+	struct dma_channel * dma_chan = get_dma_channel(channel);
+
+        wake_up(&dma_chan->wait_queue);
+
+	/* do not re-order these or it will be impossible to configure another
+	 * DMA transfer from the callback.
+	 */
+	free_fdma_channel(channel);
+	if (comp_callback)
+		comp_callback(comp_callback_param);
+}
+
+void error_completion(int channel)
+{
+
+	void (*err_callback)(void*) = (chip.channel[channel]).err_callback;
+	void *err_callback_param = (chip.channel[channel]).err_callback_param;
+
+	/* TODO: Do we need a wake up here? */
+	/* If so, how would the caller know an error occurred? */
+
+	free_fdma_channel(channel);
+	if(err_callback)
+		err_callback(err_callback_param);
+}
+
+void handle_completion(int channel)
+{
+	unsigned long irqflags;
+	spin_lock_irqsave(&(chip.channel_lock), irqflags);
+	if(chip.channel[channel].cb_in_interrupt){
+		spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+		completion_ok(channel);
+	}
+	else{
+		spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+		fdma_complete[channel].data = channel;
+		tasklet_schedule(&fdma_complete[channel]);
+	}
+}
+
+void handle_err_completion(int channel)
+{
+	unsigned long irqflags;
+	spin_lock_irqsave(&(chip.channel_lock), irqflags);
+	if(chip.channel[channel].cb_in_interrupt==1){
+		spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+		error_completion(channel);
+	}
+	else{
+		spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+		tasklet_schedule(&fdma_error[channel]);
+	}
+}
+
+static void stb7100_cb_continue(int channel)
+{
+	unsigned long irqflags;
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	if(chip.channel[channel].comp_callback){
+		if(chip.channel[channel].cb_in_interrupt){
+			spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+			(chip.channel[channel]).comp_callback(
+				(chip.channel[channel]).comp_callback_param);
+            	}
+            	else{
+               		spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+			fdma_complete[channel].data = channel;
+			tasklet_schedule(&fdma_complete[channel]);
+            	}
+	}
+	if(chip.channel[channel].ch_pause){ /*usr signals pause*/
+		chip.channel[channel].ch_pause=0;
+		spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		/*we want ot continue the current transfer*/
+		spin_lock(&chip.fdma_lock);
+		writel(	MBOX_CMD_START_CHANNEL <<
+			(channel*2),chip.io_base + FDMA2_CMD_MBOX_SET_REG);
+		spin_unlock(&chip.fdma_lock);
+	}
+	else{
+		spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		/*we need to load the next tranfer*/
+		spin_lock(&chip.fdma_lock);
+		writel( readl(chip.io_base + FDMA2_PTR_REG + (
+			channel *NODE_DATA_OFFSET))
+			| CMDSTAT_FDMA_START_CHANNEL,
+			chip.io_base+ FDMA2_CMD_STATn +
+			(channel * CMD_STAT_OFFSET));
+		writel(	MBOX_CMD_START_CHANNEL << (channel*2),chip.io_base +
+						FDMA2_CMD_MBOX_SET_REG);
+		spin_unlock(&chip.fdma_lock);
+	}
+}
+
+
+static inline void __handle_fdma_err_irq(int channel)
+{
+	u32 status = get_fdma_chan_status(channel);
+	u32 err =(status & 0x1c) >>2; /*err is bits 2-4*/
+	switch(err){
+		case 0:
+			printk(KERN_CRIT"FDMA MISSED IRQ ERR ON CHANNEL %d CMD_STAT is %x \n",channel,status);
+			break;
+		case 1:
+			printk(KERN_CRIT"FDMA START CODE LIST OVERFLOW ERROR CHANNEL %d CMD_STAT is %x \n",channel,status);
+			break;
+		case 2:
+			printk(KERN_CRIT"FDMA ES BUFFER OVERFLOW ON CHANNEL %d CMD_STAT is %x \n",channel,status);
+			break;
+		default:
+			printk(KERN_CRIT"FDMA UNDEFINED ERR ON CHANNEL %d CMD_STAT is %x \n",channel,status);
+			break;
+	}
+	writel(0, chip.io_base+FDMA2_CMD_STATn + (channel* CMD_STAT_OFFSET  ));
+	handle_err_completion(channel);
+}
+
+static inline void __handle_fdma_completion_irq(int channel)
+{
+	unsigned long irqflags;
+
+	/*now we look for reason of int may be*/
+	switch(get_fdma_chan_status(channel)){
+  	case FDMA_CHANNEL_PAUSED:
+		spin_lock_irqsave(&(chip.channel_lock), irqflags);
+		if(chip.channel[channel].ch_term==1) {
+			spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+			handle_completion(channel);
+     	 	} else if(chip.channel[channel].ch_pause) {
+      			chip.channel[channel].ch_pause=0;
+			spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+      		}
+      		else {
+			spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+			stb7100_cb_continue(channel);
+      		}
+   		break;
+	case FDMA_CHANNEL_IDLE:
+		handle_completion(channel);
+		break;
+	case FDMA_CHANNEL_RUNNING:
+		break;
+	default:
+		printk(KERN_CRIT"FMDA2 unknown interrupt status \n");
+		handle_err_completion(channel);
+	}
+}
+
+
+static irqreturn_t fdma_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int channel=0;
+	u32 int_stat_val =0;
+
+	int_stat_val = readl(chip.io_base + FDMA2_INT_STAT_REG);
+	writel(int_stat_val, chip.io_base +FDMA2_INT_CLR_REG);
+
+	for(;channel<STB7100_DMA_CHANNELS;channel++){
+		if(0x03 == (int_stat_val & 0x03)){
+			u32 reg_val = readl(chip.io_base+FDMA2_CMD_STATn
+					+ (channel* CMD_STAT_OFFSET  ));
+			u32 cmd_stat_reg = chip.io_base+FDMA2_CMD_STATn
+					+ (channel* CMD_STAT_OFFSET  );
+
+			/*clear the error (2-4) bits from the CMD_STAT reg*/
+			writel(0xffffffe3 | reg_val, cmd_stat_reg);
+
+			__handle_fdma_completion_irq(channel);
+		}
+		if(0x02 == (int_stat_val & 0x02))
+			__handle_fdma_err_irq(channel);
+		else if(0x01 == (int_stat_val & 0x01))
+			__handle_fdma_completion_irq(channel);
+
+		int_stat_val = int_stat_val>>2;
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * Linux SH-DMA-API hooks
+ * */
+/*returns the number of bytes left to transfer for the current node*/
+extern int stb7100_fdma_get_residue(struct dma_channel *chan)
+{
+	unsigned long irqflags;
+	u32 chan_base = chip.io_base + (chan->chan * NODE_DATA_OFFSET);
+	unsigned long total = 0,count=0;
+	void *first_ptr=0;
+	fdma_llu_entry *cur_ptr;
+
+	spin_lock_irqsave(&chip.fdma_lock, irqflags);
+	count=readl(chan_base + FDMA2_COUNT_REG);
+	/*first read the current node data*/
+	first_ptr = (void *) readl(chan_base + FDMA2_PTR_REG);
+	if(! first_ptr)
+		goto list_complete;
+
+	first_ptr = P2SEGADDR(first_ptr);
+	/* Accumulate the bytes remaining in the list */
+	cur_ptr = P2SEGADDR(first_ptr);
+	do {
+		if(first_ptr >=(void*)P2SEGADDR(cur_ptr->next_item)
+		   || cur_ptr->next_item ==0)
+			goto list_complete;
+
+		total += cur_ptr->size_bytes;
+	} while ((cur_ptr = P2SEGADDR((fdma_llu_entry *) cur_ptr->next_item))!=0);
+list_complete:
+	total+=count;
+ 	spin_unlock_irqrestore(&chip.fdma_lock, irqflags);
+	return total;
+}
+
+static int stb7100_fdma_request(struct dma_channel *chan)
+{
+	if(chan->chan == ANY_CHANNEL){/*get the next available*/
+		chan->chan = get_next_free_channel();
+		return ( !(chan->chan >15) || (!(chan->chan <0))) ?
+							chan->chan:
+							-ENODEV;
+	}
+	else return claim_fdma_channel(chan->chan);
+}
+
+
+static int stb7100_fdma_stop(struct dma_channel *chan)
+{
+	unsigned long irqflags;
+	spin_lock_irqsave(&(chip.channel_lock), irqflags);
+	chip.channel[chan->chan].ch_term=1;
+	spin_unlock_irqrestore(&(chip.channel_lock), irqflags);
+	//Issuing a pause on an inactive channel results in the FDMA
+	// * attempting to load the next ptr
+
+	if(get_fdma_chan_status(chan->chan) != FDMA_CHANNEL_IDLE){
+		spin_lock(&(chip.fdma_lock));
+		writel((MBOX_CMD_PAUSE_CHANNEL << (chan->chan*2)),chip.io_base
+			+ FDMA2_CMD_MBOX_SET_REG);
+		spin_unlock(&(chip.fdma_lock));
+		return 0;
+	}/*throw an error if trying to stop an inactive channel*/
+	else return -ENODEV;
+}
+
+
+static void stb7100_fdma_free(struct dma_channel *chan){
+
+
+	if(get_fdma_chan_status(chan->chan) !=  FDMA_CHANNEL_IDLE){
+		stb7100_fdma_stop(chan);
+
+		printk(KERN_CRIT"STB7100 FDMA BLOCKING in free on ch %d\n",
+				chan->chan);
+
+		wait_event(chip.channel[chan->chan].cfg_blk,
+			(chip.channel[chan->chan].is_xferring==0));
+
+	}
+	fdma_complete[chan->chan].data = chan->chan;
+	tasklet_schedule(&fdma_complete[chan->chan]);
+}
+
+static int stb7100_fdma_configure(struct dma_channel *channel,
+					unsigned long flags)
+{
+	unsigned long irqflags;
+	unsigned long start_addr=0;
+	struct dma_channel *chan = channel;
+	unsigned long node_sz_bytes =0;
+	fp nodelist_configure=0;
+	int list_len=0;
+	int ret=0;
+
+	if(channel->chan <0 || channel->chan >15)
+		return -ENODEV;
+
+	switch(chan->mode){
+		case MODE_PACED:
+			list_len = channel->list_len;
+			node_sz_bytes= sizeof(fdma_llu_entry);
+			nodelist_configure =  setup_paced_nodelist;
+			break;
+		default:
+			printk("FDMA no mode specified -Using Freerunning\n");
+		case MODE_FREERUNNING:
+			if(flags & DIM_0_x_SG ){
+				list_len = channel->dst_sg_len;
+				nodelist_configure = setup_sg_nodelist;
+			}
+			else if(flags & DIM_SG_x_0){
+				list_len = channel->src_sg_len;
+				nodelist_configure = setup_sg_nodelist;
+			}
+			else if (flags & DIM_SG_x_SG){
+				printk(KERN_CRIT" SG To SG Not Supported\n");
+				return -EINVAL;
+			}
+			else{
+				list_len = channel->list_len;
+				nodelist_configure =  setup_freerunning_nodelist;
+			}
+			node_sz_bytes= sizeof(fdma_llu_entry);
+			break;
+		case MODE_SPDIF:
+			node_sz_bytes= sizeof(fdma_spdif_entry);
+			nodelist_configure =  setup_spdif_nodelist;
+			list_len = channel->list_len;
+			break;
+		case MODE_PES:
+			printk("  PES Parsing unsupported\n");
+			return -ENODEV;
+	}
+
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	if(chip.channel[chan->chan].is_xferring){
+		spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		return -EBUSY;
+	}
+	/*we are reconfiguring a channel with alloced mem,
+	 * but we haven't started zn xfer so it is ok to re-config*/
+	else if(chip.channel[chan->chan].dynamic_mem){
+		printk(KERN_CRIT"FDMA_CH%d reconfiguring configured channel\n",
+					chan->chan);
+		 free_fdma_channel(chan->chan);
+	}
+
+	if(list_len >1 ){ /*we are doing SG so we must alloc some mem for the llu*/
+		chip.channel[chan->chan].dynamic_mem =1;
+		start_addr = (unsigned long)
+				bigphysarea_alloc(node_sz_bytes*list_len);
+	}
+	else
+		start_addr = (unsigned long)&static_llu[chan->chan];
+
+	if(!start_addr){
+		spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		return -ENOMEM;
+	}
+
+	if(chan->comp_callback) {
+		chip.channel[chan->chan].comp_callback = chan->comp_callback;
+		chip.channel[chan->chan].comp_callback_param = chan->comp_callback_param;
+	}
+	if(chan->err_callback) {
+		chip.channel[chan->chan].err_callback = chan->err_callback;
+		chip.channel[chan->chan].err_callback_param = chan->err_callback_param;
+	}
+	if((CALLBACK_CONTEXT_INTERRUPT  & flags) == CALLBACK_CONTEXT_INTERRUPT)
+		chip.channel[chan->chan].cb_in_interrupt=1;
+	else
+		chip.channel[chan->chan].cb_in_interrupt=0;
+
+	chip.channel[chan->chan].alloc_mem_sz = node_sz_bytes * list_len;
+	chip.channel[chan->chan].list_len = chan->list_len;
+	chip.channel[chan->chan].llu_virt_addr = (u32*)start_addr;
+	chip.channel[chan->chan].llu_bus_addr  = (u32) ioremap(start_addr,32);
+
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+
+	ret = nodelist_configure(chan,flags);
+	channel->flags = DMA_CONFIGURED;
+
+	dma_cache_wback(chip.channel[chan->chan].llu_virt_addr,
+			chip.channel[chan->chan].alloc_mem_sz);
+
+	return ret;
+}
+
+
+
+/*optimised for a mem->mem move*/
+static int stb7100_fdma_xfer(struct dma_channel *chan)
+{
+	unsigned long irqflags;
+	unsigned long flags =0;
+	if( (!(chan->chan >=0) && (chan->chan <= 15)))
+		return -EINVAL;
+
+	if ((chan->flags != DMA_CONFIGURED)){
+		 printk("FDMA CH%d not configured - Using default(1x1)\n",chan->chan);
+		 flags=	DIM_1_x_1 |LIST_TYPE_UNLINKED;
+		 chan->src_sz = chan->count;
+
+		 chan->list_len =1;
+ 		 /*fdma specific data not set by api */
+
+ 		 stb7100_fdma_configure(chan,flags);
+	}
+	spin_lock_irqsave(&chip.channel_lock, irqflags);
+	if(chip.channel[chan->chan].is_xferring) {
+
+		spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+		if(chan->flags & DMA_SETUP_NOBLOCK)
+			return -EBUSY;
+
+		else{
+			printk(" FDMA CH%d is busy XFER BLOCKING\n",
+					chan->chan);
+
+			wait_event(chip.channel[chan->chan].cfg_blk,
+			(chip.channel[chan->chan].is_xferring==0));
+			spin_lock_irqsave(&chip.channel_lock, irqflags);
+		}
+		/*now our channel is free*/
+	}
+	//spin_lock_irqsave(&chip.channel_lock, irqflags);
+	chip.channel[chan->chan].is_xferring=1;
+	spin_unlock_irqrestore(&chip.channel_lock, irqflags);
+	return start_fdma_channel(chan->chan,(unsigned long *)
+		(virt_to_phys((u32*)chip.channel[chan->chan].llu_bus_addr)));
+
+}
+/*---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ * MODULE INIT & REGISTRATION
+ *---------------------------------------------------------------------*
+ *---------------------------------------------------------------------*
+ *--------------------------------------------------------------------*/
+
+
+static struct dma_ops stb7100_fdma_ops = {
+	.request		= stb7100_fdma_request,
+	.free			= stb7100_fdma_free,
+	.get_residue		= stb7100_fdma_get_residue,
+	.xfer			= stb7100_fdma_xfer,
+	.configure		= stb7100_fdma_configure,
+	.pause			= stb7100_fdma_pause,
+	.unpause		= stb7100_fdma_unpause,
+	.stop			= stb7100_fdma_stop,
+};
+
+static struct dma_info stb7100_fdma_info = {
+	.name			= "ST40 STB7100 FDMAC",
+	.nr_channels	= STB7100_DMA_CHANNELS,
+	.ops			= &stb7100_fdma_ops,
+	.flags			= DMAC_CHANNELS_TEI_CAPABLE,
+};
+
+
+static void __exit deinitialise_7100_fdma2(void)
+{
+
+	writel(0,chip.io_base + FDMA2_ENABLE_REG);
+	iounmap((u32*)chip.io_base);
+	free_irq(LINUX_FDMA_MESSAGE_PEND,(void *)NULL);
+}
+
+
+static int __init initialise_7100_fdma2(void)
+{
+	int irq_val=0;
+	static struct dma_info *info = &stb7100_fdma_info;
+	int channel=0;
+
+	spin_lock_init(&chip.channel_lock);
+	spin_lock_init(&chip.fdma_lock);
+	chip.io_base  =(u32) ioremap(FDMA_BASE,0);
+	memset((u32*)&chip.channel[0],0,sizeof(channel_status)* STB7100_DMA_CHANNELS);
+
+	if((irq_val = request_irq(LINUX_FDMA_MESSAGE_PEND,
+							  fdma_irq,SA_INTERRUPT,
+           					  "STB7100 FDMA",
+           					  (void*)NULL ))
+    )
+        panic(" Cant Register irq %d for FDMA engine %d\n",LINUX_FDMA_MESSAGE_PEND,irq_val);
+
+	 stb7100_bootload_fdma((char*)chip.io_base);
+	 initialise_fdma2();
+ 	 reset_channels();
+	 initialise_req_ctl();
+	for(channel=0;channel < STB7100_DMA_CHANNELS;channel++)
+	{
+		init_waitqueue_head(&chip.channel[channel].cfg_blk);
+		tasklet_init(&fdma_error[channel],(void*)error_completion,channel);
+		tasklet_init(&fdma_complete[channel],(void*)completion_ok,channel);
+	}
+
+	if(!enable_all_channels())
+		printk(KERN_CRIT"CANT ENABLE FDMA MESSAGING ");
+
+	register_dmac(info);
+
+	return 0;
+}
+
+module_init(initialise_7100_fdma2)
+module_exit(deinitialise_7100_fdma2)
diff -Naur linux-2.6.17.8/drivers/stm/7100_fdma2_firmware.h linux-2.6.17.8-sh/drivers/stm/7100_fdma2_firmware.h
--- linux-2.6.17.8/drivers/stm/7100_fdma2_firmware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/7100_fdma2_firmware.h	2006-08-23 13:29:48.985829000 +0100
@@ -0,0 +1,735 @@
+/*
+ *  STb7100 FDMA Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited.
+ *  Author: Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+
+#ifndef FMDA_7100_FIRMWARE
+#define FMDA_7100_FIRMWARE
+/*This firmware version 2.2*/
+#define FIRMWARE_REVISION "2.2.0"
+static unsigned long DATA_REGION[]=
+{
+  0x00030202, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x23104052, 0x00000000, 0x00000000, 0x21100051, 0x00000000,
+  0x020701b2, 0x020a01b5, 0x020d01b8, 0x021001bb, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x0000031e, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x0000007e, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000fe, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00002438, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001441,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001446, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000144b, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001450,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001455, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x0000145a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000145f,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001464, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001469, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000146e,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001473, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001478, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000147d,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00001482, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00001487, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000222e, 0x05800580,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x0000222e, 0x05a005a0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x0000222e, 0x05c005c0, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0xffffff00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
+
+//#define DATA_REGION_LENGTH (0x00000600)
+
+
+static unsigned long IMEM_REGION[]=
+{
+  0x00f51000, 0x00ef0013, 0x00e10001, 0x00ee0170, 0x00b010ea, 0x00f01000,
+  0x00ef0013, 0x00a300e0, 0x00aa000b, 0x00433a00, 0x009c1526, 0x009b332b,
+  0x009a2251, 0x00d00090, 0x00a70005, 0x00177030, 0x009c1230, 0x00d00090,
+  0x00a00006, 0x009c1497, 0x00d00090, 0x00a70002, 0x009c1603, 0x00d00090,
+  0x00a70004, 0x009c179e, 0x00d00090, 0x00a70021, 0x009c185f, 0x00d00090,
+  0x00a90003, 0x009c1036, 0x00d00090, 0x00a20001, 0x009c1481, 0x00d00090,
+  0x00f00000, 0x00d00017, 0x00452003, 0x00461003, 0x00355600, 0x00755461,
+  0x00a6040e, 0x00555001, 0x00765080, 0x00d00090, 0x00b0640e, 0x00755c23,
+  0x00761c62, 0x00266500, 0x007564ca, 0x00d00090, 0x00b0540b, 0x00840d00,
+  0x00b0deff, 0x003ee001, 0x00799e00, 0x00d19040, 0x00ea0460, 0x00721484,
+  0x00222a00, 0x00f00000, 0x00aa020e, 0x00ac020f, 0x00a50a0c, 0x00ab0a0e,
+  0x00b050e9, 0x00d0b070, 0x009c106c, 0x00d00090, 0x00a70a0d, 0x00a40003,
+  0x0074003f, 0x00840700, 0x00a50a04, 0x00b04003, 0x00d7c070, 0x0098106c,
+  0x0044507f, 0x009c10a9, 0x00d7c070, 0x00177002, 0x0098106c, 0x00407080,
+  0x00981125, 0x00ed0060, 0x008c812b, 0x009c812b, 0x00e70020, 0x00af0007,
+  0x005f0500, 0x00a82c00, 0x005f0800, 0x00b080eb, 0x00255004, 0x009a80e4,
+  0x00377001, 0x008c305b, 0x00a600e9, 0x00b0c20f, 0x00a80a02, 0x00a70a05,
+  0x00605800, 0x009c1069, 0x0005073c, 0x00b06a0c, 0x00b05a04, 0x00b0ba0e,
+  0x00a70a01, 0x0098111f, 0x00d00090, 0x00a50a00, 0x00d6b070, 0x0088108f,
+  0x0099109d, 0x00d00090, 0x00a40201, 0x00ef4042, 0x00744d10, 0x00144008,
+  0x004f50f0, 0x00a32b00, 0x009c2082, 0x00d00090, 0x005f4001, 0x00a72b00,
+  0x00af2b00, 0x004f3001, 0x000f073c, 0x00d00816, 0x005f0400, 0x00af2b00,
+  0x000f033c, 0x005f0000, 0x00a70a01, 0x00255010, 0x00377010, 0x00b05a00,
+  0x00b07a01, 0x0098311f, 0x00d0b070, 0x009c1072, 0x00d00090, 0x00a00003,
+  0x00b0ba0e, 0x00982046, 0x00d00090, 0x00a00202, 0x0098109d, 0x00d00090,
+  0x00e30027, 0x00d0c370, 0x009c212b, 0x00d00090, 0x00a60003, 0x00b00003,
+  0x00b06002, 0x00b0ba0e, 0x00d4b070, 0x00d7c070, 0x00544700, 0x008c112b,
+  0x00d00090, 0x00a70202, 0x009c112b, 0x00ed00a7, 0x008c04d8, 0x00b00003,
+  0x00d0121b, 0x0099112b, 0x00ed00ca, 0x00d7c070, 0x00177002, 0x0098106c,
+  0x00d00090, 0x00a00202, 0x009810b3, 0x00307020, 0x0098208f, 0x0044501f,
+  0x00234700, 0x004030e0, 0x009810b8, 0x00e30020, 0x00333001, 0x003734ff,
+  0x007430a8, 0x00ef4252, 0x005f0400, 0x004f50e0, 0x00764c62, 0x009810c5,
+  0x005f0000, 0x00366001, 0x009c30c0, 0x00d00090, 0x00d00090, 0x00a82c00,
+  0x005f0800, 0x00b080eb, 0x00255004, 0x009a80e4, 0x00377004, 0x009c30c5,
+  0x00764ca8, 0x00d00090, 0x003606e1, 0x0016603e, 0x009810d5, 0x005f0000,
+  0x00366001, 0x009c30d1, 0x00d00090, 0x00b0c20f, 0x00a600e9, 0x00a80a02,
+  0x00a70a05, 0x00605800, 0x009c10dc, 0x0005073c, 0x00b06a0c, 0x00b05a04,
+  0x00b0ba0e, 0x00d4c070, 0x0098106c, 0x0044507f, 0x009c10a9, 0x00d0061c,
+  0x00a30a00, 0x00433001, 0x00941d00, 0x00d00090, 0x00b06eff, 0x00b07efe,
+  0x00b08efd, 0x00b09efc, 0x00b0cefb, 0x003ee005, 0x00a60a07, 0x00a70a08,
+  0x00a800e9, 0x00ec0000, 0x00788d00, 0x00106001, 0x009c2103, 0x00796d08,
+  0x003c9800, 0x00796d00, 0x00398900, 0x005cc900, 0x006cc600, 0x009c2103,
+  0x007c6c3d, 0x007cc43e, 0x00666c00, 0x007c7c3d, 0x007cc43e, 0x00577c00,
+  0x00d01112, 0x00107001, 0x009c2119, 0x00797d08, 0x003c9800, 0x00797d00,
+  0x00398900, 0x005cc900, 0x006cc700, 0x009c2119, 0x007c7c3d, 0x007cc43e,
+  0x00677c00, 0x007c6c3d, 0x007cc43e, 0x00566c00, 0x00a900e9, 0x00b06a07,
+  0x00b07a08, 0x00799c48, 0x002995fc, 0x00b28b00, 0x00b29b00, 0x00ac1e01,
+  0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00840d00, 0x00a40a00,
+  0x007b0210, 0x00544001, 0x00d00090, 0x00b04a00, 0x00d0081f, 0x00a30202,
+  0x009810a9, 0x00d00090, 0x00a60003, 0x00b00003, 0x00b06002, 0x00ad1e01,
+  0x00d00211, 0x00a50a04, 0x00b04003, 0x00d7c070, 0x0098106c, 0x0044507f,
+  0x009c1151, 0x00d7c070, 0x00177002, 0x0098106c, 0x00407080, 0x009811ed,
+  0x00ed0143, 0x008c81f3, 0x009c81f3, 0x00e70020, 0x00af0007, 0x005f0500,
+  0x00a82c00, 0x005f0800, 0x00b080eb, 0x00255004, 0x009a818b, 0x00377001,
+  0x008c313e, 0x00a600e9, 0x00b0c20f, 0x00a80a02, 0x00a70a05, 0x00605800,
+  0x009c114c, 0x0005073c, 0x00b06a0c, 0x00b05a04, 0x00b0ba0e, 0x008c006c,
+  0x008c008f, 0x009911f3, 0x00ed0172, 0x00d7c070, 0x00177002, 0x0098106c,
+  0x00d00090, 0x00a00202, 0x0098115b, 0x00307020, 0x0098208f, 0x0044501f,
+  0x00234700, 0x004030e0, 0x00981160, 0x00e30020, 0x00333001, 0x003734ff,
+  0x007430a8, 0x00ef4252, 0x005f0400, 0x004f50e0, 0x00764c62, 0x0098116d,
+  0x005f0000, 0x00366001, 0x009c3168, 0x00d00090, 0x00d00090, 0x00a82c00,
+  0x005f0800, 0x00b080eb, 0x00255004, 0x009a818b, 0x00377004, 0x009c316d,
+  0x00764ca8, 0x00d00090, 0x003606e1, 0x0016603e, 0x0098117d, 0x005f0000,
+  0x00366001, 0x009c3179, 0x00d00090, 0x00b0c20f, 0x00a600e9, 0x00a80a02,
+  0x00a70a05, 0x00605800, 0x009c1184, 0x0005073c, 0x00b06a0c, 0x00b05a04,
+  0x00d4c070, 0x0098106c, 0x0044507f, 0x009c1151, 0x00d0061c, 0x00a30a00,
+  0x00433001, 0x00941d00, 0x00d00090, 0x00b08a10, 0x00b01eff, 0x00b04efe,
+  0x00b07efd, 0x00b08efc, 0x00b09efb, 0x00b0cefa, 0x003ee006, 0x00a800e9,
+  0x00788d00, 0x0047801f, 0x00d00090, 0x00ac0e00, 0x00a900e9, 0x00778ca0,
+  0x00799c48, 0x0003093c, 0x002995fc, 0x00e44400, 0x00144710, 0x009c21ce,
+  0x00d00090, 0x00d0c070, 0x009c11ad, 0x00d00090, 0x00d00090, 0x00e401f5,
+  0x00b09a11, 0x00b04a0d, 0x00d01e10, 0x00a7030c, 0x00777e00, 0x00a42c00,
+  0x00a10a10, 0x00840700, 0x00714100, 0x00011001, 0x00d01b1c, 0x00714200,
+  0x00011002, 0x00d01b1c, 0x00714300, 0x00011003, 0x00d01b1c, 0x0001043c,
+  0x00011040, 0x00d41040, 0x00ac0a12, 0x003404e1, 0x00111400, 0x002404e1,
+  0x00111400, 0x00311001, 0x00d00090, 0x00b01a12, 0x00301c00, 0x009831d8,
+  0x00d00090, 0x00a10a08, 0x00211001, 0x00d00090, 0x00b01a08, 0x00d01e10,
+  0x00e40270, 0x00144710, 0x009821d8, 0x00d00090, 0x00d00090, 0x00780327,
+  0x00d00090, 0x00b28b00, 0x00b29b00, 0x00d01e10, 0x00ac0a08, 0x00b00a08,
+  0x002cc001, 0x0078c308, 0x00780027, 0x00d00090, 0x00b28b00, 0x00b29b00,
+  0x00ac1e01, 0x00a91e01, 0x00a81e01, 0x00a71e01, 0x00a41e01, 0x00a11e01,
+  0x00840d00, 0x00a40a00, 0x007b0210, 0x00544001, 0x00d00090, 0x00b04a00,
+  0x00d0081f, 0x00a30202, 0x00981151, 0x00d00090, 0x00a60003, 0x00b00003,
+  0x00b06002, 0x00ad1e01, 0x00d00211, 0x00b01eff, 0x00b02efe, 0x00b03efd,
+  0x00b04efc, 0x00b0befb, 0x00b0cefa, 0x003ee006, 0x00e2012d, 0x00a32c00,
+  0x00b02a0d, 0x00a20a0c, 0x00742c48, 0x00d00090, 0x00a4040c, 0x00744e10,
+  0x00a10a10, 0x00d00090, 0x00840400, 0x00713100, 0x00011001, 0x00d02111,
+  0x00713200, 0x00011002, 0x00d02111, 0x00713300, 0x00011003, 0x00d02111,
+  0x0001033c, 0x00011040, 0x00d41040, 0x00a30a12, 0x003404e1, 0x00111400,
+  0x002404e1, 0x00111400, 0x00311001, 0x00a40a08, 0x00b01a12, 0x00244001,
+  0x00301300, 0x00983221, 0x00d00090, 0x00b04a08, 0x00d02219, 0x00a10a0c,
+  0x00a30a11, 0x00b00a08, 0x00714308, 0x00710027, 0x00d00090, 0x00b21b00,
+  0x00b23b00, 0x00ac1e01, 0x00a01e01, 0x00a41e01, 0x00a31e01, 0x00a21e01,
+  0x00a11e01, 0x00d0121d, 0x00f00000, 0x00d87040, 0x0098224b, 0x00e10460,
+  0x00198004, 0x00299100, 0x00e10000, 0x00aa0900, 0x00ed023a, 0x008c04bf,
+  0x0098124b, 0x00e4033d, 0x007445f0, 0x00544850, 0x00a1000a, 0x00b04300,
+  0x005f1200, 0x004fa0e0, 0x00ea0001, 0x00ab090f, 0x001aa800, 0x007b01f0,
+  0x00677a00, 0x00e10040, 0x00b0b90f, 0x00b0190b, 0x00d02311, 0x00aa0005,
+  0x00d00090, 0x007a7210, 0x00d00090, 0x00b0a005, 0x00d00112, 0x00ac00f0,
+  0x00a80005, 0x00d1c040, 0x00982329, 0x0011103f, 0x001a1001, 0x00320a00,
+  0x0013c200, 0x00193a00, 0x00e20261, 0x00222300, 0x006cc900, 0x00eb0460,
+  0x0005013c, 0x00155004, 0x00255b00, 0x00840200, 0x00d02c1f, 0x00d02910,
+  0x00a40501, 0x00724ca0, 0x00981290, 0x00e405e0, 0x00244200, 0x00c0201f,
+  0x00981290, 0x00eb0001, 0x00a20400, 0x00702c2e, 0x009c1290, 0x001bb100,
+  0x00588b00, 0x00a2050f, 0x00aa050c, 0x00ab050b, 0x007bbd00, 0x009c1253,
+  0x00d22070, 0x00981299, 0x00f00000, 0x00991253, 0x00122002, 0x00b0050c,
+  0x00ab050d, 0x00b0250d, 0x003bb200, 0x00b0deff, 0x00b01efe, 0x00b05efd,
+  0x003ee003, 0x00ed0285, 0x008c08f8, 0x00a51e01, 0x00a11e01, 0x00ad1e01,
+  0x00a2050d, 0x00b0a50c, 0x0098128f, 0x002bb200, 0x00d00090, 0x00b0b50d,
+  0x00d02513, 0x00b0b50d, 0x00a2050b, 0x00722d00, 0x009c1253, 0x00e20001,
+  0x00122100, 0x00ab0022, 0x004bb200, 0x009c1253, 0x00588200, 0x00a40501,
+  0x00eb0001, 0x007a4ca0, 0x001bba00, 0x004bb0fe, 0x009812ab, 0x009c22a6,
+  0x007a4d00, 0x00c0a03f, 0x009c12ab, 0x007a4ca8, 0x00eb0001, 0x001bba00,
+  0x00a3000b, 0x006bb0ff, 0x00433b00, 0x00d00090, 0x00b0300b, 0x00ab050b,
+  0x007bbd00, 0x009c1253, 0x00722210, 0x006220ff, 0x00ab0001, 0x00a40002,
+  0x004bb200, 0x00444200, 0x00b0b001, 0x00ab0006, 0x00b04002, 0x00a40004,
+  0x004bb200, 0x00444200, 0x00488200, 0x00b0b006, 0x00b04004, 0x00a40021,
+  0x00444200, 0x00eb0003, 0x00b04021, 0x00a40110, 0x0074b0a0, 0x00a300f4,
+  0x001b1001, 0x00e20001, 0x00122b00, 0x00402300, 0x009812cb, 0x00122001,
+  0x00740062, 0x00b020f5, 0x00b04110, 0x00b090f2, 0x00d02513, 0x00e40001,
+  0x00144100, 0x006440ff, 0x00488400, 0x00a60110, 0x0042601f, 0x004660e0,
+  0x00566002, 0x00c02000, 0x00b06110, 0x009812e0, 0x00e20001, 0x00122110,
+  0x00588200, 0x00b06500, 0x00b090f2, 0x00d02513, 0x00a00502, 0x009c12eb,
+  0x0002053c, 0x00b0ceff, 0x00b08efe, 0x003ee002, 0x00ed02e8, 0x008c04d8,
+  0x00a81e01, 0x00ac1e01, 0x00d02513, 0x00a40501, 0x00b06110, 0x0042401f,
+  0x00981309, 0x0042403f, 0x00c0201f, 0x00981310, 0x00c0203f, 0x00981317,
+  0x00e605e0, 0x0042401f, 0x00e40001, 0x00144200, 0x00a3000b, 0x00533400,
+  0x00266200, 0x00b0300b, 0x00a20600, 0x00721088, 0x00742c2e, 0x00b02600,
+  0x00144004, 0x00244100, 0x00e60001, 0x00166400, 0x00a20006, 0x00522600,
+  0x00b090f2, 0x00b02006, 0x00d02513, 0x00a20001, 0x00eb0001, 0x001bb100,
+  0x00522b00, 0x00b090f2, 0x00b02001, 0x00d02513, 0x00a20002, 0x00eb0001,
+  0x001bb100, 0x00522b00, 0x00b090f2, 0x00b02002, 0x00d02513, 0x00a20004,
+  0x00704c2d, 0x0098131c, 0x00d00090, 0x00a20021, 0x00eb0001, 0x001bb100,
+  0x00522b00, 0x00b090f2, 0x00704c2d, 0x009c1324, 0x00d00090, 0x00b02004,
+  0x00704c2d, 0x00981328, 0x00d00090, 0x00b02021, 0x00d02513, 0x00b08005,
+  0x00d0001e, 0x00d80050, 0x00788c4c, 0x0098100c, 0x00da8040, 0x00e60140,
+  0x0076a023, 0x00a70aec, 0x00767060, 0x00d00090, 0x00a10600, 0x00b06009,
+  0x00731c80, 0x00741df0, 0x00751c64, 0x00e20460, 0x00793484, 0x00299200,
+  0x00840400, 0x00f00000, 0x0007093c, 0x00d00090, 0x00d00008, 0x00b1f701,
+  0x00a00902, 0x00981475, 0x00d00090, 0x00a70903, 0x00a20904, 0x00a60901,
+  0x0040601f, 0x00b06901, 0x00981351, 0x0047603f, 0x00c0701f, 0x0098136b,
+  0x00c0703f, 0x0098138d, 0x00d0451f, 0x00e70001, 0x00d00008, 0x00400f00,
+  0x00a60001, 0x00177300, 0x00566700, 0x00d00090, 0x00b06001, 0x00a60905,
+  0x00a70902, 0x00307600, 0x008c235e, 0x0006073c, 0x00a10903, 0x00b0690c,
+  0x00b0690d, 0x00a20904, 0x00b01909, 0x00b0290a, 0x0004093c, 0x00b0deff,
+  0x003ee001, 0x00ed0369, 0x008c0026, 0x00ad1e01, 0x00d0471b, 0x00d00008,
+  0x00400f00, 0x00a70002, 0x00e20001, 0x00122300, 0x00577200, 0x007a6c88,
+  0x001aa005, 0x00e20560, 0x002aa200, 0x00b07002, 0x00b0a90e, 0x00b0090b,
+  0x00a00a0d, 0x008c147b, 0x00a60a0e, 0x00760210, 0x00a20a0f, 0x00b06a0e,
+  0x00722a10, 0x00e60001, 0x00b02a0f, 0x00a2090f, 0x00e7004a, 0x00a60a07,
+  0x00706c3c, 0x00881388, 0x00e7012d, 0x00b00a08, 0x00720210, 0x00b07a0d,
+  0x00b0290f, 0x00b00a13, 0x00d0471b, 0x00706c2d, 0x009c142a, 0x00d00090,
+  0x00ac090f, 0x007c0210, 0x00eb05c0, 0x00b0c90f, 0x00a00b09, 0x009813b0,
+  0x00d00090, 0x00ad0903, 0x007ddc62, 0x00a2090e, 0x00522001, 0x00762c23,
+  0x002dd600, 0x00b0290e, 0x001dd00a, 0x00d00090, 0x00d00008, 0x00500f00,
+  0x00b0d90b, 0x00ad0902, 0x00a20901, 0x00702c3d, 0x009813aa, 0x00d00090,
+  0x00b0d90c, 0x00d03c19, 0x00ed0001, 0x0072d03c, 0x00b0090c, 0x00b02901,
+  0x00ed0000, 0x00d03c19, 0x00080b3c, 0x00a10903, 0x00d00004, 0x00b1f801,
+  0x00d00004, 0x00500f00, 0x00a20904, 0x0004093c, 0x00ed03ba, 0x008c0026,
+  0x00ad0902, 0x00a20901, 0x00b0d90c, 0x00702c3d, 0x009c13c9, 0x00d00090,
+  0x00ad0310, 0x004dd0e0, 0x0002093c, 0x00b0d310, 0x00b00900, 0x0001033c,
+  0x00ed03c8, 0x008c04d8, 0x00d0471b, 0x002dd003, 0x001dd03e, 0x001dd003,
+  0x00d00090, 0x00b0d90d, 0x00b0d902, 0x00a00b09, 0x009c1412, 0x00d00090,
+  0x00ad0907, 0x003dd002, 0x00a20b03, 0x00b0db09, 0x00782c44, 0x0042200f,
+  0x00188002, 0x00b02b03, 0x00b08909, 0x00a20b01, 0x00762c44, 0x0042200f,
+  0x00166002, 0x00b02b01, 0x00b06908, 0x00ad0b00, 0x00a20b02, 0x00b0db04,
+  0x00b02b06, 0x00ad0b01, 0x00a20b03, 0x00b0db05, 0x00ed00be, 0x00b02b07,
+  0x00b0db08, 0x00a50b00, 0x00a70905, 0x000d073c, 0x007d6200, 0x007d5021,
+  0x0015503f, 0x00b2dc00, 0x00a40b02, 0x001d7010, 0x007d8200, 0x007d4021,
+  0x0014403f, 0x00b2dc00, 0x00a70906, 0x000d073c, 0x007d6200, 0x007d5021,
+  0x0015503f, 0x00b2dc00, 0x001d7010, 0x007d8200, 0x007d4021, 0x0014403f,
+  0x00b2dc00, 0x00ad0b01, 0x0075d21e, 0x001dd03e, 0x00b05b00, 0x00b0db01,
+  0x00a20b03, 0x0074221e, 0x0012203e, 0x00ad090d, 0x002dd010, 0x00b04b02,
+  0x00b02b03, 0x00b0d90d, 0x00b0d902, 0x00b0c90f, 0x00ad0901, 0x0072dca8,
+  0x00e80001, 0x00a00900, 0x009c1418, 0x007d803c, 0x00168200, 0x00a5000b,
+  0x00555600, 0x00148300, 0x00b0500b, 0x00b0d901, 0x00b04004, 0x00ed05e0,
+  0x002dd200, 0x00a60310, 0x00ab0d00, 0x007b3088, 0x004660e0, 0x00566002,
+  0x00b0bd00, 0x00b06310, 0x00010a3c, 0x00d0471b, 0x00ac090f, 0x007c0210,
+  0x00b0090b, 0x00eb05c0, 0x00080b3c, 0x00b0c90f, 0x00d00004, 0x00b1f801,
+  0x00d00004, 0x00500f00, 0x00a10902, 0x00a20b03, 0x00b0190c, 0x00b0190d,
+  0x00782c49, 0x00722d20, 0x00188002, 0x00b02b03, 0x00b02b07, 0x00b08909,
+  0x00a20b01, 0x00762c49, 0x00722d20, 0x00166002, 0x00b02b01, 0x00b02b05,
+  0x00b06908, 0x00a10b00, 0x00a20b02, 0x00b01b04, 0x00e100c0, 0x00b02b06,
+  0x00b01b08, 0x00a10901, 0x00721ca8, 0x00e80001, 0x00168200, 0x00a5000b,
+  0x00555600, 0x00148300, 0x00b0500b, 0x00b04021, 0x00e105e0, 0x00211200,
+  0x00a60310, 0x00ab0100, 0x007b3088, 0x004660e0, 0x00566002, 0x00b0b100,
+  0x00b06310, 0x00010a3c, 0x00d0471b, 0x00d00008, 0x00400f00, 0x00e805e0,
+  0x004a601f, 0x00268a00, 0x00a2000b, 0x00a70600, 0x00e50001, 0x00773088,
+  0x00155a00, 0x00b07600, 0x00777c2e, 0x00177004, 0x00233700, 0x00e70001,
+  0x00177300, 0x00aa0006, 0x00522500, 0x005aa700, 0x00b0200b, 0x00b0a006,
+  0x00d03519, 0x0001033c, 0x0002093c, 0x00d00008, 0x00500f00, 0x00ed047b,
+  0x008c04d8, 0x00a20009, 0x00712c23, 0x00722c60, 0x00ed0480, 0x008c04cf,
+  0x00d0321b, 0x00a30005, 0x00142030, 0x008c1485, 0x00722210, 0x00733210,
+  0x006330ff, 0x00422300, 0x00981024, 0x00d12040, 0x00e30001, 0x00133100,
+  0x00622300, 0x00311010, 0x00b02001, 0x00b01eff, 0x003ee001, 0x00ed0493,
+  0x008c0890, 0x00a11e01, 0x00ed0496, 0x008c08f8, 0x00d00214, 0x00a20006,
+  0x00722e10, 0x009c149b, 0x00d04a1b, 0x00d12040, 0x00e30001, 0x00133100,
+  0x00622300, 0x00b01eff, 0x00b02efe, 0x00b0defd, 0x003ee003, 0x00ed04a5,
+  0x008c0890, 0x00ad1e01, 0x00a21e01, 0x00a11e01, 0x00500200, 0x009c149b,
+  0x00d00090, 0x00a20006, 0x00722e00, 0x009c14af, 0x00d00115, 0x00d12040,
+  0x00e30001, 0x00133100, 0x00622300, 0x00b01eff, 0x00b02efe, 0x00b0defd,
+  0x003ee003, 0x00ed04b9, 0x008c08f8, 0x00ad1e01, 0x00a21e01, 0x00a11e01,
+  0x00500200, 0x009c14af, 0x00d00115, 0x00e30140, 0x00731023, 0x00e40001,
+  0x00a10300, 0x00d21040, 0x009c34c7, 0x00422000, 0x00840d00, 0x00144200,
+  0x00611400, 0x00742c22, 0x00b01300, 0x00533200, 0x0072244c, 0x0072403e,
+  0x00840d00, 0x00e30140, 0x00731023, 0x00e40001, 0x00144200, 0x00a10300,
+  0x00511400, 0x00d00090, 0x00b01300, 0x00840d00, 0x00a30201, 0x0007033c,
+  0x0077005e, 0x00ea05e0, 0x00b07201, 0x00773d00, 0x00c0703f, 0x009c14e2,
+  0x00773ca8, 0x00d04e16, 0x0047301f, 0x00c0701f, 0x009c14e6, 0x00e70000,
+  0x00a9000b, 0x00e80001, 0x00188700, 0x0078003f, 0x00780020, 0x006880ff,
+  0x00499800, 0x00a40110, 0x00b0900b, 0x00a60005, 0x00e70001, 0x00177100,
+  0x00777210, 0x006770ff, 0x00a80001, 0x00a90002, 0x00aa0006, 0x00488700,
+  0x00499700, 0x004aa700, 0x00b08001, 0x00a80004, 0x00b09002, 0x00488700,
+  0x00a90021, 0x00b0a006, 0x00499700, 0x00b08004, 0x00b09021, 0x00a00200,
+  0x00d50050, 0x00455001, 0x00773c3f, 0x00555700, 0x00981511, 0x00d00090,
+  0x00a700f4, 0x00181001, 0x00155800, 0x00407500, 0x00981511, 0x00155001,
+  0x00740062, 0x00a70200, 0x0098151a, 0x00773c3e, 0x0098151a, 0x00177100,
+  0x00566700, 0x00e70003, 0x00747040, 0x00d05212, 0x00a70200, 0x009c151e,
+  0x00740040, 0x00d05212, 0x00547002, 0x00e70001, 0x00177110, 0x00566700,
+  0x00b04110, 0x00b06005, 0x00b050f5, 0x00840d00, 0x00ec0001, 0x00da3040,
+  0x008c252a, 0x00d0001b, 0x0016ca00, 0x00eb05e0, 0x00633600, 0x002bba00,
+  0x00e40460, 0x00ab0b00, 0x0079bc88, 0x00169004, 0x00244600, 0x0076bc2e,
+  0x009c157d, 0x00d00090, 0x00a7040b, 0x00a1040e, 0x00401001, 0x009c153c,
+  0x00500700, 0x009c1527, 0x004110fe, 0x0076bc84, 0x00a8040c, 0x00b0140e,
+  0x00981527, 0x0075bcb8, 0x00255001, 0x00a1040f, 0x0016563e, 0x009c1547,
+  0x00e60001, 0x00751cc9, 0x00155002, 0x00d11070, 0x00211001, 0x00355100,
+  0x00305600, 0x00982527, 0x000a043c, 0x00b03eff, 0x003ee001, 0x0071bc56,
+  0x00981556, 0x00f40000, 0x0099255b, 0x00d05518, 0x00f00000, 0x0099155b,
+  0x00ed055a, 0x008c04bf, 0x009c155f, 0x00d00090, 0x00d00090, 0x00a31e01,
+  0x00d05217, 0x0075bc84, 0x00e409a3, 0x007445f0, 0x00544900, 0x00745064,
+  0x00725084, 0x00b04300, 0x0071bcb8, 0x0098156a, 0x007210b8, 0x0072c034,
+  0x00211001, 0x00111500, 0x0075bc3d, 0x0072503d, 0x005f2c00, 0x00a20a03,
+  0x005f0200, 0x0075bc3d, 0x00981574, 0x00222100, 0x00a80a0c, 0x00388100,
+  0x009c2578, 0x0008003c, 0x00b02a03, 0x00b01a0b, 0x00b08a0c, 0x00a31e01,
+  0x00d05217, 0x00a8040d, 0x009835e5, 0x0008093c, 0x00a70402, 0x009835e5,
+  0x0077bc84, 0x0075bcb8, 0x00255001, 0x00a9040f, 0x0016573e, 0x00d59670,
+  0x00982527, 0x00307002, 0x009c258e, 0x00e60004, 0x00370700, 0x00166700,
+  0x0007043c, 0x00b03eff, 0x003ee001, 0x0071bc56, 0x00981596, 0x00f50000,
+  0x0099159b, 0x00d05918, 0x00f00000, 0x0099259b, 0x00ed059a, 0x008c04bf,
+  0x009c159f, 0x00d00090, 0x00d00090, 0x00a31e01, 0x00d05217, 0x0075bc84,
+  0x00e40836, 0x007445f0, 0x00544800, 0x00745064, 0x00746127, 0x0015c800,
+  0x00b04300, 0x00a80022, 0x00588500, 0x0004073c, 0x00b08022, 0x0070bc65,
+  0x009815e6, 0x00e54002, 0x0071bcb8, 0x009815b2, 0x007510b8, 0x0075c034,
+  0x0071bc84, 0x007510a4, 0x0071bc3d, 0x0075103d, 0x005f2500, 0x00a20404,
+  0x0005063c, 0x005f0200, 0x00af2900, 0x00355001, 0x009835be, 0x00d05b1a,
+  0x00156002, 0x0070bc3d, 0x008815c2, 0x00222500, 0x00a70402, 0x00a8040d,
+  0x00377500, 0x00388500, 0x009c35db, 0x00d00090, 0x00a80405, 0x00308700,
+  0x009825cc, 0x0008073c, 0x00a50401, 0x00b0840c, 0x00705c26, 0x009815db,
+  0x0079022f, 0x00a50406, 0x00a10409, 0x00211500, 0x00b0deff, 0x003ee001,
+  0x00b01409, 0x00b01403, 0x00ed05da, 0x008c0026, 0x00ad1e01, 0x00a1000b,
+  0x0016ca00, 0x00611600, 0x00b02404, 0x00b0100b, 0x00b0840d, 0x00b0940f,
+  0x00b07402, 0x00a31e01, 0x00d05217, 0x00d05217, 0x0071bc84, 0x00c01000,
+  0x009c15f7, 0x00e14102, 0x00e50310, 0x00715210, 0x005f2100, 0x00a20404,
+  0x00efeeee, 0x005f0200, 0x00a12900, 0x001f1000, 0x001f1038, 0x001f1030,
+  0x001f1028, 0x00e50004, 0x00d05b1f, 0x00e14112, 0x00e50110, 0x00715210,
+  0x005f2100, 0x00a20404, 0x00efffcc, 0x005f0200, 0x00a12900, 0x001f1000,
+  0x001f1030, 0x00e50004, 0x00d05b1f, 0x00a20005, 0x00722210, 0x006220ff,
+  0x00477200, 0x00d87040, 0x0098262a, 0x00e20001, 0x00122800, 0x0009083c,
+  0x00199004, 0x00e20460, 0x00299200, 0x00677200, 0x00a0090b, 0x009c162a,
+  0x00f00000, 0x00aa0903, 0x00ab0902, 0x0099162a, 0x00983607, 0x00e10147,
+  0x00e2062b, 0x00a00100, 0x009c1018, 0x00548050, 0x00742210, 0x00e26310,
+  0x00b04100, 0x00e33051, 0x00732210, 0x005f0300, 0x005f0a00, 0x00e20080,
+  0x002aa200, 0x0013203e, 0x003bb200, 0x00b0a903, 0x00b0390b, 0x00b0b902,
+  0x00d00118, 0x00ad090e, 0x00ab090b, 0x00ac090f, 0x00fa1000, 0x00a40d0a,
+  0x00a80d09, 0x00b040e9, 0x007f8c61, 0x00fa3000, 0x004f8080, 0x00b0e008,
+  0x00ae0d0f, 0x00a20d0b, 0x00981645, 0x00d00090, 0x00d00090, 0x00ad1e01,
+  0x00aa1e01, 0x00a81e01, 0x00a71e01, 0x00a61e01, 0x00a51e01, 0x00a41e01,
+  0x00a31e01, 0x00a11e01, 0x00840200, 0x00e2064a, 0x00a400ec, 0x00c04007,
+  0x009c171a, 0x00d00090, 0x00d00090, 0x00080f3c, 0x003bb001, 0x00b080eb,
+  0x00d00090, 0x009a865c, 0x00d00090, 0x00a00d13, 0x009c2658, 0x00d00090,
+  0x00d00090, 0x00b2ac00, 0x000a083c, 0x00d06416, 0x00e4ffff, 0x000a083c,
+  0x00b04d13, 0x00d06416, 0x00a50d06, 0x00105001, 0x009c2651, 0x00d00090,
+  0x00a100e9, 0x00745d08, 0x00b01d0a, 0x00761d00, 0x00374600, 0x00745d00,
+  0x00366400, 0x00577600, 0x00677500, 0x0098266b, 0x00d06511, 0x00a70d09,
+  0x00b000e9, 0x00711c48, 0x00777c41, 0x003771fb, 0x00fa1000, 0x00a40d09,
+  0x00747041, 0x004f7003, 0x00b04d09, 0x00307004, 0x009c267f, 0x00d00090,
+  0x00a400ec, 0x00e2067d, 0x00c04007, 0x009c171a, 0x00d00090, 0x003bb001,
+  0x00000f3c, 0x00307007, 0x00983689, 0x00fa2000, 0x00d00090, 0x00d00090,
+  0x00d00090, 0x00080f3c, 0x00fa3000, 0x000f083c, 0x00d06910, 0x00a400ec,
+  0x00e2068d, 0x00c04007, 0x009c171a, 0x00d00090, 0x003bb001, 0x00080f3c,
+  0x00b0c90f, 0x00738d10, 0x00333001, 0x00705c3d, 0x009816b8, 0x00303004,
+  0x009826b8, 0x00708610, 0x009c26b8, 0x00d00090, 0x00a400ec, 0x00e2069e,
+  0x00c04007, 0x009c171a, 0x003bb001, 0x00333004, 0x00040f3c, 0x00044040,
+  0x00744201, 0x00748859, 0x001440be, 0x00788c5a, 0x00588001, 0x001880bf,
+  0x00a5090f, 0x00a20d0e, 0x00d55070, 0x00155002, 0x00255101, 0x00a00d13,
+  0x009826b0, 0x00355004, 0x00d00090, 0x00d00090, 0x00b28200, 0x00a80d04,
+  0x00255800, 0x00b24200, 0x00b25200, 0x00b02d0e, 0x00c01003, 0x009c16c4,
+  0x00d00090, 0x00a40d13, 0x009826be, 0x00d06c11, 0x00444001, 0x00b2ac00,
+  0x00b04d13, 0x00e5fffc, 0x00e1ffff, 0x00d06c16, 0x002510fd, 0x00d00090,
+  0x00303504, 0x009826d1, 0x00d00090, 0x00a400ec, 0x00e206cd, 0x00c04007,
+  0x009c171a, 0x003bb001, 0x00333004, 0x00080f3c, 0x00d06c16, 0x00477003,
+  0x00357300, 0x00255101, 0x00fa1000, 0x00a40d09, 0x00745041, 0x004f5003,
+  0x00b04d09, 0x00301303, 0x00981707, 0x00c05004, 0x009c16fc, 0x00fa2000,
+  0x00d00090, 0x00d00090, 0x00d00090, 0x00080f3c, 0x00fa3000, 0x000f083c,
+  0x00d07017, 0x00fa2000, 0x00d00090, 0x00d00090, 0x00d00090, 0x00040f3c,
+  0x00fa3000, 0x000f043c, 0x00155003, 0x00144500, 0x0015503d, 0x00330300,
+  0x009c26f2, 0x00e30000, 0x00357500, 0x00355004, 0x00155003, 0x00144500,
+  0x00350500, 0x00144500, 0x00355020, 0x00188500, 0x00588400, 0x00d07017,
+  0x00455003, 0x00305700, 0x009826e5, 0x00e20704, 0x00a400ec, 0x00c04007,
+  0x009c171a, 0x00d00090, 0x003bb001, 0x00080f3c, 0x00d00090, 0x00500100,
+  0x009c270a, 0x00ea0000, 0x00211001, 0x00111003, 0x00310100, 0x00188100,
+  0x00211020, 0x001aa100, 0x00310100, 0x001aa100, 0x00211020, 0x00188100,
+  0x00e40001, 0x00588a00, 0x00b04d13, 0x00b080eb, 0x00e20646, 0x00d0641f,
+  0x00b0c90f, 0x00b02d0b, 0x00b0b90b, 0x00fa2000, 0x00b01eff, 0x00b03efe,
+  0x00b04efd, 0x00b05efc, 0x00b06efb, 0x00b07efa, 0x00b08ef9, 0x00b0aef8,
+  0x00b0def7, 0x003ee009, 0x00a100e9, 0x00a40d09, 0x00b01d0a, 0x00b0ed0f,
+  0x00050f3c, 0x00754100, 0x00ae0008, 0x00b05d09, 0x00a0090b, 0x009c132b,
+  0x00e40147, 0x00e80001, 0x00b00400, 0x00a10002, 0x0071803f, 0x00b00002,
+  0x00b01003, 0x00d0321b, 0x00a2090e, 0x00ff1000, 0x007f2c61, 0x00ff3000,
+  0x005f0200, 0x00500a00, 0x009c1742, 0x00fa0000, 0x00ec05c0, 0x00ed0008,
+  0x00a4090b, 0x00a6090f, 0x00774cca, 0x0088174c, 0x003dd700, 0x00500f00,
+  0x00377001, 0x009c3749, 0x00402001, 0x009c1751, 0x00d00090, 0x00772c41,
+  0x00244700, 0x00774cc2, 0x00a0090c, 0x008c1758, 0x00774d00, 0x0005073c,
+  0x00277003, 0x0017703e, 0x003dd700, 0x00a10c09, 0x00ab0c00, 0x00311700,
+  0x00a20c01, 0x00b01c09, 0x00a40c02, 0x00a10c03, 0x00aa0909, 0x00a80908,
+  0x00500700, 0x0098378b, 0x00d00090, 0x00d00090, 0x00a30c08, 0x009c176e,
+  0x00e300c0, 0x00ab0c04, 0x00a20c05, 0x00a40c06, 0x00b03c08, 0x00a10c07,
+  0x00333001, 0x00d00090, 0x00b03c08, 0x00530f00, 0x00a0090c, 0x008c177a,
+  0x003505fc, 0x0098277a, 0x00155003, 0x00133500, 0x00350500, 0x00133500,
+  0x00350500, 0x00783210, 0x0078b021, 0x001bb03f, 0x007b203f, 0x0012203f,
+  0x00133030, 0x007a3210, 0x007a4021, 0x0014403f, 0x0074103f, 0x0011103f,
+  0x00b28600, 0x00b2a600, 0x00377001, 0x009c3766, 0x00d00090, 0x00b0bc00,
+  0x00b02c01, 0x00b04c02, 0x00b01c03, 0x003dd001, 0x00982795, 0x00d00090,
+  0x00d00090, 0x00500f00, 0x00d0781f, 0x00fa2000, 0x00a2090e, 0x0042200e,
+  0x00b0090b, 0x0047f080, 0x00522700, 0x00b0690f, 0x00b0290e, 0x00d0471b,
+  0x00d77040, 0x00e90460, 0x007c7484, 0x002cc900, 0x00e90016, 0x00a50c0b,
+  0x00705d00, 0x009c1802, 0x00d00090, 0x00ab0c0c, 0x008c37e1, 0x00a20c01,
+  0x00702c3c, 0x00981802, 0x00eb05c0, 0x00a90c0f, 0x00a30c0d, 0x00a80b09,
+  0x009817e0, 0x00e20016, 0x00a40b00, 0x00a50b01, 0x00a60b02, 0x00a70b03,
+  0x00d09270, 0x009c27e0, 0x00e20008, 0x00308008, 0x009c27bc, 0x0002083c,
+  0x00aa0b08, 0x009c17c4, 0x00ea00c0, 0x00a50b05, 0x00b0ab08, 0x00a40b04,
+  0x00a60b06, 0x00a70b07, 0x003aa001, 0x00d00090, 0x00b0ab08, 0x00aa0c08,
+  0x007a4021, 0x0014403f, 0x0074503f, 0x0015503f, 0x00b2a900, 0x00aa0c09,
+  0x007a6021, 0x0016603f, 0x0076703f, 0x0017703f, 0x00b2a900, 0x00233008,
+  0x00388001, 0x00322001, 0x009c37bc, 0x00d00090, 0x00b04b00, 0x00b05b01,
+  0x00b06b02, 0x00b07b03, 0x00b03c02, 0x00b03c0d, 0x00b08b09, 0x00b09c0f,
+  0x00d08012, 0x00aa0c0f, 0x00a10c01, 0x00711c3b, 0x009817e8, 0x00f40000,
+  0x00992802, 0x00d07e1a, 0x00f00000, 0x00991802, 0x00d0a970, 0x009c2802,
+  0x00d00090, 0x00ed07ef, 0x008c04bf, 0x00981802, 0x00e4073a, 0x007445f0,
+  0x00544750, 0x00a90c03, 0x00b04300, 0x005f2051, 0x0046901f, 0x004f90e0,
+  0x003606e0, 0x00306b00, 0x009837fc, 0x00060b3c, 0x00756100, 0x003bb600,
+  0x00299600, 0x00b0bc0c, 0x00b09c03, 0x00b05c0b, 0x00d0011b, 0x00f50000,
+  0x00500a00, 0x009c1807, 0x00f00000, 0x00ec05c0, 0x00a7090b, 0x00a50c0a,
+  0x007d7ca3, 0x00ab0c00, 0x00a20c01, 0x00a40c02, 0x00a10c03, 0x00a70c08,
+  0x009c381a, 0x00e700c0, 0x00ab0c04, 0x00a20c05, 0x00a40c06, 0x00a10c07,
+  0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03, 0x00377001, 0x00a30908,
+  0x00a60909, 0x00b07c08, 0x0048f500, 0x004af500, 0x00783880, 0x007a6880,
+  0x0078b021, 0x007a4021, 0x001bb03f, 0x0014403f, 0x007b203f, 0x0074103f,
+  0x00a6090f, 0x0011103f, 0x0012203f, 0x00b28600, 0x00b2a600, 0x003dd001,
+  0x00b0690f, 0x008c180f, 0x00b0bc00, 0x00b02c01, 0x00b04c02, 0x00b01c03,
+  0x00b0090b, 0x00d0471b, 0x00f50000, 0x00500a00, 0x009c183a, 0x00f00000,
+  0x00761d27, 0x00000f3c, 0x00366001, 0x009c183b, 0x00d00090, 0x00a40901,
+  0x00724ca0, 0x0030201f, 0x009c1844, 0x00724ca8, 0x00e60001, 0x00a8000b,
+  0x001b6200, 0x00568b00, 0x00e80001, 0x00b0600b, 0x00ab0022, 0x00188300,
+  0x006bb800, 0x00a70902, 0x00b0b022, 0x009c385d, 0x00d00090, 0x00b00902,
+  0x00b01eff, 0x00b02efe, 0x00b0aefd, 0x003ee003, 0x0001033c, 0x0002093c,
+  0x00ed085a, 0x008c04d8, 0x00aa1e01, 0x00a21e01, 0x00a11e01, 0x00010a3c,
+  0x00d0471b, 0x00d77040, 0x00e10460, 0x007b7484, 0x002bb100, 0x00d00090,
+  0x00a40b0b, 0x009c188f, 0x00d00090, 0x00a10b0f, 0x00a80b03, 0x00d91070,
+  0x00a50b01, 0x002009e0, 0x009c288f, 0x00d00090, 0x00ea0004, 0x00a90b0c,
+  0x0088388f, 0x00329020, 0x008c2874, 0x007a9c43, 0x00715c3b, 0x00981879,
+  0x00f40000, 0x0099288f, 0x00d0871b, 0x00f00000, 0x0099188f, 0x00ed087d,
+  0x008c04bf, 0x0098188f, 0x00e40803, 0x007445f0, 0x00544730, 0x00e10000,
+  0x00b04300, 0x00a30b06, 0x005f2031, 0x004f80f8, 0x00211008, 0x00288300,
+  0x003aa001, 0x008c3884, 0x00399100, 0x00741500, 0x00b09b0c, 0x00b08b03,
+  0x00b04b0b, 0x00d0011e, 0x00b0deff, 0x003ee001, 0x00771484, 0x00e50460,
+  0x00277500, 0x0005013c, 0x00ab0701, 0x0071bc3b, 0x0098189c, 0x00f40000,
+  0x009928ce, 0x00d0891f, 0x00f00000, 0x009918ce, 0x00d00090, 0x00a90703,
+  0x00a3070b, 0x00a8070f, 0x00a4070e, 0x00404001, 0x009c18a8, 0x00500300,
+  0x009c18ce, 0x00d00090, 0x00aa070c, 0x009818ce, 0x00738d07, 0x004330fc,
+  0x00303022, 0x009828d8, 0x0040a080, 0x009818d8, 0x0040907f, 0x009c18d8,
+  0x00d48070, 0x00d00090, 0x00303421, 0x009838d2, 0x00ed08b8, 0x008c04bf,
+  0x009818ce, 0x00e409a3, 0x007445f0, 0x00544550, 0x00a10007, 0x00611003,
+  0x0071002e, 0x00b04300, 0x005f1200, 0x005f0900, 0x00a4070e, 0x00740020,
+  0x00a30701, 0x00b0470e, 0x00733c26, 0x00133007, 0x00299300, 0x00e30080,
+  0x003aa300, 0x00b09703, 0x00b0a70c, 0x00b0370b, 0x00ad1e01, 0x00d00090,
+  0x00d00090, 0x00840d00, 0x00ab0701, 0x007bbca0, 0x00e40001, 0x0074403f,
+  0x00144b00, 0x009828ce, 0x00d48070, 0x003043f6, 0x009c28ce, 0x00ed08dd,
+  0x008c04bf, 0x009818ce, 0x00e4096d, 0x007445f0, 0x00544550, 0x005f2051,
+  0x004f90e0, 0x00b04300, 0x0043901f, 0x00a4070e, 0x00740020, 0x00d00090,
+  0x00b0470e, 0x00a40701, 0x00744c26, 0x009818ed, 0x003993e0, 0x003403e0,
+  0x003aa400, 0x009c28f1, 0x000a003c, 0x00a3070b, 0x00743cca, 0x00d00090,
+  0x003304f8, 0x00133002, 0x007340ca, 0x00d08c1b, 0x00741484, 0x00e70460,
+  0x00244700, 0x00e20020, 0x00a70401, 0x00707c3a, 0x009c1902, 0x00f00000,
+  0x00991943, 0x00d09014, 0x00f50000, 0x00992943, 0x00d00090, 0x00a6040f,
+  0x00a50404, 0x0043501f, 0x009c1944, 0x00d76270, 0x00982944, 0x008c8943,
+  0x009c8943, 0x00e20080, 0x00d00090, 0x00af0007, 0x005f0500, 0x00d02000,
+  0x00af2600, 0x00a70402, 0x00b0640f, 0x00255200, 0x00377200, 0x00b05404,
+  0x00b07402, 0x009c3923, 0x00d00090, 0x00b00402, 0x0002043c, 0x00b0deff,
+  0x003ee001, 0x00ed0921, 0x008c04d8, 0x00ad1e01, 0x00d09413, 0x00a3040d,
+  0x00333200, 0x009c1942, 0x00d00090, 0x00a20405, 0x00760210, 0x00302700,
+  0x0088292c, 0x0002073c, 0x00b0640f, 0x00b0240c, 0x00b0240d, 0x00b07402,
+  0x00a2040a, 0x00a70409, 0x00a30407, 0x00a50406, 0x00222300, 0x00277500,
+  0x00b0240a, 0x00b07409, 0x00b02404, 0x00b07403, 0x0003013c, 0x0001073c,
+  0x00b0deff, 0x003ee001, 0x00ed0940, 0x008c0026, 0x00ad1e01, 0x00d09413,
+  0x00b0340d, 0x00840d00, 0x00a2040d, 0x00a0040b, 0x009c1943, 0x00222300,
+  0x00d86070, 0x00981943, 0x00188002, 0x00288300, 0x004880fc, 0x00308020,
+  0x00983950, 0x00e80020, 0x00308200, 0x00982955, 0x00392001, 0x0008023c,
+  0x00d09516, 0x00398001, 0x00ef4252, 0x000f9337, 0x004f50e0, 0x004a30fc,
+  0x003b8a00, 0x00500a00, 0x00981962, 0x005f0000, 0x003aa004, 0x009c395d,
+  0x00d00090, 0x00d00090, 0x00af2600, 0x003bb004, 0x009c3962, 0x003a08e0,
+  0x004aa0fc, 0x0098196b, 0x005f0000, 0x003aa004, 0x009c3968, 0x00328300,
+  0x00d09113, 0x00a2090e, 0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200,
+  0x00500a00, 0x009c1975, 0x00fa0000, 0x00ab090b, 0x004220fe, 0x00a8090f,
+  0x00b0290e, 0x0075bcca, 0x00981980, 0x00d00090, 0x00d00090, 0x00500f00,
+  0x00355001, 0x008c397d, 0x0075bcc2, 0x00981987, 0x00d00090, 0x00d00090,
+  0x00b2f800, 0x00355001, 0x008c3984, 0x00b0090b, 0x0002073c, 0x00010a3c,
+  0x00ed098c, 0x008c04cf, 0x00a5090e, 0x009819a1, 0x00ff2000, 0x0045500f,
+  0x00d00090, 0x00d00090, 0x004bf080, 0x00555b00, 0x00a4090c, 0x00981999,
+  0x00d00090, 0x00b0590e, 0x00d09a11, 0x00755c41, 0x00d00090, 0x003505fc,
+  0x00155003, 0x00350500, 0x001bb500, 0x00d00090, 0x00b2b800, 0x00b0890f,
+  0x00d0321b, 0x00a2090e, 0x00ff1000, 0x007f2c61, 0x00ff3000, 0x005f0200,
+  0x00500a00, 0x009c19ab, 0x00fa0000, 0x004220fe, 0x00a8090f, 0x00b0290e,
+  0x00eb09b4, 0x007c1c64, 0x002ccb00, 0x00ab090b, 0x00a20908, 0x00840c00,
+  0x00d09d15, 0x00d09c1c, 0x00d09c18, 0x00d09c13, 0x00d09b1e, 0x00ec09ba,
+  0x00d00008, 0x00b2f800, 0x003bb020, 0x00d09d1e, 0x00ec09bf, 0x00d00004,
+  0x00b2f800, 0x003bb010, 0x00d09d1e, 0x00ec09c4, 0x00d00002, 0x00b2f800,
+  0x003bb008, 0x00d09d1e, 0x00ec09c9, 0x00b2f800, 0x003bb004, 0x00d09d1e,
+  0x00ec09cd, 0x00122030, 0x0072f210, 0x003bb002, 0x008c19de, 0x00d00090,
+  0x00d00090, 0x00b22800, 0x00d09d1e, 0x00ec09d6, 0x00122038, 0x0072f118,
+  0x003bb001, 0x008c19de, 0x00d00090, 0x00d00090, 0x00b22800, 0x00d09d1e,
+  0x00a50aec, 0x00355700, 0x00801c00, 0x00b02908, 0x00b0b90b, 0x00500b00,
+  0x009c19e9, 0x0002073c, 0x00010a3c, 0x00ed09e9, 0x008c04cf, 0x00a5090e,
+  0x009819fe, 0x00ff2000, 0x00d00090, 0x00d00090, 0x0045500f, 0x004bf080,
+  0x00a4090c, 0x009819f6, 0x00555b00, 0x00d00090, 0x00b0590e, 0x00d09f1e,
+  0x00755c41, 0x00d00090, 0x003505fc, 0x00155003, 0x00350500, 0x001bb500,
+  0x00d00090, 0x00b2b800, 0x00b0890f, 0x00d0321b
+};
+
+#define DMEM_OFFSET             0x8000     /* Contains the control word interface */
+#define IMEM_OFFSET             0xC000     /* Contains config data */
+
+#define TABLE_LENGTH(x) (sizeof(x)/sizeof(*(x)))
+#define IMEM_REGION_LENGTH  0xa00
+
+#define DMEM_REGION_LENGTH  0x600
+
+#define IMEM_FIRMWARE_SZ  TABLE_LENGTH(IMEM_REGION)
+#define DMEM_FIRMWARE_SZ  TABLE_LENGTH(DATA_REGION)
+
+#endif
+
+
diff -Naur linux-2.6.17.8/drivers/stm/copro-stb7100.c linux-2.6.17.8-sh/drivers/stm/copro-stb7100.c
--- linux-2.6.17.8/drivers/stm/copro-stb7100.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/copro-stb7100.c	2006-08-23 13:29:48.788832000 +0100
@@ -0,0 +1,84 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/seq_file.h>
+#include <linux/st-coprocessor.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/coproc.h>
+
+struct coproc_board_info coproc_info = {
+	.name = "st231",
+	.max_coprs = N_COPROC,
+};
+
+coproc_t coproc[N_COPROC];
+
+int coproc_cpu_open(coproc_t * cop)
+{
+	return (0);
+}
+
+int coproc_cpu_init(coproc_t * cop)
+{
+	BUG_ON(cop->id >= N_COPROC);
+
+	/*
+	 * define for the STb7100 the ST231 view of the LMI base address
+	 */
+	return (0);
+}
+
+int coproc_cpu_grant(coproc_t * cop, unsigned long arg)
+{
+	u_long bootAddr;
+	u_long cpu = cop->id;
+
+	BUG_ON(cpu >= N_COPROC);
+
+	if (arg == 0)
+		bootAddr = COPR_ADDR(cop, 0);
+	else
+		bootAddr = arg;
+
+	/* Now set the less meaningful bit to trigger the ST231 start */
+	bootAddr |= 1;
+	DPRINTK(">>> %s: ST231-%ld start from 0x%lx...\n",
+		xstring(PLATFORM), cpu, bootAddr);
+
+	/* stick it into the System configuration and... good luck! */
+	writel((readl(SYSCFG_09) | 0x18000000), SYSCFG_09);
+	writel(bootAddr, SYSCFG_BOOT_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) | 0x1), SYSCFG_RESET_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) & ~0x1), SYSCFG_RESET_REG(cpu));
+
+	cop->control |= COPROC_RUNNING;
+	return (0);
+}
+
+int coproc_cpu_release(coproc_t * cop)
+{
+	/* do nothing! */
+	return (0);
+}
+
+int coproc_cpu_reset(coproc_t * cop)
+{
+	u_long cpu = cop->id;
+
+	/* Enable the ST231 CPUs to be resetted */
+	writel((readl(SYSCFG_09) | 0x08000000), SYSCFG_09);
+
+	writel((readl(SYSCFG_RESET_REG(cpu)) | 0x1), SYSCFG_RESET_REG(cpu));
+	writel((readl(SYSCFG_RESET_REG(cpu)) & ~0x1), SYSCFG_RESET_REG(cpu));
+
+	/* Disable the ST231 CPUs to be resetted */
+	writel((readl(SYSCFG_09) | 0x18000000), SYSCFG_09);
+	return 0;
+}
+
+void coproc_proc_other_info(coproc_t * cop_dump, struct seq_file *s_file)
+{
+	return;			/* Do nothing, doesn't delete it */
+}
diff -Naur linux-2.6.17.8/drivers/stm/copro-stm8000.c linux-2.6.17.8-sh/drivers/stm/copro-stm8000.c
--- linux-2.6.17.8/drivers/stm/copro-stm8000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/copro-stm8000.c	2006-08-23 13:29:48.811830000 +0100
@@ -0,0 +1,131 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/st-coprocessor.h>
+#include <linux/seq_file.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/coproc.h>
+
+#define CPU_2_MBX_BASE(c)     (((c) == 0) ? MBX0_BASE : MBX1_BASE )
+#define CPU_2_GROUP_BASE(c)   (((c) == 1) ? MBX_GROUP1_BASE : MBX_GROUP2_BASE)
+
+#define MBX_REGISTER(cpu)      (CPU_2_MBX_BASE(cpu) + CPU_2_GROUP_BASE(cpu))
+#define MBX_STATUS(cpu,r)      (MBX_REGISTER(cpu) + 0x04 + ((r) * sizeof(int)))
+#define MBX_STATUS_SET(cpu,r)  (MBX_REGISTER(cpu) + 0x24 + ((r) * sizeof(int)))
+#define MBX_STATUS_CLR(cpu,r)  (MBX_REGISTER(cpu) + 0x44 + ((r) * sizeof(int)))
+#define MBX_IRQ_ENABLE(cpu,r)  (MBX_REGISTER(cpu) + 0x64 + ((r) * sizeof(int)))
+#define MBX_IRQ_EN_SET(cpu,r)  (MBX_REGISTER(cpu) + 0x84 + ((r) * sizeof(int)))
+#define MBX_IRQ_EN_CLR(cpu,r)  (MBX_REGISTER(cpu) + 0xa4 + ((r) * sizeof(int)))
+
+#define COP_WAIT_PORT(cpu)	  MBX_STATUS(cpu, 0)
+#define COP_START_PORT(cpu)	  MBX_IRQ_ENABLE(cpu, 0)
+
+struct coproc_board_info coproc_info = {
+	.name = "lx220",
+	.max_coprs = N_COPROC,
+};
+
+coproc_t coproc[N_COPROC];
+
+inline int STm8000_is_processor_waiting_to_boot(coproc_t * cop)
+{
+	unsigned long sig = readl(COP_WAIT_PORT(cop->id));
+	int valid = (sig == BOOT_SIGNATURE);
+
+	DPRINTK(">>> %s: ST220-%d boot signature is %s [0x%lx]\n",
+		xstring(coproc_info.platform), cop->id,
+		(sig == BOOT_SIGNATURE ? "valid" : "invalid"), sig);
+
+	return valid;
+}
+
+int coproc_cpu_open(coproc_t * cop)
+{
+	return (0);
+}
+
+int coproc_cpu_init(coproc_t * cop)
+{
+	BUG_ON(cop->id >= N_COPROC);
+
+	/*
+	 * The following information are not necessary since they are obtained
+	 * via platform dependent macros and do not change.
+	 * At the moment store them into slave control structure for debug...
+	 */
+	cop->mbox_wait = COP_WAIT_PORT(cop->id);
+	cop->mbox_entryp = COP_WAIT_PORT(cop->id);
+	cop->mbox_enable = COP_START_PORT(cop->id);
+
+	return (0);
+}
+
+int coproc_cpu_grant(coproc_t * cop, unsigned long arg)
+{
+	DPRINTK(">>> %s: ST220-%d start from 0x%lx...\n",
+		xstring(coproc_info.platform), cop->id, arg);
+
+	if (!STm8000_is_processor_waiting_to_boot(cop) ||
+	    (cop->control & COPROC_RUNNING))
+		return (-EALREADY);	/* already running! */
+	/*
+	 * arg should contain the entry point (ST200 address based)
+	 * - overwrite the waiting signature
+	 * - trigger the start
+	 */
+	writel(arg, COP_WAIT_PORT(cop->id));
+	writel(arg, COP_START_PORT(cop->id));
+	cop->control |= COPROC_RUNNING;
+
+	return (0);
+}
+
+int coproc_cpu_release(coproc_t * cop)
+{
+	return (0);
+}
+
+int coproc_cpu_reset(coproc_t * cop)
+{
+	printk(">>> Reset for STm8000 is not available\n");
+	return 0;
+}
+
+void coproc_proc_other_info(coproc_t * cop_dump, struct seq_file *s_file)
+{
+	int i;
+
+	seq_printf(s_file, "Mailbox status:\n");
+	seq_printf(s_file, "  CPU (dev)        IRQ    Mailbox registers\n");
+	seq_printf(s_file,
+		   "  -----------------------------------------------------------\n");
+	for (i = 0, cop_dump = &coproc[0]; i < coproc_info.max_coprs;
+	     i++, cop_dump++) {
+		seq_printf(s_file, "  /dev/%-8s    ", cop_dump->dev.bus_id);
+		if (cop_dump->irq)
+			seq_printf(s_file, "%d    ", cop_dump->irq);
+		else
+			seq_printf(s_file, "n.a    ");
+
+		if (cop_dump->ram_size == 0)
+			seq_printf(s_file, "not allocated!\n");
+		else {
+			seq_printf(s_file, "signature: *(0x%08lx)=0x%08x\n",
+				   cop_dump->mbox_wait,
+				   (unsigned int)readl(cop_dump->mbox_wait));
+			seq_printf(s_file,
+				   "\t\t          entryp   : *(0x%08lx)=0x%08x\n",
+				   cop_dump->mbox_entryp,
+				   (unsigned int)readl(cop_dump->mbox_entryp));
+			seq_printf(s_file,
+				   "\t\t          enable   : *(0x%08lx)=0x%08x\n",
+				   cop_dump->mbox_enable,
+				   (unsigned int)readl(cop_dump->mbox_enable));
+			seq_printf(s_file, "\n");
+		}
+	}
+	seq_printf(s_file, "\n");
+	return;
+}
diff -Naur linux-2.6.17.8/drivers/stm/gpdma.c linux-2.6.17.8-sh/drivers/stm/gpdma.c
--- linux-2.6.17.8/drivers/stm/gpdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/gpdma.c	2006-08-23 13:29:39.360622000 +0100
@@ -0,0 +1,985 @@
+/*
+ *   STMicroelectronics GPDMA Driver
+ *   Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <asm/io.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+
+#include <linux/delay.h>
+
+#include <asm/dma.h>
+#include <linux/stm/7100_fdma2.h>
+
+static int enable_trace = 0;
+#define GPDMA_TRACE(fmt, args...) \
+		(enable_trace && printk("%s: " fmt, __FUNCTION__, ##args))
+
+/* TODO: really ought to be in the headers */
+const int DIM_MASK = DIM_0_x_0 | DIM_0_x_1 | DIM_0_x_2 |
+		     DIM_1_x_0 | DIM_1_x_1 | DIM_1_x_2 |
+		     DIM_2_x_0 | DIM_2_x_1 | DIM_2_x_2 |
+		     DIM_0_x_SG  | DIM_SG_x_0 | DIM_SG_x_SG;
+
+#define __GPDMA(ctx, n)			((ctx)->io_base + (n))
+#define __GPDMA_CHAN(ctx, n, o)		__GPDMA(ctx, (((n + 1) * 0x100) + o))
+
+#define DMA_GLOBAL_VCR_STATUS(ctx)	__GPDMA(ctx, 0x00)
+#define DMA_GLOBAL_VCR_VERSION(ctx)	__GPDMA(ctx, 0x08)
+#define DMA_GLOBAL_ENABLE(ctx)		__GPDMA(ctx, 0x10)
+#define DMA_GLOBAL_DISABLE(ctx)		__GPDMA(ctx, 0x18)
+#define DMA_GLOBAL_STATUS(ctx)		__GPDMA(ctx, 0x20)
+#define DMA_GLOBAL_INTERRUPT(ctx)	__GPDMA(ctx, 0x28)
+#define DMA_GLOBAL_ERROR(ctx)		__GPDMA(ctx, 0x30)
+#define DMA_GLOBAL_DEFINED(ctx)		__GPDMA(ctx, 0x38)
+#define DMA_GLOBAL_HANDSHAKE(ctx)	__GPDMA(ctx, 0x40)
+
+#define DMA_CHAN_IDENITY(ctx, n)	__GPDMA_CHAN(ctx, n, 0x00)
+#define DMA_CHAN_ENABLE(ctx, n)		__GPDMA_CHAN(ctx, n, 0x08)
+#define DMA_CHAN_DISABLE(ctx, n)	__GPDMA_CHAN(ctx, n, 0x10)
+#define DMA_CHAN_STATUS(ctx, n)		__GPDMA_CHAN(ctx, n, 0x18)
+#define DMA_CHAN_ACTION(ctx, n)		__GPDMA_CHAN(ctx, n, 0x20)
+#define DMA_CHAN_POINTER(ctx, n)	__GPDMA_CHAN(ctx, n, 0x28)
+#define DMA_CHAN_REQUEST(ctx, n)	__GPDMA_CHAN(ctx, n, 0x30)
+
+#define DMA_CHAN_CONTROL(ctx, n)	__GPDMA_CHAN(ctx, n, 0x80)
+#define DMA_CHAN_COUNT(ctx, n)		__GPDMA_CHAN(ctx, n, 0x88)
+#define DMA_CHAN_SAR(ctx, n)		__GPDMA_CHAN(ctx, n, 0x90)
+#define DMA_CHAN_DAR(ctx, n)		__GPDMA_CHAN(ctx, n, 0x98)
+#define DMA_CHAN_NEXT_PTR(ctx, n)	__GPDMA_CHAN(ctx, n, 0xa0)
+#define DMA_CHAN_SRC_LENGTH(ctx, n)	__GPDMA_CHAN(ctx, n, 0xa8)
+#define DMA_CHAN_SRC_STRIDE(ctx, n)	__GPDMA_CHAN(ctx, n, 0xb0)
+#define DMA_CHAN_DST_LENGTH(ctx, n)	__GPDMA_CHAN(ctx, n, 0xb8)
+#define DMA_CHAN_DST_STRIDE(ctx, n)	__GPDMA_CHAN(ctx, n, 0xc0)
+
+/* DMAC bitmasks */
+#define DMA_GLOBAL_ENABLE_CHAN_(n)              (0x00000001UL << n)
+#define DMA_GLOBAL_DISABLE_CHAN_(n)             (0x00000001UL << n)
+#define DMA_CHAN_ENABLE_CHAN_                   0x00000001UL
+#define DMA_CHAN_ENABLE_COMPLETE_		0x00000002UL
+#define DMA_CHAN_ENABLE_BUS_ERROR_		0x00000004UL
+#define DMA_CHAN_ENABLE_ALIGNMENT_		0x00000008UL
+#define DMA_CHAN_ENABLE_ALL_			0x0000003FUL
+#define DMA_CHAN_CONTROL_FREE_RUNNING_          0x00000000UL
+#define DMA_CHAN_CONTROL_TRIGGER_               0x00000001UL
+#define DMA_CHAN_CONTROL_PACED_SOURCE_          0x00000002UL
+#define DMA_CHAN_CONTROL_PACED_DESTINATION_     0x00000003UL
+#define DMA_CHAN_CONTROL_NO_LINK_LIST_          0x00000000UL
+#define DMA_CHAN_CONTROL_FINAL_LINK_ELEM_       0x00000000UL
+#define DMA_CHAN_CONTROL_LINK_ELEM_             0x00000080UL
+#define DMA_CHAN_CONTROL_SRC_TYPE_CONST_        0x00000000UL
+#define DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_   0x00010000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_2BYTES_       0x00080000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_4BYTES_       0x00100000UL
+#define DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_      0x00280000UL
+#define DMA_CHAN_CONTROL_DST_TYPE_CONST_        0x00000000UL
+#define DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_   0x01000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_2BYTES_       0x08000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_4BYTES_       0x10000000UL
+#define DMA_CHAN_CONTROL_DST_UNIT_32BYTES_      0x28000000UL
+#define DMA_CHAN_ACTION_UPDATE_			0x00000040UL
+#define DMA_CHAN_ACTION_STALL_ACK_              0x00000010UL
+#define DMA_CHAN_ACTION_ALIGNMENT_ACK_          0x00000008UL
+#define DMA_CHAN_ACTION_BUS_ERROR_ACK_          0x00000004UL
+#define DMA_CHAN_ACTION_COMPLETE_ACK_           0x00000002UL
+#define DMA_CHAN_STATUS_COMPLETE_               0x00000002UL
+#define DMA_CHAN_REQUEST0                       0x0
+#define DMA_CHAN_REQUEST1                       0x1
+#define DMA_CHAN_REQUEST2                       0x2
+#define DMA_CHAN_REQUEST3                       0x3
+
+#define DMA_LINKAGE_CONTROL(s)			((*(s))[0])
+#define DMA_LINKAGE_COUNT(s)			((*(s))[1])
+#define DMA_LINKAGE_SAR(s)			((*(s))[2])
+#define DMA_LINKAGE_DAR(s)			((*(s))[3])
+#define DMA_LINKAGE_NEXT_PTR(s)			((*(s))[4])
+#define DMA_LINKAGE_SRC_LENGTH(s)		((*(s))[5])
+#define DMA_LINKAGE_SRC_STRIDE(s)		((*(s))[6])
+#define DMA_LINKAGE_DST_LENGTH(s)		((*(s))[7])
+#define DMA_LINKAGE_DST_STRIDE(s)		((*(s))[8])
+#define DMA_LINKAGE_LENGTH			10 /* must be 64-bit aligned */
+
+#define DMA_LINKAGE_TABLE_SIZE			96
+
+#define DMA_LINKAGE_TABLE_SIZE_BYTES \
+			(DMA_LINKAGE_TABLE_SIZE*DMA_LINKAGE_LENGTH*4)
+
+typedef u32 gpdma_linkage_t[DMA_LINKAGE_LENGTH];
+
+/* TODO: this probably ought to be increated to 36 (since we probably want
+ *       to configure each of the paced sub-channels independantly)
+ */
+#define GPDMA_FIRST_FREERUNNING_CHANNEL 1
+#define GPDMA_DMA_CHANNELS 5
+
+typedef struct channel_status {
+	char    locked;
+	pf 	comp_callback;
+	pf	err_callback;
+	char    ch_term;
+	char    ch_pause;
+	char    is_xferring;
+
+	gpdma_linkage_t *dma_table;
+
+	struct tasklet_struct completion_tasklet;
+	struct tasklet_struct error_tasklet;
+} channel_status;
+
+typedef struct gpdma_chip {
+	channel_status channel[GPDMA_DMA_CHANNELS];
+	spinlock_t gpdma_lock;
+	spinlock_t channel_lock;
+	unsigned long io_base;
+	int	irq_chan[5];
+	int	irq_err;
+} gpdma_chip;
+
+/* TODO: why is this a global variable (forces single instance of driver) */
+static gpdma_chip chip;
+
+static int claim_gpdma_channel(int chan_id)
+{
+	int res = -ENODEV;
+
+	if (0 == chan_id)
+		return -ENODEV;
+
+	spin_lock(&chip.channel_lock);
+
+	if(!chip.channel[chan_id].locked) {
+		chip.channel[chan_id].dma_table =
+			kmalloc(DMA_LINKAGE_TABLE_SIZE_BYTES, GFP_KERNEL);
+
+		if (chip.channel[chan_id].dma_table) {
+			writel(DMA_GLOBAL_ENABLE_CHAN_(chan_id),
+			       DMA_GLOBAL_ENABLE(&chip));
+			chip.channel[chan_id].locked = 1;
+			res = chan_id;
+		}
+	}
+
+	spin_unlock(&chip.channel_lock);
+	return res;
+}
+
+static void free_gpdma_channel(int chan_id)
+{
+	spin_lock(&chip.channel_lock);
+	kfree(chip.channel[chan_id].dma_table);
+	writel(DMA_GLOBAL_ENABLE_CHAN_(chan_id), DMA_GLOBAL_DISABLE(&chip));
+	memset(&chip.channel[chan_id], 0, sizeof(channel_status));
+	spin_unlock(&chip.channel_lock);
+
+}
+
+static inline void gpdma_decode_control(unsigned long control)
+{
+	const char *timing, *list_enb;
+	unsigned int sub_offset;
+	const char *src_type, *src_unit, *src_update;
+	const char *dst_type, *dst_unit, *dst_update;
+
+	switch((control >>  0) & 0x03) {
+	case 0: timing = "free running"; break;
+	case 1: timing = "triggered"; break;
+	case 2: timing = "paced src"; break;
+	case 3: timing = "paced dst"; break;
+	default: timing = "ILLEGAL"; break;
+	}
+
+	switch((control >>  7) & 0x01) {
+	case 0:	list_enb = "single/final elem"; break;
+	case 1: list_enb = "linked list"; break;
+	default: list_enb = "ILLEGAL"; break;
+	}
+
+	sub_offset = (control >>  8) & 0xff;
+
+	switch((control >> 16) & 0x07) {
+	case 0: src_type = "constant src"; break;
+	case 1: src_type = "linear inc. src"; break;
+	case 2: src_type = "linear dec. src"; break;
+	case 3: src_type = "2D inc. src"; break;
+	case 4: src_type = "2D dec. src"; break;
+	default: src_type = "ILLEGAL"; break;
+	}
+
+	switch((control >> 19) & 0x07) {
+	case 0: src_unit = "1 byte read"; break;
+	case 1: src_unit = "2 byte read"; break;
+	case 2: src_unit = "4 byte read"; break;
+	case 3: src_unit = "8 byte read"; break;
+	case 4: src_unit = "16 byte read"; break;
+	case 5: src_unit = "32 byte read"; break;
+	default: src_unit = "ILLEGAL"; break;
+	}
+
+	switch((control >> 22) & 0x01) {
+	case 0: src_update = "update src"; break;
+	case 1: src_update = "no update src"; break;
+	default: src_update = "ILLEGAL"; break;
+	}
+
+	switch((control >> 24) & 0x07) {
+	case 0: dst_type = "constant dst"; break;
+	case 1: dst_type = "linear inc. dst"; break;
+	case 2: dst_type = "linear dec. dst"; break;
+	case 3: dst_type = "2D inc. dst"; break;
+	case 4: dst_type = "2D dec. dst"; break;
+	default: dst_type = "ILLEGAL"; break;
+	}
+
+	switch((control >> 27) & 0x07) {
+	case 0: dst_unit = "1 byte write"; break;
+	case 1: dst_unit = "2 byte write"; break;
+	case 2: dst_unit = "4 byte write"; break;
+	case 3: dst_unit = "8 byte write"; break;
+	case 4: dst_unit = "16 byte write"; break;
+	case 5: dst_unit = "32 byte write"; break;
+	default: dst_unit = "ILLEGAL"; break;
+	}
+
+	switch((control >> 30) & 0x01) {
+	case 0: dst_update = "update dst"; break;
+	case 1: dst_update = "no update dst"; break;
+	default: dst_update = "ILLEGAL"; break;
+	}
+
+	GPDMA_TRACE("%s, %s, offset %d, %s, %s, %s, %s, %s, %s\n",
+		    timing, list_enb, sub_offset,
+		    src_type, src_unit, src_update,
+		    dst_type, dst_unit, dst_update);
+
+}
+
+static inline void gpdma_wback_linkage(struct dma_channel *chan,
+                                       gpdma_linkage_t *link)
+{
+	GPDMA_TRACE("dmac%d: writing back linkage table (%p, count = %d)\n",
+		    chan->chan, link, DMA_LINKAGE_COUNT(link));
+
+#if 0
+	GPDMA_TRACE("   control = %08x\n", DMA_LINKAGE_CONTROL(link));
+	gpdma_decode_control(DMA_LINKAGE_CONTROL(link));
+	GPDMA_TRACE("     count = %d\n", DMA_LINKAGE_COUNT(link));
+	GPDMA_TRACE("       sar = %p\n", (void *) DMA_LINKAGE_SAR(link));
+	GPDMA_TRACE("       dar = %p\n", (void *) DMA_LINKAGE_DAR(link));
+	GPDMA_TRACE("  next ptr = %p\n", (void *) DMA_LINKAGE_NEXT_PTR(link));
+	GPDMA_TRACE("src_length = %d\n", DMA_LINKAGE_SRC_LENGTH(link));
+	GPDMA_TRACE("src_stride = %d\n", DMA_LINKAGE_SRC_STRIDE(link));
+	GPDMA_TRACE("dst_length = %d\n", DMA_LINKAGE_DST_LENGTH(link));
+	GPDMA_TRACE("dst_stride = %d\n", DMA_LINKAGE_DST_STRIDE(link));
+#endif
+
+	dma_cache_wback(link, sizeof(gpdma_linkage_t));
+}
+
+static gpdma_linkage_t * gpdma_extend_linkage(struct dma_channel *chan,
+                                              gpdma_linkage_t *link)
+{
+	gpdma_linkage_t *dma_table;
+
+	GPDMA_TRACE("dmac%d: extending linkage table (%p)\n", chan->chan, link);
+	dma_table = chip.channel[chan->chan].dma_table;
+
+	BUG_ON(link < dma_table);
+	BUG_ON(link > (dma_table + DMA_LINKAGE_TABLE_SIZE));
+
+	/* check that the link is in range */
+	if (link + 2 >  (dma_table + DMA_LINKAGE_TABLE_SIZE)) {
+		return NULL;
+	}
+
+	/* set the next link to be identical to pre-decessor */
+	memcpy(link+1, link+0, sizeof(gpdma_linkage_t));
+
+	DMA_LINKAGE_CONTROL(link) |= DMA_CHAN_CONTROL_LINK_ELEM_;
+	DMA_LINKAGE_NEXT_PTR(link) = (unsigned long) virt_to_bus(link+1);
+
+	gpdma_wback_linkage(chan, link);
+	return link+1;
+}
+
+static void gpdma_final_linkage(struct dma_channel *chan, gpdma_linkage_t *link)
+{
+	GPDMA_TRACE("dmac%d: completed linkage table (%p)\n", chan->chan, link);
+	gpdma_wback_linkage(chan, link);
+}
+
+static inline long long gpdma_get_unit_from_size(unsigned long sz,
+                                                 unsigned int write)
+{
+	if (write) {
+		switch (sz) {
+		case  2:
+			return DMA_CHAN_CONTROL_DST_UNIT_2BYTES_;
+		case  4:
+			return DMA_CHAN_CONTROL_DST_UNIT_4BYTES_;
+		case 32:
+			return DMA_CHAN_CONTROL_DST_UNIT_32BYTES_;
+		}
+	} else {
+		switch (sz) {
+		case  2:
+			return DMA_CHAN_CONTROL_SRC_UNIT_2BYTES_;
+		case  4:
+			return DMA_CHAN_CONTROL_SRC_UNIT_4BYTES_;
+		case 32:
+			return DMA_CHAN_CONTROL_SRC_UNIT_32BYTES_;
+		}
+	}
+
+	return -1;
+}
+
+static inline long long gpdma_get_unit_from_alignment(
+		unsigned long addr, unsigned int count, unsigned int write)
+{
+	unsigned int sz = 0;
+
+	/* TODO: support other alignments */
+	if (0 == ((addr | count) & 0x1f))
+		sz = 32;
+	else if (0 == ((addr | count) & 0x03))
+		sz = 4;
+	else if (0 == ((addr | count) & 0x01))
+		sz = 2;
+
+	return gpdma_get_unit_from_size(sz, write);
+}
+
+static gpdma_linkage_t *gpdma_map_sg(struct dma_channel *chan,
+                                     gpdma_linkage_t *link, unsigned int write)
+{
+	int chan_id = chan->chan;
+	struct scatterlist *sg;
+	unsigned int nents;
+	int i;
+
+	GPDMA_TRACE("dmac%d: mapping scatterlist to GPDMA linkage "
+	            "structure(s)\n", chan_id);
+
+	if (write) {
+		sg = chan->src_sg;
+		nents = chan->src_sg_len;
+	} else {
+		sg = chan->dst_sg;
+		nents = chan->dst_sg_len;
+	}
+
+	i = 0;
+	do {
+		/* although counter-intuitive we really do want to invert write
+		 * here because gpdma_get_unit_from_alignment's write flag is
+		 * from the point of view of the DMA engine, not of the IDE
+		 * transaction.
+		 */
+		DMA_LINKAGE_CONTROL(link) |= gpdma_get_unit_from_alignment(
+			sg_dma_address(sg+i), sg_dma_len(sg+i), !write);
+		DMA_LINKAGE_COUNT(link) = sg_dma_len(sg+i);
+		if (write)
+			DMA_LINKAGE_SAR(link) = sg_dma_address(sg+i);
+		else {
+			DMA_LINKAGE_DAR(link) = sg_dma_address(sg+i);
+		}
+
+		if (++i >= nents) {
+			break;
+		}
+
+		link = gpdma_extend_linkage(chan, link);
+	} while (link);
+
+	return link;
+}
+
+static int gpdma_map_channel(struct dma_channel *chan, gpdma_linkage_t *link)
+{
+	int chan_id = chan->chan;
+	long long control;
+
+	GPDMA_TRACE("dmac%d: mapping dma_channel to GPDMA linkage structure\n",
+	            chan_id);
+
+	switch (chan->flags & DIM_MASK) {
+	case DIM_0_x_0:
+		control = DMA_CHAN_CONTROL_SRC_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->src_sz, READ) |
+			  DMA_CHAN_CONTROL_DST_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->dst_sz, WRITE);
+		break;
+	case DIM_0_x_1:
+		control = DMA_CHAN_CONTROL_SRC_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->src_sz, READ) |
+			  DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_ |
+			  gpdma_get_unit_from_alignment(chan->dar, chan->count,
+			                                WRITE);
+		break;
+	case DIM_0_x_SG:
+		control = DMA_CHAN_CONTROL_SRC_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->src_sz, READ) |
+			  DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_;
+		break;
+	case DIM_1_x_0:
+		control = DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_ |
+			  gpdma_get_unit_from_alignment(chan->sar, chan->count,
+			                                READ) |
+			  DMA_CHAN_CONTROL_DST_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->dst_sz, WRITE);
+		break;
+	case DIM_SG_x_0:
+		control = DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_ |
+			  DMA_CHAN_CONTROL_DST_TYPE_CONST_ |
+			  gpdma_get_unit_from_size(chan->dst_sz, WRITE);
+		break;
+	case DIM_1_x_1:
+		control = DMA_CHAN_CONTROL_SRC_ADDRESSMODE_INC_ |
+			  gpdma_get_unit_from_alignment(chan->sar, chan->count,
+			                                READ) |
+			  DMA_CHAN_CONTROL_DST_ADDRESSMODE_INC_ |
+			  gpdma_get_unit_from_alignment(chan->dar, chan->count,
+			                                WRITE);
+		break;
+	case DIM_SG_x_SG:
+	case DIM_0_x_2:
+	case DIM_2_x_0:
+	case DIM_1_x_2:
+	case DIM_2_x_1:
+	case DIM_2_x_2:
+	default:
+		control = -1;
+	}
+
+	if (control < 0) {
+		return -EINVAL;
+	}
+
+	DMA_LINKAGE_CONTROL(link) = (unsigned int) control;
+	DMA_LINKAGE_COUNT(link) = chan->count;
+	DMA_LINKAGE_SAR(link) = chan->sar;
+	DMA_LINKAGE_DAR(link) = chan->dar;
+	DMA_LINKAGE_NEXT_PTR(link) = 0;
+	DMA_LINKAGE_SRC_LENGTH(link) = chan->src_sz;
+	DMA_LINKAGE_SRC_STRIDE(link) = chan->sstride;
+	DMA_LINKAGE_DST_LENGTH(link) = chan->dst_sz;
+	DMA_LINKAGE_DST_STRIDE(link) = chan->dstride;
+
+	return 0;
+}
+
+static int gpdma_configure_freerunning(struct dma_channel *chan,
+                                       unsigned long flags)
+{
+	int chan_id = chan->chan, res;
+	gpdma_linkage_t *link, *newlink;
+	unsigned int list_len;
+
+	GPDMA_TRACE("dmac%d: configuring freerunning GPDMA transfer\n",
+	            chan_id);
+
+	link = chip.channel[chan_id].dma_table;
+
+	if (LIST_TYPE_LINKED & flags)
+		list_len = chan->list_len;
+	else
+		list_len = 1;
+
+	while (1) {
+		/* configure the first node in the list */
+		res = gpdma_map_channel(chan, link);
+		if (res != 0) {
+			return res;
+		}
+
+		/* cope with any scatterlist transfers */
+		switch (flags & DIM_MASK) {
+		case DIM_SG_x_0:
+			newlink = gpdma_map_sg(chan, link, WRITE);
+			break;
+		case DIM_0_x_SG:
+			newlink = gpdma_map_sg(chan, link, READ);
+			break;
+		default:
+			newlink = link;
+		}
+
+		if (!newlink) {
+			printk(KERN_ERR "cannot configure scatterlist for "
+			                "GPDMAC channel %d\n", chan_id);
+			return -ENOMEM;
+		}
+
+		list_len--;
+		if (0 == list_len)
+			break;
+
+		link = gpdma_extend_linkage(chan, newlink);
+		if (!link) {
+			printk(KERN_ERR "cannot configure linked list for "
+			                "GPDMAC channel %d\n", chan_id);
+			return -ENOMEM;
+		}
+	}
+
+	gpdma_final_linkage(chan, newlink);
+	return 0;
+}
+
+static void inline gpdma_handle_channel_completion(int chan_id)
+{
+	GPDMA_TRACE("dmac%d: received GPDMA completion interrupt\n", chan_id);
+
+	/* TODO: do we need to check for error on this channel? */
+	writel(DMA_CHAN_ENABLE_COMPLETE_, DMA_CHAN_DISABLE(&chip, chan_id));
+	tasklet_schedule(&chip.channel[chan_id].completion_tasklet);
+}
+
+static irqreturn_t gpdma_completion_interrupt_handler
+		(int irq, void *p, struct pt_regs *regs)
+{
+	unsigned long i, mask;
+
+	/* this code assumed that DMA_CHAN_ENABLE_ERROR_ is never set */
+	while (0 != (mask = readl(DMA_GLOBAL_INTERRUPT(&chip)))) {
+		for (i=0; i<GPDMA_DMA_CHANNELS; i++) {
+			if (mask & (1 << i)) {
+				gpdma_handle_channel_completion(i);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void gpdma_completion_tasklet(int chan_id)
+{
+	void (*comp_callback)(void) = (chip.channel[chan_id]).comp_callback;
+
+	GPDMA_TRACE("dmac%d: GPDMA transfer completed OK\n", chan_id);
+
+	if (comp_callback)
+		comp_callback();
+
+	/* TODO: mark not tranfering? */
+}
+
+static void inline gpdma_handle_channel_error(int chan_id)
+{
+	GPDMA_TRACE("dmac%d: received GPDMA error interrupt\n", chan_id);
+
+	writel(DMA_CHAN_ENABLE_BUS_ERROR_ | DMA_CHAN_ENABLE_ALIGNMENT_,
+	       DMA_CHAN_DISABLE(&chip, chan_id));
+	tasklet_schedule(&chip.channel[chan_id].error_tasklet);
+}
+
+static irqreturn_t gpdma_error_interrupt_handler
+		(int irq, void *p, struct pt_regs *regs)
+{
+	unsigned long i, mask;
+
+	GPDMA_TRACE("received GPDMA error interrupt\n");
+
+	while (0 != (mask = readl(DMA_GLOBAL_ERROR(&chip)))) {
+		for (i=0; i<GPDMA_DMA_CHANNELS; i++) {
+			if (mask & (1 << i)) {
+				gpdma_handle_channel_error(i);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void gpdma_error_tasklet(int chan_id)
+{
+	void (*err_callback)(void) = (chip.channel[chan_id]).err_callback;
+
+	printk(KERN_ERR "dmac%d: GPDMA transfer terminated with error\n",
+	       chan_id);
+	if(err_callback)
+		err_callback();
+
+}
+
+
+/*
+ * Linux SH-DMA-API hooks
+ * */
+
+extern int gpdma_get_residue(struct dma_channel *chan)
+{
+	unsigned long pos = 0;
+	unsigned int chan_id = chan->chan;
+
+	spin_lock(&chip.channel_lock);
+	pos = readl(DMA_CHAN_COUNT(&chip, chan_id));
+	if (1 & readl(DMA_CHAN_STATUS(&chip, chan_id))) {
+		pos += 100000;
+	}
+	spin_unlock(&chip.channel_lock);
+
+	GPDMA_TRACE("dmac%d: %ld bytes left to transfer (status = %lx)\n",
+		    chan_id, pos, readl(DMA_CHAN_STATUS(&chip, chan_id)));
+
+	return pos;
+}
+
+static int gpdma_request(struct dma_channel *chan)
+{
+	int i, res;
+
+	GPDMA_TRACE("dmac: allocating GPDMA resources\n");
+
+	spin_lock(&chip.channel_lock);
+
+	if (chan->chan == ANY_CHANNEL) {
+		for (i=GPDMA_FIRST_FREERUNNING_CHANNEL;
+						i<GPDMA_DMA_CHANNELS; i++) {
+			res = claim_gpdma_channel(i);
+			if (res >= 0) {
+				break;
+			}
+		}
+
+		return res;
+	}
+
+	return claim_gpdma_channel(chan->chan);
+}
+
+static int gpdma_stop(struct dma_channel *chan)
+{
+	unsigned int chan_id = chan->chan;
+
+	GPDMA_TRACE("dmac%d: halting GPDMA transfer\n", chan_id);
+	GPDMA_TRACE("status = %08lx\n", readl(DMA_CHAN_STATUS(&chip, chan_id)));
+	GPDMA_TRACE("enable = %08lx\n", readl(DMA_CHAN_ENABLE(&chip, chan_id)));
+
+	spin_lock(chip.channel_lock);
+	chip.channel[chan->chan].ch_term = 1;
+	spin_unlock(chip.channel_lock);
+
+	spin_lock(chip.gpdma_lock);
+	writel(DMA_CHAN_ENABLE_CHAN_, DMA_CHAN_DISABLE(&chip, chan_id));
+	spin_unlock(chip.gpdma_lock);
+
+	return 1;
+}
+
+
+static void gpdma_free(struct dma_channel *chan)
+{
+	unsigned int chan_id = chan->chan;
+
+	GPDMA_TRACE("dmac%d: freeing GPDMA resources\n", chan_id);
+
+	gpdma_stop(chan);
+	/* TODO: wait for GPDMA to acknowledge stop */
+
+	/* TODO: this will clobber the tasklet structure */
+	free_gpdma_channel(chan->chan);
+
+#if 0
+	/* do our best to ensure no-one is orphaned by the free */
+	chip.channel[chan->chan].completion_tasklet.data = chan_id;
+	tasklet_schedule(&chip.channel[chan->chan].completion_tasklet);
+#endif
+}
+
+static int gpdma_configure(struct dma_channel *channel, unsigned long flags)
+{
+	struct dma_channel *chan = channel;
+	int chan_id = chan->chan;
+	int res;
+
+	GPDMA_TRACE("dmac%d: configuring GPDMA transfer\n", chan_id);
+
+	if (chan->mode != MODE_FREERUNNING) {
+		BUG();
+		return -ENODEV;
+	}
+
+	spin_lock(&chip.channel_lock);
+
+	if (readl(DMA_GLOBAL_STATUS(&chip)) & (1 << chan_id)) {
+		spin_unlock(&chip.channel_lock);
+		return -EBUSY;
+	}
+
+	if(chan->comp_callback)
+		chip.channel[chan_id].comp_callback = (pf)chan->comp_callback;
+	if(chan->err_callback)
+		chip.channel[chan_id].err_callback = (pf)chan->err_callback;
+
+	spin_unlock(&chip.channel_lock);
+
+	res = gpdma_configure_freerunning(channel, flags);
+	if (0 == res)
+		chan->flags |= DMA_CONFIGURED;
+
+	return res;
+}
+
+static int gpdma_xfer(struct dma_channel *chan)
+{
+	unsigned int chan_id = chan->chan;
+	unsigned long flags = chan->flags;
+	unsigned long status;
+	gpdma_linkage_t *link = chip.channel[chan_id].dma_table;
+
+	GPDMA_TRACE("dmac%d: starting GPDMA transfer\n", chan_id);
+
+	if (0 == (flags & DMA_CONFIGURED)) {
+		BUG();
+		return -EINVAL;
+	}
+
+	/* clear all existing error flags */
+	writel(DMA_CHAN_ACTION_COMPLETE_ACK_ | DMA_CHAN_ACTION_BUS_ERROR_ACK_ |
+	       DMA_CHAN_ACTION_ALIGNMENT_ACK_ | DMA_CHAN_ACTION_STALL_ACK_,
+	       DMA_CHAN_ACTION(&chip, chan_id));
+
+	/* check that the channel really is idle */
+	if (0 != (status = readl(DMA_CHAN_STATUS(&chip, chan_id)))) {
+		printk(KERN_ERR "dmac%d: cannot start new transfer - "
+		                 "non-zero status (%lx)", chan_id, status);
+		return -EBUSY;
+	}
+
+	/* set it running */
+	writel(DMA_CHAN_ENABLE_CHAN_, DMA_CHAN_DISABLE(&chip, chan_id));
+	writel(virt_to_bus(link), DMA_CHAN_NEXT_PTR(&chip, chan_id));
+	writel(DMA_CHAN_ACTION_UPDATE_, DMA_CHAN_ACTION(&chip, chan_id));
+	writel(DMA_CHAN_ENABLE_CHAN_ | DMA_CHAN_ENABLE_COMPLETE_ |
+	       DMA_CHAN_ENABLE_BUS_ERROR_ | DMA_CHAN_ENABLE_ALIGNMENT_,
+	       DMA_CHAN_ENABLE(&chip, chan_id));
+
+	return 0;
+}
+
+
+int gpdma_pause(int flush, struct dma_channel * chan)
+{
+	unsigned int chan_id = chan->chan;
+	GPDMA_TRACE("dmac%d: pausing GPDMA transfer\n", chan_id);
+	writel(DMA_CHAN_ENABLE_CHAN_, DMA_CHAN_DISABLE(&chip, chan_id));
+	return 1;
+}
+
+void gpdma_unpause(struct dma_channel * chan)
+{
+	unsigned int chan_id = chan->chan;
+	GPDMA_TRACE("dmac%d: continuing GPDMA transfer\n", chan_id);
+	writel(DMA_CHAN_ENABLE_CHAN_, DMA_CHAN_ENABLE(&chip, chan_id));
+}
+
+static struct dma_ops gpdma_ops = {
+	.request		= gpdma_request,
+	.free			= gpdma_free,
+	.get_residue		= gpdma_get_residue,
+	.xfer			= gpdma_xfer,
+	.configure		= gpdma_configure,
+	.pause			= gpdma_pause,
+	.unpause		= gpdma_unpause,
+	.stop			= gpdma_stop,
+};
+
+static struct dma_info gpdma_info = {
+	.name			= "STM GPDMAC",
+	.nr_channels		= GPDMA_DMA_CHANNELS,
+	.ops			= &gpdma_ops,
+	.flags			= DMAC_CHANNELS_TEI_CAPABLE,
+};
+
+static int gpdma_drv_probe(struct device *dev)
+{
+	gpdma_chip *ctx = &chip;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	int err, i;
+
+	GPDMA_TRACE("initialising STM GPDMAC driver\n");
+
+	memset(ctx, 0, sizeof(gpdma_chip));
+
+	spin_lock_init(&ctx->channel_lock);
+	spin_lock_init(&ctx->gpdma_lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+#if 0
+	/* TODO: this appears to already be in use ... */
+	if (!request_mem_region(res->start, res->end+1, "gpdma"))
+		return -EBUSY;
+#endif
+
+	ctx->io_base = (unsigned long) ioremap(res->start, res->end+1);
+	if (!ctx->io_base) {
+		err = -ENOMEM;
+		goto release_region;
+	}
+
+	ctx->irq_err = platform_get_irq(pdev, GPDMA_DMA_CHANNELS);
+	if (ctx->irq_err) {
+		if (request_irq(ctx->irq_err,
+				gpdma_error_interrupt_handler,
+				SA_INTERRUPT, "STM GPDMAC (error)", ctx)) {
+			err = -ENXIO;
+			goto release_ioremap;
+		}
+	} else {
+		err = -ENODEV;
+		goto release_ioremap;
+	}
+
+	for (i=0; i<GPDMA_DMA_CHANNELS; i++) {
+		ctx->irq_chan[i] = platform_get_irq(pdev, i);
+		if (ctx->irq_chan[i]) {
+			if (request_irq(ctx->irq_chan[i],
+					gpdma_completion_interrupt_handler,
+					SA_INTERRUPT, "STM GPDMAC", ctx)) {
+				err = -ENXIO;
+				ctx->irq_chan[i] = 0;
+				goto release_all;
+			}
+		} else {
+			err = -ENODEV;
+			goto release_all;
+		}
+
+		tasklet_init(&ctx->channel[i].error_tasklet,
+			     (void *) gpdma_error_tasklet, i);
+		tasklet_init(&ctx->channel[i].completion_tasklet,
+		             (void *) gpdma_completion_tasklet, i);
+
+		/* park the channel in sensible state */
+		writel(DMA_GLOBAL_ENABLE_CHAN_(i), DMA_GLOBAL_DISABLE(ctx));
+		writel(DMA_CHAN_ENABLE_ALL_, DMA_CHAN_DISABLE(ctx, i));
+		writel(0, DMA_CHAN_COUNT(ctx, i));
+		writel(DMA_CHAN_ACTION_STALL_ACK_ |
+		       DMA_CHAN_ACTION_ALIGNMENT_ACK_ |
+		       DMA_CHAN_ACTION_BUS_ERROR_ACK_ |
+		       DMA_CHAN_ACTION_COMPLETE_ACK_,
+		       DMA_CHAN_ACTION(ctx, i));
+	}
+
+	register_dmac(&gpdma_info);
+
+	return 0;
+
+    release_all:
+
+	for (i=0; i<GPDMA_DMA_CHANNELS; i++) {
+		if (ctx->irq_chan[i])
+			free_irq(ctx->irq_chan[i], ctx);
+	}
+
+	free_irq(ctx->irq_err, ctx);
+
+    release_ioremap:
+	iounmap((void *) ctx->io_base);
+
+    release_region:
+	release_mem_region(res->start, res->end+1);
+
+	return err;
+}
+
+static int gpdma_drv_remove(struct device *dev)
+{
+	gpdma_chip *ctx = &chip;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	int i;
+
+	GPDMA_TRACE("terminating STM GPDMAC driver\n");
+
+	/* TODO: can't call this as it is discarded by kbuild (marked __exit) */
+	/*unregister_dmac(&gpdma_info);*/
+
+	free_irq(ctx->irq_err, ctx);
+	for (i=0; i<GPDMA_DMA_CHANNELS; i++)
+		free_irq(ctx->irq_chan[i], ctx);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	BUG_ON(!res);
+	release_mem_region(res->start, res->end+1);
+	iounmap((void *) ctx->io_base);
+
+
+	return 0;
+}
+
+
+static struct device_driver gpdma_driver = {
+	.name		= "gpdma",
+	.bus		= &platform_bus_type,
+	.probe		= gpdma_drv_probe,
+	.remove		= gpdma_drv_remove,
+};
+
+static struct dentry *gpdma_debugfs_root = NULL;
+static struct dentry *gpdma_debugfs_trace = NULL;
+
+static int __init gpdma_init(void)
+{
+	GPDMA_TRACE("registering STM GPDMAC driver\n");
+
+	/* expose some internal control variables using debugfs (good for
+	 * benchmarking) */
+	gpdma_debugfs_root = debugfs_create_dir("gpdma", NULL);
+	if (gpdma_debugfs_root)
+		gpdma_debugfs_trace = debugfs_create_bool("trace", 0600,
+				gpdma_debugfs_root, &enable_trace);
+
+	return driver_register(&gpdma_driver);
+}
+
+static void __exit gpdma_cleanup(void)
+{
+	GPDMA_TRACE("unregistering STM GPDMAC driver\n");
+
+	debugfs_remove(gpdma_debugfs_trace);
+	debugfs_remove(gpdma_debugfs_root);
+
+	driver_unregister(&gpdma_driver);
+}
+
+module_init(gpdma_init);
+module_exit(gpdma_cleanup);
+
diff -Naur linux-2.6.17.8/drivers/stm/Kconfig linux-2.6.17.8-sh/drivers/stm/Kconfig
--- linux-2.6.17.8/drivers/stm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/Kconfig	2006-08-23 13:29:48.819829000 +0100
@@ -0,0 +1,109 @@
+#
+# STM specific device configuration
+#
+
+config STM_DRIVERS
+	boolean
+	default y if CPU_SUBTYPE_ST40
+	default n
+
+menu "STM specific devices"
+        depends on STM_DRIVERS
+
+config STM_DMA
+	bool "STMicroelectronics DMA API"
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STM8000
+	default y
+	---help---
+	  Selecting this option will provide support for STMicroelectronics'
+	  custom DMA API. This API provides support for data transfers of
+	  various dimensions and complex linked list operations. In addition
+	  to these free-running operations it also allows management of the
+	  paced-transfer peripherals on recent STM parts.
+
+	  On STb7100 DMA support is vital for the correct operation of the
+	  sound system.
+
+	  If you have a device from STMicroelectronics, then say Y here.
+	  Otherwise say N.
+
+config STB7100_FDMA
+	def_bool STM_DMA && CPU_SUBTYPE_STB7100
+
+config STM_GPDMA
+	def_bool STM_DMA && CPU_SUBTYPE_STM8000
+
+config STM_SSC
+       bool "STM Synchronous Serial Controller"
+       depends on !I2C_ST40_PIO
+       default y
+       ---help---
+         This driver is required to support the I2C and the SPI
+         Protocol on STM SOCs
+
+config  STM_SSC_DEBUG
+	bool "STM SSC Debug"
+	depends on STM_SSC
+	default n
+        ---help---
+        Enable this option to print out information on STM SSC device driver
+
+config STM_SPI
+	bool "STM Serial Peripheral Interface"
+	depends on STM_SSC
+	---help---
+	This driver is required to support the SPI Protocol
+
+config  STM_SPI_DEBUG
+        bool "STM SPI Debug"
+        depends on STM_SPI
+        default n
+        ---help---
+        Enable this option to print out information on STM SPI device driver
+
+choice
+	prompt "STMicroelectronics coprocessor support"
+        depends on CPU_SUBTYPE_STM8000 || CPU_SUBTYPE_STB7100
+	default STM_COPROCESSOR
+        ---help---
+        Many of the ST system-on-chip devices have multiple CPUs, where a
+        master CPU running Linux has control over a number of slave CPUs,
+        which are usually used to run dedicated algorithms.
+        Enabling this option will add support to the Linux kernel to
+        control these slave CPUs, reserve memory for them, and thus allow
+        code to be downloaded onto them and executed.
+        Adding in the command line the following string:
+        coprocessor_mem=[offset]:size0[,size1][,size2]...
+        where:
+        offset defines where the co-processors region starts.
+               It's an offset from ST40 RAM start.
+        size{n} defines the region size for the n.th slave core (max 16M).
+
+        Example: coprocessor_mem=32m:16m,16m
+
+config  STM_COPROCESSOR
+	bool "STM coprocessor support"
+	help
+	  Select this option to enable support for the slave coprocessors
+	  found on many ST system-on-chip devices.
+
+config  STM_COPROCESSOR_FRMW
+	depends on CPU_SUBTYPE_STB7100
+	bool "The new STM coprocessor firmware support "
+	select FW_LOADER
+	help
+	  Select this option to enable support for the slave coprocessors
+	  found on many ST system-on-chip devices.
+
+endchoice
+
+config  COPROCESSOR_DEBUG
+        depends on STM_COPROCESSOR || STM_COPROCESSOR_FRMW
+        bool "STM coprocessor debug"
+        default n
+        ---help---
+        Enable this option to print out information about the slave CPUs
+        addresses and operations you are using for coprocessor.
+
+endmenu
+
diff -Naur linux-2.6.17.8/drivers/stm/Makefile linux-2.6.17.8-sh/drivers/stm/Makefile
--- linux-2.6.17.8/drivers/stm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/Makefile	2006-08-23 13:29:45.769760000 +0100
@@ -0,0 +1,14 @@
+#
+# Makefile for the STMicroelectronics device drivers.
+#
+
+obj-$(CONFIG_STB7100_FDMA)	+= 7100_fdma2.o
+obj-$(CONFIG_STM_GPDMA)		+= gpdma.o
+obj-$(CONFIG_STM_SSC)           += stm_ssc.o
+obj-$(CONFIG_STM_SPI)           += stm_spi.o
+obj-$(CONFIG_STM_COPROCESSOR)   += stm-coprocessor.o
+obj-$(CONFIG_STM_COPROCESSOR_FRMW)   += stm-coprocessor_frmw.o
+ifneq ($(CONFIG_STM_COPROCESSOR)$(CONFIG_STM_COPROCESSOR_FRMW),nn)
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= copro-stb7100.o
+obj-$(CONFIG_CPU_SUBTYPE_STM8000)	+= copro-stm8000.o
+endif
diff -Naur linux-2.6.17.8/drivers/stm/stm-coprocessor.c linux-2.6.17.8-sh/drivers/stm/stm-coprocessor.c
--- linux-2.6.17.8/drivers/stm/stm-coprocessor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm-coprocessor.c	2006-08-23 13:29:50.958875000 +0100
@@ -0,0 +1,735 @@
+/*
+ * Copyright (C) 2003-2004 Giuseppe Cavallaro (peppe.cavallaro@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interfaces (where required) the co-processors on ST platforms based
+ * on multiprocessor architecture, for embedded products like Set-top-Box
+ * DVD, etc...
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+#include <linux/delay.h>
+#include <linux/mm.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
+#include <linux/st-coprocessor.h>
+#include <linux/platform_device.h>
+#include <asm/types.h>
+#include <asm/uaccess.h>
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+/* ---------------------------------------------------------------------------
+ *     Local (declared out of order) functions
+ * ------------------------------------------------------------------------ */
+
+static int __init parse_coproc_mem(char *from);
+static int __init proc_st_coproc_init(void);
+
+/* ---------------------------------------------------------------------------
+ *    Exported and Imported
+ * ------------------------------------------------------------------------ */
+extern unsigned long memory_start, memory_end;
+
+/* ---------------------------------------------------------------------------
+ * 		Co-processor: Hardware dependent support
+ * This includes:
+ *    - per platform device and memory addresses
+ *    - platform dependent macros
+ *    - HW dependent actions required by the generic APIs: Init,
+ *      Open, Release, Ioctl (to reset, trigger the start (grant),
+ *      peek and poke, etc...) functions
+ * ------------------------------------------------------------------------ */
+
+extern struct coproc_board_info coproc_info;
+
+/* ---------------------------------------------------------------------------
+ *    Local data structure
+ * ------------------------------------------------------------------------ */
+
+extern coproc_t coproc[];	/* The maximum number of copro-  */
+					   /* cessors depends on platform   */
+					   /* type                          */
+
+#ifdef CONFIG_DEVFS_FS
+static devfs_handle_t devfs_reset_hdl;
+#endif
+
+#if defined(CONFIG_COPROCESSOR_DEBUG)
+/* -------------------------------------------------------------------------
+ * 			Co-processor DEBUG Suppor26t
+ *
+ *  Currently we do not expect to receive asynchronous events from the
+ *  slave processor. This routine as well as the IRQ definition has been
+ *  foreseen and used for debug purposes.
+ *  Once a slave is started the standard and supported way of communicating
+ *  with the host processor is to rely on the RPC service.
+ */
+
+static int irq_count = 0;
+static void mbx_irq_handle(int irq, void *cop, struct pt_regs *regs)
+{
+	/* avoid a noisy loop if possible! */
+	irq_count++;
+	if ((irq_count % 100) == 0)
+		printk("st-coprocessor: unexpected interrupt %d from %s\n",
+		       irq, ((coproc_t *) cop)->dev.bus_id);
+
+	(void)&mbx_irq_handle;	/* warning suppression */
+}
+
+#endif				/* CONFIG_COPROCESSOR_DEBUG */
+
+static void __debug(coproc_t * cop, const char *fnc)
+{
+
+	/* Print the coprocessor control structure */
+	printk("%s Coprocessor -------------------------------------------\n",
+	       cop->dev.bus_id);
+	if (cop->control == 0 || cop->ram_size == 0) {
+		printk("    not configured!\n");
+		goto skip_debug;
+	} else {
+		printk
+		    ("    flags %04x RAM start at 0x%08lx  size      0x%08x\n",
+		     cop->control, HOST_ADDR(cop, 0), cop->ram_size);
+		printk("                  cop. addr 0x%08lx\n",
+		       COPR_ADDR(cop, 0));
+	}
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	if (cop->h2c_port)
+		printk
+		    ("    Channels : h->c 0x%08x (%08lx)    c->h 0x%08x (%08lx)\n",
+		     cop->h2c_port, readl(cop->h2c_port), cop->c2h_port,
+		     readl(cop->c2h_port));
+	else
+#endif
+		printk("    Channels : Not defined\n");
+
+	if (cop->irq)
+		printk("    IRQ      : %d\n", cop->irq);
+	else
+		printk("    IRQ      : not used\n");
+
+      skip_debug:
+	printk
+	    ("---------------------------------------------------------------\n");
+
+}
+
+/* ---------------------------------------------------------------------------
+ * 			Co-processor driver APIs
+ * ------------------------------------------------------------------------ */
+
+static int st_coproc_open(struct inode *inode, struct file *file)
+{
+	/*
+	 ** use minor number (ID) to access the current coproc. descriptor
+	 */
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	DPRINTK(">>> %s: %s, cop->control = %d, cop->ram_size = %d\n",
+		__FUNCTION__, cop->dev.bus_id, cop->control, cop->ram_size);
+
+	if (((cop - coproc) / sizeof(coproc_t)) >= coproc_info.max_coprs)
+		return (-ENODEV);
+	if (cop->ram_size == 0)
+		return (-ENOSPC);
+	if (cop->control & COPROC_IN_USE)
+		return (-EBUSY);
+	cop->control |= COPROC_IN_USE;
+
+	/* Now call the platform dependent open stage */
+	coproc_cpu_open(cop);
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	__debug(cop, __FUNCTION__);
+#endif
+	return 0;
+}
+
+static int st_coproc_release(struct inode *inode, struct file *file)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	coproc_cpu_release(cop);
+	cop->control &= ~COPROC_IN_USE;
+
+	return 0;
+}
+
+static int st_coproc_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+	int res = 0;
+
+	switch (cmd) {
+	case STCOP_RESET:
+		res = coproc_cpu_reset(cop);
+		break;
+	case STCOP_GRANT:
+		/* Release the Slave CPU from reset (do not wait) */
+		res = coproc_cpu_grant(cop, arg);
+		break;
+
+/* Peek and poke 32 bit cell:  for debug only
+ * ------------------------------------------
+ * Not generally available, not documented and not supported.
+ * Simple and perhaps not reliable way for writing and reading a 32 bit
+ * value using the <stslave> application.
+ * PAY ATTENTION: the code doesn't make any validity check hence the use
+ *                of a wrong address may have undesired effects!
+ */
+#define PAIRS(p) (p)[0]		/* Number of couple:  addr./value */
+#define PORT(p)  (p)[1]		/* the address (port)             */
+#define VALUE(p) (p)[2]		/* the 32 bit value               */
+
+	case STCOP_PEEK:
+		{
+			u_long peek[3];
+			res = -EINVAL;
+
+			/* so far we need to peek only a single 32 bit cell */
+			if ((res = copy_from_user(peek, arg, sizeof(peek))) < 0)
+				break;
+			if (PAIRS(peek) != 1)
+				break;
+
+			/* make the addr 32 bit aligned  and peek the value */
+			PORT(peek) &= ~0x3;
+			VALUE(peek) = peek_l(PORT(peek));
+
+			DPRINTK(">>> %s: %s;  peek[%ld] @0x%08lx = 0x%08lx\n",
+				__FUNCTION__, cop->dev.bus_id,
+				PAIRS(peek), PORT(peek), VALUE(peek));
+
+			/* don't mind wich data, make it availbale to the user */
+			res = copy_to_user((void *)arg, peek, sizeof(peek));
+			break;
+		}
+
+	case STCOP_POKE:
+		{
+			u_long poke[3];
+			res = -EINVAL;
+
+			/* so far we need to peek only a single 32 bit cell */
+			if ((res = copy_from_user(poke, arg, sizeof(poke))) < 0)
+				break;
+			if (PAIRS(poke) != 1)
+				break;
+
+			/* make the addr 32 bit aligned  and poke the value */
+			PORT(poke) &= ~0x3;
+			poke_l(VALUE(poke), PORT(poke));
+
+			DPRINTK(">>> %s: %s;  poke[%ld] @0x%08lx = 0x%08lx\n",
+				__FUNCTION__, cop->dev.bus_id,
+				PAIRS(poke), PORT(poke), VALUE(poke));
+			res = 0;
+			break;
+		}
+
+	case STCOP_GET_PROPERTIES:
+		{
+			cop_properties_t clayout;
+
+			strncpy(clayout.name, cop->dev.bus_id,
+				sizeof(clayout.name));
+			clayout.flags = cop->control;
+
+			clayout.ram_start = HOST_ADDR(cop, 0);
+			clayout.ram_size = cop->ram_size;
+			clayout.cp_ram_start = COPR_ADDR(cop, 0);
+
+			res =
+			    copy_to_user((void *)arg, &clayout,
+					 sizeof(cop_properties_t));
+			break;
+		}
+
+	case STCOP_SET_PROPERTIES:
+		{
+			/* Not yet supported! */
+			printk(KERN_INFO
+			       "%s: setting properties not yet available\n",
+			       cop->dev.bus_id);
+			res = -ENOSYS;
+			break;
+		}
+
+	default:
+		res = -EINVAL;
+	}
+	return (res);
+}
+
+static ssize_t st_coproc_read(struct file *file, char *buf,
+			      size_t count, loff_t * ppos)
+{
+	coproc_t *cop;
+	u_long from;
+	ssize_t bytes;
+	u_int offset = *ppos;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/*
+	 * File position assumes the Coprocessor RAM base addr.
+	 * normalaized to 0
+	 */
+	if (offset >= cop->ram_size)
+		return (0);
+
+	from = (u_long) HOST_ADDR(cop, offset);
+	bytes = min(count, (cop->ram_size - offset));
+
+	DPRINTK(">>> %s: from 0x%08lx to 0x%08x len 0x%x(%d)\n",
+		__FUNCTION__, from, (u_int) buf, bytes, bytes);
+
+	if (copy_to_user(buf, from, bytes))
+		return (-EFAULT);
+
+	*ppos += bytes;
+
+	return (bytes);
+}
+
+static ssize_t st_coproc_write(struct file *file, const char *buf,
+			       size_t count, loff_t * ppos)
+{
+	coproc_t *cop;
+	u_long to;
+	ssize_t bytes;
+	u_int offset = (u_int) * ppos;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/* File position assumes the RAM base addr. normalaized to 0 */
+	if (offset >= (u_long) cop->ram_size)
+		return (-EFBIG);
+
+	to = (u_long) HOST_ADDR(cop, offset);
+	bytes = min(count, (cop->ram_size - offset));
+
+	DPRINTK(">>> %s: from 0x%08x to 0x%08lx len 0x%x(%d)\n",
+		__FUNCTION__, (u_int) buf, to, bytes, bytes);
+
+	if (copy_from_user(to, buf, bytes))
+		return (-EFAULT);
+
+	*ppos += bytes;
+	return (bytes);
+}
+
+static loff_t st_coproc_llseek(struct file *file, loff_t fpos, int orig)
+{
+	coproc_t *cop;
+	u_long offset = fpos;
+	u_long base;
+
+	cop = FILE_2_COP(coproc, file);
+
+	/*
+	 * fpos  can be a real offset within the coprocessor region or a
+	 * direct host address in the region (coming from application in
+	 * case of mmap).  This code assumes to be an address if it abs.
+	 * value > COPR_ADDR, a normal offset otherwyse.
+	 */
+	base = HOST_ADDR(cop, 0);
+
+	DPRINTK
+	    (">>> %s: seek to: 0x%08lx ->  fpos = offset 0x%lx + base 0x%lx\n",
+	     __FUNCTION__, (u_long) fpos, offset, HOST_ADDR(cop, 0));
+
+	switch (orig) {
+	case 0:
+		file->f_pos = offset;
+		break;		/* SEEK_SET */
+	case 1:
+		file->f_pos += offset;
+		break;		/* SEEK_CUR */
+	case 2:
+		file->f_pos = cop->ram_size + offset;
+		break;		/* SEEK_END */
+	default:
+		return -EINVAL;
+	}
+/*
+ * A little problem with the current (0.6) stslave
+ * The current stslave assumes a zero offset
+ */
+	file->f_pos -= cop->ram_offset;
+/*
+ * End stslave problem
+ */
+	if (file->f_pos >= cop->ram_size)
+		file->f_pos = cop->ram_size - 1;
+
+	return (file->f_pos);
+
+}
+
+static int st_coproc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned int vsize = vma->vm_end - vma->vm_start;
+	unsigned int psize = cop->ram_size - offset;
+
+	DPRINTK(">>> %s: vm_start=0x%lx, vm_end=0x%lx, vm_pgoff=0x%lx\n",
+		__FUNCTION__, vma->vm_start, vma->vm_end, vma->vm_pgoff);
+
+	if (vsize > psize)
+		return (-ENOSPC);
+
+	/*
+	 * Call the remap_pfn_range(...) function to map in user space the
+	 * coprocessor memory region. Uses ST40 no cache region
+	 */
+	vma->vm_flags |= VM_IO;
+	/* TODO: double check this. was a call
+	 *       to remap_page_range but without the >> PAGE_SHIFT
+	 */
+	if (remap_pfn_range(vma, vma->vm_start, cop->ram_offset
+			    >> PAGE_SHIFT, vsize, vma->vm_page_prot)) {
+		DPRINTK(">>> %s: remap_page_range(...) failed\n", __FUNCTION__);
+		return (-EAGAIN);
+	}
+
+	DPRINTK(">>> %s: ... done: 0x%08lx len 0x%x --> 0x%08lx\n",
+		__FUNCTION__, (unsigned long)HOST_ADDR(cop, 0), vsize,
+		vma->vm_start);
+	return (0);
+}
+
+static struct file_operations coproc_fops = {
+      llseek:st_coproc_llseek,
+      read:st_coproc_read,
+      write:st_coproc_write,
+      ioctl:st_coproc_ioctl,
+      mmap:st_coproc_mmap,
+      open:st_coproc_open,
+      release:st_coproc_release
+};
+
+/* Start: ST-Coprocessor Device Attribute on SysFs*/
+static ssize_t st_copro_show_running(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "%d", cop->control & COPROC_IN_USE);
+}
+
+static DEVICE_ATTR(running, S_IRUGO, st_copro_show_running, NULL);
+
+static ssize_t st_copro_show_mem_size(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "0x%x", cop->ram_size);
+}
+
+static DEVICE_ATTR(mem_size, S_IRUGO, st_copro_show_mem_size, NULL);
+
+static ssize_t st_copro_show_mem_base(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "0x%x", (int)cop->ram_offset);
+}
+
+static DEVICE_ATTR(mem_base, S_IRUGO, st_copro_show_mem_base, NULL);
+/* End: ST-Coprocessor Device Attribute SysFs*/
+
+static int st_coproc_driver_probe(struct device *dev)
+{
+	if (!strncmp("st2", dev->bus_id, 3))
+		return 1;
+	if (!strncmp("lx2", dev->bus_id, 3))
+		return 1;
+	return 0;
+}
+
+static struct device_driver st_coproc_driver = {
+	.name = "st-copro",
+	.owner = THIS_MODULE,
+	.bus = &platform_bus_type,
+	.probe = st_coproc_driver_probe,
+};
+
+static int __init st_coproc_init(void)
+{
+	int i;
+	coproc_t *cop;
+	struct device *dev;
+
+	printk("STMicroelectronics - Coprocessors %s Init\n", coproc_info.name);
+
+	if (driver_register(&st_coproc_driver)) {
+		printk(KERN_ERR
+		       "Error on ST-Coprocessor device driver registration\n");
+		return (-EAGAIN);
+	}
+
+	if (register_chrdev(COPROCESSOR_MAJOR, coproc_info.name, &coproc_fops)) {
+		printk("Can't allocate major %d for ST Coprocessor Devices\n",
+		       COPROCESSOR_MAJOR);
+		return (-EAGAIN);
+	}
+
+	for (cop = &coproc[0], i = 0; i < coproc_info.max_coprs; i++, cop++) {
+		cop->id = i;
+
+		if (!cop->ram_offset) {
+			printk("st-coprocessor-%d: No RAM reserved\n", cop->id);
+			cop->control &= ~COPROC_SPACE_ALLOCATE;
+		} else {
+			cop->control |= COPROC_SPACE_ALLOCATE;
+			cop->vma_address =
+				ioremap_nocache((unsigned long)cop->ram_offset, cop->ram_size);
+		}
+		/*
+		 ** Nodes:
+		 **    STm8000/ST220Eval: /dev/st220-0    c   63   0
+		 **                       /dev/st220-1    c   63   1
+		 **                       /dev/st220-2    c   63   2
+		 **    STb7100          : /dev/st231-0    c   63   0
+		 **                    : /dev/st231-1    c   63   1
+		 ** if the device file system support is configured the above
+		 ** devices are autonatically generated
+		 */
+		dev = &(cop->dev);
+		memset(dev, 0, sizeof(struct device));
+		sprintf(cop->dev.bus_id, "%s-%d", coproc_info.name, i);
+
+		dev->driver = &st_coproc_driver;
+		dev->parent = &platform_bus;
+		dev->bus = &platform_bus_type;
+
+		if (device_register(dev))
+			printk(KERN_ERR
+			       "Error on ST-Coprocessor device registration\n");
+		else {
+			/* Add the attributes on the device */
+			device_create_file(dev, &dev_attr_mem_base);
+			device_create_file(dev, &dev_attr_mem_size);
+			device_create_file(dev, &dev_attr_running);
+		}
+
+		/* Now complete with the platform dependent init stage */
+#if defined(CONFIG_COPROCESSOR_DEBUG) && defined(RPC_DEBUG)
+		{
+			/* just to debug on STi5528 application using the RPC 2.1,
+			 * install a fake interrupt hadler
+			 */
+			int res;
+
+			cop->irq = EMBX_IRQ + i;
+			if ((res = request_irq(cop->irq, &mbx_irq_handle, 0,
+					       coproc_info.name, cop)) != 0) {
+				printk
+				    ("st-coprocessor: Error %d booking IRQ %d for %s\n",
+				     res, cop->irq, cop->name);
+				cop->irq = 0;
+			}
+		}
+#endif
+		__debug(cop, __FUNCTION__);
+	}
+
+	proc_st_coproc_init();
+
+	return (0);
+}
+
+static void __exit st_coproc_exit(void)
+{
+	DPRINTK("Release coprocessor module...\n");
+}
+
+/*
+ * Parse the optional kernel argument:
+ *
+ * ... coprocessor_mem=size_0@phis_address_0, size_1@phis_address_1
+ *
+ * It seems to be reasonable to assume that in a "staically partitioned
+ * RAM layout", the regions of RAM assigned to each slave processor are
+ * not scattered in memory!
+ */
+static int __init parse_coproc_mem(char *from)
+{
+	char *cmdl = (from);	/* start scan from '=' char */
+	u_long size, addr;
+	int i = 0;
+	char *error_msg;
+	static char size_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing size\n";
+	static char addr_error[] __initdata =
+		KERN_ERR "st-coprocessor: Error parsing address\n";
+	static char too_many_warn[] __initdata =
+		KERN_WARNING "st-coprocessor: More regions than coprocessors\n";
+	static char alloc_error[] __initdata =
+		KERN_ERR "st-coprocessor: Failed to reserve memory at 0x%08x\n";
+
+	while (*cmdl && (i < coproc_info.max_coprs)) {
+		size = memparse(cmdl, &cmdl);
+		if (*cmdl != '@') {
+			error_msg = size_error;
+			goto args_error;
+		}
+		addr = memparse(cmdl+1, &cmdl);
+		if (*cmdl) {
+			if (*cmdl++ != ',') {
+				error_msg = addr_error;
+				goto args_error;
+			}
+		}
+		coproc[i].ram_offset = addr;
+		coproc[i].ram_size = size;
+		++i;
+	}
+
+	if (*cmdl) {
+		printk(too_many_warn);
+	}
+
+	for (i = 0; i < coproc_info.max_coprs; ++i) {
+		if (coproc[i].ram_size) {
+			void* mem;
+			addr = coproc[i].ram_offset;
+			size = coproc[i].ram_size;
+			/* Switch to __alloc_bootmem_nopanic or
+			 * __alloc_bootmem_core when we update the kernel. */
+			mem = __alloc_bootmem(size, PAGE_SIZE, addr);
+			if (mem != __va(addr)) {
+				if (mem) {
+					free_bootmem(virt_to_phys(mem), size);
+				}
+				printk(alloc_error, addr);
+
+				/* TODO: It would be a good idea to disable the
+				 * co-processor here but at present we cannot
+				 * do so. Basically we haven't actually checked
+				 * that the coprocessor image and the kernel
+				 * memory overlap. Without this check we cannot
+				 * disable the coprocessor since failure to
+				 * allocate from bootmem is *expected* in this
+				 * case.
+				 */
+				/*coproc[i].ram_offset = coproc[i].ram_size = 0;*/
+			}
+		}
+	}
+
+	return 1;
+
+args_error:
+	printk(error_msg);
+	return 1;
+}
+
+__setup("coprocessor_mem=", parse_coproc_mem);
+
+MODULE_DESCRIPTION("Co-processor manager for multi-core devices");
+MODULE_AUTHOR("STMicroelectronics Limited");
+MODULE_VERSION("0.3");
+MODULE_LICENSE("GPL");
+
+module_init(st_coproc_init);
+module_exit(st_coproc_exit);
+
+#if CONFIG_PROC_FS
+
+static int show_st_coproc(struct seq_file *m, void *v)
+{
+	int i;
+	coproc_t *cop;
+	seq_printf(m, "Coprocessors: %d  %s\n",
+		   coproc_info.max_coprs, coproc_info.name);
+	seq_printf(m,
+		   "  CPU (dev)        Host addr.     Copr. addr.     Size\n");
+	seq_printf(m,
+		   "  -------------------------------------------------------------------\n");
+	for (i = 0, cop = &coproc[0]; i < coproc_info.max_coprs; i++, cop++) {
+		seq_printf(m, "  /dev/%-8s    ", cop->dev.bus_id);
+		if (cop->ram_size == 0)
+			seq_printf(m, "not allocated!\n");
+		else
+			seq_printf(m,
+				   "0x%08lx     0x%08lx      0x%08x (%2d Mb)\n",
+				   HOST_ADDR(cop, 0), COPR_ADDR(cop, 0),
+				   cop->ram_size, (cop->ram_size / MEGA));
+	}
+	seq_printf(m, "\n");
+
+	coproc_proc_other_info(cop, m);
+	return (0);
+}
+
+static void *st_coproc_seq_start(struct seq_file *m, loff_t * pos)
+{
+	return (void *)(*pos == 0);
+}
+
+static void *st_coproc_seq_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	return NULL;
+}
+
+static void st_coproc_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+static struct seq_operations proc_st_coproc_op = {
+      start:st_coproc_seq_start,
+      next:st_coproc_seq_next,
+      stop:st_coproc_seq_stop,
+      show:show_st_coproc,
+};
+
+static int proc_st_coproc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &proc_st_coproc_op);
+}
+
+static struct file_operations proc_st_coproc_operations = {
+      open:proc_st_coproc_open,
+      read:seq_read,
+      llseek:seq_lseek,
+      release:seq_release,
+};
+
+static int __init proc_st_coproc_init(void)
+{
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry("coprocessor", 0, NULL);
+	if (entry != NULL) {
+		entry->proc_fops = &proc_st_coproc_operations;
+	}
+
+	return 0;
+}
+
+#endif				/* CONFIG_PROC_FS */
diff -Naur linux-2.6.17.8/drivers/stm/stm-coprocessor_frmw.c linux-2.6.17.8-sh/drivers/stm/stm-coprocessor_frmw.c
--- linux-2.6.17.8/drivers/stm/stm-coprocessor_frmw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm-coprocessor_frmw.c	2006-08-23 13:29:48.836829000 +0100
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2006 STMicroelectronics
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interfaces (where required) the co-processors on ST platforms based
+ * on multiprocessor architecture, for embedded products like Set-top-Box
+ * DVD, etc...
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+#include <linux/delay.h>
+#include <linux/mm.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
+#include <linux/st-coprocessor.h>
+#include <asm/types.h>
+#include <asm/sections.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#undef dbg_print
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+#define dbg_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dbg_print(fmt, args...)
+#endif
+
+/* ---------------------------------------------------------------------------
+ *     Local (declared out of order) functions
+ * ------------------------------------------------------------------------ */
+
+static int __init parse_coproc_mem(char *from);
+static int __init proc_st_coproc_init(void);
+
+/* ---------------------------------------------------------------------------
+ *    Exported and Imported
+ * ------------------------------------------------------------------------ */
+
+extern unsigned long memory_start, memory_end;
+
+/* ---------------------------------------------------------------------------
+ * 		Co-processor: Hardware dependent support
+ * This includes:
+ *    - per platform device and memory addresses
+ *    - platform dependent macros
+ *    - HW dependent actions required by the generic APIs: Init,
+ *      Open, Release, Ioctl (to reset, trigger the start (grant),
+ *      peek and poke, etc...) functions
+ * ------------------------------------------------------------------------ */
+
+extern struct coproc_board_info coproc_info;
+
+/* ---------------------------------------------------------------------------
+ *    Local data structure
+ * ------------------------------------------------------------------------ */
+
+extern coproc_t coproc[];	/* The maximum number of coprocessors
+				 * depends on platform type  */
+
+/* ---------------------------------------------------------------------------
+ * 			Co-processor driver APIs
+ * ---------------------------------------------------------------------------
+ */
+#define minor_2_firmware(min)  ( (min) & 0x3f      )
+#define minor_2_device(min)    ( ((min) >> 6) & 0x3)
+
+static int st_coproc_open(struct inode *inode, struct file *file)
+{
+	/*
+	 ** use minor number (ID) to access the current coproc. descriptor
+	 */
+	char firm_file[FIRMWARE_NAME_MAX];
+	char number[10];
+	unsigned long minor = MINOR((file)->f_dentry->d_inode->i_rdev);
+	unsigned long id_device = minor_2_device(minor);
+	unsigned long id_firmware = minor_2_firmware(minor);
+	struct firmware *fw = NULL;
+	int res;
+
+	coproc_t *cop = &coproc[id_device];
+
+	if (cop->control & COPROC_IN_USE)
+		return -EBUSY;
+	/* Now call the platform dependent open stage */
+	coproc_cpu_open(cop);
+/* Build the firmware file name.
+ * We use the standard name: "st_firmware_XX_XX.elf"
+ * to specify the device number and the firmware number
+ */
+
+	strcpy(firm_file, "st_firmware_");
+	sprintf(number, "%ld", id_device);
+	strcat(firm_file, number);
+	strcat(firm_file, "_");
+	sprintf(number, "%ld", id_firmware);
+	strcat(firm_file, number);
+	strcat(firm_file, ".elf");
+
+	dbg_print("Asking the file %s for %s\n", firm_file, cop->dev.bus_id);
+	if (request_firmware(&fw, firm_file, &(cop->dev)) == 0) {
+		unsigned long boot_address;
+		unsigned long p1_addr;
+
+		cop->control |= COPROC_IN_USE;
+		/* move the firmware in the coprocessor memory */
+		dbg_print("Received firmware size %d bytes\n", fw->size - 4);
+		dbg_print("cop->ram_size    = 0x%x\n", cop->ram_size);
+		dbg_print("cop->ram_offset  = 0x%x\n", cop->ram_offset);
+		/*
+		 * The last 4 bytes in the fw->data buffer
+		 * aren't code.
+		 * They are the boot vma (relocated) address!
+		 */
+		memcpy(&boot_address, (fw->data) + (fw->size - 4), 4);
+		dbg_print("boot address     = 0x%x\n", boot_address);
+		memcpy(cop->vma_address, fw->data, fw->size - 4);
+		release_firmware(fw);
+		dbg_print("Run the Firmware code\n");
+		coproc_cpu_grant(cop, boot_address);	//7100 only...
+		res = 0;
+	} else {
+		dbg_print("Error on Firmware Download\n");
+		res = -EINVAL;
+	}
+	return res;
+}
+
+static int st_coproc_release(struct inode *inode, struct file *file)
+{
+	coproc_t *cop = FILE_2_COP(coproc, file);
+
+	coproc_cpu_release(cop);
+	cop->control &= ~COPROC_IN_USE;
+
+	return 0;
+}
+
+static struct file_operations coproc_fops = {
+      open:st_coproc_open,
+      release:st_coproc_release
+};
+
+/* Start: ST-Coprocessor Device Attribute on SysFs*/
+static ssize_t st_copro_show_running(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "%d", cop->control & COPROC_IN_USE);
+}
+
+static DEVICE_ATTR(running, S_IRUGO, st_copro_show_running, NULL);
+
+static ssize_t st_copro_show_mem_size(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "0x%x", cop->ram_size);
+}
+
+static DEVICE_ATTR(mem_size, S_IRUGO, st_copro_show_mem_size, NULL);
+
+static ssize_t st_copro_show_mem_base(struct device *dev, char *buf)
+{
+	coproc_t *cop = container_of(dev, coproc_t, dev);
+	return sprintf(buf, "0x%x", (int)COPR_ADDR(cop, 0));
+}
+
+static DEVICE_ATTR(mem_base, S_IRUGO, st_copro_show_mem_base, NULL);
+/* End: ST-Coprocessor Device Attribute SysFs*/
+
+static int st_coproc_driver_probe(struct device *dev)
+{
+	if (!strncmp("st2", dev->bus_id, 3))
+		return 1;
+	return 0;
+}
+static struct device_driver st_coproc_driver = {
+	.name = "st-copro",
+	.owner = THIS_MODULE,
+	.bus = &platform_bus_type,
+	.probe = st_coproc_driver_probe,
+};
+
+static int __init st_coproc_init(void)
+{
+	int i;
+	coproc_t *cop;
+	struct device *dev;
+
+	printk("STMicroelectronics - Coprocessors %s Init\n", coproc_info.name);
+
+	if (driver_register(&st_coproc_driver)) {
+		printk(KERN_ERR
+		       "Error on ST-Coprocessor device driver registration\n");
+		return (-EAGAIN);
+	}
+
+	if (register_chrdev(COPROCESSOR_MAJOR, coproc_info.name, &coproc_fops)) {
+		printk("Can't allocate major %d for ST Coprocessor Devices\n",
+		       COPROCESSOR_MAJOR);
+		driver_unregister(&st_coproc_driver);
+		return (-EAGAIN);
+	}
+
+	for (cop = &coproc[0], i = 0; i < coproc_info.max_coprs; i++, cop++) {
+       /**
+        ** Nodes:
+        **    STm8000/ST220Eval: /dev/st220-0    c   63   0
+        **                       /dev/st220-1    c   63   1
+        **                       /dev/st220-2    c   63   2
+        **    STb7100          : /dev/st231-0    c   63   0
+        **                       /dev/st231-1    c   63   1
+        **/
+		cop->id = i;
+		if (!cop->ram_offset) {
+			printk("st-coprocessor-%d: No RAM reserved\n", cop->id);
+			cop->control &= ~COPROC_SPACE_ALLOCATE;
+		} else {
+			cop->control |= COPROC_SPACE_ALLOCATE;
+			cop->vma_address =
+			    ioremap_nocache(cop->ram_offset, cop->ram_size);
+		}
+		/*
+		 * Setup and Add the device entries in the SysFS
+		 */
+		dev = &(cop->dev);
+		memset(dev, 0, sizeof(struct device));
+		sprintf(cop->dev.bus_id, "%s-%d", coproc_info.name, i);
+		dev->driver = &st_coproc_driver;
+		dev->parent = &platform_bus;
+		dev->bus = &platform_bus_type;
+		if (device_register(dev))
+			printk(KERN_ERR
+			       "Error on ST-Coprocessor device registration\n");
+		else {
+			/* Add the attributes on the device */
+			device_create_file(dev, &dev_attr_mem_base);
+			device_create_file(dev, &dev_attr_mem_size);
+			device_create_file(dev, &dev_attr_running);
+		}
+
+		/* Now complete with the platform dependent init stage */
+		if (coproc_cpu_init(cop)) {
+			printk(KERN_ERR
+			       "CPU %d : HW dep. initialization failed!\n", i);
+			return (1);
+		}
+	}
+
+	proc_st_coproc_init();
+
+	return (0);
+}
+
+static void __exit st_coproc_exit(void)
+{
+	dbg_print("Release coprocessor module...\n");
+}
+
+/*
+ * Parse the optional kernel argument:
+ *
+ * ... coprocessor_mem=size_0@phis_address_0, size_1@phis_address_1
+ *
+ * It seems to be reasonable to assume that in a "staically partitioned
+ * RAM layout", the regions of RAM assigned to each slave processor are
+ * not scattered in memory!
+ */
+static int __init parse_coproc_mem(char *from)
+{
+	/*
+	 * If this proc. is called from point to the next token of
+	 * "coprocessor_mem=size_0@phis_address_0, size_1@phis_address_1"
+	 */
+	char *cmdl = from;	/* start scan from '=' char */
+	u_long value = 0;
+	int i = 0;
+	char *error_msg;
+	int ready_for_address = 0;
+
+	dbg_print(">>> parse_coproc_mem(*from: %11s...)\n", from);
+
+	for (i = 0; *cmdl; cmdl++) {
+		value = memparse(cmdl, &cmdl);
+		if (ready_for_address) {
+			/* the phisical offset must not overlap the code and data kernel */
+			/* if so the coprocessor ram isn't (!!!) reserved */
+			dbg_print(">>> Copro offset: 0x%x\n",
+				  (value + PAGE_OFFSET));
+			coproc[i].ram_offset =
+			    ((value + PAGE_OFFSET) <= (unsigned long)_end)
+			    ? 0 : value;	/* phisical address */
+		} else
+			coproc[i].ram_size = value;
+
+		switch (*cmdl) {
+		case ',':
+		case ' ':
+		case '\0':
+			ready_for_address = 0;
+			++i;
+			break;
+		case '@':
+			ready_for_address = 1;
+			break;
+		default:
+			error_msg = "syntax error";
+			goto args_error;
+		}
+
+	}
+	for (i = 0; i < coproc_info.max_coprs; ++i)
+		if (coproc[i].ram_offset && coproc[i].ram_size &&
+		    ((coproc[i].ram_offset + coproc[i].ram_size) <
+		     PHYSADDR(memory_end)))
+			reserve_bootmem(coproc[i].ram_offset,
+					coproc[i].ram_size);
+		else
+			coproc[i].ram_offset = coproc[i].ram_size = 0;
+	return 0;
+
+      args_error:
+	printk(KERN_ERR "Coproc. args: %s. Coproc. ignored!\n", error_msg);
+	return -EINVAL;
+}
+
+__setup("coprocessor_mem=", parse_coproc_mem);
+
+MODULE_DESCRIPTION("Co-processor manager for multi-core devices");
+MODULE_AUTHOR("STMicroelectronics Limited");
+MODULE_VERSION("0.3");
+MODULE_LICENSE("GPL");
+
+module_init(st_coproc_init);
+module_exit(st_coproc_exit);
+
+#if CONFIG_PROC_FS
+
+static int show_st_coproc(struct seq_file *m, void *v)
+{
+	int i;
+	coproc_t *cop;
+
+	seq_printf(m, "Coprocessors: %d  %s\n", coproc_info.max_coprs,
+		   coproc_info.name);
+	seq_printf(m,
+		   "  CPU (dev)        Host addr.     Copr. addr.     Size\n");
+	seq_printf(m,
+		   "  -----------------------------------------------------------		--------\n");
+	for (i = 0, cop = &coproc[0]; i < coproc_info.max_coprs; i++, cop++) {
+		seq_printf(m, "  /dev/%-8s    ", cop->dev.bus_id);
+		if (cop->ram_size == 0)
+			seq_printf(m, "not allocated!\n");
+		else
+			seq_printf(m,
+				   "0x%08lx     0x%08lx      0x%08x (%2d Mb)\n",
+				   (HOST_ADDR(cop, 0)), COPR_ADDR(cop, 0),
+				   cop->ram_size, (cop->ram_size / MEGA));
+	}
+	seq_printf(m, "\n");
+
+	coproc_proc_other_info(cop, m);
+	return (0);
+}
+
+static void *st_coproc_seq_start(struct seq_file *m, loff_t * pos)
+{
+	return (void *)(*pos == 0);
+}
+
+static void *st_coproc_seq_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	return NULL;
+}
+
+static void st_coproc_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+static struct seq_operations proc_st_coproc_op = {
+      start:st_coproc_seq_start,
+      next:st_coproc_seq_next,
+      stop:st_coproc_seq_stop,
+      show:show_st_coproc,
+};
+
+static int proc_st_coproc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &proc_st_coproc_op);
+}
+
+static struct file_operations proc_st_coproc_operations = {
+      open:proc_st_coproc_open,
+      read:seq_read,
+      llseek:seq_lseek,
+      release:seq_release,
+};
+
+static int __init proc_st_coproc_init(void)
+{
+	struct proc_dir_entry *entry;
+	entry = create_proc_entry("coprocessor", 0, NULL);
+	if (entry != NULL) {
+		entry->proc_fops = &proc_st_coproc_operations;
+	}
+
+	return 0;
+}
+
+#endif				/* CONFIG_PROC_FS */
diff -Naur linux-2.6.17.8/drivers/stm/stm_spi.c linux-2.6.17.8-sh/drivers/stm/stm_spi.c
--- linux-2.6.17.8/drivers/stm/stm_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm_spi.c	2006-08-23 13:29:41.511669000 +0100
@@ -0,0 +1,765 @@
+/*
+   -------------------------------------------------------------------------
+   stm_spi.c
+   -------------------------------------------------------------------------
+   STMicroelectronics
+
+
+   ----------------------------------------------------------------------------
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, wrssc to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+/* ------------------------------------------------------------------------- */
+#include "stm_spi.h"
+#include "stm_spi_ioctl.h"
+#include <linux/stpio.h>
+#include <linux/vmalloc.h>
+#include <asm/semaphore.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/param.h>		/* for HZ */
+
+
+#undef dgb_print
+
+#ifdef  CONFIG_STM_SPI_DEBUG
+#define SPI_LOOP_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#define NANOSEC_PER_SEC         1000000000
+
+#define SPI_LINE_SHIFT      0x0
+#define SPI_BANK_SHIFT      0x3
+#define SPI_MODE_SHIFT      0x7
+
+#define SPI_LINE_MASK       0x7
+#define SPI_BANK_MASK       0xf
+#define SPI_MODE_MASK       0x1
+#define SPI_DEVICE_MASK     0xff
+
+#define spi_get_mode(address)       ( (address >> SPI_MODE_SHIFT) & SPI_MODE_MASK )
+#define spi_get_bank(address)       ( (address >> SPI_BANK_SHIFT) & SPI_BANK_MASK )
+#define spi_get_line(address)       ( (address >> SPI_LINE_SHIFT) & SPI_LINE_MASK )
+#define spi_get_device(address)     (  address & SPI_DEVICE_MASK )
+
+enum spi_state_machine_e {
+	SPI_FSM_VOID = 0,
+	SPI_FSM_PREPARE,
+	SPI_FSM_RUNNING_8BITS,
+	SPI_FSM_RUNNING_16BITS,
+	SPI_FSM_STOP,
+	SPI_FSM_COMPLETE,
+	SPI_FSM_ABORT
+};
+
+struct spi_client_t {
+	struct spi_device_t *dev;	/* the bus device used */
+	struct stpio_pin *pio_chip;
+	enum spi_state_machine_e state;
+	enum spi_state_machine_e next_state;
+	unsigned int msg_length;	// in bytes
+	unsigned int idx_write;
+	unsigned int idx_read;
+	char *buf_write;
+	char *buf_read;
+	unsigned long timeout;
+#define SPI_PHASE_MASK            0x01
+#define SPI_PHASE_HIGH            0x01
+#define SPI_PHASE_LOW             0x00
+
+#define SPI_POLARITY_MASK         0x02
+#define SPI_POLARITY_HIGH         0x02
+#define SPI_POLARITY_LOW          0x00
+
+#define SPI_MSB_MASK              0x04
+#define SPI_MSB                   0x04
+#define SPI_LSB                   0x00
+
+#define SPI_FULLDUPLEX_MASK       0x08
+#define SPI_FULLDUPLEX            0x08
+#define SPI_HALFDUPLEX            0x00
+
+#define SPI_WIDE_MASK             0x10
+#define SPI_WIDE_16BITS           0x10
+#define SPI_WIDE_8BITS            0x00
+
+#define SPI_CSACTIVE_MASK         0x20
+#define SPI_CSACTIVE_HIGH         0x20
+#define SPI_CSACTIVE_LOW          0x00
+
+#define SPI_BAUDRATE_MASK         0xffff0000
+#define SPI_BAUDRATE_SHIFT        0x10
+
+/*
+ *  * Virtual Configuration *
+ *
+ *  [  0: POLARITY  :0]
+ *  [  1: PHASE     :1]
+ *  [  2: MSB       :2]
+ *  [  3: FULL/HALF :3]
+ *  [  4: WIDE      :4]
+ *  [  5: CS_ACTIVE :5]
+ *  [ 15: FREE      :6]
+ *  [ 31: BAUDRATE  :16]
+ *
+ */
+	unsigned int virtual_configuration;
+};
+
+#define SPI_MAJOR_NUMBER 98
+
+#define SPI_RDWR_OFFSET   8
+static struct cdev spi_char_dev;
+
+/*
+ *  In this way i can manage no more than 5 bus spi
+ *  but 5 it's enough for our platform
+ */
+#define MAX_NUMBER_SPI_BUSSES 5
+/*
+ *  This array is used to speed up the
+ *  open device file
+ */
+struct spi_device_t *spi_busses_array[MAX_NUMBER_SPI_BUSSES];
+//static LIST_HEAD(spi_busses);
+/*
+ * In this way the spi bus will be available
+ * with the spi_busses_array array
+ * or the spi_busses list
+ */
+
+#define spi_malloc(size)     vmalloc(size)
+#define spi_free(addr)       vfree(addr)
+
+#define jump_on_fsm_complete()     { spi->state = SPI_FSM_COMPLETE;    \
+                                      goto be_fsm_complete;       }
+
+void spi_algo_state_machine(struct spi_client_t *spi)
+{
+
+   struct device *dev    = spi->dev->dev.parent;
+   struct ssc_t *ssc_bus = container_of(dev,struct ssc_t,dev);
+	unsigned short status;
+   unsigned int   idx;
+   unsigned short tx_fifo_status;
+   unsigned short rx_fifo_status;
+	unsigned int config = spi->virtual_configuration;
+	unsigned int phase, polarity;
+	unsigned int hb, frame_size;
+	unsigned char ctmp;
+
+	union {
+		char bytes[2];
+		short word;
+	} tmp;
+
+	tmp.word = 0;
+	spi->state = spi->next_state;
+
+	switch (spi->state) {
+	case SPI_FSM_PREPARE:
+	   dgb_print("-SPI_FSM_PREPARE\n");
+		spi->idx_write = 0;
+		spi->idx_read = 0;
+		phase = ((config & SPI_PHASE_MASK) ? 1 : 0);
+		polarity = ((config & SPI_POLARITY_MASK) ? 1 : 0);
+		hb = ((config & SPI_MSB_MASK) ? 1 : 0);
+		frame_size = ((config & SPI_WIDE_MASK) ? 1 : 0) * 0x8 + 0x7;
+
+		ssc_store16(ssc_bus, SSC_BRG,
+			    (config & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
+
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_SR | 0x1);
+		ssc_store16(ssc_bus, SSC_I2C, 0x0);
+		ssc_store16(ssc_bus, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+			    (SSC_CTL_PO * polarity) |
+			    (SSC_CTL_PH * phase) | (SSC_CTL_HB * hb) |
+#ifdef SPI_LOOP_DEBUG
+			    SSC_CTL_LPB |
+#endif
+			    frame_size);
+		tmp.bytes[0] = spi->buf_write[spi->idx_write++];
+
+		spi->next_state = SPI_FSM_RUNNING_8BITS;
+		if (frame_size > 0x7) {
+			spi->next_state = SPI_FSM_RUNNING_16BITS;
+
+			ctmp = tmp.bytes[0];
+			tmp.bytes[0] = spi->buf_write[spi->idx_write++];
+			tmp.bytes[1] = ctmp;
+		}
+	   ssc_load16(ssc_bus, SSC_RBUF);/* only to clear the status register */
+		ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
+		ssc_store16(ssc_bus, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_RIEN);
+
+		break;
+
+	case SPI_FSM_RUNNING_8BITS:
+		dgb_print(" SPI_FSM_RUNNING:\n");
+
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if ((status & SSC_STA_RIR) && spi->idx_read < spi->msg_length) {
+			tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+			spi->buf_read[spi->idx_read++] = tmp.bytes[0];
+			dgb_print(" Reading: %c\n", tmp.bytes[0]);
+		}
+		if ((status & SSC_STA_TIR) && spi->idx_write < spi->msg_length) {
+                	dgb_print(" Writeing %c\n",
+				spi->buf_write[spi->idx_write]);
+			tmp.bytes[0] = spi->buf_write[spi->idx_write++];
+			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
+		}
+		if (spi->idx_write >= spi->msg_length
+		    && spi->idx_read >= spi->msg_length)
+			jump_on_fsm_complete();
+		break;
+	case SPI_FSM_RUNNING_16BITS:
+		dgb_print(" SPI_FSM_RUNNING_16BITS\n");
+		status = ssc_load16(ssc_bus, SSC_STA);
+		if ((status & SSC_STA_RIR) && spi->idx_read < spi->msg_length) {
+			tmp.word = ssc_load16(ssc_bus, SSC_RBUF);
+			spi->buf_read[spi->idx_read++] = tmp.bytes[1];
+			spi->buf_read[spi->idx_read++] = tmp.bytes[0];
+			dgb_print(" Reading: %c %c\n", tmp.bytes[1],
+				tmp.bytes[0]);
+		}
+		if ((status & SSC_STA_TIR) && spi->idx_write < spi->msg_length) {
+			dgb_print(" Writeing %c %c\n",
+				spi->buf_write[spi->idx_write],
+				spi->buf_write[spi->idx_write + 1]);
+			tmp.bytes[1] = spi->buf_write[spi->idx_write++];
+			tmp.bytes[0] = spi->buf_write[spi->idx_write++];
+			ssc_store16(ssc_bus, SSC_TBUF, tmp.word);
+		}
+		if (spi->idx_write >= spi->msg_length
+		    && spi->idx_read >= spi->msg_length)
+			jump_on_fsm_complete();
+		break;
+	case SPI_FSM_COMPLETE:
+	      be_fsm_complete:
+		dgb_print(" SPI_FSM_COMPLETE\n");
+		ssc_store16(ssc_bus, SSC_IEN, 0x0);
+		wake_up(&(ssc_bus->wait_queue));
+		break;
+
+	case SPI_FSM_VOID:
+	default:
+		;
+	}
+	return;
+}
+
+#define chip_asserted() if ( spi->virtual_configuration & SPI_CSACTIVE_MASK ) \
+                             stpio_set_pin(spi->pio_chip, 0x1);               \
+                        else stpio_set_pin(spi->pio_chip, 0x0);
+
+#define chip_deasserted() if ( spi->virtual_configuration & SPI_CSACTIVE_MASK ) \
+                               stpio_set_pin(spi->pio_chip, 0x0);               \
+                          else stpio_set_pin(spi->pio_chip, 0x1);
+
+static ssize_t spi_cdev_read(struct file *filp,
+			     char __user * buff, size_t count, loff_t * offp)
+{
+	struct spi_client_t *spi = (struct spi_client_t *)filp->private_data;
+        struct device *dev = spi->dev->dev.parent;
+	struct ssc_t *ssc_bus = container_of(dev,struct ssc_t,dev);
+	unsigned int local_flag;
+
+	if (spi->pio_chip == NULL)
+		return -ENODATA;
+
+	if (spi->virtual_configuration & SPI_FULLDUPLEX_MASK) {
+/*
+ * In FullDuplex Mode
+ * The Datas are already ready...
+ */
+		if (spi->buf_read == NULL)
+			return 0;
+		dgb_print("Reading in FullD\n");
+		copy_to_user(buff, spi->buf_read, spi->msg_length);
+		spi_free(spi->buf_read);
+		spi->buf_read = NULL;
+		return spi->msg_length;
+	}
+
+	/*
+	 * the first step is request the bus access
+	 */
+	ssc_request_bus(ssc_bus, spi_algo_state_machine, (void *)spi);
+
+	chip_asserted();
+
+#ifdef SPI_LOOP_DEBUG
+#define DUMMY   "dummy_string_only_for_test"
+	count = strlen(DUMMY);
+#endif
+
+	dgb_print("Reading in Half/D %d bytes\n", count);
+	spi->buf_read = (char *)spi_malloc(count+SPI_RDWR_OFFSET);
+        spi->buf_write = spi->buf_read+SPI_RDWR_OFFSET;
+	spi->msg_length = count;
+
+#ifdef SPI_LOOP_DEBUG
+	strcpy(spi->buf_write, DUMMY);
+#endif
+
+	spi->next_state = SPI_FSM_PREPARE;
+	local_irq_save(local_flag);
+
+/*
+ *  When the data frame is 16 bits lenght
+ *  the msg_length must be %2=0
+ *
+ */
+	if (spi->virtual_configuration & SPI_WIDE_MASK)
+		spi->msg_length &= ~0x1;
+
+	spi_algo_state_machine(spi);
+	interruptible_sleep_on_timeout(&(ssc_bus->wait_queue),
+				       spi->timeout * HZ);
+	local_irq_restore(local_flag);
+
+	chip_deasserted();
+
+	ssc_release_bus(ssc_bus);
+	copy_to_user(buff, spi->buf_read, count);
+	spi_free(spi->buf_read);
+	spi->buf_read = NULL;
+	spi->buf_write = NULL;
+	return count;
+}
+
+static ssize_t spi_cdev_write(struct file *filp,
+			      const char __user * buff,
+			      size_t count, loff_t * offp)
+{
+	struct spi_client_t *spi = (struct spi_client_t *)filp->private_data;
+        struct device *dev = spi->dev->dev.parent;
+	struct ssc_t *ssc_bus = container_of(dev,struct ssc_t,dev);
+	unsigned int local_flag;
+	dgb_print("\n");
+
+	if (spi->pio_chip == NULL)
+		return -ENODATA;
+
+	ssc_request_bus(ssc_bus, spi_algo_state_machine, (void *)spi);
+
+	chip_asserted();
+
+	if (spi->buf_read != NULL)
+		spi_free(spi->buf_read);
+
+	spi->buf_read  = spi_malloc(count+SPI_RDWR_OFFSET);
+        spi->buf_write = spi->buf_read+SPI_RDWR_OFFSET;
+
+	spi->msg_length = count;
+	if (spi->virtual_configuration & SPI_WIDE_MASK)
+		spi->msg_length &= ~0x1;
+
+	copy_from_user(spi->buf_write, buff, spi->msg_length);
+
+	spi->next_state = SPI_FSM_PREPARE;
+
+	local_irq_save(local_flag);
+	spi_algo_state_machine(spi);
+	interruptible_sleep_on_timeout(&(ssc_bus->wait_queue),
+				       spi->timeout * HZ);
+	local_irq_restore(local_flag);
+	chip_deasserted();
+	spi->buf_write = NULL;
+	ssc_release_bus(ssc_bus);
+
+	if (!(spi->virtual_configuration & SPI_FULLDUPLEX)) {
+#ifdef SPI_LOOP_DEBUG
+		dgb_print("Read: %s\n", spi->buf_read);
+#endif
+		spi_free(spi->buf_read);
+		spi->buf_read = NULL;
+		spi->msg_length = 0;
+	}
+	return count;
+}
+
+static int spi_cdev_addressing(unsigned int address, struct spi_client_t *spi)
+{
+	unsigned int spi_device;
+
+	spi_device = spi_get_device(address);
+
+	dgb_print("Spi opening Slave 0x%x (%d)\n", spi_device, spi_device);
+
+/* 1. release the Pio of previous addressing*/
+        if ( spi->pio_chip)
+            stpio_free_pin(spi->pio_chip);
+       spi->pio_chip = NULL;
+// 2. check if the pio[BANK][LINE] used for chip_selector is free
+	spi->pio_chip =
+	    stpio_request_pin(spi_get_bank(address), spi_get_line(address),
+			      "spi-chip-selector", STPIO_OUT);
+
+	if (!(spi->pio_chip)) {
+/*
+ * Somebody already requested the PIO[bank][line]
+ * therefore we abort the addressing
+ */
+		dgb_print("Error Pio locked or not-exist\n");
+		return -ENOSYS;
+	}
+	dgb_print("->with PIO [%d][%d]\n", spi_get_bank(address),
+		spi_get_line(address));
+
+	spi->virtual_configuration =
+	    spi->virtual_configuration & ~SPI_FULLDUPLEX;
+	dgb_print("->with FULLDUPLEX = 0x%x\n", spi_get_mode(address));
+	spi->virtual_configuration |= SPI_FULLDUPLEX * spi_get_mode(address);
+/*
+ *  Free the data of prev addressing
+ */
+	if (spi->buf_read != NULL)
+		spi_free(spi->buf_read);
+
+	spi->buf_read = NULL;
+	chip_deasserted();
+
+	return 0;
+
+}
+
+static int spi_cdev_ioctl(struct inode *inode,
+			  struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct spi_client_t *spi = (struct spi_client_t *)filp->private_data;
+
+	dgb_print("\n");
+
+	switch (cmd) {
+	case SPI_IOCTL_WIDEFRAME:
+		spi->virtual_configuration =
+		    spi->virtual_configuration & ~SPI_WIDE_MASK;
+		if (arg)
+			spi->virtual_configuration |= SPI_WIDE_16BITS;
+		break;
+	case SPI_IOCTL_POLARITY:
+		spi->virtual_configuration =
+		    spi->virtual_configuration & ~SPI_POLARITY_MASK;
+		if (arg)
+			spi->virtual_configuration |= SPI_POLARITY_HIGH;
+		break;
+	case SPI_IOCTL_PHASE:
+		spi->virtual_configuration =
+		    spi->virtual_configuration & ~SPI_PHASE_MASK;
+		if (arg)
+			spi->virtual_configuration |= SPI_PHASE_HIGH;
+		break;
+	case SPI_IOCTL_HEADING:
+		spi->virtual_configuration =
+		    spi->virtual_configuration & ~SPI_MSB_MASK;
+		if (arg)
+			spi->virtual_configuration |= SPI_MSB;
+		break;
+	case SPI_IOCTL_BUADRATE:
+		{
+			unsigned long baudrate;
+			baudrate =
+			    ssc_get_clock() / (2 *arg);
+			spi->virtual_configuration =
+			    spi->virtual_configuration & ~SPI_BAUDRATE_MASK;
+			spi->virtual_configuration =
+			    spi->
+			    virtual_configuration | (baudrate <<
+						     SPI_BAUDRATE_SHIFT);
+		}
+		break;
+	case SPI_IOCTL_CSACTIVE:
+		spi->virtual_configuration =
+		    spi->virtual_configuration & ~SPI_CSACTIVE_MASK;
+		if (arg)
+			spi->virtual_configuration |= SPI_CSACTIVE_HIGH;
+		break;
+	case SPI_IOCTL_ADDRESS:
+		if (spi_cdev_addressing((unsigned int)arg, spi) != 0)
+			return -1;
+		break;
+	case SPI_IOCTL_TIMEOUT:
+		spi->timeout = arg;
+		break;
+	default:
+		;
+	}
+
+#ifdef SPI_STM_DEBUG
+	{
+		unsigned int conf = spi->virtual_configuration;
+		dgb_print("SPI - Virtual Config:\n");
+		dgb_print(" - PHASE:    0x%x\n", (conf & SPI_PHASE_MASK) != 0);
+		dgb_print(" - POLARITY: 0x%x\n", (conf & SPI_POLARITY_MASK) != 0);
+		dgb_print(" - HEADING:  0x%x\n", (conf & SPI_MSB_MASK) != 0);
+		dgb_print(" - FULLDUP:  0x%x\n",
+			(conf & SPI_FULLDUPLEX_MASK) != 0);
+		dgb_print(" - WIDE:     0x%x\n", (conf & SPI_WIDE_MASK) != 0);
+		dgb_print(" - CSACTIVE: 0x%x\n", (conf & SPI_CSACTIVE_MASK) != 0);
+		dgb_print(" - BUADRATE: 0x%x\n",
+			(conf & SPI_BAUDRATE_MASK) >> SPI_BAUDRATE_SHIFT);
+	}
+#endif
+	return 0;
+}
+
+static int spi_cdev_open(struct inode *inode, struct file *filp)
+{
+	unsigned int minor;
+	struct spi_client_t *spi;
+
+	dgb_print("\n");
+
+	minor = iminor(inode);
+	if (minor >= MAX_NUMBER_SPI_BUSSES)
+		return -ENODEV;
+        if (!spi_busses_array[minor])
+                return -ENODEV;
+        spi = (struct spi_client_t *)kmalloc(GFP_KERNEL,sizeof(struct spi_client_t));
+	spi->dev = spi_busses_array[minor];
+	spi->timeout = 5;	/* 5 seconds */
+	spi->msg_length = 0;
+	spi->buf_write = NULL;
+	spi->buf_read = NULL;
+	spi->pio_chip = NULL;
+/*
+ *  1 Phase
+ *  1 Polarity
+ *  1 Heading
+ *  - Full/Half
+ *  1 Wide (16bits)
+ *  0 CSActive
+ *  1 MHz (at 133MHz of common clock)
+ */
+	spi->virtual_configuration = 0x420017;
+
+	filp->private_data = spi;
+	return 0;
+}
+
+static int spi_cdev_release(struct inode *inode, struct file *filp)
+{
+	struct spi_client_t *spi = (struct spi_client_t *)filp->private_data;
+
+   dgb_print("\n");
+	if (spi->pio_chip != NULL) {
+		stpio_free_pin(spi->pio_chip);
+		spi->pio_chip = NULL;
+	}
+   dgb_print("PIO-chip released\n");
+	if (spi->buf_read != NULL)
+		spi_free(spi->buf_read);
+   kfree(spi);
+	filp->private_data = NULL;
+	return 0;
+}
+
+struct file_operations spi_stm_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.open = spi_cdev_open,
+	.release = spi_cdev_release,
+	.read = spi_cdev_read,
+	.write = spi_cdev_write,
+	.ioctl = spi_cdev_ioctl
+};
+
+static int spi_stm_match(struct device *dev, struct device_driver *drv)
+{
+   dgb_print("\n");
+	if (dev == NULL || drv == NULL)
+		return 0;
+	return !strncmp(dev->bus_id, drv->name, 3);
+}
+
+struct bus_type spi_bus_type = {
+	.name = "spi",
+	.match = spi_stm_match,
+};
+
+void spi_del_adapter(struct spi_device_t *spi_dev)
+{
+   dgb_print("\n");
+   spi_busses_array[spi_dev->idx_dev]=0;
+   kfree(spi_dev);
+   return ;
+}
+
+#define SPI_DRIVER_BUS
+#if   defined(SPI_DRIVER_BUS)
+static int spi_bus_driver_probe(struct device *dev)
+{
+   struct spi_device_t *spi_dev;
+
+   dgb_print("\n");
+   spi_dev = container_of(spi_dev,struct spi_device_t,dev);
+
+   return spi_dev->dev_type == SPI_DEV_BUS_ADAPTER;
+};
+
+static void spi_bus_driver_remove(struct device *dev)
+{
+	struct spi_device_t *spi_dev;
+   spi_dev = container_of(dev,struct spi_device_t,dev);
+   dgb_print("\n");
+//   spi_del_adapter(spi_dev);
+//   dgb_print("..\n");
+   return;
+}
+static void spi_bus_driver_shutdown(struct device *dev)
+{
+   struct spi_device_t *spi_dev;
+   spi_dev = container_of(dev,struct spi_device_t,dev);
+   dgb_print("\n");
+   spi_del_adapter(spi_dev);
+//   dgb_print("..\n");
+   return;
+}
+static struct device_driver spi_bus_drv = {
+   .owner = THIS_MODULE,
+   .name = "spi_bus_drv",
+   .bus = &spi_bus_type,
+   .probe = spi_bus_driver_probe,
+   .shutdown = spi_bus_driver_shutdown,
+   .remove   = spi_bus_driver_remove,
+};
+#endif
+
+int spi_add_adapter(struct spi_device_t *spi_dev)
+{
+	unsigned int ret;
+   unsigned int idx_dev = spi_dev->idx_dev;
+
+   dgb_print("\n");
+   spi_dev->dev_type = SPI_DEV_BUS_ADAPTER;
+	spi_dev->dev.bus = &(spi_bus_type);
+   sprintf(spi_dev->dev.bus_id, "spi-%d", idx_dev);
+   spi_dev->dev.release = spi_del_adapter;
+#if defined(SPI_DRIVER_BUS)
+   spi_dev->dev.driver = &spi_bus_drv;
+#endif
+	ret = device_register(&spi_dev->dev);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register %s bus\n",
+		       spi_dev->dev.bus_id);
+		kfree(spi_dev);
+	} else {
+/*
+ * with the spi_busses_array
+ * i avoid to used the list
+ */
+     spi_busses_array[idx_dev] = spi_dev;
+     //list_add(&spi_dev->list, &spi_busses);
+	}
+	return ret;
+}
+
+static int spi_stm_adapter_detect()
+{
+	unsigned int idx;
+   unsigned int num_ssc_bus = ssc_device_available();
+	unsigned int num_spi_bus;
+	struct spi_device_t *spi_dev;
+   struct ssc_t **ssc_busses;
+   dgb_print("\n");
+/*
+ *  Check the ssc on the platform
+ */
+   ssc_busses = (struct ssc_t **) kmalloc(num_ssc_bus *
+                        sizeof(struct ssc_t *), GFP_KERNEL);
+   for (idx = 0, num_spi_bus = 0; idx < num_ssc_bus; ++idx)
+       if ((ssc_capability(idx) & SSC_SPI_CAPABILITY))
+            ssc_busses[num_spi_bus++] = ssc_device_request(idx);
+
+   for (idx = 0; idx < num_spi_bus; ++idx) {
+      spi_dev = (struct spi_device_t *)
+               kmalloc(sizeof(struct spi_device_t), GFP_KERNEL);
+      memset(&spi_dev->dev, 0, sizeof(struct device));
+      spi_dev->dev.parent = &(ssc_busses[idx]->dev);
+      spi_dev->idx_dev = idx;
+      spi_add_adapter(spi_dev);
+   };
+   kfree(ssc_busses);
+}
+
+static int __init spi_stm_init(void)
+{
+   dev_t ch_device;
+   unsigned int ret;
+   unsigned int num_ssc_bus = ssc_device_available();
+   dgb_print("\n");
+	ret = bus_register(&spi_bus_type);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register spi bus\n");
+		return ret;
+	}
+#ifdef SPI_DRIVER_BUS
+   ret = driver_register(&spi_bus_drv);
+	if (ret) {
+		printk(KERN_WARNING "Unable to register spi driver\n");
+		return ret;
+	}
+#endif
+   spi_stm_adapter_detect();
+
+	ch_device = MKDEV(SPI_MAJOR_NUMBER, 0);
+   register_chrdev_region(ch_device, num_ssc_bus, "spi");
+	cdev_init(&(spi_char_dev), &(spi_stm_fops));
+   cdev_add(&(spi_char_dev), ch_device, num_ssc_bus);
+
+	printk(KERN_INFO "spi /dev layer initialized\n");
+	return 0;
+}
+
+static int __exit spi_stm_exit(void)
+{
+	dev_t ch_device;
+   struct spi_device_t *spi_dev;
+   struct list_head *item;
+
+   ch_device = MKDEV(SPI_MAJOR_NUMBER, 0);
+   dgb_print("\n");
+	cdev_del(&(spi_char_dev));
+	unregister_chrdev_region(ch_device, ssc_device_available());
+/*
+   list_for_each(item,&spi_busses) {
+   spi_dev = container_of(item, struct spi_device_t,list);
+   spi_del_adapter(spi_dev);
+   }
+*/
+   dgb_print("\n");
+
+#if defined(SPI_DRIVER_BUS)
+   driver_unregister(&spi_bus_drv);
+#endif
+	bus_unregister(&spi_bus_type);
+	return 0;
+}
+
+late_initcall(spi_stm_init);
+module_exit(spi_stm_exit);
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("Module for stm spi device");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/stm/stm_spi.h linux-2.6.17.8-sh/drivers/stm/stm_spi.h
--- linux-2.6.17.8/drivers/stm/stm_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm_spi.h	2006-08-23 13:29:41.518668000 +0100
@@ -0,0 +1,48 @@
+/*
+   --------------------------------------------------------------------
+
+   stm_spi.h
+   define and struct for SPI device driver
+   based on STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+#ifndef STM_SPI
+#define STM_SPI
+
+#include "stm_ssc.h"
+#include <linux/device.h>
+
+extern struct bus_type spi_bus_type;
+
+#define SPI_DEV_BUS_ADAPTER      0x01
+#define SPI_DEV_CLIENT_ADAPTER   0x02
+
+struct spi_device_t {
+	unsigned int idx_dev;
+        unsigned int dev_type; /* SPI_DEV_BUS_ADAPTER xor SPI_DEV_CLIENT_ADAPTER*/
+	struct device dev;
+};
+
+#endif
diff -Naur linux-2.6.17.8/drivers/stm/stm_spi_ioctl.h linux-2.6.17.8-sh/drivers/stm/stm_spi_ioctl.h
--- linux-2.6.17.8/drivers/stm/stm_spi_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm_spi_ioctl.h	2006-08-23 13:29:40.137622000 +0100
@@ -0,0 +1,59 @@
+/*
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef SPI_STM_H
+#define SPI_STM_H 1
+
+/*#include "../../include/linux/ioctl.h"*/
+/*
+ *  The following macro are used for ioctl
+ */
+#define SPI_IOCTL_WIDEFRAME     0x01
+#define SPI_ARG_WIDE_16BITS     0x01
+#define SPI_ARG_WIDE_8BITS      0x00
+
+#define SPI_IOCTL_PHASE         0x02
+#define SPI_ARG_PHASE_HIGH      0x01
+#define SPI_ARG_PHASE_LOW       0x00
+
+#define SPI_IOCTL_POLARITY      0x04
+#define SPI_ARG_POLARITY_HIGH   0x01
+#define SPI_ARG_POLARIT_LOWY    0x00
+
+#define SPI_IOCTL_HEADING       0x08
+#define SPI_ARG_HEADING_MSB     0x01
+#define SPI_ARG_HEADING_LSB     0x00
+
+#define SPI_IOCTL_CSACTIVE      0x10
+#define SPI_ARG_CSACTIVE_HIGH   0x01
+#define SPI_ARG_CSACTIVE_LOW    0x00
+
+#define SPI_IOCTL_BUADRATE      0x20
+
+#define SPI_IOCTL_ADDRESS       0x40
+
+#define SPI_IOCTL_TIMEOUT       0x80
+
+#endif				/* SPI_STM_H */
diff -Naur linux-2.6.17.8/drivers/stm/stm_ssc.c linux-2.6.17.8-sh/drivers/stm/stm_ssc.c
--- linux-2.6.17.8/drivers/stm/stm_ssc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm_ssc.c	2006-08-23 13:29:41.543671000 +0100
@@ -0,0 +1,364 @@
+/*
+   -------------------------------------------------------------------------
+   stm_ssc.c
+   -------------------------------------------------------------------------
+   STMicroelectronics
+
+
+   -------------------------------------------------------------------------
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, wrssc to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
+/* ------------------------------------------------------------------------- */
+
+#include "stm_ssc.h"
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/semaphore.h>
+#include <linux/st_soc.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+#undef dgb_print
+
+#ifdef  CONFIG_STM_SSC_DEBUG
+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define dgb_print(fmt, args...)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528) ||  defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+#define NR_SSC_BUSSES 2
+
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(ARCH_ST200)
+
+#define NR_SSC_BUSSES 3
+
+#else
+#error Need to configure the right SSC number devices on this chip
+#endif
+
+
+/*
+ *  Here we alloc the right number of busses
+ */
+static struct ssc_t ssc_device[NR_SSC_BUSSES];
+
+static struct platform_device *ssc_device_data;
+
+unsigned int ssc_device_available()
+{
+	dgb_print("\n");
+	return ssc_device_data->num_resources / 2;
+}
+
+unsigned int ssc_get_clock()
+{
+	struct plat_ssc_data *info;
+	info = (struct plat_ssc_data *)
+	    (ssc_device_data->dev.platform_data);
+	return info->sscclk;
+}
+
+struct ssc_t *ssc_device_request(unsigned int device_id)
+{
+	dgb_print("\n");
+	if (device_id >= ssc_device_data->num_resources / 2)
+		return NULL;
+
+	return &(ssc_device[device_id]);
+}
+
+unsigned int ssc_capability(unsigned int ssc_id)
+{
+	struct plat_ssc_data *info;
+	dgb_print("\n");
+
+	if (ssc_id >= ssc_device_data->num_resources / 2)
+		return 0;
+
+	info = (struct plat_ssc_data *)
+	    (ssc_device_data->dev.platform_data);
+	return (info->capability >> (2 * ssc_id)) &
+	    (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY);
+}
+
+void ssc_request_bus(struct ssc_t *ssc_bus, void (*irq_function) (void *),
+		     void *irq_data)
+{
+	dgb_print("\n");
+	down(&(ssc_bus->sem_bus));
+	ssc_bus->irq_function = irq_function;
+	ssc_bus->irq_private_data = irq_data;
+}
+
+void ssc_release_bus(struct ssc_t *ssc_bus)
+{
+   dgb_print("\n");
+	ssc_bus->irq_function = NULL;
+	ssc_bus->irq_private_data = NULL;
+	up(&(ssc_bus->sem_bus));
+}
+
+static irqreturn_t ssc_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ssc_t *ssc_bus = (struct ssc *)dev_id;
+	if (ssc_bus->irq_function != NULL)
+		ssc_bus->irq_function(ssc_bus->irq_private_data);
+	return IRQ_HANDLED;
+}
+
+static int __init stm_ssc_probe(struct device *dev)
+{
+   dgb_print("\n");
+	ssc_device_data = to_platform_device(dev);
+
+	if (!ssc_device_data->name ){
+		printk(KERN_ERR
+		       "Device probe failed.  Check your kernel SoC config!!\n");
+	}
+	return 0;
+}
+
+static int stm_ssc_remove(struct device *dev)
+{
+    dgb_print("\n");
+    return 0;
+}
+
+static void stm_ssc_shutdown(struct device *dev)
+{
+    dgb_print("\n");
+    return;
+}
+
+static struct device_driver ssc_driver = {
+	.name = "ssc",
+   .owner = THIS_MODULE,
+	.bus = &platform_bus_type,
+	.probe = stm_ssc_probe,
+   .shutdown = stm_ssc_shutdown,
+   .remove = stm_ssc_remove,
+};
+
+/*
+ * Request the IO memory
+ * Remap   the IO memory
+ * Request the right PIO pins
+ * Request the interrupt line.
+ */
+static int ssc_hw_resrc_init(struct ssc_t *ssc_data)
+{
+	struct resource *res;
+	struct plat_ssc_data *info;
+	struct plat_ssc_pio_t *pio_info;
+	unsigned char pio_bank;
+	unsigned char pio_line;
+
+	dgb_print("\n");
+
+	info = (struct plat_ssc_data *)
+	    (ssc_device_data->dev.platform_data);
+	pio_info = info->pio;
+/*1.    IO Mem*/
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->ssc_id);
+	if (!res) {
+		printk(KERN_ERR
+		       "Error on platform_get_resource mem settings\n");
+		return -ENODEV;
+	}
+	if (!request_mem_region(res->start, res->end - res->start, "ssc")) {
+		printk(KERN_ERR "ERROR: ssc %d Request MEM Region NOT Done\n",
+		       ssc_data->ssc_id);
+		return -ENODEV;
+	}
+	dgb_print("ssc bus %d Request MEM Region Done\n", ssc_data->ssc_id);
+	ssc_data->base = ioremap(res->start, res->end - res->start);
+
+	dgb_print("ssc bus %d Request MEM Region Remapping Done\n",
+		ssc_data->ssc_id);
+/* 2.   Request of PIO pins */
+
+/* 2.1  Pio clock */
+	pio_bank = pio_info[ssc_data->ssc_id].sclbank;
+	pio_line = pio_info[ssc_data->ssc_id].sclpin;
+
+	ssc_data->pio_clk = stpio_request_pin(pio_bank, pio_line,
+					      "ssc clock", STPIO_ALT_BIDIR);
+	if (!ssc_data->pio_clk) {
+		printk(KERN_ERR
+		       "ERROR: ssc bus %d Request PIO clock pins not Done\n",
+		       ssc_data->ssc_id);
+		goto release_mem_region;
+	}
+	dgb_print("ssc bus %d Request Clock: Pin%d[%d] Done\n", ssc_data->ssc_id,
+		pio_bank, pio_line);
+/* 2.2  Pio Data out */
+	pio_bank = pio_info[ssc_data->ssc_id].sdoutbank;
+	pio_line = pio_info[ssc_data->ssc_id].sdoutpin;
+
+	ssc_data->pio_data = stpio_request_pin(pio_bank, pio_line,
+					       "ssc data", STPIO_ALT_BIDIR);
+	if (!ssc_data->pio_data) {
+		printk(KERN_ERR
+		       "ERROR: ssc bus %d Request PIO Data pins not Done\n",
+		       ssc_data->ssc_id);
+		goto release_pio_clk;
+	}
+	dgb_print("ssc bus %d Request Data: Pin%d[%d] Done\n",
+		ssc_data->ssc_id, pio_bank, pio_line);
+
+/* 2.3 Pio Data in */
+	ssc_data->pio_data_in = NULL;
+
+	pio_bank = pio_info[ssc_data->ssc_id].sdinbank;
+	pio_line = pio_info[ssc_data->ssc_id].sdinpin;
+
+	if (pio_bank != 0xff) {
+		ssc_data->pio_data_in =
+		    stpio_request_pin(pio_bank,
+				      pio_line, "ssc data in", STPIO_ALT_BIDIR);
+		if (ssc_data->pio_data_in == NULL) {
+			printk(KERN_ERR
+			       "ERROR: ssc %d Request PIO DataIN pins not Done\n",
+			       ssc_data->ssc_id);
+			goto release_pio_data;
+		}
+		dgb_print("ssc bus %d Request DataIN Pin%d[%d] Done\n",
+			ssc_data->ssc_id, pio_bank, pio_line);
+	}
+	/* 3.  Request of IRQ */
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_IRQ,
+				  ssc_data->ssc_id);
+	if (!res) {
+		printk(KERN_ERR
+		       "Error on platform_get_resource irq settings\n");
+		goto release_pio_data_in;
+	}
+	if (request_irq(res->start, ssc_handler, SA_INTERRUPT, "ssc",
+			ssc_data) < 0) {
+		printk(KERN_ERR "ERROR: ssc bus %d Request IRQ NOT Done\n",
+		       ssc_data->ssc_id);
+		goto release_pio_data_in;
+	}
+	dgb_print("ssc bus %d Request IRQ %d Done\n",
+		ssc_data->ssc_id, res->start);
+        ssc_data->dev.driver = &ssc_driver;
+	ssc_data->dev.parent = &platform_bus ;
+        sprintf(ssc_data->dev.bus_id, "ssc-%d", ssc_data->ssc_id);
+	if ( device_register(&ssc_data->dev)<0){
+           printk(KERN_ERR "ERROR: Incapable to register ssc device\n");
+           goto release_irq;
+        }
+	return 0;
+      release_irq:
+        free_irq(res->start, ssc_handler);
+      release_pio_data_in:
+	if (ssc_data->pio_data_in != NULL)
+		stpio_free_pin(ssc_data->pio_data_in);
+      release_pio_data:
+	stpio_free_pin(ssc_data->pio_data);
+      release_pio_clk:
+	stpio_free_pin(ssc_data->pio_clk);
+      release_mem_region:
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->ssc_id);
+
+	release_mem_region(res->start, res->end - res->start);
+
+	return -ENODEV;
+}
+
+static void ssc_hw_release(struct ssc_t *ssc_data)
+{
+	struct resource *res;
+	dgb_print("\n");
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_MEM,
+				  ssc_data->ssc_id);
+
+	release_mem_region(res->start, res->end - res->start);
+
+	res =
+	    platform_get_resource(ssc_device_data, IORESOURCE_IRQ,
+				  ssc_data->ssc_id);
+	free_irq(res->start, ssc_data);
+
+	stpio_free_pin(ssc_data->pio_data);
+	stpio_free_pin(ssc_data->pio_clk);
+	if (!(ssc_data->pio_data_in))
+		stpio_free_pin(ssc_data->pio_data_in);
+}
+
+static int __init ssc_bus_init(void)
+{
+	unsigned int index;
+	struct ssc_t *pssc_bus;
+        dgb_print("\n");
+	driver_register(&ssc_driver);
+	dgb_print("ssc driver registered\n");
+	if (!ssc_device_data) {
+		printk(KERN_ERR "Error on ssc platform settings\n");
+		return -ENODEV;
+	}
+	for (index = 0; index < (ssc_device_data->num_resources) / 2; ++index) {
+		pssc_bus = &(ssc_device[index]);
+		pssc_bus->ssc_id = index;
+		init_MUTEX(&(pssc_bus->sem_bus));
+		init_waitqueue_head(&(pssc_bus->wait_queue));
+		ssc_hw_resrc_init(pssc_bus);
+	}
+	printk(KERN_INFO "stssc layer initialized\n");
+	return 0;
+}
+
+static void __exit ssc_bus_exit(void)
+{
+	unsigned int index;
+
+	dgb_print("\n");
+
+	if (!ssc_device_data)
+		return;
+	for (index = 0; index < (ssc_device_data->num_resources) / 2; ++index) {
+		ssc_hw_release(&(ssc_device[index]));
+	}
+}
+
+/*
+ * If modules is NOT defined when this file is compiled, then the MODULE_*
+ * macros will resolve to nothing
+ */
+
+MODULE_AUTHOR("STMicroelectronics  <www.st.com>");
+MODULE_DESCRIPTION("stssc bus adapter routines for ssc device");
+MODULE_LICENSE("GPL");
+
+/* Called when module is loaded or when kernel is initialized.
+ * If MODULES is defined when this file is compiled, then this function will
+ * resolve to init_module (the function called when insmod is invoked for a
+ * module).  Otherwise, this function is called early in the boot, when the
+ * kernel is intialized
+ */
+
+module_init(ssc_bus_init);
+
+module_exit(ssc_bus_exit);
diff -Naur linux-2.6.17.8/drivers/stm/stm_ssc.h linux-2.6.17.8-sh/drivers/stm/stm_ssc.h
--- linux-2.6.17.8/drivers/stm/stm_ssc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/stm/stm_ssc.h	2006-08-23 13:29:41.551668000 +0100
@@ -0,0 +1,214 @@
+/*
+   --------------------------------------------------------------------
+
+   stm_ssc.h
+   define and struct for STMicroelectronics SSC device
+
+   --------------------------------------------------------------------
+
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef STM_SSC_H
+#define STM_SSC_H 1
+
+#include <linux/device.h>
+#include <linux/wait.h>
+#include <linux/stpio.h>
+#include <asm/semaphore.h>
+#include <asm/io.h>
+
+
+/* SSC Baud Rate generator */
+#define SSC_BRG                  0x0
+/* SSC Transmitter Buffer  */
+#define SSC_TBUF                 0x4
+/* SSC Receive Buffer      */
+#define SSC_RBUF                 0x8
+/*SSC Control              */
+#define SSC_CTL                  0xC
+#define SSC_CTL_DATA_WIDTH_9     0x8
+#define SSC_CTL_BM               0xf
+#define SSC_CTL_HB               0x10
+#define SSC_CTL_PH               0x20
+#define SSC_CTL_PO		 0x40
+#define SSC_CTL_SR		 0x80
+#define SSC_CTL_MS		 0x100
+#define SSC_CTL_EN		 0x200
+#define SSC_CTL_LPB		 0x400
+/* SSC Interrupt Enable */
+#define SSC_IEN               	0x10
+#define SSC_IEN_RIEN		0x1
+#define SSC_IEN_TIEN		0x2
+#define SSC_IEN_TEEN		0x4
+#define SSC_IEN_REEN		0x8
+#define SSC_IEN_PEEN		0x10
+#define SSC_IEN_AASEN		0x40
+#define SSC_IEN_STOPEN		0x80
+#define SSC_IEN_ARBLEN		0x100
+#define SSC_IEN_NACKEN		0x400
+#define SSC_IEN_REPSTRTEN	0x800
+/* SSC Status */
+#define SSC_STA                   0x14
+#define SSC_STA_RIR		  0x1
+#define SSC_STA_TIR		  0x2
+#define SSC_STA_TE		  0x4
+#define SSC_STA_RE		  0x8
+#define SSC_STA_PE		 0x10
+#define SSC_STA_CLST		 0x20
+#define SSC_STA_AAS		 0x40
+#define SSC_STA_STOP		 0x80
+#define SSC_STA_ARBL		0x100
+#define SSC_STA_BUSY		0x200
+#define SSC_STA_NACK		0x400
+#define SSC_STA_REPSTRT		0x800
+/*SSC I2C Control */
+#define SSC_I2C               	0x18
+#define SSC_I2C_I2CM		0x1
+#define SSC_I2C_STRTG		0x2
+#define SSC_I2C_STOPG		0x4
+#define SSC_I2C_ACKG		0x8
+#define SSC_I2C_AD10		0x10
+#define SSC_I2C_TXENB		0x20
+#define SSC_I2C_REPSTRTG	0x800
+#define SSC_I2C_I2CFSMODE	0x1000
+/* SSC Slave Address */
+#define SSC_SLAD              	0x1C
+/* SSC I2C bus repeated start hold time */
+#define SSC_REP_START_HOLD    	0x20
+/* SSC I2C bus start hold time */
+#define SSC_START_HOLD        	0x24
+/* SSC I2C bus repeated start setup time */
+#define SSC_REP_START_SETUP   	 0x28
+/* SSC I2C bus repeated stop setup time */
+#define SSC_DATA_SETUP		0x2C
+/* SSC I2C bus stop setup time */
+#define SSC_STOP_SETUP		0x30
+/* SSC I2C bus free time */
+#define SSC_BUS_FREE		0x34
+
+/* SSC Tx FIFO Status */
+#define SSC_TX_FSTAT            0x38
+#define SSC_TX_FSTAT_STATUS     0x07
+
+/* SSC Rx FIFO Status */
+#define SSC_RX_FSTAT            0x3C
+#define SSC_RX_FSTAT_STATUS     0x07
+
+/* SSC Prescaler value value for clock */
+#define SSC_PRE_SCALER_BRG      0x40
+
+/* SSC Clear bit operation */
+#define SSC_CLR			0x80
+#define SSC_CLR_SSCAAS 		0x40
+#define SSC_CLR_SSCSTOP 	0x80
+#define SSC_CLR_SSCARBL 	0x100
+#define SSC_CLR_NACK    	0x400
+#define SSC_CLR_REPSTRT     	0x800
+
+/* SSC Noise suppression Width */
+#define SSC_AGFR		0x100
+/* SSC Clock Prescaler */
+#define SSC_PRSC		0x104
+#define SSC_PRSC_VALUE          0x0f
+
+
+#define SSC_TXFIFO_SIZE         0x7
+#define SSC_RXFIFO_SIZE         0x7
+/*
+ * The I2C timing register could be ready
+ * for normal or fast rate
+ */
+#define SSC_I2C_READY_NORMAL    0x0
+#define SSC_I2C_READY_FAST      0x1
+struct ssc_t {
+	unsigned int ssc_id;
+	struct stpio_pin *pio_clk;
+	struct stpio_pin *pio_data;
+	struct stpio_pin *pio_data_in;
+	wait_queue_head_t wait_queue;
+	struct semaphore sem_bus;
+	void *base;
+	void (*irq_function) (void *);
+	void *irq_private_data;
+        unsigned char    i2c_timing;
+        struct device dev;
+};
+
+struct ssc_t *ssc_device_request(unsigned int ssc_id);
+
+/*
+ *  How many ssc device are available on this platform
+ */
+unsigned int ssc_device_available(void);
+
+/*
+ *  The input clock for each SSC device
+ */
+
+unsigned int ssc_get_clock(void);
+
+/*
+ *  To say if the ssc_is ssc can support I2C and/or SPI protocol
+ */
+
+#define SSC_I2C_CAPABILITY  0x1
+#define SSC_SPI_CAPABILITY  0x2
+
+unsigned int ssc_capability(unsigned int ssc_id);
+/*
+ *   To request the bus access
+ *   The user registers also the function and the data that
+ *   they want use in the IRQ_Function
+ */
+void ssc_request_bus(struct ssc_t *, void (*irq_function) (void *),
+		     void *irq_data);
+
+/*
+ *   To release the bus
+ */
+void ssc_release_bus(struct ssc_t *);
+
+/*
+   we have to use the following macro
+   to access the SSC I/O Memory
+*/
+#define ssc_store16(ssc , offset, value) iowrite16(value,ssc->base+offset)
+#define ssc_store8( ssc , offset, value) iowrite8( value,ssc->base+offset)
+
+#define ssc_load16( ssc,offset)          ioread16(ssc->base+offset)
+#define ssc_load8(  ssc,offset)	         ioread8( ssc->base+offset)
+
+/*
+ *   This macro could be used to built the capability field
+ *   of struct plat_ssc_data for each SoC
+ */
+#define ssc_ability(idx_ssc, cap)  \
+         ( cap & (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY ) ) << (idx_ssc*2)
+
+#define ssc0_ability(cap)  ssc_ability(0,cap)
+#define ssc1_ability(cap)  ssc_ability(1,cap)
+#define ssc2_ability(cap)  ssc_ability(2,cap)
+#define ssc3_ability(cap)  ssc_ability(3,cap)
+#define ssc4_ability(cap)  ssc_ability(4,cap)
+
+#endif				/* STM_SSC_H */
diff -Naur linux-2.6.17.8/drivers/usb/host/ehci-hcd.c linux-2.6.17.8-sh/drivers/usb/host/ehci-hcd.c
--- linux-2.6.17.8/drivers/usb/host/ehci-hcd.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ehci-hcd.c	2006-08-23 13:29:44.345737000 +0100
@@ -110,7 +110,13 @@
 #define	EHCI_TUNE_RL_TT		0
 #define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
 #define	EHCI_TUNE_MULT_TT	1
+
+#ifdef  CONFIG_USB_ST_SOF_WORKAROUND
+/* Large frame schedule to give greatest interval between interrupts */
+#define	EHCI_TUNE_FLS		0
+#else
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+#endif
 
 #define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
@@ -127,7 +133,11 @@
 module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
+#ifdef CONFIG_USB_ST_SOF_WORKAROUND
+#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT | STS_FLR)
+#else
 #define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -902,6 +912,11 @@
 #define	EHCI_BUS_GLUED
 #endif
 
+#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#include "ehci-stcore.c"
+#define	EHCI_BUS_GLUED
+#endif
+
 #ifndef	EHCI_BUS_GLUED
 #error "missing bus glue for ehci-hcd"
 #endif
diff -Naur linux-2.6.17.8/drivers/usb/host/ehci-stcore.c linux-2.6.17.8-sh/drivers/usb/host/ehci-stcore.c
--- linux-2.6.17.8/drivers/usb/host/ehci-stcore.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ehci-stcore.c	2006-08-23 13:29:51.019875000 +0100
@@ -0,0 +1,245 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * PCI Bus Glue
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#include "stb7100-common.h"
+
+static void usb_clear_irq(void)
+{
+}
+
+static void ST40_stop_host_control(void)
+{
+}
+
+#ifdef CONFIG_USB_ST_SOF_WORKAROUND
+
+#define SOF_LOOP_COUNT 1000000 /* Paranoia, in case we get stuck */
+
+static void ehci_sof_workaround(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
+	u32 status;
+	u32 schedules;
+	u32 cmd;
+	u32 loop;
+
+	status = readl (&ehci->regs->status) & INTR_MASK;
+
+	/* If it's not a frame counter wrap, do nothing */
+	if(!(status & STS_FLR)) return;
+
+	schedules = readl(&ehci->regs->command) & (CMD_PSE|CMD_ASE);
+
+	/* Stop the controller */
+	cmd=readl(&ehci->regs->command) & ~CMD_RUN;
+	writel(cmd,&ehci->regs->command);
+
+	/* Spin till we stop */
+	loop=0;
+	while(!(readl(&ehci->regs->status)&STS_HALT) && (++loop<SOF_LOOP_COUNT));
+
+	if(loop>=SOF_LOOP_COUNT) {
+		printk("USB SOF WORKAROUND - STS_HALT loop timed out\n");
+	}
+
+	usb_hcd_st40_wait_irq();
+
+	/* Reset the frame counter. Not supposed to reset to zero */
+	writel(6,&ehci->regs->frame_index);
+
+	/* Restart the controller, but not the schedules */
+	cmd=(readl(&ehci->regs->command) & ~(CMD_PSE|CMD_ASE)) | CMD_RUN;
+	writel(cmd,&ehci->regs->command);
+
+	/* Wait for the frame index to go up to resync */
+	/* Should be generating empty frames */
+	loop=0;
+	while(readl(&ehci->regs->frame_index)<=9 && (++loop<SOF_LOOP_COUNT));
+
+	if(loop>=SOF_LOOP_COUNT) {
+		printk("USB SOF WORKAROUND - FRAME_INDEX loop timed out\n");
+	}
+
+	/* Restart the schedules */
+	writel(cmd|schedules,&ehci->regs->command);
+}
+#else
+
+static void ehci_sof_workaround(struct usb_hcd *hcd)
+{}
+
+#endif
+
+static irqreturn_t ehci_st40_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+{
+	irqreturn_t retval;
+
+	usb_hcd_st40_wait_irq();
+	ehci_sof_workaround(hcd);
+	retval = ehci_irq(hcd, regs);
+	usb_clear_irq();
+
+	return retval;
+}
+
+static const struct hc_driver ehci_st40_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "ST EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_st40_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_init,
+	.start = ehci_run,
+#ifdef	CONFIG_PM
+	.suspend = ehci_bus_suspend,
+	.resume = ehci_bus_resume,
+#endif
+	.stop = ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+};
+
+static void ehci_hcd_st40_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	ST40_stop_host_control();
+}
+
+static int ehci_hcd_st40_probe(const struct hc_driver *driver,
+			       struct usb_hcd **hcd_out,
+			       struct platform_device *dev)
+{
+	int retval = 0;
+	struct usb_hcd *hcd;
+        struct ehci_hcd *ehci;
+
+	ST40_start_host_control(dev);
+
+	hcd = usb_create_hcd(driver, &dev->dev, "STB7100_EHCI");
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+        ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize PCI reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	retval=usb_add_hcd(hcd, dev->resource[1].start, SA_SHIRQ);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	ST40_stop_host_control();
+	return retval;
+}
+
+static int ehci_hcd_st40_driver_probe(struct device *dev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret = 0;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = ehci_hcd_st40_probe(&ehci_st40_hc_driver, &hcd, pdev);
+	if (ret == 0)
+		dev_set_drvdata(dev, hcd);
+
+	return ret;
+}
+
+static int ehci_hcd_st40_driver_remove(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+
+	ehci_hcd_st40_remove(hcd, pdev);
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+
+}
+
+static struct device_driver ehci_hcd_st40_driver = {
+	.name = "ST40-ehci",
+	.bus = &platform_bus_type,
+	.probe = ehci_hcd_st40_driver_probe,
+	.remove = ehci_hcd_st40_driver_remove,
+};
+
+static int __init ehci_hcd_st40_init(void)
+{
+	return driver_register(&ehci_hcd_st40_driver);
+}
+
+static void __exit ehci_hcd_st40_cleanup(void)
+{
+	driver_unregister(&ehci_hcd_st40_driver);
+}
+
+module_init(ehci_hcd_st40_init);
+module_exit(ehci_hcd_st40_cleanup);
diff -Naur linux-2.6.17.8/drivers/usb/host/Kconfig linux-2.6.17.8-sh/drivers/usb/host/Kconfig
--- linux-2.6.17.8/drivers/usb/host/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/Kconfig	2006-08-23 13:29:44.383737000 +0100
@@ -148,3 +148,25 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called "sl811_cs".
 
+config USB_SM501
+	tristate "USB Host Controller in SM501 support"
+	depends on USB && VOYAGERGX
+	help
+	  Say Y here if you have SM501 USB host controller your system.
+
+	  if you do not know what this is, please say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called SM501.
+
+config USB_ST_SOF_WORKAROUND
+	boolean "ST SOF workaround"
+	depends on USB_EHCI_HCD && CPU_SUBTYPE_STB7100
+	help
+	  Versions of the 7100 prior to cut 3.2 have a silicon problem
+ 	  with USB. There is a bitstuffing error on some SOF packets. This
+	  is a particular problem with SMSC USB hubs, which detect the
+	  erroneous packets. The config option enables a workaround which
+	  should enable at least mass storage devices to function.
+          There will be a performance impact, as it involves stopping the
+	  controller and restarting it periodically.
diff -Naur linux-2.6.17.8/drivers/usb/host/Makefile linux-2.6.17.8-sh/drivers/usb/host/Makefile
--- linux-2.6.17.8/drivers/usb/host/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/Makefile	2006-08-23 13:29:40.771645000 +0100
@@ -15,3 +15,4 @@
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_ETRAX_ARCH_V10)	+= hc_crisv10.o
+obj-$(CONFIG_CPU_SUBTYPE_STB7100)	+= stb7100-common.o
diff -Naur linux-2.6.17.8/drivers/usb/host/ohci-hcd.c linux-2.6.17.8-sh/drivers/usb/host/ohci-hcd.c
--- linux-2.6.17.8/drivers/usb/host/ohci-hcd.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ohci-hcd.c	2006-08-23 13:29:35.393530000 +0100
@@ -878,7 +878,9 @@
 MODULE_DESCRIPTION (DRIVER_INFO);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_SM501
+#include "ohci-voyagergx.c"
+#elif defined(CONFIG_PCI)
 #include "ohci-pci.c"
 #endif
 
@@ -914,6 +916,13 @@
 #include "ohci-at91.c"
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_STI5528) || \
+	defined(CONFIG_CPU_SUBTYPE_STM8000) || \
+	defined(CONFIG_CPU_SUBTYPE_STB7100)
+#include "ohci-stcore.c"
+#endif
+
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_S3C2410) \
@@ -923,6 +932,10 @@
       || defined (CONFIG_SOC_AU1X00) \
       || defined (CONFIG_USB_OHCI_HCD_PPC_SOC) \
       || defined (CONFIG_ARCH_AT91RM9200) \
+      || defined(CONFIG_USB_SM501) \
+      || defined(CONFIG_CPU_SUBTYPE_STI5528) \
+      || defined(CONFIG_CPU_SUBTYPE_STM8000) \
+      || defined(CONFIG_CPU_SUBTYPE_STB7100) \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -Naur linux-2.6.17.8/drivers/usb/host/ohci-stcore.c linux-2.6.17.8-sh/drivers/usb/host/ohci-stcore.c
--- linux-2.6.17.8/drivers/usb/host/ohci-stcore.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ohci-stcore.c	2006-08-23 13:29:51.040875000 +0100
@@ -0,0 +1,308 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2005
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * STMicroelectronics on-chip USB host controller Bus Glue.
+ * Based on the StrongArm ohci-sa1111.c file
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/platform_device.h>
+#include "ohci-stcore.h"
+
+extern int usb_disabled(void);
+
+#if defined (CONFIG_CPU_SUBTYPE_STI5528)
+
+#define DEVICE_NAME "STi5528 OHCI"
+
+static inline void usb_hcd_st40_wait_irq(void)
+{
+}
+
+static int usb_clear_irq(void)
+{
+	writel(0, STBUS_USB_0_STATUS_REG);
+	(void)readl(STBUS_USB_0_STATUS_REG);
+
+	writel(0, STBUS_USB_1_STATUS_REG);
+	(void)readl(STBUS_USB_1_STATUS_REG);
+
+	return 0;
+}
+
+/*
+ * Functions to enable power to the USB ports on the specified host controller,
+ * by writing to the system configuration register. For more details see the
+ * STi5528 datasheet. STBus interrupts for the host controller are enabled.
+ */
+static void ST40_start_host_control(struct platform_device *dev)
+{
+	/* Set power to the port */
+	writel(USB_POWER_ENABLE, SYSTEM_CONFIG10);
+
+	/* Enable the STBus interrupts */
+	writel(0, STBUS_USB_0_STATUS_REG);
+	writel(STBUS_USB_MASK_DEFAULT, STBUS_USB_0_MASK_REG);
+
+	/* Enable the STBus interrupts */
+	writel(0, STBUS_USB_1_STATUS_REG);
+	writel(STBUS_USB_MASK_DEFAULT, STBUS_USB_1_MASK_REG);
+}
+
+static void ST40_stop_host_control(void)
+{
+	unsigned int reg = 0;
+	writel(0, STBUS_USB_0_MASK_REG);
+	writel(0, STBUS_USB_0_STATUS_REG);
+	writel(0, STBUS_USB_1_MASK_REG);
+	writel(0, STBUS_USB_1_STATUS_REG);
+
+	/* Clear power to the port */
+	reg = readl(SYSTEM_CONFIG10);
+	writel(SYSTEM_CONFIG10, (reg & ~USB_POWER_ENABLE));
+}
+
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+#define DEVICE_NAME "STm8000 OHCI"
+
+static inline void usb_hcd_st40_wait_irq(void)
+{
+}
+
+static void usb_clear_irq(void)
+{
+	writel(0, STBUS_USB_STATUS_REG);
+	(void)readl(STBUS_USB_STATUS_REG);
+}
+
+static void ST40_start_host_control(struct platform_device *dev)
+{
+
+	/* Set RESET_N1 bit to Low to start clk2 */
+	writel(0x06000000, FS_CONFIG_CLK_3);
+	/*
+	 * Bit [1:0] NDIV = 00 ) => I/P 27MHz, Int Ref 27MHz
+	 * Bit 2 SELF27   = 1  )
+	 * Bit 3 POFF     = 0 => Analog power on
+	 * Bit 4 CLK_SEL  = 0 => Clock A
+	 * Bits [31:5] Reserved
+	 */
+	writel(0x04, FS_CONFIG_GENERIC_INFO);
+
+	/* Use clk3 for USB */
+	/* Configure registers to give a clock of 48MHz */
+	/*
+	 * Bit [4:0]     MD = 0x11   => -15
+	 * Bit [20:5]    PE = 0x3E8  => 1000
+	 * Bit 21        EN_PRG  = 1 => Enable Prog
+	 * Bit [24:22]   SDIV = 010  => 8
+	 * Bit 25        SEL_OUT = 1 => Enable Clock Output
+	 * Bit 26        EXT_CLK = 1 =>
+	 * Bit 27        RESET_N = 1 => Not reset
+	 * Bit [31:28]   Reserved
+	 This magic is from verification but this explaination taken from
+	 the 2.4 kernel
+	 */
+	writel(0x0ea03e91, FS_CONFIG_CLK_3);
+
+	writel(STBUS_USB_MASK_DEFAULT, STBUS_USB_MASK_REG);
+}
+
+static void ST40_stop_host_control(void)
+{
+	writel(0, STBUS_USB_MASK_REG);
+	writel(0, STBUS_USB_STATUS_REG);
+}
+
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+
+#define DEVICE_NAME "STB7100 OHCI"
+#include "stb7100-common.h"
+
+static void usb_clear_irq(void)
+{
+}
+
+static void ST40_stop_host_control(void)
+{
+}
+#else
+#error Unknown platform
+#endif
+
+static irqreturn_t ohci_st40_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+{
+	irqreturn_t retval;
+
+	usb_hcd_st40_wait_irq();
+	retval = ohci_irq(hcd, regs);
+	usb_clear_irq();
+
+	return retval;
+}
+
+static void
+ohci_hcd_st40_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	ST40_stop_host_control();
+}
+
+static int
+ohci_st40_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret = 0;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver ohci_st40_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		DEVICE_NAME,
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/* generic hardware linkage */
+	.irq =			ohci_st40_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/* basic lifecycle operations */
+	.start =		ohci_st40_start,
+#ifdef	CONFIG_PM
+	.suspend =		ohci_st40_suspend,
+	.resume =		ohci_st40_resume,
+#endif
+	.stop =			ohci_stop,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number =	ohci_get_frame,
+
+	/* root hub support */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_USB_SUSPEND
+/* note we don't export these funcs for our ohci*/
+/*	.hub_suspend =		ohci_hub_suspend,*/
+/*	.hub_resume =		ohci_hub_resume,*/
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+static int ohci_hcd_st40_probe(const struct hc_driver *driver,
+			       struct usb_hcd **hcd_out,
+			       struct platform_device *dev)
+{
+	struct usb_hcd *hcd;
+	int retval;
+
+	ST40_start_host_control(dev);
+
+	hcd = usb_create_hcd(driver, &dev->dev, DEVICE_NAME);
+	if (!hcd) {
+		pr_debug("hcd_create_hcd failed");
+		retval = -ENOMEM;
+		goto err0;
+	}
+
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,	hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, SA_INTERRUPT);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+err0:
+	ST40_stop_host_control();
+	return retval;
+}
+
+static int ohci_hcd_st40_drv_probe(struct device *dev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = ohci_hcd_st40_probe(&ohci_st40_hc_driver, &hcd, pdev);
+	if (ret == 0)
+		dev_set_drvdata(dev, hcd);
+
+	return ret;
+}
+
+static int ohci_hcd_st40_drv_remove(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+
+	ohci_hcd_st40_remove(hcd, pdev);
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+static struct device_driver ohci_hcd_st40_driver = {
+	.name = "ST40-ohci",
+	.bus = &platform_bus_type,
+	.probe = ohci_hcd_st40_drv_probe,
+	.remove = ohci_hcd_st40_drv_remove,
+};
+
+static int __init ohci_hcd_st40_init(void)
+{
+	printk(DRIVER_INFO " (ST40)\n");
+	return driver_register(&ohci_hcd_st40_driver);
+}
+
+static void __exit ohci_hcd_st40_cleanup(void)
+{
+	driver_unregister(&ohci_hcd_st40_driver);
+}
+
+module_init(ohci_hcd_st40_init);
+module_exit(ohci_hcd_st40_cleanup);
diff -Naur linux-2.6.17.8/drivers/usb/host/ohci-stcore.h linux-2.6.17.8-sh/drivers/usb/host/ohci-stcore.h
--- linux-2.6.17.8/drivers/usb/host/ohci-stcore.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ohci-stcore.h	2006-08-23 13:29:33.174484000 +0100
@@ -0,0 +1,49 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB
+ *
+ * (C) copyright STMicroelectronics 2005
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * STMicroelectronics on-chip USB host controller Bus Glue.
+ * Based on the StrongArm ohci-sa1111.c file
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#ifndef ST40_ASSIST_H
+#define ST40_ASSIST_H
+
+#if defined(CONFIG_CPU_SUBTYPE_STI5528)
+
+	#define CFG_BASE_ADDRESS         0xb9162000
+	#define USB_OHCI_0_BASE          0xb9141000
+	#define USB_OHCI_1_BASE          0xb9142000
+
+	#define STBUS_USB_0_STATUS_REG   (USB_OHCI_0_BASE + 0x58)
+	#define STBUS_USB_1_STATUS_REG   (USB_OHCI_1_BASE + 0x58)
+	#define STBUS_USB_0_MASK_REG     (USB_OHCI_0_BASE + 0x5c)
+	#define STBUS_USB_1_MASK_REG     (USB_OHCI_1_BASE + 0x5c)
+
+	#define SYSTEM_CONFIG10          (CFG_BASE_ADDRESS + 0x58)
+
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+
+	#define USB_OHCI_0_BASE         0xb4400000
+	#define FS_B_BASE              (0xb0420000)
+	#define FS_CONFIG_CLK_3        (FS_B_BASE + 0x18)
+	#define FS_CONFIG_GENERIC_INFO (FS_B_BASE + 0x00)
+
+	#define STBUS_USB_STATUS_REG    (USB_OHCI_0_BASE + 0x58)
+	#define STBUS_USB_MASK_REG      (USB_OHCI_0_BASE + 0x5c)
+#endif
+
+#define INT_RMT_WAKEUP			0x01
+#define INT_BUF_ACCESS			0x02
+#define INT_NEW_FRAME			0x04
+#define INT_GENERAL			0x08
+#define STBUS_USB_MASK_DEFAULT  (INT_RMT_WAKEUP | INT_BUF_ACCESS | INT_GENERAL)
+#define USB_POWER_ENABLE 		((  1 <<4) | ( 1 <<11)) /*power enable usb blk 1/2*/
+
+#endif
+
diff -Naur linux-2.6.17.8/drivers/usb/host/ohci-voyagergx.c linux-2.6.17.8-sh/drivers/usb/host/ohci-voyagergx.c
--- linux-2.6.17.8/drivers/usb/host/ohci-voyagergx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/ohci-voyagergx.c	2006-08-23 13:29:28.048346000 +0100
@@ -0,0 +1,259 @@
+/*
+ * SM501 USB HCD for Linux Version.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright 2003 (c) Lineo uSolutions,Inc.
+ * Copyright 2004 (c) Paul Mundt
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/voyagergx.h>
+
+extern int usb_disabled(void);
+
+static void usb_hcd_voyager_remove(struct usb_hcd *hcd, struct platform_device *pdev);
+static int __devinit ohci_voyager_start(struct usb_hcd *hcd);
+static int __init voyagergx_ohci_init(void);
+static void __exit voyagergx_ohci_exit(void);
+
+/*
+ * VoyagerGX USB, when not used as a PCI device.
+ */
+#define VOYAGER_OHCI_NAME	"voyager-ohci"
+
+static void __init voyagergx_ohci_configure(void)
+{
+	unsigned long val;
+
+        // Power Mode 0 Gate
+        val = inl(POWER_MODE0_GATE);
+        outl((val | POWER_MODE0_GATE_UH), POWER_MODE0_GATE);
+
+	val = inl(POWER_MODE1_GATE);
+        outl((val | POWER_MODE1_GATE_UH), POWER_MODE1_GATE);
+
+        //Miscellaneous USB Clock Selsct
+        val = inl(MISC_CTRL);
+	val &= ~MISC_CTRL_USBCLK_48;
+        outl(val, MISC_CTRL);
+
+        // Interrupt Mask
+        val = inl(VOYAGER_INT_MASK);
+        val |= 0x00000040;
+        outl(val, VOYAGER_INT_MASK);
+}
+
+static int usb_hcd_voyager_probe(const struct hc_driver *driver,
+				 struct platform_device *dev)
+{
+	struct usb_hcd *hcd;
+	struct ohci_hcd *ohci;
+	struct resource *res;
+	int retval, irq;
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res) {
+		err("no IO resources defined");
+		return -ENODEV;
+	}
+	irq = platform_get_irq(dev, 0);
+
+	hcd = usb_create_hcd(driver, &dev->dev, "sm501");
+	if (PTR_ERR(hcd) == 0) {
+		err("usb_create_hcd failed");
+		return -ENOMEM;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (PTR_ERR(hcd->regs) == 0) {
+		err("ioremap failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	ohci = hcd_to_ohci(hcd);
+	ohci_hcd_init(ohci);
+
+	retval = hcd_buffer_create(hcd);
+	if (retval != 0) {
+		err("hcd_buffer_create failed, %d", retval);
+		goto err2;
+	}
+
+	retval = usb_add_hcd(hcd, irq, SA_INTERRUPT);
+	if (!retval)
+		return retval;	/* all done */
+
+	/* error path */
+	hcd_buffer_destroy(hcd);
+err2:
+	iounmap(hcd->regs);
+err1:
+	usb_put_hcd(hcd);
+
+	return retval;
+}
+
+static void usb_hcd_voyager_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	hcd_buffer_destroy(hcd);
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	usb_put_hcd(hcd);
+}
+
+static int __devinit ohci_voyager_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver voyager_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "SM501 OHCI",
+	.hcd_priv_size		= sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ohci_irq,
+	.flags			= HCD_USB11,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start			= ohci_voyager_start,
+	.stop			= ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend 		= ohci_bus_suspend,
+	.bus_resume 		= ohci_bus_resume,
+#endif
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static int usb_hcd_voyager_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_hcd_voyager_probe(&voyager_hc_driver, pdev);
+}
+
+static int usb_hcd_voyager_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_voyager_remove(hcd, pdev);
+
+	return 0;
+}
+
+/*
+ * Driver definitions to register with SH Bus
+ */
+static struct platform_driver usb_hcd_voyager_driver = {
+	.driver	= {
+		.owner	= THIS_MODULE,
+		.name	= VOYAGER_OHCI_NAME,
+	},
+	.probe		= usb_hcd_voyager_drv_probe,
+	.remove		= usb_hcd_voyager_drv_remove,
+};
+
+static struct resource voyager_hcd_res[] = {
+	[0] = {
+		.start	= VOYAGER_USBH_BASE,
+		.end	= VOYAGER_USBH_BASE + 0xfff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= VOYAGER_USBH_IRQ,
+		.end	= VOYAGER_USBH_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usb_hcd_voyager_dev = {
+	.name		= VOYAGER_OHCI_NAME,
+	.id		= 0,
+	.resource	= voyager_hcd_res,
+	.num_resources	= ARRAY_SIZE(voyager_hcd_res),
+};
+
+static int __init voyagergx_ohci_init(void)
+{
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	voyagergx_ohci_configure();
+
+	ret = platform_driver_register(&usb_hcd_voyager_driver);
+	if (ret)
+		return -ENODEV;
+
+	ret = platform_device_register(&usb_hcd_voyager_dev);
+	if (ret) {
+		platform_driver_unregister(&usb_hcd_voyager_driver);
+		return -ENODEV;
+	}
+
+	return ret;
+}
+
+static void __exit voyagergx_ohci_exit(void)
+{
+	platform_device_unregister(&usb_hcd_voyager_dev);
+	platform_driver_unregister(&usb_hcd_voyager_driver);
+}
+
+module_init(voyagergx_ohci_init);
+module_exit(voyagergx_ohci_exit);
diff -Naur linux-2.6.17.8/drivers/usb/host/stb7100-common.c linux-2.6.17.8-sh/drivers/usb/host/stb7100-common.c
--- linux-2.6.17.8/drivers/usb/host/stb7100-common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/stb7100-common.c	2006-08-23 13:29:40.785646000 +0100
@@ -0,0 +1,58 @@
+/*
+ * STb7100 common OHCI/EHCI controller functions.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/device.h>
+#include <linux/stpio.h>
+#include <linux/st_soc.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include "stb7100-common.h"
+
+/*
+ * Set up the USB hardware wrapper
+ */
+void ST40_start_host_control(struct platform_device *dev)
+{
+	unsigned long reg;
+	static int initialised = 0;
+
+	printk("%s\n", __FUNCTION__);
+
+	if (xchg(&initialised, 1))
+		return;
+
+	printk("%s proceeding\n", __FUNCTION__);
+
+	/* Make sure PLL is on */
+	reg = readl(SYS_CFG2);
+	if (reg & SYS_CFG2_PLL_POWER_DOWN_BIT) {
+		writel(reg & (~SYS_CFG2_PLL_POWER_DOWN_BIT), SYS_CFG2);
+		mdelay(100);
+	}
+
+	/* Set 16 bit strap mode */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_16_BIT, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	mdelay(100);
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	mdelay(100);
+
+	/* Set the STBus Opcode Config for 32-bit access */
+	writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+	/* Set the Message Size Config to 64 packets per message */
+	writel(AHB2STBUS_MSGSIZE_64, AHB2STBUS_MSGSIZE);
+
+	/* Set the Chunk Size Config to 64 packets per chunk */
+	writel(AHB2STBUS_CHUNKSIZE_64, AHB2STBUS_CHUNKSIZE);
+}
diff -Naur linux-2.6.17.8/drivers/usb/host/stb7100-common.h linux-2.6.17.8-sh/drivers/usb/host/stb7100-common.h
--- linux-2.6.17.8/drivers/usb/host/stb7100-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/host/stb7100-common.h	2006-08-23 13:29:40.802646000 +0100
@@ -0,0 +1,120 @@
+/*
+ * STb7100 common OHCI/EHCI controller functions.
+ *
+ * Copyright (c) 2005 STMicroelectronics Limited
+ * Author: Mark Glaisher <mark.glaisher@st.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+/*
+ * Some of these register are described in ADCS 7518758.
+ */
+
+/*
+ * Defines for the controller register offsets
+ */
+#define UHOST2C_BASE			0xb9100000
+#define AHB2STBUS_WRAPPER_GLUE_BASE	(UHOST2C_BASE)
+#define AHB2STBUS_RESERVED1_BASE	(UHOST2C_BASE + 0x000e0000)
+#define AHB2STBUS_RESERVED2_BASE	(UHOST2C_BASE + 0x000f0000)
+#define AHB2STBUS_OHCI_BASE		(UHOST2C_BASE + 0x000ffc00)
+#define AHB2STBUS_EHCI_BASE		(UHOST2C_BASE + 0x000ffe00)
+#define AHB2STBUS_PROTOCOL_BASE		(UHOST2C_BASE + 0x000fff00)
+
+/* The transaction opcode is programmed in this register */
+#define AHB2STBUS_STBUS_OPC		(AHB2STBUS_PROTOCOL_BASE + 0x00)
+#define AHB2STBUS_STBUS_OPC_4BIT	0x00
+#define AHB2STBUS_STBUS_OPC_8BIT	0x01
+#define AHB2STBUS_STBUS_OPC_16BIT	0x02
+#define AHB2STBUS_STBUS_OPC_32BIT	0x03
+#define AHB2STBUS_STBUS_OPC_64BIT	0x04
+
+/* The message length in number of packets is programmed in this register. */
+#define AHB2STBUS_MSGSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x04)
+#define AHB2STBUS_MSGSIZE_DISABLE	0x0
+#define AHB2STBUS_MSGSIZE_2		0x1
+#define AHB2STBUS_MSGSIZE_4		0x2
+#define AHB2STBUS_MSGSIZE_8		0x3
+#define AHB2STBUS_MSGSIZE_16		0x4
+#define AHB2STBUS_MSGSIZE_32		0x5
+#define AHB2STBUS_MSGSIZE_64		0x6
+
+/* The chunk size in number of packets is programmed in this register */
+#define AHB2STBUS_CHUNKSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x08)
+#define AHB2STBUS_CHUNKSIZE_DISABLE	0x0
+#define AHB2STBUS_CHUNKSIZE_2		0x1
+#define AHB2STBUS_CHUNKSIZE_4		0x2
+#define AHB2STBUS_CHUNKSIZE_8		0x3
+#define AHB2STBUS_CHUNKSIZE_16		0x4
+#define AHB2STBUS_CHUNKSIZE_32		0x5
+#define AHB2STBUS_CHUNKSIZE_64		0x6
+
+/* This register holds the timeout value in number of STBus clock cycles */
+#define AHB2STBUS_REQ_TIMEOUT		(AHB2STBUS_PROTOCOL_BASE + 0x0c)
+
+/* Undocumented */
+#define AHB2STBUS_PC_STATUS		(AHB2STBUS_PROTOCOL_BASE + 0x10)
+#define AHB2STBUS_PC_STATUS_IDLE	1
+
+
+/* This register implements interrupt status for the OHCI controller */
+#define AHB2STBUS_OHCI_INT_STS		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x08)
+
+/* This register implements interrupt mask for the OHCI controller */
+#define AHB2STBUS_OHCI_INT_MASK		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x0c)
+
+/* This register implements interrupt status for the EHCI controller */
+#define AHB2STBUS_EHCI_INT_STS		(AHB2STBUS_WRAPPER_GLUE_BASE + 0x10)
+
+
+#define AHB2STBUS_STRAP			(AHB2STBUS_WRAPPER_GLUE_BASE + 0x14)
+#define AHB2STBUS_STRAP_PLL		0x08	/* undocumented */
+#define AHB2STBUS_STRAP_16_BIT		0x04	/* ss_word_if */
+
+
+/*
+ * SYSCONF stuff
+ */
+
+#define SYSCONF_BASE			0xb9001000
+#define SYS_CFG2			(SYSCONF_BASE + 0x108)
+#define SYS_CFG2_PLL_POWER_DOWN_BIT	1
+
+static inline void usb_hcd_st40_wait_irq(void)
+{
+	/*
+	 * Fix required to work around a problem which causes controller
+	 * memory writes to be overtaken by interrupt requests.
+	 *
+	 * From the document:
+	 * STBus USB Host 2.0 Controller
+	 * Known Problems and Workaround
+	 *
+	 * 2.1 Interrupt Generation not linked with completed read/write
+	 * on STBUS
+	 *
+	 * This limitation occurs because any writes issued by the AHB
+	 *Master of the Synopsys Controller to the AHB Slave of the
+	 * protocol converter is acknowledged by the STBUS target
+	 * immediately to the AHB Master, before the transfer is
+	 * completed by the STBUS Inititator.This causes the OHCI
+	 * Interrupt to be generated before the transfer is completed
+	 * on the STBUS. This may cause problems when the OHCI ISR
+	 * successfully reads the memory location before the completion
+	 * of the write by the STBUS Initiator of the DUT.
+	 *
+	 * This problems has also been observed in the EHCI controller.
+	 */
+	int count = 0;
+
+	while ((readl(AHB2STBUS_PC_STATUS) & AHB2STBUS_PC_STATUS_IDLE) == 0) {
+		count++;
+		if (count == 100) {
+			warn("OHCI AHB interrupt sync looped too many times");
+			break;
+		}
+	}
+}
+
+void ST40_start_host_control(struct platform_device *dev);
diff -Naur linux-2.6.17.8/drivers/usb/Kconfig linux-2.6.17.8-sh/drivers/usb/Kconfig
--- linux-2.6.17.8/drivers/usb/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/Kconfig	2006-08-23 13:29:35.352530000 +0100
@@ -29,6 +29,11 @@
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
+	# SH:
+	default y if VOYAGERGX
+	default y if CPU_SUBTYPE_STI5528
+	default y if CPU_SUBTYPE_STM8000
+	default y if CPU_SUBTYPE_STB7100
 	# more:
 	default PCI
 
@@ -37,6 +42,7 @@
 	boolean
 	default y if PPC_83xx
 	default y if SOC_AU1200
+	default y if CPU_SUBTYPE_STB7100
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff -Naur linux-2.6.17.8/drivers/usb/net/asix.c linux-2.6.17.8-sh/drivers/usb/net/asix.c
--- linux-2.6.17.8/drivers/usb/net/asix.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/usb/net/asix.c	2006-08-23 13:29:35.612530000 +0100
@@ -328,12 +328,14 @@
 {
 	struct usbnet *dev = netdev_priv(netdev);
 	u16 res;
+	u16* buf = kmalloc(sizeof(u16),GFP_KERNEL);
 
 	asix_set_sw_mii(dev);
-	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
-				(__u16)loc, 2, (u16 *)&res);
+	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, buf);
+	res = *buf;
 	asix_set_hw_mii(dev);
 
+	kfree(buf);
 	return res & 0xffff;
 }
 
@@ -348,11 +350,13 @@
 {
 	struct usbnet *dev = netdev_priv(netdev);
 	u16 res = val;
+	u16 *buf = kmalloc(sizeof(u16),GFP_KERNEL);
 
 	asix_set_sw_mii(dev);
-	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
-				(__u16)loc, 2, (u16 *)&res);
+	*buf = res;
+	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, buf);
 	asix_set_hw_mii(dev);
+	kfree(buf);
 }
 
 /* same as above, but converts new value to le16 byte order before writing */
@@ -406,7 +410,7 @@
 {
 	struct usbnet *dev = netdev_priv(net);
 	u8 opt = 0;
-	u8 buf[1];
+	u8 *buf = kmalloc(sizeof(u8),GFP_KERNEL);
 
 	if (wolinfo->wolopts & WAKE_PHY)
 		opt |= AX_MONITOR_LINK;
@@ -416,9 +420,11 @@
 		opt |= AX_MONITOR_MODE;
 
 	if (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,
-			      opt, 0, 0, &buf) < 0)
+			      opt, 0, 0, &buf[0]) < 0){
+		kfree(&buf[0]);
 		return -EINVAL;
-
+	}
+	kfree(&buf[0]);
 	return 0;
 }
 
diff -Naur linux-2.6.17.8/drivers/video/backlight/hp680_bl.c linux-2.6.17.8-sh/drivers/video/backlight/hp680_bl.c
--- linux-2.6.17.8/drivers/video/backlight/hp680_bl.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/backlight/hp680_bl.c	2006-08-23 13:29:20.962185000 +0100
@@ -20,7 +20,7 @@
 
 #include <asm/cpu/dac.h>
 #include <asm/hp6xx/hp6xx.h>
-#include <asm/hd64461/hd64461.h>
+#include <asm/hd64461.h>
 
 #define HP680_MAX_INTENSITY 255
 #define HP680_DEFAULT_INTENSITY 10
@@ -163,6 +163,6 @@
 module_init(hp680bl_init);
 module_exit(hp680bl_exit);
 
-MODULE_AUTHOR("Andriy Skulysh <askulysh@image.kiev.ua>");
+MODULE_AUTHOR("Andriy Skulysh <askulysh@gmail.com>");
 MODULE_DESCRIPTION("HP Jornada 680 Backlight Driver");
 MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/backlight/Kconfig linux-2.6.17.8-sh/drivers/video/backlight/Kconfig
--- linux-2.6.17.8/drivers/video/backlight/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/backlight/Kconfig	2006-08-23 13:29:12.225001000 +0100
@@ -51,7 +51,7 @@
 	  backlight driver.
 
 config BACKLIGHT_HP680
-	tristate "HP Jornada 680 Backlight Driver"
+	tristate "HP Jornada 680 Backlight Driver "
 	depends on BACKLIGHT_DEVICE && SH_HP6XX
 	default y
 	help
diff -Naur linux-2.6.17.8/drivers/video/console/Kconfig linux-2.6.17.8-sh/drivers/video/console/Kconfig
--- linux-2.6.17.8/drivers/video/console/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/console/Kconfig	2006-08-23 13:29:10.463955000 +0100
@@ -6,7 +6,7 @@
 
 config VGA_CONSOLE
 	bool "VGA text console" if EMBEDDED || !X86
-	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && !ARCH_VERSATILE
+	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && !ARCH_VERSATILE && !SUPERH
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
diff -Naur linux-2.6.17.8/drivers/video/fbmem.c linux-2.6.17.8-sh/drivers/video/fbmem.c
--- linux-2.6.17.8/drivers/video/fbmem.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/fbmem.c	2006-08-23 13:29:35.027508000 +0100
@@ -817,11 +817,16 @@
 
 		if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
 			struct fb_videomode mode;
+			struct fb_var_screeninfo oldvar = info->var;
 			int err = 0;
 
 			info->var = *var;
-			if (info->fbops->fb_set_par)
-				info->fbops->fb_set_par(info);
+			if (info->fbops->fb_set_par) {
+				if((err = info->fbops->fb_set_par(info))) {
+					info->var = oldvar;
+					return err;
+				}
+			}
 
 			fb_pan_display(info, &info->var);
 
diff -Naur linux-2.6.17.8/drivers/video/hitfb.c linux-2.6.17.8-sh/drivers/video/hitfb.c
--- linux-2.6.17.8/drivers/video/hitfb.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/hitfb.c	2006-08-23 13:29:22.018208000 +0100
@@ -4,7 +4,7 @@
  * (C) 1999 Mihai Spatar
  * (C) 2000 YAEGASHI Takeshi
  * (C) 2003, 2004 Paul Mundt
- * (C) 2003, 2004 Andriy Skulysh
+ * (C) 2003, 2004, 2006 Andriy Skulysh
  *
  *  This file is subject to the terms and conditions of the GNU General Public
  *  License. See the file COPYING in the main directory of this archive for
@@ -22,18 +22,16 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/platform_device.h>
 #include <linux/fb.h>
 
 #include <asm/machvec.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
-#include <asm/hd64461/hd64461.h>
-
-#ifdef MACH_HP600
+#include <asm/hd64461.h>
 #include <asm/cpu/dac.h>
 #include <asm/hp6xx/hp6xx.h>
-#endif
 
 #define	WIDTH 640
 
@@ -47,7 +45,6 @@
 static struct fb_fix_screeninfo hitfb_fix __initdata = {
 	.id		= "Hitachi HD64461",
 	.type		= FB_TYPE_PACKED_PIXELS,
-	.ypanstep	= 8,
 	.accel		= FB_ACCEL_NONE,
 };
 
@@ -75,26 +72,14 @@
 	if (truecolor)
 		saddr <<= 1;
 
-	fb_writew(width, HD64461_BBTDWR);
-	fb_writew(height, HD64461_BBTDHR);
+	fb_writew(width-1, HD64461_BBTDWR);
+	fb_writew(height-1, HD64461_BBTDHR);
 
 	fb_writew(saddr & 0xffff, HD64461_BBTDSARL);
 	fb_writew(saddr >> 16, HD64461_BBTDSARH);
 
 }
 
-static inline void hitfb_accel_solidfill(int truecolor, u16 dx, u16 dy,
-					 u16 width, u16 height, u16 color)
-{
-	hitfb_accel_set_dest(truecolor, dx, dy, width, height);
-
-	fb_writew(0x00f0, HD64461_BBTROPR);
-	fb_writew(16, HD64461_BBTMDR);
-	fb_writew(color, HD64461_GRSCR);
-
-	hitfb_accel_start(truecolor);
-}
-
 static inline void hitfb_accel_bitblt(int truecolor, u16 sx, u16 sy, u16 dx,
 				      u16 dy, u16 width, u16 height, u16 rop,
 				      u32 mask_addr)
@@ -102,6 +87,8 @@
 	u32 saddr, daddr;
 	u32 maddr = 0;
 
+	height--;
+	width--;
 	fb_writew(rop, HD64461_BBTROPR);
 	if ((sy < dy) || ((sy == dy) && (sx <= dx))) {
 		saddr = WIDTH * (sy + height) + sx + width;
@@ -148,6 +135,7 @@
 	if (rect->rop != ROP_COPY)
 		cfb_fillrect(p, rect);
 	else {
+		hitfb_accel_wait();
 		fb_writew(0x00f0, HD64461_BBTROPR);
 		fb_writew(16, HD64461_BBTMDR);
 
@@ -163,16 +151,15 @@
 					     rect->height);
 			hitfb_accel_start(0);
 		}
-		hitfb_accel_wait();
 	}
 }
 
 static void hitfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)
 {
+	hitfb_accel_wait();
 	hitfb_accel_bitblt(p->var.bits_per_pixel == 16, area->sx, area->sy,
 			   area->dx, area->dy, area->width, area->height,
 			   0x00cc, 0);
-	hitfb_accel_wait();
 }
 
 static int hitfb_pan_display(struct fb_var_screeninfo *var,
@@ -184,7 +171,7 @@
 	if (xoffset != 0)
 		return -EINVAL;
 
-	fb_writew(yoffset, HD64461_LCDCBAR);
+	fb_writew((yoffset*info->fix.line_length)>>10, HD64461_LCDCBAR);
 
 	return 0;
 }
@@ -194,12 +181,6 @@
 	unsigned short v;
 
 	if (blank_mode) {
-#ifdef MACH_HP600
-		sh_dac_disable(DAC_LCD_BRIGHTNESS);
-		v = fb_readw(HD64461_GPBDR);
-		v |= HD64461_GPBDR_LCDOFF;
-		fb_writew(v, HD64461_GPBDR);
-#endif
 		v = fb_readw(HD64461_LDR1);
 		v &= ~HD64461_LDR1_DON;
 		fb_writew(v, HD64461_LDR1);
@@ -215,19 +196,18 @@
 		v = fb_readw(HD64461_STBCR);
 		v &= ~HD64461_STBCR_SLCDST;
 		fb_writew(v, HD64461_STBCR);
-#ifdef MACH_HP600
-		sh_dac_enable(DAC_LCD_BRIGHTNESS);
-		v = fb_readw(HD64461_GPBDR);
-		v &= ~HD64461_GPBDR_LCDOFF;
-		fb_writew(v, HD64461_GPBDR);
-#endif
-		v = fb_readw(HD64461_LDR1);
-		v |= HD64461_LDR1_DON;
-		fb_writew(v, HD64461_LDR1);
 
 		v = fb_readw(HD64461_LCDCCR);
-		v &= ~HD64461_LCDCCR_MOFF;
+		v &= ~(HD64461_LCDCCR_MOFF | HD64461_LCDCCR_STREQ);
 		fb_writew(v, HD64461_LCDCCR);
+
+		do {
+		    v = fb_readw(HD64461_LCDCCR);
+		} while(v&HD64461_LCDCCR_STBACK);
+
+		v = fb_readw(HD64461_LDR1);
+		v |= HD64461_LDR1_DON;
+		fb_writew(v, HD64461_LDR1);
 	}
 	return 0;
 }
@@ -235,7 +215,7 @@
 static int hitfb_setcolreg(unsigned regno, unsigned red, unsigned green,
 			   unsigned blue, unsigned transp, struct fb_info *info)
 {
-	if (regno >= info->cmap.len)
+	if (regno >= 256)
 		return 1;
 
 	switch (info->var.bits_per_pixel) {
@@ -246,6 +226,8 @@
 		fb_writew(blue >> 10, HD64461_CPTWDR);
 		break;
 	case 16:
+		if (regno >= 16)
+			return 1;
 		((u32 *) (info->pseudo_palette))[regno] =
 		    ((red & 0xf800)) |
 		    ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
@@ -254,26 +236,113 @@
 	return 0;
 }
 
+static int hitfb_sync(struct fb_info *info)
+{
+	hitfb_accel_wait();
+
+	return 0;
+}
+
+static int hitfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int maxy;
+
+	var->xres = info->var.xres;
+	var->xres_virtual = info->var.xres;
+	var->yres = info->var.yres;
+
+	if ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16))
+		var->bits_per_pixel = info->var.bits_per_pixel;
+
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	maxy = info->fix.smem_len / var->xres;
+
+	if (var->bits_per_pixel == 16)
+		maxy /= 2;
+
+	if (var->yres_virtual > maxy)
+		var->yres_virtual = maxy;
+
+	var->xoffset = 0;
+	var->yoffset = 0;
+
+	switch (var->bits_per_pixel) {
+	case 8:
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 16:		/* RGB 565 */
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int hitfb_set_par(struct fb_info *info)
+{
+	unsigned short ldr3;
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		info->fix.line_length = info->var.xres;
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		info->fix.ypanstep = 16;
+		break;
+	case 16:
+		info->fix.line_length = info->var.xres*2;
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		info->fix.ypanstep = 8;
+		break;
+	}
+
+	fb_writew(info->fix.line_length, HD64461_LCDCLOR);
+	ldr3 = fb_readw(HD64461_LDR3);
+	ldr3 &= ~15;
+	ldr3 |= (info->var.bits_per_pixel == 8) ? 4 : 8;
+	fb_writew(ldr3, HD64461_LDR3);
+	return 0;
+}
+
 static struct fb_ops hitfb_ops = {
 	.owner		= THIS_MODULE,
+	.fb_check_var	= hitfb_check_var,
+	.fb_set_par		= hitfb_set_par,
 	.fb_setcolreg	= hitfb_setcolreg,
 	.fb_blank	= hitfb_blank,
+	.fb_sync	= hitfb_sync,
 	.fb_pan_display = hitfb_pan_display,
 	.fb_fillrect	= hitfb_fillrect,
 	.fb_copyarea	= hitfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
 };
 
-int __init hitfb_init(void)
+static int __init hitfb_probe(struct platform_device *dev)
 {
 	unsigned short lcdclor, ldr3, ldvndr;
-	int size;
 
 	if (fb_get_options("hitfb", NULL))
 		return -ENODEV;
 
+	hitfb_fix.mmio_start = CONFIG_HD64461_IOBASE+0x1000;
+	hitfb_fix.mmio_len = 0x1000;
 	hitfb_fix.smem_start = CONFIG_HD64461_IOBASE + 0x02000000;
-	hitfb_fix.smem_len = (MACH_HP690) ? 1024 * 1024 : 512 * 1024;
+	hitfb_fix.smem_len = 512 * 1024;
 
 	lcdclor = fb_readw(HD64461_LCDCLOR);
 	ldvndr = fb_readw(HD64461_LDVNDR);
@@ -323,12 +392,12 @@
 	fb_info.var = hitfb_var;
 	fb_info.fix = hitfb_fix;
 	fb_info.pseudo_palette = pseudo_palette;
-	fb_info.flags = FBINFO_DEFAULT;
+	fb_info.flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN |
+		FBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;
 
 	fb_info.screen_base = (void *)hitfb_fix.smem_start;
 
-	size = (fb_info.var.bits_per_pixel == 8) ? 256 : 16;
-	fb_alloc_cmap(&fb_info.cmap, size, 0);
+	fb_alloc_cmap(&fb_info.cmap, 256, 0);
 
 	if (register_framebuffer(&fb_info) < 0)
 		return -EINVAL;
@@ -338,9 +407,75 @@
 	return 0;
 }
 
+static int __devexit hitfb_remove(struct platform_device *dev)
+{
+	return unregister_framebuffer(&fb_info);
+}
+
+#ifdef CONFIG_PM
+static int hitfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	u16 v;
+
+	hitfb_blank(1,0);
+	v = fb_readw(HD64461_STBCR);
+	v |= HD64461_STBCR_SLCKE_IST;
+	fb_writew(v, HD64461_STBCR);
+
+	return 0;
+}
+
+static int hitfb_resume(struct platform_device *dev)
+{
+	u16 v;
+
+	v = fb_readw(HD64461_STBCR);
+	v &= ~HD64461_STBCR_SLCKE_OST;
+	msleep(100);
+	v = fb_readw(HD64461_STBCR);
+	v &= ~HD64461_STBCR_SLCKE_IST;
+	fb_writew(v, HD64461_STBCR);
+	hitfb_blank(0,0);
+
+	return 0;
+}
+#endif
+
+static struct platform_driver hitfb_driver = {
+	.probe		= hitfb_probe,
+	.remove		= __devexit_p(hitfb_remove),
+#ifdef CONFIG_PM
+	.suspend	= hitfb_suspend,
+	.resume		= hitfb_resume,
+#endif
+	.driver		= {
+		.name	= "hitfb",
+	},
+};
+
+static struct platform_device hitfb_device = {
+	.name	= "hitfb",
+	.id	= -1,
+};
+
+static int __init hitfb_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&hitfb_driver);
+	if (!ret) {
+		ret = platform_device_register(&hitfb_device);
+		if (ret)
+			platform_driver_unregister(&hitfb_driver);
+	}
+	return ret;
+}
+
+
 static void __exit hitfb_exit(void)
 {
-	unregister_framebuffer(&fb_info);
+	platform_device_unregister(&hitfb_device);
+	platform_driver_unregister(&hitfb_driver);
 }
 
 module_init(hitfb_init);
diff -Naur linux-2.6.17.8/drivers/video/Kconfig linux-2.6.17.8-sh/drivers/video/Kconfig
--- linux-2.6.17.8/drivers/video/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/Kconfig	2006-08-23 13:29:25.243300000 +0100
@@ -151,6 +151,21 @@
 	help
 	  Support the Permedia2 FIFO disconnect feature (see CONFIG_FB_PM2).
 
+config FB_VOYAGER_GX
+	bool "Silicon Motion Voyager GX support"
+	depends on FB && VOYAGERGX
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Say Y to enable support for the Silicon Motion VoyagerGX framebuffer.
+
+config FB_VOYAGER_GX_MP
+	bool "Voyager multi plane support"
+	depends on FB_VOYAGER_GX
+	help
+	  Say Y to enable support VoyagerGX multi plane.
+
 config FB_ARMCLCD
 	tristate "ARM PrimeCell PL110 support"
 	depends on FB && ARM && ARM_AMBA
diff -Naur linux-2.6.17.8/drivers/video/Makefile linux-2.6.17.8-sh/drivers/video/Makefile
--- linux-2.6.17.8/drivers/video/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/Makefile	2006-08-23 13:29:07.990886000 +0100
@@ -38,6 +38,8 @@
 obj-$(CONFIG_FB_KYRO)             += kyro/
 obj-$(CONFIG_FB_SAVAGE)		  += savage/
 obj-$(CONFIG_FB_GEODE)		  += geode/
+obj-$(CONFIG_FB_VOYAGER_GX)	  += voyager/
+
 obj-$(CONFIG_FB_I810)             += vgastate.o
 obj-$(CONFIG_FB_NEOMAGIC)         += neofb.o vgastate.o
 obj-$(CONFIG_FB_VIRGE)            += virgefb.o
diff -Naur linux-2.6.17.8/drivers/video/pvr2fb.c linux-2.6.17.8-sh/drivers/video/pvr2fb.c
--- linux-2.6.17.8/drivers/video/pvr2fb.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/pvr2fb.c	2006-08-23 13:29:20.772185000 +0100
@@ -189,7 +189,7 @@
 static unsigned int is_blanked = 0;		/* Is the screen blanked? */
 
 #ifdef CONFIG_SH_STORE_QUEUES
-static struct sq_mapping *pvr2fb_map;
+static unsigned long pvr2fb_map;
 #endif
 
 #ifdef CONFIG_SH_DMA
@@ -215,15 +215,17 @@
 static int pvr2_init_cable(void);
 static int pvr2_get_param(const struct pvr2_params *p, const char *s,
                             int val, int size);
+#ifdef CONFIG_SH_DMA
 static ssize_t pvr2fb_write(struct file *file, const char *buf,
 			    size_t count, loff_t *ppos);
+#endif
 
 static struct fb_ops pvr2fb_ops = {
-	.owner 		= THIS_MODULE,
-	.fb_setcolreg 	= pvr2fb_setcolreg,
-	.fb_blank 	= pvr2fb_blank,
-	.fb_check_var 	= pvr2fb_check_var,
-	.fb_set_par 	= pvr2fb_set_par,
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= pvr2fb_setcolreg,
+	.fb_blank	= pvr2fb_blank,
+	.fb_check_var	= pvr2fb_check_var,
+	.fb_set_par	= pvr2fb_set_par,
 #ifdef CONFIG_SH_DMA
 	.fb_write	= pvr2fb_write,
 #endif
@@ -785,7 +787,7 @@
 		goto out_err;
 	}
 
-	fb_memset((unsigned long)fb_info->screen_base, 0, pvr2_fix.smem_len);
+	fb_memset(fb_info->screen_base, 0, pvr2_fix.smem_len);
 
 	pvr2_fix.ypanstep	= nopan  ? 0 : 1;
 	pvr2_fix.ywrapstep	= nowrap ? 0 : 1;
@@ -822,7 +824,7 @@
 	       modememused >> 10, (unsigned long)(fb_info->fix.smem_len >> 10));
 	printk("fb%d: Mode %dx%d-%d pitch = %ld cable: %s video output: %s\n", 
 	       fb_info->node, fb_info->var.xres, fb_info->var.yres,
-	       fb_info->var.bits_per_pixel, 
+	       fb_info->var.bits_per_pixel,
 	       get_line_length(fb_info->var.xres, fb_info->var.bits_per_pixel),
 	       (char *)pvr2_get_param(cables, NULL, cable_type, 3),
 	       (char *)pvr2_get_param(outputs, NULL, video_output, 3));
@@ -831,10 +833,10 @@
 	printk(KERN_NOTICE "fb%d: registering with SQ API\n", fb_info->node);
 
 	pvr2fb_map = sq_remap(fb_info->fix.smem_start, fb_info->fix.smem_len,
-			      fb_info->fix.id);
+			      fb_info->fix.id, pgprot_val(PAGE_SHARED));
 
 	printk(KERN_NOTICE "fb%d: Mapped video memory to SQ addr 0x%lx\n",
-	       fb_info->node, pvr2fb_map->sq_addr);
+	       fb_info->node, pvr2fb_map);
 #endif
 
 	return 0;
diff -Naur linux-2.6.17.8/drivers/video/voyager/Makefile linux-2.6.17.8-sh/drivers/video/voyager/Makefile
--- linux-2.6.17.8/drivers/video/voyager/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/Makefile	2006-08-23 13:29:11.387979000 +0100
@@ -0,0 +1,13 @@
+#
+# Makefile for the VoyagerGX framebuffer driver
+#
+
+my-obj-$(CONFIG_FB_VOYAGER_GX_MP)	+= voyager_alphafb.o \
+					   voyager_crtcsrfb.o \
+					   voyager_crtfb.o \
+					   voyager_panelcsrfb.o \
+					   voyager_valphafb.o \
+					   voyager_videofb.o
+
+obj-$(CONFIG_FB_VOYAGER_GX)		+= voyager_gxfb.o $(my-obj-y)
+
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_alphafb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_alphafb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_alphafb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_alphafb.c	2006-08-23 13:29:28.058346000 +0100
@@ -0,0 +1,282 @@
+/*
+ *  linux/drivers/video/voyager_alphafb.c -- voyager alpha frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init4(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+static int  change_mode(struct fb_var_screeninfo *var);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = XRES,
+	.yres = YRES,
+	.xres_virtual = XRES,
+	.yres_virtual = YRES,
+	.bits_per_pixel = BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > XRES || var->yres > YRES
+	    || var->xres_virtual > XRES || var->yres_virtual > YRES
+	    || var->bits_per_pixel != BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres_virtual = XRES;
+	var->yres_virtual = YRES;
+
+	if(change_mode(var) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = XRES*2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+		}
+		else {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= 0x04;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ENABLE_CK) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffff7;
+		}
+		else {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= 0x00000008;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ENABLE_AL) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xefffffff;
+		}
+		else {
+			*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= 0x10000000;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_CHKEY) {
+		*(volatile unsigned long *)(ALPHA_CHROMA_KEY) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_TYPE) {
+		*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffffc;
+		*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= (arg & 0x03);
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ALPHA) {
+		*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xf0ffffff;
+		*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= (arg & 0x0f) << 24;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static void __init voya_hw_init(void)
+{
+	*(volatile unsigned long *)(ALPHA_FB_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP4 & 0x00ffffff);
+	change_mode(&voyafb_var);
+	*(volatile unsigned long *)(ALPHA_CHROMA_KEY) = 0;
+
+	*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffff0;
+	*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) |= 0x01;
+
+}
+
+
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER ALPHA",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	XRES*2,
+	.smem_len =	MAX_FRAMEBUFFER_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX ALPHA framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_ALPHA frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init4(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP4;
+	size = MAX_FRAMEBUFFER_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_FRAMEBUFFER_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+}
+
+
+//------------------------------------------------------------------------------------
+static	int	change_mode(struct fb_var_screeninfo *var)
+{
+int	x,ali;
+
+	if((var->xres < 0)||(var->xres > XRES)||
+	   (var->yres < 0)||(var->yres > YRES)||
+	   (var->xres_virtual < 0)||(var->xres_virtual > XRES)||
+	   (var->yres_virtual < 0)||(var->yres_virtual > YRES)||
+	   (var->xoffset < 0)||(var->xoffset > XRES)||
+	   (var->yoffset < 0)||(var->yoffset > YRES))
+	{
+		return(-1);
+	}
+	x = var->xres_virtual * 2;
+	ali = x + (x % 16);
+	*(volatile unsigned long *)(ALPHA_FB_WIDTH) = (ali << 16) | ali;
+	*(volatile unsigned long *)(ALPHA_PLANE_TL) = (var->yoffset << 16) |
+								  var->xoffset;
+	*(volatile unsigned long *)(ALPHA_PLANE_BR) =
+			((var->yoffset + var->yres - 1) << 16) |
+			 (var->xoffset + var->xres - 1);
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_crtcsrfb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_crtcsrfb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_crtcsrfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_crtcsrfb.c	2006-08-23 13:29:28.068346000 +0100
@@ -0,0 +1,240 @@
+/*
+ *  linux/drivers/video/voyager_crtcsrfb.c -- voyager crt HWC frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init7(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+static int  change_mode(struct fb_var_screeninfo *var);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = CSR_XRES,
+	.yres = CSR_YRES,
+	.xres_virtual = CSR_XRES,
+	.yres_virtual = CSR_YRES,
+	.bits_per_pixel = CSR_BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > CSR_XRES || var->yres > CSR_YRES
+	    || var->xres_virtual > CSR_XRES || var->yres_virtual > CSR_YRES
+	    || var->bits_per_pixel != CSR_BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres = var->xres_virtual = CSR_XRES;
+	var->yres = var->yres_virtual = CSR_YRES;
+	if(change_mode(var) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = CSR_XRES/2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(CRT_HWC_ADDRESS) &= 0x7fffffff;
+		}
+		else {
+			*(volatile unsigned long *)(CRT_HWC_ADDRESS) |= 0x80000000;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_COLOR_1) {
+		*(volatile unsigned long *)(CRT_HWC_COLOR_12) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_COLOR_2) {
+		*(volatile unsigned long *)(CRT_HWC_COLOR_3) = arg;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static void __init voya_hw_init(void)
+{
+	*(volatile unsigned long *)(CRT_HWC_ADDRESS) = (VOY_VRAM_TOP5 & 0x00ffffff);
+	*(volatile unsigned long *)(CRT_HWC_COLOR_12) = 0x5555aaaa;
+	*(volatile unsigned long *)(CRT_HWC_COLOR_3) = 0x0000ffff;
+	change_mode(&voyafb_var);
+}
+
+
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER C_CSR",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	CSR_XRES/2,
+	.smem_len =	MAX_HWC_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX CRT CSR framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_CRT CSR frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init7(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP6;
+	size = MAX_HWC_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_HWC_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(CRT_HWC_ADDRESS) &= 0x7fffffff;
+}
+
+static	int	change_mode(struct fb_var_screeninfo *var)
+{
+	if((var->xoffset < 0)||(var->xoffset > XRES)||
+	   (var->yoffset < 0)||(var->yoffset > YRES))
+	{
+		return(-1);
+	}
+	*(volatile unsigned long *)(CRT_HWC_LOCATION) = (var->yoffset << 16) |
+								      var->xoffset;
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_crtfb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_crtfb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_crtfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_crtfb.c	2006-08-23 13:29:28.075346000 +0100
@@ -0,0 +1,240 @@
+/*
+ *  linux/drivers/video/voyager_crtfb.c -- voyager crt frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init6(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = XRES,
+	.yres = YRES,
+	.xres_virtual = XRES,
+	.yres_virtual = YRES,
+	.bits_per_pixel = BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > XRES || var->yres > YRES
+	    || var->xres_virtual > XRES || var->yres_virtual > YRES
+	    || var->bits_per_pixel != BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres = var->xres_virtual = XRES;
+	var->yres = var->yres_virtual = YRES;
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = XRES*2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffffb;
+		}
+		else {
+			*(volatile unsigned long *)(CRT_DISPLAY_CTRL) |= 0x04;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_TYPE) {
+		*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffffc;
+		*(volatile unsigned long *)(CRT_DISPLAY_CTRL) |= (arg & 0x03);
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_SELECT) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffdff;
+		}
+		else {
+			*(volatile unsigned long *)(CRT_DISPLAY_CTRL) |= 0x00000200;
+		}
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static void __init voya_hw_init(void)
+{
+int	i;
+
+	*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffcf0;
+	*(volatile unsigned long *)(CRT_FB_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP6 & 0x00ffffff);
+	*(volatile unsigned long *)(CRT_FB_WIDTH) = 0x5000500;
+	*(volatile unsigned long *)(CRT_HORIZONTAL_TOTAL) = 0x033f027f;
+	*(volatile unsigned long *)(CRT_HORIZONTAL_SYNC) = 0x4a028b;
+	*(volatile unsigned long *)(CRT_VERTICAL_TOTAL) = 0x20c01df;
+	*(volatile unsigned long *)(CRT_VERTICAL_SYNC) = 0x201e9;
+	*(volatile unsigned long *)(CRT_DISPLAY_CTRL) |= 0x70000105;
+	//palet initialize
+	for(i=0;i<256;i++) {
+		*(volatile unsigned long *)(CRT_PALETTE_RAM+(i*4)) = (i << 16)+(i << 8)+i;
+	}
+}
+
+
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER CRT",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	XRES*2,
+	.smem_len =	MAX_FRAMEBUFFER_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX CRT framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_CRT frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init6(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP6;
+	size = MAX_FRAMEBUFFER_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_FRAMEBUFFER_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffffb;
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_gxfb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_gxfb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_gxfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_gxfb.c	2006-08-23 13:29:28.083346000 +0100
@@ -0,0 +1,441 @@
+/*
+ *  linux/drivers/video/voyager_gxfb.c -- voyager panel frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+#ifdef CONFIG_FB_VOYAGER_GX_MP
+#define	MAX_VRAM	MAX_FRAMEBUFFER_MEM_SIZE
+#else
+#define	MAX_VRAM	1024*768*4
+#endif
+
+#ifdef CONFIG_FB_VOYAGER_GX_MP
+extern int voyafb_init2(void);
+extern int voyafb_init3(void);
+extern int voyafb_init4(void);
+extern int voyafb_init5(void);
+extern int voyafb_init6(void);
+extern int voyafb_init7(void);
+#endif
+
+static struct fb_info voyafb_info;
+
+static int voyafb_init(void);
+static int voyafbmem_init(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+						struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+					u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+				unsigned int, unsigned long, struct fb_info*);
+static int voyafb_pan_display(struct fb_var_screeninfo *var,
+						struct fb_info *info);
+static void vsyncwait(int delay);
+static int change_mode(void);
+
+typedef	struct {
+	__u32	xres;
+	__u32	yres;
+	__u32	clock;
+	__u32	h_total;
+	__u32	h_sync;
+	__u32	v_total;
+	__u32	v_sync;
+} VOYA_CRT_DATA;
+
+static	VOYA_CRT_DATA	clock_data[] = {
+	{ 640, 480, 0x10021801, 0x33f027f, 0x4a028b, 0x20c01df, 0x201e9, },
+	{ 800, 600, 0x023a1801, 0x454031f, 0x9b0350, 0x2730257, 0x40258, },
+	{1024, 768, 0x283a1801, 0x5460400, 0x800438, 0x3340300, 0x3031b, },
+	{-1, -1, -1, -1, -1, -1, -1, },
+};
+static int clock_data_index = 0;
+static int clock_data_bpp = BPP;
+
+static unsigned int pseudo_palette[17];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+	.fb_pan_display = voyafb_pan_display,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = XRES,
+	.yres = YRES,
+	.xres_virtual = XRES,
+	.yres_virtual = YRES,
+	.bits_per_pixel = BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 0,
+	.right_margin = 0,
+	.upper_margin = 0,
+	.lower_margin = 0,
+	.hsync_len = 0,
+	.vsync_len = 0,
+};
+
+static int voyafb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	info->var.xoffset = 0;
+	info->var.yoffset = 0;
+	info->var.vmode &= ~FB_VMODE_YWRAP;
+
+	return 0;
+}
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+#ifndef CONFIG_FB_VOYAGER_GX_MP
+	int	i;
+#endif
+
+#ifdef CONFIG_FB_VOYAGER_GX_MP
+	if (var->xres > XRES || var->yres > YRES
+	    || var->xres_virtual > XRES || var->yres_virtual > YRES
+	    || var->bits_per_pixel != BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres = var->xres_virtual = XRES;
+	var->yres = var->yres_virtual = YRES;
+#else
+	if ((var->bits_per_pixel != 8)  &&
+	    (var->bits_per_pixel != 16) &&
+	    (var->bits_per_pixel != 32))
+		return -EINVAL;
+
+	for (i=0; clock_data[i].xres != -1; i++)
+		if ((clock_data[i].xres == var->xres) &&
+		    (clock_data[i].yres == var->yres))
+			break;
+
+	if (clock_data[i].xres == -1)
+		return -EINVAL;
+
+	clock_data_index = i;
+	clock_data_bpp = var->bits_per_pixel;
+#endif
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+#ifdef CONFIG_FB_VOYAGER_GX_MP
+	info->fix.line_length = XRES * 2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.bits_per_pixel = 16;
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+#else
+	if (clock_data_bpp == 8) {
+		info->fix.line_length = clock_data[clock_data_index].xres;
+		info->var.transp.offset  = 0;
+		info->var.transp.length  = 0;
+		info->var.red.length = info->var.blue.length = info->var.green.length = 8;
+		info->var.red.offset = info->var.blue.offset = info->var.green.offset = 0;
+		info->var.bits_per_pixel = 8;
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	} else if (clock_data_bpp == 16) {
+		info->fix.line_length = clock_data[clock_data_index].xres * 2;
+		info->var.transp.offset  = 0;
+		info->var.transp.length  = 0;
+		info->var.red.length     = 5;
+		info->var.blue.length    = 5;
+		info->var.green.length   = 6;
+		info->var.red.offset     = 11;
+		info->var.green.offset   = 5;
+		info->var.blue.offset    = 0;
+		info->var.bits_per_pixel = 16;
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+	} else {
+		info->fix.line_length = clock_data[clock_data_index].xres * 4;
+		info->var.transp.offset  = 24;
+		info->var.transp.length  = 8;
+		info->var.red.length     = 8;
+		info->var.blue.length    = 8;
+		info->var.green.length   = 8;
+		info->var.red.offset     = 16;
+		info->var.green.offset   = 8;
+		info->var.blue.offset    = 0;
+		info->var.bits_per_pixel = 32;
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+	}
+	change_mode();
+#endif
+
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 0;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	int	*palette;
+
+	if (regno > 256)
+		return 1;
+
+	palette = (int *)PANEL_PALETTE_RAM;
+	palette[regno] = (red & 0xff) << 16 | (green & 0xff) << 8 | (blue & 0xff);
+	((u32 *)(info->pseudo_palette))[regno] = (red & 0xff) << 16 | (green & 0xff) << 8 | (blue & 0xff);
+
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	static	long	*po;
+	int	*wk;
+
+	if (cmd == VOYAGER_IOCTL_DEBUG_ADD) {
+		po = (long *)arg;
+		return 0;
+	} else if (cmd == VOYAGER_IOCTL_DEBUG_GET) {
+		wk = (int *)arg;
+		*wk = *po;
+		return 0;
+	} else if (cmd == VOYAGER_IOCTL_DEBUG_PUT) {
+		*po = arg;
+		return 0;
+	} else if (cmd == VOYAGER_IOCTL_ENABLE) {
+		if (arg == 0)
+			*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) &= 0xfffffffb;
+		else
+			*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x04;
+		return 0;
+	} else if (cmd == VOYAGER_IOCTL_TYPE) {
+		*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) &= 0xfffffffc;
+		*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= (arg & 0x03);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static void __init voya_hw_init(void)
+{
+	int	i;
+
+	//DAC enable
+	*(volatile unsigned long *)(MISC_CTRL) &= 0xffffefff;
+
+	//Power Gate
+	*(volatile unsigned long *)(POWER_MODE0_GATE) |= 0x7f;
+	*(volatile unsigned long *)(POWER_MODE1_GATE) |= 0x7f;
+
+	//Power Clock
+	*(volatile unsigned long *)(POWER_MODE0_CLOCK) = 0x10021801;
+	*(volatile unsigned long *)(POWER_MODE1_CLOCK) = 0x10021801;
+
+	//Power Mode Control
+	*(volatile unsigned long *)(POWER_MODE_CTRL) = 0;
+
+	//Miscellaneous Timing
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) &= 0xfffffffb;
+	*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xfffffffb;
+	*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+	*(volatile unsigned long *)(ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+	*(volatile unsigned long *)(PANEL_HWC_ADDRESS) &= 0x7fffffff;
+	*(volatile unsigned long *)(CRT_DISPLAY_CTRL) &= 0xfffffffb;
+	*(volatile unsigned long *)(CRT_HWC_ADDRESS) &= 0x7fffffff;
+
+	change_mode();
+
+	vsyncwait(4);
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x1000000;
+	vsyncwait(4);
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x3000000;
+	vsyncwait(4);
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x7000000;
+
+	//palet initialize
+	for (i=0; i<256; i++) {
+		*(volatile unsigned long *)(PANEL_PALETTE_RAM+(i*4)) = (i << 16)+(i << 8)+i;
+	}
+}
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER PANEL",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	XRES * (BPP / 8),
+	.smem_len =	MAX_VRAM,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX PANEL framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_PANEL frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+static int __init voyafb_init(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr;
+
+	if (fb_get_options("voyager_panel_fb", NULL))
+		return -ENODEV;
+
+        addr = VOY_VRAM_TOP0;
+	p->screen_base = ioremap((u_long)addr, ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL)
+		return -ENOMEM;
+
+	init_voya(p, addr);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) &= 0xfffffffb;
+}
+
+static int __init voyafbmem_init(void)
+{
+	voyafb_init();
+#ifdef CONFIG_FB_VOYAGER_GX_MP
+	voyafb_init2();
+	voyafb_init3();
+	voyafb_init4();
+	voyafb_init5();
+	voyafb_init6();
+	voyafb_init7();
+#endif
+
+	return 0;
+}
+
+module_init(voyafbmem_init);
+
+static void vsyncwait(int delay)
+{
+	int	reg;
+
+	while(delay-- > 0) {
+		do {
+			reg = *(volatile unsigned long *)(CMD_INTPR_STATUS);
+		} while(reg & 0x1000);
+		do {
+			reg = *(volatile unsigned long *)(CMD_INTPR_STATUS);
+		} while(!reg & 0x1000);
+	}
+}
+
+static int change_mode()
+{
+	int	size,xres,yres;
+
+	xres = clock_data[clock_data_index].xres;
+	yres = clock_data[clock_data_index].yres;
+	size = clock_data_bpp / 8;
+
+	//Power Clock
+	*(volatile unsigned long *)(POWER_MODE0_CLOCK) = clock_data[clock_data_index].clock;
+	*(volatile unsigned long *)(POWER_MODE1_CLOCK) = clock_data[clock_data_index].clock;
+	//PANEL register SET
+	*(volatile unsigned long *)(PANEL_FB_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP0 & 0x00ffffff);
+	*(volatile unsigned long *)(PANEL_FB_WIDTH) = (xres * size) << 16 | (xres * size);
+	*(volatile unsigned long *)(PANEL_WINDOW_WIDTH) = (xres << 16);
+	*(volatile unsigned long *)(PANEL_WINDOW_HEIGHT) = (yres << 16);
+	*(volatile unsigned long *)(PANEL_PLANE_TL) = 0;
+	*(volatile unsigned long *)(PANEL_PLANE_BR) = ((yres-1) << 16) | (xres-1);
+	*(volatile unsigned long *)(PANEL_HORIZONTAL_TOTAL) = clock_data[clock_data_index].h_total;
+	*(volatile unsigned long *)(PANEL_HORIZONTAL_SYNC) = clock_data[clock_data_index].h_sync;
+	*(volatile unsigned long *)(PANEL_VERTICAL_TOTAL) = clock_data[clock_data_index].v_total;
+	*(volatile unsigned long *)(PANEL_VERTICAL_SYNC) = clock_data[clock_data_index].v_sync;
+
+	*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) &= 0xffffcea8;
+	if (size == 1)
+		*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x3104;
+	else if (size == 2)
+		*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x3105;
+	else
+		*(volatile unsigned long *)(PANEL_DISPLAY_CTRL) |= 0x3106;
+
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_panelcsrfb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_panelcsrfb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_panelcsrfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_panelcsrfb.c	2006-08-23 13:29:28.090346000 +0100
@@ -0,0 +1,240 @@
+/*
+ *  linux/drivers/video/voyager_panelcsrfb.c -- voyager panel HWC frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init5(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+static int  change_mode(struct fb_var_screeninfo *var);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = CSR_XRES,
+	.yres = CSR_YRES,
+	.xres_virtual = CSR_XRES,
+	.yres_virtual = CSR_YRES,
+	.bits_per_pixel = CSR_BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > CSR_XRES || var->yres > CSR_YRES
+	    || var->xres_virtual > CSR_XRES || var->yres_virtual > CSR_YRES
+	    || var->bits_per_pixel != CSR_BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres = var->xres_virtual = CSR_XRES;
+	var->yres = var->yres_virtual = CSR_YRES;
+	if(change_mode(var) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = CSR_XRES/2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(PANEL_HWC_ADDRESS) &= 0x7fffffff;
+		}
+		else {
+			*(volatile unsigned long *)(PANEL_HWC_ADDRESS) |= 0x80000000;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_COLOR_1) {
+		*(volatile unsigned long *)(PANEL_HWC_COLOR_12) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_COLOR_2) {
+		*(volatile unsigned long *)(PANEL_HWC_COLOR_3) = arg;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static void __init voya_hw_init(void)
+{
+	*(volatile unsigned long *)(PANEL_HWC_ADDRESS) = (VOY_VRAM_TOP5 & 0x00ffffff);
+	*(volatile unsigned long *)(PANEL_HWC_COLOR_12) = 0x5555aaaa;
+	*(volatile unsigned long *)(PANEL_HWC_COLOR_3) = 0x0000ffff;
+	change_mode(&voyafb_var);
+}
+
+
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER P_CSR",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	CSR_XRES/2,
+	.smem_len =	MAX_HWC_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX PANEL CSR framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_PANEL CSR frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init5(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP6;
+	size = MAX_HWC_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_HWC_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(PANEL_HWC_ADDRESS) &= 0x7fffffff;
+}
+
+static	int	change_mode(struct fb_var_screeninfo *var)
+{
+	if((var->xoffset < 0)||(var->xoffset > XRES)||
+	   (var->yoffset < 0)||(var->yoffset > YRES))
+	{
+		return(-1);
+	}
+	*(volatile unsigned long *)(PANEL_HWC_LOCATION) = (var->yoffset << 16) |
+								      var->xoffset;
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_valphafb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_valphafb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_valphafb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_valphafb.c	2006-08-23 13:29:28.097346000 +0100
@@ -0,0 +1,286 @@
+/*
+ *  linux/drivers/video/voyager_valphafb.c -- voyager video alpha frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init3(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+static int  change_mode(struct fb_var_screeninfo *var);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = XRES,
+	.yres = YRES,
+	.xres_virtual = XRES,
+	.yres_virtual = YRES,
+	.bits_per_pixel = BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > XRES || var->yres > YRES
+	    || var->xres_virtual > XRES || var->yres_virtual > YRES
+	    || var->bits_per_pixel != BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres_virtual = XRES;
+	var->yres_virtual = YRES;
+
+	if(change_mode(var) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = XRES*2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+		}
+		else {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= 0x04;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ENABLE_CK) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffff7;
+		}
+		else {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= 0x08;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ENABLE_AL) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xefffffff;
+		}
+		else {
+			*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= 0x10000000;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_SCALE) {
+		*(volatile unsigned long *)(VIDEO_ALPHA_SCALE) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_CHKEY) {
+		*(volatile unsigned long *)(VIDEO_ALPHA_CHROMA_KEY) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_TYPE) {
+		*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffffc;
+		*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= (arg & 0x03);
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ALPHA) {
+		*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xf0ffffff;
+		*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= (arg & 0x0f) << 24;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void __init voya_hw_init(void)
+{
+	*(volatile unsigned long *)(VIDEO_ALPHA_FB_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP3 & 0x00ffffff);
+	change_mode(&voyafb_var);
+	*(volatile unsigned long *)(VIDEO_ALPHA_SCALE) = 0;
+	*(volatile unsigned long *)(VIDEO_ALPHA_CHROMA_KEY) = 0;
+
+	*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffff0;
+//	*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= 0x05;
+	*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) |= 0x01;
+}
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER VALPHA",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	XRES*2,
+	.smem_len =	MAX_FRAMEBUFFER_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX VIDEO ALPHA framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_VIDEO_ALPHA frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init3(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP3;
+	size = MAX_FRAMEBUFFER_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_FRAMEBUFFER_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(VIDEO_ALPHA_DISPLAY_CTRL) &= 0xfffffffb;
+}
+
+
+//------------------------------------------------------------------------------------
+static	int	change_mode(struct fb_var_screeninfo *var)
+{
+int	x,ali,size;
+
+	if((var->xres < 0)||(var->xres > XRES)||
+	   (var->yres < 0)||(var->yres > YRES)||
+	   (var->xres_virtual < 0)||(var->xres_virtual > XRES)||
+	   (var->yres_virtual < 0)||(var->yres_virtual > YRES)||
+	   (var->xoffset < 0)||(var->xoffset > XRES)||
+	   (var->yoffset < 0)||(var->yoffset > YRES))
+	{
+		return(-1);
+	}
+	x = var->xres_virtual * 2;
+	ali = x + (x % 16);
+	*(volatile unsigned long *)(VIDEO_ALPHA_FB_WIDTH) = (ali << 16) | ali;
+	*(volatile unsigned long *)(VIDEO_ALPHA_PLANE_TL) = (var->yoffset << 16) |
+									var->xoffset;
+	*(volatile unsigned long *)(VIDEO_ALPHA_PLANE_BR) =
+			((var->yoffset + var->yres - 1) << 16) |
+			 (var->xoffset + var->xres - 1);
+	size = var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8;
+	*(volatile unsigned long *)(VIDEO_ALPHA_FB_LAST_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP3 & 0x00ffffff) + size;
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/drivers/video/voyager/voyager_videofb.c linux-2.6.17.8-sh/drivers/video/voyager/voyager_videofb.c
--- linux-2.6.17.8/drivers/video/voyager/voyager_videofb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/drivers/video/voyager/voyager_videofb.c	2006-08-23 13:29:28.104346000 +0100
@@ -0,0 +1,273 @@
+/*
+ *  linux/drivers/video/voyager_videofb.c -- voyager video frame buffer driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/voyagergx.h>
+#include <video/voyager.h>
+
+static struct fb_info voyafb_info;
+
+int voyafb_init2(void);
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int voyafb_set_par(struct fb_info *info);
+static int voyafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			     u_int transp, struct fb_info *info);
+static int voyafb_blank(int blank, struct fb_info *info);
+static int voyafb_ioctl(struct inode*, struct file*,
+			   unsigned int, unsigned long, struct fb_info*);
+static int  change_mode(struct fb_var_screeninfo *var);
+
+static	unsigned	int	pseudo_palette[16];
+
+static struct fb_ops voyafb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= voyafb_check_var,
+	.fb_set_par	= voyafb_set_par,
+	.fb_setcolreg	= voyafb_setcolreg,
+	.fb_blank	= voyafb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = voyafb_ioctl,
+};
+
+static struct fb_var_screeninfo voyafb_var __initdata = {
+	.xres = XRES,
+	.yres = YRES,
+	.xres_virtual = XRES,
+	.yres_virtual = YRES,
+	.bits_per_pixel = BPP,
+	.red = { 11,5,0 },
+	.green = { 5,6,0 },
+	.blue = { 0,5,0 },
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.pixclock = 10000,
+	.left_margin = 16,
+	.right_margin = 16,
+	.upper_margin = 16,
+	.lower_margin = 16,
+	.hsync_len = 8,
+	.vsync_len = 8,
+};
+
+static int voyafb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if (var->xres > XRES || var->yres > YRES
+	    || var->xres_virtual > XRES || var->yres_virtual > YRES
+	    || var->bits_per_pixel != BPP
+	    || var->nonstd
+	    || (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+	var->xres_virtual = XRES;
+	var->yres_virtual = YRES;
+
+	if(change_mode(var) != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int voyafb_set_par(struct fb_info *info)
+{
+	info->fix.line_length = XRES*2;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->var.red.offset = 11;
+	info->var.green.offset = 5;
+	info->var.blue.offset = 0;
+	info->var.red.length = info->var.blue.length = 5;
+	info->var.green.length = 6;
+	return 0;
+}
+
+static int voyafb_blank(int blank, struct fb_info *info)
+{
+	return 1;
+}
+
+static int voyafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			     unsigned blue, unsigned transp,
+			     struct fb_info* info)
+{
+	red   >>= 11;
+	green >>= 11;
+	blue  >>= 10;
+
+	if (regno < 16)
+		((u32 *)(info->pseudo_palette))[regno] = ((red & 31) << 6) |
+                                                         ((green & 31) << 11) |
+                                                         ((blue & 63));
+	return 0;
+}
+
+static int voyafb_ioctl(struct inode* inode, struct file* file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info* info)
+{
+	if(cmd == VOYAGER_IOCTL_ENABLE) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xfffffffb;
+		}
+		else {
+			*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) |= 0x04;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_ENABLE_CP) {
+		if(arg == 0) {
+			*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xffffbfff;
+		}
+		else {
+			*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) |= 0x00004000;
+		}
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_SCALE) {
+		*(volatile unsigned long *)(VIDEO_SCALE) = arg;
+		return 0;
+	}
+	else if(cmd == VOYAGER_IOCTL_TYPE) {
+		*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xfffffffc;
+		*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) |= (arg & 0x03);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void __init voya_hw_init(void)
+{
+int	i;
+
+	*(volatile unsigned long *)(VIDEO_FB_0_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP1 & 0x00ffffff);
+	*(volatile unsigned long *)(VIDEO_FB_1_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP2 & 0x00ffffff);
+	change_mode(&voyafb_var);
+	*(volatile unsigned long *)(VIDEO_SCALE) = 0;
+
+	*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xffffcea8;
+	*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) |= 0x10003;
+	//palet initialize
+	for(i=0;i<256;i++) {
+		*(volatile unsigned long *)(VIDEO_PALETTE_RAM+(i*4)) = (i << 16)+(i << 8)+i;
+	}
+}
+
+static struct fb_fix_screeninfo voyafb_fix __initdata = {
+	.id =		"VOYAGER VIDEO",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.accel =	FB_ACCEL_NONE,
+	.line_length =	XRES*2,
+	.smem_len =	MAX_FRAMEBUFFER_MEM_SIZE,
+};
+
+
+static void __init init_voya(struct fb_info *p, unsigned long addr)
+{
+	p->fix = voyafb_fix;
+	p->fix.smem_start = addr;
+
+	p->var = voyafb_var;
+
+	p->fbops = &voyafb_ops;
+	p->flags = FBINFO_FLAG_DEFAULT;
+	p->pseudo_palette = pseudo_palette;
+
+	fb_alloc_cmap(&p->cmap, 16, 0);
+
+	if (register_framebuffer(p) < 0) {
+		printk(KERN_ERR "VOYAGER GX VIDEO framebuffer failed to register\n");
+		return;
+	}
+
+	printk(KERN_INFO "fb%d: VOYAGER GX_VIDEO frame buffer (%dK RAM detected)\n",
+		p->node, p->fix.smem_len / 1024);
+
+	voya_hw_init();
+}
+
+int __init voyafb_init2(void)
+{
+	struct fb_info *p = &voyafb_info;
+	unsigned long addr, size;
+
+        addr = VOY_VRAM_TOP1;
+	size = MAX_FRAMEBUFFER_MEM_SIZE;
+	p->screen_base = ioremap((u_long)addr,
+				     ALLOCATED_FB_MEM_SIZE);
+	if (p->screen_base == NULL) {
+		return -ENOMEM;
+	}
+	init_voya(p, addr);
+	memset(p->screen_base, 0, MAX_FRAMEBUFFER_MEM_SIZE);
+
+	return 0;
+}
+
+static void __exit voyafb_exit(void)
+{
+	*(volatile unsigned long *)(VIDEO_DISPLAY_CTRL) &= 0xfffffffb;
+}
+
+
+//------------------------------------------------------------------------------------
+static	int	change_mode(struct fb_var_screeninfo *var)
+{
+int	x,ali,size;
+
+	if((var->xres < 0)||(var->xres > XRES)||
+	   (var->yres < 0)||(var->yres > YRES)||
+	   (var->xres_virtual < 0)||(var->xres_virtual > XRES)||
+	   (var->yres_virtual < 0)||(var->yres_virtual > YRES)||
+	   (var->xoffset < 0)||(var->xoffset > XRES)||
+	   (var->yoffset < 0)||(var->yoffset > YRES))
+	{
+		return(-1);
+	}
+	x = var->xres_virtual * 2;
+	ali = x + (x % 16);
+	*(volatile unsigned long *)(VIDEO_FB_WIDTH) = (ali << 16) | ali;
+	*(volatile unsigned long *)(VIDEO_PLANE_TL) = (var->yoffset << 16) | var->xoffset;
+	*(volatile unsigned long *)(VIDEO_PLANE_BR) =
+			((var->yoffset + var->yres - 1) << 16) |
+			 (var->xoffset + var->xres - 1);
+	size = var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8;
+	*(volatile unsigned long *)(VIDEO_FB_0_LAST_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP1 & 0x00ffffff) + size;
+	*(volatile unsigned long *)(VIDEO_FB_1_LAST_ADDRESS) = 0x80000000 + (VOY_VRAM_TOP2 & 0x00ffffff) + size;
+	return(0);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/include/asm-sh/addrspace.h linux-2.6.17.8-sh/include/asm-sh/addrspace.h
--- linux-2.6.17.8/include/asm-sh/addrspace.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/addrspace.h	2006-08-23 13:29:28.835369000 +0100
@@ -14,11 +14,19 @@
 #include <asm/cpu/addrspace.h>
 
 /* Memory segments (32bit Privileged mode addresses)  */
+#ifndef CONFIG_CPU_SH2A
 #define P0SEG		0x00000000
 #define P1SEG		0x80000000
 #define P2SEG		0xa0000000
 #define P3SEG		0xc0000000
 #define P4SEG		0xe0000000
+#else
+#define P0SEG		0x00000000
+#define P1SEG		0x00000000
+#define P2SEG		0x20000000
+#define P3SEG		0x00000000
+#define P4SEG 		0x80000000
+#endif
 
 /* Returns the privileged segment base of a given address  */
 #define PXSEG(a)	(((unsigned long)(a)) & 0xe0000000)
diff -Naur linux-2.6.17.8/include/asm-sh/apm.h linux-2.6.17.8-sh/include/asm-sh/apm.h
--- linux-2.6.17.8/include/asm-sh/apm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/apm.h	2006-08-23 13:29:22.026208000 +0100
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2006 (c) Andriy Skulysh <askulysh@gmail.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#ifndef __ASM_SH_APM_H
+#define __ASM_SH_APM_H
+
+#define APM_AC_OFFLINE			0
+#define APM_AC_ONLINE			1
+#define APM_AC_BACKUP			2
+#define APM_AC_UNKNOWN			0xff
+
+#define APM_BATTERY_STATUS_HIGH		0
+#define APM_BATTERY_STATUS_LOW		1
+#define APM_BATTERY_STATUS_CRITICAL	2
+#define APM_BATTERY_STATUS_CHARGING	3
+#define APM_BATTERY_STATUS_NOT_PRESENT	4
+#define APM_BATTERY_STATUS_UNKNOWN	0xff
+
+#define APM_BATTERY_LIFE_UNKNOWN	0xFFFF
+#define APM_BATTERY_LIFE_MINUTES	0x8000
+#define APM_BATTERY_LIFE_VALUE_MASK	0x7FFF
+
+#define APM_BATTERY_FLAG_HIGH		(1 << 0)
+#define APM_BATTERY_FLAG_LOW		(1 << 1)
+#define APM_BATTERY_FLAG_CRITICAL	(1 << 2)
+#define APM_BATTERY_FLAG_CHARGING	(1 << 3)
+#define APM_BATTERY_FLAG_NOT_PRESENT	(1 << 7)
+#define APM_BATTERY_FLAG_UNKNOWN	0xff
+
+#define APM_UNITS_MINS			0
+#define APM_UNITS_SECS			1
+#define APM_UNITS_UNKNOWN		-1
+
+
+extern int (*apm_get_info)(char *buf, char **start, off_t fpos, int length);
+extern int apm_suspended;
+
+void apm_queue_event(apm_event_t event);
+
+#endif
diff -Naur linux-2.6.17.8/include/asm-sh/atomic.h linux-2.6.17.8-sh/include/asm-sh/atomic.h
--- linux-2.6.17.8/include/asm-sh/atomic.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/atomic.h	2006-08-23 13:29:49.418852000 +0100
@@ -6,6 +6,12 @@
  * resource counting etc..
  *
  */
+/*
+  15th jan 2006  Added gKSA (Kernel gUSA) support
+                   Francesco Virlinzi <francesco.virlinzi@st.com>
+  1st  Apr 2006  Moved the gKSA in gRB
+		   Francesco Virlinzi <francesco.virlinzi@st.com>
+*/
 
 typedef struct { volatile int counter; } atomic_t;
 
@@ -14,6 +20,7 @@
 #define atomic_read(v)		((v)->counter)
 #define atomic_set(v,i)		((v)->counter = (i))
 
+#include <linux/compiler.h>
 #include <asm/system.h>
 
 /*
@@ -21,6 +28,154 @@
  * forward to code at the end of this object's .text section, then
  * branch back to restart the operation.
  */
+#if defined(CONFIG_STM_GRB)
+static __inline__ void atomic_add(int i, atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+		"   mov    r15,   r1      \n\t"  // r1 = saved sp
+                "   mov    #-6,   r15     \n\t"  // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t"  // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (i)        // 2
+                : "memory" , "r0", "r1" );
+}
+
+static __inline__ void atomic_sub(int i, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+		"   mov     r15,  r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   sub     %2,   %0      \n\t" // sub
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (i)        // 2
+                : "memory" , "r0", "r1");
+}
+
+static __inline__ int atomic_add_return(int i, atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+		"   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (i)        // 2
+                : "memory" , "r0", "r1");
+        return tmp;
+}
+
+#define atomic_add_negative(a, v)       (atomic_add_return((a), (v)) < 0)
+
+static __inline__ int atomic_sub_return(int i, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   sub     %2,   %0      \n\t" // sub
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (i)        // 2
+                : "memory", "r0", "r1" );
+        return tmp;
+}
+
+static __inline__ void atomic_inc(atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     #1,   %0      \n\t" // add 1
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v)        // 1
+                : "memory" , "r0", "r1" );
+}
+
+static __inline__ void atomic_dec(atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add    #-1,   %0      \n\t" // add -1
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v)        // 1
+                : "memory" , "r0", "r1" );
+}
+
+static __inline__ int atomic_inc_return(atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add     #1,   %0      \n\t" // add 1
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v)        // 1
+                : "memory" , "r0", "r1" );
+	return tmp;
+}
+
+static __inline__ int atomic_dec_return(atomic_t * v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   add    #-1,   %0      \n\t" // add -1
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v)        // 1
+                : "memory" , "r0", "r1" );
+	return tmp;
+}
+
+#else
 
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
@@ -68,8 +223,12 @@
 	return temp;
 }
 
+#define atomic_inc(v) atomic_add(1,(v))
+#define atomic_dec(v) atomic_sub(1,(v))
+
 #define atomic_dec_return(v) atomic_sub_return(1,(v))
 #define atomic_inc_return(v) atomic_add_return(1,(v))
+#endif
 
 /*
  * atomic_inc_and_test - increment and test
@@ -84,9 +243,6 @@
 #define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
 #define atomic_dec_and_test(v) (atomic_sub_return(1, (v)) == 0)
 
-#define atomic_inc(v) atomic_add(1,(v))
-#define atomic_dec(v) atomic_sub(1,(v))
-
 static inline int atomic_cmpxchg(atomic_t *v, int old, int new)
 {
 	int ret;
@@ -118,6 +274,44 @@
 }
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
+#if defined(CONFIG_STM_GRB)
+static __inline__ void atomic_clear_mask(unsigned int mask, atomic_t *v)
+{
+       int tmp;
+       unsigned int _mask = ~mask;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   and     %2,   %0      \n\t" // add
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (_mask)    // 2
+                : "memory" , "r0", "r1" );
+}
+
+static __inline__ void atomic_set_mask(unsigned int mask, atomic_t *v)
+{
+       int tmp;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   or      %2,   %0      \n\t" // or
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (v),       // 1
+                  "r"   (mask)    // 2
+                : "memory" , "r0", "r1" );
+}
+#else
 static __inline__ void atomic_clear_mask(unsigned int mask, atomic_t *v)
 {
 	unsigned long flags;
@@ -135,6 +329,7 @@
 	*(long *)v |= mask;
 	local_irq_restore(flags);
 }
+#endif
 
 /* Atomic operations are already serializing on SH */
 #define smp_mb__before_atomic_dec()	barrier()
diff -Naur linux-2.6.17.8/include/asm-sh/bitops.h linux-2.6.17.8-sh/include/asm-sh/bitops.h
--- linux-2.6.17.8/include/asm-sh/bitops.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/bitops.h	2006-08-23 13:29:49.428852000 +0100
@@ -1,12 +1,42 @@
 #ifndef __ASM_SH_BITOPS_H
 #define __ASM_SH_BITOPS_H
+/*
+  15th jan 2006  Added gKSA (Kernel gUSA) support
+                   Francesco Virlinzi <francesco.virlinzi@st.com>
+  1st  Apr 2006  Moved the gKSA in gRB
+                   Francesco Virlinzi <francesco.virlinzi@st.com>
+*/
 
 #ifdef __KERNEL__
 #include <asm/system.h>
 /* For __swab32 */
 #include <asm/byteorder.h>
 
-static __inline__ void set_bit(int nr, volatile void * addr)
+#if defined(CONFIG_STM_GRB)
+static inline void set_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+	unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   or      %2,   %0      \n\t" // or
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (a),       // 1
+                  "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+#else
+static inline void set_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile unsigned int *a = addr;
@@ -18,13 +48,38 @@
 	*a |= mask;
 	local_irq_restore(flags);
 }
+#endif
 
 /*
  * clear_bit() doesn't provide any barrier for the compiler.
  */
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
-static __inline__ void clear_bit(int nr, volatile void * addr)
+#if defined(CONFIG_STM_GRB)
+static inline void clear_bit(int nr, volatile void * addr)
+{
+	int	mask;
+	volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+	a += nr >> 5;
+        mask = ~(1 << (nr & 0x1f));
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   and     %2,   %0      \n\t" // and
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (a),       // 1
+                  "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+#else
+static inline void clear_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile unsigned int *a = addr;
@@ -36,8 +91,33 @@
 	*a &= ~mask;
 	local_irq_restore(flags);
 }
+#endif
 
-static __inline__ void change_bit(int nr, volatile void * addr)
+#if defined(CONFIG_STM_GRB)
+static inline void change_bit(int nr, volatile void * addr)
+{
+        int     mask;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-6,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   xor     %2,   %0      \n\t" // xor
+                "   mov.l   %0,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp)      // 0
+                : "r"   (a),       // 1
+                  "r"   (mask)     // 2
+                : "memory" , "r0", "r1" );
+}
+#else
+static inline void change_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile unsigned int *a = addr;
@@ -49,8 +129,44 @@
 	*a ^= mask;
 	local_irq_restore(flags);
 }
+#endif
 
-static __inline__ int test_and_set_bit(int nr, volatile void * addr)
+#if defined(CONFIG_STM_GRB)
+static inline int test_and_set_bit(int nr, volatile void * addr)
+{
+        int     mask, retval;
+	volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a |= mask;
+*/
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov   #-14,   r15     \n\t" // LOGIN: r15 = size
+                "   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" //
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+                "   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   or      %3,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+                "1: mov     r1,  r15      \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "=&r" (retval)   // 1
+                : "r"   (a),       // 2
+                  "r"   (mask)     // 3
+                : "memory" , "r0", "r1" ,"t");
+
+        return retval;
+}
+#else
+static inline int test_and_set_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile unsigned int *a = addr;
@@ -65,8 +181,47 @@
 
 	return retval;
 }
+#endif
+
+#if defined(CONFIG_STM_GRB)
+static inline int test_and_clear_bit(int nr, volatile void * addr)
+{
+        int     mask, retval,not_mask;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a &= ~mask;
+*/
+	not_mask = ~mask;
+
+        asm volatile(
+                "   .align 2              \n\t"
+		"   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+		"   mov   #-14,   r15     \n\t" // LOGIN
+		"   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" // %1     = *a
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+		"   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   and     %4,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+		"1: mov     r1,   r15     \n\t" // LOGOUT
+		: "=&r" (tmp),     // 0
+		  "=&r" (retval)   // 1
+		: "r"   (a),       // 2
+		  "r"   (mask),    // 3
+		  "r"   (not_mask) // 4
+		: "memory" , "r0", "r1", "t" );
 
-static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
+        return retval;
+}
+#else
+static inline int test_and_clear_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile unsigned int *a = addr;
@@ -81,8 +236,43 @@
 
 	return retval;
 }
+#endif
 
-static __inline__ int test_and_change_bit(int nr, volatile void * addr)
+#if defined(CONFIG_STM_GRB)
+static inline int test_and_change_bit(int nr, volatile void * addr)
+{
+        int     mask, retval;
+        volatile unsigned int *a = addr;
+        unsigned long tmp;
+
+        a += nr >> 5;
+        mask = 1 << (nr & 0x1f);
+/*
+        retval = (mask & *a) != 0;
+        *a ^= mask;
+*/
+        asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov   #-14,   r15     \n\t" // LOGIN
+                "   mov.l  @%2,   %0      \n\t" // load old value
+                "   mov     %0,   %1      \n\t" // %1     = *a
+                "   tst     %1,   %3      \n\t" // T_bit  = ( (*a & mask) == 0 )
+                "   mov    #-1,   %1      \n\t" // retvat = -1
+                "   negc    %1,   %1      \n\t" // retval = (mask & *a) != 0
+                "   xor     %3,   %0      \n\t" //
+                "   mov.l   %0,  @%2      \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (tmp),     // 0
+                  "=&r" (retval)   // 1
+                : "r"   (a),       // 2
+                  "r"   (mask)     // 3
+                : "memory" , "r0", "r1", "t" );
+        return retval;
+}
+#else
+static inline int test_and_change_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile unsigned int *a = addr;
@@ -97,10 +287,11 @@
 
 	return retval;
 }
+#endif
 
 #include <asm-generic/bitops/non-atomic.h>
 
-static __inline__ unsigned long ffz(unsigned long word)
+static inline unsigned long ffz(unsigned long word)
 {
 	unsigned long result;
 
@@ -120,7 +311,7 @@
  *
  * Undefined if no bit exists, so code should check against 0 first.
  */
-static __inline__ unsigned long __ffs(unsigned long word)
+static inline unsigned long __ffs(unsigned long word)
 {
 	unsigned long result;
 
diff -Naur linux-2.6.17.8/include/asm-sh/bugs.h linux-2.6.17.8-sh/include/asm-sh/bugs.h
--- linux-2.6.17.8/include/asm-sh/bugs.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/bugs.h	2006-08-23 13:29:13.807024000 +0100
@@ -32,6 +32,10 @@
 	case CPU_SH7750 ... CPU_SH4_501:
 		*p++ = '4';
 		break;
+	case CPU_SH7770 ... CPU_SH7781:
+		*p++ = '4';
+		*p++ = 'a';
+		break;
 	default:
 		*p++ = '?';
 		*p++ = '!';
diff -Naur linux-2.6.17.8/include/asm-sh/cachectl.h linux-2.6.17.8-sh/include/asm-sh/cachectl.h
--- linux-2.6.17.8/include/asm-sh/cachectl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cachectl.h	2006-08-23 13:29:44.812739000 +0100
@@ -0,0 +1,12 @@
+#ifndef _SH_CACHECTL_H
+#define _SH_CACHECTL_H
+
+/* Definitions for the cacheflush system call.  */
+
+#define CACHEFLUSH_D_INVAL	0x1	/* invalidate (without write back) */
+#define CACHEFLUSH_D_WB		0x2	/* write back (without invalidate) */
+#define CACHEFLUSH_D_PURGE	0x3	/* writeback and invalidate */
+
+#define CACHEFLUSH_I		0x4
+
+#endif /* _SH_CACHECTL_H */
diff -Naur linux-2.6.17.8/include/asm-sh/cacheflush.h linux-2.6.17.8-sh/include/asm-sh/cacheflush.h
--- linux-2.6.17.8/include/asm-sh/cacheflush.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cacheflush.h	2006-08-23 13:29:17.105093000 +0100
@@ -2,6 +2,7 @@
 #define __ASM_SH_CACHEFLUSH_H
 #ifdef __KERNEL__
 
+#include <linux/mm.h>
 #include <asm/cpu/cacheflush.h>
 
 /* Flush (write-back only) a region (smaller than a page) */
diff -Naur linux-2.6.17.8/include/asm-sh/cache.h linux-2.6.17.8-sh/include/asm-sh/cache.h
--- linux-2.6.17.8/include/asm-sh/cache.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cache.h	2006-08-23 13:29:17.088095000 +0100
@@ -10,7 +10,6 @@
 #ifdef __KERNEL__
 
 #include <asm/cpu/cache.h>
-#include <asm/cpu/cacheflush.h>
 
 #define SH_CACHE_VALID		1
 #define SH_CACHE_UPDATED	2
@@ -23,24 +22,31 @@
 #define L1_CACHE_ALIGN(x)	(((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
 
 struct cache_info {
-	unsigned int ways;
-	unsigned int sets;
-	unsigned int linesz;
-
+	unsigned int ways;		/* Number of cache ways */
+	unsigned int sets;		/* Number of cache sets */
+	unsigned int linesz;		/* Cache line size (bytes) */
+
+	unsigned int way_size;		/* sets * line size */
+
+	/*
+	 * way_incr is the address offset for accessing the next way
+	 * in memory mapped cache array ops.
+	 */
 	unsigned int way_incr;
-
 	unsigned int entry_shift;
 	unsigned int entry_mask;
 
+	/*
+	 * Compute a mask which selects the address bits which overlap between
+	 * 1. those used to select the cache set during indexing
+	 * 2. those in the physical page number.
+	 */
+	unsigned int alias_mask;
+
+	unsigned int n_aliases;		/* Number of aliases */
+
 	unsigned long flags;
 };
 
-/* Flush (write-back only) a region (smaller than a page) */
-extern void __flush_wback_region(void *start, int size);
-/* Flush (write-back & invalidate) a region (smaller than a page) */
-extern void __flush_purge_region(void *start, int size);
-/* Flush (invalidate only) a region (smaller than a page) */
-extern void __flush_invalidate_region(void *start, int size);
-
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_CACHE_H */
diff -Naur linux-2.6.17.8/include/asm-sh/checksum.h linux-2.6.17.8-sh/include/asm-sh/checksum.h
--- linux-2.6.17.8/include/asm-sh/checksum.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/checksum.h	2006-08-23 13:29:20.185185000 +0100
@@ -160,6 +160,7 @@
 }
 
 #define _HAVE_ARCH_IPV6_CSUM
+#ifdef CONFIG_IPV6
 static __inline__ unsigned short int csum_ipv6_magic(struct in6_addr *saddr,
 						     struct in6_addr *daddr,
 						     __u32 len,
@@ -195,6 +196,7 @@
 
 	return csum_fold(sum);
 }
+#endif
 
 /* 
  *	Copy and checksum to user
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh3/cacheflush.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/cacheflush.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh3/cacheflush.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/cacheflush.h	2006-08-23 13:29:17.462116000 +0100
@@ -10,7 +10,7 @@
 #ifndef __ASM_CPU_SH3_CACHEFLUSH_H
 #define __ASM_CPU_SH3_CACHEFLUSH_H
 
-/* 
+/*
  * Cache flushing:
  *
  *  - flush_cache_all() flushes entire cache
@@ -35,53 +35,41 @@
  /* 32KB cache, 4kb PAGE sizes need to check bit 12 */
 #define CACHE_ALIAS 0x00001000
 
-struct page;
-struct mm_struct;
-struct vm_area_struct;
-
-extern void flush_cache_all(void);
-extern void flush_cache_mm(struct mm_struct *mm);
-extern void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
-                              unsigned long end);
-extern void flush_cache_page(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn);
-extern void flush_dcache_page(struct page *pg);
-extern void flush_icache_range(unsigned long start, unsigned long end);
-extern void flush_icache_page(struct vm_area_struct *vma, struct page *page);
-
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
-
-/* SH3 has unified cache so no special action needed here */
-#define flush_cache_sigtramp(vaddr)		do { } while (0)
-#define flush_page_to_ram(page)			do { } while (0)
-#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
-
-#define p3_cache_init()				do { } while (0)
-
 #define PG_mapped	PG_arch_1
 
-/* We provide our own get_unmapped_area to avoid cache alias issue */
-#define HAVE_ARCH_UNMAPPED_AREA
-
+void flush_cache_all(void);
+void flush_cache_mm(struct mm_struct *mm);
+void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
+                              unsigned long end);
+void flush_cache_page(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn);
+void flush_dcache_page(struct page *pg);
+void flush_icache_range(unsigned long start, unsigned long end);
+void flush_icache_page(struct vm_area_struct *vma, struct page *page);
 #else
-
 #define flush_cache_all()			do { } while (0)
 #define flush_cache_mm(mm)			do { } while (0)
 #define flush_cache_range(vma, start, end)	do { } while (0)
 #define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
 #define flush_dcache_page(page)			do { } while (0)
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
 #define flush_icache_range(start, end)		do { } while (0)
 #define flush_icache_page(vma,pg)		do { } while (0)
-#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
+#endif
+
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+
+/* SH3 has unified cache so no special action needed here */
 #define flush_cache_sigtramp(vaddr)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
 
 #define p3_cache_init()				do { } while (0)
 
+/*
+ * We provide our own get_unmapped_area to avoid cache aliasing issues
+ * on SH7705 with a 32KB cache, and to page align addresses in the
+ * non-aliasing case.
+ */
 #define HAVE_ARCH_UNMAPPED_AREA
 
-#endif
-
 #endif /* __ASM_CPU_SH3_CACHEFLUSH_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh3/freq.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/freq.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh3/freq.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/freq.h	2006-08-23 13:29:22.085208000 +0100
@@ -18,5 +18,9 @@
 #define MIN_DIVISOR_NR		0
 #define MAX_DIVISOR_NR		4
 
+#define FRQCR_CKOEN	0x0100
+#define FRQCR_PLLEN	0x0080
+#define FRQCR_PSTBY	0x0040
+
 #endif /* __ASM_CPU_SH3_FREQ_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh3/timer.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/timer.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh3/timer.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh3/timer.h	2006-08-23 13:29:11.304979000 +0100
@@ -23,6 +23,10 @@
  * ---------------------------------------------------------------------------
  */
 
+#if !defined(CONFIG_CPU_SUBTYPE_SH7727)
+#define TMU_TOCR	0xfffffe90	/* Byte access */
+#endif
+
 #if defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7710)
 #define TMU_TSTR	0xa412fe92	/* Byte access */
 
@@ -39,9 +43,6 @@
 #define TMU2_TCR	0xa412feb4	/* Word access */
 
 #else
-#if !defined(CONFIG_CPU_SUBTYPE_SH7727)
-#define TMU_TOCR	0xfffffe90	/* Byte access */
-#endif
 #define TMU_TSTR	0xfffffe92	/* Byte access */
 
 #define TMU0_TCOR	0xfffffe94	/* Long access */
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/addrspace.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/addrspace.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/addrspace.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/addrspace.h	2006-08-23 13:29:21.458210000 +0100
@@ -22,5 +22,8 @@
 #define P4SEG_TLB_DATA	0xf7000000
 #define P4SEG_REG_BASE	0xff000000
 
+#define PA_AREA5_IO	0xb4000000	/* Area 5 IO Memory */
+#define PA_AREA6_IO	0xb8000000	/* Area 6 IO Memory */
+
 #endif /* __ASM_CPU_SH4_ADDRSPACE_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/cacheflush.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/cacheflush.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/cacheflush.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/cacheflush.h	2006-08-23 13:29:17.125093000 +0100
@@ -16,34 +16,26 @@
  *  caching; in which case they're only semi-broken),
  *  so we need them.
  */
-
-/* Page is 4K, OC size is 16K, there are four lines. */
-#define CACHE_ALIAS 0x00003000
-
-struct page;
-struct mm_struct;
-struct vm_area_struct;
-
-extern void flush_cache_all(void);
-extern void flush_cache_mm(struct mm_struct *mm);
-extern void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
-			      unsigned long end);
-extern void flush_cache_page(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn);
-extern void flush_dcache_page(struct page *pg);
+void flush_cache_all(void);
+void flush_cache_mm(struct mm_struct *mm);
+void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
+		       unsigned long end);
+void flush_cache_page(struct vm_area_struct *vma, unsigned long addr,
+		      unsigned long pfn);
+void flush_dcache_page(struct page *pg);
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
 #define flush_dcache_mmap_unlock(mapping)	do { } while (0)
 
-extern void flush_icache_range(unsigned long start, unsigned long end);
-extern void flush_cache_sigtramp(unsigned long addr);
-extern void flush_icache_user_range(struct vm_area_struct *vma,
-				    struct page *page, unsigned long addr,
-				    int len);
+void flush_icache_range(unsigned long start, unsigned long end);
+void flush_cache_sigtramp(unsigned long addr);
+void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
+			     unsigned long addr, int len);
 
 #define flush_icache_page(vma,pg)		do { } while (0)
 
 /* Initialization of P3 area for copy_user_page */
-extern void p3_cache_init(void);
+void p3_cache_init(void);
 
 #define PG_mapped	PG_arch_1
 
@@ -61,4 +53,3 @@
 }
 #endif /* CONFIG_MMU */
 #endif /* __ASM_CPU_SH4_CACHEFLUSH_H */
-
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/cache.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/cache.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/cache.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/cache.h	2006-08-23 13:29:13.831024000 +0100
@@ -22,7 +22,9 @@
 #define CCR_CACHE_ICE	0x0100	/* Instruction Cache Enable */
 #define CCR_CACHE_ICI	0x0800	/* IC Invalidate */
 #define CCR_CACHE_IIX	0x8000	/* IC Index Enable */
+#ifndef CONFIG_CPU_SUBTYPE_SH7780
 #define CCR_CACHE_EMODE	0x80000000	/* EMODE Enable */
+#endif
 
 /* Default CCR setup: 8k+16k-byte cache,P1-wb,enable */
 #define CCR_CACHE_ENABLE	(CCR_CACHE_OCE|CCR_CACHE_ICE)
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/dma.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/dma.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/dma.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/dma.h	2006-08-23 13:29:23.537254000 +0100
@@ -1,11 +1,17 @@
 #ifndef __ASM_CPU_SH4_DMA_H
 #define __ASM_CPU_SH4_DMA_H
 
+#define DMAOR_INIT	( 0x8000 | DMAOR_DME )
+
 #ifdef CONFIG_CPU_SH4A
 #define SH_DMAC_BASE	0xfc808020
+
+#define CHCR_TS_MASK	0x18
+#define CHCR_TS_SHIFT	3
+
+#include <asm/cpu/dma-sh7780.h>
 #else
 #define SH_DMAC_BASE	0xffa00000
-#endif
 
 /* Definitions for the SuperH DMAC */
 #define TM_BURST	0x0000080
@@ -19,8 +25,6 @@
 
 #define DMAOR_COD	0x00000008
 
-#define DMAOR_INIT	( 0x8000 | DMAOR_DME )
-
 /*
  * The SuperH DMAC supports a number of transmit sizes, we list them here,
  * with their respective values as they appear in the CHCR registers.
@@ -45,5 +49,6 @@
 	[XMIT_SZ_32BIT]		= 2,
 	[XMIT_SZ_256BIT]	= 5,
 };
+#endif
 
 #endif /* __ASM_CPU_SH4_DMA_H */
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/dma-sh7780.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/dma-sh7780.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/dma-sh7780.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/dma-sh7780.h	2006-08-23 13:29:23.508255000 +0100
@@ -0,0 +1,39 @@
+#ifndef __ASM_SH_CPU_SH4_DMA_SH7780_H
+#define __ASM_SH_CPU_SH4_DMA_SH7780_H
+
+#define REQ_HE	0x000000C0
+#define REQ_H	0x00000080
+#define REQ_LE	0x00000040
+#define TM_BURST 0x0000020
+#define TS_8	0x00000000
+#define TS_16	0x00000008
+#define TS_32	0x00000010
+#define TS_16BLK	0x00000018
+#define TS_32BLK	0x00100000
+
+/*
+ * The SuperH DMAC supports a number of transmit sizes, we list them here,
+ * with their respective values as they appear in the CHCR registers.
+ *
+ * Defaults to a 64-bit transfer size.
+ */
+enum {
+	XMIT_SZ_8BIT,
+	XMIT_SZ_16BIT,
+	XMIT_SZ_32BIT,
+	XMIT_SZ_128BIT,
+	XMIT_SZ_256BIT,
+};
+
+/*
+ * The DMA count is defined as the number of bytes to transfer.
+ */
+static unsigned int __attribute__ ((used)) ts_shift[] = {
+	[XMIT_SZ_8BIT]		= 0,
+	[XMIT_SZ_16BIT]		= 1,
+	[XMIT_SZ_32BIT]		= 2,
+	[XMIT_SZ_128BIT]	= 4,
+	[XMIT_SZ_256BIT]	= 5,
+};
+
+#endif /* __ASM_SH_CPU_SH4_DMA_SH7780_H */
diff -Naur linux-2.6.17.8/include/asm-sh/cpu-sh4/sq.h linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/sq.h
--- linux-2.6.17.8/include/asm-sh/cpu-sh4/sq.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/cpu-sh4/sq.h	2006-08-23 13:29:19.467162000 +0100
@@ -17,7 +17,7 @@
  * Store queues range from e0000000-e3fffffc, allowing approx. 64MB to be
  * mapped to any physical address space. Since data is written (and aligned)
  * to 32-byte boundaries, we need to be sure that all allocations are aligned.
- */ 
+ */
 #define SQ_SIZE                 32
 #define SQ_ALIGN_MASK           (~(SQ_SIZE - 1))
 #define SQ_ALIGN(addr)          (((addr)+SQ_SIZE-1) & SQ_ALIGN_MASK)
@@ -26,23 +26,10 @@
 #define SQ_QACR1		(P4SEG_REG_BASE  + 0x3c)
 #define SQ_ADDRMAX              (P4SEG_STORE_QUE + 0x04000000)
 
-struct sq_mapping {
-	const char *name;
-
-	unsigned long sq_addr;
-	unsigned long addr;
-	unsigned int size;
-
-	struct list_head list;
-};
-
 /* arch/sh/kernel/cpu/sh4/sq.c */
-extern struct sq_mapping *sq_remap(unsigned long phys, unsigned int size, const char *name);
-extern void sq_unmap(struct sq_mapping *map);
-
-extern void sq_clear(unsigned long addr, unsigned int len);
-extern void sq_flush(void *addr);
-extern void sq_flush_range(unsigned long start, unsigned int len);
+unsigned long sq_remap(unsigned long phys, unsigned int size,
+		       const char *name, unsigned long flags);
+void sq_unmap(unsigned long vaddr);
+void sq_flush_range(unsigned long start, unsigned int len);
 
 #endif /* __ASM_CPU_SH4_SQ_H */
-
diff -Naur linux-2.6.17.8/include/asm-sh/dma.h linux-2.6.17.8-sh/include/asm-sh/dma.h
--- linux-2.6.17.8/include/asm-sh/dma.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/dma.h	2006-08-23 13:29:45.105738000 +0100
@@ -18,6 +18,11 @@
 #include <linux/device.h>
 #include <asm/cpu/dma.h>
 #include <asm/semaphore.h>
+#if defined CONFIG_CPU_SUBTYPE_STB7100 || defined CONFIG_STM_GPDMA
+#include <linux/stm/7100_fdma2.h>
+#include <asm/scatterlist.h>
+#endif
+
 
 /* The maximum address that we can perform a DMA transfer to on this platform */
 /* Don't define MAX_DMA_ADDRESS; it's useless on the SuperH and any
@@ -47,16 +52,47 @@
  * DMAC (dma_info) flags
  */
 enum {
-	DMAC_CHANNELS_CONFIGURED	= 0x00,
-	DMAC_CHANNELS_TEI_CAPABLE	= 0x01,
+	DMAC_CHANNELS_CONFIGURED	= 0x01,
+	DMAC_CHANNELS_TEI_CAPABLE	= 0x02,	/* Transfer end interrupt */
 };
 
 /*
  * DMA channel capabilities / flags
  */
 enum {
-	DMA_TEI_CAPABLE			= 0x01,
+	DMA_TEI_CAPABLE			= 0x01,	/* Transfer end interrupt.
+						 * Inherited from DMAC.
+						 * wait_queue used in dma_wait_for_completion */
 	DMA_CONFIGURED			= 0x02,
+#if defined(CONFIG_STM_DMA)
+	/* Extra DMA channel flags */
+#define NODE_DONE_ISR 		0x20	/* FDMA */
+#define NODE_PAUSE_ISR		0x40	/* FDMA */
+#define ANY_CHANNEL     	0x80	/* API, FDMA, GPDMA */
+#define DIM_0_x_0			0x100	/* FDMA, GPDMA */
+#define DIM_0_x_1			0x200
+#define DIM_0_x_2			0x400
+#define DIM_1_x_0			0x800
+#define DIM_1_x_1			0x1000
+#define DIM_1_x_2			0x2000
+#define DIM_2_x_0			0x4000
+#define DIM_2_x_1			0x8000
+#define DIM_2_x_2			0x10000	/* FDMA, GPDMA */
+#define DIM_0_x_SG			0x20000	/* FDMA, GPDMA */
+#define DIM_SG_x_0			0x40000	/* FDMA, GPDMA */
+#define DIM_SG_x_SG			0x80000	/* FDMA, GPDMA */
+#define LIST_TYPE_LINKED 	        0x100000	/* FDMA, GPDMA */
+#define LIST_TYPE_UNLINKED 	        0x200000	/* FDMA */
+#define DMA_CONFIGURED		        0x400000	/* API, SH, FDMA, GPDMA, Overrides DMA_CONFIGURED above */
+#define DMA_SETUP_NOBLOCK               0x800000	/* FDMA */
+#define CALLBACK_CONTEXT_INTERRUPT      0x1000000
+/*FDMA Mode flags*/
+#define MODE_FREERUNNING   		0x01	/* FDMA, GPDMA */
+#define MODE_PACED  		 	0x02	/* FDMA */
+#define MODE_SPDIF				0x04	/* FDMA */
+#define MODE_PES				0x08	/* FDMA */
+#endif
+
 };
 
 extern spinlock_t dma_spin_lock;
@@ -69,21 +105,99 @@
 
 	int (*get_residue)(struct dma_channel *chan);
 	int (*xfer)(struct dma_channel *chan);
-	void (*configure)(struct dma_channel *chan, unsigned long flags);
+	int (*configure)(struct dma_channel *chan, unsigned long flags);
+#if defined(CONFIG_STM_DMA)
+	int (*pause)(int flags,struct dma_channel *chan);
+	void (*unpause)(struct dma_channel *chan);
+	int (*stop)(struct dma_channel *chan);
+#endif
 };
 
 struct dma_channel {
-	char dev_id[16];
+	char dev_id[16];	/*unique name per DMAC of channel*/
 
 	unsigned int chan;		/* Physical channel number */
 	unsigned int vchan;		/* Virtual channel number */
-	unsigned int mode;
-	unsigned int count;
-
-	unsigned long sar;
-	unsigned long dar;
+	unsigned int mode;  /*For STMicro DMA API modes see /include/linux/7100_fdma2.h*/
+	unsigned int count; /*transfer length in bytes*/
 
+	unsigned long sar;  /*source address location - specified as P3 and 32 byte aligned
+						should not be specified in DIM_SG_x_0 mode*/
+	unsigned long dar;  /*destination address location - specified as P3 and 32 byte aligned
+						should not be specified in DIM_0_x_SG mode*/
+#if defined(CONFIG_STM_DMA)
+
+	/* The STMicroelectronics DMA-API supports two scatter-gather
+	 * transfer modes:
+	 *  - from scattered memory to a linear memory
+	 *  - from linear memory into scattered memory
+	 * src and dst sg lists should be used for this purpose
+	 * when the correct transfer dimension is specified (see
+	 * include/linux/stm/7100_fdma2.h).
+         */
+
+	/* pointer to the first member of a struct scatterlist *[].
+	 * .dma_address and .length(bytes) fields are required for
+	 * each element.  The .dma_address must be specified in P3.
+	 * If in src scattered mode, use the src_sg member, and the
+	 * dst_sg member for destination scattered mode
+	 */
+	struct scatterlist 		*src_sg;
+	struct scatterlist  	   	*dst_sg;
+
+	/* specifies the scatterlist length in number of elements for
+	 * src and dst scatter - gather transfers respectively */
+	unsigned long 			src_sg_len;
+	unsigned long 			dst_sg_len;
+
+	/* a pointer to a callback function of type void foo(void*)
+	 * which will be called on completion of the entire
+	 * transaction or after each transfer suceeds if
+	 * NODE_PAUSE_ISR is specifed */
+	void				(*comp_callback)(void*);
+	void				*comp_callback_param;
+
+	/* a pointer to a callback function of type void foo(void*)
+	 * which will be called upon failure of a transfer or
+	 * transaction*/
+	void				(*err_callback)(void*);
+	void				*err_callback_param;
+
+	/*size in bytes of the source location*/
+	unsigned long 			src_sz;
+
+	/*size in bytes of the destination location*/
+	unsigned long 			dst_sz;
+
+	/*Source location line stride for use in 0/1/2 x 2D modes*/
+	unsigned long 			sstride;
+
+	/*Source location line stride for use in 2D x 0/1/2 modes*/
+	unsigned long 			dstride;
+
+	/*specifies the additional data for spdif formatting when running in SPDIF bus paced mode*/
+	spdif_data				spdif;
+
+	/*specifies the additional data for spdif formatting when running in PES_SCD bus paced mode
+	 * - currently unsupported*/
+	void* 				pes;
+
+	/* number of elements of a linked list transfer.
+	 * Must be set to 1 in any SG or single shot mode*/
+	unsigned long 			list_len;
+#endif
+ 	/* Gives the setup mode flags of each channel:
+ 	 * --Should include at least one dimensionality specifier.
+ 	 * --Should include either LIST_TYPE_LINKED or LIST_TYPE_UNLINKED
+ 	 * --Should specify NODE_PAUSE_ISR if you wish the FDMA engine
+ 	 *  to pause and callback between each element of an llu
+ 	 * ( comp_callback member must be specified in this case)
+ 	 * --If running in paced mode should also include the paced channnel number.
+ 	 * --Should specify FDMA_SETUP_NOBLOCK if you do not wish for the dma_configure()
+ 	 * function to block if the channel is busy.*/
 	unsigned long flags;
+
+	/*internal locking variables -> do not modify at runtime*/
 	atomic_t busy;
 
 	struct semaphore sem;
@@ -108,8 +222,6 @@
 #define to_dma_channel(channel) container_of(channel, struct dma_channel, dev)
 
 /* arch/sh/drivers/dma/dma-api.c */
-extern int dma_xfer(unsigned int chan, unsigned long from,
-		    unsigned long to, size_t size, unsigned int mode);
 
 #define dma_write(chan, from, to, size)	\
 	dma_xfer(chan, from, to, size, DMA_MODE_WRITE)
@@ -127,8 +239,22 @@
 extern struct dma_info *get_dma_info(unsigned int chan);
 extern struct dma_channel *get_dma_channel(unsigned int chan);
 extern void dma_wait_for_completion(unsigned int chan);
+
+#ifdef CONFIG_STM_DMA
+extern int dma_configure_channel(struct dma_channel* channel);
+extern int dma_xfer(unsigned int chan);
+
+#else
+extern int dma_xfer(unsigned int chan, unsigned long from,
+		    unsigned long to, size_t size, unsigned int mode);
 extern void dma_configure_channel(unsigned int chan, unsigned long flags);
+#endif
 
+/*here the additions for stb7100 fdma*/
+extern int dma_pause_channel(int flags,unsigned int chan);
+extern void dma_unpause_channel(unsigned int chan);
+extern int dma_stop_channel(unsigned int chan);
+/*---*/
 extern int register_dmac(struct dma_info *info);
 extern void unregister_dmac(struct dma_info *info);
 
diff -Naur linux-2.6.17.8/include/asm-sh/flat.h linux-2.6.17.8-sh/include/asm-sh/flat.h
--- linux-2.6.17.8/include/asm-sh/flat.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/flat.h	2006-08-23 13:29:28.491370000 +0100
@@ -13,7 +13,7 @@
 #define __ASM_SH_FLAT_H
 
 #define	flat_stack_align(sp)			/* nothing needed */
-#define	flat_argvp_envp_on_stack()		1
+#define	flat_argvp_envp_on_stack()		0
 #define	flat_old_ram_flag(flags)		(flags)
 #define	flat_reloc_valid(reloc, size)		((reloc) <= (size))
 #define	flat_get_addr_from_rp(rp, relval, flags)	get_unaligned(rp)
diff -Naur linux-2.6.17.8/include/asm-sh/harp/harp.h linux-2.6.17.8-sh/include/asm-sh/harp/harp.h
--- linux-2.6.17.8/include/asm-sh/harp/harp.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/harp/harp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* 
- * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
- *
- * Defintions applicable to the STMicroelectronics ST40STB1 HARP and
- * compatible boards.
- */
-
-#if defined(CONFIG_SH_STB1_HARP)
-
-#define EPLD_BASE     0xa0800000
-
-#define EPLD_LED      (EPLD_BASE+0x000c0000)
-#define EPLD_INTSTAT0 (EPLD_BASE+0x00200000)
-#define EPLD_INTSTAT1 (EPLD_BASE+0x00240000)
-#define EPLD_INTMASK0 (EPLD_BASE+0x00280000)
-#define EPLD_INTMASK1 (EPLD_BASE+0x002c0000)
-#define EPLD_PAGEADDR (EPLD_BASE+0x00300000)
-#define EPLD_REVID1   (EPLD_BASE+0x00380000)
-#define EPLD_REVID2   (EPLD_BASE+0x003c0000)
-
-#define EPLD_LED_ON  1
-#define EPLD_LED_OFF 0
-
-#elif defined(CONFIG_SH_STB1_OVERDRIVE)
-
-#define EPLD_BASE     0xa7000000
-
-#define EPLD_REVID    (EPLD_BASE+0x00000000)
-#define EPLD_LED      (EPLD_BASE+0x00040000)
-#define EPLD_INTMASK0 (EPLD_BASE+0x001c0000)
-#define EPLD_INTMASK1 (EPLD_BASE+0x00200000)
-#define EPLD_INTSTAT0 (EPLD_BASE+0x00240000)
-#define EPLD_INTSTAT1 (EPLD_BASE+0x00280000)
-
-#define EPLD_LED_ON  0
-#define EPLD_LED_OFF 1
-
-#else
-#error Unknown board
-#endif
diff -Naur linux-2.6.17.8/include/asm-sh/harp/io.h linux-2.6.17.8-sh/include/asm-sh/harp/io.h
--- linux-2.6.17.8/include/asm-sh/harp/io.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/harp/io.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-#ifndef __ASM_SH_HARP_IO_H
-#define __ASM_SH_HARP_IO_H
-
-/*
- * Nothing special here.. just use the generic cchip io routines.
- */
-#include <asm/hd64465/io.h>
-
-#endif /* __ASM_SH_HARP_IO_H */
-
diff -Naur linux-2.6.17.8/include/asm-sh/hd64461.h linux-2.6.17.8-sh/include/asm-sh/hd64461.h
--- linux-2.6.17.8/include/asm-sh/hd64461.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hd64461.h	2006-08-23 13:29:22.095208000 +0100
@@ -0,0 +1,208 @@
+#ifndef __ASM_SH_HD64461
+#define __ASM_SH_HD64461
+/*
+ *	$Id: hd64461.h,v 1.5 2004/03/16 00:07:51 lethal Exp $
+ *	Copyright (C) 2000 YAEGASHI Takeshi
+ *	Hitachi HD64461 companion chip support
+ */
+
+/* Constants for PCMCIA mappings */
+#define HD64461_PCC_WINDOW	0x01000000
+
+#define HD64461_PCC0_BASE	0xb8000000	/* area 6 */
+#define HD64461_PCC0_ATTR	(HD64461_PCC0_BASE)
+#define HD64461_PCC0_COMM	(HD64461_PCC0_BASE+HD64461_PCC_WINDOW)
+#define HD64461_PCC0_IO		(HD64461_PCC0_BASE+2*HD64461_PCC_WINDOW)
+
+#define HD64461_PCC1_BASE	0xb4000000	/* area 5 */
+#define HD64461_PCC1_ATTR	(HD64461_PCC1_BASE)
+#define HD64461_PCC1_COMM	(HD64461_PCC1_BASE+HD64461_PCC_WINDOW)
+
+#define HD64461_STBCR	0x10000
+#define HD64461_STBCR_CKIO_STBY			0x2000
+#define HD64461_STBCR_SAFECKE_IST		0x1000
+#define HD64461_STBCR_SLCKE_IST			0x0800
+#define HD64461_STBCR_SAFECKE_OST		0x0400
+#define HD64461_STBCR_SLCKE_OST			0x0200
+#define HD64461_STBCR_SMIAST			0x0100
+#define HD64461_STBCR_SLCDST			0x0080
+#define HD64461_STBCR_SPC0ST			0x0040
+#define HD64461_STBCR_SPC1ST			0x0020
+#define HD64461_STBCR_SAFEST			0x0010
+#define HD64461_STBCR_STM0ST			0x0008
+#define HD64461_STBCR_STM1ST			0x0004
+#define HD64461_STBCR_SIRST				0x0002
+#define HD64461_STBCR_SURTST			0x0001
+
+#define HD64461_SYSCR	0x10002
+#define HD64461_SCPUCR	0x10004
+
+#define HD64461_LCDCBAR		0x11000
+#define HD64461_LCDCLOR		0x11002
+#define HD64461_LCDCCR		0x11004
+#define HD64461_LCDCCR_STBACK	0x0400
+#define HD64461_LCDCCR_STREQ	0x0100
+#define HD64461_LCDCCR_MOFF	0x0080
+#define HD64461_LCDCCR_REFSEL	0x0040
+#define HD64461_LCDCCR_EPON	0x0020
+#define HD64461_LCDCCR_SPON	0x0010
+
+#define	HD64461_LDR1		0x11010
+#define	HD64461_LDR1_DON	0x01
+#define	HD64461_LDR1_DINV	0x80
+
+#define	HD64461_LDR2		0x11012
+#define	HD64461_LDHNCR		0x11014
+#define	HD64461_LDHNSR		0x11016
+#define HD64461_LDVNTR		0x11018
+#define HD64461_LDVNDR		0x1101a
+#define HD64461_LDVSPR		0x1101c
+#define HD64461_LDR3		0x1101e
+
+#define HD64461_CPTWAR		0x11030
+#define HD64461_CPTWDR		0x11032
+#define HD64461_CPTRAR		0x11034
+#define HD64461_CPTRDR		0x11036
+
+#define HD64461_GRDOR		0x11040
+#define HD64461_GRSCR		0x11042
+#define HD64461_GRCFGR		0x11044
+#define HD64461_GRCFGR_ACCSTATUS		0x10
+#define HD64461_GRCFGR_ACCRESET			0x08
+#define HD64461_GRCFGR_ACCSTART_BITBLT	0x06
+#define HD64461_GRCFGR_ACCSTART_LINE	0x04
+#define HD64461_GRCFGR_COLORDEPTH16		0x01
+
+#define HD64461_LNSARH		0x11046
+#define HD64461_LNSARL		0x11048
+#define HD64461_LNAXLR		0x1104a
+#define HD64461_LNDGR		0x1104c
+#define HD64461_LNAXR		0x1104e
+#define HD64461_LNERTR		0x11050
+#define HD64461_LNMDR		0x11052
+#define HD64461_BBTSSARH	0x11054
+#define HD64461_BBTSSARL	0x11056
+#define HD64461_BBTDSARH	0x11058
+#define HD64461_BBTDSARL	0x1105a
+#define HD64461_BBTDWR		0x1105c
+#define HD64461_BBTDHR		0x1105e
+#define HD64461_BBTPARH		0x11060
+#define HD64461_BBTPARL		0x11062
+#define HD64461_BBTMARH		0x11064
+#define HD64461_BBTMARL		0x11066
+#define HD64461_BBTROPR		0x11068
+#define HD64461_BBTMDR		0x1106a
+
+/* PC Card Controller Registers */
+#define HD64461_PCC0ISR         0x12000 /* socket 0 interface status */
+#define HD64461_PCC0GCR         0x12002 /* socket 0 general control */
+#define HD64461_PCC0CSCR        0x12004 /* socket 0 card status change */
+#define HD64461_PCC0CSCIER      0x12006 /* socket 0 card status change interrupt enable */
+#define HD64461_PCC0SCR         0x12008 /* socket 0 software control */
+#define HD64461_PCC1ISR         0x12010 /* socket 1 interface status */
+#define HD64461_PCC1GCR         0x12012 /* socket 1 general control */
+#define HD64461_PCC1CSCR        0x12014 /* socket 1 card status change */
+#define HD64461_PCC1CSCIER      0x12016 /* socket 1 card status change interrupt enable */
+#define HD64461_PCC1SCR         0x12018 /* socket 1 software control */
+
+/* PCC Interface Status Register */
+#define HD64461_PCCISR_READY		0x80	/* card ready */
+#define HD64461_PCCISR_MWP		0x40	/* card write-protected */
+#define HD64461_PCCISR_VS2		0x20	/* voltage select pin 2 */
+#define HD64461_PCCISR_VS1		0x10	/* voltage select pin 1 */
+#define HD64461_PCCISR_CD2		0x08	/* card detect 2 */
+#define HD64461_PCCISR_CD1		0x04	/* card detect 1 */
+#define HD64461_PCCISR_BVD2		0x02	/* battery 1 */
+#define HD64461_PCCISR_BVD1		0x01	/* battery 1 */
+
+#define HD64461_PCCISR_PCD_MASK		0x0c    /* card detect */
+#define HD64461_PCCISR_BVD_MASK		0x03    /* battery voltage */
+#define HD64461_PCCISR_BVD_BATGOOD	0x03    /* battery good */
+#define HD64461_PCCISR_BVD_BATWARN	0x01    /* battery low warning */
+#define HD64461_PCCISR_BVD_BATDEAD1	0x02    /* battery dead */
+#define HD64461_PCCISR_BVD_BATDEAD2	0x00    /* battery dead */
+
+/* PCC General Control Register */
+#define HD64461_PCCGCR_DRVE		0x80    /* output drive */
+#define HD64461_PCCGCR_PCCR		0x40    /* PC card reset */
+#define HD64461_PCCGCR_PCCT		0x20    /* PC card type, 1=IO&mem, 0=mem */
+#define HD64461_PCCGCR_VCC0		0x10    /* voltage control pin VCC0SEL0 */
+#define HD64461_PCCGCR_PMMOD		0x08    /* memory mode */
+#define HD64461_PCCGCR_PA25		0x04    /* pin A25 */
+#define HD64461_PCCGCR_PA24		0x02    /* pin A24 */
+#define HD64461_PCCGCR_REG		0x01    /* pin PCC0REG# */
+
+/* PCC Card Status Change Register */
+#define HD64461_PCCCSCR_SCDI		0x80    /* sw card detect intr */
+#define HD64461_PCCCSCR_SRV1		0x40    /* reserved */
+#define HD64461_PCCCSCR_IREQ		0x20    /* IREQ intr req */
+#define HD64461_PCCCSCR_SC		0x10    /* STSCHG (status change) pin */
+#define HD64461_PCCCSCR_CDC		0x08    /* CD (card detect) change */
+#define HD64461_PCCCSCR_RC		0x04    /* READY change */
+#define HD64461_PCCCSCR_BW		0x02    /* battery warning change */
+#define HD64461_PCCCSCR_BD		0x01    /* battery dead change */
+
+/* PCC Card Status Change Interrupt Enable Register */
+#define HD64461_PCCCSCIER_CRE		0x80    /* change reset enable */
+#define HD64461_PCCCSCIER_IREQE_MASK	0x60   /* IREQ enable */
+#define HD64461_PCCCSCIER_IREQE_DISABLED	0x00   /* IREQ disabled */
+#define HD64461_PCCCSCIER_IREQE_LEVEL	0x20   /* IREQ level-triggered */
+#define HD64461_PCCCSCIER_IREQE_FALLING	0x40   /* IREQ falling-edge-trig */
+#define HD64461_PCCCSCIER_IREQE_RISING	0x60   /* IREQ rising-edge-trig */
+
+#define HD64461_PCCCSCIER_SCE		0x10    /* status change enable */
+#define HD64461_PCCCSCIER_CDE		0x08    /* card detect change enable */
+#define HD64461_PCCCSCIER_RE		0x04    /* ready change enable */
+#define HD64461_PCCCSCIER_BWE		0x02    /* battery warn change enable */
+#define HD64461_PCCCSCIER_BDE		0x01    /* battery dead change enable*/
+
+/* PCC Software Control Register */
+#define HD64461_PCCSCR_VCC1		0x02	/* voltage control pin 1 */
+#define HD64461_PCCSCR_SWP		0x01    /* write protect */
+
+#define HD64461_P0OCR           0x1202a
+#define HD64461_P1OCR           0x1202c
+#define HD64461_PGCR            0x1202e
+
+#define HD64461_GPACR		0x14000
+#define HD64461_GPBCR		0x14002
+#define HD64461_GPCCR		0x14004
+#define HD64461_GPDCR		0x14006
+#define HD64461_GPADR		0x14010
+#define HD64461_GPBDR		0x14012
+#define HD64461_GPCDR		0x14014
+#define HD64461_GPDDR		0x14016
+#define HD64461_GPAICR		0x14020
+#define HD64461_GPBICR		0x14022
+#define HD64461_GPCICR		0x14024
+#define HD64461_GPDICR		0x14026
+#define HD64461_GPAISR		0x14040
+#define HD64461_GPBISR		0x14042
+#define HD64461_GPCISR		0x14044
+#define HD64461_GPDISR		0x14046
+
+#define HD64461_NIRR		0x15000
+#define HD64461_NIMR		0x15002
+
+#define HD64461_IRQBASE		OFFCHIP_IRQ_BASE
+#define HD64461_IRQ_NUM		16
+
+#define HD64461_IRQ_UART	(HD64461_IRQBASE+5)
+#define HD64461_IRQ_IRDA	(HD64461_IRQBASE+6)
+#define HD64461_IRQ_TMU1	(HD64461_IRQBASE+9)
+#define HD64461_IRQ_TMU0	(HD64461_IRQBASE+10)
+#define HD64461_IRQ_GPIO	(HD64461_IRQBASE+11)
+#define HD64461_IRQ_AFE		(HD64461_IRQBASE+12)
+#define HD64461_IRQ_PCC1	(HD64461_IRQBASE+13)
+#define HD64461_IRQ_PCC0	(HD64461_IRQBASE+14)
+
+#define __IO_PREFIX	hd64461
+#include <asm/io_generic.h>
+
+/* arch/sh/cchips/hd6446x/hd64461/setup.c */
+int hd64461_irq_demux(int irq);
+void hd64461_register_irq_demux(int irq,
+				int (*demux) (int irq, void *dev), void *dev);
+void hd64461_unregister_irq_demux(int irq);
+
+#endif
diff -Naur linux-2.6.17.8/include/asm-sh/hd64465/gpio.h linux-2.6.17.8-sh/include/asm-sh/hd64465/gpio.h
--- linux-2.6.17.8/include/asm-sh/hd64465/gpio.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hd64465/gpio.h	2006-08-23 13:29:29.772392000 +0100
@@ -11,7 +11,7 @@
  * by Greg Banks <gbanks@pocketpenguins.com>
  * (c) 2000 PocketPenguins Inc.
  */
-#include <asm/hd64465.h>
+#include <asm/hd64465/hd64465.h>
 
 /* Macro to construct a portpin number (used in all
  * subsequent functions) from a port letter and a pin
diff -Naur linux-2.6.17.8/include/asm-sh/hd64465/io.h linux-2.6.17.8-sh/include/asm-sh/hd64465/io.h
--- linux-2.6.17.8/include/asm-sh/hd64465/io.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hd64465/io.h	2006-08-23 13:29:29.788392000 +0100
@@ -27,6 +27,13 @@
 extern unsigned char hd64465_inb_p(unsigned long port);
 extern void hd64465_outb_p(unsigned char value, unsigned long port);
 
+extern void hd64465_insb(unsigned long port, void *addr, unsigned long count);
+extern void hd64465_insw(unsigned long port, void *addr, unsigned long count);
+extern void hd64465_insl(unsigned long port, void *addr, unsigned long count);
+extern void hd64465_outsb(unsigned long port, const void *addr, unsigned long count);
+extern void hd64465_outsw(unsigned long port, const void *addr, unsigned long count);
+extern void hd64465_outsl(unsigned long port, const void *addr, unsigned long count);
+
 extern unsigned long hd64465_isa_port2addr(unsigned long offset);
 extern int hd64465_irq_demux(int irq);
 /* Provision for generic secondary demux step -- used by PCMCIA code */
diff -Naur linux-2.6.17.8/include/asm-sh/hp6xx/hp6xx.h linux-2.6.17.8-sh/include/asm-sh/hp6xx/hp6xx.h
--- linux-2.6.17.8/include/asm-sh/hp6xx/hp6xx.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hp6xx/hp6xx.h	2006-08-23 13:29:22.178235000 +0100
@@ -2,16 +2,33 @@
 #define __ASM_SH_HP6XX_H
 
 /*
- * Copyright (C) 2003  Andriy Skulysh
+ * Copyright (C) 2003, 2004, 2005  Andriy Skulysh
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
  */
 
-#define HP680_TS_IRQ IRQ3_IRQ
+#define HP680_BTN_IRQ		IRQ0_IRQ
+#define HP680_TS_IRQ		IRQ3_IRQ
+#define HP680_HD64461_IRQ	IRQ4_IRQ
 
 #define DAC_LCD_BRIGHTNESS	0
 #define DAC_SPEAKER_VOLUME	1
 
+#define PGDR_OPENED		0x01
+#define PGDR_MAIN_BATTERY_OUT	0x04
+#define PGDR_PLAY_BUTTON	0x08
+#define PGDR_REWIND_BUTTON	0x10
+#define PGDR_RECORD_BUTTON	0x20
+
 #define PHDR_TS_PEN_DOWN	0x08
 
+#define PJDR_LED_BLINK		0x02
+
+#define PKDR_LED_GREEN		0x10
+
 #define SCPDR_TS_SCAN_ENABLE	0x20
 #define SCPDR_TS_SCAN_Y		0x02
 #define SCPDR_TS_SCAN_X		0x01
@@ -21,11 +38,43 @@
 
 #define ADC_CHANNEL_TS_Y	1
 #define ADC_CHANNEL_TS_X	2
+#define ADC_CHANNEL_BATTERY	3
+#define ADC_CHANNEL_BACKUP	4
+#define ADC_CHANNEL_CHARGE	5
 
 #define HD64461_GPADR_SPEAKER	0x01
 #define HD64461_GPADR_PCMCIA0	(0x02|0x08)
+
 #define HD64461_GPBDR_LCDOFF	0x01
+#define HD64461_GPBDR_LCD_CONTRAST_MASK	0x78
 #define HD64461_GPBDR_LED_RED	0x80
 
+#include <asm/hd64461.h>
+#include <asm/io.h>
+
+#define PJDR	0xa4000130
+#define PKDR	0xa4000132
+
+static inline void hp6xx_led_red(int on)
+{
+	u16 v16;
+	v16 = ctrl_inw(CONFIG_HD64461_IOBASE + HD64461_GPBDR - 0x10000);
+	if (on)
+	    ctrl_outw(v16 & (~HD64461_GPBDR_LED_RED), CONFIG_HD64461_IOBASE + HD64461_GPBDR - 0x10000);
+	else
+	    ctrl_outw(v16 | HD64461_GPBDR_LED_RED, CONFIG_HD64461_IOBASE + HD64461_GPBDR - 0x10000);
+}
+
+static inline void hp6xx_led_green(int on)
+{
+	u8 v8;
+
+	v8 = ctrl_inb(PKDR);
+	if (on)
+	    ctrl_outb(v8 & (~PKDR_LED_GREEN), PKDR);
+	else
+	    ctrl_outb(v8 | PKDR_LED_GREEN, PKDR);
+}
+
 
 #endif /* __ASM_SH_HP6XX_H */
diff -Naur linux-2.6.17.8/include/asm-sh/hp6xx/io.h linux-2.6.17.8-sh/include/asm-sh/hp6xx/io.h
--- linux-2.6.17.8/include/asm-sh/hp6xx/io.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hp6xx/io.h	2006-08-23 13:29:17.861119000 +0100
@@ -4,7 +4,7 @@
 /*
  * Nothing special here.. just use the generic cchip io routines.
  */
-#include <asm/hd64461/io.h>
+#include <asm/hd64461.h>
 
 #endif /* __ASM_SH_HP6XX_IO_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/hs7751rvoip/hs7751rvoip.h linux-2.6.17.8-sh/include/asm-sh/hs7751rvoip/hs7751rvoip.h
--- linux-2.6.17.8/include/asm-sh/hs7751rvoip/hs7751rvoip.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/hs7751rvoip/hs7751rvoip.h	2006-08-23 13:29:21.473208000 +0100
@@ -19,8 +19,6 @@
 #define PA_OUTPORTR	0xa400000e	/* Output Port Reguster */
 #define PA_VERREG	0xa4000014	/* FPGA Version Register */
 
-#define PA_AREA5_IO	0xb4000000	/* Area 5 IO Memory */
-#define PA_AREA6_IO	0xb8000000	/* Area 6 IO Memory */
 #define PA_IDE_OFFSET	0x1f0		/* CF IDE Offset */
 
 #define IRLCNTR1	(PA_BCR + 0)	/* Interrupt Control Register1 */
@@ -44,4 +42,13 @@
 #define	IRQ_RINGING	4		/* Ringing IRQ */
 #define	IRQ_CODEC	5		/* CODEC IRQ */
 
+#define __IO_PREFIX	hs7751rvoip
+#include <asm/io_generic.h>
+
+/* arch/sh/boards/renesas/hs7751rvoip/irq.c */
+void init_hs7751rvoip_IRQ(void);
+
+/* arch/sh/boards/renesas/hs7751rvoip/io.c */
+void *hs7751rvoip_ioremap(unsigned long, unsigned long);
+
 #endif  /* __ASM_SH_RENESAS_HS7751RVOIP */
diff -Naur linux-2.6.17.8/include/asm-sh/ide.h linux-2.6.17.8-sh/include/asm-sh/ide.h
--- linux-2.6.17.8/include/asm-sh/ide.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/ide.h	2006-08-23 13:29:38.778599000 +0100
@@ -16,10 +16,69 @@
 
 #include <linux/config.h>
 
+#ifdef CONFIG_BLK_DEV_ST40IDE
+#include <asm/st40core_ide.h>
+#endif
+
 #define ide_default_io_ctl(base)	(0)
 
+
 #include <asm-generic/ide_iops.h>
 
+/* IDE code reads and writes directly to user space buffers via
+ * kernel logical addresses, with no explicit cache synchronization.
+ * Insert explicit cache flushes as required.
+ * This uses the same technique as the Sparc64.
+ */
+#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SH_CACHE_DISABLE)
+
+#ifdef insl
+#undef insl
+#endif
+#ifdef outsl
+#undef outsl
+#endif
+#ifdef insw
+#undef insw
+#endif
+#ifdef outsw
+#undef outsw
+#endif
+
+#define wrap_in(op)					\
+static __inline__ void sh_ide_##op(unsigned long port,	\
+				void *buffer,		\
+				unsigned long count,	\
+				unsigned long nbytes)	\
+{							\
+	__##op(port, buffer, count);			\
+	__flush_wback_region(buffer, nbytes);		\
+}
+
+wrap_in(insw)
+wrap_in(insl)
+#define insw(port, buffer, count) sh_ide_insw((port), (buffer), (count), (count)<<1)
+#define insl(port, buffer, count) sh_ide_insl((port), (buffer), (count), (count)<<2)
+#undef wrap_in
+
+#define wrap_out(op)					\
+static __inline__ void sh_ide_##op(unsigned long port,	\
+				void *buffer,		\
+				unsigned long count,	\
+				unsigned long nbytes)	\
+{							\
+	__##op(port, buffer, count);			\
+	/* __flush_wback_region(buffer, nbytes); */		\
+}
+
+wrap_out(outsw)
+wrap_out(outsl)
+#define outsw(port, buffer, count) sh_ide_outsw((port), (buffer), (count), (count)<<1)
+#define outsl(port, buffer, count) sh_ide_outsl((port), (buffer), (count), (count)<<2)
+#undef wrap_out
+
+#endif /* CONFIG_CPU_SH4 && !CONFIG_SH_CACHE_DISABLE */
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASM_SH_IDE_H */
diff -Naur linux-2.6.17.8/include/asm-sh/io.h linux-2.6.17.8-sh/include/asm-sh/io.h
--- linux-2.6.17.8/include/asm-sh/io.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/io.h	2006-08-23 13:29:35.474530000 +0100
@@ -108,6 +108,9 @@
 #define __raw_writew(v, a)	__writew(v, (void __iomem *)(a))
 #define __raw_writel(v, a)	__writel(v, (void __iomem *)(a))
 
+void __raw_writesl(void __iomem *addr, const void *data, int longlen);
+void __raw_readsl(const void __iomem *addr, void *data, int longlen);
+
 /*
  * The platform header files may define some of these macros to use
  * the inlined versions where appropriate.  These macros may also be
@@ -133,6 +136,9 @@
 # define writel(v,a)	({ __raw_writel((v),(a)); mb(); })
 #endif
 
+#define writesl __raw_writesl
+#define readsl  __raw_readsl
+
 #define readb_relaxed(a) readb(a)
 #define readw_relaxed(a) readw(a)
 #define readl_relaxed(a) readl(a)
@@ -210,8 +216,14 @@
         *(volatile unsigned long*)addr = b;
 }
 
+static inline void ctrl_delay(void)
+{
+	ctrl_inw(P2SEG);
+}
+
 #define IO_SPACE_LIMIT 0xffffffff
 
+#ifdef CONFIG_MMU
 /*
  * Change virtual addresses to physical addresses and vv.
  * These are trivial on the 1:1 Linux/SuperH mapping
@@ -225,6 +237,10 @@
 {
 	return (void *)P1SEGADDR(address);
 }
+#else
+#define phys_to_virt(address)	((void *)(address))
+#define virt_to_phys(address)	((unsigned long)(address))
+#endif
 
 #define virt_to_bus virt_to_phys
 #define bus_to_virt phys_to_virt
diff -Naur linux-2.6.17.8/include/asm-sh/irq.h linux-2.6.17.8-sh/include/asm-sh/irq.h
--- linux-2.6.17.8/include/asm-sh/irq.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/irq.h	2006-08-23 13:29:49.542852000 +0100
@@ -36,8 +36,36 @@
 #define INTC_IPRA	0xffd00004UL
 #define INTC_IPRB	0xffd00008UL
 #define INTC_IPRC	0xffd0000cUL
-#define INTC_IPRD	0xffd00010UL
-#endif
+#define INTC_IPRD	0xffd00010UL	/* Not on plain 7750 */
+
+/*
+ * The notIRL0 to notIRL3 pins can be configured as four independent
+ * interrupts by setting INTC_ICR.IRLM. The IRQ numbers are fixed.
+ * Note that the priority is fixed on the original 7750, it can be
+ * set on the 7750S and 7750R, and all 7751 and ST40 parts.
+ */
+
+#define IRL0_IRQ		2
+#define IRL0_IPR_ADDR	INTC_IPRD
+#define IRL0_IPR_POS	3
+#define IRL0_PRIORITY	13
+
+#define IRL1_IRQ		5
+#define IRL1_IPR_ADDR	INTC_IPRD
+#define IRL1_IPR_POS	2
+#define IRL1_PRIORITY	10
+
+#define IRL2_IRQ		8
+#define IRL2_IPR_ADDR	INTC_IPRD
+#define IRL2_IPR_POS	1
+#define IRL2_PRIORITY	7
+
+#define IRL3_IRQ		11
+#define IRL3_IPR_ADDR	INTC_IPRD
+#define IRL3_IPR_POS	0
+#define IRL3_PRIORITY	4
+
+#endif /* __SH4__ */
 
 #ifdef CONFIG_IDE
 # ifndef IRQ_CFCARD
@@ -226,7 +254,7 @@
 #define IRDA_IPR_POS	2
 #define IRDA_PRIORITY	3
 #elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-      defined(CONFIG_CPU_SUBTYPE_ST40STB1) || defined(CONFIG_CPU_SUBTYPE_SH4_202)
+      defined(CONFIG_CPU_SUBTYPE_ST40) || defined(CONFIG_CPU_SUBTYPE_SH4_202)
 #define SCIF_ERI_IRQ	40
 #define SCIF_RXI_IRQ	41
 #define SCIF_BRI_IRQ	42
@@ -234,7 +262,7 @@
 #define SCIF_IPR_ADDR	INTC_IPRC
 #define SCIF_IPR_POS	1
 #define SCIF_PRIORITY	3
-#if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#if defined(CONFIG_CPU_SUBTYPE_ST40)
 #define SCIF1_ERI_IRQ	23
 #define SCIF1_RXI_IRQ	24
 #define SCIF1_BRI_IRQ	25
@@ -275,6 +303,11 @@
 # define ONCHIP_NR_IRQS 72
 #elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
 # define ONCHIP_NR_IRQS 144
+#elif defined(CONFIG_CPU_SUBTYPE_ST40GX1) || \
+      defined(CONFIG_CPU_SUBTYPE_STI5528) || \
+      defined(CONFIG_CPU_SUBTYPE_STM8000) || \
+      defined(CONFIG_CPU_SUBTYPE_STB7100)
+#  define ONCHIP_NR_IRQS 176
 #elif defined(CONFIG_CPU_SUBTYPE_SH7300) || \
       defined(CONFIG_CPU_SUBTYPE_SH73180)
 # define ONCHIP_NR_IRQS 109
@@ -282,6 +315,8 @@
 # define ONCHIP_NR_IRQS 111
 #elif defined(CONFIG_SH_UNKNOWN)	/* Most be last */
 # define ONCHIP_NR_IRQS 144
+#else
+#  error Unknown chip
 #endif
 
 /* 2. PINT_NR_IRQS */
@@ -312,6 +347,10 @@
 # define OFFCHIP_NR_IRQS 4
 #elif defined(CONFIG_SH_R7780RP)
 # define OFFCHIP_NR_IRQS 16
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+# define ILC_FIRST_IRQ OFFCHIP_IRQ_BASE
+# define ILC_NR_IRQS  60
+# define OFFCHIP_NR_IRQS ILC_NR_IRQS
 #elif defined(CONFIG_SH_UNKNOWN)
 # define OFFCHIP_NR_IRQS 16	/* Must also be last */
 #else
@@ -336,6 +375,11 @@
 extern unsigned short *irq_mask_register;
 
 /*
+ * PINT IRQs
+ */
+void init_IRQ_pint(void);
+
+/*
  * Function for "on chip support modules".
  */
 extern void make_ipr_irq(unsigned int irq, unsigned int addr,
@@ -547,7 +591,7 @@
 #endif /* CONFIG_CPU_SUBTYPE_SH7707 || CONFIG_CPU_SUBTYPE_SH7709 */
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-    defined(CONFIG_CPU_SUBTYPE_ST40STB1) || defined(CONFIG_CPU_SUBTYPE_SH4_202)
+    defined(CONFIG_CPU_SUBTYPE_ST40) || defined(CONFIG_CPU_SUBTYPE_SH4_202)
 #define INTC_ICR        0xffd00000
 #define INTC_ICR_NMIL	(1<<15)
 #define INTC_ICR_MAI	(1<<14)
@@ -563,28 +607,40 @@
 /* SH with INTC2-style interrupts */
 #ifdef CONFIG_CPU_HAS_INTC2_IRQ
 #if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
-#define INTC2_BASE	0xfe080000
 #define INTC2_FIRST_IRQ 64
-#define INTC2_INTREQ_OFFSET	0x20
-#define INTC2_INTMSK_OFFSET	0x40
-#define INTC2_INTMSKCLR_OFFSET	0x60
-#define NR_INTC2_IRQS	25
+#define NR_INTC2_IRQS	80
+#elif defined(CONFIG_CPU_SUBTYPE_ST40GX1) || \
+      defined(CONFIG_CPU_SUBTYPE_STI5528)
+#define INTC2_FIRST_IRQ 64
+#define NR_INTC2_IRQS	112
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+#define INTC2_FIRST_IRQ 112
+#define NR_INTC2_IRQS	64
+#elif defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define INTC2_BASE	0xB9001300
+#define INTC2_FIRST_IRQ	64
+#define NR_INTC2_IRQS	112
 #elif defined(CONFIG_CPU_SUBTYPE_SH7760)
-#define INTC2_BASE	0xfe080000
 #define INTC2_FIRST_IRQ 48	/* INTEVT 0x800 */
-#define INTC2_INTREQ_OFFSET	0x20
-#define INTC2_INTMSK_OFFSET	0x40
-#define INTC2_INTMSKCLR_OFFSET	0x60
 #define NR_INTC2_IRQS	64
 #elif defined(CONFIG_CPU_SUBTYPE_SH7780)
 #define INTC2_BASE	0xffd40000
-#define INTC2_FIRST_IRQ	22
+#define INTC2_FIRST_IRQ	21
+#define INTC2_INTPRI_OFFSET	0x00
 #define INTC2_INTMSK_OFFSET	(0x38)
 #define INTC2_INTMSKCLR_OFFSET	(0x3c)
 #define NR_INTC2_IRQS	60
 #endif
 
+#ifndef INTC2_BASE
+#define INTC2_BASE	0xfe080000
+#endif
+#ifndef INTC2_INTPRI_OFFSET
 #define INTC2_INTPRI_OFFSET	0x00
+#define INTC2_INTREQ_OFFSET	0x20
+#define INTC2_INTMSK_OFFSET	0x40
+#define INTC2_INTMSKCLR_OFFSET	0x60
+#endif
 
 void make_intc2_irq(unsigned int irq,
 		    unsigned int ipr_offset, unsigned int ipr_shift,
@@ -595,6 +651,17 @@
 
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_STI5528) || defined(CONFIG_CPU_SUBTYPE_STB7100)
+void ilc_route_external(int ilc_irq, int ext_out, int invert);
+#define ILC_EXT_IRQ0	64
+#define ILC_EXT_IRQ1	65
+#define ILC_EXT_IRQ2	66
+#define ILC_EXT_IRQ3	67
+#elif defined(CONFIG_CPU_SUBTYPE_STM8000)
+void init_IRQ_STm8000_ilc(void);
+int stm8000_irq_demux(int irq);
+#endif
+
 static inline int generic_irq_demux(int irq)
 {
 	return irq;
@@ -606,6 +673,10 @@
 #define irq_canonicalize(irq)	(irq)
 #define irq_demux(irq)		__irq_demux(sh_mv.mv_irq_demux(irq))
 
+#if defined(CONFIG_4KSTACKS)
+#define __ARCH_HAS_DO_SOFTIRQ
+#endif
+
 #if defined(CONFIG_CPU_SUBTYPE_SH73180)
 #include <asm/irq-sh73180.h>
 #endif
diff -Naur linux-2.6.17.8/include/asm-sh/irq-sh7780.h linux-2.6.17.8-sh/include/asm-sh/irq-sh7780.h
--- linux-2.6.17.8/include/asm-sh/irq-sh7780.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/irq-sh7780.h	2006-08-23 13:29:27.422347000 +0100
@@ -145,11 +145,6 @@
 #define	TMU_CH5_IPR_POS		1
 #define TMU_CH5_PRIORITY	2
 
-#define	RTC_IRQ		22
-#define	RTC_IPR_ADDR	INTC_INT2PRI1
-#define	RTC_IPR_POS	0
-#define	RTC_PRIORITY	TIMER_PRIORITY
-
 /* SCIF0 */
 #define SCIF0_ERI_IRQ	40
 #define SCIF0_RXI_IRQ	41
diff -Naur linux-2.6.17.8/include/asm-sh/kexec.h linux-2.6.17.8-sh/include/asm-sh/kexec.h
--- linux-2.6.17.8/include/asm-sh/kexec.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/kexec.h	2006-08-23 13:29:26.154312000 +0100
@@ -23,6 +23,8 @@
 /* The native architecture */
 #define KEXEC_ARCH KEXEC_ARCH_SH
 
+#define MAX_NOTE_BYTES 1024
+
 #ifndef __ASSEMBLY__
 
 extern void machine_shutdown(void);
diff -Naur linux-2.6.17.8/include/asm-sh/kgdb.h linux-2.6.17.8-sh/include/asm-sh/kgdb.h
--- linux-2.6.17.8/include/asm-sh/kgdb.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/kgdb.h	2006-08-23 13:29:23.066231000 +0100
@@ -128,4 +128,19 @@
 #define KGDB_ASSERT(condition, message)
 #endif
 
+/* Taken from sh-stub.c of GDB 4.18 */
+static const char hexchars[] = "0123456789abcdef";
+
+/* Get high hex bits */
+static inline char highhex(const int x)
+{
+	return hexchars[(x >> 4) & 0xf];
+}
+
+/* Get low hex bits */
+static inline char lowhex(const int x)
+{
+	return hexchars[x & 0xf];
+}
+
 #endif
diff -Naur linux-2.6.17.8/include/asm-sh/landisk/gio.h linux-2.6.17.8-sh/include/asm-sh/landisk/gio.h
--- linux-2.6.17.8/include/asm-sh/landisk/gio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/landisk/gio.h	2006-08-23 13:29:14.906050000 +0100
@@ -0,0 +1,45 @@
+#ifndef __ASM_SH_LANDISK_GIO_H
+#define __ASM_SH_LANDISK_GIO_H
+
+#include <linux/ioctl.h>
+
+/* version */
+#define VERSION_STR	"1.00"
+
+/* Driver name */
+#define GIO_DRIVER_NAME		"/dev/giodrv"
+
+/* Use 'k' as magic number */
+#define GIODRV_IOC_MAGIC  'k'
+
+#define GIODRV_IOCRESET    _IO(GIODRV_IOC_MAGIC, 0)
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly
+ * G means "Get" (to a pointed var)
+ * Q means "Query", response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define GIODRV_IOCSGIODATA1   _IOW(GIODRV_IOC_MAGIC,  1, unsigned char *)
+#define GIODRV_IOCGGIODATA1   _IOR(GIODRV_IOC_MAGIC,  2, unsigned char *)
+#define GIODRV_IOCSGIODATA2   _IOW(GIODRV_IOC_MAGIC,  3, unsigned short *)
+#define GIODRV_IOCGGIODATA2   _IOR(GIODRV_IOC_MAGIC,  4, unsigned short *)
+#define GIODRV_IOCSGIODATA4   _IOW(GIODRV_IOC_MAGIC,  5, unsigned long *)
+#define GIODRV_IOCGGIODATA4   _IOR(GIODRV_IOC_MAGIC,  6, unsigned long *)
+#define GIODRV_IOCSGIOSETADDR _IOW(GIODRV_IOC_MAGIC,  7, unsigned long *)
+#define GIODRV_IOCHARDRESET   _IO(GIODRV_IOC_MAGIC, 8) /* debugging tool */
+
+#define GIODRV_IOCSGIO_LED    _IOW(GIODRV_IOC_MAGIC,  9, unsigned long *)
+#define GIODRV_IOCGGIO_LED    _IOR(GIODRV_IOC_MAGIC,  10, unsigned long *)
+#define GIODRV_IOCSGIO_BUZZER _IOW(GIODRV_IOC_MAGIC,  11, unsigned long *)
+#define GIODRV_IOCGGIO_LANDISK _IOR(GIODRV_IOC_MAGIC,  14, unsigned long *)
+#define GIODRV_IOCGGIO_BTN _IOR(GIODRV_IOC_MAGIC,  22, unsigned long *)
+#define GIODRV_IOCSGIO_BTNPID _IOW(GIODRV_IOC_MAGIC,  23, unsigned long *)
+#define GIODRV_IOCGGIO_BTNPID _IOR(GIODRV_IOC_MAGIC,  24, unsigned long *)
+
+#define GIODRV_IOC_MAXNR 8
+#define GIO_READ 0x00000000
+#define GIO_WRITE 0x00000001
+
+#endif /* __ASM_SH_LANDISK_GIO_H  */
diff -Naur linux-2.6.17.8/include/asm-sh/landisk/ide.h linux-2.6.17.8-sh/include/asm-sh/landisk/ide.h
--- linux-2.6.17.8/include/asm-sh/landisk/ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/landisk/ide.h	2006-08-23 13:29:14.957050000 +0100
@@ -0,0 +1,14 @@
+/*
+ * modifed by kogiidena
+ * 2005.03.03
+ */
+
+#ifndef __ASM_SH_LANDISK_IDE_H
+#define __ASM_SH_LANDISK_IDE_H
+
+/* Nothing to see here.. */
+#include <asm/landisk/iodata_landisk.h>
+#define IRQ_CFCARD	IRQ_FATA	/* CF Card IRQ */
+#define IRQ_PCMCIA	IRQ_ATA		/* PCMCIA IRQ */
+
+#endif /* __ASM_SH_LANDISK_IDE_H  */
diff -Naur linux-2.6.17.8/include/asm-sh/landisk/iodata_landisk.h linux-2.6.17.8-sh/include/asm-sh/landisk/iodata_landisk.h
--- linux-2.6.17.8/include/asm-sh/landisk/iodata_landisk.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/landisk/iodata_landisk.h	2006-08-23 13:29:21.481208000 +0100
@@ -0,0 +1,79 @@
+#ifndef __ASM_SH_IODATA_LANDISK_H
+#define __ASM_SH_IODATA_LANDISK_H
+
+/*
+ * linux/include/asm-sh/landisk/iodata_landisk.h
+ *
+ * Copyright (C) 2000  Atom Create Engineering Co., Ltd.
+ *
+ * IO-DATA LANDISK support
+ */
+
+/* Box specific addresses.  */
+
+#define PA_USB		0xa4000000	/* USB Controller M66590 */
+
+#define PA_ATARST	0xb0000000	/* ATA/FATA Access Control Register */
+#define PA_LED		0xb0000001	/* LED Control Register */
+#define PA_STATUS	0xb0000002	/* Switch Status Register */
+#define PA_SHUTDOWN	0xb0000003	/* Shutdown Control Register */
+#define PA_PCIPME	0xb0000004	/* PCI PME Status Register */
+#define PA_IMASK	0xb0000005	/* Interrupt Mask Register */
+/* 2003.10.31 I-O DATA NSD NWG	add.	for shutdown port clear */
+#define PA_PWRINT_CLR	0xb0000006	/* Shutdown Interrupt clear Register */
+
+#define PA_LCD_CLRDSP	0x00		/* LCD Clear Display Offset */
+#define PA_LCD_RTNHOME	0x00		/* LCD Return Home Offset */
+#define PA_LCD_ENTMODE	0x00		/* LCD Entry Mode Offset */
+#define PA_LCD_DSPCTL	0x00		/* LCD Display ON/OFF Control Offset */
+#define PA_LCD_FUNC	0x00		/* LCD Function Set Offset */
+#define PA_LCD_CGRAM	0x00		/* LCD Set CGRAM Address Offset */
+#define PA_LCD_DDRAM	0x00		/* LCD Set DDRAM Address Offset */
+#define PA_LCD_RDFLAG	0x01		/* LCD Read Busy Flag Offset */
+#define PA_LCD_WTDATA	0x02		/* LCD Write Datat to RAM Offset */
+#define PA_LCD_RDDATA	0x03		/* LCD Read Data from RAM Offset */
+#define PA_PIDE_OFFSET	0x40		/* CF IDE Offset */
+#define PA_SIDE_OFFSET	0x40		/* HDD IDE Offset */
+
+#define IRQ_PCIINTA	5		/* PCI INTA IRQ */
+#define IRQ_PCIINTB	6		/* PCI INTB IRQ */
+#define IRQ_PCIINDC	7		/* PCI INTC IRQ */
+#define IRQ_PCIINTD	8		/* PCI INTD IRQ */
+#define IRQ_ATA		9		/* ATA IRQ */
+#define IRQ_FATA	10		/* FATA IRQ */
+#define IRQ_POWER	11		/* Power Switch IRQ */
+#define IRQ_BUTTON	12		/* USL-5P Button IRQ */
+#define IRQ_FAULT	13		/* USL-5P Fault  IRQ */
+
+#define SHUTDOWN_BTN_MAJOR	99	/* Shutdown button device major no. */
+
+#define SHUTDOWN_LOOP_CNT	5	/* Shutdown button Detection loop */
+#define SHUTDOWN_DELAY		200	/* Shutdown button delay value(ms) */
+
+
+/* added by kogiidena */
+/*
+ *  landisk_ledparam
+ *
+ * led  ------10 -6543210 -6543210 -6543210
+ *     |000000..|0.......|0.......|U.......|
+ *     |  HARD  |fastblik| blink  |   on   |
+ *
+ *   led0: power       U:update flag
+ *   led1: error
+ *   led2: usb1
+ *   led3: usb2
+ *   led4: usb3
+ *   led5: usb4
+ *   led6: usb5
+ *
+ */
+extern int landisk_ledparam;    /* from setup.c */
+extern int landisk_buzzerparam; /* from setup.c */
+extern int landisk_arch;        /* from setup.c */
+
+#define __IO_PREFIX landisk
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_IODATA_LANDISK_H */
+
diff -Naur linux-2.6.17.8/include/asm-sh/led.h linux-2.6.17.8-sh/include/asm-sh/led.h
--- linux-2.6.17.8/include/asm-sh/led.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/led.h	2006-08-23 13:29:29.803394000 +0100
@@ -0,0 +1,18 @@
+/*
+ * include/asm-sh/led.h
+ *
+ * Copyright (c) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Generic support for LEDs on ST boards.
+ */
+
+#ifndef _STM_LED_H_
+#define _STM_LED_H_ 1
+
+void mach_led(int position, int value);
+
+void heartbeat_heart(void);
+void heartbeat_knightrider(void);
+
+#endif /* _STM_LED_H_  */
diff -Naur linux-2.6.17.8/include/asm-sh/mc146818rtc.h linux-2.6.17.8-sh/include/asm-sh/mc146818rtc.h
--- linux-2.6.17.8/include/asm-sh/mc146818rtc.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/mc146818rtc.h	2006-08-23 13:29:18.984139000 +0100
@@ -24,7 +24,7 @@
 #define CMOS_WRITE(val,addr)	__CMOS_WRITE(val,addr,b)
 
 #elif defined(CONFIG_SH_SECUREEDGE5410)
-#include <asm/snapgear/io.h>
+#include <asm/snapgear.h>
 
 #define RTC_PORT(n)             SECUREEDGE_IOPORT_ADDR
 #define CMOS_READ(addr)         secureedge5410_cmos_read(addr)
diff -Naur linux-2.6.17.8/include/asm-sh/mmu_context.h linux-2.6.17.8-sh/include/asm-sh/mmu_context.h
--- linux-2.6.17.8/include/asm-sh/mmu_context.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/mmu_context.h	2006-08-23 13:29:15.480071000 +0100
@@ -174,9 +174,7 @@
 {
 	/* Enable MMU */
 	ctrl_outl(MMU_CONTROL_INIT, MMUCR);
-
-	/* The manual suggests doing some nops after turning on the MMU */
-	__asm__ __volatile__ ("nop;nop;nop;nop;nop;nop;nop;nop\n\t");
+	ctrl_barrier();
 
 	if (mmu_context_cache == NO_CONTEXT)
 		mmu_context_cache = MMU_CONTEXT_FIRST_VERSION;
@@ -191,7 +189,8 @@
 	cr = ctrl_inl(MMUCR);
 	cr &= ~MMU_CONTROL_INIT;
 	ctrl_outl(cr, MMUCR);
-	__asm__ __volatile__ ("nop;nop;nop;nop;nop;nop;nop;nop\n\t");
+
+	ctrl_barrier();
 }
 #else
 /*
diff -Naur linux-2.6.17.8/include/asm-sh/mmu.h linux-2.6.17.8-sh/include/asm-sh/mmu.h
--- linux-2.6.17.8/include/asm-sh/mmu.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/mmu.h	2006-08-23 13:29:28.526369000 +0100
@@ -3,19 +3,8 @@
 
 #if !defined(CONFIG_MMU)
 
-struct mm_rblock_struct {
-	int	size;
-	int	refcount;
-	void	*kblock;
-};
-
-struct mm_tblock_struct {
-	struct mm_rblock_struct *rblock;
-	struct mm_tblock_struct *next;
-};
-
 typedef struct {
-	struct mm_tblock_struct tblock;
+	struct vm_list_struct	*vmlist;
 	unsigned long		end_brk;
 } mm_context_t;
 
@@ -25,5 +14,60 @@
 typedef unsigned long mm_context_t;
 
 #endif /* CONFIG_MMU */
-#endif /* __MMH_H */
+
+/*
+ * Privileged Space Mapping Buffer (PMB) definitions
+ */
+#define PMB_PASCR		0xff000070
+#define PMB_IRMCR		0xff000078
+
+#define PMB_ADDR		0xf6100000
+#define PMB_DATA		0xf7100000
+#define PMB_ENTRY_MAX		16
+#define PMB_E_MASK		0x0000000f
+#define PMB_E_SHIFT		8
+
+#define PMB_SZ_16M		0x00000000
+#define PMB_SZ_64M		0x00000010
+#define PMB_SZ_128M		0x00000080
+#define PMB_SZ_512M		0x00000090
+#define PMB_SZ_MASK		PMB_SZ_512M
+#define PMB_C			0x00000008
+#define PMB_WT			0x00000001
+#define PMB_UB			0x00000200
+#define PMB_V			0x00000100
+
+#define PMB_NO_ENTRY		(-1)
+
+struct pmb_entry;
+
+struct pmb_entry {
+	unsigned long vpn;
+	unsigned long ppn;
+	unsigned long flags;
+
+	/*
+	 * 0 .. NR_PMB_ENTRIES for specific entry selection, or
+	 * PMB_NO_ENTRY to search for a free one
+	 */
+	int entry;
+
+	struct pmb_entry *next;
+	/* Adjacent entry link for contiguous multi-entry mappings */
+	struct pmb_entry *link;
+};
+
+/* arch/sh/mm/pmb.c */
+int __set_pmb_entry(unsigned long vpn, unsigned long ppn,
+		    unsigned long flags, int *entry);
+int set_pmb_entry(struct pmb_entry *pmbe);
+void clear_pmb_entry(struct pmb_entry *pmbe);
+struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
+			    unsigned long flags);
+void pmb_free(struct pmb_entry *pmbe);
+long pmb_remap(unsigned long virt, unsigned long phys,
+	       unsigned long size, unsigned long flags);
+void pmb_unmap(unsigned long addr);
+
+#endif /* __MMU_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/page.h linux-2.6.17.8-sh/include/asm-sh/page.h
--- linux-2.6.17.8/include/asm-sh/page.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/page.h	2006-08-23 13:29:49.554852000 +0100
@@ -17,7 +17,13 @@
 
 /* PAGE_SHIFT determines the page size */
 #define PAGE_SHIFT	12
+
+#ifndef __ASSEMBLY__
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#else
+#define PAGE_SIZE	(1 << PAGE_SHIFT )
+#endif
+
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 #define PTE_MASK	PAGE_MASK
 
@@ -31,7 +37,6 @@
 #define HPAGE_SIZE		(1UL << HPAGE_SHIFT)
 #define HPAGE_MASK		(~(HPAGE_SIZE-1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT-PAGE_SHIFT)
-#define ARCH_HAS_SETCLEAR_HUGE_PTE
 #endif
 
 #ifdef __KERNEL__
@@ -40,41 +45,38 @@
 extern void (*clear_page)(void *to);
 extern void (*copy_page)(void *to, void *from);
 
+#ifdef CONFIG_MMU
 extern void clear_page_slow(void *to);
 extern void copy_page_slow(void *to, void *from);
+#else
+extern void clear_page_nommu(void *to);
+extern void copy_page_nommu(void *to, void *from);
+#endif
 
-#if defined(CONFIG_SH7705_CACHE_32KB) && defined(CONFIG_MMU)
+#if defined(CONFIG_MMU) && (defined(CONFIG_CPU_SH4) || \
+	defined(CONFIG_SH7705_CACHE_32KB))
 struct page;
 extern void clear_user_page(void *to, unsigned long address, struct page *pg);
 extern void copy_user_page(void *to, void *from, unsigned long address, struct page *pg);
 extern void __clear_user_page(void *to, void *orig_to);
 extern void __copy_user_page(void *to, void *from, void *orig_to);
-#elif defined(CONFIG_CPU_SH2) || defined(CONFIG_CPU_SH3) || !defined(CONFIG_MMU)
+#elif defined(CONFIG_CPU_SH3) || !defined(CONFIG_MMU)
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
-#elif defined(CONFIG_CPU_SH4)
-struct page;
-extern void clear_user_page(void *to, unsigned long address, struct page *pg);
-extern void copy_user_page(void *to, void *from, unsigned long address, struct page *pg);
-extern void __clear_user_page(void *to, void *orig_to);
-extern void __copy_user_page(void *to, void *from, void *orig_to);
 #endif
 
 /*
  * These are used to make use of C type-checking..
  */
 typedef struct { unsigned long pte; } pte_t;
-typedef struct { unsigned long pmd; } pmd_t;
 typedef struct { unsigned long pgd; } pgd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
 
 #define pte_val(x)	((x).pte)
-#define pmd_val(x)	((x).pmd)
 #define pgd_val(x)	((x).pgd)
 #define pgprot_val(x)	((x).pgprot)
 
 #define __pte(x) ((pte_t) { (x) } )
-#define __pmd(x) ((pmd_t) { (x) } )
 #define __pgd(x) ((pgd_t) { (x) } )
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
@@ -94,7 +96,7 @@
 #define __MEMORY_START		CONFIG_MEMORY_START
 #define __MEMORY_SIZE		CONFIG_MEMORY_SIZE
 
-#define PAGE_OFFSET		(0x80000000UL)
+#define PAGE_OFFSET		CONFIG_PAGE_OFFSET
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
 
@@ -105,7 +107,7 @@
 
 /* PFN start number, because of __MEMORY_START */
 #define PFN_START		(__MEMORY_START >> PAGE_SHIFT)
-#define ARCH_PFN_OFFSET		(FPN_START)
+#define ARCH_PFN_OFFSET		(PFN_START)
 #define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
 #define pfn_valid(pfn)		(((pfn) - PFN_START) < max_mapnr)
 #define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
diff -Naur linux-2.6.17.8/include/asm-sh/param.h linux-2.6.17.8-sh/include/asm-sh/param.h
--- linux-2.6.17.8/include/asm-sh/param.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/param.h	2006-08-23 13:29:40.899645000 +0100
@@ -1,9 +1,11 @@
 #ifndef __ASM_SH_PARAM_H
 #define __ASM_SH_PARAM_H
 
+#include <linux/config.h>
+
 #ifdef __KERNEL__
-# ifdef CONFIG_SH_WDT
-#  define HZ		1000		/* Needed for high-res WOVF */
+# ifdef CONFIG_SH_FAST_HZ
+#  define HZ		1000
 # else
 #  define HZ		100
 # endif
diff -Naur linux-2.6.17.8/include/asm-sh/pci.h linux-2.6.17.8-sh/include/asm-sh/pci.h
--- linux-2.6.17.8/include/asm-sh/pci.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/pci.h	2006-08-23 13:29:51.647898000 +0100
@@ -32,6 +32,38 @@
 #define PCIBIOS_MIN_IO		board_pci_channels->io_resource->start
 #define PCIBIOS_MIN_MEM		board_pci_channels->mem_resource->start
 
+/*
+ * I/O routine helpers
+ */
+#if defined(CONFIG_CPU_SUBTYPE_SH7751) || defined(CONFIG_CPU_SUBTYPE_SH7780)
+
+#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#define PCI_IO_AREA		0xFE400000
+#define PCI_IO_SIZE		0x00400000
+#else
+#define PCI_IO_AREA		0xFE240000
+#define PCI_IO_SIZE		0X00040000
+#endif
+
+#define PCI_MEM_SIZE		0x01000000
+
+#define SH4_PCIIOBR_MASK	0xFFFC0000
+#define pci_ioaddr(addr)	(PCI_IO_AREA + (addr & ~SH4_PCIIOBR_MASK))
+
+#endif
+
+#if defined(CONFIG_PCI) && defined(PCI_IO_SIZE)
+#define is_pci_ioaddr(port)		\
+	(((port) >= PCIBIOS_MIN_IO) &&	\
+	 ((port) < (PCIBIOS_MIN_IO + PCI_IO_SIZE)))
+#define is_pci_memaddr(port)		\
+	(((port) >= PCIBIOS_MIN_MEM) &&	\
+	 ((port) < (PCIBIOS_MIN_MEM + PCI_MEM_SIZE)))
+#else
+#define is_pci_ioaddr(port)	(0)
+#define is_pci_memaddr(port)	(0)
+#endif
+
 struct pci_dev;
 
 extern void pcibios_set_master(struct pci_dev *dev);
@@ -87,15 +119,6 @@
  */
 #define pci_dac_dma_supported(pci_dev, mask) (0)
 
-/* These macros should be used after a pci_map_sg call has been done
- * to get bus addresses of each of the SG entries and their lengths.
- * You should only work with the number of sg entries pci_map_sg
- * returns, or alternatively stop on the first sg_dma_len(sg) which
- * is 0.
- */
-#define sg_dma_address(sg)	(virt_to_bus((sg)->dma_address))
-#define sg_dma_len(sg)		((sg)->length)
-
 #ifdef CONFIG_PCI
 static inline void pci_dma_burst_advice(struct pci_dev *pdev,
 					enum pci_dma_burst_strategy *strat,
@@ -107,11 +130,12 @@
 #endif
 
 /* Board-specific fixup routines. */
-extern void pcibios_fixup(void);
-extern void pcibios_fixup_irqs(void);
+// void pcibios_fixup(void); is this still needed? SIM
+int pcibios_init_platform(void);
+int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin);
 
 #ifdef CONFIG_PCI_AUTO
-extern int pciauto_assign_resources(int busno, struct pci_channel *hose);
+int pciauto_assign_resources(int busno, struct pci_channel *hose);
 #endif
 
 static inline void pcibios_add_platform_entries(struct pci_dev *dev)
diff -Naur linux-2.6.17.8/include/asm-sh/pgalloc.h linux-2.6.17.8-sh/include/asm-sh/pgalloc.h
--- linux-2.6.17.8/include/asm-sh/pgalloc.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/pgalloc.h	2006-08-23 13:29:17.140100000 +0100
@@ -1,15 +1,6 @@
 #ifndef __ASM_SH_PGALLOC_H
 #define __ASM_SH_PGALLOC_H
 
-#include <linux/threads.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-
-#define pgd_quicklist ((unsigned long *)0)
-#define pmd_quicklist ((unsigned long *)0)
-#define pte_quicklist ((unsigned long *)0)
-#define pgtable_cache_size 0L
-
 #define pmd_populate_kernel(mm, pmd, pte) \
 		set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
 
@@ -24,38 +15,24 @@
  */
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
-	unsigned int pgd_size = (USER_PTRS_PER_PGD * sizeof(pgd_t));
-	pgd_t *pgd = (pgd_t *)kmalloc(pgd_size, GFP_KERNEL);
-
-	if (pgd)
-		memset(pgd, 0, pgd_size);
-
-	return pgd;
+	return (pgd_t *)__get_free_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);
 }
 
 static inline void pgd_free(pgd_t *pgd)
 {
-	kfree(pgd);
+	free_page((unsigned long)pgd);
 }
 
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
-	pte_t *pte;
-
-	pte = (pte_t *) __get_free_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);
-
-	return pte;
+	return (pte_t *)__get_free_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);
 }
 
 static inline struct page *pte_alloc_one(struct mm_struct *mm,
 					 unsigned long address)
 {
-	struct page *pte;
-
-   	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, 0);
-
-	return pte;
+	return alloc_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);
 }
 
 static inline void pte_free_kernel(pte_t *pte)
@@ -75,14 +52,8 @@
  * inside the pgd, so has no extra memory associated with it.
  */
 
-#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
 #define pmd_free(x)			do { } while (0)
 #define __pmd_free_tlb(tlb,x)		do { } while (0)
-#define pgd_populate(mm, pmd, pte)	BUG()
 #define check_pgt_cache()		do { } while (0)
 
-#ifdef CONFIG_CPU_SH4
-#define PG_mapped			PG_arch_1
-#endif
-
 #endif /* __ASM_SH_PGALLOC_H */
diff -Naur linux-2.6.17.8/include/asm-sh/pgtable.h linux-2.6.17.8-sh/include/asm-sh/pgtable.h
--- linux-2.6.17.8/include/asm-sh/pgtable.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/pgtable.h	2006-08-23 13:29:21.575208000 +0100
@@ -1,43 +1,43 @@
-#ifndef __ASM_SH_PGTABLE_H
-#define __ASM_SH_PGTABLE_H
-
-#include <asm-generic/4level-fixup.h>
-
 /*
+ * This file contains the functions and defines necessary to modify and
+ * use the SuperH page table tree.
+ *
  * Copyright (C) 1999 Niibe Yutaka
- * Copyright (C) 2002, 2003, 2004 Paul Mundt
+ * Copyright (C) 2002 - 2005 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of this
+ * archive for more details.
  */
+#ifndef __ASM_SH_PGTABLE_H
+#define __ASM_SH_PGTABLE_H
 
 #include <linux/config.h>
-#include <asm/pgtable-2level.h>
+#include <asm-generic/pgtable-nopmd.h>
+#include <asm/page.h>
+
+#define PTRS_PER_PGD		1024
 
-/*
- * This file contains the functions and defines necessary to modify and use
- * the SuperH page table tree.
- */
 #ifndef __ASSEMBLY__
-#include <asm/processor.h>
 #include <asm/addrspace.h>
 #include <asm/fixmap.h>
-#include <linux/threads.h>
 
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 extern void paging_init(void);
 
 /*
- * Basically we have the same two-level (which is the logical three level
- * Linux page table layout folded) page tables as the i386.
- */
-
-/*
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
  */
-extern unsigned long empty_zero_page[1024];
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 
 #endif /* !__ASSEMBLY__ */
 
+/* traditional two-level paging structure */
+#define PGDIR_SHIFT	22
+#define PTRS_PER_PMD	1
+#define PTRS_PER_PTE	1024
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
@@ -48,7 +48,6 @@
 
 #define PTE_PHYS_MASK	0x1ffff000
 
-#ifndef __ASSEMBLY__
 /*
  * First 1MB map is used by fixed purpose.
  * Currently only 4-enty (16kB) is used (see arch/sh/mm/cache.c)
@@ -56,20 +55,41 @@
 #define VMALLOC_START	(P3SEG+0x00100000)
 #define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
 
-#define	_PAGE_WT	0x001  /* WT-bit on SH-4, 0 on SH-3 */
-#define _PAGE_HW_SHARED	0x002  /* SH-bit  : page is shared among processes */
-#define _PAGE_DIRTY	0x004  /* D-bit   : page changed */
-#define _PAGE_CACHABLE	0x008  /* C-bit   : cachable */
-#define _PAGE_SZ0	0x010  /* SZ0-bit : Size of page */
-#define _PAGE_RW	0x020  /* PR0-bit : write access allowed */
-#define _PAGE_USER	0x040  /* PR1-bit : user space access allowed */
-#define _PAGE_SZ1	0x080  /* SZ1-bit : Size of page (on SH-4) */
-#define _PAGE_PRESENT	0x100  /* V-bit   : page is valid */
-#define _PAGE_PROTNONE	0x200  /* software: if not present  */
-#define _PAGE_ACCESSED 	0x400  /* software: page referenced */
-#define _PAGE_U0_SHARED 0x800  /* software: page is shared in user space */
-
-#define	_PAGE_FILE	_PAGE_WT  /* software: pagecache or swap? */
+/*
+ * Linux PTEL encoding.
+ *
+ * Hardware and software bit definitions for the PTEL value:
+ *
+ * - Bits 0 and 7 are reserved on SH-3 (_PAGE_WT and _PAGE_SZ1 on SH-4).
+ *
+ * - Bit 1 is the SH-bit, but is unused on SH-3 due to an MMU bug (the
+ *   hardware PTEL value can't have the SH-bit set when MMUCR.IX is set,
+ *   which is the default in cpu-sh3/mmu_context.h:MMU_CONTROL_INIT).
+ *
+ *   In order to keep this relatively clean, do not use these for defining
+ *   SH-3 specific flags until all of the other unused bits have been
+ *   exhausted.
+ *
+ * - Bit 9 is reserved by everyone and used by _PAGE_PROTNONE.
+ *
+ * - Bits 10 and 11 are low bits of the PPN that are reserved on >= 4K pages.
+ *   Bit 10 is used for _PAGE_ACCESSED, bit 11 remains unused.
+ *
+ * - Bits 31, 30, and 29 remain unused by everyone and can be used for future
+ *   software flags, although care must be taken to update _PAGE_CLEAR_FLAGS.
+ */
+#define	_PAGE_WT	0x001		/* WT-bit on SH-4, 0 on SH-3 */
+#define _PAGE_HW_SHARED	0x002		/* SH-bit  : shared among processes */
+#define _PAGE_DIRTY	0x004		/* D-bit   : page changed */
+#define _PAGE_CACHABLE	0x008		/* C-bit   : cachable */
+#define _PAGE_SZ0	0x010		/* SZ0-bit : Size of page */
+#define _PAGE_RW	0x020		/* PR0-bit : write access allowed */
+#define _PAGE_USER	0x040		/* PR1-bit : user space access allowed */
+#define _PAGE_SZ1	0x080		/* SZ1-bit : Size of page (on SH-4) */
+#define _PAGE_PRESENT	0x100		/* V-bit   : page is valid */
+#define _PAGE_PROTNONE	0x200		/* software: if not present  */
+#define _PAGE_ACCESSED	0x400		/* software: page referenced */
+#define _PAGE_FILE	_PAGE_WT	/* software: pagecache or swap? */
 
 /* software: moves to PTEA.TC (Timing Control) */
 #define _PAGE_PCC_AREA5	0x00000000	/* use BSC registers for area5 */
@@ -84,23 +104,17 @@
 #define _PAGE_PCC_ATR8	0x60000000	/* Attribute Memory space, 8 bit bus */
 #define _PAGE_PCC_ATR16	0x60000001	/* Attribute Memory space, 6 bit bus */
 
-
-/* Mask which drop software flags
- * We also drop WT bit since it is used for _PAGE_FILE
- * bit in this implementation.
- */
-#define _PAGE_CLEAR_FLAGS	(_PAGE_WT | _PAGE_PROTNONE | _PAGE_ACCESSED | _PAGE_U0_SHARED)
-
-#if defined(CONFIG_CPU_SH3)
-/*
- * MMU on SH-3 has bug on SH-bit: We can't use it if MMUCR.IX=1.
- * Work around: Just drop SH-bit.
- */
-#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS | _PAGE_HW_SHARED))
+/* Mask which drops unused bits from the PTEL value */
+#ifdef CONFIG_CPU_SH3
+#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED| \
+				 _PAGE_FILE	| _PAGE_SZ1	| \
+				 _PAGE_HW_SHARED)
 #else
-#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS))
+#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED | _PAGE_FILE)
 #endif
 
+#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS))
+
 /* Hardware flags: SZ0=1 (4k-byte) */
 #define _PAGE_FLAGS_HARD	_PAGE_SZ0
 
@@ -110,15 +124,15 @@
 #define _PAGE_SZHUGE	(_PAGE_SZ0 | _PAGE_SZ1)
 #endif
 
-#define _PAGE_SHARED	_PAGE_U0_SHARED
-
 #define _PAGE_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_DIRTY)
 #define _KERNPG_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY)
-#define _PAGE_CHG_MASK	(PTE_MASK | _PAGE_ACCESSED | _PAGE_CACHABLE | _PAGE_DIRTY | _PAGE_SHARED)
+#define _PAGE_CHG_MASK	(PTE_MASK | _PAGE_ACCESSED | _PAGE_CACHABLE | _PAGE_DIRTY)
+
+#ifndef __ASSEMBLY__
 
 #ifdef CONFIG_MMU
 #define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_CACHABLE |_PAGE_ACCESSED | _PAGE_FLAGS_HARD)
-#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_CACHABLE |_PAGE_ACCESSED | _PAGE_SHARED | _PAGE_FLAGS_HARD)
+#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_CACHABLE |_PAGE_ACCESSED | _PAGE_FLAGS_HARD)
 #define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
 #define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
 #define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_CACHABLE | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_HW_SHARED | _PAGE_FLAGS_HARD)
@@ -138,12 +152,13 @@
 #define PAGE_KERNEL_PCC		__pgprot(0)
 #endif
 
+#endif /* __ASSEMBLY__ */
+
 /*
  * As i386 and MIPS, SuperH can't do page protection for execute, and
  * considers that the same as a read.  Also, write permissions imply
- * read permissions. This is the closest we can get..  
+ * read permissions. This is the closest we can get..
  */
-
 #define __P000	PAGE_NONE
 #define __P001	PAGE_READONLY
 #define __P010	PAGE_COPY
@@ -162,6 +177,26 @@
 #define __S110	PAGE_SHARED
 #define __S111	PAGE_SHARED
 
+#ifndef __ASSEMBLY__
+
+/*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ */
+#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
+#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
+
+/*
+ * (pmds are folded into pgds so this doesn't get actually called,
+ * but the define is needed for a generic inline function.)
+ */
+#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
+
+#define pte_pfn(x)		((unsigned long)(((x).pte >> PAGE_SHIFT)))
+#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+
 #define pte_none(x)	(!pte_val(x))
 #define pte_present(x)	(pte_val(x) & (_PAGE_PRESENT | _PAGE_PROTNONE))
 #define pte_clear(mm,addr,xp)	do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
@@ -172,7 +207,7 @@
 #define	pmd_bad(x)	((pmd_val(x) & (~PAGE_MASK & ~_PAGE_USER)) != _KERNPG_TABLE)
 
 #define pages_to_mb(x)	((x) >> (20-PAGE_SHIFT))
-#define pte_page(x) 	phys_to_page(pte_val(x)&PTE_PHYS_MASK)
+#define pte_page(x)	phys_to_page(pte_val(x)&PTE_PHYS_MASK)
 
 /*
  * The following only work if pte_present() is true.
@@ -249,6 +284,11 @@
 #define pte_unmap(pte)		do { } while (0)
 #define pte_unmap_nested(pte)	do { } while (0)
 
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
 struct vm_area_struct;
 extern void update_mmu_cache(struct vm_area_struct * vma,
 			     unsigned long address, pte_t pte);
@@ -273,8 +313,6 @@
 
 typedef pte_t *pte_addr_t;
 
-#endif /* !__ASSEMBLY__ */
-
 #define kern_addr_valid(addr)	(1)
 
 #define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\
@@ -302,5 +340,7 @@
 
 #include <asm-generic/pgtable.h>
 
+#endif /* !__ASSEMBLY__ */
+
 #endif /* __ASM_SH_PAGE_H */
 
diff -Naur linux-2.6.17.8/include/asm-sh/pm.h linux-2.6.17.8-sh/include/asm-sh/pm.h
--- linux-2.6.17.8/include/asm-sh/pm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/pm.h	2006-08-23 13:29:22.190231000 +0100
@@ -0,0 +1,17 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright 2006 (c) Andriy Skulysh <askulysh@gmail.com>
+ *
+ */
+#ifndef __ASM_SH_PM_H
+#define __ASM_SH_PM_H
+
+extern u8 wakeup_start;
+extern u8 wakeup_end;
+
+void pm_enter(void);
+
+#endif
diff -Naur linux-2.6.17.8/include/asm-sh/processor.h linux-2.6.17.8-sh/include/asm-sh/processor.h
--- linux-2.6.17.8/include/asm-sh/processor.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/processor.h	2006-08-23 13:29:32.614461000 +0100
@@ -42,7 +42,9 @@
 
 	/* SH-4 types */
 	CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
-	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_SH4_202, CPU_SH4_501,
+	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_STI5528, CPU_STM8000,
+	CPU_STB7100,
+	CPU_SH4_202, CPU_SH4_501,
 	CPU_SH73180, CPU_SH7770, CPU_SH7780, CPU_SH7781,
 
 	/* Unknown subtype */
@@ -148,6 +150,10 @@
 	union sh_fpu_union fpu;
 };
 
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
 /* Count of active tasks with UBC settings */
 extern int ubc_usercnt;
 
@@ -265,5 +271,18 @@
 #define cpu_sleep()	__asm__ __volatile__ ("sleep" : : : "memory")
 #define cpu_relax()	do { } while (0)
 
+#if defined(CONFIG_CPU_SH2A) || defined(CONFIG_CPU_SH3) || \
+    defined(CONFIG_CPU_SH4)
+#define PREFETCH_STRIDE		L1_CACHE_BYTES
+#define ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCHW
+static inline void prefetch(void *x)
+{
+	__asm__ __volatile__ ("pref @%0\n\t" : : "r" (x) : "memory");
+}
+
+#define prefetchw(x)	prefetch(x)
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_PROCESSOR_H */
diff -Naur linux-2.6.17.8/include/asm-sh/r7780rp/ide.h linux-2.6.17.8-sh/include/asm-sh/r7780rp/ide.h
--- linux-2.6.17.8/include/asm-sh/r7780rp/ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/r7780rp/ide.h	2006-08-23 13:29:19.805163000 +0100
@@ -0,0 +1,8 @@
+#ifndef __ASM_SH_R7780RP_IDE_H
+#define __ASM_SH_R7780RP_IDE_H
+
+/* Nothing to see here.. */
+#include <asm/mach/r7780rp.h>
+
+#endif /* __ASM_SH_R7780RP_IDE_H */
+
diff -Naur linux-2.6.17.8/include/asm-sh/r7780rp/r7780rp.h linux-2.6.17.8-sh/include/asm-sh/r7780rp/r7780rp.h
--- linux-2.6.17.8/include/asm-sh/r7780rp/r7780rp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/r7780rp/r7780rp.h	2006-08-23 13:29:26.416324000 +0100
@@ -0,0 +1,177 @@
+#ifndef __ASM_SH_RENESAS_R7780RP_H
+#define __ASM_SH_RENESAS_R7780RP_H
+
+/*
+ * linux/include/asm-sh/r7780rp.h
+ *
+ * Copyright (C) 2000  Atom Create Engineering Co., Ltd.
+ *
+ * Renesas Solutions Highlander R7780RP support
+ */
+
+/* Box specific addresses.  */
+#if defined(CONFIG_SH_R7780MP)
+#define PA_BCR          0xa4000000      /* FPGA */
+#define PA_IRLMSK       (PA_BCR+0x0000) /* Interrupt Mask control */
+#define PA_IRLMON       (PA_BCR+0x0002) /* Interrupt Status control */
+#define PA_IRLPRI1      (PA_BCR+0x0004) /* Interrupt Priorty 1 */
+#define PA_IRLPRI2      (PA_BCR+0x0006) /* Interrupt Priorty 2 */
+#define PA_IRLPRI3      (PA_BCR+0x0008) /* Interrupt Priorty 3 */
+#define PA_IRLPRI4      (PA_BCR+0x000a) /* Interrupt Priorty 4 */
+#define PA_RSTCTL       (PA_BCR+0x000c) /* Reset Control */
+#define PA_PCIBD        (PA_BCR+0x000e) /* PCI Board detect control */
+#define PA_PCICD        (PA_BCR+0x0010) /* PCI Conector detect control */
+#define PA_EXTGIO       (PA_BCR+0x0016) /* Extension GPIO Control */
+#define PA_IVDRMON      (PA_BCR+0x0018) /* iVDR Moniter control */
+#define PA_IVDRCTL      (PA_BCR+0x001a) /* iVDR control */
+#define PA_OBLED        (PA_BCR+0x001c) /* On Board LED control */
+#define PA_OBSW         (PA_BCR+0x001e) /* On Board Switch control */
+#define PA_AUDIOSEL     (PA_BCR+0x0020) /* Sound Interface Select control */
+#define PA_EXTPLR       (PA_BCR+0x001e) /* Extention Pin Polarity control */
+#define PA_TPCTL        (PA_BCR+0x0100) /* Touch Panel Access control */
+#define PA_TPDCKCTL     (PA_BCR+0x0102) /* Touch Panel Access data control */
+#define PA_TPCTLCLR     (PA_BCR+0x0104) /* Touch Panel Access control */
+#define PA_TPXPOS       (PA_BCR+0x0106) /* Touch Panel X position control */
+#define PA_TPYPOS       (PA_BCR+0x0108) /* Touch Panel Y position control */
+#define PA_DBSW         (PA_BCR+0x0200) /* Debug Board Switch control */
+#define PA_CFCTL        (PA_BCR+0x0300) /* CF Timing control */
+#define PA_CFPOW        (PA_BCR+0x0302) /* CF Power control */
+#define PA_CFCDINTCLR   (PA_BCR+0x0304) /* CF Insert Interrupt clear */
+#define PA_SCSMR0       (PA_BCR+0x0400) /* SCIF0 Serial mode control */
+#define PA_SCBRR0       (PA_BCR+0x0404) /* SCIF0 Bit rate control */
+#define PA_SCSCR0       (PA_BCR+0x0408) /* SCIF0 Serial control */
+#define PA_SCFTDR0      (PA_BCR+0x040c) /* SCIF0 Send FIFO control */
+#define PA_SCFSR0       (PA_BCR+0x0410) /* SCIF0 Serial status control */
+#define PA_SCFRDR0      (PA_BCR+0x0414) /* SCIF0 Receive FIFO control */
+#define PA_SCFCR0       (PA_BCR+0x0418) /* SCIF0 FIFO control */
+#define PA_SCTFDR0      (PA_BCR+0x041c) /* SCIF0 Send FIFO data control */
+#define PA_SCRFDR0      (PA_BCR+0x0420) /* SCIF0 Receive FIFO data control */
+#define PA_SCSPTR0      (PA_BCR+0x0424) /* SCIF0 Serial Port control */
+#define PA_SCLSR0       (PA_BCR+0x0428) /* SCIF0 Line Status control */
+#define PA_SCRER0       (PA_BCR+0x042c) /* SCIF0 Serial Error control */
+#define PA_SCSMR1       (PA_BCR+0x0500) /* SCIF1 Serial mode control */
+#define PA_SCBRR1       (PA_BCR+0x0504) /* SCIF1 Bit rate control */
+#define PA_SCSCR1       (PA_BCR+0x0508) /* SCIF1 Serial control */
+#define PA_SCFTDR1      (PA_BCR+0x050c) /* SCIF1 Send FIFO control */
+#define PA_SCFSR1       (PA_BCR+0x0510) /* SCIF1 Serial status control */
+#define PA_SCFRDR1      (PA_BCR+0x0514) /* SCIF1 Receive FIFO control */
+#define PA_SCFCR1       (PA_BCR+0x0518) /* SCIF1 FIFO control */
+#define PA_SCTFDR1      (PA_BCR+0x051c) /* SCIF1 Send FIFO data control */
+#define PA_SCRFDR1      (PA_BCR+0x0520) /* SCIF1 Receive FIFO data control */
+#define PA_SCSPTR1      (PA_BCR+0x0524) /* SCIF1 Serial Port control */
+#define PA_SCLSR1       (PA_BCR+0x0528) /* SCIF1 Line Status control */
+#define PA_SCRER1       (PA_BCR+0x052c) /* SCIF1 Serial Error control */
+#define PA_ICCR         (PA_BCR+0x0600) /* Serial control */
+#define PA_SAR          (PA_BCR+0x0602) /* Serial Slave control */
+#define PA_MDR          (PA_BCR+0x0604) /* Serial Mode control */
+#define PA_ADR1         (PA_BCR+0x0606) /* Serial Address1 control */
+#define PA_DAR1         (PA_BCR+0x0646) /* Serial Data1 control */
+#define PA_VERREG       (PA_BCR+0x0700) /* FPGA Version Register */
+#define PA_POFF         (PA_BCR+0x0800) /* System Power Off control */
+#define PA_PMR          (PA_BCR+0x0900) /*  */
+
+#define PA_AX88796L     0xa4100400      /* AX88796L Area */
+#define PA_SC1602BSLB   0xa6000000      /* SC1602BSLB Area */
+#define PA_AREA5_IO     0xb4000000      /* Area 5 IO Memory */
+#define PA_AREA6_IO     0xb8000000      /* Area 6 IO Memory */
+#define PA_IDE_OFFSET   0x1f0           /* CF IDE Offset */
+#define AX88796L_IO_BASE        0x1000  /* AX88796L IO Base Address */
+
+#define IRLCNTR1        (PA_BCR + 0)    /* Interrupt Control Register1 */
+
+#define IRQ_PCISLOT1    65              /* PCI Slot #1 IRQ */
+#define IRQ_PCISLOT2    66              /* PCI Slot #2 IRQ */
+#define IRQ_PCISLOT3    67              /* PCI Slot #3 IRQ */
+#define IRQ_PCISLOT4    68              /* PCI Slot #4 IRQ */
+#define IRQ_CFCARD      1               /* CF Card IRQ */
+// #define IRQ_CFINST   0               /* CF Card Insert IRQ */
+#define IRQ_TP          2               /* Touch Panel IRQ */
+#define IRQ_SCI1        3               /* SCI1 IRQ */
+#define IRQ_SCI0        4               /* SCI0 IRQ */
+#define IRQ_2SERIAL     5               /* Serial IRQ */
+#define IRQ_RTC         6               /* RTC A / B IRQ */
+#define IRQ_EXTENTION6  7               /* EXT6n IRQ */
+#define IRQ_EXTENTION5  8               /* EXT5n IRQ */
+#define IRQ_EXTENTION4  9               /* EXT4n IRQ */
+#define IRQ_EXTENTION2  10              /* EXT2n IRQ */
+#define IRQ_EXTENTION1  11              /* EXT1n IRQ */
+#define IRQ_ONETH       13              /* On board Ethernet IRQ */
+#define IRQ_PSW         14              /* Push Switch IRQ */
+
+#else /* R7780RP */
+
+#define PA_BCR		0xa5000000	/* FPGA */
+#define	PA_IRLMSK	(PA_BCR+0x0000)	/* Interrupt Mask control */
+#define PA_IRLMON	(PA_BCR+0x0002)	/* Interrupt Status control */
+#define	PA_SDPOW	(PA_BCR+0x0004)	/* SD Power control */
+#define	PA_RSTCTL	(PA_BCR+0x0006)	/* Device Reset control */
+#define	PA_PCIBD	(PA_BCR+0x0008)	/* PCI Board detect control */
+#define	PA_PCICD	(PA_BCR+0x000a)	/* PCI Conector detect control */
+#define	PA_ZIGIO1	(PA_BCR+0x000c)	/* Zigbee IO control 1 */
+#define	PA_ZIGIO2	(PA_BCR+0x000e)	/* Zigbee IO control 2 */
+#define	PA_ZIGIO3	(PA_BCR+0x0010)	/* Zigbee IO control 3 */
+#define	PA_ZIGIO4	(PA_BCR+0x0012)	/* Zigbee IO control 4 */
+#define	PA_IVDRMON	(PA_BCR+0x0014)	/* iVDR Moniter control */
+#define	PA_IVDRCTL	(PA_BCR+0x0016)	/* iVDR control */
+#define PA_OBLED	(PA_BCR+0x0018)	/* On Board LED control */
+#define PA_OBSW		(PA_BCR+0x001a)	/* On Board Switch control */
+#define PA_AUDIOSEL	(PA_BCR+0x001c)	/* Sound Interface Select control */
+#define PA_EXTPLR	(PA_BCR+0x001e)	/* Extention Pin Polarity control */
+#define PA_TPCTL	(PA_BCR+0x0100)	/* Touch Panel Access control */
+#define PA_TPDCKCTL	(PA_BCR+0x0102)	/* Touch Panel Access data control */
+#define PA_TPCTLCLR	(PA_BCR+0x0104)	/* Touch Panel Access control */
+#define PA_TPXPOS	(PA_BCR+0x0106)	/* Touch Panel X position control */
+#define PA_TPYPOS	(PA_BCR+0x0108)	/* Touch Panel Y position control */
+#define PA_DBDET	(PA_BCR+0x0200)	/* Debug Board detect control */
+#define PA_DBDISPCTL	(PA_BCR+0x0202)	/* Debug Board Dot timing control */
+#define PA_DBSW		(PA_BCR+0x0204)	/* Debug Board Switch control */
+#define PA_CFCTL	(PA_BCR+0x0300)	/* CF Timing control */
+#define PA_CFPOW	(PA_BCR+0x0302)	/* CF Power control */
+#define PA_CFCDINTCLR	(PA_BCR+0x0304)	/* CF Insert Interrupt clear */
+#define PA_SCSMR	(PA_BCR+0x0400)	/* SCIF Serial mode control */
+#define PA_SCBRR	(PA_BCR+0x0402)	/* SCIF Bit rate control */
+#define PA_SCSCR	(PA_BCR+0x0404)	/* SCIF Serial control */
+#define PA_SCFDTR	(PA_BCR+0x0406)	/* SCIF Send FIFO control */
+#define PA_SCFSR	(PA_BCR+0x0408)	/* SCIF Serial status control */
+#define PA_SCFRDR	(PA_BCR+0x040a)	/* SCIF Receive FIFO control */
+#define PA_SCFCR	(PA_BCR+0x040c)	/* SCIF FIFO control */
+#define PA_SCFDR	(PA_BCR+0x040e)	/* SCIF FIFO data control */
+#define PA_SCLSR	(PA_BCR+0x0412)	/* SCIF Line Status control */
+#define PA_ICCR		(PA_BCR+0x0500)	/* Serial control */
+#define PA_SAR		(PA_BCR+0x0502)	/* Serial Slave control */
+#define PA_MDR		(PA_BCR+0x0504)	/* Serial Mode control */
+#define PA_ADR1		(PA_BCR+0x0506)	/* Serial Address1 control */
+#define PA_DAR1		(PA_BCR+0x0546)	/* Serial Data1 control */
+#define PA_VERREG	(PA_BCR+0x0600)	/* FPGA Version Register */
+
+#define PA_AX88796L	0xa5800400	/* AX88796L Area */
+#define PA_SC1602BSLB	0xa6000000	/* SC1602BSLB Area */
+#define PA_AREA5_IO	0xb4000000	/* Area 5 IO Memory */
+#define PA_AREA6_IO	0xb8000000	/* Area 6 IO Memory */
+#define PA_IDE_OFFSET	0x1f0		/* CF IDE Offset */
+#define AX88796L_IO_BASE	0x1000	/* AX88796L IO Base Address */
+
+#define IRLCNTR1	(PA_BCR + 0)	/* Interrupt Control Register1 */
+
+#define IRQ_PCISLOT1	0		/* PCI Slot #1 IRQ */
+#define IRQ_PCISLOT2	1		/* PCI Slot #2 IRQ */
+#define IRQ_PCISLOT3	2		/* PCI Slot #3 IRQ */
+#define IRQ_PCISLOT4	3		/* PCI Slot #4 IRQ */
+#define IRQ_CFCARD	4		/* CF Card IRQ */
+#define IRQ_CFINST	5		/* CF Card Insert IRQ */
+#define IRQ_M66596	6		/* M66596 IRQ */
+#define IRQ_SDCARD	7		/* SD Card IRQ */
+#define IRQ_TUCHPANEL	8		/* Touch Panel IRQ */
+#define IRQ_SCI		9		/* SCI IRQ */
+#define IRQ_2SERIAL	10		/* Serial IRQ */
+#define	IRQ_EXTENTION	11		/* EXTn IRQ */
+#define IRQ_ONETH	12		/* On board Ethernet IRQ */
+#define IRQ_PSW		13		/* Push Switch IRQ */
+#define IRQ_ZIGBEE	14		/* Ziggbee IO IRQ */
+
+#endif  /* CONFIG_SH_R7780MP */
+
+#define __IO_PREFIX	r7780rp
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_RENESAS_R7780RP */
diff -Naur linux-2.6.17.8/include/asm-sh/rtc.h linux-2.6.17.8-sh/include/asm-sh/rtc.h
--- linux-2.6.17.8/include/asm-sh/rtc.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/rtc.h	2006-08-23 13:29:30.876416000 +0100
@@ -7,9 +7,12 @@
 
 extern void sh_rtc_gettimeofday(struct timespec *ts);
 extern int sh_rtc_settimeofday(const time_t secs);
+extern void st_rtc_gettimeofday(struct timespec *ts);
+extern int st_rtc_settimeofday(const time_t secs);
+
 extern void (*board_time_init)(void);
-extern void (*rtc_get_time)(struct timespec *);
-extern int (*rtc_set_time)(const time_t);
+extern void (*rtc_sh_get_time)(struct timespec *);
+extern int (*rtc_sh_set_time)(const time_t);
 
 /* RCR1 Bits */
 #define RCR1_CF		0x80	/* Carry Flag             */
diff -Naur linux-2.6.17.8/include/asm-sh/rts7751r2d/rts7751r2d.h linux-2.6.17.8-sh/include/asm-sh/rts7751r2d/rts7751r2d.h
--- linux-2.6.17.8/include/asm-sh/rts7751r2d/rts7751r2d.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/rts7751r2d/rts7751r2d.h	2006-08-23 13:29:21.499208000 +0100
@@ -41,8 +41,6 @@
 
 #define PA_AX88796L	0xaa000400	/* AX88796L Area */
 #define PA_VOYAGER	0xab000000	/* VOYAGER GX Area */
-#define PA_AREA5_IO	0xb4000000	/* Area 5 IO Memory */
-#define PA_AREA6_IO	0xb8000000	/* Area 6 IO Memory */
 #define PA_IDE_OFFSET	0x1f0		/* CF IDE Offset */
 #define AX88796L_IO_BASE	0x1000	/* AX88796L IO Base Address */
 
@@ -70,4 +68,7 @@
 #define IRQ_PCISLOT2	10		/* PCI Slot #2 IRQ */
 #define	IRQ_EXTENTION	11		/* EXTn IRQ */
 
+#define __IO_PREFIX rts7751r2d
+#include <asm/io_generic.h>
+
 #endif  /* __ASM_SH_RENESAS_RTS7751R2D */
diff -Naur linux-2.6.17.8/include/asm-sh/scatterlist.h linux-2.6.17.8-sh/include/asm-sh/scatterlist.h
--- linux-2.6.17.8/include/asm-sh/scatterlist.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/scatterlist.h	2006-08-23 13:29:14.467047000 +0100
@@ -10,4 +10,13 @@
 
 #define ISA_DMA_THRESHOLD (0x1fffffff)
 
+/* These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns, or alternatively stop on the first sg_dma_len(sg) which
+ * is 0.
+ */
+#define sg_dma_address(sg)	((sg)->dma_address)
+#define sg_dma_len(sg)		((sg)->length)
+
 #endif /* !(__ASM_SH_SCATTERLIST_H) */
diff -Naur linux-2.6.17.8/include/asm-sh/se7300.h linux-2.6.17.8-sh/include/asm-sh/se7300.h
--- linux-2.6.17.8/include/asm-sh/se7300.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/se7300.h	2006-08-23 13:29:18.298139000 +0100
@@ -0,0 +1,64 @@
+#ifndef __ASM_SH_HITACHI_SE7300_H
+#define __ASM_SH_HITACHI_SE7300_H
+
+/*
+ * linux/include/asm-sh/se/se7300.h
+ *
+ * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
+ *
+ * SH-Mobile SolutionEngine 7300 support
+ */
+
+/* Box specific addresses.  */
+
+/* Area 0 */
+#define PA_ROM		0x00000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte(Actually 2MB) */
+#define PA_FROM		0x00400000	/* Flash ROM */
+#define PA_FROM_SIZE	0x00400000	/* Flash size 4M byte */
+#define PA_SRAM		0x00800000	/* SRAM */
+#define PA_FROM_SIZE	0x00400000	/* SRAM size 4M byte */
+/* Area 1 */
+#define PA_EXT1		0x04000000
+#define PA_EXT1_SIZE	0x04000000
+/* Area 2 */
+#define PA_EXT2		0x08000000
+#define PA_EXT2_SIZE	0x04000000
+/* Area 3 */
+#define PA_SDRAM	0x0c000000
+#define PA_SDRAM_SIZE	0x04000000
+/* Area 4 */
+#define PA_PCIC		0x10000000	/* MR-SHPC-01 PCMCIA */
+#define PA_MRSHPC       0xb03fffe0      /* MR-SHPC-01 PCMCIA controller */
+#define PA_MRSHPC_MW1   0xb0400000      /* MR-SHPC-01 memory window base */
+#define PA_MRSHPC_MW2   0xb0500000      /* MR-SHPC-01 attribute window base */
+#define PA_MRSHPC_IO    0xb0600000      /* MR-SHPC-01 I/O window base */
+#define MRSHPC_OPTION   (PA_MRSHPC + 6)
+#define MRSHPC_CSR      (PA_MRSHPC + 8)
+#define MRSHPC_ISR      (PA_MRSHPC + 10)
+#define MRSHPC_ICR      (PA_MRSHPC + 12)
+#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
+#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
+#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
+#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
+#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
+#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
+#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
+#define MRSHPC_CDCR     (PA_MRSHPC + 28)
+#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
+#define PA_LED		0xb0800000	/* LED */
+#define PA_DIPSW	0xb0900000	/* Dip switch 31 */
+#define PA_EPLD_MODESET	0xb0a00000	/* FPGA Mode set register */
+#define PA_EPLD_ST1	0xb0a80000	/* FPGA Interrupt status register1 */
+#define PA_EPLD_ST2	0xb0ac0000	/* FPGA Interrupt status register2 */
+/* Area 5 */
+#define PA_EXT5		0x14000000
+#define PA_EXT5_SIZE	0x04000000
+/* Area 6 */
+#define PA_LCD1		0xb8000000
+#define PA_LCD2		0xb8800000
+
+#define __IO_PREFIX	sh7300se
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_HITACHI_SE7300_H */
diff -Naur linux-2.6.17.8/include/asm-sh/se73180.h linux-2.6.17.8-sh/include/asm-sh/se73180.h
--- linux-2.6.17.8/include/asm-sh/se73180.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/se73180.h	2006-08-23 13:29:18.364139000 +0100
@@ -0,0 +1,65 @@
+#ifndef __ASM_SH_HITACHI_SE73180_H
+#define __ASM_SH_HITACHI_SE73180_H
+
+/*
+ * include/asm-sh/se/se73180.h
+ *
+ * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
+ *
+ * SH-Mobile SolutionEngine 73180 support
+ */
+
+/* Box specific addresses.  */
+
+/* Area 0 */
+#define PA_ROM		0x00000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte(Actually 2MB) */
+#define PA_FROM		0x00400000	/* Flash ROM */
+#define PA_FROM_SIZE	0x00400000	/* Flash size 4M byte */
+#define PA_SRAM		0x00800000	/* SRAM */
+#define PA_FROM_SIZE	0x00400000	/* SRAM size 4M byte */
+/* Area 1 */
+#define PA_EXT1		0x04000000
+#define PA_EXT1_SIZE	0x04000000
+/* Area 2 */
+#define PA_EXT2		0x08000000
+#define PA_EXT2_SIZE	0x04000000
+/* Area 3 */
+#define PA_SDRAM	0x0c000000
+#define PA_SDRAM_SIZE	0x04000000
+/* Area 4 */
+#define PA_PCIC		0x10000000	/* MR-SHPC-01 PCMCIA */
+#define PA_MRSHPC       0xb03fffe0      /* MR-SHPC-01 PCMCIA controller */
+#define PA_MRSHPC_MW1   0xb0400000      /* MR-SHPC-01 memory window base */
+#define PA_MRSHPC_MW2   0xb0500000      /* MR-SHPC-01 attribute window base */
+#define PA_MRSHPC_IO    0xb0600000      /* MR-SHPC-01 I/O window base */
+#define MRSHPC_OPTION   (PA_MRSHPC + 6)
+#define MRSHPC_CSR      (PA_MRSHPC + 8)
+#define MRSHPC_ISR      (PA_MRSHPC + 10)
+#define MRSHPC_ICR      (PA_MRSHPC + 12)
+#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
+#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
+#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
+#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
+#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
+#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
+#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
+#define MRSHPC_CDCR     (PA_MRSHPC + 28)
+#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
+#define PA_LED		0xb0C00000	/* LED */
+#define LED_SHIFT       0
+#define PA_DIPSW	0xb0900000	/* Dip switch 31 */
+#define PA_EPLD_MODESET	0xb0a00000	/* FPGA Mode set register */
+#define PA_EPLD_ST1	0xb0a80000	/* FPGA Interrupt status register1 */
+#define PA_EPLD_ST2	0xb0ac0000	/* FPGA Interrupt status register2 */
+/* Area 5 */
+#define PA_EXT5		0x14000000
+#define PA_EXT5_SIZE	0x04000000
+/* Area 6 */
+#define PA_LCD1		0xb8000000
+#define PA_LCD2		0xb8800000
+
+#define __IO_PREFIX	sh73180se
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_HITACHI_SE73180_H */
diff -Naur linux-2.6.17.8/include/asm-sh/se7751.h linux-2.6.17.8-sh/include/asm-sh/se7751.h
--- linux-2.6.17.8/include/asm-sh/se7751.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/se7751.h	2006-08-23 13:29:18.758140000 +0100
@@ -0,0 +1,71 @@
+#ifndef __ASM_SH_HITACHI_7751SE_H
+#define __ASM_SH_HITACHI_7751SE_H
+
+/*
+ * linux/include/asm-sh/hitachi_7751se.h
+ *
+ * Copyright (C) 2000  Kazumoto Kojima
+ *
+ * Hitachi SolutionEngine support
+
+ * Modified for 7751 Solution Engine by
+ * Ian da Silva and Jeremy Siegel, 2001.
+ */
+
+/* Box specific addresses.  */
+
+#define PA_ROM		0x00000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_FROM		0x01000000	/* EPROM */
+#define PA_FROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_EXT1		0x04000000
+#define PA_EXT1_SIZE	0x04000000
+#define PA_EXT2		0x08000000
+#define PA_EXT2_SIZE	0x04000000
+#define PA_SDRAM	0x0c000000
+#define PA_SDRAM_SIZE	0x04000000
+
+#define PA_EXT4		0x12000000
+#define PA_EXT4_SIZE	0x02000000
+#define PA_EXT5		0x14000000
+#define PA_EXT5_SIZE	0x04000000
+#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
+
+#define PA_DIPSW0	0xb9000000	/* Dip switch 5,6 */
+#define PA_DIPSW1	0xb9000002	/* Dip switch 7,8 */
+#define PA_LED		0xba000000	/* LED */
+#define	PA_BCR		0xbb000000	/* FPGA on the MS7751SE01 */
+
+#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controler */
+#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
+#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
+#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
+#define MRSHPC_MODE     (PA_MRSHPC + 4)
+#define MRSHPC_OPTION   (PA_MRSHPC + 6)
+#define MRSHPC_CSR      (PA_MRSHPC + 8)
+#define MRSHPC_ISR      (PA_MRSHPC + 10)
+#define MRSHPC_ICR      (PA_MRSHPC + 12)
+#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
+#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
+#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
+#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
+#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
+#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
+#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
+#define MRSHPC_CDCR     (PA_MRSHPC + 28)
+#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
+
+#define BCR_ILCRA	(PA_BCR + 0)
+#define BCR_ILCRB	(PA_BCR + 2)
+#define BCR_ILCRC	(PA_BCR + 4)
+#define BCR_ILCRD	(PA_BCR + 6)
+#define BCR_ILCRE	(PA_BCR + 8)
+#define BCR_ILCRF	(PA_BCR + 10)
+#define BCR_ILCRG	(PA_BCR + 12)
+
+#define IRQ_79C973	13
+
+#define __IO_PREFIX	sh7751se
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_HITACHI_7751SE_H */
diff -Naur linux-2.6.17.8/include/asm-sh/se.h linux-2.6.17.8-sh/include/asm-sh/se.h
--- linux-2.6.17.8/include/asm-sh/se.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/se.h	2006-08-23 13:29:18.589139000 +0100
@@ -0,0 +1,80 @@
+#ifndef __ASM_SH_HITACHI_SE_H
+#define __ASM_SH_HITACHI_SE_H
+
+/*
+ * linux/include/asm-sh/hitachi_se.h
+ *
+ * Copyright (C) 2000  Kazumoto Kojima
+ *
+ * Hitachi SolutionEngine support
+ */
+
+/* Box specific addresses.  */
+
+#define PA_ROM		0x00000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_FROM		0x01000000	/* EPROM */
+#define PA_FROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_EXT1		0x04000000
+#define PA_EXT1_SIZE	0x04000000
+#define PA_EXT2		0x08000000
+#define PA_EXT2_SIZE	0x04000000
+#define PA_SDRAM	0x0c000000
+#define PA_SDRAM_SIZE	0x04000000
+
+#define PA_EXT4		0x12000000
+#define PA_EXT4_SIZE	0x02000000
+#define PA_EXT5		0x14000000
+#define PA_EXT5_SIZE	0x04000000
+#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
+
+#define PA_83902	0xb0000000	/* DP83902A */
+#define PA_83902_IF	0xb0040000	/* DP83902A remote io port */
+#define PA_83902_RST	0xb0080000	/* DP83902A reset port */
+
+#define PA_SUPERIO	0xb0400000	/* SMC37C935A super io chip */
+#define PA_DIPSW0	0xb0800000	/* Dip switch 5,6 */
+#define PA_DIPSW1	0xb0800002	/* Dip switch 7,8 */
+#define PA_LED		0xb0c00000	/* LED */
+#if defined(CONFIG_CPU_SUBTYPE_SH7705)
+#define PA_BCR		0xb0e00000
+#else
+#define PA_BCR		0xb1400000	/* FPGA */
+#endif
+
+#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controller */
+#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
+#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
+#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
+#define MRSHPC_OPTION   (PA_MRSHPC + 6)
+#define MRSHPC_CSR      (PA_MRSHPC + 8)
+#define MRSHPC_ISR      (PA_MRSHPC + 10)
+#define MRSHPC_ICR      (PA_MRSHPC + 12)
+#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
+#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
+#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
+#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
+#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
+#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
+#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
+#define MRSHPC_CDCR     (PA_MRSHPC + 28)
+#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
+
+#define BCR_ILCRA	(PA_BCR + 0)
+#define BCR_ILCRB	(PA_BCR + 2)
+#define BCR_ILCRC	(PA_BCR + 4)
+#define BCR_ILCRD	(PA_BCR + 6)
+#define BCR_ILCRE	(PA_BCR + 8)
+#define BCR_ILCRF	(PA_BCR + 10)
+#define BCR_ILCRG	(PA_BCR + 12)
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7705)
+#define IRQ_STNIC   12
+#else
+#define IRQ_STNIC	10
+#endif
+
+#define __IO_PREFIX	se
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_HITACHI_SE_H */
diff -Naur linux-2.6.17.8/include/asm-sh/setup.h linux-2.6.17.8-sh/include/asm-sh/setup.h
--- linux-2.6.17.8/include/asm-sh/setup.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/setup.h	2006-08-23 13:29:31.985440000 +0100
@@ -2,7 +2,7 @@
 #ifndef _SH_SETUP_H
 #define _SH_SETUP_H
 
-#define COMMAND_LINE_SIZE 256
+#define COMMAND_LINE_SIZE 512
 
 #endif /* _SH_SETUP_H */
 #endif /* __KERNEL__ */
diff -Naur linux-2.6.17.8/include/asm-sh/sfp-machine.h linux-2.6.17.8-sh/include/asm-sh/sfp-machine.h
--- linux-2.6.17.8/include/asm-sh/sfp-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/sfp-machine.h	2006-08-23 13:29:27.875346000 +0100
@@ -0,0 +1,86 @@
+/* Machine-dependent software floating-point definitions.
+   SuperH kernel version.
+   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com),
+		  Jakub Jelinek (jj@ultra.linux.cz),
+		  David S. Miller (davem@redhat.com) and
+		  Peter Maydell (pmaydell@chiark.greenend.org.uk).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _SFP_MACHINE_H
+#define _SFP_MACHINE_H
+   
+#include <linux/config.h>
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+
+/*
+ * If one NaN is signaling and the other is not,
+ * we choose that one, otherwise we choose X.
+ */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)                      \
+  do {                                                          \
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)          \
+        && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))     \
+      {                                                         \
+        R##_s = Y##_s;                                          \
+        _FP_FRAC_COPY_##wc(R,Y);                                \
+      }                                                         \
+    else                                                        \
+      {                                                         \
+        R##_s = X##_s;                                          \
+        _FP_FRAC_COPY_##wc(R,X);                                \
+      }                                                         \
+    R##_c = FP_CLS_NAN;                                         \
+  } while (0)
+
+//#define FP_ROUNDMODE		FPSCR_RM
+#define FP_DENORM_ZERO		1/*FPSCR_DN*/
+
+/* Exception flags. */
+#define FP_EX_INVALID		(1<<4)
+#define FP_EX_DIVZERO		(1<<3)
+#define FP_EX_OVERFLOW		(1<<2)
+#define FP_EX_UNDERFLOW		(1<<1)
+#define FP_EX_INEXACT		(1<<0)
+
+#endif
+
diff -Naur linux-2.6.17.8/include/asm-sh/sh03/io.h linux-2.6.17.8-sh/include/asm-sh/sh03/io.h
--- linux-2.6.17.8/include/asm-sh/sh03/io.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/sh03/io.h	2006-08-23 13:29:18.848139000 +0100
@@ -33,14 +33,6 @@
 #define IRL3_IPR_POS	0
 #define IRL3_PRIORITY	4
 
-
-extern unsigned long sh03_isa_port2addr(unsigned long offset);
-
-extern void setup_sh03(void);
-extern void init_sh03_IRQ(void);
-extern void heartbeat_sh03(void);
-
-extern void sh03_rtc_gettimeofday(struct timeval *tv);
-extern int sh03_rtc_settimeofday(const struct timeval *tv);
+void heartbeat_sh03(void);
 
 #endif /* _ASM_SH_IO_SH03_H */
diff -Naur linux-2.6.17.8/include/asm-sh/smc37c93x.h linux-2.6.17.8-sh/include/asm-sh/smc37c93x.h
--- linux-2.6.17.8/include/asm-sh/smc37c93x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/smc37c93x.h	2006-08-23 13:29:06.833863000 +0100
@@ -0,0 +1,190 @@
+#ifndef __ASM_SH_SMC37C93X_H
+#define __ASM_SH_SMC37C93X_H
+
+/*
+ * linux/include/asm-sh/smc37c93x.h
+ *
+ * Copyright (C) 2000  Kazumoto Kojima
+ *
+ * SMSC 37C93x Super IO Chip support
+ */
+
+/* Default base I/O address */
+#define FDC_PRIMARY_BASE	0x3f0
+#define IDE1_PRIMARY_BASE	0x1f0
+#define IDE1_SECONDARY_BASE	0x170
+#define PARPORT_PRIMARY_BASE	0x378
+#define COM1_PRIMARY_BASE	0x2f8
+#define COM2_PRIMARY_BASE	0x3f8
+#define RTC_PRIMARY_BASE	0x070
+#define KBC_PRIMARY_BASE	0x060
+#define AUXIO_PRIMARY_BASE	0x000	/* XXX */
+
+/* Logical device number */
+#define LDN_FDC			0
+#define LDN_IDE1		1
+#define LDN_IDE2		2
+#define LDN_PARPORT		3
+#define LDN_COM1		4
+#define LDN_COM2		5
+#define LDN_RTC			6
+#define LDN_KBC			7
+#define LDN_AUXIO		8
+
+/* Configuration port and key */
+#define CONFIG_PORT		0x3f0
+#define INDEX_PORT		CONFIG_PORT
+#define DATA_PORT		0x3f1
+#define CONFIG_ENTER		0x55
+#define CONFIG_EXIT		0xaa
+
+/* Configuration index */
+#define CURRENT_LDN_INDEX	0x07
+#define POWER_CONTROL_INDEX	0x22
+#define ACTIVATE_INDEX		0x30
+#define IO_BASE_HI_INDEX	0x60
+#define IO_BASE_LO_INDEX	0x61
+#define IRQ_SELECT_INDEX	0x70
+#define DMA_SELECT_INDEX	0x74
+
+#define GPIO46_INDEX		0xc6
+#define GPIO47_INDEX		0xc7
+
+/* UART stuff. Only for debugging.  */
+/* UART Register */
+
+#define UART_RBR	0x0	/* Receiver Buffer Register (Read Only) */
+#define UART_THR	0x0	/* Transmitter Holding Register (Write Only) */
+#define UART_IER	0x2	/* Interrupt Enable Register */
+#define UART_IIR	0x4	/* Interrupt Ident Register (Read Only) */
+#define UART_FCR	0x4	/* FIFO Control Register (Write Only) */
+#define UART_LCR	0x6	/* Line Control Register */
+#define UART_MCR	0x8	/* MODEM Control Register */
+#define UART_LSR	0xa	/* Line Status Register */
+#define UART_MSR	0xc	/* MODEM Status Register */
+#define UART_SCR	0xe	/* Scratch Register */
+#define UART_DLL	0x0	/* Divisor Latch (LS) */
+#define UART_DLM	0x2	/* Divisor Latch (MS) */
+
+#ifndef __ASSEMBLY__
+typedef struct uart_reg {
+	volatile __u16 rbr;
+	volatile __u16 ier;
+	volatile __u16 iir;
+	volatile __u16 lcr;
+	volatile __u16 mcr;
+	volatile __u16 lsr;
+	volatile __u16 msr;
+	volatile __u16 scr;
+} uart_reg;
+#endif /* ! __ASSEMBLY__ */
+
+/* Alias for Write Only Register */
+
+#define thr	rbr
+#define tcr	iir
+
+/* Alias for Divisor Latch Register */
+
+#define dll	rbr
+#define dlm	ier
+#define fcr	iir
+
+/* Interrupt Enable Register */
+
+#define IER_ERDAI	0x0100	/* Enable Received Data Available Interrupt */
+#define IER_ETHREI	0x0200	/* Enable Transmitter Holding Register Empty Interrupt */
+#define IER_ELSI	0x0400	/* Enable Receiver Line Status Interrupt */
+#define IER_EMSI	0x0800	/* Enable MODEM Status Interrupt */
+
+/* Interrupt Ident Register */
+
+#define IIR_IP		0x0100	/* "0" if Interrupt Pending */
+#define IIR_IIB0	0x0200	/* Interrupt ID Bit 0 */
+#define IIR_IIB1	0x0400	/* Interrupt ID Bit 1 */
+#define IIR_IIB2	0x0800	/* Interrupt ID Bit 2 */
+#define IIR_FIFO	0xc000	/* FIFOs enabled */
+
+/* FIFO Control Register */
+
+#define FCR_FEN		0x0100	/* FIFO enable */
+#define FCR_RFRES	0x0200	/* Receiver FIFO reset */
+#define FCR_TFRES	0x0400	/* Transmitter FIFO reset */
+#define FCR_DMA		0x0800	/* DMA mode select */
+#define FCR_RTL		0x4000	/* Receiver triger (LSB) */
+#define FCR_RTM		0x8000	/* Receiver triger (MSB) */
+
+/* Line Control Register */
+
+#define LCR_WLS0	0x0100	/* Word Length Select Bit 0 */
+#define LCR_WLS1	0x0200	/* Word Length Select Bit 1 */
+#define LCR_STB		0x0400	/* Number of Stop Bits */
+#define LCR_PEN		0x0800	/* Parity Enable */
+#define LCR_EPS		0x1000	/* Even Parity Select */
+#define LCR_SP		0x2000	/* Stick Parity */
+#define LCR_SB		0x4000	/* Set Break */
+#define LCR_DLAB	0x8000	/* Divisor Latch Access Bit */
+
+/* MODEM Control Register */
+
+#define MCR_DTR		0x0100	/* Data Terminal Ready */
+#define MCR_RTS		0x0200	/* Request to Send */
+#define MCR_OUT1	0x0400	/* Out 1 */
+#define MCR_IRQEN	0x0800	/* IRQ Enable */
+#define MCR_LOOP	0x1000	/* Loop */
+
+/* Line Status Register */
+
+#define LSR_DR		0x0100	/* Data Ready */
+#define LSR_OE		0x0200	/* Overrun Error */
+#define LSR_PE		0x0400	/* Parity Error */
+#define LSR_FE		0x0800	/* Framing Error */
+#define LSR_BI		0x1000	/* Break Interrupt */
+#define LSR_THRE	0x2000	/* Transmitter Holding Register Empty */
+#define LSR_TEMT	0x4000	/* Transmitter Empty */
+#define LSR_FIFOE	0x8000	/* Receiver FIFO error */
+
+/* MODEM Status Register */
+
+#define MSR_DCTS	0x0100	/* Delta Clear to Send */
+#define MSR_DDSR	0x0200	/* Delta Data Set Ready */
+#define MSR_TERI	0x0400	/* Trailing Edge Ring Indicator */
+#define MSR_DDCD	0x0800	/* Delta Data Carrier Detect */
+#define MSR_CTS		0x1000	/* Clear to Send */
+#define MSR_DSR		0x2000	/* Data Set Ready */
+#define MSR_RI		0x4000	/* Ring Indicator */
+#define MSR_DCD		0x8000	/* Data Carrier Detect */
+
+/* Baud Rate Divisor */
+
+#define UART_CLK	(1843200)	/* 1.8432 MHz */
+#define UART_BAUD(x)	(UART_CLK / (16 * (x)))
+
+/* RTC register definition */
+#define RTC_SECONDS             0
+#define RTC_SECONDS_ALARM       1
+#define RTC_MINUTES             2
+#define RTC_MINUTES_ALARM       3
+#define RTC_HOURS               4
+#define RTC_HOURS_ALARM         5
+#define RTC_DAY_OF_WEEK         6
+#define RTC_DAY_OF_MONTH        7
+#define RTC_MONTH               8
+#define RTC_YEAR                9
+#define RTC_FREQ_SELECT		10
+# define RTC_UIP 0x80
+# define RTC_DIV_CTL 0x70
+/* This RTC can work under 32.768KHz clock only.  */
+# define RTC_OSC_ENABLE 0x20
+# define RTC_OSC_DISABLE 0x00
+#define RTC_CONTROL     	11
+# define RTC_SET 0x80
+# define RTC_PIE 0x40
+# define RTC_AIE 0x20
+# define RTC_UIE 0x10
+# define RTC_SQWE 0x08
+# define RTC_DM_BINARY 0x04
+# define RTC_24H 0x02
+# define RTC_DST_EN 0x01
+
+#endif  /* __ASM_SH_SMC37C93X_H */
diff -Naur linux-2.6.17.8/include/asm-sh/smp.h linux-2.6.17.8-sh/include/asm-sh/smp.h
--- linux-2.6.17.8/include/asm-sh/smp.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/smp.h	2006-08-23 13:29:14.088025000 +0100
@@ -20,11 +20,6 @@
 #include <asm/atomic.h>
 #include <asm/current.h>
 
-extern cpumask_t cpu_online_map;
-extern cpumask_t cpu_possible_map;
-
-#define cpu_online(cpu)		cpu_isset(cpu, cpu_online_map)
-
 #define raw_smp_processor_id()	(current_thread_info()->cpu)
 
 /* I've no idea what the real meaning of this is */
diff -Naur linux-2.6.17.8/include/asm-sh/snapgear.h linux-2.6.17.8-sh/include/asm-sh/snapgear.h
--- linux-2.6.17.8/include/asm-sh/snapgear.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/snapgear.h	2006-08-23 13:29:19.009139000 +0100
@@ -0,0 +1,79 @@
+/*
+ * include/asm-sh/snapgear/io.h
+ *
+ * Modified version of io_se.h for the snapgear-specific functions.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * IO functions for a SnapGear
+ */
+
+#ifndef _ASM_SH_IO_SNAPGEAR_H
+#define _ASM_SH_IO_SNAPGEAR_H
+
+#if defined(CONFIG_CPU_SH4)
+/*
+ * The external interrupt lines, these take up ints 0 - 15 inclusive
+ * depending on the priority for the interrupt.  In fact the priority
+ * is the interrupt :-)
+ */
+
+#define IRL0_IRQ		2
+#define IRL0_IPR_ADDR	INTC_IPRD
+#define IRL0_IPR_POS	3
+#define IRL0_PRIORITY	13
+
+#define IRL1_IRQ		5
+#define IRL1_IPR_ADDR	INTC_IPRD
+#define IRL1_IPR_POS	2
+#define IRL1_PRIORITY	10
+
+#define IRL2_IRQ		8
+#define IRL2_IPR_ADDR	INTC_IPRD
+#define IRL2_IPR_POS	1
+#define IRL2_PRIORITY	7
+
+#define IRL3_IRQ		11
+#define IRL3_IPR_ADDR	INTC_IPRD
+#define IRL3_IPR_POS	0
+#define IRL3_PRIORITY	4
+#endif
+
+#define __IO_PREFIX	snapgear
+#include <asm/io_generic.h>
+
+#ifdef CONFIG_SH_SECUREEDGE5410
+/*
+ * We need to remember what was written to the ioport as some bits
+ * are shared with other functions and you cannot read back what was
+ * written :-|
+ *
+ * Bit        Read                   Write
+ * -----------------------------------------------
+ * D0         DCD on ttySC1          power
+ * D1         Reset Switch           heatbeat
+ * D2         ttySC0 CTS (7100)      LAN
+ * D3         -                      WAN
+ * D4         ttySC0 DCD (7100)      CONSOLE
+ * D5         -                      ONLINE
+ * D6         -                      VPN
+ * D7         -                      DTR on ttySC1
+ * D8         -                      ttySC0 RTS (7100)
+ * D9         -                      ttySC0 DTR (7100)
+ * D10        -                      RTC SCLK
+ * D11        RTC DATA               RTC DATA
+ * D12        -                      RTS RESET
+ */
+
+#define SECUREEDGE_IOPORT_ADDR ((volatile short *) 0xb0000000)
+extern unsigned short secureedge5410_ioport;
+
+#define SECUREEDGE_WRITE_IOPORT(val, mask) (*SECUREEDGE_IOPORT_ADDR = \
+	 (secureedge5410_ioport = \
+			((secureedge5410_ioport & ~(mask)) | ((val) & (mask)))))
+#define SECUREEDGE_READ_IOPORT() \
+	 ((*SECUREEDGE_IOPORT_ADDR&0x0817) | (secureedge5410_ioport&~0x0817))
+#endif
+
+#endif /* _ASM_SH_IO_SNAPGEAR_H */
diff -Naur linux-2.6.17.8/include/asm-sh/st220eval/coproc.h linux-2.6.17.8-sh/include/asm-sh/st220eval/coproc.h
--- linux-2.6.17.8/include/asm-sh/st220eval/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st220eval/coproc.h	2006-08-23 13:29:42.577691000 +0100
@@ -0,0 +1,22 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STm8000 platform
+ */
+
+#define COPR_RAM_START	 	0x08000000	/* LX220 LMI RAM base address */
+
+/*
+ * Note:             Mailbox 0 - Group 1     IRQ #232  Not used
+ *      LX200-0 uses Mailbox 0 - Group 2     IRQ #233
+ *      LX200-1 uses Mailbox 1 - Group 1     IRQ #234
+ *      LX200-2 uses Mailbox 1 - Group 2     IRQ #235
+ */
+#define EMBX_IRQ		233		/* first IRQ to be used       */
+#define MBX0_BASE	    	P2SEGADDR(0x10200000)
+#define MBX1_BASE	    	P2SEGADDR(0x10210000)
+#define MBX_GROUP1_BASE	    	0x000
+#define MBX_GROUP2_BASE	    	0x100
+
+#define BOOT_SIGNATURE 		  0x3a17b007
+
+#define N_COPROC	3
diff -Naur linux-2.6.17.8/include/asm-sh/st220eval/st220eval.h linux-2.6.17.8-sh/include/asm-sh/st220eval/st220eval.h
--- linux-2.6.17.8/include/asm-sh/st220eval/st220eval.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st220eval/st220eval.h	2006-08-23 13:29:30.534417000 +0100
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics ST220 Eval Board.
+ */
+
+#define EPLD_BASE        0xa2000000
+
+#define EPLD_EPLD_VER    (EPLD_BASE+0x00)
+#define EPLD_PCB_VER     (EPLD_BASE+0x04)
+#define EPLD_LED         (EPLD_BASE+0x0c)
+#define EPLD_FLASH_WE    (EPLD_BASE+0x1c)       /* Note not VPP enable */
+
+#define EPLD_LED_ON     0
+#define EPLD_LED_OFF    1
diff -Naur linux-2.6.17.8/include/asm-sh/st220eval/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/st220eval/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/st220eval/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st220eval/st40_ide.h	2006-08-23 13:29:36.639553000 +0100
@@ -0,0 +1,66 @@
+/*
+ * include/asm-sh/st220eval/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on ST220EVAL board (mb392).
+ * mb392 has the HDDI interface, that provides
+ * an interface between STBus and the IDE device.
+ */
+
+#include <asm/io.h>
+
+/* On the mb392 is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* HDDI interface is present on the mb392 board */
+#define HDDI_INTERFACE_PRESENT
+
+/* The ATA base address. For mb392 it is the HDDI base
+ * address.
+ */
+#define ATA_ADDRESS	      0xB4500000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS    0x00000040
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET   4
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET      -0x8
+
+/* ATA IRQ number, mapped on the ILC for mb392 */
+#define ATA_IRQ		ILC_FIRST_IRQ + 30
+/* ide_enable set the System configuration hddi register to
+ * enable the interface.
+ */
+#define SYSCON_REGS_BASE   0xB0300000
+#define SYSCFG_HDDI        (SYSCON_REGS_BASE + 0x14)
+#define ide_enable()	ctrl_outl(0x3FFFF800, SYSCFG_HDDI);
+
+/* hddi_reset performs the HDDI reset. */
+#define hddi_reset()    ctrl_outl(0x01,  HDDI_ATARESET); \
+                        ctrl_outl(0x00,  HDDI_ATARESET);
+
+/* hddi_set_pio_timings sets the PIO timing registers
+ * at a fixed rate.
+ */
+#define hddi_set_pio_timings(rate)      set_pio_timings(rate);
+
+/* ide_ack_intr is requested by the ide_intr function.
+ * It resets the interrupt reading the HDDI_DMA_ITS registeri for
+ * those platform having the HDDI interface.
+ */
+#define ide_ack_intr(hwif)      st40ide_ack_intr(hwif)
+
+/* hddi_setup_dma allocate the dma engine, giving at the IDE
+ * interface the possibility to work in DMA mode.
+ */
+#define hddi_setup_dma(interface, address, offset)      _ide_setup_dma(interface, address, offset);
diff -Naur linux-2.6.17.8/include/asm-sh/st40core_ide.h linux-2.6.17.8-sh/include/asm-sh/st40core_ide.h
--- linux-2.6.17.8/include/asm-sh/st40core_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st40core_ide.h	2006-08-23 13:29:36.676553000 +0100
@@ -0,0 +1,114 @@
+/*
+ * include/asm-sh/st40core_ide.h
+ */
+
+#include <asm/irq.h>
+#include <asm/clock.h>
+#include <asm/mach/st40_ide.h>
+
+#ifndef ATA_ADDRESS
+#error "HDDI not supported by this ST platform!"
+#endif
+#define ATA_REG_ADDRESS		(ATA_ADDRESS + ATA_DATA_OFFS_ADDRESS)
+
+#ifdef HDDI_INTERFACE_PRESENT
+#define HDDI_MODE          (ATA_ADDRESS + 0x00000080)
+#define HDDI_ATARESET      (ATA_ADDRESS + 0x00000084)
+/* HDDI DMA control registers */
+#define HDDI_DMA_SA       (ATA_ADDRESS + 0x000000B4)  /* RW: Start Addr.  */
+#define HDDI_DMA_WC       (ATA_ADDRESS + 0x000000B8)  /* RW: Word count   */
+#define HDDI_DMA_SI       (ATA_ADDRESS + 0x000000BC)  /* RW: burst size   */
+#define HDDI_DMA_CA       (ATA_ADDRESS + 0x000000D0)  /* R-: current addr.*/
+#define HDDI_DMA_CB       (ATA_ADDRESS + 0x000000D4)  /* R-: bytes resid  */
+#define HDDI_DMA_PS       (ATA_ADDRESS + 0x000000D8)  /* RW: packet size  */
+#define HDDI_DMA_ITS      (ATA_ADDRESS + 0x000000E0)  /* R-: IRQ status   */
+#define HDDI_DMA_ITM      (ATA_ADDRESS + 0x000000E8)  /* -W: masked IRQs  */
+#define HDDI_DMA_STA      (ATA_ADDRESS + 0x000000E4)  /* RW: DMA status   */
+#define HDDI_DMA_C        (ATA_ADDRESS + 0x000000B0)  /* RW: DMA control  */
+
+/*
+** HDDI bit masks Select the ATA/ATAPI data transfer protocol
+*/
+
+#define DMA_MASK             0xFFE0     /* used to test the DMA engine  */
+                                        /* status (inactive =0)         */
+                                        /* Note: STm8000 bits [10-8]    */
+                                        /*       STi5528 bits [11-9]    */
+
+#define ATA_PIO_MODE            0x0     /* PIO Mode (register transfer) */
+#define ATA_MWDMA_MODE          0x2     /* Multi word DMA               */
+#define ATA_UDMA_MODE           0x3     /* Ultra DMA mode               */
+#define DMA_START               0x1     /* See DMA control reg. bit 1   */
+#define DMA_ENABLE              0x4     /* See DMA control reg. bit 2   */
+#define DMA_DEVTERM_OK          0x4     /* See DMA status reg. bit 2    */
+#define DMA_END_OK              0x1     /* See DMA status reg. bit 1    */
+#define PIO_RATE                  4     /* PIO mode = 4 (transfer rate) */
+#define UDMA_RATE                 4     /* U-DMA mode = 4 (transf. rate)*/
+
+#define READ_FROM_DEVICE          1
+#define WRITE_TO_DEVICE           2
+
+/* _ata_adjust:  adjust the time value before setting the relevant
+ *               HDDI register.
+ *               Time value depend on HDD_CLK frequency (ST-BUS clock)
+ *
+ *               Reg value =  V(tab) *  Period(HDD_CLK)
+ *
+ *    where period of HDD_CLK  = 7.51ns (assuming HDD_CLK = BUS_CLK = 133 Mhz)
+ */
+static inline unsigned int _ata_adjust(unsigned int time)
+{
+	struct clk *clk;
+	unsigned long mhz;
+	unsigned int v;
+
+	clk = clk_get("stbus_clk");
+	mhz = clk_get_rate(clk) / 1000000;
+	clk_put(clk);
+
+        v = (time * mhz) / 1000;
+        /* round up to nearest greater integer */
+        if ( (time * mhz % 1000) > 0 ) v++;
+        /* subtract 1 before use...            */
+        if (v > 0) v--;
+        return(v);
+}
+#endif /* HDDI_INTERFACE_PRESENT */
+
+#define IDE_ARCH_OBSOLETE_DEFAULTS
+#define IDE_ARCH_OBSOLETE_INIT
+#define ide_init_default_irq(base) ide_default_irq(base)
+#define	ide_default_irq(base)	ide_default_irq_st40
+#define ide_default_irq_st40	 ATA_IRQ
+
+/* This is only to initialize the hwif->io_ports array,
+ * in order to avoid the hwif->noprobe = 1 to default.
+ * The right initialization will be performed into
+ * ide-sh.c, calling the ide_sh_init_hwif_ports function.
+ */
+#define ide_default_io_base(index)	0x1f0
+
+#define MAX_REQUEST_SIZE(hwif)  (hwif->rqsize * 1024)
+extern int st40ide_ack_intr(struct hwif_s *);
+extern int sh_udma_choosen[];
+extern void ide_sh_init(void);
+#define IDE_ARCH_ACK_INTR	1
+
+static __inline__ void ide_sh_init_hwif_ports(hw_regs_t *hw, unsigned long data_port, unsigned long ctrl_port, int *irq)
+{
+        unsigned long reg = data_port;
+        int i;
+
+        for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+                hw->io_ports[i] = reg;
+                reg += REG_OFFSET;
+        }
+        if (ctrl_port) {
+                hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+        } else {
+                hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + CTRL_REG_OFFSET;
+        }
+        if (irq != NULL)
+                *irq = 0;
+        hw->io_ports[IDE_IRQ_OFFSET] = 0;
+}
diff -Naur linux-2.6.17.8/include/asm-sh/st40gx1eval/harp.h linux-2.6.17.8-sh/include/asm-sh/st40gx1eval/harp.h
--- linux-2.6.17.8/include/asm-sh/st40gx1eval/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st40gx1eval/harp.h	2006-08-23 13:29:29.818392000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40GX1 Eval Board.
+ */
+
+#define EPLD_BASE		0xa7000000
+#define EPLD_SIZE		0x00f00000
+
+#define EPLD_REVID1		(EPLD_BASE+0x00000000) /* drw1325 IC42 */
+#define EPLD_TEST1		(EPLD_BASE+0x00040000) /* drw1325 IC42 */
+#define EPLD_7SEG		(EPLD_BASE+0x002c0000)
+#define EPLD_VPP		(EPLD_BASE+0x00300000)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00440000)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00480000)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x004c0000)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00500000)
+#define EPLD_REVID2		(EPLD_BASE+0x00700000) /* drw1326 IC43 */
+#define EPLD_TEST2		(EPLD_BASE+0x00740000) /* drw1326 IC43 */
+#define EPLD_LED		(EPLD_BASE+0x00d00000)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x00e00000)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x00e40000)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00e80000)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x00ec0000)
+
+#define EPLD_LED_ON   1
+#define EPLD_LED_OFF  0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+        unsigned long version, major, minor;
+        version = ctrl_inl(EPLD_REVID1);
+	minor = version & 0xf;
+        major = (version >> 4) & 0xf;
+        return ((major == 10) && (minor >= 2)) || (major >= 11);
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	ctrl_outl(1, EPLD_VPP);
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	ctrl_outl(0, EPLD_VPP);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/st40raeval/harp.h linux-2.6.17.8-sh/include/asm-sh/st40raeval/harp.h
--- linux-2.6.17.8/include/asm-sh/st40raeval/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st40raeval/harp.h	2006-08-23 13:29:29.825392000 +0100
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40RA Eval board.
+ */
+
+#define EPLD_BASE		0xa6000000
+#define EPLD_SIZE		0x40
+
+#define EPLD_REVID_PLD		(EPLD_BASE+0x00000000)
+#define EPLD_REVID_BOARD	(EPLD_BASE+0x00000004)
+#define EPLD_GPCR		(EPLD_BASE+0x00000018)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x00000020)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00000024)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00000028)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x0000002c)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x00000030)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00000034)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00000038)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x0000003c)
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+	return 1;
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/st40rastarter/harp.h linux-2.6.17.8-sh/include/asm-sh/st40rastarter/harp.h
--- linux-2.6.17.8/include/asm-sh/st40rastarter/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/st40rastarter/harp.h	2006-08-23 13:29:29.833392000 +0100
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40RA Starter Board.
+ */
+
+#define EPLD_BASE		0xa7000000
+#define EPLD_SIZE		0x34
+
+#define EPLD_REVID		(EPLD_BASE+0x00000000)
+#define EPLD_RESET		(EPLD_BASE+0x00000004)
+#define EPLD_LED_SET		(EPLD_BASE+0x00000008)
+#define EPLD_LED_CLR		(EPLD_BASE+0x0000000c)
+#define EPLD_VPP		(EPLD_BASE+0x00000010)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00000014)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x00000018)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x0000001c)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00000020)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00000024)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x00000028)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x0000002c)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00000030)
+
+#define EPLD_LED_ON   1
+#define EPLD_LED_OFF  0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+	return 1;
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	ctrl_outl(1, EPLD_VPP);
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	ctrl_outl(0, EPLD_VPP);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/stb1harp/harp.h linux-2.6.17.8-sh/include/asm-sh/stb1harp/harp.h
--- linux-2.6.17.8/include/asm-sh/stb1harp/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb1harp/harp.h	2006-08-23 13:29:29.841392000 +0100
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40STB1 HARP.
+ */
+
+#define EPLD_BASE	0xa0800000
+#define EPLD_SIZE	0x00500000
+
+/*
+ * switch settings are mixed up
+ * switch on = EPLD signal low, off = high
+
+ *     s/w register    =   EPLD signal   =   SW  -> MODE
+ *  EPLD_SWITCH2 bit 0 = ! IC8 switch3_1 = SW1-1 ->
+ *  EPLD_SWITCH2 bit 1 = ! IC8 switch3_1 = SW1-2 ->
+ *  EPLD_SWITCH2 bit 2 = ! IC8 switch3_1 = SW1-3 ->
+ *  EPLD_SWITCH2 bit 3 = ! IC8 switch3_1 = SW1-4 ->
+ *  EPLD_SWITCH2 bit 4 = MEZZ_PRES0
+ *  EPLD_SWITCH2 bit 5 = MEZZ_PRES1
+ *
+ *  EPLD_SWITCH1 bit 0 = ! IC36 switch1_1 = SW3-1 -> ! Mode[0] \
+ *  EPLD_SWITCH1 bit 1 = ! IC36 switch1_2 = SW3-2 -> ! Mode[1]  > freq select
+ *  EPLD_SWITCH1 bit 2 = ! IC36 switch1_3 = SW3-3 -> ! Mode[2] /
+ *  EPLD_SWITCH1 bit 3 = ! IC36 switch1_4 = SW3-4 -> ! Mode[5] - crystal enable
+ *  EPLD_SWITCH1 bit 4 = ! IC36 switch2_1 = SW2-1 -> ! Mode[3] \ PCI fre select
+ *  EPLD_SWITCH1 bit 5 = ! IC36 switch2_2 = SW2-2 -> ! Mode[4] /
+ *  EPLD_SWITCH1 bit 6 = ! IC36 switch2_3 = SW2-3 -> ! Mode[6] - CLKIO = 27Mhz
+ *  EPLD_SWITCH1 bit 7 = ! IC36 switch2_4 = SW2-4 -> ! Mode[8] - endianness
+ */
+
+#define EPLD_FLASHCTRL		(EPLD_BASE+0x00000000)
+#define EPLD_SWITCH1		(EPLD_BASE+0x00040000) // IC36: switch1/SW2-4->1 switch2/SW1-4->1
+#define EPLD_SWITCH2		(EPLD_BASE+0x00080000) // IC8:  x x STEM1 STEM0 switch3/SW1-41>1
+#define EPLD_LED		(EPLD_BASE+0x000c0000)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x00200000)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00240000)
+#define EPLD_INTMASK0		(EPLD_BASE+0x00280000)
+#define EPLD_INTMASK1		(EPLD_BASE+0x002c0000)
+#define EPLD_PAGEADDR		(EPLD_BASE+0x00300000)
+#define EPLD_REVID1		(EPLD_BASE+0x00380000)
+#define EPLD_REVID2		(EPLD_BASE+0x003c0000)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x00400000)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x00440000)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00480000)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x004c0000)
+
+#define EPLD_LED_ON  1
+#define EPLD_LED_OFF 0
+
+#ifndef __ASSEMBLY__
+/*
+ * The set and clear registers are only present in EPLD revision:
+ *   2.2 or higher, 3.3 or higher, 4 or higher
+ */
+extern inline int harp_has_intmask_setclr(void)
+{
+	unsigned long version, major, minor;
+	version = ctrl_inl(EPLD_REVID2);
+	minor = version & 0xf;
+	major = (version >> 4) & 0xf;
+	return ((major == 2) && (minor >= 2)) ||
+	       ((major == 3) && (minor >= 3)) ||
+                (major >= 4);
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	ctrl_outl(3, EPLD_FLASHCTRL);
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	ctrl_outl(0, EPLD_FLASHCTRL);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/stb1harp/io.h linux-2.6.17.8-sh/include/asm-sh/stb1harp/io.h
--- linux-2.6.17.8/include/asm-sh/stb1harp/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb1harp/io.h	2006-08-23 13:29:29.850393000 +0100
@@ -0,0 +1,10 @@
+#ifndef __ASM_SH_HARP_IO_H
+#define __ASM_SH_HARP_IO_H
+
+/*
+ * Nothing special here.. just use the generic cchip io routines.
+ */
+#include <asm/hd64465/io.h>
+
+#endif /* __ASM_SH_HARP_IO_H */
+
diff -Naur linux-2.6.17.8/include/asm-sh/stb1overdrive/harp.h linux-2.6.17.8-sh/include/asm-sh/stb1overdrive/harp.h
--- linux-2.6.17.8/include/asm-sh/stb1overdrive/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb1overdrive/harp.h	2006-08-23 13:29:29.855392000 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Defintions applicable to the STMicroelectronics ST40STB1 Overdrive.
+ */
+
+#define EPLD_BASE		0xa7000000
+#define EPLD_SIZE		0x00500000
+
+#define EPLD_REVID		(EPLD_BASE+0x00000000)
+#define EPLD_LED		(EPLD_BASE+0x00040000)
+#define EPLD_SWITCH		(EPLD_BASE+0x00140000) // x x STEM1 STEM0 SW1-4 -> SW1-1
+#define EPLD_INTMASK0		(EPLD_BASE+0x001c0000)
+#define EPLD_INTMASK1		(EPLD_BASE+0x00200000)
+#define EPLD_INTSTAT0		(EPLD_BASE+0x00240000)
+#define EPLD_INTSTAT1		(EPLD_BASE+0x00280000)
+#define EPLD_EMPMBINT		(EPLD_BASE+0x00340000)
+#define EPLD_INTMASK0SET	(EPLD_BASE+0x00380000)
+#define EPLD_INTMASK0CLR	(EPLD_BASE+0x003c0000)
+#define EPLD_INTMASK1SET	(EPLD_BASE+0x00400000)
+#define EPLD_INTMASK1CLR	(EPLD_BASE+0x00440000)
+
+#define EPLD_LED_ON  0
+#define EPLD_LED_OFF 1
+
+#ifndef __ASSEMBLY__
+/*
+ * The set and clear registers are only present in EPLD revisions:
+ *   4.1 or higher and 9 or higher
+ */
+extern inline int harp_has_intmask_setclr(void)
+{
+        unsigned long version, major, minor;
+        version = ctrl_inl(EPLD_REVID);
+	minor = version & 0xf;
+        major = (version >> 4) & 0xf;
+        return ((major == 4) && (minor >= 1)) || (major >= 9);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/stb7100mboard/coproc.h linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/coproc.h
--- linux-2.6.17.8/include/asm-sh/stb7100mboard/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/coproc.h	2006-08-23 13:29:42.593691000 +0100
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff -Naur linux-2.6.17.8/include/asm-sh/stb7100mboard/harp.h linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/harp.h
--- linux-2.6.17.8/include/asm-sh/stb7100mboard/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/harp.h	2006-08-23 13:29:36.339553000 +0100
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics STb7100 Validation board.
+ */
+
+#define epld_out(val,addr) ctrl_outb(val,addr)
+#define epld_in(addr)      ctrl_inb(addr)
+
+#define EPLD_BASE		0xa3000000
+#define EPLD_EPLDVER		(EPLD_BASE + 0x000000)
+#define EPLD_PCBVER		(EPLD_BASE + 0x020000)
+#define EPLD_STEM		(EPLD_BASE + 0x040000)
+#define EPLD_DRIVER		(EPLD_BASE + 0x060000)
+#define EPLD_RESET		(EPLD_BASE + 0x080000)
+#define EPLD_INTSTAT0		(EPLD_BASE + 0x0a0000)
+#define EPLD_INTSTAT1		(EPLD_BASE + 0x0c0000)
+#define EPLD_INTMASK0		(EPLD_BASE + 0x0e0000)
+#define EPLD_INTMASK0SET	(EPLD_BASE + 0x100000)
+#define EPLD_INTMASK0CLR	(EPLD_BASE + 0x120000)
+#define EPLD_INTMASK1		(EPLD_BASE + 0x140000)
+#define EPLD_INTMASK1SET	(EPLD_BASE + 0x160000)
+#define EPLD_INTMASK1CLR	(EPLD_BASE + 0x180000)
+#define EPLD_TEST		(EPLD_BASE + 0x1e0000)
+#define EPLD_FLASH		(EPLD_BASE + 0x400000)
+#define EPLD_ATAPI		(EPLD_BASE + 0x900000)
+
+/* Some registers are also available in the POD EPLD */
+#define EPLD_POD_BASE		0xa2100000
+#define EPLD_POD_REVID		(EPLD_POD_BASE + 0x00)
+#define EPLD_POD_LED		(EPLD_POD_BASE + 0x10)
+#define EPLD_POD_DEVID		(EPLD_POD_BASE + 0x1c)
+
+#define EPLD_LED_ON     1
+#define EPLD_LED_OFF    0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+        return 1;
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	epld_out(3, EPLD_FLASH);	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	epld_out(2, EPLD_FLASH);	/* Leave ON only RESET		*/
+}
+
+extern inline void harp_set_atapi_on(void)
+{
+	epld_out(1, EPLD_ATAPI);
+}
+
+extern inline void harp_set_atapi_off(void)
+{
+	epld_out(0, EPLD_ATAPI);
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/stb7100mboard/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/stb7100mboard/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7100mboard/st40_ide.h	2006-08-23 13:29:36.683553000 +0100
@@ -0,0 +1,59 @@
+/*
+ * include/asm-sh/stb7100mboard/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on stb7100mboard board (mb411).
+ * mb411 has not the HDDI interface, IDE is mapped on
+ * the EMI bank3.
+ *
+ */
+
+#include <asm/mach/harp.h>
+
+/* On the mb411 is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. For mb411 it is an EPLD
+ * address.
+ */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET	0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number, mapped as an IRL interrupts for mb411 */
+#define ATA_IRQ		8
+
+/* ide_enable set the EPLD ATAPI register to 1, enabling the IDE
+ * interface.
+ */
+#define ide_enable()	harp_set_atapi_on();
+
+/* hddi_reset does nothing for mb411, because it has not an HDDI interface. */
+#define hddi_reset()	;
+
+/* hddi_set_pio_timings does nothing for mb411, because it has not an HDDI
+ * interface and PIO timings are setted into the EMI bank3 (PIO4).
+ */
+#define hddi_set_pio_timings(rate)      ;
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
+
+/* DMA in not supported for mb411 board, so hddi_setup_dma does nothing. */
+#define hddi_setup_dma(interface, address, offset)	;
diff -Naur linux-2.6.17.8/include/asm-sh/stb7100ref/coproc.h linux-2.6.17.8-sh/include/asm-sh/stb7100ref/coproc.h
--- linux-2.6.17.8/include/asm-sh/stb7100ref/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7100ref/coproc.h	2006-08-23 13:29:42.600692000 +0100
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff -Naur linux-2.6.17.8/include/asm-sh/stb7100ref/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/stb7100ref/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/stb7100ref/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7100ref/st40_ide.h	2006-08-23 13:29:40.381646000 +0100
@@ -0,0 +1,51 @@
+/*
+ * include/asm-sh/stb7100ref/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on stb7100ref board.
+ * IDE is mapped into EMI bank3.
+ */
+
+/* STb7100 only has one hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. This is the base of EMI bank 3. */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET		0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number */
+#define ATA_IRQ			IRL1_IRQ
+
+/* ide_enable does nothing because there is no external hardware to configure */
+#define ide_enable()
+
+/* hddi_reset does nothing for stb7100, because it does not have a HDDI interface. */
+#define hddi_reset()
+
+/* hddi_set_pio_timings does nothing for mb411, because it has not an HDDI
+ * interface and PIO timings are setted into the EMI bank3 (PIO4).
+ */
+#define hddi_set_pio_timings(rate)
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
+
+/* DMA in not supported for mb411 board, so hddi_setup_dma does nothing. */
+#define hddi_setup_dma(interface, address, offset)
diff -Naur linux-2.6.17.8/include/asm-sh/stb7109eref/coproc.h linux-2.6.17.8-sh/include/asm-sh/stb7109eref/coproc.h
--- linux-2.6.17.8/include/asm-sh/stb7109eref/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7109eref/coproc.h	2006-08-23 13:29:43.050691000 +0100
@@ -0,0 +1,13 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STb7100 platform
+ */
+
+#define N_COPROC        2
+
+#define COPR_RAM_START	 	0x4000000	/* ST231 LMI RAM base address */
+
+#define SYSCON_REGS_BASE        P2SEGADDR(0x19001000)
+#define SYSCFG_09		(SYSCON_REGS_BASE + 0x124)
+#define SYSCFG_BOOT_REG(x)	(SYSCON_REGS_BASE + (x ? 0x168 : 0x170))
+#define SYSCFG_RESET_REG(x)	(SYSCON_REGS_BASE + (x ? 0x16c : 0x174))
diff -Naur linux-2.6.17.8/include/asm-sh/stb7109eref/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/stb7109eref/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/stb7109eref/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stb7109eref/st40_ide.h	2006-08-23 13:29:43.061692000 +0100
@@ -0,0 +1,51 @@
+/*
+ * include/asm-sh/stb7109eref/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on STb7109E Reference Board.
+ * IDE is mapped into EMI bank 4.
+ */
+
+/* STb7109 only has one hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* The ATA base address. This is the base of EMI bank 3. */
+#define ATA_ADDRESS           0xA2800000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS	0x00200000
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET		0x20000
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET		-0x40000
+
+/* ATA IRQ number */
+#define ATA_IRQ			IRL2_IRQ
+
+/* ide_enable does nothing because there is no external hardware to configure */
+#define ide_enable()
+
+/* hddi_reset does nothing for stb7109, because it does not have a HDDI interface. */
+#define hddi_reset()
+
+/* hddi_set_pio_timings does nothing for mb448, because it has not an HDDI
+ * interface and PIO timings are setted into the EMI bank 4 (PIO4).
+ */
+#define hddi_set_pio_timings(rate)
+
+/* ide_ack_intr returns 1 when invoked.
+ * It is needed by the ide_intr function.
+ */
+#define ide_ack_intr(hwif)	1
+
+/* DMA in not supported for mb448 board, so hddi_setup_dma does nothing. */
+#define hddi_setup_dma(interface, address, offset)
diff -Naur linux-2.6.17.8/include/asm-sh/sti5528espresso/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/sti5528espresso/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/sti5528espresso/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/sti5528espresso/st40_ide.h	2006-08-23 13:29:36.689555000 +0100
@@ -0,0 +1,62 @@
+/*
+ * include/asm-sh/sti5528espresso/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on Espresso board.
+ * Espresso has the HDDI interface, that provides
+ * an interface between STBus and the IDE device.
+ */
+
+/* On the Espresso is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* HDDI interface is present on the Espresso board */
+#define HDDI_INTERFACE_PRESENT
+
+/* The ATA base address. For Espresso it is the HDDI base
+ * address.
+ */
+#define ATA_ADDRESS      0xB9140000
+
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS    0x00000040
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET   4
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET      -0x8
+
+/* ATA IRQ number */
+#define ATA_IRQ		173
+
+/* ide_enable does nothing on the Espresso platform. */
+#define ide_enable()	;
+
+/* hddi_reset performs the HDDI reset. */
+#define hddi_reset()	ctrl_outl(0x01,  HDDI_ATARESET); \
+			ctrl_outl(0x00,  HDDI_ATARESET);
+
+/* hddi_set_pio_timings sets the PIO timing registers
+ * at a fixed rate.
+ */
+#define hddi_set_pio_timings(rate)	set_pio_timings(rate);
+
+/* ide_ack_intr is requested by the ide_intr function.
+ * It resets the interrupt reading the HDDI_DMA_ITS registeri for
+ * those platform having the HDDI interface.
+ */
+#define ide_ack_intr(hwif)      st40ide_ack_intr(hwif)
+
+/* hddi_setup_dma allocate the dma engine, giving at the IDE
+ * interface the possibility to work in DMA mode.
+ */
+#define hddi_setup_dma(interface, address, offset)	_ide_setup_dma(interface, address, offset);
diff -Naur linux-2.6.17.8/include/asm-sh/sti5528eval/harp.h linux-2.6.17.8-sh/include/asm-sh/sti5528eval/harp.h
--- linux-2.6.17.8/include/asm-sh/sti5528eval/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/sti5528eval/harp.h	2006-08-23 13:29:30.545415000 +0100
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics STi5528 Eval Board.
+ */
+
+/* The 5528 has an 8 bit bus. The interrupt code happens to work
+ * by chance, because you only ever write masks. These macros have
+ * been introduced in case we need to change something board specific
+ */
+#define epld_out(val,addr) ctrl_outb(val,addr)
+#define epld_in(addr)      ctrl_inb(addr)
+
+#define EPLD_BASE        0xa2000000
+#define EPLD_REVID       (EPLD_BASE+0x00000000)         /* Current: 1533   */
+#define EPLD_LED         (EPLD_BASE+0x00040000)
+#define EPLD_TEST        (EPLD_BASE+0x00080000)
+#define EPLD_INTMASK0    (EPLD_BASE+0x000c0000)
+#define EPLD_INTMASK1    (EPLD_BASE+0x00100000)
+#define EPLD_INTSTAT0    (EPLD_BASE+0x00140000)         /* So far not used */
+#define EPLD_INTSTAT1    (EPLD_BASE+0x00180000)         /* So far not used */
+#define EPLD_INTMASK0SET (EPLD_BASE+0x001c0000)
+#define EPLD_INTMASK0CLR (EPLD_BASE+0x00200000)
+#define EPLD_INTMASK1SET (EPLD_BASE+0x00240000)
+#define EPLD_INTMASK1CLR (EPLD_BASE+0x00280000)
+#define EPLD_USB0Cx      (EPLD_BASE+0x002c0000)         /* So far not used */
+#define EPLD_FLASH       (EPLD_BASE+0x00300000)         /* Vpp Flash (MTD) */
+#define EPLD_STEM        (EPLD_BASE+0x00340000)         /* Stem reset      */
+#define EPLD_STEMSET     (EPLD_BASE+0x00380000)
+#define EPLD_STEMCLR     (EPLD_BASE+0x003c0000)
+
+#define EPLD_LED_ON     0
+#define EPLD_LED_OFF    1
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+        return 1;
+}
+
+extern inline void harp_set_vpp_on(void)
+{
+	epld_out(3, EPLD_FLASH);	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+extern inline void harp_set_vpp_off(void)
+{
+	epld_out(2, EPLD_FLASH);	/* Leave ON only RESET		*/
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/sti5528eval/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/sti5528eval/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/sti5528eval/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/sti5528eval/st40_ide.h	2006-08-23 13:29:36.700553000 +0100
@@ -0,0 +1,62 @@
+/*
+ * include/asm-sh/sti5528eval/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on Evaluation board (mb376).
+ * mb376 has the HDDI interface, that provides
+ * an interface between STBus and the IDE device.
+ */
+
+/* On the mb376 is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* HDDI interface is present on the mb376 board */
+#define HDDI_INTERFACE_PRESENT
+
+/* The ATA base address. For mb376 it is the HDDI base
+ * address.
+ */
+#define ATA_ADDRESS      0xB9140000
+
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS    0x00000040
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET   4
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET      -0x8
+
+/* ATA IRQ number */
+#define ATA_IRQ		173
+
+/* ide_enable does nothing on the mb376 platform. */
+#define ide_enable()	;
+
+/* hddi_reset performs the HDDI reset. */
+#define hddi_reset()	ctrl_outl(0x01,  HDDI_ATARESET); \
+			ctrl_outl(0x00,  HDDI_ATARESET);
+
+/* hddi_set_pio_timings sets the PIO timing registers
+ * at a fixed rate.
+ */
+#define hddi_set_pio_timings(rate)	set_pio_timings(rate);
+
+/* ide_ack_intr is requested by the ide_intr function.
+ * It resets the interrupt reading the HDDI_DMA_ITS registeri for
+ * those platform having the HDDI interface.
+ */
+#define ide_ack_intr(hwif)      st40ide_ack_intr(hwif)
+
+/* hddi_setup_dma allocate the dma engine, giving at the IDE
+ * interface the possibility to work in DMA mode.
+ */
+#define hddi_setup_dma(interface, address, offset)	_ide_setup_dma(interface, address, offset);
diff -Naur linux-2.6.17.8/include/asm-sh/stm8000demo/coproc.h linux-2.6.17.8-sh/include/asm-sh/stm8000demo/coproc.h
--- linux-2.6.17.8/include/asm-sh/stm8000demo/coproc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stm8000demo/coproc.h	2006-08-23 13:29:42.586691000 +0100
@@ -0,0 +1,22 @@
+/* ------------------------------------------------------------------------
+ *
+ *  HW dependent actions: STm8000 platform
+ */
+
+#define COPR_RAM_START	 	0x08000000	/* LX220 LMI RAM base address */
+
+/*
+ * Note:             Mailbox 0 - Group 1     IRQ #232  Not used
+ *      LX200-0 uses Mailbox 0 - Group 2     IRQ #233
+ *      LX200-1 uses Mailbox 1 - Group 1     IRQ #234
+ *      LX200-2 uses Mailbox 1 - Group 2     IRQ #235
+ */
+#define EMBX_IRQ		233		/* first IRQ to be used       */
+#define MBX0_BASE	    	P2SEGADDR(0x10200000)
+#define MBX1_BASE	    	P2SEGADDR(0x10210000)
+#define MBX_GROUP1_BASE	    	0x000
+#define MBX_GROUP2_BASE	    	0x100
+
+#define BOOT_SIGNATURE 		  0x3a17b007
+
+#define N_COPROC	3
diff -Naur linux-2.6.17.8/include/asm-sh/stm8000demo/harp.h linux-2.6.17.8-sh/include/asm-sh/stm8000demo/harp.h
--- linux-2.6.17.8/include/asm-sh/stm8000demo/harp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stm8000demo/harp.h	2006-08-23 13:29:30.554417000 +0100
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Definitions applicable to the STMicroelectronics STm8000 Demo Board.
+ */
+
+#define epld_out(val,addr) ctrl_outb(val,addr)
+#define epld_in(addr)      ctrl_inb(addr)
+
+#define EPLD_BASE        0xa7000000
+
+#define EPLD_EPLD_VER    (EPLD_BASE+0x00000000)
+#define EPLD_PCB_VER     (EPLD_BASE+0x00000004)
+#define EPLD_INTSTAT0    (EPLD_BASE+0x00000020)
+#define EPLD_INTSTAT1    (EPLD_BASE+0x00000024)
+#define EPLD_INTMASK0    (EPLD_BASE+0x00000028)
+#define EPLD_INTMASK0SET (EPLD_BASE+0x0000002c)
+#define EPLD_INTMASK0CLR (EPLD_BASE+0x00000030)
+#define EPLD_INTMASK1    (EPLD_BASE+0x00000034)
+#define EPLD_INTMASK1SET (EPLD_BASE+0x00000038)
+#define EPLD_INTMASK1CLR (EPLD_BASE+0x0000003c)
+#define EPLD_LED_CTRL    (EPLD_BASE+0x00000044)
+#define EPLD_LED         (EPLD_BASE+0x00000078)
+#define EPLD_TEST        (EPLD_BASE+0x0000007c)
+
+#define EPLD_LED_ON     1
+#define EPLD_LED_OFF    0
+
+#ifndef __ASSEMBLY__
+extern inline int harp_has_intmask_setclr(void)
+{
+        return 1;
+}
+
+void harp_init_irq(void);
+#endif /* !__ASSEMBLY__ */
diff -Naur linux-2.6.17.8/include/asm-sh/stm8000demo/st40_ide.h linux-2.6.17.8-sh/include/asm-sh/stm8000demo/st40_ide.h
--- linux-2.6.17.8/include/asm-sh/stm8000demo/st40_ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/stm8000demo/st40_ide.h	2006-08-23 13:29:36.708555000 +0100
@@ -0,0 +1,66 @@
+/*
+ * include/asm-sh/stm8000demo/st40_ide.h
+ *
+ * This file contains all the definitions to support
+ * the IDE interface on STm8000DEMO board (mb379).
+ * mb379 has the HDDI interface, that provides
+ * an interface between STBus and the IDE device.
+ */
+
+#include <asm/io.h>
+
+/* On the mb379 is present only 1 hw interface */
+#undef MAX_HWIFS
+#define MAX_HWIFS       1
+
+/* HDDI interface is present on the mb379 board */
+#define HDDI_INTERFACE_PRESENT
+
+/* The ATA base address. For mb379 it is the HDDI base
+ * address.
+ */
+#define ATA_ADDRESS	      0xB4500000
+
+/* The ATA data base address offset. It is used to map
+ * all the ide registers on the hwif interface
+ * starting from this offset.
+ */
+#define ATA_DATA_OFFS_ADDRESS    0x00000040
+
+/* The ide registers offset. Registers will be stored into
+ * the hwif interface with a costant offset starting from
+ * the ATA data register address.
+ */
+#define REG_OFFSET   4
+
+/* Only the control register has a different offset. */
+#define CTRL_REG_OFFSET      -0x8
+
+/* ATA IRQ number, mapped on the ILC for mb379 */
+#define ATA_IRQ		ILC_FIRST_IRQ + 30
+/* ide_enable set the System configuration hddi register to
+ * enable the interface.
+ */
+#define SYSCON_REGS_BASE   0xB0300000
+#define SYSCFG_HDDI        (SYSCON_REGS_BASE + 0x14)
+#define ide_enable()	ctrl_outl(0x3FFFF800, SYSCFG_HDDI);
+
+/* hddi_reset performs the HDDI reset. */
+#define hddi_reset()    ctrl_outl(0x01,  HDDI_ATARESET); \
+                        ctrl_outl(0x00,  HDDI_ATARESET);
+
+/* hddi_set_pio_timings sets the PIO timing registers
+ * at a fixed rate.
+ */
+#define hddi_set_pio_timings(rate)      set_pio_timings(rate);
+
+/* ide_ack_intr is requested by the ide_intr function.
+ * It resets the interrupt reading the HDDI_DMA_ITS registeri for
+ * those platform having the HDDI interface.
+ */
+#define ide_ack_intr(hwif)      st40ide_ack_intr(hwif)
+
+/* hddi_setup_dma allocate the dma engine, giving at the IDE
+ * interface the possibility to work in DMA mode.
+ */
+#define hddi_setup_dma(interface, address, offset)      _ide_setup_dma(interface, address, offset);
diff -Naur linux-2.6.17.8/include/asm-sh/system.h linux-2.6.17.8-sh/include/asm-sh/system.h
--- linux-2.6.17.8/include/asm-sh/system.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/system.h	2006-08-23 13:29:49.434852000 +0100
@@ -5,8 +5,14 @@
  * Copyright (C) 1999, 2000  Niibe Yutaka  &  Kaz Kojima
  * Copyright (C) 2002 Paul Mundt
  */
-
+/*
+  15th jan 2006  Added gKSA (Kernel gUSA) support
+                   Francesco Virlinzi <francesco.virlinzi@st.com>
+  1st  Apr 2006  Moved the gKSA in gRB
+                   Francesco Virlinzi <francesco.virlinzi@st.com>
+*/
 #include <linux/config.h>
+#include <asm/types.h>
 
 /*
  *	switch_to() should switch tasks to task nr n, first
@@ -21,6 +27,7 @@
  register unsigned long *__ts6 __asm__ ("r6") = &next->thread.sp;	\
  register unsigned long __ts7 __asm__ ("r7") = next->thread.pc;		\
  __asm__ __volatile__ (".balign 4\n\t" 					\
+		       "__switch_to_begin:\n\t"				\
 		       "stc.l	gbr, @-r15\n\t" 			\
 		       "sts.l	pr, @-r15\n\t" 				\
 		       "mov.l	r8, @-r15\n\t" 				\
@@ -50,6 +57,7 @@
 		       "mov.l	@r15+, r8\n\t"				\
 		       "lds.l	@r15+, pr\n\t"				\
 		       "ldc.l	@r15+, gbr\n\t"				\
+		       "__switch_to_end:\n\t"				\
 		       : "=z" (__last)					\
 		       : "r" (__ts1), "r" (__ts2), "r" (__ts4), 	\
 			 "r" (__ts5), "r" (__ts6), "r" (__ts7) 		\
@@ -67,13 +75,20 @@
 {
 }
 
-#define nop() __asm__ __volatile__ ("nop")
-
-
-#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+#ifdef CONFIG_CPU_SH4A
+#define __icbi()			\
+{					\
+	unsigned long __addr;		\
+	__addr = 0xa8000000;		\
+	__asm__ __volatile__(		\
+		"icbi   %0\n\t"		\
+		: /* no output */	\
+		: "m" (__m(__addr)));	\
+}
+#endif
 
 static __inline__ unsigned long tas(volatile int *m)
-{ /* #define tas(ptr) (xchg((ptr),1)) */
+{
 	unsigned long retval;
 
 	__asm__ __volatile__ ("tas.b	@%1\n\t"
@@ -82,12 +97,33 @@
 	return retval;
 }
 
-extern void __xchg_called_with_bad_pointer(void);
-
-#define mb()	__asm__ __volatile__ ("": : :"memory")
-#define rmb()	mb()
-#define wmb()	__asm__ __volatile__ ("": : :"memory")
+/*
+ * A brief note on ctrl_barrier(), the control register write barrier.
+ *
+ * Legacy SH cores typically require a sequence of 8 nops after
+ * modification of a control register in order for the changes to take
+ * effect. On newer cores (like the sh4a and sh5) this is accomplished
+ * with icbi.
+ *
+ * Also note that on sh4a in the icbi case we can forego a synco for the
+ * write barrier, as it's not necessary for control registers.
+ *
+ * Historically we have only done this type of barrier for the MMUCR, but
+ * it's also necessary for the CCR, so we make it generic here instead.
+ */
+#ifdef CONFIG_CPU_SH4A
+#define mb()		__asm__ __volatile__ ("synco": : :"memory")
+#define rmb()		mb()
+#define wmb()		__asm__ __volatile__ ("synco": : :"memory")
+#define ctrl_barrier()	__icbi()
+#define read_barrier_depends()	do { } while(0)
+#else
+#define mb()		__asm__ __volatile__ ("": : :"memory")
+#define rmb()		mb()
+#define wmb()		__asm__ __volatile__ ("": : :"memory")
+#define ctrl_barrier()	__asm__ __volatile__ ("nop;nop;nop;nop;nop;nop;nop;nop")
 #define read_barrier_depends()	do { } while(0)
+#endif
 
 #ifdef CONFIG_SMP
 #define smp_mb()	mb()
@@ -105,7 +141,8 @@
 #define set_wmb(var, value) do { var = value; wmb(); } while (0)
 
 /* Interrupt Control */
-static __inline__ void local_irq_enable(void)
+#ifdef CONFIG_CPU_HAS_SR_RB
+static inline void local_irq_enable(void)
 {
 	unsigned long __dummy0, __dummy1;
 
@@ -118,6 +155,20 @@
 			     : "1" (~0x000000f0)
 			     : "memory");
 }
+#else
+static inline void local_irq_enable(void)
+{
+	unsigned long __dummy0, __dummy1;
+
+	__asm__ __volatile__ (
+		"stc	sr, %0\n\t"
+		"and	%1, %0\n\t"
+		"ldc	%0, sr\n\t"
+		: "=&r" (__dummy0), "=r" (__dummy1)
+		: "1" (~0x000000f0)
+		: "memory");
+}
+#endif
 
 static __inline__ void local_irq_disable(void)
 {
@@ -130,6 +181,31 @@
 			     : "memory");
 }
 
+static __inline__ void set_bl_bit(void)
+{
+	unsigned long __dummy0, __dummy1;
+
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			     "or	%2, %0\n\t"
+			     "and	%3, %0\n\t"
+			     "ldc	%0, sr"
+			     : "=&r" (__dummy0), "=r" (__dummy1)
+			     : "r" (0x10000000), "r" (0xffffff0f)
+			     : "memory");
+}
+
+static __inline__ void clear_bl_bit(void)
+{
+	unsigned long __dummy0, __dummy1;
+
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			     "and	%2, %0\n\t"
+			     "ldc	%0, sr"
+			     : "=&r" (__dummy0), "=r" (__dummy1)
+			     : "1" (~0x10000000)
+			     : "memory");
+}
+
 #define local_save_flags(x) \
 	__asm__("stc sr, %0; and #0xf0, %0" : "=&z" (x) :/**/: "memory" )
 
@@ -174,17 +250,17 @@
 	}
 }
 #else
-#define local_irq_restore(x) do { 			\
+#define local_irq_restore(x) do {			\
 	if ((x & 0x000000f0) != 0x000000f0)		\
-		local_irq_enable();				\
+		local_irq_enable();			\
 } while (0)
 #endif
 
-#define really_restore_flags(x) do { 			\
+#define really_restore_flags(x) do {			\
 	if ((x & 0x000000f0) != 0x000000f0)		\
-		local_irq_enable();				\
+		local_irq_enable();			\
 	else						\
-		local_irq_disable();				\
+		local_irq_disable();			\
 } while (0)
 
 /*
@@ -212,8 +288,8 @@
 #define back_to_P1()					\
 do {							\
 	unsigned long __dummy;				\
+	ctrl_barrier();					\
 	__asm__ __volatile__(				\
-		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
 		"mov.l	1f, %0\n\t"			\
 		"jmp	@%0\n\t"			\
 		" nop\n\t"				\
@@ -226,7 +302,49 @@
 /* For spinlocks etc */
 #define local_irq_save(x)	x = local_irq_save()
 
-static __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
+#if defined(CONFIG_STM_GRB)
+static inline unsigned long xchg_u32(volatile u32 * m, unsigned long val)
+{
+       unsigned long retval;
+       asm volatile(
+                "   .align 2              \n\t"
+                "   mova    1f,   r0      \n\t" // r0 = end point
+                "   nop                   \n\t"
+                "   mov    r15,   r1      \n\t" // r1 = saved sp
+                "   mov    #-4,   r15     \n\t" // LOGIN
+                "   mov.l  @%1,   %0      \n\t" // load  old value
+                "   mov.l   %2,   @%1     \n\t" // store new value
+                "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval)   // 0
+                : "r"   (m),       // 1
+                  "r"   (val)      // 2
+                : "memory", "r0", "r1" );
+
+        return retval;
+}
+
+static inline unsigned long xchg_u8(volatile unsigned u8 * m, unsigned long
+ val)
+{
+       unsigned long retval;
+
+        asm volatile(
+	       "   .align  2             \n\t"
+               "   mova    1f,   r0      \n\t" // r0 = end point
+	       "   mov    r15,   r1      \n\t" // r1 = saved sp
+               "   mov    #-6,   r15     \n\t" // LOGIN
+               "   mov.b  @%1,   %0      \n\t" // load  old value
+               "   extu.b  %0,   %0      \n\t" // extend as unsigned
+               "   mov.b   %2,   @%1     \n\t" // store new value
+               "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval)  // 0
+                : "r"   (m),      // 1
+                  "r"   (val)     // 2
+                : "memory" , "r0", "r1");
+        return retval ;
+}
+#else
+static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
 {
 	unsigned long flags, retval;
 
@@ -237,7 +355,7 @@
 	return retval;
 }
 
-static __inline__ unsigned long xchg_u8(volatile unsigned char * m, unsigned long val)
+static inline unsigned long xchg_u8(volatile u8 *m, unsigned long val)
 {
 	unsigned long flags, retval;
 
@@ -247,21 +365,96 @@
 	local_irq_restore(flags);
 	return retval;
 }
+#endif
+
+extern void __xchg_called_with_bad_pointer(void);
+
+#define __xchg(ptr, x, size)				\
+({							\
+	unsigned long __xchg__res;			\
+	volatile void *__xchg_ptr = (ptr);		\
+	switch (size) {					\
+	case 4:						\
+		__xchg__res = xchg_u32(__xchg_ptr, x);	\
+		break;					\
+	case 1:						\
+		__xchg__res = xchg_u8(__xchg_ptr, x);	\
+		break;					\
+	default:					\
+		__xchg_called_with_bad_pointer();	\
+		__xchg__res = x;			\
+		break;					\
+	}						\
+							\
+	__xchg__res;					\
+})
+
+#define xchg(ptr,x)	\
+	((__typeof__(*(ptr)))__xchg((ptr),(unsigned long)(x), sizeof(*(ptr))))
+
+#if defined(CONFIG_STM_GRB)
+static inline unsigned long __cmpxchg_u32(volatile u32 * m, unsigned long old,
+        unsigned long new)
+{
+       unsigned long retval;
+        asm volatile(
+               "   .align  2             \n\t"
+               "   mova    1f,   r0      \n\t" // r0 = end point
+               "   nop                   \n\t"
+               "   mov    r15,   r1      \n\t" // r1 = saved sp
+               "   mov    #-8,   r15     \n\t" // LOGIN
+               "   mov.l  @%1,   %0      \n\t" // load  old value
+               "   cmp/eq  %0,   %2      \n\t" //
+               "   bf            1f      \n\t" // if not equal
+               "   mov.l   %2,   @%1     \n\t" // store new value
+               "1: mov     r1,   r15     \n\t" // LOGOUT
+                : "=&r" (retval)   // 0
+                : "r"   (m),       // 1
+                  "r"   (new)      // 2
+                : "memory" , "r0", "r1", "t");
+        return retval;
+}
+#else
+static inline unsigned long __cmpxchg_u32(volatile int * m, unsigned long old,
+	unsigned long new)
+{
+	__u32 retval;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	retval = *m;
+	if (retval == old)
+		*m = new;
+	local_irq_restore(flags);       /* implies memory barrier  */
+	return retval;
+}
+#endif
+
+/* This function doesn't exist, so you'll get a linker error
+ * if something tries to do an invalid cmpxchg(). */
+extern void __cmpxchg_called_with_bad_pointer(void);
 
-static __inline__ unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+#define __HAVE_ARCH_CMPXCHG 1
+
+static inline unsigned long __cmpxchg(volatile void * ptr, unsigned long old,
+		unsigned long new, int size)
 {
 	switch (size) {
 	case 4:
-		return xchg_u32(ptr, x);
-		break;
-	case 1:
-		return xchg_u8(ptr, x);
-		break;
+		return __cmpxchg_u32(ptr, old, new);
 	}
-	__xchg_called_with_bad_pointer();
-	return x;
+	__cmpxchg_called_with_bad_pointer();
+	return old;
 }
 
+#define cmpxchg(ptr,o,n)						 \
+  ({									 \
+     __typeof__(*(ptr)) _o_ = (o);					 \
+     __typeof__(*(ptr)) _n_ = (n);					 \
+     (__typeof__(*(ptr))) __cmpxchg((ptr), (unsigned long)_o_,		 \
+				    (unsigned long)_n_, sizeof(*(ptr))); \
+  })
+
 /* XXX
  * disable hlt during certain critical i/o operations
  */
diff -Naur linux-2.6.17.8/include/asm-sh/systemh7751.h linux-2.6.17.8-sh/include/asm-sh/systemh7751.h
--- linux-2.6.17.8/include/asm-sh/systemh7751.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/systemh7751.h	2006-08-23 13:29:19.113139000 +0100
@@ -0,0 +1,71 @@
+#ifndef __ASM_SH_SYSTEMH_7751SYSTEMH_H
+#define __ASM_SH_SYSTEMH_7751SYSTEMH_H
+
+/*
+ * linux/include/asm-sh/systemh/7751systemh.h
+ *
+ * Copyright (C) 2000  Kazumoto Kojima
+ *
+ * Hitachi SystemH support
+
+ * Modified for 7751 SystemH by
+ * Jonathan Short, 2002.
+ */
+
+/* Box specific addresses.  */
+
+#define PA_ROM		0x00000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_FROM		0x01000000	/* EPROM */
+#define PA_FROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_EXT1		0x04000000
+#define PA_EXT1_SIZE	0x04000000
+#define PA_EXT2		0x08000000
+#define PA_EXT2_SIZE	0x04000000
+#define PA_SDRAM	0x0c000000
+#define PA_SDRAM_SIZE	0x04000000
+
+#define PA_EXT4		0x12000000
+#define PA_EXT4_SIZE	0x02000000
+#define PA_EXT5		0x14000000
+#define PA_EXT5_SIZE	0x04000000
+#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
+
+#define PA_DIPSW0	0xb9000000	/* Dip switch 5,6 */
+#define PA_DIPSW1	0xb9000002	/* Dip switch 7,8 */
+#define PA_LED		0xba000000	/* LED */
+#define	PA_BCR		0xbb000000	/* FPGA on the MS7751SE01 */
+
+#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controler */
+#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
+#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
+#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
+#define MRSHPC_MODE     (PA_MRSHPC + 4)
+#define MRSHPC_OPTION   (PA_MRSHPC + 6)
+#define MRSHPC_CSR      (PA_MRSHPC + 8)
+#define MRSHPC_ISR      (PA_MRSHPC + 10)
+#define MRSHPC_ICR      (PA_MRSHPC + 12)
+#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
+#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
+#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
+#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
+#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
+#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
+#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
+#define MRSHPC_CDCR     (PA_MRSHPC + 28)
+#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
+
+#define BCR_ILCRA	(PA_BCR + 0)
+#define BCR_ILCRB	(PA_BCR + 2)
+#define BCR_ILCRC	(PA_BCR + 4)
+#define BCR_ILCRD	(PA_BCR + 6)
+#define BCR_ILCRE	(PA_BCR + 8)
+#define BCR_ILCRF	(PA_BCR + 10)
+#define BCR_ILCRG	(PA_BCR + 12)
+
+#define IRQ_79C973	13
+
+#define __IO_PREFIX	sh7751systemh
+#include <asm/io_generic.h>
+
+#endif  /* __ASM_SH_SYSTEMH_7751SYSTEMH_H */
diff -Naur linux-2.6.17.8/include/asm-sh/thread_info.h linux-2.6.17.8-sh/include/asm-sh/thread_info.h
--- linux-2.6.17.8/include/asm-sh/thread_info.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/thread_info.h	2006-08-23 13:29:51.698898000 +0100
@@ -12,6 +12,8 @@
 
 #ifdef __KERNEL__
 
+#include <asm/page.h>
+
 #ifndef __ASSEMBLY__
 #include <asm/processor.h>
 
@@ -20,7 +22,8 @@
 	struct exec_domain	*exec_domain;	/* execution domain */
 	unsigned long		flags;		/* low level flags */
 	__u32			cpu;
-	int			preempt_count; /* 0 => preemptable, <0 => BUG */
+	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
+	mm_segment_t		addr_limit;	/* thread address space */
 	struct restart_block	restart_block;
 	__u8			supervisor_stack[0];
 };
@@ -40,6 +43,7 @@
 	.flags		= 0,			\
 	.cpu		= 0,			\
 	.preempt_count	= 1,			\
+	.addr_limit	= KERNEL_DS,		\
 	.restart_block	= {			\
 		.fn = do_no_restart_syscall,	\
 	},					\
@@ -47,25 +51,59 @@
 
 #define init_thread_info	(init_thread_union.thread_info)
 #define init_stack		(init_thread_union.stack)
+#endif
+
+#ifdef CONFIG_4KSTACKS
+#define THREAD_SIZE   (PAGE_SIZE)
+#else
+#define THREAD_SIZE (2*PAGE_SIZE)
+#endif
 
+#ifndef __ASSEMBLY__
 /* how to get the thread information struct from C */
 static inline struct thread_info *current_thread_info(void)
 {
 	struct thread_info *ti;
+#ifdef CONFIG_CPU_HAS_SR_RB
 	__asm__("stc	r7_bank, %0" : "=r" (ti));
+#else
+	unsigned long __dummy;
+
+	__asm__ __volatile__ (
+		"mov	r15, %0\n\t"
+		"and	%1, %0\n\t"
+		: "=&r" (ti), "=r" (__dummy)
+		: "1" (~(THREAD_SIZE - 1))
+		: "memory");
+#endif
+
 	return ti;
 }
 
 /* thread information allocation */
-#define THREAD_SIZE (2*PAGE_SIZE)
-#define alloc_thread_info(ti) ((struct thread_info *) __get_free_pages(GFP_KERNEL,1))
-#define free_thread_info(ti) free_pages((unsigned long) (ti), 1)
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk)					\
+	({							\
+		struct thread_info *ret;			\
+		int order = get_order(THREAD_SIZE);		\
+								\
+		ret = __get_free_pages(GFP_KERNEL, order);	\
+		if (ret)					\
+			memset(ret, 0, THREAD_SIZE);		\
+		ret;						\
+	})
+#else
+#define alloc_thread_info(ti) ((struct thread_info *) \
+	__get_free_pages(GFP_KERNEL, get_order(THREAD_SIZE)))
+#endif
+
+#define free_thread_info(ti) free_pages((unsigned long) (ti), get_order(THREAD_SIZE))
 
 #else /* !__ASSEMBLY__ */
 
 /* how to get the thread information struct from ASM */
 #define GET_THREAD_INFO(reg) \
-	stc	r7_bank, reg
+	stc     r7_bank, reg
 
 #endif
 
@@ -79,18 +117,18 @@
 #define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_SINGLESTEP		4
 #define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 #define TIF_MEMDIE		18
-#define TIF_USERSPACE		31	/* true if FS sets userspace */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
 #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
 #define _TIF_USEDFPU		(1<<TIF_USEDFPU)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
-#define _TIF_USERSPACE		(1<<TIF_USERSPACE)
 
 #define _TIF_WORK_MASK		0x000000FE	/* work to do on interrupt/exception return */
 #define _TIF_ALLWORK_MASK	0x000000FF	/* work to do on any return to u-space */
diff -Naur linux-2.6.17.8/include/asm-sh/timer.h linux-2.6.17.8-sh/include/asm-sh/timer.h
--- linux-2.6.17.8/include/asm-sh/timer.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/timer.h	2006-08-23 13:29:22.265231000 +0100
@@ -6,6 +6,8 @@
 
 struct sys_timer_ops {
 	int (*init)(void);
+	int (*start)(void);
+	int (*stop)(void);
 	unsigned long (*get_offset)(void);
 	unsigned long (*get_frequency)(void);
 };
diff -Naur linux-2.6.17.8/include/asm-sh/timex.h linux-2.6.17.8-sh/include/asm-sh/timex.h
--- linux-2.6.17.8/include/asm-sh/timex.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/timex.h	2006-08-23 13:29:09.803932000 +0100
@@ -6,7 +6,7 @@
 #ifndef __ASM_SH_TIMEX_H
 #define __ASM_SH_TIMEX_H
 
-#define CLOCK_TICK_RATE		(CONFIG_SH_PCLK_FREQ / 4) /* Underlying HZ */
+#define CLOCK_TICK_RATE		(HZ * 100000UL)
 
 typedef unsigned long long cycles_t;
 
diff -Naur linux-2.6.17.8/include/asm-sh/titan.h linux-2.6.17.8-sh/include/asm-sh/titan.h
--- linux-2.6.17.8/include/asm-sh/titan.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/titan.h	2006-08-23 13:29:16.333093000 +0100
@@ -0,0 +1,43 @@
+/*
+ * Platform defintions for Titan
+ */
+
+#ifndef _ASM_SH_TITAN_TITAN_H
+#define _ASM_SH_TITAN_TITAN_H
+
+#define __IO_PREFIX titan
+#include <asm/io_generic.h>
+
+/* IRQ assignments */
+#define TITAN_IRQ_WAN		2	/* eth0 (WAN) */
+#define TITAN_IRQ_LAN		5	/* eth1 (LAN) */
+#define TITAN_IRQ_MPCIA		8	/* mPCI A */
+#define TITAN_IRQ_MPCIB		11	/* mPCI B */
+#define TITAN_IRQ_USB		11	/* USB */
+
+/*
+ * The external interrupt lines, these take up ints 0 - 15 inclusive
+ * depending on the priority for the interrupt.  In fact the priority
+ * is the interrupt :-)
+ */
+#define IRL0_IRQ	0
+#define IRL0_IPR_ADDR	INTC_IPRD
+#define IRL0_IPR_POS	3
+#define IRL0_PRIORITY	8
+
+#define IRL1_IRQ	1
+#define IRL1_IPR_ADDR	INTC_IPRD
+#define IRL1_IPR_POS	2
+#define IRL1_PRIORITY	8
+
+#define IRL2_IRQ	2
+#define IRL2_IPR_ADDR	INTC_IPRD
+#define IRL2_IPR_POS	1
+#define IRL2_PRIORITY	8
+
+#define IRL3_IRQ	3
+#define IRL3_IPR_ADDR	INTC_IPRD
+#define IRL3_IPR_POS	0
+#define IRL3_PRIORITY	8
+
+#endif
diff -Naur linux-2.6.17.8/include/asm-sh/uaccess.h linux-2.6.17.8-sh/include/asm-sh/uaccess.h
--- linux-2.6.17.8/include/asm-sh/uaccess.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/uaccess.h	2006-08-23 13:29:35.530530000 +0100
@@ -1,5 +1,4 @@
-/* $Id: uaccess.h,v 1.11 2003/10/13 07:21:20 lethal Exp $
- *
+/*
  * User space memory access functions
  *
  * Copyright (C) 1999, 2002  Niibe Yutaka
@@ -16,21 +15,9 @@
 #include <linux/errno.h>
 #include <linux/sched.h>
 
-/*
- * NOTE: Macro/functions in this file depends on threads_info.h implementation.
- * Assumes:
- * TI_FLAGS == 8
- * TIF_USERSPACE == 31
- * USER_ADDR_LIMIT == 0x80000000
- */
-
 #define VERIFY_READ    0
 #define VERIFY_WRITE   1
 
-typedef struct {
-	unsigned int is_user_space;
-} mm_segment_t;
-
 /*
  * The fs value determines whether argument validity checking should be
  * performed or not.  If get_fs() == USER_DS, checking is performed, with
@@ -40,12 +27,14 @@
  */
 
 #define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
-#define segment_eq(a,b)	((a).is_user_space == (b).is_user_space)
 
-#define USER_ADDR_LIMIT	0x80000000
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFFUL)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
 
-#define KERNEL_DS	MAKE_MM_SEG(0)
-#define USER_DS		MAKE_MM_SEG(1)
+#define __addr_ok(addr) \
+	((unsigned long)(addr) < (current_thread_info()->addr_limit.seg))
 
 #define get_ds()	(KERNEL_DS)
 
@@ -76,31 +65,8 @@
 	return ((addr >= memory_start) && ((addr + size) < memory_end));
 }
 #else /* CONFIG_MMU */
-static inline mm_segment_t get_fs(void)
-{
-	return MAKE_MM_SEG(test_thread_flag(TIF_USERSPACE));
-}
-
-static inline void set_fs(mm_segment_t s)
-{
-	unsigned long ti, flag;
-	__asm__ __volatile__(
-		"stc	r7_bank, %0\n\t"
-		"mov.l	@(8,%0), %1\n\t"
-		"shal	%1\n\t"
-		"cmp/pl	%2\n\t"
-		"rotcr	%1\n\t"
-		"mov.l	%1, @(8,%0)"
-		: "=&r" (ti), "=&r" (flag)
-		: "r" (s.is_user_space)
-		: "t");
-/****
-	if (s.is_user_space)
-		set_thread_flag(TIF_USERSPACE);
-	else
-		clear_thread_flag(TIF_USERSPACE);
-****/
-}
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
 
 /*
  * __access_ok: Check if address with size is OK or not.
@@ -108,7 +74,7 @@
  * We do three checks:
  * (1) is it user space? 
  * (2) addr + size --> carry?
- * (3) addr + size >= 0x80000000  (USER_ADDR_LIMIT)
+ * (3) addr + size >= 0x80000000  (PAGE_OFFSET)
  *
  * (1) (2) (3) | RESULT
  *  0   0   0  |  ok
@@ -201,6 +167,7 @@
 	__gu_err;						\
 })
 
+#ifdef CONFIG_MMU
 #define __get_user_check(x,ptr,size)				\
 ({								\
 	long __gu_err, __gu_val;				\
@@ -290,6 +257,18 @@
 	: "r" (addr)				\
 	: "t");					\
 })
+#else /* CONFIG_MMU */
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err, __gu_val;					\
+	if (__access_ok((unsigned long)(ptr), (size))) {		\
+		__get_user_size(__gu_val, (ptr), (size), __gu_err);	\
+		(x) = (__typeof__(*(ptr)))__gu_val;			\
+	} else								\
+		__gu_err = -EFAULT;					\
+	__gu_err;							\
+})
+#endif
 
 #define __get_user_asm(x, addr, err, insn) \
 ({ \
@@ -476,7 +455,7 @@
 __strncpy_from_user(unsigned long __dest, unsigned long __user __src, int __count)
 {
 	__kernel_size_t res;
-	unsigned long __dummy, _d, _s;
+	unsigned long __dummy, _d, _s, _c;
 
 	__asm__ __volatile__(
 		"9:\n"
@@ -485,17 +464,17 @@
 		"bt/s	2f\n"
 		"1:\n"
 		"mov.b	%1, @%3\n\t"
-		"dt	%7\n\t"
+		"dt	%4\n\t"
 		"bf/s	9b\n\t"
 		" add	#1, %3\n\t"
 		"2:\n\t"
-		"sub	%7, %0\n"
+		"sub	%4, %0\n"
 		"3:\n"
 		".section .fixup,\"ax\"\n"
 		"4:\n\t"
 		"mov.l	5f, %1\n\t"
 		"jmp	@%1\n\t"
-		" mov	%8, %0\n\t"
+		" mov	%9, %0\n\t"
 		".balign 4\n"
 		"5:	.long 3b\n"
 		".previous\n"
@@ -503,14 +482,32 @@
 		"	.balign 4\n"
 		"	.long 9b,4b\n"
 		".previous"
-		: "=r" (res), "=&z" (__dummy), "=r" (_s), "=r" (_d)
-		: "0" (__count), "2" (__src), "3" (__dest), "r" (__count),
+		: "=r" (res), "=&z" (__dummy), "=r" (_s), "=r" (_d), "=r"(_c)
+		: "0" (__count), "2" (__src), "3" (__dest), "4" (__count),
 		  "i" (-EFAULT)
 		: "memory", "t");
 
 	return res;
 }
 
+/**
+ * strncpy_from_user: - Copy a NUL terminated string from userspace.
+ * @dst:   Destination address, in kernel space.  This buffer must be at
+ *         least @count bytes long.
+ * @src:   Source address, in user space.
+ * @count: Maximum number of bytes to copy, including the trailing NUL.
+ *
+ * Copies a NUL-terminated string from userspace to kernel space.
+ *
+ * On success, returns the length of the string (not including the trailing
+ * NUL).
+ *
+ * If access to userspace fails, returns -EFAULT (some data may have been
+ * copied).
+ *
+ * If @count is smaller than the length of the string, copies @count bytes
+ * and returns @count.
+ */
 #define strncpy_from_user(dest,src,count) ({ \
 unsigned long __sfu_src = (unsigned long) (src); \
 int __sfu_count = (int) (count); \
@@ -541,7 +538,7 @@
 		"3:\n\t"
 		"mov.l	4f, %1\n\t"
 		"jmp	@%1\n\t"
-		" mov	%5, %0\n"
+		" mov	#0, %0\n"
 		".balign 4\n"
 		"4:	.long 2b\n"
 		".previous\n"
@@ -550,26 +547,20 @@
 		"	.long 1b,3b\n"
 		".previous"
 		: "=z" (res), "=&r" (__dummy)
-		: "0" (0), "r" (__s), "r" (__n), "i" (-EFAULT)
+		: "0" (0), "r" (__s), "r" (__n)
 		: "t");
 	return res;
 }
 
 static __inline__ long strnlen_user(const char __user *s, long n)
 {
-	if (!access_ok(VERIFY_READ, s, n))
+	if (!__addr_ok(s))
 		return 0;
 	else
 		return __strnlen_user(s, n);
 }
 
-static __inline__ long strlen_user(const char __user *s)
-{
-	if (!access_ok(VERIFY_READ, s, 0))
-		return 0;
-	else
-		return __strnlen_user(s, ~0UL >> 1);
-}
+#define strlen_user(str)	strnlen_user(str, ~0UL >> 1)
 
 /*
  * The exception table consists of pairs of addresses: the first is the
diff -Naur linux-2.6.17.8/include/asm-sh/unistd.h linux-2.6.17.8-sh/include/asm-sh/unistd.h
--- linux-2.6.17.8/include/asm-sh/unistd.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/unistd.h	2006-08-23 13:29:44.792738000 +0100
@@ -132,7 +132,7 @@
 #define __NR_clone		120
 #define __NR_setdomainname	121
 #define __NR_uname		122
-#define __NR_modify_ldt		123
+#define __NR_cacheflush		123
 #define __NR_adjtimex		124
 #define __NR_mprotect		125
 #define __NR_sigprocmask	126
@@ -300,9 +300,31 @@
 #define __NR_inotify_init	290
 #define __NR_inotify_add_watch	291
 #define __NR_inotify_rm_watch	292
+#define __NR_migrate_pages	293
+#define __NR_openat		294
+#define __NR_mkdirat		295
+#define __NR_mknodat		296
+#define __NR_fchownat		297
+#define __NR_futimesat		298
+#define __NR_fstatat64		299
+#define __NR_unlinkat		300
+#define __NR_renameat		301
+#define __NR_linkat		302
+#define __NR_symlinkat		303
+#define __NR_readlinkat		304
+#define __NR_fchmodat		305
+#define __NR_faccessat		305
+#define __NR_pselect6		307
+#define __NR_ppoll		308
+#define __NR_unshare		309
+#define __NR_set_robust_list	310
+#define __NR_get_robust_list	311
+#define __NR_splice		312
+#define __NR_sync_file_range	313
+#define __NR_tee		314
+#define __NR_vmsplice		315
 
-
-#define NR_syscalls 293
+#define NR_syscalls 316
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-sh/errno.h> */
 
diff -Naur linux-2.6.17.8/include/asm-sh/voyagergx.h linux-2.6.17.8-sh/include/asm-sh/voyagergx.h
--- linux-2.6.17.8/include/asm-sh/voyagergx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/asm-sh/voyagergx.h	2006-08-23 13:29:28.114346000 +0100
@@ -0,0 +1,313 @@
+/* -------------------------------------------------------------------- */
+/* voyagergx.h	                                                      */
+/* -------------------------------------------------------------------- */
+/*  This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Copyright 2003 (c) Lineo uSolutions,Inc.
+*/
+/* -------------------------------------------------------------------- */
+
+#ifndef _VOYAGER_GX_REG_H
+#define _VOYAGER_GX_REG_H
+
+#define VOYAGER_BASE			0xb3e00000
+#define VOYAGER_USBH_BASE		(0x40000 + VOYAGER_BASE)
+#define VOYAGER_UART_BASE		(0x30000 + VOYAGER_BASE)
+#define	VOYAGER_AC97_BASE		(0xa0000 + VOYAGER_BASE)
+
+#define VOYAGER_IRQ_NUM			32
+#define VOYAGER_IRQ_BASE		50
+#define VOYAGER_USBH_IRQ		VOYAGER_IRQ_BASE + 6
+#define VOYAGER_8051_IRQ		VOYAGER_IRQ_BASE + 10
+#define VOYAGER_UART0_IRQ		VOYAGER_IRQ_BASE + 12
+#define VOYAGER_UART1_IRQ		VOYAGER_IRQ_BASE + 13
+#define	VOYAGER_AC97_IRQ		VOYAGER_IRQ_BASE + 17
+
+/* ----- MISC controle  register ------------------------------ */
+#define MISC_CTRL			(0x000004 + VOYAGER_BASE)
+#define MISC_CTRL_USBCLK_48		(3 << 28)
+#define MISC_CTRL_USBCLK_96		(2 << 28)
+#define MISC_CTRL_USBCLK_CRYSTAL	(1 << 28)
+
+/* ----- GPIO[31:0] register --------------------------------- */
+#define GPIO_MUX_LOW			(0x000008 + VOYAGER_BASE)
+#define GPIO_MUX_LOW_AC97		0x1F000000
+#define GPIO_MUX_LOW_8051		0x0000ffff
+#define GPIO_MUX_LOW_PWM		(1 << 29)
+
+/* ----- GPIO[63:32] register --------------------------------- */
+#define GPIO_MUX_HIGH			(0x00000C + VOYAGER_BASE)
+
+/* ----- DRAM controle  register ------------------------------- */
+#define DRAM_CTRL			(0x000010 + VOYAGER_BASE)
+#define DRAM_CTRL_EMBEDDED		(1 << 31)
+#define DRAM_CTRL_CPU_BURST_1		(0 << 28)
+#define DRAM_CTRL_CPU_BURST_2		(1 << 28)
+#define DRAM_CTRL_CPU_BURST_4		(2 << 28)
+#define DRAM_CTRL_CPU_BURST_8		(3 << 28)
+#define DRAM_CTRL_CPU_CAS_LATENCY	(1 << 27)
+#define DRAM_CTRL_CPU_SIZE_2		(0 << 24)
+#define DRAM_CTRL_CPU_SIZE_4		(1 << 24)
+#define DRAM_CTRL_CPU_SIZE_64		(4 << 24)
+#define DRAM_CTRL_CPU_SIZE_32		(5 << 24)
+#define DRAM_CTRL_CPU_SIZE_16		(6 << 24)
+#define DRAM_CTRL_CPU_SIZE_8		(7 << 24)
+#define DRAM_CTRL_CPU_COLUMN_SIZE_1024	(0 << 22)
+#define DRAM_CTRL_CPU_COLUMN_SIZE_512	(2 << 22)
+#define DRAM_CTRL_CPU_COLUMN_SIZE_256	(3 << 22)
+#define DRAM_CTRL_CPU_ACTIVE_PRECHARGE	(1 << 21)
+#define DRAM_CTRL_CPU_RESET		(1 << 20)
+#define DRAM_CTRL_CPU_BANKS		(1 << 19)
+#define DRAM_CTRL_CPU_WRITE_PRECHARGE	(1 << 18)
+#define DRAM_CTRL_BLOCK_WRITE		(1 << 17)
+#define DRAM_CTRL_REFRESH_COMMAND	(1 << 16)
+#define DRAM_CTRL_SIZE_4		(0 << 13)
+#define DRAM_CTRL_SIZE_8		(1 << 13)
+#define DRAM_CTRL_SIZE_16		(2 << 13)
+#define DRAM_CTRL_SIZE_32		(3 << 13)
+#define DRAM_CTRL_SIZE_64		(4 << 13)
+#define DRAM_CTRL_SIZE_2		(5 << 13)
+#define DRAM_CTRL_COLUMN_SIZE_256	(0 << 11)
+#define DRAM_CTRL_COLUMN_SIZE_512	(2 << 11)
+#define DRAM_CTRL_COLUMN_SIZE_1024	(3 << 11)
+#define DRAM_CTRL_BLOCK_WRITE_TIME	(1 << 10)
+#define DRAM_CTRL_BLOCK_WRITE_PRECHARGE	(1 << 9)
+#define DRAM_CTRL_ACTIVE_PRECHARGE	(1 << 8)
+#define DRAM_CTRL_RESET			(1 << 7)
+#define DRAM_CTRL_REMAIN_ACTIVE		(1 << 6)
+#define DRAM_CTRL_BANKS			(1 << 1)
+#define DRAM_CTRL_WRITE_PRECHARGE	(1 << 0)
+
+/* ----- Arvitration control register -------------------------- */
+#define ARBITRATION_CTRL		(0x000014 + VOYAGER_BASE)
+#define ARBITRATION_CTRL_CPUMEM		(1 << 29)
+#define ARBITRATION_CTRL_INTMEM		(1 << 28)
+#define ARBITRATION_CTRL_USB_OFF	(0 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_1	(1 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_2	(2 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_3	(3 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_4	(4 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_5	(5 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_6	(6 << 24)
+#define ARBITRATION_CTRL_USB_PRIORITY_7	(7 << 24)
+#define ARBITRATION_CTRL_PANEL_OFF	(0 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_1	(1 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_2	(2 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_3	(3 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_4	(4 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_5	(5 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_6	(6 << 20)
+#define ARBITRATION_CTRL_PANEL_PRIORITY_7	(7 << 20)
+#define ARBITRATION_CTRL_ZVPORT_OFF	(0 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_1	(1 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_2	(2 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_3	(3 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_4	(4 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_5	(5 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_6	(6 << 16)
+#define ARBITRATION_CTRL_ZVPORTL_PRIORITY_7	(7 << 16)
+#define ARBITRATION_CTRL_CMD_INTPR_OFF	(0 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_1	(1 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_2	(2 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_3	(3 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_4	(4 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_5	(5 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_6	(6 << 12)
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_7	(7 << 12)
+#define ARBITRATION_CTRL_DMA_OFF	(0 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_1	(1 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_2	(2 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_3	(3 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_4	(4 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_5	(5 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_6	(6 << 8)
+#define ARBITRATION_CTRL_DMA_PRIORITY_7	(7 << 8)
+#define ARBITRATION_CTRL_VIDEO_OFF	(0 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_1	(1 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_2	(2 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_3	(3 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_4	(4 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_5	(5 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_6	(6 << 4)
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_7	(7 << 4)
+#define ARBITRATION_CTRL_CRT_OFF	(0 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_1	(1 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_2	(2 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_3	(3 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_4	(4 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_5	(5 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_6	(6 << 0)
+#define ARBITRATION_CTRL_CRT_PRIORITY_7	(7 << 0)
+
+/* ----- Command list status register -------------------------- */
+#define CMD_INTPR_STATUS		(0x000024 + VOYAGER_BASE)
+
+/* ----- Interrupt status register ----------------------------- */
+#define INT_STATUS			(0x00002c + VOYAGER_BASE)
+#define INT_STATUS_UH			(1 << 6)
+#define INT_STATUS_MC			(1 << 10)
+#define INT_STATUS_U0			(1 << 12)
+#define INT_STATUS_U1			(1 << 13)
+#define	INT_STATUS_AC			(1 << 17)
+
+/* ----- Interrupt mask register ------------------------------ */
+#define VOYAGER_INT_MASK		(0x000030 + VOYAGER_BASE)
+#define VOYAGER_INT_MASK_AC		(1 << 17)
+
+/* ----- Current Gate register ---------------------------------*/
+#define CURRENT_GATE			(0x000038 + VOYAGER_BASE)
+
+/* ----- Power mode 0 gate register --------------------------- */
+#define POWER_MODE0_GATE		(0x000040 + VOYAGER_BASE)
+#define POWER_MODE0_GATE_G		(1 << 6)
+#define POWER_MODE0_GATE_U0		(1 << 7)
+#define POWER_MODE0_GATE_U1		(1 << 8)
+#define POWER_MODE0_GATE_UH		(1 << 11)
+#define	POWER_MODE0_GATE_AC		(1 << 18)
+
+/* ----- Power mode 1 gate register --------------------------- */
+#define POWER_MODE1_GATE		(0x000048 + VOYAGER_BASE)
+#define POWER_MODE1_GATE_G		(1 << 6)
+#define POWER_MODE1_GATE_U0		(1 << 7)
+#define POWER_MODE1_GATE_U1		(1 << 8)
+#define POWER_MODE1_GATE_UH		(1 << 11)
+#define	POWER_MODE1_GATE_AC		(1 << 18)
+
+/* ----- Power mode 0 clock register -------------------------- */
+#define POWER_MODE0_CLOCK		(0x000044 + VOYAGER_BASE)
+
+/* ----- Power mode 1 clock register -------------------------- */
+#define POWER_MODE1_CLOCK		(0x00004C + VOYAGER_BASE)
+
+/* ----- Power mode controll register ------------------------- */
+#define POWER_MODE_CTRL			(0x000054 + VOYAGER_BASE)
+
+/* ----- Miscellaneous Timing register ------------------------ */
+#define SYSTEM_DRAM_CTRL		(0x000068 + VOYAGER_BASE)
+
+/* ----- PWM register ------------------------------------------*/
+#define PWM_0				(0x010020 + VOYAGER_BASE)
+#define PWM_0_HC(x)			(((x)&0x0fff)<<20)
+#define PWM_0_LC(x)			(((x)&0x0fff)<<8 )
+#define PWM_0_CLK_DEV(x)		(((x)&0x000f)<<4 )
+#define PWM_0_EN			(1<<0)
+
+/* ----- I2C register ----------------------------------------- */
+#define I2C_BYTECOUNT			(0x010040 + VOYAGER_BASE)
+#define I2C_CONTROL			(0x010041 + VOYAGER_BASE)
+#define I2C_STATUS			(0x010042 + VOYAGER_BASE)
+#define I2C_RESET			(0x010042 + VOYAGER_BASE)
+#define I2C_SADDRESS			(0x010043 + VOYAGER_BASE)
+#define I2C_DATA			(0x010044 + VOYAGER_BASE)
+
+/* ----- Controle register bits ----------------------------------------- */
+#define I2C_CONTROL_E			(1 << 0)
+#define I2C_CONTROL_MODE		(1 << 1)
+#define I2C_CONTROL_STATUS		(1 << 2)
+#define I2C_CONTROL_INT			(1 << 4)
+#define I2C_CONTROL_INTACK		(1 << 5)
+#define I2C_CONTROL_REPEAT		(1 << 6)
+
+/* ----- Status register bits ----------------------------------------- */
+#define I2C_STATUS_BUSY			(1 << 0)
+#define I2C_STATUS_ACK			(1 << 1)
+#define I2C_STATUS_ERROR		(1 << 2)
+#define I2C_STATUS_COMPLETE		(1 << 3)
+
+/* ----- Reset register  ---------------------------------------------- */
+#define I2C_RESET_ERROR			(1 << 2)
+
+/* ----- transmission frequencies ------------------------------------- */
+#define I2C_SADDRESS_SELECT		(1 << 0)
+
+/* ----- Display Controll register ----------------------------------------- */
+#define PANEL_DISPLAY_CTRL		(0x080000 + VOYAGER_BASE)
+#define PANEL_DISPLAY_CTRL_BIAS         (1<<26)
+#define PANEL_PAN_CTRL			(0x080004 + VOYAGER_BASE)
+#define PANEL_COLOR_KEY			(0x080008 + VOYAGER_BASE)
+#define PANEL_FB_ADDRESS		(0x08000C + VOYAGER_BASE)
+#define PANEL_FB_WIDTH			(0x080010 + VOYAGER_BASE)
+#define PANEL_WINDOW_WIDTH		(0x080014 + VOYAGER_BASE)
+#define PANEL_WINDOW_HEIGHT		(0x080018 + VOYAGER_BASE)
+#define PANEL_PLANE_TL			(0x08001C + VOYAGER_BASE)
+#define PANEL_PLANE_BR			(0x080020 + VOYAGER_BASE)
+#define PANEL_HORIZONTAL_TOTAL		(0x080024 + VOYAGER_BASE)
+#define PANEL_HORIZONTAL_SYNC		(0x080028 + VOYAGER_BASE)
+#define PANEL_VERTICAL_TOTAL		(0x08002C + VOYAGER_BASE)
+#define PANEL_VERTICAL_SYNC		(0x080030 + VOYAGER_BASE)
+#define PANEL_CURRENT_LINE		(0x080034 + VOYAGER_BASE)
+#define VIDEO_DISPLAY_CTRL		(0x080040 + VOYAGER_BASE)
+#define VIDEO_FB_0_ADDRESS		(0x080044 + VOYAGER_BASE)
+#define VIDEO_FB_WIDTH			(0x080048 + VOYAGER_BASE)
+#define VIDEO_FB_0_LAST_ADDRESS		(0x08004C + VOYAGER_BASE)
+#define VIDEO_PLANE_TL			(0x080050 + VOYAGER_BASE)
+#define VIDEO_PLANE_BR			(0x080054 + VOYAGER_BASE)
+#define VIDEO_SCALE			(0x080058 + VOYAGER_BASE)
+#define VIDEO_INITIAL_SCALE		(0x08005C + VOYAGER_BASE)
+#define VIDEO_YUV_CONSTANTS		(0x080060 + VOYAGER_BASE)
+#define VIDEO_FB_1_ADDRESS		(0x080064 + VOYAGER_BASE)
+#define VIDEO_FB_1_LAST_ADDRESS		(0x080068 + VOYAGER_BASE)
+#define VIDEO_ALPHA_DISPLAY_CTRL	(0x080080 + VOYAGER_BASE)
+#define VIDEO_ALPHA_FB_ADDRESS		(0x080084 + VOYAGER_BASE)
+#define VIDEO_ALPHA_FB_WIDTH		(0x080088 + VOYAGER_BASE)
+#define VIDEO_ALPHA_FB_LAST_ADDRESS	(0x08008C + VOYAGER_BASE)
+#define VIDEO_ALPHA_PLANE_TL		(0x080090 + VOYAGER_BASE)
+#define VIDEO_ALPHA_PLANE_BR		(0x080094 + VOYAGER_BASE)
+#define VIDEO_ALPHA_SCALE		(0x080098 + VOYAGER_BASE)
+#define VIDEO_ALPHA_INITIAL_SCALE	(0x08009C + VOYAGER_BASE)
+#define VIDEO_ALPHA_CHROMA_KEY		(0x0800A0 + VOYAGER_BASE)
+#define PANEL_HWC_ADDRESS		(0x0800F0 + VOYAGER_BASE)
+#define PANEL_HWC_LOCATION		(0x0800F4 + VOYAGER_BASE)
+#define PANEL_HWC_COLOR_12		(0x0800F8 + VOYAGER_BASE)
+#define PANEL_HWC_COLOR_3		(0x0800FC + VOYAGER_BASE)
+#define ALPHA_DISPLAY_CTRL		(0x080100 + VOYAGER_BASE)
+#define ALPHA_FB_ADDRESS		(0x080104 + VOYAGER_BASE)
+#define ALPHA_FB_WIDTH			(0x080108 + VOYAGER_BASE)
+#define ALPHA_PLANE_TL			(0x08010C + VOYAGER_BASE)
+#define ALPHA_PLANE_BR			(0x080110 + VOYAGER_BASE)
+#define ALPHA_CHROMA_KEY		(0x080114 + VOYAGER_BASE)
+#define CRT_DISPLAY_CTRL		(0x080200 + VOYAGER_BASE)
+#define CRT_FB_ADDRESS			(0x080204 + VOYAGER_BASE)
+#define CRT_FB_WIDTH			(0x080208 + VOYAGER_BASE)
+#define CRT_HORIZONTAL_TOTAL		(0x08020C + VOYAGER_BASE)
+#define CRT_HORIZONTAL_SYNC		(0x080210 + VOYAGER_BASE)
+#define CRT_VERTICAL_TOTAL		(0x080214 + VOYAGER_BASE)
+#define CRT_VERTICAL_SYNC		(0x080218 + VOYAGER_BASE)
+#define CRT_SIGNATURE_ANALYZER		(0x08021C + VOYAGER_BASE)
+#define CRT_CURRENT_LINE		(0x080220 + VOYAGER_BASE)
+#define CRT_MONITOR_DETECT		(0x080224 + VOYAGER_BASE)
+#define CRT_HWC_ADDRESS			(0x080230 + VOYAGER_BASE)
+#define CRT_HWC_LOCATION		(0x080234 + VOYAGER_BASE)
+#define CRT_HWC_COLOR_12		(0x080238 + VOYAGER_BASE)
+#define CRT_HWC_COLOR_3			(0x08023C + VOYAGER_BASE)
+#define CRT_PALETTE_RAM			(0x080400 + VOYAGER_BASE)
+#define PANEL_PALETTE_RAM		(0x080800 + VOYAGER_BASE)
+#define VIDEO_PALETTE_RAM		(0x080C00 + VOYAGER_BASE)
+
+/* ----- 8051 Controle register ----------------------------------------- */
+#define VOYAGER_8051_BASE		(0x000c0000 + VOYAGER_BASE)
+#define VOYAGER_8051_RESET		(0x000b0000 + VOYAGER_BASE)
+#define VOYAGER_8051_SELECT		(0x000b0004 + VOYAGER_BASE)
+#define VOYAGER_8051_CPU_INT		(0x000b000c + VOYAGER_BASE)
+
+/* ----- AC97 Controle register ----------------------------------------- */
+#define AC97_TX_SLOT0			(0x00000000 + VOYAGER_AC97_BASE)
+#define AC97_CONTROL_STATUS		(0x00000080 + VOYAGER_AC97_BASE)
+#define AC97C_READ			(1 << 19)
+#define AC97C_WD_BIT			(1 << 2)
+#define AC97C_INDEX_MASK		0x7f
+/* -------------------------------------------------------------------- */
+
+#endif /* _VOYAGER_GX_REG_H */
diff -Naur linux-2.6.17.8/include/linux/bigphysarea.h linux-2.6.17.8-sh/include/linux/bigphysarea.h
--- linux-2.6.17.8/include/linux/bigphysarea.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/bigphysarea.h	2006-08-23 13:29:32.829461000 +0100
@@ -0,0 +1,32 @@
+/* linux/mm/bigphysarea.h, M. Welsh (mdw@cs.cornell.edu)
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?)
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ *
+ */
+
+#ifndef __LINUX_BIGPHYSAREA_H
+#define __LINUX_BIGPHYSAREA_H
+
+#include <linux/types.h>
+
+/* original interface */
+extern caddr_t	bigphysarea_alloc(int size);
+extern void	bigphysarea_free(caddr_t addr, int size);
+
+/* new interface */
+extern caddr_t	bigphysarea_alloc_pages(int count, int align, int priority);
+extern void	bigphysarea_free_pages(caddr_t base);
+
+/* low level interface */
+extern void     bigphysarea_memory(unsigned long *base, unsigned long *size);
+
+#endif // __LINUX_BIGPHYSAREA_H
diff -Naur linux-2.6.17.8/include/linux/i2c-id.h linux-2.6.17.8-sh/include/linux/i2c-id.h
--- linux-2.6.17.8/include/linux/i2c-id.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/i2c-id.h	2006-08-23 13:29:32.334461000 +0100
@@ -189,6 +189,7 @@
 #define I2C_HW_B_RADEON		0x01001e /* radeon framebuffer driver */
 #define I2C_HW_B_EM28XX		0x01001f /* em28xx video capture cards */
 #define I2C_HW_B_CX2341X	0x010020 /* Conexant CX2341X MPEG encoder cards */
+#define I2C_HW_B_ST40_PIO	0x010021 /* STMicroelectronics ST40 parts */
 
 /* --- PCF 8584 based algorithms					*/
 #define I2C_HW_P_LP		0x020000 /* Parallel port interface */
@@ -245,6 +246,7 @@
 #define I2C_HW_SMBUS_OV518	0x04000f /* OV518(+) USB 1.1 webcam ICs */
 #define I2C_HW_SMBUS_OV519	0x040010 /* OV519 USB 1.1 webcam IC */
 #define I2C_HW_SMBUS_OVFX2	0x040011 /* Cypress/OmniVision FX2 webcam */
+#define I2C_HW_SMBUS_VOYAGER	0x040012
 
 /* --- ISA pseudo-adapter						*/
 #define I2C_HW_ISA		0x050000
diff -Naur linux-2.6.17.8/include/linux/ide.h linux-2.6.17.8-sh/include/linux/ide.h
--- linux-2.6.17.8/include/linux/ide.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/ide.h	2006-08-23 13:29:39.610622000 +0100
@@ -1178,6 +1178,7 @@
 extern int ide_spin_wait_hwgroup(ide_drive_t *);
 extern void ide_timer_expiry(unsigned long);
 extern irqreturn_t ide_intr(int irq, void *dev_id, struct pt_regs *regs);
+extern void ide_do_request(ide_hwgroup_t *hwgroup, int masked_irq);
 extern void do_ide_request(request_queue_t *);
 
 void ide_init_disk(struct gendisk *, ide_drive_t *);
diff -Naur linux-2.6.17.8/include/linux/libata.h linux-2.6.17.8-sh/include/linux/libata.h
--- linux-2.6.17.8/include/linux/libata.h	2006-08-21 14:42:23.469775000 +0100
+++ linux-2.6.17.8-sh/include/linux/libata.h	2006-08-23 13:29:47.651806000 +0100
@@ -38,8 +38,8 @@
  * compile-time options: to be removed as soon as all the drivers are
  * converted to the new debugging mechanism
  */
-#undef ATA_DEBUG		/* debugging output */
-#undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
+//#undef ATA_DEBUG		/* debugging output */
+//#undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
 #undef ATA_ENABLE_PATA		/* define to enable PATA support in some
@@ -469,6 +469,11 @@
 
 	void (*bmdma_stop) (struct ata_queued_cmd *qc);
 	u8   (*bmdma_status) (struct ata_port *ap);
+
+	unsigned char (*readb)(const volatile void __iomem *addr);
+	unsigned short (*readw)(const volatile void __iomem *addr);
+	void (*writeb)(unsigned char b, volatile void __iomem *addr);
+	void (*writew)(unsigned short b, volatile void __iomem *addr);
 };
 
 struct ata_port_info {
@@ -495,6 +500,58 @@
 
 #define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
 
+static inline u8 sata_readb(struct ata_port *ap,
+			    const volatile void __iomem *addr)
+{
+	u8 r;
+	if (ap->ops->readb)
+		r = (ap->ops->readb)(addr);
+	else
+		r = readb(addr);
+
+	return r;
+}
+
+static inline u16 sata_readw(struct ata_port *ap,
+			     const volatile void __iomem *addr)
+{
+	u16 r;
+	if (ap->ops->readw)
+		r = (ap->ops->readw)(addr);
+	else
+		r = readw(addr);
+
+	return r;
+}
+
+static inline void sata_writeb(struct ata_port *ap,
+			       u8 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writeb)
+		(ap->ops->writeb)(b, addr);
+	else
+		writeb(b, addr);
+}
+
+static inline void sata_writew(struct ata_port *ap,
+			       u16 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writew)
+		(ap->ops->writew)(b, addr);
+	else
+		writew(b, addr);
+}
+
+#undef readb
+#define readb(a_)	sata_readb(ap, a_)
+#undef writeb
+#define writeb(v_,a_)	sata_writeb(ap, v_, a_)
+#undef readw
+#define readw(a_)	sata_readw(ap, a_)
+#undef writew
+#define writew(v_,a_)	sata_writew(ap, v_, a_)
+
+
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
diff -Naur linux-2.6.17.8/include/linux/lirc.h linux-2.6.17.8-sh/include/linux/lirc.h
--- linux-2.6.17.8/include/linux/lirc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/lirc.h	2006-08-23 13:29:33.989484000 +0100
@@ -0,0 +1,103 @@
+/*      $Id: lirc.h,v 5.8 2003/01/26 12:57:59 lirc Exp $      */
+
+#ifndef _LINUX_LIRC_H
+#define _LINUX_LIRC_H
+
+#if defined (__linux__)
+#include <asm/types.h>
+#include <linux/ioctl.h>
+#else
+#include <sys/types.h>
+typedef u_int32_t __u32;
+#endif
+
+#define PULSE_BIT  0x01000000
+#define PULSE_MASK 0x00FFFFFF
+
+typedef int lirc_t;
+
+/*
+ * lirc compatible hardware features
+ */
+
+
+#define LIRC_MODE2SEND(x) (x)
+#define LIRC_SEND2MODE(x) (x)
+#define LIRC_MODE2REC(x) ((x) << 16)
+#define LIRC_REC2MODE(x) ((x) >> 16)
+
+#define LIRC_MODE_RAW                  0x00000001
+#define LIRC_MODE_PULSE                0x00000002
+#define LIRC_MODE_MODE2                0x00000004
+#define LIRC_MODE_CODE                 0x00000008
+#define LIRC_MODE_LIRCCODE             0x00000010
+#define LIRC_MODE_STRING               0x00000020
+
+
+#define LIRC_CAN_SEND_RAW              LIRC_MODE2SEND(LIRC_MODE_RAW)
+#define LIRC_CAN_SEND_PULSE            LIRC_MODE2SEND(LIRC_MODE_PULSE)
+#define LIRC_CAN_SEND_MODE2            LIRC_MODE2SEND(LIRC_MODE_MODE2)
+#define LIRC_CAN_SEND_CODE             LIRC_MODE2SEND(LIRC_MODE_CODE)
+#define LIRC_CAN_SEND_LIRCCODE         LIRC_MODE2SEND(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_SEND_STRING           LIRC_MODE2SEND(LIRC_MODE_STRING)
+
+#define LIRC_CAN_SEND_MASK             0x0000003f
+
+#define LIRC_CAN_SET_SEND_CARRIER      0x00000100
+#define LIRC_CAN_SET_SEND_DUTY_CYCLE   0x00000200
+
+#define LIRC_CAN_REC_RAW               LIRC_MODE2REC(LIRC_MODE_RAW)
+#define LIRC_CAN_REC_PULSE             LIRC_MODE2REC(LIRC_MODE_PULSE)
+#define LIRC_CAN_REC_MODE2             LIRC_MODE2REC(LIRC_MODE_MODE2)
+#define LIRC_CAN_REC_CODE              LIRC_MODE2REC(LIRC_MODE_CODE)
+#define LIRC_CAN_REC_LIRCCODE          LIRC_MODE2REC(LIRC_MODE_LIRCCODE)
+#define LIRC_CAN_REC_STRING            LIRC_MODE2REC(LIRC_MODE_STRING)
+
+#define LIRC_CAN_REC_MASK              LIRC_MODE2REC(LIRC_CAN_SEND_MASK)
+
+#define LIRC_CAN_SET_REC_CARRIER       (LIRC_CAN_SET_SEND_CARRIER << 16)
+#define LIRC_CAN_SET_REC_DUTY_CYCLE    (LIRC_CAN_SET_SEND_DUTY_CYCLE << 16)
+
+#define LIRC_CAN_SET_REC_DUTY_CYCLE_RANGE 0x40000000
+#define LIRC_CAN_SET_REC_CARRIER_RANGE    0x80000000
+
+
+#define LIRC_CAN_SEND(x) ((x)&LIRC_CAN_SEND_MASK)
+#define LIRC_CAN_REC(x) ((x)&LIRC_CAN_REC_MASK)
+
+/*
+ * IOCTL commands for lirc driver
+ */
+
+#define LIRC_GET_FEATURES              _IOR('i', 0x00000000, __u32)
+
+#define LIRC_GET_SEND_MODE             _IOR('i', 0x00000001, __u32)
+#define LIRC_GET_REC_MODE              _IOR('i', 0x00000002, __u32)
+#define LIRC_GET_SEND_CARRIER          _IOR('i', 0x00000003, __u32)
+#define LIRC_GET_REC_CARRIER           _IOR('i', 0x00000004, __u32)
+#define LIRC_GET_SEND_DUTY_CYCLE       _IOR('i', 0x00000005, __u32)
+#define LIRC_GET_REC_DUTY_CYCLE        _IOR('i', 0x00000006, __u32)
+
+/* code length in bits, currently only for LIRC_MODE_LIRCCODE */
+#define LIRC_GET_LENGTH                _IOR('i', 0x0000000f, __u32)
+
+#define LIRC_SET_SEND_MODE             _IOW('i', 0x00000011, __u32)
+#define LIRC_SET_REC_MODE              _IOW('i', 0x00000012, __u32)
+/* Note: these can reset the according pulse_width */
+#define LIRC_SET_SEND_CARRIER          _IOW('i', 0x00000013, __u32)
+#define LIRC_SET_REC_CARRIER           _IOW('i', 0x00000014, __u32)
+#define LIRC_SET_SEND_DUTY_CYCLE       _IOW('i', 0x00000015, __u32)
+#define LIRC_SET_REC_DUTY_CYCLE        _IOW('i', 0x00000016, __u32)
+
+/* to set a range use
+   LIRC_SET_REC_DUTY_CYCLE_RANGE/LIRC_SET_REC_CARRIER_RANGE with the
+   lower bound first and later
+   LIRC_SET_REC_DUTY_CYCLE/LIRC_SET_REC_CARRIER with the upper bound */
+
+#define LIRC_SET_REC_DUTY_CYCLE_RANGE  _IOW('i', 0x0000001e, __u32)
+#define LIRC_SET_REC_CARRIER_RANGE     _IOW('i', 0x0000001f, __u32)
+
+#define DEV_LIRC       "lirc"
+#define IRCTL_DEV_MAJOR 61
+
+#endif
diff -Naur linux-2.6.17.8/include/linux/serial_core.h linux-2.6.17.8-sh/include/linux/serial_core.h
--- linux-2.6.17.8/include/linux/serial_core.h	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/serial_core.h	2006-08-23 13:29:31.243438000 +0100
@@ -130,6 +130,9 @@
 /* SUN4V Hypervisor Console */
 #define PORT_SUNHV	72
 
+/* ST ASC type numbers */
+#define PORT_ASC	72
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
diff -Naur linux-2.6.17.8/include/linux/st-coprocessor.h linux-2.6.17.8-sh/include/linux/st-coprocessor.h
--- linux-2.6.17.8/include/linux/st-coprocessor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/st-coprocessor.h	2006-08-23 13:29:48.842831000 +0100
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2003-2004 Giuseppe Cavallaro (peppe.cavallaro@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+#include <linux/ioctl.h>
+#include <linux/device.h>
+#include <asm/addrspace.h>
+
+#define	MEGA			(1024 * 1024)
+typedef unsigned long kaddr_t;
+
+/* IOCTL parameters */
+
+typedef struct {
+	char	    name[16];		/* coprocessor name		    */
+	u_int	    flags;		/* control flags 		    */
+					/* Coprocessor region:              */
+	kaddr_t	    ram_start;		/*   Host effective address         */
+	u_int	    ram_size;		/*   region size (in bytes)         */
+	kaddr_t	    cp_ram_start;	/*   coprocessor effective address  */
+
+} cop_properties_t;
+
+#define ST_IOCTL_BASE		'l'
+#define STCOP_GRANT		_IOR(ST_IOCTL_BASE, 0, u_int)
+#define STCOP_RESET		_IOR(ST_IOCTL_BASE, 1, u_int)
+#define STCOP_START             STCOP_GRANT
+#define STCOP_PEEK		_IOR(ST_IOCTL_BASE, 2, void*)
+#define STCOP_POKE		_IOW(ST_IOCTL_BASE, 3, void*)
+#define STCOP_GET_PROPERTIES	_IOR(ST_IOCTL_BASE, 4, cop_properties_t*)
+#define STCOP_SET_PROPERTIES	_IOW(ST_IOCTL_BASE, 5, cop_properties_t*)
+
+#define NO_DATA		0xdeadbeef
+#define UNDEFINED_DATA	NO_DATA
+
+/* ---------------------------------------------------------------------------
+ *     Generic macros
+ * ------------------------------------------------------------------------ */
+
+#define xstring(x)              string(x)
+#define string(x)		#x
+#define plname(x)		x
+#define make_pname(x,y)		x ## y
+
+#define	MEGA			(1024 * 1024)
+#define COPROCESSOR_MAJOR	63
+#define FILE_2_COP(c,f)	  	(&(c)[MINOR((f)->f_dentry->d_inode->i_rdev)])
+
+#define OUT_PORT		2	/* Mailbox host --> cop. port */
+#define IN_PORT			3	/* Mailbox cop. --> host port */
+#define poke_l(v,a)		*((u_int *)(a)) = (v)
+#define peek_l(a)		*((u_int *)(a))
+
+
+#define COPR_ADDR(cop, off)     ( (cop)->ram_offset  + (off))
+#define HOST_ADDR(cop, off)	( (cop)->vma_address + (off))
+
+#ifdef CONFIG_COPROCESSOR_DEBUG
+#define DPRINTK(args...)   printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+#define __debug(a, b)	   _debug(a, b)
+
+/* ---------------------------------------------------------------------------
+ *     Local types
+ * ------------------------------------------------------------------------ */
+
+#define COPROC_SPACE_ALLOCATE	 0x0001	/* coprocessor RAM has been defined */
+#define COPROC_IN_USE    	 0x0002	/* copr. device has been opened     */
+#define COPROC_RUNNING   	 0x0004	/* coproc. is running (ioctl GRANT) */
+
+typedef struct {
+	u_int	    id;			/* CPU ID, now the CPU N. 	    */
+	u_int	    control;		/* see flags above (driver control) */
+	/*
+	 * The base address of coprocessor region, both sides: host (ST40)
+	 * and slave (ST231, LX,...) are build based on offset and start addr.
+	 */
+	u_long	    ram_offset;		/* Coprocessor RAM offset (in bytes)*/
+	u_int	    ram_size;		/* Coprocessor RAM size (in bytes)  */
+	u_long      vma_address;	/* The remap phisycal memory */
+#ifdef CONFIG_COPROCESSOR_DEBUG
+	u_int	    h2c_port;		/* comm. port: host --> coproc.     */
+	u_int	    c2h_port;		/* comm. port: host <-- coproc.     */
+#endif
+	u_int	    irq;		/* interrup used... if any          */
+	u_long	    mbox_wait;		/* CPU signature (waiting for boot) */
+	u_long	    mbox_entryp;	/* where to put the entry point...  */
+	u_long	    mbox_enable;	/* ... to trigger the CPU start     */
+	struct device dev;
+} coproc_t;
+
+struct coproc_board_info {
+	char *name;
+	int max_coprs;
+};
+
+extern int coproc_cpu_open(coproc_t *);
+extern int coproc_cpu_init(coproc_t *);
+extern int coproc_cpu_grant(coproc_t *, unsigned long);
+extern int coproc_cpu_release(coproc_t *);
+extern int coproc_cpu_reset(coproc_t *);
+extern void coproc_proc_other_info(coproc_t *, struct seq_file *);
diff -Naur linux-2.6.17.8/include/linux/stm/7100_fdma2.h linux-2.6.17.8-sh/include/linux/stm/7100_fdma2.h
--- linux-2.6.17.8/include/linux/stm/7100_fdma2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/stm/7100_fdma2.h	2006-08-23 13:29:44.954737000 +0100
@@ -0,0 +1,225 @@
+/*
+ *  STb7100 FDMA Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited.
+ *  Author: Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef STB7100_FDMA_H
+#define STB7100_FDMA_H
+
+/* Memory section offsets from FDMA base address */
+#define FDMA_BASE 0x19220000
+#define DMEM_OFFSET             		0x8000     /* Contains the control word interface */
+#define IMEM_OFFSET             		0xC000     /* Contains config data */
+
+#define FDMA2_ID						0x0000   /* Block Id */
+#define FDAM2_VER						0x0004
+#define FDMA2_ENABLE_REG				0x0008
+#define FDMA2_CLOCKGATE					0x000C       /* Clock enable control */
+
+#define FDMA2_REV_ID					0x8000
+#define FDMA2_CMD_STATn 				0x8040 //( +n * 4)
+
+#define NODE_DATA_OFFSET				0x40
+/*here our our current node params region */
+#define FDMA2_PTR_REG 					0x9180  /* ( + n * 0x40*/
+#define FDMA2_COUNT_REG					0x9188
+#define FDMA2_SADDR_REG					0x918c
+#define FDMA2_DADDR_REG					0x9190
+#define FDMA2_REQ_CTL_REG				0x9780 /* (+ n *0x04) */
+
+#define FDMA2_SYNCREG                 			0xBF88
+#define FDMA2_CMD_MBOX_STAT_REG				0xBFC0
+#define FDMA2_CMD_MBOX_SET_REG				0xBFC4
+#define FDMA2_CMD_MBOX_CLR_REG				0xBFC8
+#define FDMA2_CMD_MBOX_MASK_REG 			0xBFCC
+
+#define FDMA2_INT_STAT_REG				0xBFD0
+#define FDMA2_INT_SET_REG				0xBFD4
+#define FDMA2_INT_CLR_REG				0xBFD8
+#define FDMA2_INT_MASK_REG				0xBFDC
+
+/*our reg values*/
+#define CMD_STAT_OFFSET       			0x04
+
+#define CHANNEL_NOFLUSH 				0
+#define CHANNEL_FLUSH   				1
+#define CHAN_ALL_ENABLE 				3
+
+/**cmd stat vals*/
+#define SET_NODE_COMP_PAUSE		    		1 <<30
+#define SET_NODE_COMP_IRQ				1 <<31
+#define NODE_ADDR_STATIC 				0x01
+#define NODE_ADDR_INCR	 				0x02
+
+#define SOURCE_ADDR 	0x05
+#define DEST_ADDR   	0x07
+
+#define NODE_TYPE_SPDIF  		1 << 5
+#define SPDIF_NODE_VALID 		1 << 29
+#define SPDIF_BURST_END  		1 << 28
+#define EXTENDED_NODE_TYPE 		0x1f
+#define CHHI_STA_ZERO_PAD_MASK 		0x3f
+#define ZERO_PAD_MASK 			0xF0001FFF
+
+#define CMDSTAT_FDMA_START_CHANNEL  1
+#define CMDSTAT_FDMA_PAUSE_CHANNEL  3
+
+
+#define LINUX_FDMA_MESSAGE_PEND		140
+
+/*******************************/
+/*MBOX SETUP VALUES*/
+
+#define MBOX_CMD_PAUSE_FLUSH_CHANNEL 		3
+#define MBOX_CMD_PAUSE_CHANNEL		 	2
+#define MBOX_CMD_START_CHANNEL       		1
+#define CLEAR_WORD				0XFFFFFFFF
+
+
+typedef struct _fdma_llu_entry {
+	u32 next_item;
+	u32 control;
+	u32 size_bytes;
+	u32 saddr;
+	u32 daddr;
+	u32 length;
+	u32 node_sstride;
+	u32 node_dstride;
+}fdma_llu_entry;
+
+typedef struct _fdma_spdif_entry {
+	u32 next_item;
+	u32 control;
+	u32 size_bytes;
+	u32 saddr;
+	u32 daddr;
+	u32 node_pa_pb;
+	u32 node_pc_pd;
+	u32 node_bst_prd;
+	u32 node_chn0_sta_low;
+	u32 node_chn0_sta_high;
+	u32 node_chn1_sta_low;
+	u32 node_chn1_sta_high;
+	u32 align_pad0;
+	u32 align_pad1;
+	u32 align_pad2;
+	u32 align_pad3;
+}fdma_spdif_entry;
+
+
+typedef struct _fdma_pes_scdc_entry{
+	u32 next_item;
+	u32 control;
+	u32 node_nbytes;
+	u32 pes_buff;
+	u32 sc_write_n;
+	u32 sc_size_n;
+	u32 esbuf_top_n;
+	u32 esbuf_read_n;
+	u32 esbuf_write_n;
+	u32 esbuf_bot_n;
+	u32 pes_ctl_n;
+	u32 sc1_ctl_n;
+	u32 sc2_ctl_n;
+	u32 scd_sta_n;
+	u32 sc_type;
+	u32 sc_addr;
+	u32 sc_val;
+	u32 pts_type;
+	u32 pts_addr;
+	u32 pts_hi;
+	u32 pts_lo;
+}fdma_pes_scdc_entry;
+
+
+typedef void (*pf)(void * data);
+
+#define CHANNEL_ERR_IRQ 		3
+#define CHANNEL_IRQ     		1
+
+#define FDMA_CHANNEL_IDLE 		0
+#define FDMA_CHANNEL_RUNNING 		2
+#define FDMA_CHANNEL_PAUSED 		3
+
+
+
+/*FDMA Channel FLAGS*/
+/*values below D28 are reserved for REQ_LINE parameter*/
+#define REQ_LINE_MASK 	0x1f
+
+
+typedef struct _spdif_data
+{
+	u32 valid;
+	u32 burst_end;
+	u32 pa_pb;
+	u32 pc_pd;
+	u32 bst_prd;
+	u32 chn0_sta_low;
+	u32 chn0_sta_high;
+	u32 chn1_sta_low;
+	u32 chn1_sta_high;
+}spdif_data;
+
+
+typedef struct fmdareq_RequestConfig_s
+{
+    char Index;         /* Request line index number */
+    char Access;        /* Access type: Read or Write */
+    char OpCode;        /* Size of word access */
+    char Count;         /* Number of transfers per request */
+    char Increment;     /* Whether to increment. On 5517, number of bytes to increment per request */
+    char HoldOff;       /* Holdoff value between req signal samples (clock cycles)*/
+    char Initiator;     /* Use the default value */
+}fdmareq_RequestConfig_t;
+/*---- Constants for use in defining the request signals -----*/
+
+/* Access */
+#define ENABLE_FLG      1
+#define DISABLE_FLG     0
+
+/* Access */
+#define READ            0
+#define WRITE           1
+
+/* Opcodes */
+#define OPCODE_1        0x00
+#define OPCODE_2        0x01
+#define OPCODE_4        0x02
+#define OPCODE_8        0x03
+#define OPCODE_16       0x04
+#define OPCODE_32       0x05
+/* Increment Size */
+#define INCSIZE_0       0
+#define INCSIZE_4       4
+#define INCSIZE_8       8
+#define INCSIZE_16      16
+#define INCSIZE_32      32
+/* Utility values */
+#define UNUSED       0xff
+#define EOT          	0xfe
+
+/* Indicator for end of request signal table */
+#define REQUEST_SIGNAL_TABLE_END   EOT
+
+/* Indicator for unused request signal */
+#define REQUEST_SIGNAL_UNUSED      UNUSED
+
+
+#endif
diff -Naur linux-2.6.17.8/include/linux/stpio.h linux-2.6.17.8-sh/include/linux/stpio.h
--- linux-2.6.17.8/include/linux/stpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/stpio.h	2006-08-23 13:29:46.244783000 +0100
@@ -0,0 +1,61 @@
+/*
+ * include/linux/st_pio.h
+ *
+ * Copyright (c) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * ST40 General Purpose IO pins support.
+ *
+ * This layer enables other device drivers to configure PIO
+ * pins, get and set their values, and register an interrupt
+ * routine for when input pins change state.
+ */
+
+#ifndef _LINUX_ST_PIO_H_
+#define _LINUX_ST_PIO_H_ 1
+
+/*
+ * The ST40GX1 has two blocks of PIO registers:
+ *   3 in the ST40 core peripherals (PIO0 to PIO2)
+ *   2 in the ST20 legacy peripherals (comms block) (IO_PIO0 and IO_PIO1)
+ */
+#define STPIO_PIO_BANK(n) ((n)+0)
+#define STPIO_IO_PIO_BANK(n) ((n)+3)
+
+/* Pin configuration constants */
+/* Note that behaviour for modes 0, 6 and 7 differ between the ST40STB1
+ * datasheet (implementation restrictions appendix), and the ST40
+ * architectural defintions.
+ */
+#define STPIO_NONPIO		0	/* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1     	0	/* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR		1	/* Bidirectonal open-drain */
+#define STPIO_OUT		2	/* Output push-pull */
+/*efine STPIO_BIDIR		3	 * Bidirectional open drain */
+#define STPIO_IN		4	/* Input Hi-Z */
+/*efine STPIO_IN		5	 * Input Hi-Z */
+#define STPIO_ALT_OUT		6	/* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR		7	/* Alt bidir open drain (arch defn) */
+
+struct stpio_pin;
+
+/* Request and release exclusive use of a PIO pin */
+struct stpio_pin* stpio_request_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction);
+struct stpio_pin* stpio_request_set_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction, unsigned int value);
+void stpio_free_pin(struct stpio_pin* pin);
+
+/* Get, set value */
+void stpio_set_pin(struct stpio_pin* pin, unsigned int value);
+unsigned int stpio_get_pin(struct stpio_pin* pin);
+
+/* Interrupt on external value change */
+void stpio_request_irq(struct stpio_pin* pin, int mode,
+		       void (*handler)(struct stpio_pin *pin, void *dev),
+		       void *dev);
+void stpio_free_irq(struct stpio_pin* pin);
+void stpio_enable_irq(struct stpio_pin* pin, int mode);
+void stpio_disable_irq(struct stpio_pin* pin);
+
+#endif /* _LINUX_ST_PIO_H_ */
diff -Naur linux-2.6.17.8/include/linux/st_soc.h linux-2.6.17.8-sh/include/linux/st_soc.h
--- linux-2.6.17.8/include/linux/st_soc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/linux/st_soc.h	2006-08-23 13:29:50.692875000 +0100
@@ -0,0 +1,95 @@
+
+#ifndef __LINUX_ST_SOC_H
+#define __LINUX_ST_SOC_H
+
+struct soc_info {
+	/* List of platform devices exported by this SOC. You may choose which devices
+	 * you instantiate in the board support list. The UARTS are *NOT* present in this
+	 * list, they are in a separate one because you nearly always need to diddle with
+	 * the uarts, since the boards vary wildly.
+	 */
+	struct platform_device **devices;
+	int num_devices;
+
+	/* list of ASC ports this soc exports */
+	struct platform_device *uarts;
+	int num_uarts;
+};
+
+
+extern struct soc_info soc_data;
+
+/* Do whatever you need to do in order to allow the board_setup routine
+ * to work. Usually this involves mapping the PIOs and sysconfig
+ * registers, perhaps some clock setup etc etc.
+ */
+
+
+int soc_setup(void);
+
+int board_setup(void);
+
+
+/* This is the private platform data for the ASC driver */
+struct plat_serial_stasc_port {
+	unsigned int	uartclk;	/* UART clock rate in Hz*/
+	int late; /* Was this uart setup early in the boot or not ? */
+};
+
+/* This is the private platform data for the heartbeat LED driver */
+struct plat_heartbeat {
+  int (*init)(void); /* Do whatever you need to set it up */
+  void (*set)(int on); /* Switch it on/off */
+};
+
+/* This is the private platform data for the lirc driver */
+struct plat_lirc_data {
+	unsigned int irbclock;		/* IRB block clock (set to 0 for auto) */
+	unsigned int irbclkdiv;		/* IRB block clock divisor (set to 0 for auto) */
+	unsigned int irbperiodmult;	/* manual setting period multiplier */
+	unsigned int irbperioddiv;	/* manual setting period divisor */
+	unsigned int irbontimemult;	/* manual setting pulse period multiplier */
+	unsigned int irbontimediv;	/* manual setting pulse period divisor */
+	unsigned int irbrxmaxperiod;	/* maximum rx period in uS */
+	unsigned int irbversion;	/* IRB version type (1,2 or 3) */
+	unsigned int sysclkdiv;		/* factor to divide system bus clock by */
+	unsigned int rxpolarity;        /* flag to set gpio rx polarity (usually set to 1) */
+	unsigned int subcarrwidth;      /* Subcarrier width in percent - this is used to */
+					/* make the subcarrier waveform square after passing */
+					/* through the 555-based threshold detector on ST boards */
+};
+
+/* This is the private platform data for the ssc driver */
+struct plat_ssc_pio_t {
+        unsigned char sclbank;
+        unsigned char sclpin;
+        unsigned char sdoutbank;
+        unsigned char sdoutpin;
+        unsigned char sdinbank;
+        unsigned char sdinpin;
+} ;
+
+struct plat_ssc_data {
+        unsigned int    sscclk;       /* SSC clock rate in Hz*/
+        unsigned short  capability;   /* bitmask on the ssc capability */
+        struct plat_ssc_pio_t *pio;   /* the Pio map */
+};
+
+/* Private data for the SATA driver */
+struct plat_sata_data {
+	unsigned long phy_init;
+	unsigned long pc_glue_logic_init;
+	unsigned int only_32bit;
+};
+
+/* Private data for the PWM driver */
+struct plat_stm_pwm_data {
+	unsigned long flags;
+};
+
+#define PLAT_STM_PWM_OUT0	(1<<0)
+#define PLAT_STM_PWM_OUT1	(1<<1)
+
+#endif /* __LINUX_ST_SOC_H */
+
+
diff -Naur linux-2.6.17.8/include/video/voyager.h linux-2.6.17.8-sh/include/video/voyager.h
--- linux-2.6.17.8/include/video/voyager.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/include/video/voyager.h	2006-08-23 13:29:08.105887000 +0100
@@ -0,0 +1,39 @@
+#define	VOY_REG_TOP	0xb3e00000	//voyager register
+#define	VOY_VRAM_TOP0	0xb0400000	//PANEL PLANE
+#define	VOY_VRAM_TOP1	0xb04a0000	//VIDEO PLANE 0
+#define	VOY_VRAM_TOP2	0xb0540000	//VIDEO PLANE 1
+#define	VOY_VRAM_TOP3	0xb05e0000	//VIDEO ALPHA PLANE
+#define	VOY_VRAM_TOP4	0xb0680000	//ALPHA PLANE
+#define	VOY_VRAM_TOP5	0xb0720000	//PANEL CURSOR PLANE
+#define	VOY_VRAM_TOP6	0xb0730000	//CRT PLANE
+#define	VOY_VRAM_TOP7	0xb07d0000	//CRT CURSOR PLANE
+
+#define XRES 640
+#define YRES 480
+#define BPP  16
+
+#define CSR_XRES 64
+#define CSR_YRES 64
+#define CSR_BPP  2
+
+#define MAX_PIXEL_MEM_SIZE ((XRES * YRES * BPP) / 8)
+#define LINE_LENGTH        ((XRES * BPP) / 8)
+#define MAX_FRAMEBUFFER_MEM_SIZE (MAX_PIXEL_MEM_SIZE)
+#define MAX_HWC_MEM_SIZE ((CSR_XRES * CSR_YRES * CSR_BPP) / 8)
+#define ALLOCATED_FB_MEM_SIZE \
+	(PAGE_ALIGN(MAX_FRAMEBUFFER_MEM_SIZE + PAGE_SIZE))
+
+#define	VOYAGER_IOCTL_DEBUG_ADD		0x00
+#define	VOYAGER_IOCTL_DEBUG_GET		0x01
+#define	VOYAGER_IOCTL_DEBUG_PUT		0x02
+#define	VOYAGER_IOCTL_ENABLE		0x10
+#define	VOYAGER_IOCTL_ENABLE_CK		0x11
+#define	VOYAGER_IOCTL_ENABLE_CP		0x12
+#define	VOYAGER_IOCTL_ENABLE_AL		0x13
+#define	VOYAGER_IOCTL_SCALE		0x20
+#define	VOYAGER_IOCTL_CHKEY		0x30
+#define	VOYAGER_IOCTL_COLOR_1		0x40
+#define	VOYAGER_IOCTL_COLOR_2		0x41
+#define	VOYAGER_IOCTL_TYPE		0x50
+#define	VOYAGER_IOCTL_SELECT		0x51
+#define	VOYAGER_IOCTL_ALPHA		0x60
diff -Naur linux-2.6.17.8/kernel/kallsyms.c linux-2.6.17.8-sh/kernel/kallsyms.c
--- linux-2.6.17.8/kernel/kallsyms.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/kernel/kallsyms.c	2006-08-23 13:29:32.117438000 +0100
@@ -20,6 +20,9 @@
 #include <linux/proc_fs.h>
 #include <linux/sched.h>	/* for cond_resched */
 #include <linux/mm.h>
+#ifdef CONFIG_BIGPHYS_AREA
+#include <linux/bigphysarea.h>
+#endif
 
 #include <asm/sections.h>
 
@@ -419,3 +422,10 @@
 __initcall(kallsyms_init);
 
 EXPORT_SYMBOL(__print_symbol);
+#ifdef CONFIG_BIGPHYS_AREA
+EXPORT_SYMBOL(bigphysarea_alloc);
+EXPORT_SYMBOL(bigphysarea_free);
+EXPORT_SYMBOL(bigphysarea_alloc_pages);
+EXPORT_SYMBOL(bigphysarea_free_pages);
+#endif
+
diff -Naur linux-2.6.17.8/lib/Kconfig.debug linux-2.6.17.8-sh/lib/Kconfig.debug
--- linux-2.6.17.8/lib/Kconfig.debug	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/lib/Kconfig.debug	2006-08-23 13:29:22.825232000 +0100
@@ -178,7 +178,7 @@
 
 config FRAME_POINTER
 	bool "Compile the kernel with frame pointers"
-	depends on DEBUG_KERNEL && (X86 || CRIS || M68K || M68KNOMMU || FRV || UML)
+	depends on DEBUG_KERNEL && (X86 || CRIS || M68K || M68KNOMMU || FRV || UML || SUPERH)
 	default y if DEBUG_INFO && UML
 	help
 	  If you say Y here the resulting kernel image will be slightly larger
diff -Naur linux-2.6.17.8/localversion-sh linux-2.6.17.8-sh/localversion-sh
--- linux-2.6.17.8/localversion-sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/localversion-sh	2006-08-23 13:29:26.097300000 +0100
@@ -0,0 +1 @@
+-sh
diff -Naur linux-2.6.17.8/mm/bigphysarea.c linux-2.6.17.8-sh/mm/bigphysarea.c
--- linux-2.6.17.8/mm/bigphysarea.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/mm/bigphysarea.c	2006-08-23 13:29:45.573760000 +0100
@@ -0,0 +1,366 @@
+/* linux/mm/bigphysarea.c, M. Welsh (mdw@cs.cornell.edu)
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?)
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/ptrace.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/bigphysarea.h>
+
+static int get_info(char* buf, char**, off_t, int);
+
+typedef struct range_struct {
+	struct range_struct *next;
+	caddr_t base;			/* base of allocated block */
+	size_t  size;			/* size in bytes */
+} range_t;
+
+/*
+ * 0: nothing initialized
+ * 1: bigphysarea_pages initialized
+ * 2: free list initialized
+ */
+static int	init_level = 0;
+static int	bigphysarea_pages = 0;
+static caddr_t	bigphysarea = 0;
+static range_t	*free_list = NULL;
+static range_t	*used_list = NULL;
+static struct resource mem_resource = { "Bigphysarea", 0, 0, IORESOURCE_MEM|IORESOURCE_BUSY };
+
+static
+int __init bigphysarea_init(void)
+{
+	if (bigphysarea_pages == 0 || bigphysarea == 0)
+		return -EINVAL;
+
+	/* create to /proc entry for it */
+	if (!create_proc_info_entry("bigphysarea",0444,&proc_root,get_info)) {
+		// ohoh, no way to free the allocated memory!
+		// continue without proc support, it not fatal in itself
+//		free_bootmem((unsigned long)bigphysarea>>PAGE_SHIFT,bigphysarea_pages<<PAGE_SHIFT);
+//		bigphysarea = 0;
+//		return -ENOMEM;
+	}
+
+	init_level = 1;
+
+	printk(KERN_INFO "bigphysarea: Allocated %d pages at 0x%p.\n",
+	       bigphysarea_pages, bigphysarea);
+
+	return 0;
+}
+
+__initcall(bigphysarea_init);
+
+/*
+ * call when 'bigphysarea=' is given on the commandline.
+ *
+ * Strangely, bootmem is still active during this call, but
+ * during the processing of the initcalls it isn't anymore!
+ * So we alloc the needed memory here instead of bigphysarea_init().
+ */
+static
+int __init bigphysarea_setup(char *str)
+{
+	int par, base;
+
+	if (get_option(&str,&par)) {
+		bigphysarea_pages = par;
+		// Alloc the memory
+		if (get_option(&str, &base)) {
+			/* reserving boot memory from kernel arguments is a bit
+			 * risky because reserve_bootmem() silently allocates
+			 * memory twice (unless CONFIG_DEBUG_BOOTMEM is set
+			 * in mm/bootmem.c) and does not even have a return
+			 * code for us to check.
+			 */
+			reserve_bootmem(base, bigphysarea_pages<<PAGE_SHIFT);
+			bigphysarea = phys_to_virt(base);
+		} else {
+			bigphysarea = alloc_bootmem_low_pages(bigphysarea_pages<<PAGE_SHIFT);
+		}
+		if (!bigphysarea) {
+			printk(KERN_CRIT "bigphysarea: not enough memory for %d pages\n",bigphysarea_pages);
+			return -ENOMEM;
+		}
+
+		// register the resource for it
+		mem_resource.start = (unsigned long)bigphysarea;
+		mem_resource.end = mem_resource.start + (bigphysarea_pages<<PAGE_SHIFT);
+		request_resource(&iomem_resource, &mem_resource);
+	}
+	return 1;
+}
+
+__setup("bigphysarea=", bigphysarea_setup);
+
+/*
+ * When we have pages but don't have a freelist, put all pages in
+ * one free list entry. Return 0 on success, 1 on error.
+ */
+static
+int init2(int priority)
+{
+	if (init_level == 1) {
+		free_list = kmalloc(sizeof(range_t), priority);
+		if (free_list != NULL) {
+			free_list->next = NULL;
+			free_list->base = bigphysarea;
+			free_list->size = bigphysarea_pages * PAGE_SIZE;
+			init_level = 2;
+			return 0;
+		}
+	}
+	return 1;
+}
+
+
+/*
+ * Allocate `count' pages from the big physical area. Pages are aligned to
+ * a multiple of `align'. `priority' has the same meaning in kmalloc, it
+ * is needed for management information.
+ * This function may not be called from an interrupt!
+ */
+caddr_t bigphysarea_alloc_pages(int count, int align, int priority)
+{
+	range_t *range, **range_ptr, *new_range, *align_range;
+	caddr_t aligned_base=0;
+
+	if (init_level < 2)
+		if (init2(priority))
+			return 0;
+	new_range   = NULL;
+	align_range = NULL;
+
+	if (align == 0)
+		align = PAGE_SIZE;
+	else
+		align = align * PAGE_SIZE;
+	/*
+	 * Search a free block which is large enough, even with alignment.
+	 */
+	range_ptr = &free_list;
+	while (*range_ptr != NULL) {
+		range = *range_ptr;
+		aligned_base =
+		  (caddr_t)((((unsigned long)range->base + align - 1) / align) * align);
+		if (aligned_base + count * PAGE_SIZE <=
+		    range->base + range->size)
+			break;
+	     range_ptr = &range->next;
+	}
+	if (*range_ptr == NULL)
+		return 0;
+	range = *range_ptr;
+	/*
+	 * When we have to align, the pages needed for alignment can
+	 * be put back to the free pool.
+	 * We check here if we need a second range data structure later
+	 * and allocate it now, so that we don't have to check for a
+	 * failed kmalloc later.
+	 */
+	if (aligned_base - range->base + count * PAGE_SIZE < range->size) {
+		new_range = kmalloc(sizeof(range_t), priority);
+		if (new_range == NULL)
+			return NULL;
+	}
+	if (aligned_base != range->base) {
+		align_range = kmalloc(sizeof(range_t), priority);
+		if (align_range == NULL) {
+			if (new_range != NULL)
+				kfree(new_range);
+			return NULL;
+		}
+		align_range->base = range->base;
+		align_range->size = aligned_base - range->base;
+		range->base = aligned_base;
+		range->size -= align_range->size;
+		align_range->next = range;
+		*range_ptr = align_range;
+		range_ptr = &align_range->next;
+	}
+	if (new_range != NULL) {
+		/*
+		 * Range is larger than needed, create a new list element for
+		 * the used list and shrink the element in the free list.
+		 */
+		new_range->base        = range->base;
+		new_range->size        = count * PAGE_SIZE;
+		range->base = new_range->base + new_range->size;
+		range->size = range->size - new_range->size;
+	} else {
+		/*
+		 * Range fits perfectly, remove it from free list.
+		 */
+		*range_ptr = range->next;
+		new_range = range;
+	}
+	/*
+	 * Insert block into used list
+	 */
+	new_range->next = used_list;
+	used_list = new_range;
+
+	return new_range->base;
+}
+
+/*
+ * Free pages allocated with `bigphysarea_alloc_pages'. `base' must be an
+ * address returned by `bigphysarea_alloc_pages'.
+ * This function my not be called from an interrupt!
+ */
+void bigphysarea_free_pages(caddr_t base)
+{
+	range_t *prev, *next, *range, **range_ptr;
+
+	/*
+	 * Search the block in the used list.
+	 */
+	for (range_ptr = &used_list;
+	     *range_ptr != NULL;
+	     range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base == base)
+			break;
+	if (*range_ptr == NULL) {
+		printk("bigphysarea_free_pages(0x%08x), not allocated!\n",
+		       (unsigned)base);
+		return;
+	}
+	range = *range_ptr;
+	/*
+	 * Remove range from the used list:
+	 */
+	*range_ptr = (*range_ptr)->next;
+	/*
+	 * The free-list is sorted by address, search insertion point
+	 * and insert block in free list.
+	 */
+	for (range_ptr = &free_list, prev = NULL;
+	     *range_ptr != NULL;
+	     prev = *range_ptr, range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base >= base)
+			break;
+	range->next  = *range_ptr;
+	*range_ptr   = range;
+	/*
+	 * Concatenate free range with neighbors, if possible.
+	 * Try for upper neighbor (next in list) first, then
+	 * for lower neighbor (predecessor in list).
+	 */
+	if (range->next != NULL &&
+	    range->base + range->size == range->next->base) {
+		next = range->next;
+		range->size += range->next->size;
+		range->next = next->next;
+		kfree(next);
+	}
+	if (prev != NULL &&
+	    prev->base + prev->size == range->base) {
+		prev->size += prev->next->size;
+		prev->next = range->next;
+		kfree(range);
+	}
+}
+
+caddr_t bigphysarea_alloc(int size)
+{
+	int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+	return bigphysarea_alloc_pages(pages, 1, GFP_KERNEL);
+}
+
+void bigphysarea_free(caddr_t addr, int size)
+{
+	(void)size;
+	bigphysarea_free_pages(addr);
+}
+
+static
+int get_info(char *buf, char **a, off_t b, int c)
+{
+	char    *p = buf;
+	range_t *ptr;
+	int     free_count, free_total, free_max;
+	int     used_count, used_total, used_max;
+
+	if (init_level == 1)
+	  init2(GFP_KERNEL);
+
+	free_count = 0;
+	free_total = 0;
+	free_max   = 0;
+	for (ptr = free_list; ptr != NULL; ptr = ptr->next) {
+		free_count++;
+		free_total += ptr->size;
+		if (ptr->size > free_max)
+			free_max = ptr->size;
+	}
+
+	used_count = 0;
+	used_total = 0;
+	used_max   = 0;
+	for (ptr = used_list; ptr != NULL; ptr = ptr->next) {
+		used_count++;
+		used_total += ptr->size;
+		if (ptr->size > used_max)
+			used_max = ptr->size;
+	}
+
+	if (bigphysarea_pages == 0) {
+		p += sprintf(p, "No big physical area allocated!\n");
+		return  p - buf;
+	}
+
+	p += sprintf(p, "Big physical area, size %ld kB\n",
+		     bigphysarea_pages * PAGE_SIZE / 1024);
+	p += sprintf(p, "                       free list:             used list:\n");
+	p += sprintf(p, "number of blocks:      %8d               %8d\n",
+		     free_count, used_count);
+	p += sprintf(p, "size of largest block: %8d kB            %8d kB\n",
+		     free_max / 1024, used_max / 1024);
+	p += sprintf(p, "total:                 %8d kB            %8d kB\n",
+		     free_total / 1024, used_total /1024);
+
+	return  p - buf;
+}
+
+void bigphysarea_memory(unsigned long *base, unsigned long *size)
+{
+        *base = (unsigned long) bigphysarea;
+        *size = bigphysarea_pages * PAGE_SIZE;
+}
+EXPORT_SYMBOL(bigphysarea_memory);
diff -Naur linux-2.6.17.8/mm/bootmem.c linux-2.6.17.8-sh/mm/bootmem.c
--- linux-2.6.17.8/mm/bootmem.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/mm/bootmem.c	2006-08-23 13:29:45.595760000 +0100
@@ -21,6 +21,8 @@
 #include <asm/io.h>
 #include "internal.h"
 
+#define CONFIG_DEBUG_BOOTMEM
+
 /*
  * Access to this subsystem has to be serialized externally. (this is
  * true for the boot process anyway)
diff -Naur linux-2.6.17.8/mm/Makefile linux-2.6.17.8-sh/mm/Makefile
--- linux-2.6.17.8/mm/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/mm/Makefile	2006-08-23 13:29:32.145438000 +0100
@@ -23,4 +23,5 @@
 obj-$(CONFIG_MEMORY_HOTPLUG) += memory_hotplug.o
 obj-$(CONFIG_FS_XIP) += filemap_xip.o
 obj-$(CONFIG_MIGRATION) += migrate.o
+obj-$(CONFIG_BIGPHYS_AREA) += bigphysarea.o
 
diff -Naur linux-2.6.17.8/mm/memory.c linux-2.6.17.8-sh/mm/memory.c
--- linux-2.6.17.8/mm/memory.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/mm/memory.c	2006-08-23 13:29:07.084863000 +0100
@@ -1455,7 +1455,9 @@
 		int reuse = can_share_swap_page(old_page);
 		unlock_page(old_page);
 		if (reuse) {
+#ifdef CONFIG_ARM
 			flush_cache_page(vma, address, pte_pfn(orig_pte));
+#endif
 			entry = pte_mkyoung(orig_pte);
 			entry = maybe_mkwrite(pte_mkdirty(entry), vma);
 			ptep_set_access_flags(vma, address, page_table, entry, 1);
diff -Naur linux-2.6.17.8/mm/slab.c linux-2.6.17.8-sh/mm/slab.c
--- linux-2.6.17.8/mm/slab.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/mm/slab.c	2006-08-23 13:29:44.558737000 +0100
@@ -149,7 +149,7 @@
  * alignment larger than BYTES_PER_WORD. ARCH_KMALLOC_MINALIGN allows that.
  * Note that this flag disables some debug features.
  */
-#define ARCH_KMALLOC_MINALIGN 0
+#define ARCH_KMALLOC_MINALIGN 32
 #endif
 
 #ifndef ARCH_SLAB_MINALIGN
@@ -2025,8 +2025,9 @@
 			flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
 	}
 	/* 3) caller mandated alignment: disables debug if necessary */
-	if (ralign < align) {
-		ralign = align;
+	if (align) {
+		if (ralign < align)
+			ralign = align;
 		if (ralign > BYTES_PER_WORD)
 			flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);
 	}
diff -Naur linux-2.6.17.8/net/core/netpoll.c linux-2.6.17.8-sh/net/core/netpoll.c
--- linux-2.6.17.8/net/core/netpoll.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/net/core/netpoll.c	2006-08-23 13:29:33.720484000 +0100
@@ -53,6 +53,10 @@
 		(MAX_UDP_CHUNK + sizeof(struct udphdr) + \
 				sizeof(struct iphdr) + sizeof(struct ethhdr))
 
+#ifdef CONFIG_NWHW_CONFIG
+void nwhw_uconfig(struct net_device *);
+#endif
+
 static void zap_completion_queue(void);
 
 static void queue_process(void *p)
@@ -666,6 +670,13 @@
 	if (!netif_running(ndev)) {
 		unsigned long atmost, atleast;
 
+#ifdef CONFIG_NWHW_CONFIG
+		/* Configuring the network hardware from the command line,
+		   enabling the NWHW_CONFIG support, we are quite sure that the
+		   network devices properties must be set manually. */
+		nwhw_uconfig(ndev);
+#endif
+
 		printk(KERN_INFO "%s: device %s not up yet, forcing it\n",
 		       np->name, np->dev_name);
 
diff -Naur linux-2.6.17.8/net/ipv4/ipconfig.c linux-2.6.17.8-sh/net/ipv4/ipconfig.c
--- linux-2.6.17.8/net/ipv4/ipconfig.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/net/ipv4/ipconfig.c	2006-08-23 13:29:34.731508000 +0100
@@ -113,7 +113,7 @@
  */
 int ic_set_manually __initdata = 0;		/* IPconfig parameters set manually */
 
-static int ic_enable __initdata = 0;		/* IP config enabled? */
+static int ic_enable __initdata = 1;		/* IP config enabled? */
 
 /* Protocol choice */
 int ic_proto_enabled __initdata = 0
@@ -178,6 +178,7 @@
 
 static struct ic_device *ic_first_dev __initdata = NULL;/* List of open device */
 static struct net_device *ic_dev __initdata = NULL;	/* Selected device */
+static unsigned int __initdata ipconf_delay = 0;
 
 static int __init ic_open_devs(void)
 {
@@ -185,6 +186,12 @@
 	struct net_device *dev;
 	unsigned short oflags;
 
+	if (ipconf_delay) {
+		printk(KERN_INFO "Waiting %dsec before opening network devices...\n",
+		       ipconf_delay);
+		ssleep(ipconf_delay);
+	}
+
 	last = &ic_first_dev;
 	rtnl_lock();
 
@@ -1506,5 +1513,12 @@
 	return ip_auto_config_setup(addrs);
 }
 
+static int __init ipconfdelay_config_setup(char *str)
+{
+	ipconf_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+
 __setup("ip=", ip_auto_config_setup);
 __setup("nfsaddrs=", nfsaddrs_config_setup);
+__setup("ipconfdelay=", ipconfdelay_config_setup);
diff -Naur linux-2.6.17.8/sound/Kconfig linux-2.6.17.8-sh/sound/Kconfig
--- linux-2.6.17.8/sound/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/sound/Kconfig	2006-08-23 13:29:35.885530000 +0100
@@ -62,6 +62,10 @@
 
 source "sound/mips/Kconfig"
 
+source "sound/sh/Kconfig"
+
+source "sound/stm/Kconfig"
+
 # the following will depenend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff -Naur linux-2.6.17.8/sound/Makefile linux-2.6.17.8-sh/sound/Makefile
--- linux-2.6.17.8/sound/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/sound/Makefile	2006-08-23 13:29:35.908530000 +0100
@@ -4,7 +4,7 @@
 obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ sh/ stm/
 
 ifeq ($(CONFIG_SND),y)
   obj-y += last.o
diff -Naur linux-2.6.17.8/sound/oss/Kconfig linux-2.6.17.8-sh/sound/oss/Kconfig
--- linux-2.6.17.8/sound/oss/Kconfig	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/Kconfig	2006-08-23 13:29:08.136899000 +0100
@@ -833,6 +833,12 @@
 	tristate "XpressAudio Sound Blaster emulation"
 	depends on SOUND_SB
 
+config SOUND_VOYAGERGX
+	tristate "VoyagerGX/SH4 AC97 support"
+	depends on SOUND_PRIME!=n && SOUND && SH_RTS7751R2D
+	help
+	  Say Y or M if you have a VoyagerGX sound audio.
+
 config SOUND_SH_DAC_AUDIO
 	tristate "SuperH DAC audio support"
 	depends on SOUND_PRIME && CPU_SH3
diff -Naur linux-2.6.17.8/sound/oss/Makefile linux-2.6.17.8-sh/sound/oss/Makefile
--- linux-2.6.17.8/sound/oss/Makefile	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/Makefile	2006-08-23 13:29:08.182909000 +0100
@@ -82,6 +82,7 @@
 
 obj-$(CONFIG_SOUND_AD1980)	+= ac97_plugin_ad1980.o ac97_codec.o
 obj-$(CONFIG_SOUND_WM97XX)	+= ac97_plugin_wm97xx.o
+obj-$(CONFIG_SOUND_VOYAGERGX)	+= voyagergx_sound.o voyagergx_8051.o ac97_codec.o
 
 ifeq ($(CONFIG_MIDI_EMU10K1),y)
   obj-$(CONFIG_SOUND_EMU10K1)	+= sound.o
diff -Naur linux-2.6.17.8/sound/oss/sh_dac_audio.c linux-2.6.17.8-sh/sound/oss/sh_dac_audio.c
--- linux-2.6.17.8/sound/oss/sh_dac_audio.c	2006-06-18 02:49:35.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/sh_dac_audio.c	2006-08-23 13:29:17.882116000 +0100
@@ -1,3 +1,14 @@
+/*
+ * sound/oss/sh_dac_audio.c
+ *
+ * SH DAC based sound :(
+ *
+ *  Copyright (C) 2004,2005  Andriy Skulysh
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -7,18 +18,17 @@
 #include <linux/fs.h>
 #include <linux/sound.h>
 #include <linux/soundcard.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/irq.h>
 #include <asm/delay.h>
-#include <linux/interrupt.h>
-
+#include <asm/clock.h>
 #include <asm/cpu/dac.h>
-
-#ifdef MACH_HP600
+#include <asm/cpu/timer.h>
+#include <asm/machvec.h>
 #include <asm/hp6xx/hp6xx.h>
-#include <asm/hd64461/hd64461.h>
-#endif
+#include <asm/hd64461.h>
 
 #define MODNAME "sh_dac_audio"
 
@@ -27,11 +37,6 @@
 #define TMU1_TCR_INIT	0x0020	/* Clock/4, rising edge; interrupt on */
 #define TMU1_TSTR_INIT  0x02	/* Bit to turn on TMU1 */
 
-#define TMU_TSTR	0xfffffe92
-#define TMU1_TCOR	0xfffffea0
-#define TMU1_TCNT	0xfffffea4
-#define TMU1_TCR	0xfffffea8
-
 #define BUFFER_SIZE 48000
 
 static int rate;
@@ -72,34 +77,37 @@
 
 static void dac_audio_start(void)
 {
-#ifdef MACH_HP600
-	u16 v;
-	v = inw(HD64461_GPADR);
-	v &= ~HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-#endif
+	if (mach_is_hp6xx()) {
+		u16 v = inw(HD64461_GPADR);
+		v &= ~HD64461_GPADR_SPEAKER;
+		outw(v, HD64461_GPADR);
+	}
+
 	sh_dac_enable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 	ctrl_outw(TMU1_TCR_INIT, TMU1_TCR);
 }
 static void dac_audio_stop(void)
 {
-#ifdef MACH_HP600
-	u16 v;
-#endif
 	dac_audio_stop_timer();
-#ifdef MACH_HP600
-	v = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-#endif
+
+	if (mach_is_hp6xx()) {
+		u16 v = inw(HD64461_GPADR);
+		v |= HD64461_GPADR_SPEAKER;
+		outw(v, HD64461_GPADR);
+	}
+
+ 	sh_dac_output(0, CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 	sh_dac_disable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 }
 
 static void dac_audio_set_rate(void)
 {
 	unsigned long interval;
+ 	struct clk *clk;
 
-	interval = (current_cpu_data.module_clock / 4) / rate;
+ 	clk = clk_get("module_clk");
+ 	interval = (clk_get_rate(clk) / 4) / rate;
+ 	clk_put(clk);
 	ctrl_outl(interval, TMU1_TCOR);
 	ctrl_outl(interval, TMU1_TCNT);
 }
diff -Naur linux-2.6.17.8/sound/oss/voyagergx_8051.c linux-2.6.17.8-sh/sound/oss/voyagergx_8051.c
--- linux-2.6.17.8/sound/oss/voyagergx_8051.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/voyagergx_8051.c	2006-08-23 13:29:28.145349000 +0100
@@ -0,0 +1,204 @@
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <asm/voyagergx.h>
+#include "voyagergx_sound.h"
+
+#define DELAY_8051	300000
+
+
+static	unsigned char	code_8051[] = {
+	0x02,0x01,0x00,0x02,0x07,0x73,0x90,0x08,0xae,0xe0,0xfa,0xa3,0xe0,0x8a,0x82,0xf5,
+	0x83,0xe0,0x60,0x13,0x90,0x08,0xa2,0xe4,0xf0,0xa3,0x74,0x30,0xf0,0x78,0x19,0x76,
+	0x01,0x78,0x1e,0x76,0x01,0x80,0x04,0x78,0x19,0x76,0x00,0x90,0x3f,0xf2,0x74,0x01,
+	0xf0,0xa3,0xe4,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0x02,0x06,0x83,0xff,0xff,
+	0xff,0xff,0xff,0x02,0x04,0xe3,0x90,0x3f,0xf2,0xe4,0xf0,0xa3,0xf0,0x90,0x3f,0xf0,
+	0xe0,0x70,0x02,0xa3,0xe0,0x70,0x06,0x12,0x08,0x8d,0x02,0x00,0xd4,0x90,0x3f,0xf0,
+	0xc3,0xe0,0x94,0x01,0x70,0x04,0xa3,0xe0,0x94,0x00,0x70,0x06,0x12,0x00,0xd9,0x02,
+	0x00,0xd4,0x90,0x3f,0xf0,0xc3,0xe0,0x94,0x02,0x70,0x04,0xa3,0xe0,0x94,0x00,0x70,
+	0x05,0x12,0x07,0xf3,0x80,0x4e,0x90,0x3f,0xf0,0xc3,0xe0,0x94,0x03,0x70,0x04,0xa3,
+	0xe0,0x94,0x00,0x70,0x05,0x12,0x08,0x1a,0x80,0x3a,0x90,0x3f,0xf0,0xc3,0xe0,0x94,
+	0x04,0x70,0x04,0xa3,0xe0,0x94,0x00,0x70,0x05,0x12,0x08,0x41,0x80,0x26,0x90,0x3f,
+	0xf0,0xc3,0xe0,0x94,0x05,0x70,0x04,0xa3,0xe0,0x94,0x00,0x70,0x05,0x12,0x08,0x7c,
+	0x80,0x12,0x90,0x3f,0xf0,0xc3,0xe0,0x94,0x07,0x70,0x04,0xa3,0xe0,0x94,0x00,0x70,
+	0x03,0x12,0x00,0x06,0x78,0x1b,0x76,0x00,0x22,0x90,0x3f,0xf4,0x7a,0x04,0x78,0x08,
+	0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x91,0x04,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,
+	0x08,0xda,0xfa,0x12,0x06,0xd6,0x90,0x3f,0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,0x22,
+	0x75,0x81,0x2b,0x75,0x0c,0xc0,0x75,0x0d,0x08,0x75,0x0e,0xff,0x75,0x0f,0x2f,0xc2,
+	0xd3,0xc2,0xd4,0x12,0x03,0x4a,0x12,0x03,0xb6,0x12,0x03,0x2c,0x12,0x03,0x0e,0x12,
+	0x02,0xac,0x12,0x07,0xcb,0x12,0x01,0x2a,0x01,0x00,0x90,0x08,0xc1,0x85,0x82,0x0a,
+	0x85,0x83,0x0b,0x74,0x98,0xf5,0x82,0xf5,0x08,0x74,0x02,0xf5,0x83,0xf5,0x09,0x7a,
+	0x14,0xe4,0x93,0xa3,0x85,0x82,0x08,0x85,0x83,0x09,0x85,0x0a,0x82,0x85,0x0b,0x83,
+	0xf0,0xa3,0x85,0x83,0x0b,0x85,0x82,0x0a,0x85,0x09,0x83,0x85,0x08,0x82,0xda,0xe1,
+	0x90,0x08,0xd5,0xe4,0xf0,0xa3,0xf0,0x90,0x08,0xd7,0xe4,0xf0,0xa3,0xf0,0x90,0x08,
+	0xd9,0xe4,0xf0,0xa3,0xf0,0x90,0x08,0xdb,0xe4,0xf0,0xa3,0xf0,0x78,0x18,0x76,0x00,
+	0x78,0x1f,0x76,0x00,0x90,0x91,0x80,0x74,0x03,0xf0,0x90,0x08,0xc1,0x7a,0x04,0x78,
+	0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x91,0x00,0x7a,0x04,0x78,0x08,0xe6,0xf0,
+	0xa3,0x08,0xda,0xfa,0x90,0x08,0xc5,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,
+	0xfa,0x90,0x91,0x04,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x08,
+	0xc9,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x91,0x08,0x7a,0x04,
+	0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x08,0xcd,0x7a,0x04,0x78,0x08,0xe0,
+	0xf6,0xa3,0x08,0xda,0xfa,0x90,0x91,0x0c,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,
+	0xda,0xfa,0x90,0x08,0xd1,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,
+	0x91,0x10,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x91,0x40,0xe4,
+	0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x91,0x44,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,
+	0xa3,0xf0,0x90,0x91,0x48,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x43,0xa0,0x01,
+	0x90,0x08,0xdd,0xe4,0xf0,0xa3,0xf0,0x12,0x06,0x2f,0x90,0x08,0xdd,0x74,0xc8,0xf0,
+	0xa3,0xe4,0xf0,0x12,0x05,0xd0,0x90,0x91,0x80,0x74,0x01,0xf0,0x90,0x08,0xdd,0x74,
+	0xff,0xf0,0xa3,0xe4,0xf0,0x12,0x06,0x2f,0x90,0x08,0xdd,0x74,0x64,0xf0,0xa3,0xe4,
+	0xf0,0x12,0x05,0xd0,0x12,0x07,0xa1,0x90,0x08,0xdd,0x74,0xff,0xf0,0xa3,0xe4,0xf0,
+	0x12,0x06,0x2f,0x12,0x07,0xa1,0x12,0x07,0x28,0x12,0x07,0x28,0x78,0x1b,0xe6,0x60,
+	0x03,0x12,0x00,0x46,0x78,0x1e,0xe6,0x60,0x07,0x78,0x1e,0x76,0x00,0x12,0x08,0x9b,
+	0x80,0xea,0x90,0x91,0x80,0xe4,0xf0,0x22,0x00,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x14,0x70,0x04,
+	0x74,0x00,0x60,0x1e,0x90,0x08,0x68,0xa8,0x83,0xa9,0x82,0x90,0x08,0xa2,0xaa,0x83,
+	0xab,0x82,0x90,0x08,0xb6,0xac,0x83,0xad,0x82,0xc3,0xed,0x9b,0x70,0x28,0xec,0x9a,
+	0x70,0x24,0x74,0x0a,0x70,0x04,0x74,0x00,0x60,0x1b,0x90,0x08,0xc0,0xac,0x83,0xad,
+	0x82,0x90,0x08,0xb6,0xc3,0xed,0x95,0x82,0x70,0x05,0xec,0x95,0x83,0x60,0x06,0xe4,
+	0xf0,0xa3,0x02,0x02,0xe4,0x22,0x88,0x83,0x89,0x82,0xe4,0x93,0xa3,0xa8,0x83,0xa9,
+	0x82,0x8a,0x83,0x8b,0x82,0xf0,0xa3,0xaa,0x83,0xab,0x82,0x02,0x02,0xc9,0x74,0x00,
+	0x60,0x0d,0x90,0x00,0x00,0x79,0x00,0xfa,0xe4,0x93,0xf7,0xa3,0x09,0xda,0xf9,0x74,
+	0x13,0x60,0x08,0x78,0x18,0xfa,0xe4,0xf6,0x08,0xda,0xfc,0x22,0x74,0x00,0x60,0x0d,
+	0x90,0x00,0x00,0x79,0x00,0xfa,0xe4,0x93,0xf7,0xa3,0x09,0xda,0xf9,0x74,0x00,0x60,
+	0x08,0x78,0x00,0xfa,0xe4,0xf6,0x08,0xda,0xfc,0x22,0x74,0x00,0x60,0x35,0xfb,0x90,
+	0x00,0x00,0x74,0x00,0x75,0xf0,0x08,0x84,0x24,0x20,0xf8,0x7a,0x08,0xe5,0xf0,0x60,
+	0x07,0xe6,0x03,0x1a,0xd5,0xf0,0xfb,0xf6,0xeb,0x60,0x0d,0x1b,0xe4,0x93,0xa3,0xa2,
+	0xe0,0xe6,0x13,0xf6,0xda,0xf2,0x80,0x05,0xe6,0x03,0xda,0xfd,0xf6,0x08,0x7a,0x08,
+	0xeb,0x70,0xe5,0x74,0x00,0x60,0x2e,0xfb,0x74,0x00,0x75,0xf0,0x08,0x84,0x24,0x20,
+	0xf8,0x7a,0x08,0xe5,0xf0,0x60,0x07,0xe6,0x03,0x1a,0xd5,0xf0,0xfb,0xf6,0xeb,0x60,
+	0x09,0x1b,0xc3,0xe6,0x13,0xf6,0xda,0xf6,0x80,0x05,0xe6,0x03,0xda,0xfd,0xf6,0x08,
+	0x7a,0x08,0xeb,0x70,0xe9,0x22,0x74,0x00,0x60,0x0d,0x90,0x00,0x00,0x79,0x00,0xfa,
+	0xe4,0x93,0xf7,0xa3,0x09,0xda,0xf9,0x74,0x00,0x60,0x08,0x78,0x00,0xfa,0xe4,0xf6,
+	0x08,0xda,0xfc,0x22,0x90,0x08,0xdd,0xe4,0xf0,0xa3,0xf0,0x90,0x08,0xdd,0xc3,0xe0,
+	0x94,0x40,0xa3,0xe0,0x94,0x00,0x30,0xd2,0x04,0xb2,0xe7,0xd2,0xe0,0x20,0xe7,0x03,
+	0x02,0x04,0xdf,0x90,0x08,0xdd,0xe0,0xf5,0x08,0xa3,0xe0,0xf5,0x09,0x7a,0x0c,0xe5,
+	0x08,0xc3,0x33,0xf5,0x08,0xe5,0x09,0x33,0xf5,0x09,0xda,0xf3,0xe5,0x09,0x33,0xe4,
+	0x50,0x01,0x14,0xf5,0x0a,0xf5,0x0b,0xe5,0x08,0x44,0x00,0xf5,0x08,0xe5,0x09,0x44,
+	0x00,0xf5,0x09,0xe5,0x0a,0x44,0x08,0xf5,0x0a,0xe5,0x0b,0x44,0x00,0xf5,0x0b,0x90,
+	0x08,0xe1,0xe5,0x08,0xf0,0xa3,0xe5,0x09,0xf0,0x90,0x08,0xe1,0xe0,0xf5,0x08,0xa3,
+	0xe0,0xf5,0x09,0x33,0xe4,0x50,0x01,0x14,0xf5,0x0a,0xf5,0x0b,0x90,0x91,0x04,0x7a,
+	0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x08,0xdf,0xe4,0xf0,0xa3,0xf0,
+	0x90,0x08,0xdf,0xc3,0xe0,0x94,0x80,0xa3,0xe0,0x94,0x38,0x30,0xd2,0x04,0xb2,0xe7,
+	0xd2,0xe0,0x30,0xe7,0x5b,0x90,0x91,0x40,0xe0,0x54,0x00,0xf5,0x08,0xa3,0xe0,0x54,
+	0xa0,0xf5,0x09,0xa3,0xe0,0x54,0x00,0xf5,0x0a,0xa3,0xe0,0x54,0x00,0xf5,0x0b,0x78,
+	0x08,0xc3,0xe6,0x94,0x00,0x70,0x10,0x08,0xe6,0x94,0xa0,0x70,0x0a,0x08,0xe6,0x94,
+	0x00,0x70,0x04,0x08,0xe6,0x94,0x00,0x70,0x19,0x90,0x91,0x48,0x7a,0x04,0x78,0x08,
+	0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x08,0xe1,0xe5,0x08,0xf0,0xa3,0xe5,0x09,0xf0,
+	0x80,0x0e,0x90,0x08,0xdf,0xe0,0x24,0x01,0xf0,0xa3,0xe0,0x34,0x00,0xf0,0x80,0x90,
+	0x90,0x08,0xdd,0xe0,0x24,0x01,0xf0,0xa3,0xe0,0x34,0x00,0xf0,0x02,0x03,0xdb,0x12,
+	0x06,0xd6,0x22,0xc0,0xe0,0xc0,0x82,0xc0,0x83,0xc0,0xd0,0xc0,0x08,0xc0,0x09,0xc0,
+	0x0a,0xc0,0x0b,0xc2,0xd3,0xd2,0xd4,0xc2,0xaf,0x53,0xa8,0xfe,0x53,0xe8,0xf9,0x78,
+	0x19,0xe6,0x70,0x03,0x02,0x05,0xac,0x90,0x08,0xbe,0xc3,0xe0,0x94,0x01,0x70,0x04,
+	0xa3,0xe0,0x94,0x00,0x60,0x03,0x02,0x05,0xac,0x78,0x1f,0xe6,0x70,0x37,0x90,0x08,
+	0xa4,0xe0,0xfa,0xa3,0xe0,0x8a,0x82,0xf5,0x83,0xe0,0xf5,0x08,0xa3,0xe0,0xf5,0x09,
+	0x33,0xe4,0x50,0x01,0x14,0xf5,0x0a,0xf5,0x0b,0x90,0x91,0x10,0x7a,0x04,0x78,0x08,
+	0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x91,0x0c,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,
+	0x08,0xda,0xfa,0x80,0x54,0x90,0x08,0xa4,0xe0,0xfa,0xa3,0xe0,0x8a,0x82,0xf5,0x83,
+	0xe0,0xf5,0x08,0xa3,0xe0,0xf5,0x09,0x33,0xe4,0x50,0x01,0x14,0xf5,0x0a,0xf5,0x0b,
+	0x90,0x91,0x0c,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x90,0x08,0xa4,
+	0xe0,0x24,0x02,0xfa,0xa3,0xe0,0x34,0x00,0xf5,0x83,0x8a,0x82,0xe0,0xf5,0x08,0xa3,
+	0xe0,0xf5,0x09,0x33,0xe4,0x50,0x01,0x14,0xf5,0x0a,0xf5,0x0b,0x90,0x91,0x10,0x7a,
+	0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x12,0x08,0x9b,0x90,0x91,0x81,0xe0,
+	0x90,0x00,0x39,0xf0,0x43,0xe8,0x06,0x43,0xf8,0x04,0x43,0xa8,0x01,0xd2,0xaf,0xd0,
+	0x0b,0xd0,0x0a,0xd0,0x09,0xd0,0x08,0xd0,0xd0,0xd0,0x83,0xd0,0x82,0xd0,0xe0,0x32,
+	0x90,0x08,0xdf,0xe4,0xf0,0xa3,0xf0,0x90,0x08,0xdf,0xc3,0xe0,0x94,0xe8,0xa3,0xe0,
+	0x94,0x03,0x30,0xd2,0x04,0xb2,0xe7,0xd2,0xe0,0x30,0xe7,0x42,0x90,0x08,0xe1,0xe4,
+	0xf0,0xa3,0xf0,0x90,0x08,0xdd,0xe0,0xf5,0x08,0xa3,0xe0,0xf5,0x09,0x90,0x08,0xe1,
+	0xc3,0xe0,0x95,0x08,0xa3,0xe0,0x95,0x09,0x30,0xd2,0x04,0xb2,0xe7,0xd2,0xe0,0x30,
+	0xe7,0x0e,0x90,0x08,0xe1,0xe0,0x24,0x01,0xf0,0xa3,0xe0,0x34,0x00,0xf0,0x80,0xd3,
+	0x90,0x08,0xdf,0xe0,0x24,0x01,0xf0,0xa3,0xe0,0x34,0x00,0xf0,0x80,0xa9,0x22,0x90,
+	0x08,0xe1,0xe4,0xf0,0xa3,0x74,0x30,0xf0,0x90,0x08,0xdf,0xe4,0xf0,0xa3,0xf0,0x90,
+	0x08,0xdf,0xc3,0xe0,0x94,0x00,0xa3,0xe0,0x94,0x06,0x30,0xd2,0x04,0xb2,0xe7,0xd2,
+	0xe0,0x30,0xe7,0x2e,0x90,0x08,0xdd,0xe0,0x90,0x08,0xe1,0xc0,0xe0,0xe0,0xfa,0xa3,
+	0xe0,0x8a,0x82,0xf5,0x83,0xd0,0xe0,0xf0,0x90,0x08,0xe1,0xe0,0x24,0x01,0xf0,0xa3,
+	0xe0,0x34,0x00,0xf0,0x90,0x08,0xdf,0xe0,0x24,0x01,0xf0,0xa3,0xe0,0x34,0x00,0xf0,
+	0x80,0xbd,0x22,0xc0,0xe0,0xc0,0x82,0xc0,0x83,0xc0,0xd0,0xc0,0x08,0xc0,0x09,0xc0,
+	0x0a,0xc0,0x0b,0xc2,0xd3,0xd2,0xd4,0xc2,0xaf,0x53,0xa8,0xfe,0x53,0xe8,0xf9,0x78,
+	0x1b,0x76,0x01,0x90,0x90,0x0c,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,
+	0x90,0x00,0x35,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x43,0xe8,0x06,
+	0x43,0xa8,0x01,0xd2,0xaf,0xd0,0x0b,0xd0,0x0a,0xd0,0x09,0xd0,0x08,0xd0,0xd0,0xd0,
+	0x83,0xd0,0x82,0xd0,0xe0,0x32,0x90,0x00,0x3e,0xe4,0xf0,0xa3,0xf0,0x90,0x00,0x3e,
+	0xc3,0xe0,0x94,0x80,0xa3,0xe0,0x94,0x38,0x30,0xd2,0x04,0xb2,0xe7,0xd2,0xe0,0x30,
+	0xe7,0x35,0x90,0x91,0x40,0xe0,0x54,0x00,0xf5,0x08,0xa3,0xe0,0x54,0x60,0xf5,0x09,
+	0xa3,0xe0,0x54,0x00,0xf5,0x0a,0xa3,0xe0,0x54,0x00,0xf5,0x0b,0x78,0x08,0x7a,0x04,
+	0xe6,0x70,0x03,0x08,0xda,0xfa,0x70,0x01,0x22,0x90,0x00,0x3e,0xe0,0x24,0x01,0xf0,
+	0xa3,0xe0,0x34,0x00,0xf0,0x80,0xb6,0x22,0x90,0x3f,0xf0,0x74,0x0f,0xf0,0xa3,0xe4,
+	0xf0,0x90,0x3f,0xf4,0xe4,0xf0,0xa3,0x74,0x60,0xf0,0xa3,0x74,0x0a,0xf0,0xa3,0xe4,
+	0xf0,0x90,0x3f,0xf8,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x12,0x00,0x46,0x90,
+	0x3f,0xf8,0xe0,0x54,0xf0,0xf5,0x08,0x7a,0x03,0x78,0x08,0xa3,0x08,0xe0,0x54,0x00,
+	0xf6,0xda,0xf8,0x78,0x08,0x7a,0x04,0xe6,0x70,0x03,0x08,0xda,0xfa,0x60,0x01,0x22,
+	0x80,0xb6,0x22,0xc0,0xe0,0xc0,0x82,0xc0,0x83,0xc0,0xd0,0xc2,0xd3,0xd2,0xd4,0xc2,
+	0xaf,0x53,0xa8,0xfe,0x53,0xe8,0xf9,0x90,0x08,0xbe,0x74,0x01,0xf0,0xa3,0xe4,0xf0,
+	0x43,0xe8,0x06,0x43,0xa8,0x01,0xd2,0xaf,0xd0,0xd0,0xd0,0x83,0xd0,0x82,0xd0,0xe0,
+	0x32,0x90,0x91,0x40,0xe0,0x54,0x00,0xf5,0x08,0xa3,0xe0,0x54,0x80,0xf5,0x09,0xa3,
+	0xe0,0x54,0x00,0xf5,0x0a,0xa3,0xe0,0x54,0x00,0xf5,0x0b,0x78,0x08,0x7a,0x04,0xe6,
+	0x70,0x03,0x08,0xda,0xfa,0x60,0x01,0x22,0x80,0xd7,0x22,0x90,0x08,0xbe,0xe4,0xf0,
+	0xa3,0xf0,0x90,0x08,0xb8,0xe4,0xf0,0xa3,0xf0,0x90,0x08,0xb6,0xe4,0xf0,0xa3,0xf0,
+	0x78,0x1e,0x76,0x00,0x75,0xa8,0x81,0x75,0xb8,0x01,0x75,0xe8,0x06,0x75,0xf8,0x04,
+	0xd2,0xaf,0x22,0x90,0x91,0x44,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,
+	0x90,0x3f,0xf4,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x12,0x06,0xd6,
+	0x90,0x3f,0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,0x22,0x90,0x3f,0xf4,0x7a,0x04,0x78,
+	0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x91,0x08,0x7a,0x04,0x78,0x08,0xe6,0xf0,
+	0xa3,0x08,0xda,0xfa,0x12,0x06,0xd6,0x90,0x3f,0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,
+	0x22,0x90,0x91,0x48,0x7a,0x04,0x78,0x08,0xe0,0xf6,0xa3,0x08,0xda,0xfa,0x90,0x3f,
+	0xf4,0x7a,0x04,0x78,0x08,0xe6,0xf0,0xa3,0x08,0xda,0xfa,0x12,0x06,0xd6,0x90,0x3f,
+	0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,0x22,0x00,0x30,0x00,0x36,0x41,0x91,0x45,0x91,
+	0xf4,0x3f,0xf6,0x3f,0xf4,0x3f,0xf5,0x3f,0xf6,0x3f,0xf7,0x3f,0x90,0x3f,0xf4,0x78,
+	0x1f,0xe0,0xf6,0x90,0x3f,0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,0x22,0x78,0x1e,0x76,
+	0x01,0x90,0x3f,0xf2,0x74,0x01,0xf0,0xa3,0xe4,0xf0,0x22,0x53,0xa0,0xfe,0x43,0xa0,
+	0x01,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+
+void init_8051(void)
+{
+	int	i,j;
+
+	*(volatile unsigned long *)(VOYAGER_8051_RESET) = 0x0000;
+	*(volatile unsigned long *)(VOYAGER_8051_SELECT) = 0x0011;
+	//8051 program write
+	for(i=0;i<sizeof(code_8051);i++) {
+		*(volatile unsigned char *)(VOYAGER_8051_BASE+i) = code_8051[i];
+	}
+	*(volatile unsigned long *)(VOYAGER_8051_RESET) = 0x0001;
+	for(i=0;i<DELAY_8051;i++) {
+		for(j=0;j<200;j++);
+	}
+}
+
+
+int command_8051(int com,int *data,int *data2)
+{
+	int	ret,i,j;
+
+	j = 0;
+	do {
+		*(volatile unsigned short *)(VOYAGER_8051_COMMAND) = com;
+		*(volatile unsigned short *)(VOYAGER_8051_STATUS) = 0;
+		*(volatile unsigned long *)(VOYAGER_8051_DATA) = *data;
+		*(volatile unsigned long *)(VOYAGER_8051_DATA+4) = *data2;
+		*(volatile unsigned long *)(VOYAGER_8051_CPU_INT) = 0xff;
+		for(i=0;i<DELAY_8051;i++) {
+			ret = *(volatile unsigned short *)(VOYAGER_8051_STATUS);
+			if(ret != 0) {
+				break;
+			}
+		}
+		j++;
+		if(j > 100) {
+			*data = 0;
+			*data2 = 0;
+			printk("8051 command process error\n");
+			return(-1);
+		}
+	} while(ret == 0);
+	*data = *(volatile unsigned long *)(VOYAGER_8051_DATA);
+	*data2 = *(volatile unsigned long *)(VOYAGER_8051_DATA+4);
+
+	return(ret);
+}
+
+EXPORT_SYMBOL(init_8051);
+EXPORT_SYMBOL(command_8051);
+
diff -Naur linux-2.6.17.8/sound/oss/voyagergx_sound.c linux-2.6.17.8-sh/sound/oss/voyagergx_sound.c
--- linux-2.6.17.8/sound/oss/voyagergx_sound.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/voyagergx_sound.c	2006-08-23 13:29:28.175370000 +0100
@@ -0,0 +1,1122 @@
+/*
+ *  linux/drivers/sound/voyagergx_sound.c -- voyager sound driver
+ *
+ *     Copyright (C) 2003 Renesas Technology Sales Co.,Ltd.
+ *     Copyright (C) 2003 Atom Create Engineering Co.,Ltd.
+ *     Anthor : Atom Create Engineering Co.,Ltd.
+ *                   Kenichi Sakuma
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ * 1.00
+ *  - initial version (ks)
+ * 1.01
+ *  - Kernel 2.6 correspondence
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/sound.h>
+#include <linux/slab.h>
+#include <linux/soundcard.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/ac97_codec.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+#include <asm/voyagergx.h>
+#include <asm/irq.h>
+#include "voyagergx_sound.h"
+
+static DEFINE_SPINLOCK(voyagergx_sound_lock);
+
+/* --------------------------------------------------------------------- */
+#undef OSS_DOCUMENTED_MIXER_SEMANTICS
+
+#define VOYAGERGX_MODULE_NAME "Voyagergx audio"
+#define PFX VOYAGERGX_MODULE_NAME
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
+//#define info(format, arg...) printk(": " format "\n" , ## arg)
+//#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
+
+// buffer size
+#define	VOYAGER_SOUND_SIZE	0x100000
+// data buffer 1 - vram upper
+#define	VOYAGER_SOUND_BUF1	0xb0200000
+// data buffer 2 - vram upper
+#define	VOYAGER_SOUND_BUF2	VOYAGER_SOUND_BUF1+VOYAGER_SOUND_SIZE
+//WAIT TIME OUT
+//#define	WAIT_TIMEOUT	((VOYAGER_SOUND_SIZE / 48000) * HZ + 10)
+#define	WAIT_TIMEOUT	1100
+
+DECLARE_WAIT_QUEUE_HEAD(int_wq);
+
+/* Boot options */
+static int      vra = 0;	// 0 = no VRA, 1 = use VRA if codec supports it
+MODULE_PARM(vra, "i");
+MODULE_PARM_DESC(vra, "if 1 use VRA if codec supports it");
+
+struct voyager_setting {
+	int             ch;
+	int		fmt;
+	int		rate;
+} setting;
+
+int	init_8051(void);
+int	command_8051(int com,int *data,int *data2);
+
+// DMA used channel - set DMA used channel(fixed at 0)
+static	int	sh7751_dmasound_play_irq = 0;
+// buffer 1 used flag - transfersize is set when used
+static	int	buff_flg1 = 0;
+// buffer 2 used flag - transfersize is set when used
+static	int	buff_flg2 = 0;
+// buffer judgement flag - which buffer is used by DMA
+static	int	proc_flg = 0;
+// first judgement flag - data transfer is first time?
+static	int	first_flg = 0;
+// last judgement flag - data transfer is last?
+static	int	last_flg = 0;
+// interrupt flag - 0 cleard if interrupt occured
+static	int	wari_flg;
+// break flag - to cancel or done of sound play
+static	int	break_flg;
+// play cancel flag - performance problem or end of play
+static	int	abnml_flg;
+// number of write buffer - which buffer will be used
+static	int	next_write;
+// remained buffer size
+static	int	next_size;
+// DMA transfer size
+static	int	dma_req[2];
+// DMA address table - address per channel
+static	int	dma_tbl[] = {
+	0xffa00000, 0xffa00010, 0xffa00020, 0xffa00030,
+	0xffa00040, 0xffa00050, 0xffa00060, 0xffa00070
+};
+
+/* --------------------------------------------------------------------- */
+// DMA start
+// enable selected dma channel
+void	dma2_start(int irq)
+{
+int	base;
+
+	base = dma_tbl[irq];
+	*(volatile unsigned long *)(base + 0xc) |= 0x00000001;
+}
+
+
+// DMA stop
+// disable selected dma channel
+void	dma2_stop(int irq)
+{
+int	base;
+
+	base = dma_tbl[irq];
+	*(volatile unsigned long *)(base + 0xc) &= 0xfffffffc;
+}
+
+
+// prepare DMA transfer
+// set transfer src address and transfer size
+void	dma2_queue_buffer(int irq,int src, int cnt)
+{
+int	base;
+
+	base = dma_tbl[irq];
+	*(volatile unsigned long *)(base + 0x0) = src & 0x1fffffff;
+	// change transfer unit for mono or stereo
+	if(setting.ch == 1) {
+		// 4 byte for stereo
+		*(volatile unsigned long *)(base + 0x8) = cnt;
+	}
+	else {
+		// 2 byte for mono
+		*(volatile unsigned long *)(base + 0x8) = cnt * 2;
+	}
+}
+
+
+// DMA registration
+// register DMA interrupt
+int	request_dma2(int irq,char *str,irqreturn_t (*callback)(int, void *, struct pt_regs *))
+{
+int	ret;
+
+	make_ipr_irq(DMTE0_IRQ+irq, DMA_IPR_ADDR, DMA_IPR_POS,DMA_PRIORITY);
+	ret = request_irq(DMTE0_IRQ+irq,callback,SA_INTERRUPT,str,0);
+	return(ret);
+}
+
+
+// preparation for DMA use
+// set transfer dst address and transfer unit, transfer condition, etc
+void	dma2_set_device(int irq)
+{
+int	base;
+
+	//DMA initialize
+	base = dma_tbl[irq];
+	*(volatile unsigned long *)(base + 0x0) = 0;
+	*(volatile unsigned long *)(base + 0x4) = VOYAGER_8051_FIFO & 0x1fffffff;
+	*(volatile unsigned long *)(base + 0x8) = 0;
+	// change transfer unit for mono or stereo
+	if(setting.ch == 1) {
+		// 4 byte for stereo
+		*(volatile unsigned long *)(base + 0xc) = 0xb1034;
+	}
+	else {
+		// 2 byte for mono
+		*(volatile unsigned long *)(base + 0xc) = 0xb1024;
+	}
+	*(volatile unsigned long *)(base + 0x40) = 0x01;
+}
+
+/* --------------------------------------------------------------------- */
+
+
+// cancel sound play(done)
+//
+static	void	voy_break(void)
+{
+int	data,data2;
+
+	// cancel for 8051
+	data = 0x00;
+	command_8051(0x07,&data,&data2);
+	// stop DMA
+	dma2_stop(sh7751_dmasound_play_irq);
+	break_flg = 1;
+}
+/* --------------------------------------------------------------------- */
+// ISR for DMA
+// called after DMA transfer is done
+// next request is issued here in the case of sequential transfer
+static	irqreturn_t do_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	spin_lock_irq(&voyagergx_sound_lock);
+
+	// stop DMA
+	dma2_stop(sh7751_dmasound_play_irq);
+	// clear interrupt flag
+	wari_flg = 0;
+	// play of buffer 1 is done?
+	if((proc_flg == 1)&&(buff_flg1 == 1)) {
+		// buffer 1 is free
+		buff_flg1 = 0;
+		// buffer 2 is being played
+		proc_flg = 2;
+		// next data is ready?
+		if(buff_flg2 == 1) {
+			// request DMA
+			dma2_queue_buffer(sh7751_dmasound_play_irq,VOYAGER_SOUND_BUF2,dma_req[1]);
+			dma2_start(sh7751_dmasound_play_irq);
+		}
+		else {
+			// set stop flag if no data
+			abnml_flg = 1;
+		}
+	}
+	// play of buffer 2 is done?
+	else if((proc_flg == 2)&&(buff_flg2 == 1)) {
+		// buffer 2 is free
+		buff_flg2 = 0;
+		// buffer 1 is being played
+		proc_flg = 1;
+		// next data is ready?
+		if(buff_flg1 == 1) {
+			// request DMA
+			dma2_queue_buffer(sh7751_dmasound_play_irq,VOYAGER_SOUND_BUF1,dma_req[0]);
+			dma2_start(sh7751_dmasound_play_irq);
+		}
+		else {
+			// set stop flag if no data
+			abnml_flg = 1;
+		}
+	}
+	// play remained data(last data or small one)
+	else {
+		//last transfer is done
+		last_flg = 0;
+	}
+	//wake up sleeping write routine
+	wake_up_interruptible(&int_wq);
+	spin_unlock_irq(&voyagergx_sound_lock);
+
+	return IRQ_HANDLED;
+}
+
+/* --------------------------------------------------------------------- */
+// 32 bit memory read
+static inline u32 voyager_readl(u32 addr)
+{
+	return *(volatile unsigned long *)(addr);
+}
+
+// 32 bit memory write
+static inline void voyager_writel(u32 val,u32 addr)
+{
+	*(volatile unsigned long *)(addr) = val;
+}
+
+/* --------------------------------------------------------------------- */
+
+struct voyagergx_state {
+	/* soundcore stuff */
+	int             dev_audio;
+
+	struct ac97_codec codec;
+	unsigned        codec_base_caps;	// AC'97 reg 00h, "Reset Register"
+	unsigned        codec_ext_caps;		// AC'97 reg 28h, "Extended Audio ID"
+	int             no_vra;			// do not use VRA
+
+	spinlock_t      lock;
+	struct semaphore open_sem;
+	mode_t          open_mode;
+
+} voyagergx_state;
+
+
+/* --------------------------------------------------------------------- */
+// read codec
+static	u16 rdcodec(struct ac97_codec *codec, u8 addr)
+{
+	u32             cmd,ret;
+	u16             data;
+
+
+	// set register address for reading
+	cmd = (u32) (addr & AC97C_INDEX_MASK) << 12;
+	cmd |= AC97C_READ;	// read command
+	command_8051(1,&cmd,&ret);
+	mdelay(1);
+	// read register
+	command_8051(4,&cmd,&ret);
+	mdelay(1);
+	// convert it as it was shifted
+	data = (cmd >> 4) & 0xffff;
+	return data;
+}
+
+
+// write codec
+static	void wrcodec(struct ac97_codec *codec, u8 addr, u16 data)
+{
+	u32             cmd,ret;
+	int	i;
+
+	//  reset?
+	if(addr == 0) {
+		// try again if failed
+		for(i=0;i<10;i++) {
+			// set write data
+			cmd = (u32) data << AC97C_WD_BIT;	// OR in the data word
+			command_8051(3,&cmd,&ret);
+			// set write address
+			cmd = (u32) (addr & AC97C_INDEX_MASK) << 12;
+			cmd &= ~AC97C_READ;	// write command
+			command_8051(1,&cmd,&ret);
+			// check whether reset succeed
+			ret = rdcodec(codec,0);
+			if((ret & 0x8000) == 0) {
+				break;
+			}
+		}
+	}
+	// instead of reset
+	else {
+		// set write data
+		cmd = (u32) data << AC97C_WD_BIT;	// OR in the data word
+		command_8051(3,&cmd,&ret);
+		// set write address
+		cmd = (u32) (addr & AC97C_INDEX_MASK) << 12;
+		cmd &= ~AC97C_READ;	// write command
+		command_8051(1,&cmd,&ret);
+		mdelay(1);
+		// read variables of volume for preservation
+		rdcodec(codec,2);
+		rdcodec(codec,24);
+		rdcodec(codec,22);
+		rdcodec(codec,0x2c);
+	}
+}
+
+/* --------------------------------------------------------------------- */
+
+static loff_t voyagergx_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+
+static int voyagergx_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &voyagergx_state;
+	return 0;
+}
+
+static int voyagergx_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
+                        unsigned long arg)
+{
+	return codec->mixer_ioctl(codec, cmd, arg);
+}
+
+static int voyagergx_ioctl_mixdev(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
+{
+	struct voyagergx_state *s = (struct voyagergx_state *)file->private_data;
+	struct ac97_codec *codec = &s->codec;
+
+	return mixdev_ioctl(codec, cmd, arg);
+}
+
+static /*const */ struct file_operations voyagergx_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:voyagergx_llseek,
+	ioctl:voyagergx_ioctl_mixdev,
+	open:voyagergx_open_mixdev,
+	release:voyagergx_release_mixdev,
+};
+
+/* --------------------------------------------------------------------- */
+// read routine
+// record(sampling) should be used originally
+// do nothing without record(sampling) now
+static ssize_t voyagergx_read(struct file *file, char *buffer,
+			   size_t count, loff_t *ppos)
+{
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+	return 0;
+}
+
+// write routine
+// used for sound play
+// sound play is being done by 8051 and data itsself is transfered by DMA
+// the preparation for the above is done here
+static ssize_t voyagergx_write(struct file *file, const char *buffer,
+	     		    size_t count, loff_t * ppos)
+{
+int	i,data,data2,data_size;
+int	ret;
+
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+	// exit if break flag is set
+	if(break_flg) {
+		return count;
+	}
+	// wait until buffers are not free
+	if((buff_flg1 == 1)&&(buff_flg2 == 1)) {
+		wari_flg = 1;
+		i = 0;
+		while(wari_flg) {
+			// sound play already done?
+			if(abnml_flg) {
+				break;
+			}
+			// sleep until buffer is not full
+			ret = interruptible_sleep_on_timeout(&int_wq,WAIT_TIMEOUT);
+			if(ret == 0) {
+				break;
+			}
+			// check Ctrl-C
+			if (signal_pending(current)) {
+				voy_break();
+				return -ERESTARTSYS;
+			}
+			i++;
+			if(i > 10000000) {
+				printk("DMA endcheck-1 error\n");
+				voy_break();
+				return -EFAULT;
+			}
+		}
+	}
+	data_size = count;
+	// multiple transfer
+	if(data_size >= next_size) {
+		// until play data is larger than buffer
+		while(data_size >= next_size) {
+			// buffer 1 is free
+			if((next_write == 1)&&(buff_flg1 == 0)) {
+				// copy data to VRAM
+				copy_from_user((long *)(VOYAGER_SOUND_BUF1+VOYAGER_SOUND_SIZE-next_size),
+					(long *)buffer,next_size);
+				// buffer1 used
+				buff_flg1 = 1;
+				next_write = 2;
+				// update pointer
+				buffer += next_size;
+				// decrease remained play data
+				data_size -= next_size;
+				// set remained buffer size
+				next_size = VOYAGER_SOUND_SIZE;
+				// kick DMA again when data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+							VOYAGER_SOUND_BUF1,dma_req[0]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+			// buffer 2 is free
+			else if((next_write == 2)&&(buff_flg2 == 0)) {
+				// copy data to VRAM
+				copy_from_user((long *)(VOYAGER_SOUND_BUF2+VOYAGER_SOUND_SIZE-next_size),
+					(long *)buffer,next_size);
+				//buffer 2 used
+				buff_flg2 = 1;
+				next_write = 1;
+				// update pointer
+				buffer += next_size;
+				// decrease remained play data
+				data_size -= next_size;
+				// set remained buffer size
+				next_size = VOYAGER_SOUND_SIZE;
+				// kick DMA again when data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+						VOYAGER_SOUND_BUF2,dma_req[1]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+			// first time?
+			if(first_flg == 0) {
+				//buffer 1 is full?(buffer 1 is used at first)
+				if(buff_flg1 == 1) {
+					// request DMA
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+       							VOYAGER_SOUND_BUF1,
+       							VOYAGER_SOUND_SIZE/4);
+					// start play on 8051
+					data = 0x01;
+					command_8051(0x07,&data,&data2);
+					// start DMA transfer
+					dma2_start(sh7751_dmasound_play_irq);
+					// set first flag
+					first_flg = 1;
+				}
+			}
+			// wait until 2 buffer are full
+			if((buff_flg1 == 1)&&(buff_flg2 == 1)) {
+				wari_flg = 1;
+				i = 0;
+				while(wari_flg) {
+					// sound play already done?
+					if(abnml_flg) {
+						break;
+					}
+					// sleep until buffer is not full
+					ret = interruptible_sleep_on_timeout(&int_wq,WAIT_TIMEOUT);
+					if(ret == 0) {
+						break;
+					}
+					// check Ctrl-C
+					if (signal_pending(current)) {
+						voy_break();
+						return -ERESTARTSYS;
+					}
+					i++;
+					if(i > 10000000) {
+						printk("DMA endcheck-2 error\n");
+						voy_break();
+						return -EFAULT;
+					}
+				}
+			}
+		}
+	}
+	// play data size is less than remained buffer size
+	if((data_size != 0)&&(data_size < next_size)) {
+		// buffer 1 is free
+		if((next_write == 1)&&(buff_flg1 == 0)) {
+			// copy data to VRAM
+			copy_from_user((long *)(VOYAGER_SOUND_BUF1+VOYAGER_SOUND_SIZE-next_size),
+				(void *)buffer,data_size);
+			// reset buffer remain size
+			next_size -= data_size;
+			// buffer is full?
+			if(next_size == 0) {
+				//buffer1 used
+				buff_flg1 = 1;
+				next_write = 2;
+				// reset buffer remain size
+				next_size = VOYAGER_SOUND_SIZE;
+				// kick DMA again when data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+						VOYAGER_SOUND_BUF1,dma_req[0]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+		}
+		//buffer 2 is free
+		else if((next_write == 2)&&(buff_flg2 == 0)) {
+			// copy data to VRAM
+			copy_from_user((long *)(VOYAGER_SOUND_BUF2+VOYAGER_SOUND_SIZE-next_size),
+				(void *)buffer,data_size);
+			// reset buffer remained size
+			next_size -= data_size;
+			// buffer is full?
+			if(next_size == 0) {
+				//buffer2 used
+				buff_flg2 = 1;
+				next_write = 1;
+				// reset buffer remained size
+				next_size = VOYAGER_SOUND_SIZE;
+				// kick DMA again when data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+						VOYAGER_SOUND_BUF2,dma_req[1]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+		}
+	}
+	// is it first time?
+	if(first_flg == 0) {
+		// buffer 1 is full(buffer1 is used first at first time)
+		if(buff_flg1 == 1) {
+			// DMA request
+			dma2_queue_buffer(sh7751_dmasound_play_irq,
+       					VOYAGER_SOUND_BUF1,
+       					VOYAGER_SOUND_SIZE/4);
+			// start play on 8051
+			data = 0x01;
+			command_8051(0x07,&data,&data2);
+			dma2_start(sh7751_dmasound_play_irq);
+			// set first flag
+			first_flg = 1;
+		}
+	}
+	return(count);
+}
+
+// polling - not used
+static unsigned int voyagergx_poll(struct file *file,
+				struct poll_table_struct *wait)
+{
+	return 0;
+}
+
+// mmap - not used
+static int voyagergx_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return 0;
+}
+
+// I/O control
+// operation for change data type and volume
+static int voyagergx_ioctl(struct inode *inode, struct file *file,
+                        unsigned int cmd, unsigned long arg)
+{
+	struct voyagergx_state *s = (struct voyagergx_state *)file->private_data;
+	int	data,data2,rate;
+
+
+	switch (cmd) {
+//Sound Stop control
+	case -1:
+		voy_break();
+		return 0;
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_SYNC:
+		return 0;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		return 0;
+
+	case SNDCTL_DSP_SPEED:		// set sampling rate
+		if((*(int *)arg <= 0xbb80)&&(*(int *)arg >= 0x1b80)) {
+			setting.rate = *(int *)arg;
+		}
+		if(setting.ch == 0) {
+			rate = setting.rate / 2;
+		}
+		else {
+			rate = setting.rate;
+		}
+		return setting.rate;
+
+	case SNDCTL_DSP_STEREO:		//set # of play channel(stereo or mono)
+		setting.ch = *(int *)arg;
+		// set # of channel for 8051
+		data = setting.ch;
+		command_8051(0x05,&data,&data2);
+        	dma2_set_device(sh7751_dmasound_play_irq);
+		return(setting.ch);
+
+	case SNDCTL_DSP_CHANNELS:
+		return 0;
+
+	case SNDCTL_DSP_GETFMTS:	// set play data format(8bit or 16bit)
+		if(setting.fmt == 16) {
+			arg = (unsigned long)AFMT_S16_LE;
+		}
+		else {
+			arg = (unsigned long)AFMT_U8;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SETFMT:		// set play data format(8bit or 16bit)
+		if(*(int *)arg == AFMT_S16_LE) {
+			setting.fmt = 16;
+		}
+		else {
+			setting.fmt = 8;
+		}
+		return 0;
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		return 0;
+
+	case SNDCTL_DSP_SETTRIGGER:
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+		return 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		return 0;
+
+	case SNDCTL_DSP_NONBLOCK:
+		return 0;
+
+	case SNDCTL_DSP_GETODELAY:
+		return 0;
+
+	case SNDCTL_DSP_GETIPTR:
+		return 0;
+
+	case SNDCTL_DSP_GETOPTR:
+		return 0;
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		return 0;
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		return 0;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		return 0;
+
+	case SOUND_PCM_READ_RATE:
+		return 0;
+
+	case SOUND_PCM_READ_CHANNELS:
+		return 0;
+
+	case SOUND_PCM_READ_BITS:
+		return 0;
+
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+	}
+
+	return mixdev_ioctl(&s->codec, cmd, arg);
+}
+
+// open
+// flag initialization
+// stop 8051 to play(it will be started by first write)
+static int  voyagergx_open(struct inode *inode, struct file *file)
+{
+struct voyagergx_state *s = &voyagergx_state;
+int	data,data2;
+
+	file->private_data = s;
+
+	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
+	//head transferflag clear
+	first_flg = 0;
+	//last transfer flag clear
+	last_flg = 0;
+	//buffer flag clear
+	buff_flg1 = buff_flg2 = 0;
+	// buffer 1 is first
+	proc_flg = 1;
+	// reset buffer remained size
+	next_size = VOYAGER_SOUND_SIZE;
+	// initialize DMA transfer size
+	dma_req[0] = VOYAGER_SOUND_SIZE/4;
+	dma_req[1] = VOYAGER_SOUND_SIZE/4;
+	// clear break flag
+	break_flg = 0;
+	// clear cancel play flag
+	abnml_flg = 0;
+	// initialize # of write buffer
+	next_write = 1;
+	// start play on 8051
+	data = 0x00;
+	command_8051(0x07,&data,&data2);
+
+	return 0;
+}
+
+// release(close)
+// play again if data remains in buffer
+// stop DMA
+// stop 8051
+static int voyagergx_release(struct inode *inode, struct file *file)
+{
+int	data,data2,i;
+int	ret;
+
+	// stop if break flag is set
+	if(break_flg) {
+		return 0;
+	}
+	// wait until buffer is not full
+	if((buff_flg1 == 1)&&(buff_flg2 == 1)) {
+		wari_flg = 1;
+		i = 0;
+		while(wari_flg) {
+			// sound play already done?
+			if(abnml_flg) {
+				break;
+			}
+			// sleep until buffer is not full
+			ret = interruptible_sleep_on_timeout(&int_wq,WAIT_TIMEOUT);
+			if(ret == 0) {
+				break;
+			}
+			// check Ctrl-C
+			if (signal_pending(current)) {
+				voy_break();
+				return -ERESTARTSYS;
+			}
+			i++;
+			if(i > 10000000) {
+				printk("DMA endcheck-3 error\n");
+				voy_break();
+				return -EFAULT;
+			}
+		}
+	}
+	// exit if size is less than 4
+	if((VOYAGER_SOUND_SIZE - next_size) < 4) {
+		voy_break();
+		return 0;
+	}
+	// buffer is not full?
+	if(next_size != 0) {
+
+		// first time?
+		if(first_flg == 0) {
+			// no data
+			if(next_size == VOYAGER_SOUND_SIZE) {
+				// exit
+				voy_break();
+				return 0;
+			}
+			// buffer 1 used?
+			if(proc_flg == 1) {
+      				dma2_queue_buffer(sh7751_dmasound_play_irq,
+       						VOYAGER_SOUND_BUF1,
+       						(VOYAGER_SOUND_SIZE-next_size)/4);
+				// set last judgement flag
+				last_flg = 1;
+			}
+			// start play on 8051
+			data = 0x01;
+			command_8051(0x07,&data,&data2);
+			dma2_start(sh7751_dmasound_play_irq);
+		}
+		// sound play in case that data is less than a buffer
+		else {
+			if(proc_flg == 2) {
+				dma_req[0] = (VOYAGER_SOUND_SIZE-next_size)/4;
+				buff_flg1 = 1;
+				// set last judgement flag
+				last_flg = 1;
+				// kick dma again if data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+						VOYAGER_SOUND_BUF1,dma_req[0]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+			else {
+				// DMA request
+				dma_req[1] = (VOYAGER_SOUND_SIZE-next_size)/4;
+				buff_flg2 = 1;
+				// set last  judgement flag
+				last_flg = 1;
+				// kick dma again if data is not enough
+				if(abnml_flg == 1) {
+					dma2_queue_buffer(sh7751_dmasound_play_irq,
+						VOYAGER_SOUND_BUF2,dma_req[1]);
+					dma2_start(sh7751_dmasound_play_irq);
+					abnml_flg = 0;
+				}
+			}
+		}
+	}
+	// wait for all sound play(transfer)
+	while(1) {
+		if(abnml_flg) {
+			break;
+		}
+		// exit if last judgement flag is 0
+		if(last_flg == 0) {
+			break;
+		}
+		wari_flg = 1;
+		i = 0;
+		while(wari_flg) {
+			// sound play already done?
+			if(abnml_flg) {
+				break;
+			}
+			// exit if last judgement flag is 0
+			if(last_flg == 0) {
+				break;
+			}
+			// sleep until buffer is not full
+			ret = interruptible_sleep_on_timeout(&int_wq,WAIT_TIMEOUT);
+			if(ret == 0) {
+				voy_break();
+				return -EFAULT;
+			}
+			// check Ctrl-C
+			if (signal_pending(current)) {
+				voy_break();
+				return -ERESTARTSYS;
+			}
+			i++;
+			if(i > 10000000) {
+				printk("DMA endcheck-last error\n");
+				voy_break();
+				return -EFAULT;
+			}
+		}
+	}
+	// end
+	voy_break();
+
+	return 0;
+}
+
+static /*const */ struct file_operations voyagergx_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		voyagergx_llseek,
+	read:		voyagergx_read,
+	write:		voyagergx_write,
+	poll:		voyagergx_poll,
+	ioctl:		voyagergx_ioctl,
+	mmap:		voyagergx_mmap,
+	open:		voyagergx_open,
+	release:	voyagergx_release,
+};
+
+
+/* --------------------------------------------------------------------- */
+MODULE_AUTHOR("Atom Create Engineering Co.,Ltd.");
+MODULE_DESCRIPTION("DSP audio and mixer driver for Silicon Motion VoyagerGX audio device");
+
+/* --------------------------------------------------------------------- */
+
+// probe
+// driver initialization
+// codec initialization
+// check ac97 chip#
+static int __devinit voyagergx_probe(void)
+{
+struct voyagergx_state *s = &voyagergx_state;
+int             val;
+
+	memset(s, 0, sizeof(struct voyagergx_state));
+
+	init_MUTEX(&s->open_sem);
+	s->codec.private_data = s;
+	s->codec.id = 0;
+	s->codec.codec_read = rdcodec;
+	s->codec.codec_write = wrcodec;
+	s->codec.codec_wait = NULL;
+
+	/* register devices */
+
+	if ((s->dev_audio = register_sound_dsp(&voyagergx_audio_fops, -1)) < 0)
+		goto err_dev1;
+	if ((s->codec.dev_mixer =
+	     register_sound_mixer(&voyagergx_mixer_fops, -1)) < 0)
+		goto err_dev2;
+
+
+	/* codec init */
+	if (!ac97_probe_codec(&s->codec))
+		goto err_dev3;
+
+	s->codec_base_caps = rdcodec(&s->codec, AC97_RESET);
+	s->codec_ext_caps = rdcodec(&s->codec, AC97_EXTENDED_ID);
+	info("AC'97 Base/Extended ID = %04x/%04x",
+	     s->codec_base_caps, s->codec_ext_caps);
+
+	s->codec.supported_mixers |= SOUND_MASK_ALTPCM;
+	val = 0x4343;
+	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_ALTPCM,
+		     (unsigned long) &val);
+
+	if (!(s->codec_ext_caps & AC97_EXTID_VRA)) {
+		// codec does not support VRA
+		s->no_vra = 1;
+	} else if (!vra) {
+		// Boot option says disable VRA
+		u16 ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
+		wrcodec(&s->codec, AC97_EXTENDED_STATUS,
+			ac97_extstat & ~AC97_EXTSTAT_VRA);
+		s->no_vra = 1;
+	}
+	if (s->no_vra)
+		info("no VRA, interpolating and decimating");
+
+	// set 48k for sampling rate
+	setting.rate  = 48000;
+	wrcodec(&s->codec, 0x2a, 1);
+	wrcodec(&s->codec, 0x2c, setting.rate);
+	//volume set
+	wrcodec(&s->codec, 2, 0);
+	wrcodec(&s->codec, 24, 0);
+	wrcodec(&s->codec, 22, 0);
+
+	return 0;
+
+ err_dev3:
+	unregister_sound_mixer(s->codec.dev_mixer);
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+ err_dev1:
+	return -1;
+}
+
+// remove procedure
+static void __devinit voyagergx_remove(void)
+{
+	struct voyagergx_state *s = &voyagergx_state;
+
+	if (!s)
+		return;
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->codec.dev_mixer);
+}
+
+// initilization
+static	int __init init_voyagergx(void)
+{
+unsigned long	value;
+int	err;
+
+	info("sakuma@ace-jp.com, built " __TIME__ " on " __DATE__);
+
+	// set GPIO for ac97 & 8051
+	value = *(volatile unsigned long *)(GPIO_MUX_LOW);
+	value |= GPIO_MUX_LOW_AC97 | GPIO_MUX_LOW_8051;
+	*(volatile unsigned long *)(GPIO_MUX_LOW) = value;
+
+	// stop DMA
+	dma2_stop(sh7751_dmasound_play_irq);
+
+	//DMA interrupt request
+        err = request_dma2(sh7751_dmasound_play_irq, "voyager DMA",do_irq);
+        if (err) {
+                return 0;
+        }
+
+	// enalbe ac97 interrupt
+	value = *(volatile unsigned long *)(VOYAGER_INT_MASK);
+	value |= VOYAGER_INT_MASK_AC;
+	*(volatile unsigned long *)(VOYAGER_INT_MASK) = value;
+
+	// power on ac97
+	value = *(volatile unsigned long *)(POWER_MODE0_GATE);
+	value |= POWER_MODE0_GATE_AC;
+	*(volatile unsigned long *)(POWER_MODE0_GATE) = value;
+
+	// power on ac97
+	value = *(volatile unsigned long *)(POWER_MODE1_GATE);
+	value |= POWER_MODE1_GATE_AC;
+	*(volatile unsigned long *)(POWER_MODE1_GATE) = value;
+
+	// enable ac97
+	value = *(volatile unsigned long *)(AC97_CONTROL_STATUS);
+	value |= 0x0000000F;
+	*(volatile unsigned long *)(AC97_CONTROL_STATUS) = value;
+	// wait for a while
+	mdelay(2);
+	// exit reset
+	value &= 0xFFFFFFF9;
+	*(volatile unsigned long *)(AC97_CONTROL_STATUS) = value;
+
+	// tag initialization(enable stot1-4)
+	value = *(volatile unsigned long *)(AC97_TX_SLOT0);
+	value |= 0x0000F800;
+	*(volatile unsigned long *)(AC97_TX_SLOT0) = value;
+
+	// mono 16bit 48k
+	setting.ch = 0;
+	setting.fmt = 16;
+	setting.rate = 48000;
+
+	// DMA initialization
+        dma2_set_device(sh7751_dmasound_play_irq);
+
+	// 8051 initialization
+	init_8051();
+
+	return voyagergx_probe();
+}
+
+// unload
+static void __exit cleanup_voyagergx(void)
+{
+	info("unloading");
+	voyagergx_remove();
+}
+
+module_init(init_voyagergx);
+module_exit(cleanup_voyagergx);
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.8/sound/oss/voyagergx_sound.h linux-2.6.17.8-sh/sound/oss/voyagergx_sound.h
--- linux-2.6.17.8/sound/oss/voyagergx_sound.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/oss/voyagergx_sound.h	2006-08-23 13:29:08.259909000 +0100
@@ -0,0 +1,4 @@
+#define VOYAGER_8051_COMMAND	(VOYAGER_BASE + 0x000c3ff0)
+#define VOYAGER_8051_STATUS	(VOYAGER_BASE + 0x000c3ff2)
+#define VOYAGER_8051_DATA	(VOYAGER_BASE + 0x000c3ff4)
+#define VOYAGER_8051_FIFO	(VOYAGER_BASE + 0x000c3600)
diff -Naur linux-2.6.17.8/sound/sh/aica.c linux-2.6.17.8-sh/sound/sh/aica.c
--- linux-2.6.17.8/sound/sh/aica.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/sh/aica.c	2006-08-23 13:29:27.714346000 +0100
@@ -0,0 +1,711 @@
+/*
+* This code is licenced under 
+* the General Public Licence
+* version 2
+*
+* Copyright Adrian McMenamin 2005, 2006
+* <adrian@mcmen.demon.co.uk>
+* See also http://newgolddream.dyndns.info/cgi-bin/cvsweb
+* 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of version 2 of the GNU General Public License as published by
+* the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*
+*/
+
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/info.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include "aica.h"
+
+MODULE_AUTHOR("Adrian McMenamin <adrian@mcmen.demon.co.uk>");
+MODULE_DESCRIPTION("Dreamcast AICA sound (pcm) driver");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Yamaha/SEGA, AICA}}");
+
+/* Command values */
+#define AICA_CMD_KICK 0x80000000
+#define AICA_CMD_NONE 0
+#define AICA_CMD_START 1
+#define AICA_CMD_STOP 2
+#define AICA_CMD_VOL 3
+
+/* Sound modes */
+#define SM_8BIT		1
+#define SM_16BIT	0
+#define SM_ADPCM	2
+
+/* Buffer and period size */
+#define AICA_BUFFER_SIZE 0x8000
+#define AICA_PERIOD_SIZE 0x800
+#define AICA_PERIOD_NUMBER 16
+
+#define AICA_CHANNEL0_OFFSET 0x11000
+#define AICA_CHANNEL1_OFFSET 0x21000
+#define CHANNEL_OFFSET 0x10000
+
+#define AICA_DMA_CHANNEL 0
+#define AICA_DMA_MODE 5
+
+#define SND_AICA_DRIVER "AICA"
+
+struct aica_channel {
+	uint32_t cmd;		/* Command ID           */
+	uint32_t pos;		/* Sample position      */
+	uint32_t length;	/* Sample length        */
+	uint32_t freq;		/* Frequency            */
+	uint32_t vol;		/* Volume 0-255         */
+	uint32_t pan;		/* Pan 0-255            */
+	uint32_t sfmt;		/* Sound format         */
+	uint32_t flags;		/* Bit flags            */
+};
+
+struct snd_card_aica {
+	struct snd_card *card;
+	struct aica_channel *channel;
+	snd_pcm_substream_t *substream;
+	int clicks;
+	int current_period;
+	struct timer_list timer;
+	int master_volume;
+	int dma_started;
+};
+
+/* module parameters */
+#define CARD_NAME "AICA"
+static int index = -1;
+static char *id;
+static int enable = 1;
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
+module_param(enable, bool, 0644);
+MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
+
+/* Use workqueue */
+static struct work_struct spu_dma_work;
+static struct workqueue_struct *aica_queue;
+
+/* Simple platform device */
+static struct platform_device *pd;
+static struct resource aica_memory_space[2] = {
+	{
+	 .name = "AICA ARM CONTROL",
+	 .start = ARM_RESET_REGISTER,
+	 .flags = IORESOURCE_MEM,
+	 .end = ARM_RESET_REGISTER + 3,
+	 },
+	{
+	 .name = "AICA Sound RAM",
+	 .start = AICA_MEMORY_BASE,
+	 .flags = IORESOURCE_MEM,
+	 .end = AICA_MEMORY_BASE + AICA_MEMORY_SIZE - 1,
+	 },
+};
+
+/* SPU specific functions */
+/* spu_write_wait - wait for G2-SH FIFO to clear */
+static inline void spu_write_wait(void)
+{
+	int time_count;
+	time_count = 0;
+	while (1) {
+		if (!(readl(G2_FIFO) & 0x11))
+			break;
+		/* To ensure hardware failure doesn't wedge kernel */
+		time_count++;
+		if (time_count > 0x10000)
+			break;
+	}
+}
+
+/* spu_memset - write to memory in SPU address space */
+static void spu_memset(uint32_t toi, uint32_t what, int length)
+{
+	int i;
+	snd_assert(length % 4 == 0, return);
+	spu_write_wait();
+	for (i = 0; i < length; i++) {
+		writel(what, toi + AICA_MEMORY_BASE);
+		toi++;
+		if (i && !(i % 8))
+			spu_write_wait();
+	}
+}
+
+/* spu_memload - write to SPU address space */
+static void spu_memload(uint32_t toi, void __iomem * from, int length)
+{
+	uint32_t __iomem *froml = from;
+	uint32_t __iomem *to = (uint32_t __iomem *) (AICA_MEMORY_BASE + toi);
+	int i, val;
+	if (length % 4)
+		length = (length / 4) + 1;
+	else
+		length = length / 4;
+	spu_write_wait();
+	for (i = 0; i < length; i++) {
+		val = *froml;
+		writel(val, to);
+		froml++;
+		to++;
+		if (i && !(i % 8))
+			spu_write_wait();
+	}
+}
+
+/* spu_disable - set spu registers to stop sound output */
+static void spu_disable(void)
+{
+	int i;
+	uint32_t regval;
+	spu_write_wait();
+	regval = readl(ARM_RESET_REGISTER);
+	regval |= 1;
+	spu_write_wait();
+	writel(regval, ARM_RESET_REGISTER);
+	for (i = 0; i < 64; i++) {
+		spu_write_wait();
+		regval = readl(AICA_REGISTER_BASE + (i * 0x80));
+		regval = (regval & ~0x4000) | 0x8000;
+		spu_write_wait();
+		writel(regval, AICA_REGISTER_BASE + (i * 0x80));
+	}
+}
+
+/* spu_enable - set spu registers to enable sound output */
+static void spu_enable(void)
+{
+	uint32_t regval = readl(ARM_RESET_REGISTER);
+	regval &= ~1;
+	spu_write_wait();
+	writel(regval, ARM_RESET_REGISTER);
+}
+
+/* 
+ * Halt the sound processor, clear the memory,
+ * load some default ARM7 code, and then restart ARM7
+*/
+static void spu_reset(void)
+{
+	spu_disable();
+	spu_memset(0, 0, 0x200000 / 4);
+	/* Put ARM7 in endless loop */
+	ctrl_outl(0xea000002, AICA_MEMORY_BASE);
+	spu_enable();
+}
+
+/* aica_chn_start - write to spu to start playback */
+static void aica_chn_start(void)
+{
+	spu_write_wait();
+	writel(AICA_CMD_KICK | AICA_CMD_START, (uint32_t *) AICA_CONTROL_POINT);
+}
+
+/* aica_chn_halt - write to spu to halt playback */
+static void aica_chn_halt(void)
+{
+	spu_write_wait();
+	writel(AICA_CMD_KICK | AICA_CMD_STOP, (uint32_t *) AICA_CONTROL_POINT);
+}
+
+/* ALSA code below */
+static struct snd_pcm_hardware snd_pcm_aica_playback_hw = {
+	.info = (SNDRV_PCM_INFO_NONINTERLEAVED),
+	.formats =
+	    (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |
+	     SNDRV_PCM_FMTBIT_IMA_ADPCM),
+	.rates = SNDRV_PCM_RATE_8000_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = AICA_BUFFER_SIZE,
+	.period_bytes_min = AICA_PERIOD_SIZE,
+	.period_bytes_max = AICA_PERIOD_SIZE,
+	.periods_min = AICA_PERIOD_NUMBER,
+	.periods_max = AICA_PERIOD_NUMBER,
+};
+
+static int aica_dma_transfer(int channels, int buffer_size,
+			     struct snd_pcm_substream *substream)
+{
+	int q, err, period_offset;
+	struct snd_card_aica *dreamcastcard;
+	struct snd_pcm_runtime *runtime;
+	err = 0;
+	dreamcastcard = substream->pcm->private_data;
+	period_offset = dreamcastcard->clicks;
+	period_offset %= (AICA_PERIOD_NUMBER / channels);
+	runtime = substream->runtime;
+	for (q = 0; q < channels; q++) {
+		err = dma_xfer(AICA_DMA_CHANNEL,
+			       (unsigned long)(runtime->dma_area +
+					       (AICA_BUFFER_SIZE * q) /
+					       channels +
+					       AICA_PERIOD_SIZE *
+					       period_offset),
+			       AICA_CHANNEL0_OFFSET + q * CHANNEL_OFFSET +
+			       AICA_PERIOD_SIZE * period_offset,
+			       buffer_size / channels, AICA_DMA_MODE);
+		if (unlikely(err < 0))
+			break;
+		dma_wait_for_completion(AICA_DMA_CHANNEL);
+	}
+	return err;
+}
+
+static void startup_aica(struct snd_card_aica *dreamcastcard)
+{
+	spu_memload(AICA_CHANNEL0_CONTROL_OFFSET,
+		    (uint8_t *) dreamcastcard->channel,
+		    sizeof(struct aica_channel));
+	aica_chn_start();
+}
+
+
+static void execute_spu_dma(void *sstream)
+{
+	int buffer_size;
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	struct snd_card_aica *dreamcastcard;
+	substream = sstream;
+	dreamcastcard = substream->pcm->private_data;
+	runtime = substream->runtime;
+	if (unlikely(dreamcastcard->dma_started == 0))
+	{
+		buffer_size = frames_to_bytes(runtime, runtime->buffer_size);
+		if (runtime->channels > 1)
+			dreamcastcard->channel->flags |= 0x01;
+		aica_dma_transfer(runtime->channels, buffer_size, substream);
+		startup_aica(dreamcastcard);
+		dreamcastcard->clicks =
+	    		buffer_size / (AICA_PERIOD_SIZE * runtime->channels);
+		dreamcastcard->dma_started = 1;
+	}
+	else
+	{
+		aica_dma_transfer(runtime->channels,
+			  AICA_PERIOD_SIZE * runtime->channels, substream);
+		snd_pcm_period_elapsed(dreamcastcard->substream);
+		dreamcastcard->clicks++;
+		dreamcastcard->clicks %= AICA_PERIOD_NUMBER;
+		mod_timer(&dreamcastcard->timer, jiffies+1);
+	}
+	
+}
+
+static void aica_period_elapsed(unsigned long timer_var)
+{
+	/*timer fuction - so cannot sleep */
+	int play_period;
+	struct snd_pcm_runtime *runtime;
+	struct snd_pcm_substream *substream;
+	struct snd_card_aica *dreamcastcard;
+	substream = (struct snd_pcm_substream *)timer_var;
+	runtime = substream->runtime;
+	dreamcastcard = substream->pcm->private_data;
+	/* Have we played out an additional period? */
+	play_period =
+	    frames_to_bytes(runtime,
+			    readl
+			    (AICA_CONTROL_CHANNEL_SAMPLE_NUMBER)) /
+	    AICA_PERIOD_SIZE;
+	if (play_period == dreamcastcard->current_period) {
+		/* reschedule the timer */
+		mod_timer(&dreamcastcard->timer, jiffies+1);
+		return;
+	}
+	if (runtime->channels > 1)
+		dreamcastcard->current_period = play_period;
+	queue_work(aica_queue, &spu_dma_work);
+}
+
+static int snd_aicapcm_pcm_open(struct snd_pcm_substream
+				*substream)
+{
+	struct snd_pcm_runtime *runtime;
+	struct aica_channel *channel;
+	struct snd_card_aica *dreamcastcard;
+	if (!enable)
+		return -ENOENT;
+	dreamcastcard = substream->pcm->private_data;
+	channel = kmalloc(sizeof(struct aica_channel), GFP_KERNEL);
+	if (!channel)
+		return -ENOMEM;
+	/* set defaults for channel */
+	channel->sfmt = SM_8BIT;
+	channel->cmd = AICA_CMD_START;
+	channel->vol = dreamcastcard->master_volume;
+	channel->pan = 0x80;
+	channel->pos = 0;
+	channel->flags = 0;	/* default to mono */
+	dreamcastcard->channel = channel;
+	runtime = substream->runtime;
+	runtime->hw = snd_pcm_aica_playback_hw;
+	spu_enable();
+	dreamcastcard->clicks = 0;
+	dreamcastcard->current_period = 0;
+	dreamcastcard->dma_started = 0;
+	return 0;
+}
+
+static int snd_aicapcm_pcm_close(struct snd_pcm_substream
+				 *substream)
+{
+	struct snd_card_aica *dreamcastcard = substream->pcm->private_data;
+	del_timer(&dreamcastcard->timer);
+	kfree(dreamcastcard->channel);
+	spu_disable();
+	return 0;
+}
+
+static int snd_aicapcm_pcm_hw_free(struct snd_pcm_substream
+				   *substream)
+{
+	/* Free the DMA buffer */
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_aicapcm_pcm_hw_params(struct snd_pcm_substream
+				     *substream, struct snd_pcm_hw_params
+				     *hw_params)
+{
+	/* Allocate a DMA buffer using ALSA built-ins */
+	return
+	    snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_aicapcm_pcm_prepare(struct snd_pcm_substream
+				   *substream)
+{
+	struct snd_card_aica *dreamcastcard = substream->pcm->private_data;
+	if ((substream->runtime)->format == SNDRV_PCM_FORMAT_S16_LE)
+		dreamcastcard->channel->sfmt = SM_16BIT;
+	dreamcastcard->channel->freq = substream->runtime->rate;
+	dreamcastcard->substream = substream;
+	return 0;
+}
+
+
+
+static void spu_begin_dma(struct snd_pcm_substream *substream)
+{
+	/* Must be atomic */
+	struct snd_card_aica *dreamcastcard;
+	struct snd_pcm_runtime *runtime;
+	runtime = substream->runtime;
+	dreamcastcard = substream->pcm->private_data;
+	/*  Use queue to do the heavy lifting */
+	INIT_WORK(&spu_dma_work, execute_spu_dma, substream);
+	queue_work(aica_queue, &spu_dma_work);
+	init_timer(&(dreamcastcard->timer));
+	dreamcastcard->timer.data = (unsigned long)substream;
+	dreamcastcard->timer.function = aica_period_elapsed;
+	dreamcastcard->timer.expires = jiffies + 4;
+	add_timer(&(dreamcastcard->timer));
+}
+
+static int snd_aicapcm_pcm_trigger(struct snd_pcm_substream
+				   *substream, int cmd)
+{
+	struct snd_card_aica *dreamcastcard;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		spu_begin_dma(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dreamcastcard = substream->pcm->private_data;
+		if (dreamcastcard->timer.data)
+			del_timer(&dreamcastcard->timer);
+		aica_chn_halt();
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static unsigned long snd_aicapcm_pcm_pointer(struct snd_pcm_substream
+					     *substream)
+{
+	return readl(AICA_CONTROL_CHANNEL_SAMPLE_NUMBER);
+}
+
+static struct snd_pcm_ops snd_aicapcm_playback_ops = {
+	.open = snd_aicapcm_pcm_open,
+	.close = snd_aicapcm_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_aicapcm_pcm_hw_params,
+	.hw_free = snd_aicapcm_pcm_hw_free,
+	.prepare = snd_aicapcm_pcm_prepare,
+	.trigger = snd_aicapcm_pcm_trigger,
+	.pointer = snd_aicapcm_pcm_pointer,
+};
+
+/* TO DO: set up to handle more than one pcm instance */
+static int __init snd_aicapcmchip(struct snd_card_aica
+				  *dreamcastcard, int pcm_index)
+{
+	struct snd_pcm *pcm;
+	int err;
+	/* AICA has no capture ability */
+	err =
+	    snd_pcm_new(dreamcastcard->card, "AICA PCM", pcm_index, 1, 0, &pcm);
+	    if (unlikely(err < 0))
+		return err;
+	pcm->private_data = dreamcastcard;
+	strcpy(pcm->name, "AICA PCM");
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_aicapcm_playback_ops);
+	/* Allocate the DMA buffers */
+	err =
+	    snd_pcm_lib_preallocate_pages_for_all(pcm,
+						  SNDRV_DMA_TYPE_CONTINUOUS,
+						  snd_dma_continuous_data
+						  (GFP_KERNEL),
+						  AICA_BUFFER_SIZE,
+						  AICA_BUFFER_SIZE);
+	return err;
+}
+
+/* Mixer controls */
+static int aica_pcmswitch_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int aica_pcmswitch_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = 1;	/* TO DO: Fix me */
+	return 0;
+}
+
+static int aica_pcmswitch_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	if (ucontrol->value.integer.value[0] == 1)
+		return 0;	/* TO DO: Fix me */
+	else
+		aica_chn_halt();
+	return 0;
+}
+
+static int aica_pcmvolume_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xFF;
+	return 0;
+}
+
+static int aica_pcmvolume_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_card_aica *dreamcastcard;
+	dreamcastcard = kcontrol->private_data;
+	if (unlikely(!dreamcastcard->channel))
+		return -ETXTBSY;	/* we've not yet been set up */
+	ucontrol->value.integer.value[0] = dreamcastcard->channel->vol;
+	return 0;
+}
+
+static int aica_pcmvolume_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_card_aica *dreamcastcard;
+	dreamcastcard = kcontrol->private_data;
+	if (unlikely(!dreamcastcard->channel))
+		return -ETXTBSY;
+	if (unlikely(dreamcastcard->channel->vol ==
+		     ucontrol->value.integer.value[0]))
+		return 0;
+	dreamcastcard->channel->vol = ucontrol->value.integer.value[0];
+	dreamcastcard->master_volume = ucontrol->value.integer.value[0];
+	spu_memload(AICA_CHANNEL0_CONTROL_OFFSET,
+		    (uint8_t *) dreamcastcard->channel,
+		    sizeof(struct aica_channel));
+
+	return 1;
+}
+
+static struct snd_kcontrol_new snd_aica_pcmswitch_control __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Playback Switch",
+	.index = 0,
+	.info = aica_pcmswitch_info,
+	.get = aica_pcmswitch_get,
+	.put = aica_pcmswitch_put
+};
+
+static struct snd_kcontrol_new snd_aica_pcmvolume_control __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Playback Volume",
+	.index = 0,
+	.info = aica_pcmvolume_info,
+	.get = aica_pcmvolume_get,
+	.put = aica_pcmvolume_put
+};
+
+static int load_aica_firmware(void)
+{
+	int err;
+	const struct firmware *fw_entry;
+	err = 0;
+	spu_reset();
+	err = request_firmware(&fw_entry, "aica_firmware.bin", &pd->dev);
+	if (unlikely(err))
+		return err;
+	/* write firware into memory */
+	spu_disable();
+	spu_memload(0, fw_entry->data, fw_entry->size);
+	spu_enable();
+	release_firmware(fw_entry);
+	return err;
+}
+
+static int __devinit add_aicamixer_controls(struct snd_card_aica
+					    *dreamcastcard)
+{
+	int err;
+	err = snd_ctl_add
+	    (dreamcastcard->card,
+	     snd_ctl_new1(&snd_aica_pcmvolume_control, dreamcastcard));
+	if (unlikely(err < 0))
+		return err;
+	err = snd_ctl_add
+	    (dreamcastcard->card,
+	     snd_ctl_new1(&snd_aica_pcmswitch_control, dreamcastcard));
+	if (unlikely(err < 0))
+		return err;
+	return 0;
+}
+
+static int snd_aica_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));	
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+static int __init snd_aica_probe(struct platform_device *devptr)
+{
+	int err;
+	struct snd_card_aica *dreamcastcard;
+
+	dreamcastcard = kmalloc(sizeof(struct snd_card_aica), GFP_KERNEL);
+	if (unlikely(!dreamcastcard))
+		return -ENOMEM;
+	dreamcastcard->card =
+	    snd_card_new(index, SND_AICA_DRIVER, THIS_MODULE, 0);
+	if (unlikely(!dreamcastcard->card)) {
+		kfree(dreamcastcard);
+		return -ENODEV;
+	}
+	strcpy(dreamcastcard->card->driver, "snd_aica");
+	strcpy(dreamcastcard->card->shortname, SND_AICA_DRIVER);
+	strcpy(dreamcastcard->card->longname,
+	       "Yamaha AICA Super Intelligent Sound Processor for SEGA Dreamcast");
+	/* Load the PCM 'chip' */
+	err = snd_aicapcmchip(dreamcastcard, 0);
+	if (unlikely(err < 0))
+		goto freedreamcast;
+	snd_card_set_dev(dreamcastcard->card, &devptr->dev);
+	dreamcastcard->channel = NULL;
+	/* Add basic controls */
+	err = add_aicamixer_controls(dreamcastcard);
+	if (unlikely(err < 0))
+		goto freedreamcast;
+	/* Register the card with ALSA subsystem */
+	err = snd_card_register(dreamcastcard->card);
+	if (unlikely(err < 0))
+		goto freedreamcast;
+	platform_set_drvdata(devptr, dreamcastcard->card);
+	aica_queue = create_workqueue("aica");
+	if (unlikely(!aica_queue))
+		goto freedreamcast;
+	snd_printk
+	    ("ALSA Driver for Yamaha AICA Super Intelligent Sound Processor\n");
+	return 0;
+      freedreamcast:
+	snd_card_free(dreamcastcard->card);
+	kfree(dreamcastcard);
+	return err;
+}
+
+static struct platform_driver snd_aica_driver = {
+	.probe = snd_aica_probe,
+	.remove = snd_aica_remove,
+	.driver = {
+		   .name = SND_AICA_DRIVER
+	},
+};
+
+static int __init aica_init(void) {
+	int err;
+	err = platform_driver_register(&snd_aica_driver);
+	if (unlikely(err < 0)) return err;
+	pd = platform_device_register_simple(SND_AICA_DRIVER, -1,
+					     aica_memory_space, 2);
+	if (unlikely(IS_ERR(pd))) {
+		platform_driver_unregister(&snd_aica_driver);
+		return PTR_ERR(pd);
+	}
+	err = load_aica_firmware();
+	if (unlikely(err < 0)) {
+		platform_driver_unregister(&snd_aica_driver);
+		platform_device_unregister(pd);
+		return err;
+		}
+	return 0;
+}
+
+static void __exit aica_exit(void)
+{
+	/* Flush and destroy the aica kernel thread */
+	destroy_workqueue(aica_queue);
+	platform_device_unregister(pd);
+	platform_driver_unregister(&snd_aica_driver);
+	/* Kill any sound still playing and reset ARM7 to safe state */
+	spu_reset();
+}
+
+module_init(aica_init);
+module_exit(aica_exit);
+
diff -Naur linux-2.6.17.8/sound/sh/aica.h linux-2.6.17.8-sh/sound/sh/aica.h
--- linux-2.6.17.8/sound/sh/aica.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/sh/aica.h	2006-08-23 13:29:27.730346000 +0100
@@ -0,0 +1,44 @@
+/*
+* This code is licenced under 
+* the General Public Licence
+* version 2
+*
+* Copyright Adrian McMenamin 2006
+* <adrian@mcmen.demon.co.uk>
+* See also http://newgolddream.dyndns.info/cgi-bin/cvsweb
+* 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of version 2 of the GNU General Public License as published by
+* the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*
+*/
+
+#ifndef _ASM_DREAMCAST_AICA
+#define _ASM_DREAMCAST_AICA
+
+#ifdef MACH_DREAMCAST
+/* SPU memory and register constants etc */
+#define G2_FIFO 0xa05f688c
+#define AICA_MEMORY_BASE 0xA0800000
+#define ARM_RESET_REGISTER 0xA0702C00
+#define AICA_REGISTER_BASE 0xA0700000
+
+/* AICA channels stuff */
+#define AICA_CONTROL_POINT 0xA0810000
+#define AICA_CONTROL_CHANNEL_SAMPLE_NUMBER 0xA0810008
+#define AICA_MEMORY_SIZE 0x200000
+#define AICA_CHANNEL0_CONTROL_OFFSET 0x10004
+#endif
+
+#endif
+
diff -Naur linux-2.6.17.8/sound/sh/Kconfig linux-2.6.17.8-sh/sound/sh/Kconfig
--- linux-2.6.17.8/sound/sh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/sh/Kconfig	2006-08-23 13:29:26.047300000 +0100
@@ -0,0 +1,15 @@
+menu "SuperH devices"
+       depends on SND!=n && SUPERH
+
+config SND_AICA
+       tristate "Yamaha AICA sound for SEGA Dreamcast"
+       depends on SND
+       depends on SH_DREAMCAST
+       select SND_PCM
+       help
+         Say Y here to include support for sound on your SEGA Dreamcast
+
+         To compile this driver as a module, choose M here: the module
+         will be called snd-aica.
+
+endmenu
diff -Naur linux-2.6.17.8/sound/sh/Makefile linux-2.6.17.8-sh/sound/sh/Makefile
--- linux-2.6.17.8/sound/sh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/sh/Makefile	2006-08-23 13:29:25.972301000 +0100
@@ -0,0 +1,4 @@
+
+snd-aica-objs := aica.o
+obj-$(CONFIG_SND_AICA) += snd-aica.o
+
diff -Naur linux-2.6.17.8/sound/stm/Kconfig linux-2.6.17.8-sh/sound/stm/Kconfig
--- linux-2.6.17.8/sound/stm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/Kconfig	2006-08-23 13:29:50.245875000 +0100
@@ -0,0 +1,32 @@
+# ALSA SH4 drivers
+
+menu "ST PCM-ALSA driver"
+	depends on SND!=n && CPU_SUBTYPE_ST40
+
+config SND_STM8000
+	tristate "STM8000 ALSA driver"
+	depends on CPU_SUBTYPE_STM8000
+	select SND_PCM
+	help
+	  Say Y here for ALSA support on the STm8000.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-stm8000.
+
+config SND_STB7100
+	tristate "STB7100 ALSA driver"
+	depends on CPU_SUBTYPE_STB7100
+	select SND_PCM
+	help
+	  Say Y here for ALSA support on the STb7100.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-stb7100.
+
+config STB7100_IEC_DEBUG
+	tristate "STB7100 ALSA driver IEC debug"
+	depends on CPU_SUBTYPE_STB7100
+	select SND_PCM
+	help
+	  Say Y here for ALSA-IEC debugging on the STb7100.
+endmenu
diff -Naur linux-2.6.17.8/sound/stm/Makefile linux-2.6.17.8-sh/sound/stm/Makefile
--- linux-2.6.17.8/sound/stm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/Makefile	2006-08-23 13:29:39.802624000 +0100
@@ -0,0 +1,10 @@
+
+snd-stm8000-objs := st_pcm_core.o
+snd-stb7100-objs := st_pcm_core.o
+snd-spdif-stb7100-objs :=st_pcm_core.o
+
+obj-$(CONFIG_SND_STM8000) += snd-stm8000.o
+obj-$(CONFIG_SND_STB7100) += snd-stb7100.o
+
+
+
diff -Naur linux-2.6.17.8/sound/stm/stb7100_i2s_spdif.c linux-2.6.17.8-sh/sound/stm/stb7100_i2s_spdif.c
--- linux-2.6.17.8/sound/stm/stb7100_i2s_spdif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/stb7100_i2s_spdif.c	2006-08-23 13:29:50.382876000 +0100
@@ -0,0 +1,436 @@
+/*
+ *  STb7100 PCM->SPDIF protocol converter setup
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+/*
+ * Default HW template for PCM player 0 when used with the I2S->SPDIF
+ * protocol converter.
+ */
+static snd_pcm_hardware_t stb7100_converter_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID     |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	(SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE),
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 48000,
+	.channels_min	  = 10,
+	.channels_max	  = 10,
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.period_bytes_min = FRAMES_TO_BYTES(1,10),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+
+DECLARE_WAIT_QUEUE_HEAD(software_reset_wq);
+static volatile int software_reset_complete = 0;
+
+static void reset_pcm_converter(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t * chip = snd_pcm_substream_chip(substream);
+	u32 reg;
+
+	software_reset_complete = 0;
+	reg = readl(chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	writel((reg|PR_CFG_CONV_SW_RESET),chip->pcm_converter+AUD_SPDIF_PR_CFG);
+	wait_event(software_reset_wq, (software_reset_complete != 0));
+	writel(reg,chip->pcm_converter+AUD_SPDIF_PR_CFG);
+}
+
+
+static inline void bit_duplicate(u32 bits, u32 *word1, u32 *word2)
+{
+	int i,test_bit;
+
+	*word1 = 0;
+	*word2 = 0;
+	test_bit = 1;
+
+	for(i=0;i<16;i++) {
+		if(bits & test_bit) {
+			*word1 |= (1<<(i*2));
+			*word1 |= (1<<(i*2+1));
+		}
+
+		test_bit <<= 1;
+	}
+	/*
+	 * Note that test bit keeps going!
+	 */
+	for(i=0;i<16;i++) {
+		if(bits & test_bit) {
+			*word2 |= (1<<(i*2));
+			*word2 |= (1<<(i*2+1));
+		}
+
+		test_bit <<= 1;
+	}
+
+}
+
+
+static void stb7100_converter_write_channel_status(pcm_hw_t *chip)
+{
+	u32 chstatus,word1,word2;
+
+	chstatus = chip->current_spdif_control.channel.status[0]        |
+		   (chip->current_spdif_control.channel.status[1] <<8)  |
+		   (chip->current_spdif_control.channel.status[2] <<16) |
+		   (chip->current_spdif_control.channel.status[3] <<24);
+
+	bit_duplicate(chstatus, &word1, &word2);
+
+	writel(	word1, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE);
+
+	writel(	word2, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 4);
+
+	chstatus = chip->current_spdif_control.channel.status[4]        |
+		   (chip->current_spdif_control.channel.status[5] <<8)  |
+		   (chip->current_spdif_control.channel.status[6] <<16) |
+		   (chip->current_spdif_control.channel.status[7] <<24);
+
+	bit_duplicate(chstatus, &word1, &word2);
+
+	writel(	word1, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 8);
+	writel(	word2, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 12);
+
+	writel(	0, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 16);
+	writel(	0, chip->pcm_converter + AUD_SPDIF_PR_CHANNEL_STA_BASE + 20);
+}
+
+
+static irqreturn_t stb7100_converter_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+	unsigned long handled= IRQ_NONE;
+	pcm_hw_t *chip = dev_id;
+
+        /* Read and clear interrupt status */
+	spin_lock(&chip->lock);
+	val = readl(chip->pcm_converter + AUD_SPDIF_PR_INT_STA);
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+	spin_unlock(&chip->lock);
+
+	if(val & PR_SOFT_RESET_INT_ENABLE){
+		software_reset_complete = 1;
+		wake_up(&software_reset_wq);
+		handled = IRQ_HANDLED;
+	}
+
+	if(val & PR_I2S_FIFO_OVERRUN_INT){
+		int reg;
+
+		reg = readl(chip->pcm_converter+AUD_SPDIF_PR_CFG);
+		writel((reg & ~PR_CFG_FIFO_ENABLE),chip->pcm_converter+AUD_SPDIF_PR_CFG);
+		writel(reg,chip->pcm_converter+AUD_SPDIF_PR_CFG);
+		handled = IRQ_HANDLED;
+	}
+
+	if(val & PR_AUDIO_SAMPLES_FULLY_READ_INT){
+            /* Inform higher layer that we have completed a period */
+		snd_pcm_period_elapsed(chip->current_substream);
+		handled =IRQ_HANDLED;
+	}
+	return handled;
+}
+
+
+static void stb7100_converter_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) & ~PR_CFG_DEVICE_ENABLE;
+	writel(reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+	writel((reg|PR_CTRL_OFF), chip->pcm_converter+AUD_SPDIF_PR_SPDIF_CTRL);
+
+	writel(0         , chip->pcm_converter + AUD_SPDIF_PR_INT_EN);
+	writel(0xffffffff, chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+
+	/*
+	 * Stop PCM Player0 with mute, see the stm7100_pcm.c for an explanation
+	 */
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+
+	dma_stop_channel(chip->fdma_channel);
+}
+
+
+static void stb7100_converter_start_playback(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t     *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	dma_xfer(chip->fdma_channel);
+
+	reg = readl(chip->pcm_converter +AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+	writel(reg | PR_CTRL_AUDIO_DATA_MODE,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) | PR_CFG_DEVICE_ENABLE;
+	writel(reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	/*
+	 * We appear to need to reset the PCM player otherwise we end up
+	 * with channel data sent to the wrong channels when starting up for
+	 * the second time.
+	 */
+	stb7100_reset_pcm_player(chip);
+
+	writel((chip->pcmplayer_control | PCMP_ON), chip->pcm_player + STM_PCMP_CONTROL);
+
+}
+
+
+static void stb7100_converter_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+        spin_lock(&chip->lock);
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+	writel(reg | PR_CTRL_AUDIO_DATA_MODE,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) | PR_CFG_DEVICE_ENABLE;
+	writel(reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	writel((chip->pcmplayer_control|PCMP_ON), chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static void stb7100_converter_pause_playback(snd_pcm_substream_t *substream)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+	reg = readl(chip->pcm_converter + AUD_SPDIF_PR_CFG) & ~PR_CFG_DEVICE_ENABLE;
+	writel(reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	reg = readl(chip->pcm_converter +AUD_SPDIF_PR_SPDIF_CTRL) & ~0x7L; /* mask bottom three bits */
+	writel(reg|PR_CTRL_MUTE_PCM_NULL_DATA, chip->pcm_converter+AUD_SPDIF_PR_SPDIF_CTRL);
+
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static int stb7100_converter_program_player(snd_pcm_substream_t * substream)
+{
+	unsigned long cfg_reg = 0;
+	unsigned long ctl_reg = 0;
+	unsigned long interrupt_list = (PR_INTERRUPT_ENABLE             |
+					PR_SOFT_RESET_INT_ENABLE        |
+					PR_I2S_FIFO_OVERRUN_INT         |
+					PR_AUDIO_SAMPLES_FULLY_READ_INT);
+	unsigned long flags=0;
+
+	snd_pcm_runtime_t * runtime = substream->runtime;
+	pcm_hw_t          * chip    = snd_pcm_substream_chip(substream);
+	int val =0;
+
+	/*we only ever call from the stm7100_pcm program func,
+	 * therefore we assume we already own the chip lock*/
+	spin_lock_irqsave(&chip->lock,flags);
+	/*
+	 * Clear then enable the protocol converter interrupts.
+	 */
+	writel(0xffffffff,    chip->pcm_converter + AUD_SPDIF_PR_INT_CLR);
+	writel(interrupt_list,chip->pcm_converter + AUD_SPDIF_PR_INT_EN);
+
+	cfg_reg = (PR_CFG_FIFO_ENABLE | PR_CFG_REQ_ACK_ENABLE);
+
+	if(runtime->format == SNDRV_PCM_FORMAT_S16_LE)
+	  cfg_reg |= PR_CFG_WORD_SZ_16BIT;
+	else
+	  cfg_reg |= PR_CFG_WORD_SZ_24BIT;
+
+	writel(cfg_reg, chip->pcm_converter + AUD_SPDIF_PR_CFG );
+
+	/*
+	 * Setup initial channel status data for the hardware mode and
+	 * program for the new data burst.
+	 */
+	chip->pending_spdif_control = chip->default_spdif_control;
+	iec60958_set_runtime_status(substream);
+	chip->iec60958_output_count = 0;
+
+	chip->current_spdif_control = chip->pending_spdif_control;
+	stb7100_converter_write_channel_status(chip);
+
+	val = 	chip->current_spdif_control.validity_l[0]        |
+	 	(chip->current_spdif_control.validity_l[1] <<8)  |
+	 	(chip->current_spdif_control.validity_l[2] <<16) |
+	 	(chip->current_spdif_control.validity_l[3] <<24);
+	/*TODO need a way to set up and expose the channel status/user & validity to the user*/
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_VALIDITY);
+
+	val = 	chip->current_spdif_control.user[0]        |
+		(chip->current_spdif_control.user[1] <<8)  |
+		(chip->current_spdif_control.user[2] <<16) |
+		(chip->current_spdif_control.user[3] <<24);
+
+	writel(val,chip->pcm_converter + AUD_SPDIF_PR_USER_DATA);
+
+	/*
+	 * These following writes refer to the IEC encoded mode - which is part
+	 * of the converter block but not implemented in the instance of the
+	 * 7100, so make sure it is all swithced off
+	 */
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PAUSE);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_DATA_BURST);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PA_PB);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_PC_PD);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CL1);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CR1);
+	writel(0,chip->pcm_converter + AUD_SPDIF_PR_SPDIF_SUV);
+
+	/*
+	 * Setup the control register, but don't start it all of just yet.
+	 */
+	ctl_reg   = PR_CTRL_SW_STUFFING | PR_CTRL_16BIT_DATA_NOROUND | PR_CTRL_OFF;
+	ctl_reg  |= SPDIF_FSYNTH_DIVIDE32_128;
+        ctl_reg  |= ((runtime->period_size * 2) << PR_CTRL_SAMPLES_SHIFT);
+
+	writel(ctl_reg, chip->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+	spin_unlock_irqrestore(&chip->lock,flags);
+	/*this reset will cause us to de-schedule, then well get an IRQ when
+	 * the reset has completed, so make sure we dont hold any locks by now*/
+	reset_pcm_converter(substream);
+}
+
+
+static int stb7100_converter_free(pcm_hw_t *card)
+{
+	writel(0, card->pcm_converter + AUD_SPDIF_PR_CFG );
+	writel(0, card->pcm_converter + AUD_SPDIF_PR_SPDIF_CTRL);
+	writel(PCMP_OFF, card->pcm_player + STM_PCMP_CONTROL);
+
+	free_dma(card->fdma_channel);
+
+	iounmap(card->pcm_clock_reg);
+	iounmap(card->out_pipe);
+	iounmap(card->pcm_player);
+	iounmap(card->pcm_converter);
+
+	if(card->irq > 0)
+		free_irq(card->irq,(void *)card);
+
+	kfree(card);
+
+	return 0;
+}
+
+
+static stm_playback_ops_t stb7100_converter_ops = {
+	.free_device      = stb7100_converter_free,
+	.open_device      = stb7100_pcm_open,
+	.program_hw       = stb7100_pcm_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_converter_start_playback,
+	.stop_playback    = stb7100_converter_stop_playback,
+	.pause_playback   = stb7100_converter_pause_playback,
+	.unpause_playback = stb7100_converter_unpause_playback
+};
+
+
+static int stb7100_create_converter_device(pcm_hw_t *chip,snd_card_t  *this_card)
+{
+	int err = 0;
+	int irq = linux_pcm_irq[chip->card_data->major];
+
+	strcpy(this_card->shortname, "STb7100_CNV");
+	strcpy(this_card->longname,  "STb7100_CNV");
+	sprintf(this_card->driver,   "%d",chip->card_data->major);
+        /*
+         * In this case we need the base address of pcm0 for the player +
+         * the base address of the IEC60958 device for the conversion block
+         */
+	chip->pcm_player    = ioremap(pcm_base_addr[0],0);
+	chip->pcm_converter = ioremap(pcm_base_addr[chip->card_data->major],0);
+	chip->hw            = stb7100_converter_hw;
+	chip->oversampling_frequency = 128;
+
+	chip->playback_ops  = &stb7100_converter_ops;
+
+	if(request_irq(irq, stb7100_converter_interrupt, SA_INTERRUPT, "STB7100_CNV",(void*)chip)){
+               		printk(">>> failed to get IRQ %d\n",irq);
+	                stb7100_converter_free(chip);
+        	        return -EBUSY;
+        }
+
+	chip->irq = irq;
+
+	iec60958_default_channel_status(chip);
+
+	/*
+	 * For the converter device we rely on the PCM0 clock setup to drive
+	 * the IEC block.
+	 */
+	set_default_device_clock(chip);
+
+	stb7100_reset_pcm_player(chip);
+
+	if((err = snd_card_pcm_allocate(chip,chip->card_data->minor,this_card->longname)) < 0) {
+        	printk(" >>> Failed to create PCM-SPDIF converter Stream\n");
+        	stb7100_converter_free(chip);
+    	}
+
+    	if ((err = snd_iec60958_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if((err = snd_generic_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if((err = snd_device_new(this_card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0){
+        	printk(">>> creating sound device :%d,%d failed\n",chip->card_data->major,chip->card_data->minor);
+        	stb7100_converter_free(chip);
+		return err;
+    	}
+
+	if((err = snd_card_register(this_card)) < 0){
+        	stb7100_converter_free(chip);
+		return err;
+    	}
+
+    	return 0;
+}
+
diff -Naur linux-2.6.17.8/sound/stm/stb7100_snd.h linux-2.6.17.8-sh/sound/stm/stb7100_snd.h
--- linux-2.6.17.8/sound/stm/stb7100_snd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/stb7100_snd.h	2006-08-23 13:29:50.262875000 +0100
@@ -0,0 +1,244 @@
+/*
+ *  STb7100 ALSA Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef STB7100_SND_H_
+#define STB7100_SND_H_
+
+#define FDMA2_BASE_ADDRESS			0x19220000
+#define AUD_CFG_BASE				0x19210000
+#define SPDIF_BASE				0x18103000
+#define PCMP0_BASE				0x18101000
+#define PCMP1_BASE				0x18101800
+#define PCM0_CONVERTER_BASE     		0x18103800
+
+#define FDMA2_BASE_ADDRESS			0x19220000
+#define AUD_CFG_BASE				0x19210000
+
+#define LINUX_PCMPLAYER0_ALLREAD_IRQ		144
+#define LINUX_PCMPLAYER1_ALLREAD_IRQ		145
+#define LINUX_SPDIFPLAYER_ALLREAD_IRQ		147
+#define LINUX_SPDIFCONVERTER_ALLREAD_IRQ	142
+
+/*
+ * Thankfully the block register offsets for PCM0/1 & spdif
+ * are the same, only with a differing base address.
+ *
+ * Alas this is not the case for the Fsynth's, so we must specify those seperately
+ */
+#define STM_PCMP_DATA_FIFO			0x04
+#define STM_PCMP_IRQ_STATUS			0x08
+#define STM_PCMP_IRQ_ENABLE			0x10
+#define STM_PCMP_ITS_CLR 			0x0C
+#define STM_PCMP_IRQ_EN_SET			0x14
+#define STM_PCMP_IRQ_EN_CLR			0x18
+#define STM_PCMP_CONTROL        		0x1C
+#define STM_PCMP_STATUS         		0x20
+#define STM_PCMP_FORMAT         		0x24
+
+/*
+ * The STb7100 PCM Player has an interrupt status, which inconveniently doesn't
+ * have the bits laid out in the same position as the PCM Player Status register.
+ */
+#define PCMP_INT_STATUS_ALLREAD			(1<<1)
+#define PCMP_INT_STATUS_UNDERFLOW		(1<<0)
+
+
+#define AUD_FSYN0_MD				0x10
+#define AUD_FSYN0_PE 				0x14
+#define AUD_FSYN0_SDIV				0x18
+#define AUD_FSYN0_PROG_EN      			0x1c
+
+#define AUD_FSYN1_MD				0x20
+#define AUD_FSYN1_PE				0x24
+#define AUD_FSYN1_SDIV				0x28
+#define AUD_FSYN1_PROG_EN			0x2c
+
+#define AUD_FSYN2_MD				0x30
+#define AUD_FSYN2_PE 				0x34
+#define AUD_FSYN2_SDIV				0x38
+#define AUD_FSYN2_PROG_EN			0x3c
+
+
+/*spdif control reg operators*/
+
+#define SPDIF_OFF				0x00
+#define SPDIF_MUTE_NULL_DATA			0x01
+#define SPDIF_MUTE_BURST			0x02
+#define SPDIF_PCM_ON				0x03
+#define SPDIF_ENCODED_ON			0x04
+#define SPDIF_IDLE 				(1L<<3)
+#define SPDIF_BIT16_DATA_ROUND 			(1L<<4)
+#define SPDIF_BIT16_DATA_NOROUND 		(0L<<4)
+#define SPDIF_FSYNTH_DIVIDE32_1			(0L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_128		(1L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_192		(6L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_256		(2L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_384		(3L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_512		(4L<<5)
+#define SPDIF_FSYNTH_DIVIDE32_784		(6L<<5)
+#define SPDIF_BYTE_SWAP 			(1L<<13)
+#define SPDIF_HW_STUFFING 			(1L<<14)
+#define SPDIF_SW_STUFFING 			(0L<<14)
+#define SPDIF_SAMPLES_SHIFT			15
+
+
+#define AUD_SPDIF_STA 				0x20
+#define AUD_SPDIF_PA_PB 			0x24
+#define AUD_SPDIF_PC_PD 			0x28
+#define AUD_SPDIF_CL1   			0x2c/*left subframe status 31-0*/
+#define AUD_SPDIF_CR1   			0x30 /*right subframe status 31-0*/
+#define AUD_SPDIF_CL2_CR2_UV 			0x34
+#define AUD_SPDIF_PAU_LAT 			0x38
+#define AUD_SPDIF_FRA_LEN_BST 			0x3c
+
+
+/*spdif int generation vals*/
+#define ENABLE_INT_UNDERFLOW 			(1L<<0)
+#define ENABLE_INT_EODBURST 			(1L<<1)
+#define ENABLE_INT_EOBLOCK 			(1L<<2)
+#define ENABLE_INT_EOLATENCY 			(1L<<3)
+#define ENABLE_INT_EOPD				(1L<<4)
+#define ENABLE_INT_NSAMPLE 			(1L<<5)
+
+#define SPDIF_INT_STATUS_UNF			(1L<<0)
+#define SPDIF_INT_STATUS_EODBURST  		(1L<<1)
+#define SPDIF_INT_STATUS_EOBLOCK 		(1L<<2)
+#define SPDIF_INT_STATUS_EOLATENCY 		(1L<<3)
+#define SPDIF_INT_STATUS_EOPD	 		(1L<<4)
+#define SPDIF_INT_STATUS_ALLREAD 		(1L<<5)
+
+
+#define MPEG_DECODE_LAT_48KHZ 21 /*really 20.9 ms*/
+#define MPEG_DECODE_LAT_441KHZ 23 /*really 22.75 ms*/
+#define MPEG_DECODE_LAT_32KHZ 31 /*really 30.35 ms*/
+
+#define TIME_TO_FRAMES(freq,time)((time * freq) /1000)
+
+#define  IEC61937_PA  		 0xF872
+#define  IEC61937_PB  		 0x4E1F
+#define  IEC61937_DTS_TYPE_1	 11
+#define  IEC61937_DTS_TYPE_2	 12
+#define  IEC61937_DTS_TYPE_3	 13
+#define  IEC61937_AC3_STREAM     0x1
+
+#define DUMP_SPDIF_STATE()(\
+	printk("%s\n\
+	AUD_SPDIF_RST  %x\n\
+	AUD_SPDIF_DATA %x\n\
+	AUD_SPDIF_ITS  %x\n\
+	AUD_SPDIF_ITS_CLR %x\n\
+	AUD_SPDIF_ITS_EN %x\n\
+	AUD_SPDIF_ITS_EN_SET %x\n\
+	AUD_SPDIF_ITS_EN_CLR %x\n\
+	AUD_SPDIF_CTL %x\n\
+	AUD_SPDIF_STA %x\n\
+	AUD_SPDIF_PA_PB %x\n\
+	AUD_SPDIF_PC_PD %x\n \
+	AUD_SPDIF_CL1 %x\n\
+	AUD_SPDIF_CR1 %x\n\
+	AUD_SPDIF_CL2CR2UV %x\n\
+	AUD_SPDIF_FRA_LEN_BST %x\n\
+	AUD_SPDIF_PAU_LAT %x \n",\
+		__FUNCTION__,\
+		(int)readl(chip->pcm_player+0x00),\
+		(int)readl(chip->pcm_player+STM_PCMP_DATA_FIFO),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_STATUS),\
+		(int)readl(chip->pcm_player+STM_PCMP_ITS_CLR ),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_ENABLE),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_SET),\
+		(int)readl(chip->pcm_player+STM_PCMP_IRQ_EN_CLR),\
+		(int)readl(chip->pcm_player+STM_PCMP_CONTROL),\
+		(int)readl(chip->pcm_player+STM_PCMP_STATUS ),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PA_PB),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PC_PD),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CL1),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CR1),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_CL2_CR2_UV),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_FRA_LEN_BST),\
+		(int)readl(chip->pcm_player+AUD_SPDIF_PAU_LAT)))
+
+
+/*
+ * I2S to SPDIF Protocol converter defines
+ */
+#define AUD_SPDIF_PR_CFG			0x00
+#define AUD_SPDIF_PR_STAT			0x04
+#define AUD_SPDIF_PR_INT_EN			0x08
+#define AUD_SPDIF_PR_INT_STA			0x0c
+#define AUD_SPDIF_PR_INT_CLR			0x10
+#define AUD_SPDIF_PR_VALIDITY			0x100
+#define AUD_SPDIF_PR_USER_DATA			0x104
+#define AUD_SPDIF_PR_CHANNEL_STA_BASE		0x108
+#define AUD_SPDIF_PR_SPDIF_CTRL			0x200
+#define AUD_SPDIF_PR_SPDIF_STA			0x204
+#define AUD_SPDIF_PR_SPDIF_PAUSE		0x208
+#define AUD_SPDIF_PR_SPDIF_DATA_BURST		0x20c
+#define AUD_SPDIF_PR_SPDIF_PA_PB		0x210
+#define AUD_SPDIF_PR_SPDIF_PC_PD		0x214
+#define AUD_SPDIF_PR_SPDIF_CL1			0x218
+#define AUD_SPDIF_PR_SPDIF_CR1			0x21c
+#define AUD_SPDIF_PR_SPDIF_SUV			0x220
+
+#define PR_CFG_DEVICE_ENABLE			(1L<<0)
+#define PR_CFG_CONV_SW_RESET			(1L<<1)
+#define PR_CFG_FIFO_ENABLE			(1L<<2)
+#define PR_CFG_WORD_SZ_16BIT			(0L<<3)
+#define PR_CFG_WORD_SZ_20BIT			(1L<<3)
+#define PR_CFG_WORD_SZ_24BIT			(2L<<3)
+#define PR_CFG_REQ_ACK_ENABLE			(1L<<5)
+
+
+#define PR_PD_PAUSE_BURST_INT			(1L<<31)
+#define PR_AUDIO_SAMPLES_FULLY_READ_INT		(1L<<22)
+#define PR_PD_DATA_BURST_INT			(1L<<21)
+#define PR_LATENCY_INT				(1L<<20)
+#define PR_EOBLOCK_INT				(1L<<19)
+#define PR_EODATABURST_INT			(1L<<18)
+#define PR_UNDERFLOW_INT			(1L<<17)
+#define PR_RUN_STOP_INT				(1L<<16)
+#define PR_I2S_FIFO_OVERRUN_INT			(1L<<8)
+#define PR_CHLL_STS_UNDERRUN_INT		(1L<<7)
+#define PR_CHLL_STS_EMPTY_INT			(1L<<6)
+#define PR_USER_DATA_UNDERRUN_INT		(1L<<5)
+#define PR_USER_DATA_EMPTY_INT			(1L<<4)
+#define PR_VALIDITY_UNDERRUN_INT		(1L<<3)
+#define PR_VALIDITY_EMPTY_INT			(1L<<2)
+#define PR_SOFT_RESET_INT_ENABLE		(1L<<1)
+#define PR_INTERRUPT_ENABLE			(1L<<0)
+
+
+#define PR_CTRL_OFF				0
+#define PR_CTRL_MUTE_PCM_NULL_DATA		1
+#define PR_CTRL_MUTE_PAUSE_BURST		2
+#define PR_CTRL_AUDIO_DATA_MODE			3
+#define PR_CTRL_16BIT_DATA_NOROUND		0
+#define PR_CTRL_16BIT_DATA_ROUND		(1L<<4)
+#define PR_CTRL_SW_STUFFING			0
+#define PR_CTRL_HW_STUFFING			(1L<<14)
+#define PR_CTRL_SAMPLES_SHIFT			15
+
+#endif /*STB7100_SND_H_*/
+
+static int stb7100_spdif_card_probe(stm_snd_output_device_t *dev);
+static int stb7100_create_converter_device(pcm_hw_t *chip,snd_card_t *this_card);
+static int stb7100_converter_program_player(snd_pcm_substream_t *substream);
+static void stb7100_reset_pcm_player(pcm_hw_t *chip);
diff -Naur linux-2.6.17.8/sound/stm/stb7100_spdif.c linux-2.6.17.8-sh/sound/stm/stb7100_spdif.c
--- linux-2.6.17.8/sound/stm/stb7100_spdif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/stb7100_spdif.c	2006-08-23 13:29:51.083876000 +0100
@@ -0,0 +1,535 @@
+/*
+ *  STb7100 SPDIF player setup
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <asm/dma.h>
+#include <asm/cacheflush.h>
+
+#if (STM_USE_BIGPHYS_AREA == 0)
+#define SPDIF_MAX_FRAMES	((128*1024)/8)  /* <128k, max slab allocation */
+#else
+#define SPDIF_MAX_FRAMES	48000           /* 1s @ 48KHz */
+#endif
+
+/*
+ * Default HW template for SPDIF player.
+ */
+static snd_pcm_hardware_t stb7100_spdif_hw =
+{
+	.info =		(SNDRV_PCM_INFO_INTERLEAVED |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	(SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE),
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 48000,
+	.channels_min	  = 2,
+	.channels_max	  = 2,
+	.buffer_bytes_max = FRAMES_TO_BYTES(SPDIF_MAX_FRAMES,2),
+	.period_bytes_min = FRAMES_TO_BYTES(1,2),
+	.period_bytes_max = FRAMES_TO_BYTES(SPDIF_MAX_FRAMES,2),
+	.periods_min	  = 1,
+	.periods_max	  = SPDIF_MAX_FRAMES
+};
+
+
+static inline void reset_spdif_on(pcm_hw_t  *chip)
+{
+	writel(1,chip->pcm_player);
+}
+
+static inline void reset_spdif_off(pcm_hw_t  *chip)
+{
+	writel(0,chip->pcm_player);
+}
+
+static void stb7100_iec61937_deferred_unpause(pcm_hw_t * chip)
+{
+	spin_lock(&chip->lock);
+	writel(SPDIF_INT_STATUS_EOPD ,chip->pcm_player +STM_PCMP_IRQ_EN_CLR);
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+	chip->iec61937.pause_count=0;
+	/*throw an xrun to flush the buffer of invalidated data bursts and re-align the
+	 * next burst with a block boundary*/
+	snd_pcm_kernel_ioctl(chip->current_substream, SNDRV_PCM_IOCTL_XRUN, NULL);
+}
+
+static irqreturn_t stb7100_spdif_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long int_status;
+	pcm_hw_t *stb7100 = dev_id;
+	irqreturn_t status =IRQ_NONE;;
+	/* Read and clear interrupt status */
+	spin_lock(&stb7100->lock);
+	int_status = readl(stb7100->pcm_player + STM_PCMP_IRQ_STATUS);
+	writel(int_status,stb7100->pcm_player + STM_PCMP_ITS_CLR);
+	spin_unlock(&stb7100->lock);
+
+	if((int_status & SPDIF_INT_STATUS_ALLREAD) == SPDIF_INT_STATUS_ALLREAD ){
+		snd_pcm_period_elapsed(stb7100->current_substream);
+		status =  IRQ_HANDLED;
+	}
+	if((int_status & SPDIF_INT_STATUS_EOLATENCY) == SPDIF_INT_STATUS_EOLATENCY){
+		status =  IRQ_HANDLED;
+	}
+	if((int_status & SPDIF_INT_STATUS_EOPD) == SPDIF_INT_STATUS_EOPD){
+
+		stb7100->iec61937.pause_count = ((stb7100->iec61937.pause_count+1)
+						%stb7100->iec61937.frame_size);
+
+		/*we have to wait until we have completed an entire iec91637 burst length
+		 * before we stop emitting bursts, so we have to wait for mod(iec61937_frame_size)*/
+		if((stb7100->iec61937.pause_count==0) && (stb7100->iec61937.unpause_flag==1)){
+			stb7100->iec61937.unpause_flag=0;
+			stb7100_iec61937_deferred_unpause(stb7100);
+		}
+		status =  IRQ_HANDLED;
+	}
+	return status;
+}
+
+
+static inline void stb7100_spdif_pause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if (chip->iec_encoding_mode != ENCODING_IEC60958) {
+		/*here we turn on iec61937 pause bursts, modulated by the
+		 * frames of latency value*/
+		chip->iec61937.pause_count = chip->iec60958_output_count;
+		chip->iec60958_output_count=0;
+		writel(chip->irq_mask | SPDIF_INT_STATUS_EOPD,chip->pcm_player+STM_PCMP_IRQ_EN_SET);
+    	}
+
+	spin_lock(&chip->lock);
+	writel((chip->pcmplayer_control|chip->iec61937.pause_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+
+}
+
+
+static inline void stb7100_spdif_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	/*we are doing pause burst, must count %frame_size*/
+
+	if(chip->iec_encoding_mode != ENCODING_IEC60958){
+		/*first we need to check if pause burst are enable,
+		 * otherwise we will deadlock here
+		 * */
+		if(readl(chip->pcm_player+STM_PCMP_IRQ_ENABLE) & ENABLE_INT_EOPD){
+			chip->iec61937.unpause_flag=1;
+			return;
+		}
+
+	}
+
+	spin_lock(&chip->lock);
+
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),
+		chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static inline void stb7100_spdif_start_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	chip->hwbuf_current_addr = 0;
+	dma_xfer(chip->fdma_channel);
+
+	spin_lock(&chip->lock);
+	reset_spdif_off(chip);
+	writel((chip->pcmplayer_control|chip->spdif_player_mode),chip->pcm_player + STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+
+}
+
+
+static inline void stb7100_spdif_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	spin_lock(&chip->lock);
+	writel(0,chip->pcm_player+STM_PCMP_CONTROL);
+	reset_spdif_on(chip);
+	spin_unlock(&chip->lock);
+	dma_stop_channel(chip->fdma_channel);
+}
+
+
+static void stb7100_spdif_set_iec_mode(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned int decode_lat=0;
+	unsigned int rate =substream->runtime->rate;
+
+	switch(	chip->iec_encoding_mode){
+
+		case ENCODING_IEC61937_AC3:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep =3;
+			chip->iec61937.latency=256;
+			chip->iec61937.frame_size=1536;
+			break;
+		case ENCODING_IEC61937_DTS_1:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=768;
+			chip->iec61937.frame_size=512;
+			break;
+		case ENCODING_IEC61937_DTS_2:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=1280;
+			chip->iec61937.frame_size=1024;
+			break;
+		case ENCODING_IEC61937_DTS_3:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 3;
+			chip->iec61937.latency=2304;
+			chip->iec61937.frame_size=2048;
+			break;
+			{
+		case ENCODING_IEC61937_MPEG_384_FRAME:
+			chip->iec61937.frame_size = 384;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_1152_FRAME:
+			chip->iec61937.frame_size = 1152;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_1024_FRAME:
+			chip->iec61937.frame_size = 1024;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_2304_FRAME:
+			chip->iec61937.frame_size = 2304;
+			goto generic_mpeg_encoding;
+		case ENCODING_IEC61937_MPEG_768_FRAME:
+			chip->iec61937.frame_size = 768;
+			/*fallthrough*/
+generic_mpeg_encoding:
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 32;
+			switch(rate){
+				case 32000:
+					decode_lat = MPEG_DECODE_LAT_32KHZ;
+					break;
+				case 44100:
+					decode_lat = MPEG_DECODE_LAT_441KHZ;
+					break;
+				case 48000:
+					decode_lat = MPEG_DECODE_LAT_48KHZ;
+					break;
+				default:
+					printk("%s Unsupported Sample Freq\n",__FUNCTION__);
+					break;
+			}
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+			}
+		case ENCODING_IEC61937_MPEG_2304_FRAME_LSF:
+			chip->iec61937.frame_size=2304;
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 64;
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+		case ENCODING_IEC61937_MPEG_768_FRAME_LSF:
+			chip->iec61937.frame_size=768;
+			chip->iec61937.pause_mode=SPDIF_MUTE_BURST;
+			chip->iec61937.mute_rep = 64;
+			chip->iec61937.latency=TIME_TO_FRAMES(rate,decode_lat);
+			break;
+		default:
+			printk("%s unrecognised IEC61937 mode\n",__FUNCTION__);
+			/*fallthorugh*/
+		case ENCODING_IEC60958:
+			chip->iec61937.pause_mode=SPDIF_MUTE_NULL_DATA;
+			chip->iec61937.mute_rep =1;
+			chip->iec61937.latency=256;
+			break;
+	}
+}
+
+
+static int stb7100_program_spdifplayer(snd_pcm_substream_t *substream){
+
+	unsigned long reg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	u32 val=0;
+	unsigned long flags=0;
+	u32 irq_enable = ENABLE_INT_NSAMPLE;
+
+	reg =(runtime->period_size * runtime->channels) << SPDIF_SAMPLES_SHIFT;
+
+	reg |= SPDIF_SW_STUFFING | SPDIF_BIT16_DATA_NOROUND;
+
+	spin_lock_irqsave(&chip->lock,flags);
+	switch(chip->oversampling_frequency)
+	{
+		case 128:
+			reg |= SPDIF_FSYNTH_DIVIDE32_128;
+			break;
+		case 256:
+			reg |= SPDIF_FSYNTH_DIVIDE32_256;
+			break;
+		default:
+			printk("stb7100_program_spdifplayer: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+			break;
+	}
+
+	reset_spdif_on(chip);
+	reset_spdif_off(chip);
+
+	/*
+	 * Setup channel status bits for the hardware mode and prepare for
+	 * starting a new data burst. Also setup the hardware pause burst
+	 * registers with the channel status as well.
+	 */
+	chip->pending_spdif_control = chip->default_spdif_control;
+	iec60958_set_runtime_status(substream);
+	chip->iec60958_output_count = 0;
+	stb7100_spdif_set_iec_mode(substream);
+
+	val = chip->pending_spdif_control.channel.status[0]	   |
+	      (chip->pending_spdif_control.channel.status[1] <<8)  |
+	      (chip->pending_spdif_control.channel.status[2] <<16) |
+	      (chip->pending_spdif_control.channel.status[3] <<24);
+
+	writel(val, chip->pcm_player + AUD_SPDIF_CL1);
+	writel(val, chip->pcm_player + AUD_SPDIF_CR1);
+
+	val = chip->pending_spdif_control.channel.status[4];
+	val |= (val << 8); /* Right channel status always = left channel status */
+	writel(val, chip->pcm_player + AUD_SPDIF_CL2_CR2_UV);
+
+	/*enable the latency irq*/
+	if(get_spdif_syncing_status()){
+		irq_enable |= ENABLE_INT_EOLATENCY;
+		chip->spdif_player_mode = SPDIF_ENCODED_ON;
+	}
+	if(chip->iec_encoding_mode != ENCODING_IEC60958){
+
+		int pause_data_type=-0;
+		reg |= SPDIF_HW_STUFFING;
+		switch(chip->iec_encoding_mode){
+			case ENCODING_IEC61937_AC3:
+				pause_data_type	= IEC61937_AC3_STREAM;
+				break;
+			case ENCODING_IEC61937_DTS_1:
+				pause_data_type	= IEC61937_DTS_TYPE_1;
+				break;
+			case ENCODING_IEC61937_DTS_2:
+				pause_data_type= IEC61937_DTS_TYPE_2;
+				break;
+			case ENCODING_IEC61937_DTS_3:
+				pause_data_type= IEC61937_DTS_TYPE_3;
+				break;
+			default:
+				printk("%s Uncrecognised Encoded Data Stream %d\n",
+					__FUNCTION__,chip->iec_encoding_mode);
+				break;
+		}
+		val = chip->iec61937.mute_rep & 0x0000ffff;
+		writel(val,chip->pcm_player + AUD_SPDIF_FRA_LEN_BST);
+
+		val = (IEC61937_PA <<16)| IEC61937_PB ;
+		writel(val ,chip->pcm_player +AUD_SPDIF_PA_PB );
+
+		val = 	(pause_data_type <<16) | chip->iec61937.mute_rep;
+		writel(val,chip->pcm_player +AUD_SPDIF_PC_PD);
+
+		chip->spdif_player_mode = SPDIF_ENCODED_ON;
+	}
+	else{
+		reg |= SPDIF_SW_STUFFING;
+		chip->spdif_player_mode =SPDIF_ENCODED_ON;
+	}
+
+	val =((chip->iec61937.mute_rep <<16) |
+			(chip->iec61937.latency & 0x0000ffff)) ;
+	writel(val,chip->pcm_player + AUD_SPDIF_PAU_LAT);
+
+	chip->pcmplayer_control = reg;
+	chip->irq_mask = irq_enable;
+	writel(chip->irq_mask,chip->pcm_player +STM_PCMP_IRQ_EN_SET);
+	spin_unlock_irqrestore(&chip->lock,flags);
+
+	return 0;
+}
+
+
+static int stb7100_spdif_program_hw(snd_pcm_substream_t *substream)
+{
+	int err;
+	if((err = stb7100_program_fsynth(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_spdifplayer(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_fdma(substream)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int stb7100_spdif_open(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+
+	if(chip->iec60958_rawmode)
+	{
+		runtime->hw.info   |= SNDRV_PCM_INFO_MMAP;
+		runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE; /* Only 32bit in RAW mode */
+	}
+
+	return 0;
+}
+
+
+static stm_playback_ops_t stb7100_spdif_ops = {
+	.free_device      = stb7100_pcm_free,
+	.open_device      = stb7100_spdif_open,
+	.program_hw       = stb7100_spdif_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_spdif_start_playback,
+	.stop_playback    = stb7100_spdif_stop_playback,
+	.pause_playback   = stb7100_spdif_pause_playback,
+	.unpause_playback = stb7100_spdif_unpause_playback
+};
+
+
+static int stb7100_spdif_create(snd_card_t *card,stm_snd_output_device_t *dev_data)
+{
+	int err=0;
+	unsigned long reg=0;
+	pcm_hw_t *chip=0;
+
+	static snd_device_ops_t ops = {
+		.dev_free = snd_pcm_dev_free,
+	};
+
+	if((chip = kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	if(!card)
+		return -EINVAL;
+
+	spin_lock_init(&chip->lock);
+
+	chip->fdma_channel = request_dma(5,"STB7100_SPDIF_DMA");
+	chip->card         = card;
+	chip->irq          = -1;
+	chip->card_data    = dev_data;
+	chip->hw           = stb7100_spdif_hw;
+	chip->oversampling_frequency = 128; /* This is for HDMI compatibility */
+
+	chip->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	chip->out_pipe      = ioremap(FDMA2_BASE_ADDRESS, 0);
+	chip->pcm_player    = ioremap(SPDIF_BASE,0);
+
+	chip->playback_ops  = &stb7100_spdif_ops;
+
+	iec60958_default_channel_status(chip);
+	chip->iec_encoding_mode = ENCODING_IEC60958;
+
+	/*
+	 * Set all the audio pins to be outputs
+	 */
+
+	reg =	PCM_DATA_OUT << PCM_CLK_OUT |
+		PCM_DATA_OUT << PCM0_OUT    |
+		PCM_DATA_OUT << PCM1_OUT    |
+		PCM_DATA_OUT << SPDIF_ENABLE;
+
+	writel(reg,chip->pcm_clock_reg+AUD_IO_CTL_REG);
+
+	if(request_irq(LINUX_SPDIFPLAYER_ALLREAD_IRQ,
+                       stb7100_spdif_interrupt, SA_INTERRUPT,
+                       "STB7100 SPDIF Player",(void*)chip))
+	{
+		DEBUG_PRINT((">>> failed to get IRQ\n"));
+		stb7100_pcm_free(chip);
+		return -EBUSY;
+	}
+	else
+		chip->irq = LINUX_SPDIFPLAYER_ALLREAD_IRQ;
+
+	if ((err = snd_card_pcm_allocate(chip, chip->card_data->minor, card->longname)) < 0){
+		printk(">>> failed to create PCM stream\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_iec60958_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if((err = snd_generic_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0){
+		printk(">>> creating sound device failed\n");
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	return 0;
+}
+
+
+static int __init stb7100_spdif_card_probe(stm_snd_output_device_t *dev_data)
+{
+	snd_card_t *card;
+	int err;
+
+	card = snd_card_new(index[dev_data->major],id[dev_data->major], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	sprintf(card->driver,   "%d",dev_data->major);
+	strcpy(card->shortname, "STb7100_SPDIF");
+	/*-2 on dev num as we are assuming 2 pcm outputs initialised before the spdif*/
+	sprintf(card->longname, "STb7100_SPDIF%d",dev_data->major -2);
+
+	if ((err = stb7100_spdif_create(card, dev_data)) < 0){
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	return 0;
+}
diff -Naur linux-2.6.17.8/sound/stm/stm7100_pcm.c linux-2.6.17.8-sh/sound/stm/stm7100_pcm.c
--- linux-2.6.17.8/sound/stm/stm7100_pcm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/stm7100_pcm.c	2006-08-23 13:29:50.391875000 +0100
@@ -0,0 +1,943 @@
+/*
+ *  STb7100 PCM Player Sound Driver
+ *  Copyright (c)   (c) 2005 STMicroelectronics Limited
+ *
+ *  *  Authors:  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/delay.h>
+
+#define STb7100_SYSCFG_BASE         0x19001000
+
+static unsigned long pcm_base_addr[SND_DRV_CARDS] =
+{
+	PCMP0_BASE,
+	PCMP1_BASE,
+	SPDIF_BASE,
+	PCM0_CONVERTER_BASE
+};
+
+static unsigned long linux_pcm_irq[SND_DRV_CARDS] =
+{
+	LINUX_PCMPLAYER0_ALLREAD_IRQ,
+	LINUX_PCMPLAYER1_ALLREAD_IRQ,
+        LINUX_SPDIFPLAYER_ALLREAD_IRQ,
+        LINUX_SPDIFCONVERTER_ALLREAD_IRQ,
+};
+/*here we specify the paced channel id's for the pcm players*/
+static unsigned long fdma_bus_req_id[SND_DRV_CARDS] =
+{
+	26,/* PCM0 */
+	27, /* PCM1 */
+	29, /* SPDIF*/
+        26    /*PROTOCOL CONVERTER PIGGY_BACKS on PCM0*/
+};
+
+/*
+ * Extra PCM Player format regsiter define for 7100 Cut2/3
+ */
+#define PCMP_CHANNELS_SHIFT     (8)
+/*
+ * On Cut2/3 7100 DMA requests can be triggered when 2,4,6,8 or 10 cells
+ * are available in the PCMP Player FIFO. For the moment pick the middle
+ * value.
+ */
+#define PCMP_DREQ_TRIGGER       (6L)
+#define PCMP_DREQ_TRIGGER_SHIFT (12)
+
+#define AUD_ADAC_CTL_REG		0x100
+#define AUD_IO_CTL_REG			0x200
+
+/*
+ * AUD_ FSYNTH_CFG control vals
+ */
+#define AUD_FSYNTH_SATA_PHY_30MHZ_REF		(0<<23)
+#define AUD_FSYNTH_SYSBCLKINALT_REF		(1<<23)
+#define AUD_FSYNTH_VGOOD_REF_SOURCE		(0<<16)
+#define AUD_FSYNTH_GOOD_REF_SOURCE		(1<<16)
+#define AUD_FSYNTH_BAD_REF_SOURCE		(2<<16)
+#define AUD_FSYNTH_VBAD_REF_SOURCE		(3<<16)
+#define AUD_FSYNTH_FS_REF_CLK_27_30MHZ		(0<<15)
+#define AUD_FSYNTH_FS_REF_CLK_54_60MHZ		(1<<15)
+#define AUD_FSYNTH_NPDA_POWER_DOWN		(0<<14)
+#define AUD_FSYNTH_NPDA_POWER_UP		(1<<14)
+
+#define AUD_FSYNTH_UNKNOWN_STANDBY		(0<<13)
+#define AUD_FSYNTH_UNKNOWN_ACTIVE		(1<<13)
+#define AUD_FSYNTH_FSYNTH2_STANDBY		(0<<12)
+#define AUD_FSYNTH_FSYNTH2_ACTIVE		(1<<12)
+#define AUD_FSYNTH_FSYNTH1_STANDBY		(0<<11)
+#define AUD_FSYNTH_FSYNTH1_ACTIVE		(1<<11)
+#define AUD_FSYNTH_FSYNTH0_STANDBY		(0<<10)
+#define AUD_FSYNTH_FSYNTH0_ACTIVE		(1<<10)
+
+#define AUD_FSYNTH_RESERVED_9			(1<<9)
+#define AUD_FSYNTH_RESERVED_8			(1<<8)
+#define AUD_FSYNTH_RESERVED_7			(1<<7)
+#define AUD_FSYNTH_RESERVED_6			(1<<6)
+#define AUD_FSYNTH_RESERVED_5			(1<<5)
+
+#define AUD_FSYNTH_FSYNTH2_BYPASS		(0<<4)
+#define AUD_FSYNTH_FSYNTH2_ENABLE		(1<<4)
+#define AUD_FSYNTH_FSYNTH1_BYPASS		(0<<3)
+#define AUD_FSYNTH_FSYNTH1_ENABLE		(1<<3)
+#define AUD_FSYNTH_FSYNTH0_BYPASS		(0<<2)
+#define AUD_FSYNTH_FSYNTH0_ENABLE		(1<<2)
+#define AUD_FSYNTH_RESERVED_1			(1<<1)
+#define AUD_FSYNTH_RESET_ON			(1<<0)
+
+
+/*AUD_IO_CTL reg vals*/
+#define PCM_DATA_IN	0
+#define PCM_DATA_OUT	1
+
+#define PCM_CLK_OUT	0
+#define PCM0_OUT	1
+#define PCM1_OUT	2
+#define SPDIF_ENABLE	3
+
+/*AUD_ADAC_CTL vals*/
+
+#define DAC_NRST     0x1
+#define DAC_SOFTMUTE 0x10
+/* here we bring the dac sub-blocks out of powerdown these are
+ * -DAC BANDGAP  (bit 6)
+ * -ANALOUG PART (bit 5)
+ * -DIGITAL PART (bit 3)
+ * then we reset with bit 1
+ */
+#define DAC_POWERUP_VAL (1 << 3 | 1 <<5 | 1 <<6)
+
+
+/*here we define the block offsets for both pcm players that is fysnth0 & 1
+ * We must specify the pe/md/ and sdiv offsets
+ * */
+ typedef enum {
+ 	SDIV=0x0,
+ 	PE,
+ 	MD,
+ 	PROG_EN
+ }clk_offsets;
+
+
+ /*unfortunatley for pcm0/1 the reg offsets for the fsynth programming are different
+  * hence we select from the table according to the current output*/
+static unsigned long dev_fsynth_regs[4][SND_DRV_CARDS]= {
+			/*PCM0*/		/*PCM1*/	/*spdif*/
+/*SDIV*/	{AUD_FSYN0_SDIV,	AUD_FSYN1_SDIV,		AUD_FSYN2_SDIV},
+/*PE*/		{AUD_FSYN0_PE,		AUD_FSYN1_PE,		AUD_FSYN2_PE},
+/*MD*/		{AUD_FSYN0_MD,		AUD_FSYN1_MD,		AUD_FSYN2_MD},
+/*PROG_EN*/	{AUD_FSYN0_PROG_EN,	AUD_FSYN1_PROG_EN,	AUD_FSYN2_PROG_EN}};
+
+
+#define MEM_FULL_READIRQ	0x02
+#define SELECT_PROG_FSYN	0x01
+#define SELECT_RSTP		0x01
+#define SELECT_PCM_FSYN_CLK	(0x01 << 2)
+#define SELECT_SYSBCLKINALT	(0x01 << 23)
+
+
+static snd_pcm_hardware_t stb7100_pcm_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID     |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	(SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE),
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 |
+			 SNDRV_PCM_RATE_96000 |
+			 SNDRV_PCM_RATE_192000 ),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 192000,
+	.channels_min	  = 10,
+	.channels_max	  = 10,
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.period_bytes_min = FRAMES_TO_BYTES(1,10),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+
+/*
+ * The following FSynth programming has been provided by ST validation
+ * teams for STb7100 Cut1.3. They are for an oversampling frequency of 256*Fs.
+ *
+ *  peq is the value for a 0.001 % adjustment of the current output freq
+ *  which is defined by the forumlae in the manual.
+ */
+
+static struct stm_freq_s gClockSettings[NUM_CLOCK_SETTINGS] =
+{
+     	/*             freq(Fs) sdiv  pe      md   peq */
+	/*8.1920 == */{ 32000,  0x4, 0x5a00, 0xfd, 0xa},
+	/*11.2895Mhz*/{ 44100,  0x4, 0x5EE9, 0xF5 ,0x7},
+	/*12.2880MHz*/{ 48000,  0x4, 0x3C00, 0xF3 ,0x7},
+	/*24.5760MHz*/{ 96000,  0x3, 0x3C00, 0xF3 ,0x6},
+	/*36.8640MHz*/{ 192000, 0x2, 0x7AAB ,0xFA, 0x8}
+};
+
+
+/*Here we can  dynamically adjust the sampling frequencies of playback on the
+ * pcm0/1 players and the SPDIF. The function allows a +/- 10 % adjustment of
+ * frequency in 0.001% increments of current playback frequency.
+ *
+ * The adjusts parm indicates the number of .001% adjustments to apply,
+ *  up to a maximum of 10000, or 10%
+ *
+ * There is an error  in the order of 1 % due to relying on integer
+ * approximations of float values, not available in the kernel.
+ * Additionally the PE solutions of the equation do not offer a linear response,
+ * here we assume a linear response and discard the remainder as error.
+ * We can never calculate the exact output frequency from this driver,
+ * so we utilise a quanta value which represents a % adjustment of each frequency
+ * */
+int adjust_audio_clock(snd_pcm_substream_t *substream,int adjusts,int dir)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	int i=0,total_shift=0;
+	unsigned long new_pe=0, peq=0,new_md=0,new_sdiv=0;
+
+	unsigned long pg_en_offset = dev_fsynth_regs[PROG_EN][chip->card_data->major];
+	unsigned long pe_offset    = dev_fsynth_regs[PE][chip->card_data->major];
+	unsigned long md_offset    = dev_fsynth_regs[MD][chip->card_data->major];
+ 	unsigned long sdiv_offset  = dev_fsynth_regs[SDIV][chip->card_data->major];
+
+	unsigned long cur_pe   = readl(chip->pcm_clock_reg + pe_offset);
+	unsigned long cur_md   = readl(chip->pcm_clock_reg + md_offset);
+	unsigned long cur_sdiv = readl(chip->pcm_clock_reg + sdiv_offset);
+
+	if( ((adjusts <=0) || (adjusts >10000)) || !substream)
+		return -EINVAL;
+
+	/*get the correct fsynth settings for FS*/
+	while(i < NUM_CLOCK_SETTINGS && runtime->rate != gClockSettings[i].freq)
+		i++;
+
+	if(!(i<=NUM_CLOCK_SETTINGS))
+		return -ENODEV;
+
+	peq = 	gClockSettings[i].pe_quantum;
+	new_md = cur_md;
+	new_pe = cur_pe;
+	new_sdiv = cur_sdiv;
+
+	if(INCR_FSYNTH == dir){
+		if(((adjusts*peq )+cur_pe) > 0xffff){
+			while(total_shift<=adjusts){
+				while(new_pe < 0xffff){
+					if(total_shift>=adjusts)
+						goto write_fsynth;
+					new_pe+=peq;
+					total_shift++;
+				}
+				/*overflow- incr the md and set the
+				 * pe down to maintain current FS*/
+				new_md--;
+				/*now we have crossed the sdiv
+				 *md is a 5 bit signed term, leaving
+				 * 1-16 available*/
+				if(new_md  < 0x10){
+					new_sdiv--;
+					new_md = 0x1f;
+					new_pe +=SDIV_SHIFT_VAL;
+				}
+				else new_pe -= MD_SHIFT_VAL;
+			}
+		}
+		else new_pe += adjusts *peq;
+
+	}
+	else if(DECR_FSYNTH == dir){
+		if( (int)(cur_pe-(adjusts*peq )) < (int)0x000){
+			while(total_shift <=adjusts){
+				while((int)new_pe > (int)0){
+					if(total_shift >= adjusts)
+						goto write_fsynth;
+					new_pe -= peq;
+					total_shift++;
+				}
+				new_md++;
+
+				if(new_md  >0x1f) {
+					new_sdiv++;
+					new_md =0x10;
+					new_pe +=SDIV_SHIFT_VAL;
+				}
+				else new_pe+=MD_SHIFT_VAL;
+			}
+		}
+		else new_pe -= adjusts * peq;
+	}
+	else return -EINVAL;
+
+
+
+write_fsynth:
+	writel(0,chip->pcm_clock_reg+pg_en_offset);
+	writel(new_pe,chip->pcm_clock_reg + pe_offset);
+	writel(new_md,chip->pcm_clock_reg + md_offset);
+	writel(new_sdiv,chip->pcm_clock_reg + sdiv_offset);
+	writel(1,chip->pcm_clock_reg+pg_en_offset);
+	return 0;
+}
+
+
+void stb7100_reset_pcm_player(pcm_hw_t  *chip)
+{
+	/* Give the pcm player a soft reset */
+	writel(1,chip->pcm_player );
+	writel(0,chip->pcm_player );
+}
+
+
+static void stb7100_reset_internal_DAC(pcm_hw_t *chip)
+{
+	writel(0,chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	writel((DAC_POWERUP_VAL|DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+}
+
+
+static void stb7100_pcm_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG) | DAC_SOFTMUTE;
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		udelay(100);
+		reg = reg & ~DAC_NRST; /* Reset active low */
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	}
+
+	/*
+	 * Disable PCM Player IRQ, this is important when switching
+	 * between PCM0 and the protocol converter as there is
+	 * nowhere else to turn the interrupts off, and the
+	 * PCM0 interrupt will fire with the wrong card structure!
+	 */
+	writel(MEM_FULL_READIRQ, chip->pcm_player + STM_PCMP_IRQ_EN_CLR);
+
+	/*
+	 * We use "mute" to stop the PCM player, which in fact is implemented
+	 * as a pause, rather than "off" becuase it keeps the L/R clocks
+	 * running to the DACs. This avoids noise on the analogue output
+	 * and occasional DAC failures, due to the DACs being intolerant of
+	 * losing their clocks unless in reset or powerdown modes. At the
+	 * moment we have no control over external DACs in this code.
+	 *
+	 * Note: the internal DAC doesn't absolutely need this (as it
+	 * can be reset).
+	 */
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+	dma_stop_channel(chip->fdma_channel);
+}
+
+
+static void stb7100_pcm_start_playback(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t     *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	dma_xfer(chip->fdma_channel);
+
+	spin_lock(&chip->lock);
+
+	/*
+	 * We appear to need to reset the PCM player otherwise we end up
+	 * with channel data sent to the wrong channels when starting up for
+	 * the second time.
+	 */
+	stb7100_reset_pcm_player(chip);
+
+	writel((chip->pcmplayer_control | PCMP_ON), chip->pcm_player + STM_PCMP_CONTROL);
+
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG) | DAC_NRST; /* Bring DAC out of Reset */
+		writel(reg, chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		udelay(100);
+		writel((reg & ~DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG); /* Unmute */
+	}
+
+	spin_unlock(&chip->lock);
+}
+
+
+static void stb7100_pcm_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+        spin_lock(&chip->lock);
+	if(chip->card_data->major == PCM1_DEVICE){
+		reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+		writel((reg & ~DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+        }
+
+	writel((chip->pcmplayer_control|PCMP_ON),chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+
+static void stb7100_pcm_pause_playback(snd_pcm_substream_t *substream)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long reg=0;
+
+	spin_lock(&chip->lock);
+	if(chip->card_data->major == PCM1_DEVICE){
+	        reg = readl(chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	        writel((reg | DAC_SOFTMUTE),chip->pcm_clock_reg+AUD_ADAC_CTL_REG);
+	}
+	writel((chip->pcmplayer_control|PCMP_MUTE),chip->pcm_player+STM_PCMP_CONTROL);
+	spin_unlock(&chip->lock);
+}
+
+static snd_pcm_uframes_t stb7100_fdma_playback_pointer(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	/*
+	 * Calculate our current playback position, using the number of bytes
+	 * left for the DMA engine needs to transfer to complete a full
+	 * iteration of the buffer. This is common to all STb7100 audio players
+	 * using the FDMA (including SPDIF).
+	 */
+	u32 pos = substream->runtime->dma_bytes - get_dma_residue(chip->fdma_channel);
+	return bytes_to_frames(substream->runtime,pos);
+}
+
+
+static irqreturn_t stb7100_pcm_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+	pcm_hw_t *stb7100 = dev_id;
+
+	/* Read and clear interrupt status */
+	spin_lock(&stb7100->lock);
+	val = readl(stb7100->pcm_player + STM_PCMP_IRQ_STATUS);
+	writel(val,stb7100->pcm_player + STM_PCMP_ITS_CLR);
+	spin_unlock(&stb7100->lock);
+
+	if((val & PCMP_INT_STATUS_ALLREAD) == PCMP_INT_STATUS_ALLREAD){
+		/* Inform higher layer that we have completed a period */
+		snd_pcm_period_elapsed(stb7100->current_substream);
+
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+
+static int stb7100_program_fdma(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t          *chip    = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct dma_channel* pcm_channel;
+	int bus_req_id = fdma_bus_req_id[chip->card_data->major];
+	unsigned long flags=0;
+	int err=0;
+
+	if(!chip->out_pipe || ! chip->pcm_player)
+		return -EINVAL;
+
+	spin_lock_irqsave(&chip->lock,flags);
+
+	chip->buffer_start_addr = (unsigned long)runtime->dma_addr;
+
+	pcm_channel = get_dma_channel(chip->fdma_channel);
+	if(!pcm_channel){
+		err =  -EIO;
+		goto exit;
+	}
+
+	pcm_channel->comp_callback = 0;
+	pcm_channel->err_callback  = 0;
+	pcm_channel->mode          = MODE_PACED;
+	pcm_channel->count         = snd_pcm_lib_buffer_bytes(substream);
+	pcm_channel->sar           = runtime->dma_addr;
+	pcm_channel->dar           = virt_to_phys(chip->pcm_player+STM_PCMP_DATA_FIFO);
+
+	pcm_channel->list_len      = 1;
+	pcm_channel->flags         = bus_req_id
+				   | DIM_1_x_0
+                                   | LIST_TYPE_LINKED
+                                   | CALLBACK_CONTEXT_INTERRUPT;
+	err = dma_configure_channel(pcm_channel);
+exit:
+	spin_unlock_irqrestore(&chip->lock,flags);
+	return err;
+}
+
+
+static int stb7100_program_fsynth(snd_pcm_substream_t *substream)
+{
+	int i;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+        unsigned long flags=0;
+        int err=0, dev_num=0,sdiv=0;
+
+	spin_lock_irqsave(&chip->lock,flags);
+        dev_num = chip->card_data->major == PROTOCOL_CONVERTER_DEVICE ?
+        			0:
+        			chip->card_data->major;
+
+	if(! runtime->rate  || ! chip->pcm_clock_reg){
+		err= -EINVAL;
+		goto exit;
+	}
+
+	else for(i=0; i < NUM_CLOCK_SETTINGS; i++) {
+		if (runtime->rate == gClockSettings[i].freq){
+
+			writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+
+                        /*if we are using the PCM converter we require a divisor of 128 not 256
+                           therefore our SDIV must be incremented to account for this
+                         */
+			switch(chip->oversampling_frequency){
+				case 128:
+					/*
+					 * FSynth setting are for 256xFs, adding
+					 * one to sdiv changes this to 128xFs
+					 */
+					sdiv = gClockSettings[i].sdiv_val +1;
+					break;
+				case 256:
+					sdiv = gClockSettings[i].sdiv_val;
+					break;
+				default:
+					printk("snd_pcm_program_freq: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+					err= -EINVAL;
+					goto exit;
+			}
+
+                        writel(sdiv,chip->pcm_clock_reg +dev_fsynth_regs[SDIV][dev_num]);
+
+			writel(gClockSettings[i].md_val ,
+				chip->pcm_clock_reg + dev_fsynth_regs[MD][dev_num]);
+
+			writel(gClockSettings[i].pe_val,
+				chip->pcm_clock_reg + dev_fsynth_regs[PE][dev_num]);
+
+			writel(SELECT_PROG_FSYN,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+			writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev_num]);
+			err = 0;
+			goto exit;
+		}
+	}
+	err =  -1;
+exit:
+	spin_unlock_irqrestore(&chip->lock,flags);
+	return err;
+
+}
+
+
+static int stb7100_program_pcmplayer(snd_pcm_substream_t *substream)
+{
+	unsigned long ctrlreg, fmtreg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t          *chip = snd_pcm_substream_chip(substream);
+	unsigned long flags=0;
+
+
+	fmtreg = PCMP_FORMAT_32  | PCMP_ALIGN_START       | PCMP_MSB_FIRST  |
+		 PCMP_CLK_RISING | PCMP_LRLEVEL_LEFT_HIGH | PCMP_PADDING_ON;
+
+	ctrlreg = (runtime->period_size * runtime->channels) << PCMP_SAMPLES_SHIFT;
+
+
+	/*
+	 * The PCM data format is set to be I2S.
+	 * External DACs must be configured to expect this format and
+	 * an oversampling frequency of 256*Fs. Please see the documentation
+	 * on http://www.stlinux.com for board configuration information.
+	 *
+         * Except when we are running the PCM0 with the spdif converter, in
+         * which case the HDMI expects an oversampling frequency of 128*FS,
+         * as defined in the spec.
+         */
+
+        ctrlreg |= PCMP_NO_ROUNDING;
+
+        if(runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
+		ctrlreg |= PCMP_MEM_FMT_16_16;
+		fmtreg  |= PCMP_LENGTH_16;
+        } else {
+		ctrlreg |= PCMP_MEM_FMT_16_0;
+		fmtreg  |= PCMP_LENGTH_24;
+        }
+
+
+	/*
+	 * Note that the frequency divide is the same for both 32bit and 16bit
+	 * data input, because the number of _output_ bits per subframe is
+	 * always 32.
+	 */
+	spin_lock_irqsave(&chip->lock,flags);
+	switch(chip->oversampling_frequency){
+		case 128:
+			ctrlreg |= PCMP_FSYNTH_DIVIDE32_128;
+			break;
+		case 256:
+			ctrlreg |= PCMP_FSYNTH_DIVIDE32_256;
+			break;
+		default:
+			printk("snd_pcm_program_pcmplayer: unsupported oversampling frequency %d\n",chip->oversampling_frequency);
+			break;
+	}
+
+	if(PROTOCOL_CONVERTER_DEVICE==chip->card_data->major){
+		/*this call will result in a reset and sleep of the
+		 * converter, so we abandon locks now.*/
+	 	spin_unlock_irqrestore(&chip->lock,flags);
+		stb7100_converter_program_player(substream);
+		spin_lock_irqsave(&chip->lock,flags);
+	}
+
+	if(get_spdif_syncing_status()==SPDIF_SYNC_MODE_ON)
+		ctrlreg |= PCMP_WAIT_SPDIF_LATENCY;
+	else
+		ctrlreg |= PCMP_IGNORE_SPDIF_LATENCY;
+
+
+	chip->pcmplayer_control = ctrlreg;
+
+
+        /*
+         * The 7100 cut2/3 can use 1-5 stereo channels, cut1.3 is like the
+         * stm8000 and is fixed to 5 stereo channels.
+         */
+	fmtreg |= (runtime->channels/2) << PCMP_CHANNELS_SHIFT;
+	fmtreg |= PCMP_DREQ_TRIGGER << PCMP_DREQ_TRIGGER_SHIFT;
+	writel(fmtreg, chip->pcm_player + STM_PCMP_FORMAT);
+
+	/*enable the allread irq - but only for the pcm players, the pcm
+	 * converter takes this interrupt during I2s->IEC60958 mode*/
+	if(PROTOCOL_CONVERTER_DEVICE != chip->card_data->major){
+		writel(MEM_FULL_READIRQ,chip->pcm_player + STM_PCMP_IRQ_EN_SET);
+	}
+	spin_unlock_irqrestore(&chip->lock,flags);
+	return 0;
+}
+
+
+static int stb7100_pcm_program_hw(snd_pcm_substream_t *substream)
+{
+	int err=0;
+	if((err = stb7100_program_fsynth(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_pcmplayer(substream)) < 0)
+		return err;
+
+	if((err = stb7100_program_fdma(substream)) < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int stb7100_pcm_free(pcm_hw_t *card)
+{
+	writel(PCMP_OFF, card->pcm_player + STM_PCMP_CONTROL);
+
+	free_dma(card->fdma_channel);
+
+	iounmap(card->pcm_clock_reg);
+	iounmap(card->out_pipe);
+	iounmap(card->pcm_player);
+
+	if(card->irq > 0)
+		free_irq(card->irq,(void *)card);
+
+	kfree(card);
+
+	return 0;
+}
+
+
+static void set_default_device_clock(pcm_hw_t * chip)
+{
+/*
+ * Set a default clock frequency running for each device. Not doing this
+ * can lead to clocks not starting correctly later, for reasons that
+ * cannot be explained at this time.
+ */
+
+ /*the protocol converter clocks from the pcm0 clock(fsynth0)*/
+ 	int dev = (PROTOCOL_CONVERTER_DEVICE == chip->card_data->major) ?
+ 					0:
+ 					chip->card_data->major;
+
+	writel(0,chip->pcm_clock_reg +dev_fsynth_regs[PROG_EN][dev]);
+
+        writel(gClockSettings[0].sdiv_val ,
+               chip->pcm_clock_reg +dev_fsynth_regs[SDIV][dev]);
+
+        writel(gClockSettings[0].md_val ,
+               chip->pcm_clock_reg + dev_fsynth_regs[MD][dev]);
+
+        writel(gClockSettings[0].pe_val,
+               chip->pcm_clock_reg + dev_fsynth_regs[PE][dev]);
+
+        writel(SELECT_PROG_FSYN,chip->pcm_clock_reg +
+               dev_fsynth_regs[PROG_EN][dev]);
+
+        writel(0,chip->pcm_clock_reg +
+               dev_fsynth_regs[PROG_EN][dev]);
+        writel(0,chip->pcm_player + STM_PCMP_CONTROL);
+}
+
+
+static void stb7100_pcm0_create(pcm_hw_t *stb7100)
+{
+	unsigned long reg;
+	/*
+	 * Do a one time setup of the audio clock system
+	 *
+	 * First put the audio FSynth block into reset
+	 */
+	reg =	AUD_FSYNTH_SATA_PHY_30MHZ_REF	|
+		AUD_FSYNTH_VGOOD_REF_SOURCE	|
+		AUD_FSYNTH_FS_REF_CLK_27_30MHZ	|
+		AUD_FSYNTH_NPDA_POWER_UP	|
+		AUD_FSYNTH_FSYNTH2_ACTIVE	|
+		AUD_FSYNTH_FSYNTH1_ACTIVE	|
+		AUD_FSYNTH_FSYNTH0_ACTIVE	|
+		/*
+		 * Each of these reserved bits relates to one of the
+		 * Fsynth's (6-0 7-1 8-2).  However at the present time
+		 * they are not documented.  The datasheets
+		 * are currently being updated.  Each must be set to
+		 * enable correct playback at 256Khz DAC freq */
+		AUD_FSYNTH_RESERVED_6		|
+		AUD_FSYNTH_RESERVED_7		|
+		AUD_FSYNTH_RESERVED_8		|
+		AUD_FSYNTH_FSYNTH2_ENABLE	|
+		AUD_FSYNTH_FSYNTH1_ENABLE	|
+		AUD_FSYNTH_FSYNTH0_ENABLE;
+
+	writel((reg | AUD_FSYNTH_RESET_ON),stb7100->pcm_clock_reg);
+	/*
+	 * Now bring it out of reset, powering up the analogue
+	 * part and bringing the digital parts out of standby.
+	 */
+	writel(reg,stb7100->pcm_clock_reg);
+
+	/*
+	 * Set all the audio pins to be outputs
+	 */
+	reg =	PCM_DATA_OUT << PCM_CLK_OUT |
+		PCM_DATA_OUT << PCM0_OUT    |
+		PCM_DATA_OUT << PCM1_OUT    |
+		PCM_DATA_OUT << SPDIF_ENABLE;
+
+	writel(reg,stb7100->pcm_clock_reg+AUD_IO_CTL_REG);
+}
+
+
+static unsigned int stb7100_pcm_channels[] = { 2,4,6,8,10 };
+
+
+static snd_pcm_hw_constraint_list_t stb7100_constraints_channels = {
+		.count = ARRAY_SIZE(stb7100_pcm_channels),
+		.list = stb7100_pcm_channels,
+		.mask = 0
+};
+
+
+static int stb7100_pcm_open(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	void              *syscfg;
+        unsigned long      chiprev;
+        int                err;
+
+	syscfg = ioremap(STb7100_SYSCFG_BASE,sizeof(unsigned long));
+	if(!syscfg)
+		return -EIO;
+
+        chiprev = (readl(syscfg)>>28)+1;
+
+	iounmap(syscfg);
+
+	if(chiprev < 3)
+		return 0;
+
+	runtime->hw.channels_min = 2;
+
+	err = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &stb7100_constraints_channels);
+
+	return err;
+}
+
+
+static stm_playback_ops_t stb7100_pcm_ops = {
+	.free_device      = stb7100_pcm_free,
+	.open_device      = stb7100_pcm_open,
+	.program_hw       = stb7100_pcm_program_hw,
+	.playback_pointer = stb7100_fdma_playback_pointer,
+	.start_playback   = stb7100_pcm_start_playback,
+	.stop_playback    = stb7100_pcm_stop_playback,
+	.pause_playback   = stb7100_pcm_pause_playback,
+	.unpause_playback = stb7100_pcm_unpause_playback
+};
+
+
+static int main_device_allocate(snd_card_t *card, stm_snd_output_device_t *dev_data, pcm_hw_t *stb7100 )
+{
+	if(!card)
+		return -EINVAL;
+
+	spin_lock_init(&stb7100->lock);
+
+        stb7100->card          = card;
+	stb7100->irq           = -1;
+	stb7100->card_data     = dev_data;
+	stb7100->pcm_clock_reg = ioremap(AUD_CFG_BASE, 0);
+	stb7100->out_pipe      = ioremap(FDMA2_BASE_ADDRESS,0);
+        stb7100->fdma_channel  = request_dma((stb7100->card_data->major+3),"STB7100_PCM_DMA");
+
+	return 0;
+}
+
+static snd_device_ops_t ops = {
+    .dev_free = snd_pcm_dev_free,
+};
+
+
+static int stb7100_create_lpcm_device(pcm_hw_t *chip,snd_card_t *this_card)
+{
+	int err = 0;
+	int irq = linux_pcm_irq[chip->card_data->major];
+
+	chip->pcm_converter = 0;
+	chip->pcm_player    = ioremap(pcm_base_addr[chip->card_data->major],0);
+        chip->hw            = stb7100_pcm_hw;
+	chip->oversampling_frequency = 256;
+
+	chip->playback_ops  = &stb7100_pcm_ops;
+
+
+	sprintf(this_card->shortname, "STb7100_PCM%d",chip->card_data->major);
+	sprintf(this_card->longname,  "STb7100_PCM%d",chip->card_data->major );
+	sprintf(this_card->driver,    "%d",chip->card_data->major);
+
+
+	if(request_irq(irq, stb7100_pcm_interrupt, SA_INTERRUPT, "STB7100_PCM", (void*)chip)){
+               		printk(">>> failed to get IRQ %d\n",irq);
+	                stb7100_pcm_free(chip);
+        	        return -EBUSY;
+        }
+
+	chip->irq = irq;
+
+    	switch(chip->card_data->major){
+	        case PCM0_DEVICE:
+        	    	stb7100_pcm0_create(chip);
+			break;
+		case PCM1_DEVICE:
+			stb7100_reset_internal_DAC(chip);
+			break;
+    	}
+
+	set_default_device_clock(chip);
+
+	stb7100_reset_pcm_player(chip);
+
+	if((err = snd_card_pcm_allocate(chip,chip->card_data->minor,this_card->longname)) < 0){
+        	printk(">>> Failed to create PCM stream \n");
+	        stb7100_pcm_free(chip);
+    	}
+    	if((err = snd_generic_create_controls(chip)) < 0){
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	if((err = snd_device_new(this_card, SNDRV_DEV_LOWLEVEL,chip, &ops)) < 0){
+		printk(">>> creating sound device :%d,%d failed\n",chip->card_data->major,chip->card_data->minor);
+		stb7100_pcm_free(chip);
+		return err;
+	}
+	if ((err = snd_card_register(this_card)) < 0) {
+		stb7100_pcm_free(chip);
+		return err;
+	}
+
+	return 0;
+}
+
+
+static int __init snd_pcm_card_probe(int dev)
+{
+	snd_card_t *card={0};
+
+	int err;
+        pcm_hw_t *chip;
+
+        switch(card_list[dev].major){
+            case SPDIF_DEVICE:
+		return stb7100_spdif_card_probe(&card_list[dev]);
+            case PCM0_DEVICE:
+            case PCM1_DEVICE:
+            case PROTOCOL_CONVERTER_DEVICE:
+                if((chip = kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+                    return -ENOMEM;
+
+                    card = snd_card_new(index[card_list[dev].major],id[card_list[dev].major], THIS_MODULE, 0);
+
+                    if (card == NULL)
+                        return -ENOMEM;
+
+                    if ((err = main_device_allocate(card,&card_list[dev],chip)) < 0){
+                        printk(" snd card free on main alloc device\n");
+                        snd_card_free(card);
+                        return err;
+                    }
+
+                    if(PROTOCOL_CONVERTER_DEVICE==card_list[dev].major){
+                        if((err=  stb7100_create_converter_device(chip,card))<0)
+                            snd_card_free(card);
+                    }
+                    else{
+                        if((err = stb7100_create_lpcm_device(chip,card)) <0)
+                            snd_card_free(card);
+                   }
+                    return err;
+             default:
+                 return -ENODEV;
+        }
+
+}
diff -Naur linux-2.6.17.8/sound/stm/stm8000_pcm.c linux-2.6.17.8-sh/sound/stm/stm8000_pcm.c
--- linux-2.6.17.8/sound/stm/stm8000_pcm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/stm8000_pcm.c	2006-08-23 13:29:50.399875000 +0100
@@ -0,0 +1,601 @@
+/*
+ *  STm8000 PCM Player Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *  Authors: Stephen Gallimore <Stephen.Gallimore@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#define PCMP_BASE 			0x14700000
+#define STM_FSYNTHA_BASE 		0x10410000
+
+/* FSYNTHA GENERIC INFO
+    Bit [1:0] NDIV = 00 => I/P 27MHz, Int Ref 27MHz
+    Bit 2 SELF27   = 1
+    Bit 3 POFF     = 0  => Analog power on
+    Bit 4 CLK_SEL  = 0  => Clock A
+    Bits [31:5] Reserved
+*/
+#define STM_FSYNTHA_INFO 		0
+#define FSYNTH_SELF27  			(1<<2)
+#define FSYNTH_POFF    			(1<<3)
+#define FSYNTH_CLK_SEL 			(1<<4)
+
+/* FSYNTHA CLK[1-4]
+    Bit [4:0]   MD
+    Bit [20:5]  PE
+    Bit 21      EN_PRG  = 1 => Enable Prog
+    Bit [24:22] SDIV
+    Bit 25      SEL_OUT = 1 => Enable Clock Output
+    Bit 26      EXT_CLK = 1
+    Bit 27      RESET_N = 1 => Not reset
+    Bit [31:28] Reserved
+*/
+#define STM_FSYNTHA_CLK1 		(0x08)
+
+#define FSYNTH_EN_PRG  			(1<<21)
+#define FSYNTH_SEL_OUT 			(1<<25)
+#define FSYNTH_EXT_CLK 			(1<<26)
+#define FSYNTH_RESET_N 			(1<<27)
+
+
+/*
+ * The following FSYNTHA clk programming figures have been
+ * taken from the DVD VDR driver.
+ *
+ * SDIV     PE      MD
+ * 0x4,  0x5100,  0xFA, Freq =  8.2MHz : 256*32kHz,   sdiv = 32
+ * 0x4,  0x6F05,  0xF3, Freq = 11.3MHz : 256*44.1kHz, sdiv = 32
+ * 0x4,  0x3600,  0xF1, Freq = 12.3MHz : 256*48kHz,   sdiv = 32
+ * 0x3,  0x3600,  0xF1, Freq = 24.6MHz : 256*96kHz,   sdiv = 16
+ * 0x2,  0x3600,  0xF1, Freq = 49.2MHz : 256*192kHz,  sdiv = 8
+ */
+
+
+extern int adjust_audio_clock(snd_pcm_substream_t *substream,int adjusts,int dir){return -ENODEV;}
+
+static struct stm_freq_s gClockSettings[NUM_CLOCK_SETTINGS] =
+{	/* freq   sdiv	 pe    md*//*fsynth adjust unsupported*/
+	{ 32000,  0x4, 0x5100, 0x1a,0x00},
+	{ 44100,  0x4, 0x6F05, 0x13,0x00},
+	{ 48000,  0x4, 0x3600, 0x11,0x00},
+	{ 96000,  0x3, 0x3600, 0x11,0x00},
+	{ 192000, 0x2, 0x3600, 0x11,0x00}
+};
+
+#define STM_PCMP_CONTROL        	0x38
+#define STM_PCMP_STATUS         	0x3c
+#define STM_PCMP_FORMAT         	0x40
+
+/*these for the GPFIFO setup */
+#define STM_GPFIFO_BASE 0x14700000
+#define STM_GPFIFO_MODE                    ( 0x00 )
+#define STM_GPFIFO_PACKET_SIZE             ( 0x04 )
+#define STM_GPFIFO_CHUNK_SIZE              ( 0x08 )
+#define STM_GPFIFO_MESSAGE_SIZE            ( 0x0C )
+#define STM_GPFIFO_FIX_TRANSF_SIZE         ( 0x10 )
+#define STM_GPFIFO_TRIGGER_COUNT           ( 0x14 )
+#define STM_GPFIFO_BUF_LIMIT_ADDR          ( 0x18 )
+#define STM_GPFIFO_START_ADDRESS           ( 0x1C )
+#define STM_GPFIFO_INCREMENT               ( 0x20 )
+#define STM_GPFIFO_ITER_1                  ( 0x24 )
+#define STM_GPFIFO_ITER_2                  ( 0x28 )
+#define STM_GPFIFO_JUMP_1                  ( 0x2C )
+#define STM_GPFIFO_JUMP_2                  ( 0x30 )
+#define STM_GPFIFO_SOFT_RESET              ( 0x34 )
+
+#if defined(__PROVOKE_FIFO_EMPTY_FULL_BUG__)
+#define GPFIFO_PACKET_SIZE      0x8
+#define GPFIFO_PACKET_SIZE_LOG2 0x3
+#define GPFIFO_TRANSFER_THRESHOLD (PCMP_PACKET_SIZE+1)
+#else
+#define GPFIFO_PACKET_SIZE      0x2
+#define GPFIFO_PACKET_SIZE_LOG2 0x1
+#define GPFIFO_TRANSFER_THRESHOLD 0xF
+#endif
+
+
+#define LINUX_PCMPLAYER_ALLREAD_IRQ (ILC_FIRST_IRQ+55)
+
+static snd_pcm_hardware_t stm8000_pcm_hw =
+{
+	.info =		(SNDRV_PCM_INFO_MMAP           |
+			 SNDRV_PCM_INFO_INTERLEAVED    |
+			 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			 SNDRV_PCM_INFO_MMAP_VALID     |
+			 SNDRV_PCM_INFO_PAUSE),
+
+	.formats =	 SNDRV_PCM_FMTBIT_S32_LE,
+
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 |
+			 SNDRV_PCM_RATE_96000 |
+			 SNDRV_PCM_RATE_192000 ),
+
+	.rate_min	  = 32000,
+	.rate_max	  = 192000,
+	.channels_min	  = 10,
+	.channels_max	  = 10,
+	.buffer_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.period_bytes_min = FRAMES_TO_BYTES(1,10),
+	.period_bytes_max = FRAMES_TO_BYTES(PCM_MAX_FRAMES,10),
+	.periods_min	  = 1,
+	.periods_max	  = PCM_MAX_FRAMES
+};
+
+
+static int stm8000_program_fsynth(snd_pcm_substream_t *substream)
+{
+	int i;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t  *chip = snd_pcm_substream_chip(substream);
+	DEBUG_PRINT(("stm8000_program_fsynth(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx rate = %d\n",chip, runtime->rate));
+
+	for(i=0; i < NUM_CLOCK_SETTINGS; i++) {
+		if (runtime->rate == gClockSettings[i].freq) {
+			unsigned long c;
+
+			c = ( gClockSettings[i].sdiv_val <<22 |
+				  gClockSettings[i].pe_val <<5  |
+				  gClockSettings[i].md_val |
+			      FSYNTH_RESET_N | FSYNTH_EXT_CLK |
+			      FSYNTH_SEL_OUT | FSYNTH_EN_PRG);
+
+			writel(c, chip->pcm_clock_reg + STM_FSYNTHA_CLK1);
+			chip->are_clocks_active = 1;
+			return 0;
+		}
+	}
+
+	DEBUG_PRINT((">>> Unsupported sample rate!\n"));
+
+	return -1;
+}
+
+
+static int stm8000_program_gpfifo(snd_pcm_substream_t *substream)
+{
+	unsigned long count,jump;
+	snd_pcm_runtime_t  *runtime = substream->runtime;
+	pcm_hw_t  *chip = snd_pcm_substream_chip(substream);
+
+
+	DEBUG_PRINT(("stm8000_program_gpfifo(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx dma_area = 0x%08lx\n",chip, runtime->dma_area));
+
+	writel(1, chip->out_pipe + STM_GPFIFO_MODE);
+
+	writel(GPFIFO_PACKET_SIZE_LOG2, chip->out_pipe + STM_GPFIFO_PACKET_SIZE);
+	writel(0, chip->out_pipe + STM_GPFIFO_CHUNK_SIZE);
+	writel(0, chip->out_pipe + STM_GPFIFO_MESSAGE_SIZE);
+	writel(0, chip->out_pipe + STM_GPFIFO_FIX_TRANSF_SIZE);
+	writel(GPFIFO_TRANSFER_THRESHOLD, chip->out_pipe + STM_GPFIFO_TRIGGER_COUNT);
+	writel(GPFIFO_PACKET_SIZE, chip->out_pipe + STM_GPFIFO_INCREMENT);
+	writel((0x0DFFFFFF>>2),  chip->out_pipe + STM_GPFIFO_BUF_LIMIT_ADDR);
+	writel(0, chip->out_pipe + STM_GPFIFO_ITER_2);
+	writel(0, chip->out_pipe + STM_GPFIFO_JUMP_2);
+
+	count = ((snd_pcm_lib_buffer_bytes(substream)>>2)/GPFIFO_PACKET_SIZE)-1;
+	writel(count, chip->out_pipe + STM_GPFIFO_ITER_1);
+
+	DEBUG_PRINT((">>> count = 0x%08lx\n",count));
+
+	jump = -((snd_pcm_lib_buffer_bytes(substream)>>2)-GPFIFO_PACKET_SIZE);
+	writel((jump & 0x000FFFFF), chip->out_pipe +STM_GPFIFO_JUMP_1);
+
+	DEBUG_PRINT((">>> jump = 0x%08lx\n",jump));
+
+	chip->buffer_start_addr = (unsigned long)runtime->dma_addr;
+
+	DEBUG_PRINT((">>> gpfifo_start_address = 0x%08lx\n",chip->buffer_start_addr));
+
+	return 0;
+}
+
+
+static int stm8000_program_pcmplayer(snd_pcm_substream_t *substream)
+{
+	unsigned long reg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t  *chip = snd_pcm_substream_chip(substream);
+
+	/*
+	 * The PCM data format is set to be I2S.
+	 * External DACs must be configured to expect this format and
+	 * an oversampling frequency of 256*Fs. Please see the documentation
+	 * on http://www.stlinux.com for board configuration information.
+	 */
+
+	reg = (runtime->period_size * runtime->channels) << PCMP_SAMPLES_SHIFT;
+
+	reg |= PCMP_FSYNTH_DIVIDE32_256 | PCMP_NO_ROUNDING | PCMP_MEM_FMT_16_0 | PCMP_IGNORE_SPDIF_LATENCY;
+
+	chip->pcmplayer_control = reg;
+
+	reg = PCMP_FORMAT_32  | PCMP_LENGTH_24  |
+	      PCMP_ALIGN_START| PCMP_MSB_FIRST  |
+	      PCMP_CLK_RISING | PCMP_LRLEVEL_LEFT_LOW | PCMP_PADDING_ON;
+
+	writel(reg, chip->pcm_player + STM_PCMP_FORMAT);
+
+	return 0;
+}
+
+
+static int stm8000_pcm_program_hw(snd_pcm_substream_t *substream)
+{
+	unsigned long flags=0;
+	pcm_hw_t  *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock_irqsave(&chip->lock,flags);
+	if(stm8000_program_fsynth(substream) < 0)
+		return -1;
+
+	stm8000_program_pcmplayer(substream);
+	stm8000_program_gpfifo(substream);
+	spin_unlock_irqrestore(&chip->lock,flags);
+
+	return 0;
+}
+
+
+static irqreturn_t stm8000_pcm_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long val;
+
+	pcm_hw_t *stm8000 = dev_id;
+	snd_pcm_runtime_t *runtime = stm8000->current_substream->runtime;
+
+	spin_lock(&stm8000->lock);
+
+	/* Read and clear interrupt status */
+	val = readl(stm8000->pcm_player + STM_PCMP_STATUS);
+
+	if(val & PCMP_STATUS_ALLREAD) {
+
+		/* Keep track of hwptr */
+		stm8000->hwbuf_current_addr += runtime->period_size;
+		if(stm8000->hwbuf_current_addr >= runtime->buffer_size)
+			stm8000->hwbuf_current_addr -= runtime->buffer_size;
+
+		/* Must unlock before calling higher levels */
+		spin_unlock(&stm8000->lock);
+
+		/* Inform higher layer that we have completed a period */
+		snd_pcm_period_elapsed(stm8000->current_substream);
+
+		return IRQ_HANDLED;
+	}
+	else {
+
+		spin_unlock(&stm8000->lock);
+
+		return IRQ_NONE;
+	}
+}
+
+
+static snd_pcm_uframes_t stm8000_playback_pointer(snd_pcm_substream_t * substream)
+{
+	snd_pcm_uframes_t pointer;
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	/*
+	 * This routine is called atomically by the higher ALSA layers
+	 * and may be called from interupt context. So we only need to
+	 * spin_lock to protect against pre-emption.
+	 */
+	spin_lock(&chip->lock);
+	pointer = chip->hwbuf_current_addr;
+	spin_unlock(&chip->lock);
+
+	return pointer;
+}
+
+
+static void stm8000_pcm_pause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	spin_lock(&chip->lock);
+
+	writel((chip->pcmplayer_control | PCMP_MUTE),
+			chip->pcm_player + STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+}
+
+
+static void stm8000_pcm_unpause_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	spin_lock(&chip->lock);
+
+	writel((chip->pcmplayer_control | PCMP_ON),
+		chip->pcm_player + STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+}
+
+
+static void stm8000_pcm_start_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	spin_lock(&chip->lock);
+
+	/* Reset buffer position */
+	chip->hwbuf_current_addr = 0;
+
+	writel((chip->pcmplayer_control | PCMP_ON),
+	chip->pcm_player + STM_PCMP_CONTROL);
+
+	writel( chip->buffer_start_addr,
+	chip->out_pipe + STM_GPFIFO_START_ADDRESS);
+	//setup the fdma buffer start address
+
+	writel(0, chip->out_pipe + STM_GPFIFO_SOFT_RESET);
+	spin_unlock(&chip->lock);
+
+}
+
+
+static void stm8000_pcm_stop_playback(snd_pcm_substream_t *substream)
+{
+ 	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	DEBUG_PRINT(("stm8k_pcm_stop_playback(stm8000 = 0x%08lx)\n",chip));
+	spin_lock(&chip->lock);
+
+	/* Resetting the GPFIFO before stopping the
+	 * PCM player makes restarting the GPFIFO/
+	 * player slightly more reliable than if we
+	 * turn the PCM player off first, but it doesn't
+	 * cure the chip lock ups completely.
+	 */
+	writel(1, chip->out_pipe +  STM_GPFIFO_SOFT_RESET);
+
+	/*
+	 * We use "mute" to stop the PCM player on the external DACs, which
+	 * in fact is implemented as a pause, rather than "off" becuase it
+	 * keeps the L/R clocks running to the DACs. This avoids
+	 * noise on the analogue output and occasional DAC failures, due
+	 * to the DACs being intolerant of losing their clocks unless in reset
+	 * or powerdown modes.
+	 *
+	 */
+	writel((chip->pcmplayer_control | PCMP_MUTE),
+		chip->pcm_player +  STM_PCMP_CONTROL);
+
+	spin_unlock(&chip->lock);
+}
+
+
+static int stm8000_device_free(pcm_hw_t *stm8000)
+{
+	DEBUG_PRINT(("stm8000_device_free(stm8000 = 0x%08lx)\n",stm8000));
+
+	writel(1, stm8000->out_pipe + STM_GPFIFO_SOFT_RESET);
+	writel(PCMP_OFF, stm8000->pcm_player +STM_PCMP_CONTROL);
+
+	iounmap(stm8000->pcm_clock_reg);
+	iounmap(stm8000->out_pipe);
+	iounmap(stm8000->pcm_player);
+	if(stm8000->irq > 0)
+		free_irq(stm8000->irq,(void *)stm8000);
+
+	kfree(stm8000);
+
+	return 0;
+}
+
+
+/*
+ * This is a parameter constraint rule which forces the buffer size (in
+ * ALSA frames) to be a multiple of 4. This is necessary as the buffer
+ * size (in bytes) must be a multiple of the STBus transfer size
+ * (i.e. 8 words/32bytes) for correct operation of the GPFIFO.
+ * Each frame is 10channels * 4bytes = 40bytes. The smallest number
+ * of frames that represents a multiple of 32bytes is 4 ( 4*40 = 160 / 32 = 5).
+ */
+static int stm8000_pcm_buffer_size_rule(snd_pcm_hw_params_t *params,
+					snd_pcm_hw_rule_t   *rule)
+{
+	snd_interval_t *bufsize;
+	snd_interval_t  newbufsize;
+
+	int refine = 0;
+
+	bufsize    = hw_param_interval(params, SNDRV_PCM_HW_PARAM_BUFFER_SIZE);
+	newbufsize = *bufsize;
+
+	if(((bufsize->max) & 0x3) != 0) {
+		newbufsize.max = bufsize->max & 0xfffffffc;
+		refine = 1;
+	}
+
+	if(((bufsize->min) & 0x3) != 0) {
+		newbufsize.min = (bufsize->min + 4) & 0xfffffffc;
+		refine = 1;
+	}
+
+	if(refine) {
+		DEBUG_PRINT(("stm8000_pcm_buffer_size_rule: refining (%d,%d) to (%d,%d)\n",bufsize->min,bufsize->max,newbufsize.min,newbufsize.max));
+		return snd_interval_refine(bufsize, &newbufsize);
+	}
+
+	return 0;
+}
+
+
+static int stm8000_pcm_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	/*
+	 * Add buffer size constraint rules to deal with limitations in
+	 * the GPFIFO. The problem however is that these don't always
+	 * work as you expect and the ALSA constraint system is wierd.
+	 * The problem is that most applications set the buffer size by "time"
+	 * not by "samples". Under some circumstances it appears that the
+	 * following happens:
+	 *
+	 * 1. app does a set buffer time _near_
+	 * 2. the constraint system calls our rules to adjust the buffer size
+	 * 3. instead of then adjusting the _time_ to match the new buffer size
+	 *    the constraint system tries to adjust the _sample rate_ very
+	 *    slightly to keep the time the same
+	 *
+	 * The last step fails as we only support fixed sample rates and the
+	 * application reports a setup error. If anyone wants to fix this
+	 * feel free, but as the STm8000 is becoming obsolete and this
+	 * problem doesn't effect newer FDMA based systems it probably won't
+	 * get fixed.
+	 */
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_BUFFER_TIME,
+			    stm8000_pcm_buffer_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+			    -1);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+			    stm8000_pcm_buffer_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+			    -1);
+
+	return 0;
+}
+
+
+static stm_playback_ops_t stm8000_pcm_ops = {
+        .free_device      = stm8000_device_free,
+        .open_device      = stm8000_pcm_open,
+	.program_hw       = stm8000_pcm_program_hw,
+	.playback_pointer = stm8000_playback_pointer,
+	.start_playback   = stm8000_pcm_start_playback,
+	.stop_playback    = stm8000_pcm_stop_playback,
+	.pause_playback   = stm8000_pcm_pause_playback,
+	.unpause_playback = stm8000_pcm_unpause_playback
+};
+
+
+
+static int __devinit stm8000_snd_create(snd_card_t *card)
+{
+	pcm_hw_t *stm8000 = 0;
+	int err;
+
+	static snd_device_ops_t ops = {
+		.dev_free = snd_pcm_dev_free,
+	};
+
+	DEBUG_PRINT(("stm8000_snd_create(0x%08lx)\n",card));
+
+
+	if((stm8000 = kcalloc(1,sizeof(pcm_hw_t), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	DEBUG_PRINT((">>> stm8000 = 0x%08lx\n",stm8000));
+
+	stm8000->card = card;
+	stm8000->irq  = -1;
+	spin_lock_init(&stm8000->lock);
+	stm8000->pcm_clock_reg = ioremap(STM_FSYNTHA_BASE, 64);
+	/*
+	 * FOR THE 8K IT HAPPENS that the gpfifo & pcm are on a linear adr range
+	 * we can't always guarantee this.
+	 */
+	stm8000->out_pipe   = ioremap(PCMP_BASE,128);
+	stm8000->pcm_player = ioremap(PCMP_BASE,128);
+
+	/* Setup card configuration */
+	stm8000->card_data  = &card_list[0];
+	stm8000->hw         = stm8000_pcm_hw;
+	stm8000->oversampling_frequency = 256;
+
+	/* Playback function pointers */
+	stm8000->playback_ops = &stm8000_pcm_ops;
+
+	DEBUG_PRINT((">>> stm8000->pcm_clock_reg = 0x%08lx\n",stm8000->pcm_clock_reg));
+	DEBUG_PRINT((">>> stm8000->out_pipe      = 0x%08lx\n",stm8000->out_pipe));
+
+	writel(1, stm8000->out_pipe   + STM_GPFIFO_SOFT_RESET);
+	writel(0, stm8000->pcm_player + STM_PCMP_CONTROL);
+	writel(FSYNTH_SELF27,stm8000->pcm_clock_reg + STM_FSYNTHA_INFO);
+
+	if(request_irq(LINUX_PCMPLAYER_ALLREAD_IRQ,
+                       stm8000_pcm_interrupt, SA_INTERRUPT,
+                       "STm8000 PCM Player",(void*)stm8000))
+	{
+		DEBUG_PRINT((">>> failed to get IRQ\n"));
+		stm8000_device_free(stm8000);
+		return -EBUSY;
+	}
+
+	stm8000->irq = LINUX_PCMPLAYER_ALLREAD_IRQ;
+
+	if ((err = snd_card_pcm_allocate(stm8000, 0,"STM8000")) < 0) {
+		DEBUG_PRINT((">>> failed to create PCM stream\n"));
+		stm8000_device_free(stm8000);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, stm8000, &ops)) < 0)
+	{
+		DEBUG_PRINT((">>> creating sound device failed\n"));
+		stm8000_device_free(stm8000);
+		return err;
+	}
+
+	return 0;
+}
+
+
+static int __init snd_pcm_card_probe(int dev)
+{
+	snd_card_t *card;
+	int err;
+
+	DEBUG_PRINT(("snd_card_stm8000_probe(%d)\n",dev));
+
+	if (dev != 0 )
+		return -ENODEV;
+
+	card = snd_card_new(index[dev],id[dev], THIS_MODULE, 0);
+
+	if (card == NULL)
+		return -ENOMEM;
+
+	if ((err = stm8000_snd_create(card)) < 0)
+	{
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver,    "STm8000");
+	strcpy(card->shortname, "STm8000");
+	sprintf(card->longname, "STm8000 %i", dev + 1);
+
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	card_list[dev].device = card;
+
+	return 0;
+}
diff -Naur linux-2.6.17.8/sound/stm/st_pcm_core.c linux-2.6.17.8-sh/sound/stm/st_pcm_core.c
--- linux-2.6.17.8/sound/stm/st_pcm_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/st_pcm_core.c	2006-08-23 13:29:50.357875000 +0100
@@ -0,0 +1,1274 @@
+/*
+ *  STPCM Player Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *  Authors: Stephen Gallimore <Stephen.Gallimore@st.com> and
+ *  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/proc_fs.h>
+
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#define SNDRV_GET_ID
+#include <sound/initval.h>
+
+#include <sound/asoundef.h>
+
+#ifdef CONFIG_BIGPHYS_AREA
+
+#include <linux/bigphysarea.h>
+	#define STM_USE_BIGPHYS_AREA 1
+#else
+	/* Private dummy defines so we do not have to ifdef the code */
+	static caddr_t  bigphysarea_alloc(int size) { return NULL; }
+	static void     bigphysarea_free(caddr_t addr, int size) {}
+	#define STM_USE_BIGPHYS_AREA 0
+#endif /* CONFIG_BIGPHYS_AREA */
+
+
+#include <asm/dma.h>
+#include "st_pcm.h"
+
+static int index[SNDRV_CARDS] = {SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1,SNDRV_DEFAULT_IDX1};
+        	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = {SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1,SNDRV_DEFAULT_STR1};	/* ID for this card */
+
+static u8 global_spdif_sync_status=0;
+
+static int get_spdif_syncing_status(void)
+{
+	return global_spdif_sync_status;
+}
+
+
+void set_spdif_syncing_status(int enable)
+{
+	global_spdif_sync_status = enable;
+}
+
+
+#if defined (CONFIG_CPU_SUBTYPE_STB7100)
+
+#define SND_DRV_CARDS  4
+
+static stm_snd_output_device_t  card_list[SND_DRV_CARDS]= {
+        /*major                      minor             input type          output type          */
+        {PCM0_DEVICE,               MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_LPCM},
+        {PCM1_DEVICE,               MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_LPCM},
+        {SPDIF_DEVICE,              MAIN_DEVICE, STM_DATA_TYPE_IEC60958, STM_DATA_TYPE_IEC60958},
+        {PROTOCOL_CONVERTER_DEVICE, MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_IEC60958}
+};
+
+#include "stb7100_snd.h"
+#include "stm7100_pcm.c"
+#include "stb7100_i2s_spdif.c"
+#include "stb7100_spdif.c"
+#define DEVICE_NAME "STb7100"
+
+#elif defined (CONFIG_CPU_SUBTYPE_STM8000)
+
+#define SND_DRV_CARDS 1
+
+static stm_snd_output_device_t card_list[SND_DRV_CARDS]={
+        /*major                      minor             input type          output type       */
+        {PCM0_DEVICE,               MAIN_DEVICE, STM_DATA_TYPE_LPCM,     STM_DATA_TYPE_LPCM}
+};
+
+#include "stm8000_pcm.c"
+#define DEVICE_NAME "STm8000"
+/*we need a dummy define of the spdif data so no need for #ifdef*/
+static snd_pcm_hardware_t snd_spdif_playback;
+
+#else
+
+#error "BAD cpu arhitecture defined - PCM player is not supported"
+
+#endif
+
+MODULE_AUTHOR("Mark Glaisher <mark.glaisher@st.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION(DEVICE_NAME " ALSA driver");
+MODULE_SUPPORTED_DEVICE("{{STM," DEVICE_NAME "}}");
+
+static int snd_pcm_playback_hwfree(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+        chip->card_data->in_use = 0;
+
+	if(runtime->dma_area == NULL)
+		return 0;
+
+        if(STM_USE_BIGPHYS_AREA &&
+           runtime->dma_bytes > PCM_BIGALLOC_SIZE) {
+
+		bigphysarea_free(runtime->dma_area,
+				 runtime->dma_bytes);
+
+		runtime->dma_area    = 0;
+		runtime->dma_addr    = 0;
+		runtime->dma_bytes   = 0;
+
+		return 0;
+	}
+	else
+		return snd_pcm_lib_free_pages(substream);
+}
+
+
+static snd_pcm_uframes_t snd_pcm_playback_pointer(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	return chip->playback_ops->playback_pointer(substream);
+}
+
+
+static int snd_pcm_playback_prepare(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long flags=0;
+	/* Chip isn't running at this point so we don't have to disable interrupts*/
+	spin_lock_irqsave(&chip->lock,flags);
+
+#if defined (CONFIG_CPU_SUBTYPE_STB7100)
+	/*
+	 * On the STb7100 we can only use either the PCM0 device or the protocol
+	 * converter as they physically use the same hardware. As we have no
+	 * device specific hook for prepare, we do this here for the moment.
+	 */
+	if((card_list[PCM0_DEVICE].in_use               && (chip->card_data->major == PROTOCOL_CONVERTER_DEVICE)) ||
+	   (card_list[PROTOCOL_CONVERTER_DEVICE].in_use && (chip->card_data->major == PCM0_DEVICE)))
+	{
+		int converter_enable = (chip->card_data->major==PROTOCOL_CONVERTER_DEVICE ? 1:0);
+		printk("%s: device (%d,%d) is in use by (%d,%d)\n",
+                	__FUNCTION__,
+                	chip->card_data->major,
+                	chip->card_data->minor,
+                	(converter_enable ? 	PCM0_DEVICE:
+                				PROTOCOL_CONVERTER_DEVICE),
+                	(converter_enable ? 	card_list[PCM0_DEVICE].minor:
+                				card_list[PROTOCOL_CONVERTER_DEVICE].minor));
+
+        	return -EBUSY;
+        }
+#endif
+
+	chip->card_data->in_use = 1;
+	spin_unlock_irqrestore(&chip->lock,flags);
+
+	if(chip->playback_ops->program_hw(substream) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+
+static int snd_pcm_dev_free(snd_device_t *dev)
+{
+	pcm_hw_t *snd_card = dev->device_data;
+
+	DEBUG_PRINT(("snd_pcm_dev_free(dev = 0x%08lx)\n",dev));
+	DEBUG_PRINT((">>> snd_card = 0x%08lx\n",snd_card));
+
+	if(snd_card->playback_ops->free_device)
+		return snd_card->playback_ops->free_device(snd_card);
+
+	return 0;
+}
+
+
+static int snd_playback_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	switch(cmd)
+	{
+		case SNDRV_PCM_TRIGGER_START:
+			chip->playback_ops->start_playback(substream);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			chip->playback_ops->stop_playback(substream);
+		        chip->card_data->in_use = 0;
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			chip->playback_ops->pause_playback(substream);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			chip->playback_ops->unpause_playback(substream);
+			break;
+		default:
+			return -EINVAL;
+	}
+	snd_pcm_trigger_done(substream,substream);
+	return 0;
+}
+
+
+static int snd_pcm_playback_close(snd_pcm_substream_t * substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	DEBUG_PRINT(("snd_pcm_playback_close(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx\n",chip));
+
+	/*
+	 * If the PCM clocks are programmed then ensure the playback is
+	 * stopped. If not do nothing otherwise we can end up with the
+	 * DAC in a bad state.
+	 */
+	if(chip->are_clocks_active)
+		chip->playback_ops->stop_playback(substream);
+
+	spin_lock(&chip->lock);
+	chip->current_substream = 0;
+	spin_unlock(&chip->lock);
+
+	return 0;
+}
+
+
+static int snd_pcm_playback_hwparams(snd_pcm_substream_t * substream,
+					 snd_pcm_hw_params_t * hw_params)
+{
+	int   err  = 0;
+	int   size = 0;
+	char* addr = 0;
+
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	size = params_buffer_bytes(hw_params);
+
+	if (STM_USE_BIGPHYS_AREA && size > PCM_BIGALLOC_SIZE){
+		/*
+		 * This routine can be called multiple times without a free
+		 * in between, so we need to make sure we don't overallocate.
+		 */
+		if(runtime->dma_area) {
+			if(runtime->dma_bytes >= size) {
+				err = 0; /* Not changed */
+				goto exit;
+			}
+			else {
+				/* Use this to make sure we do the right free */
+				snd_pcm_playback_hwfree(substream);
+			}
+		}
+
+		addr = bigphysarea_alloc(size);
+
+		if(addr == 0) {
+			printk(KERN_WARNING "ALSA driver: sound buffer allocation from bigphysmem failed.\n");
+			printk(KERN_WARNING "ALSA driver: either increase bigphysmem pages with 'bigphyspages=xxxx' on the kernel command line\n");
+			printk(KERN_WARNING "ALSA driver: or reduce the requested buffer size to <=128k (3276 audio frames)\n");
+			err = -ENOMEM;
+			goto exit;
+		}
+		else{
+			dma_cache_wback(&addr, size);
+
+			runtime->dma_area    = addr;
+			runtime->dma_addr    = virt_to_phys(addr);
+			runtime->dma_bytes   = size;
+			err = 1; /* Changed buffer */
+		}
+	}
+	else {
+		err = snd_pcm_lib_malloc_pages(substream, size);
+		if(err >= 0) {
+			runtime->dma_addr = virt_to_phys(runtime->dma_area);
+		}
+	}
+
+exit:
+	DEBUG_PRINT((">>> dma_area = 0x%08lx err = %d\n",substream->runtime->dma_area, err));
+
+	return err;
+}
+
+
+/*
+ * This is a constraint rule which limits the period size to the capabilities
+ * of the ST PCM Players. These only have a 19bit count register which
+ * counts individual samples, i.e. for a 10-channel player it will count 10
+ * for each alsa 10 channel frame. This means we also need to ensure that
+ * the number of samples is an exact multiple of the number of channels.
+ */
+static int snd_pcm_period_size_rule(snd_pcm_hw_params_t *params,
+				     snd_pcm_hw_rule_t   *rule)
+{
+	snd_interval_t *periodsize;
+	snd_interval_t *channels;
+	snd_interval_t  newperiodsize;
+
+	int refine = 0;
+
+	periodsize    = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+	newperiodsize = *periodsize;
+	channels      = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	if((periodsize->max * channels->min) > PCMP_MAX_SAMPLES) {
+		newperiodsize.max = PCMP_MAX_SAMPLES / channels->min;
+		refine = 1;
+	}
+
+	if((periodsize->min * channels->min) > PCMP_MAX_SAMPLES) {
+		newperiodsize.min = PCMP_MAX_SAMPLES / channels->min;
+		refine = 1;
+	}
+
+	if(refine) {
+		DEBUG_PRINT(("snd_pcm_period_size_rule: refining (%d,%d) to (%d,%d)\n",periodsize->min,periodsize->max,newperiodsize.min,newperiodsize.max));
+		return snd_interval_refine(periodsize, &newperiodsize);
+	}
+
+	return 0;
+}
+
+
+static int snd_pcm_playback_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+	int err = 0;
+
+	DEBUG_PRINT(("snd_pcm_playback_open(substream = 0x%08lx)\n",substream));
+	DEBUG_PRINT((">>> chip = 0x%08lx\n",chip));
+
+	snd_pcm_set_sync(substream);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_TIME,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	snd_pcm_hw_rule_add(substream->runtime,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    snd_pcm_period_size_rule,
+			    0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+			    -1);
+
+	spin_lock(&chip->lock);
+
+	chip->current_substream = substream;
+        runtime->hw = chip->hw;
+
+        if(chip->playback_ops->open_device)
+		err = chip->playback_ops->open_device(substream);
+
+	spin_unlock(&chip->lock);
+
+	return err;
+}
+
+/*
+ * nopage callback for mmapping a RAM page
+ */
+
+static struct page *snd_pcm_mmap_data_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+{
+        snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+        snd_pcm_runtime_t *runtime;
+        unsigned long offset;
+        struct page * page;
+        void *vaddr;
+        size_t dma_bytes;
+
+        if (substream == NULL)
+                return NOPAGE_OOM;
+        runtime = substream->runtime;
+        offset = area->vm_pgoff << PAGE_SHIFT;
+        offset += address - area->vm_start;
+        snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+        dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
+        if (offset > dma_bytes - PAGE_SIZE)
+                return NOPAGE_SIGBUS;
+
+        if (substream->ops->page) {
+                page = substream->ops->page(substream, offset);
+                if (! page)
+                        return NOPAGE_OOM;
+        } else {
+                vaddr = runtime->dma_area + offset;
+                page = virt_to_page(vaddr);
+        }
+        if (!PageReserved(page))
+                get_page(page);
+        if (type)
+                *type = VM_FAULT_MINOR;
+        return page;
+}
+
+
+static struct vm_operations_struct snd_pcm_vm_ops_data =
+{
+        .open =         snd_pcm_mmap_data_open,
+        .close =        snd_pcm_mmap_data_close,
+        .nopage =       snd_pcm_mmap_data_nopage,
+};
+
+/*
+ * mmap the DMA buffer on RAM
+ */
+
+static int snd_pcm_mmap(snd_pcm_substream_t *substream, struct vm_area_struct *area)
+{
+        area->vm_ops = &snd_pcm_vm_ops_data;
+        area->vm_private_data = substream;
+        area->vm_flags |= VM_RESERVED;
+
+        area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+
+        atomic_inc(&substream->runtime->mmap_count);
+        return 0;
+}
+
+
+static int snd_pcm_silence(snd_pcm_substream_t *substream, int channel,
+                            snd_pcm_uframes_t    pos,       snd_pcm_uframes_t count)
+{
+        snd_pcm_runtime_t *runtime = substream->runtime;
+        char *hwbuf;
+	int   totalbytes;
+
+        if(channel != -1)
+                return -EINVAL;
+
+        hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+
+	totalbytes = frames_to_bytes(runtime, count);
+
+        snd_pcm_format_set_silence(runtime->format, hwbuf, totalbytes);
+        dma_cache_wback(hwbuf, totalbytes);
+        return 0;
+}
+
+
+static int snd_pcm_copy(snd_pcm_substream_t	*substream,
+			 int			 channel,
+			 snd_pcm_uframes_t	 pos,
+			 void __user		*buf,
+			 snd_pcm_uframes_t	 count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	char		  *hwbuf;
+	int                totalbytes;
+
+	if(channel != -1)
+		return -EINVAL;
+
+	hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+
+	totalbytes = frames_to_bytes(runtime, count);
+
+	if(copy_from_user(hwbuf, buf, totalbytes))
+		return -EFAULT;
+
+	dma_cache_wback(hwbuf, totalbytes);
+
+	return 0;
+}
+
+/*
+ * IEC60958 channel status and format handling for SPDIF and I2S->SPDIF
+ * protocol converters
+ */
+void iec60958_default_channel_status(pcm_hw_t *chip)
+{
+	chip->default_spdif_control.channel.status[0]  = (IEC958_AES0_CON_NOT_COPYRIGHT |
+							  IEC958_AES0_CON_EMPHASIS_NONE);
+
+	chip->default_spdif_control.channel.status[1] |= (IEC958_AES1_CON_NON_IEC908_DVD |
+							  IEC958_AES1_CON_ORIGINAL) ;
+
+
+	chip->default_spdif_control.channel.status[2] |= (IEC958_AES2_CON_SOURCE_UNSPEC |
+							  IEC958_AES2_CON_CHANNEL_UNSPEC);
+
+	chip->default_spdif_control.channel.status[3] |= (IEC958_AES3_CON_FS_44100 |
+							  IEC958_AES3_CON_CLOCK_VARIABLE);
+
+	chip->default_spdif_control.channel.status[4]  = (IEC958_AES4_CON_WORDLEN_MAX_24 |
+							  IEC958_AES4_CON_WORDLEN_24_20);
+
+	memset(chip->default_spdif_control.user,      0x0,sizeof(u8)*48);
+	memset(chip->default_spdif_control.validity_l,0x0,sizeof(u8)*24);
+	memset(chip->default_spdif_control.validity_r,0x0,sizeof(u8)*24);
+}
+
+
+void iec60958_set_runtime_status(snd_pcm_substream_t *substream)
+{
+	pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if(chip->pending_spdif_control.channel.status[0] & IEC958_AES0_PROFESSIONAL) {
+		chip->pending_spdif_control.channel.status[0] &= ~IEC958_AES0_PRO_FS;
+		switch(substream->runtime->rate){
+			case 32000:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_32000;
+				break;
+			case 48000:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_48000;
+				break;
+			default:
+				chip->pending_spdif_control.channel.status[0]
+					 |= IEC958_AES0_PRO_FS_44100;
+				break;
+		}
+
+		chip->pending_spdif_control.channel.status[2]
+			&= ~((IEC958_AES2_PRO_SBITS | IEC958_AES2_PRO_WORDLEN));
+
+		chip->pending_spdif_control.channel.status[2]
+			|= (IEC958_AES2_PRO_SBITS_24 | IEC958_AES2_PRO_WORDLEN_24_20);
+
+		chip->pending_spdif_control.channel.status[4] = 0;
+
+	} else {
+		chip->pending_spdif_control.channel.status[3] &=
+				 ~((IEC958_AES3_CON_FS|IEC958_AES3_CON_CLOCK));
+		switch(substream->runtime->rate){
+			case 32000:
+				chip->pending_spdif_control.channel.status[3]
+					|= IEC958_AES3_CON_FS_32000;
+				break;
+			case 48000:
+				chip->pending_spdif_control.channel.status[3]
+					 |= IEC958_AES3_CON_FS_48000;
+				break;
+			default:
+				chip->pending_spdif_control.channel.status[3]
+					 |= IEC958_AES3_CON_FS_44100;
+				break;
+		}
+
+		chip->pending_spdif_control.channel.status[3] |= IEC958_AES3_CON_CLOCK_VARIABLE;
+
+		if(chip->pending_spdif_control.channel.status[0] & IEC958_AES0_NONAUDIO) {
+			DEBUG_PRINT(("iec60958_set_runtime_status: NON LPCM Setup\n",dev));
+			chip->pending_spdif_control.channel.status[4] = 0;
+			/*
+			 * Force all validity bits to 1 as specified in the spec
+			 * to prevent accidental interpretation as LPCM.
+			 */
+			memset(chip->default_spdif_control.validity_l,0xff,sizeof(u8)*24);
+			memset(chip->default_spdif_control.validity_r,0xff,sizeof(u8)*24);
+		} else {
+			DEBUG_PRINT(("iec60958_set_runtime_status: 24bit LPCM Setup\n",dev));
+			chip->pending_spdif_control.channel.status[4]  = (IEC958_AES4_CON_WORDLEN_MAX_24 |
+									  IEC958_AES4_CON_WORDLEN_24_20);
+		}
+	}
+
+}
+
+
+static int snd_iec60958_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+
+static int snd_iec60958_default_get(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.iec958.status[0] = chip->default_spdif_control.channel.status[0];
+	ucontrol->value.iec958.status[1] = chip->default_spdif_control.channel.status[1];
+	ucontrol->value.iec958.status[2] = chip->default_spdif_control.channel.status[2];
+	ucontrol->value.iec958.status[3] = chip->default_spdif_control.channel.status[3];
+
+	return 0;
+}
+
+
+static int snd_iec60958_default_put(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	u32 val, old;
+
+	val =  ucontrol->value.iec958.status[0]        |
+	      (ucontrol->value.iec958.status[1] << 8)  |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+
+	old =  chip->default_spdif_control.channel.status[0] 	    |
+	      (chip->default_spdif_control.channel.status[1] << 8)  |
+	      (chip->default_spdif_control.channel.status[2] << 16) |
+	      (chip->default_spdif_control.channel.status[3] << 24);
+
+	if(val == old)
+		return 0;
+
+	spin_lock_irq(&chip->lock);
+	chip->default_spdif_control.channel = ucontrol->value.iec958;
+	spin_unlock_irq(&chip->lock);
+	return (val != old);
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_default __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_default_get,
+	.put =		snd_iec60958_default_put
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_stream __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_default_get,
+	.put =		snd_iec60958_default_put
+};
+
+static int snd_iec60958_maskc_get(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO          |
+					   IEC958_AES0_PROFESSIONAL      |
+					   IEC958_AES0_CON_NOT_COPYRIGHT |
+					   IEC958_AES0_CON_EMPHASIS;
+
+	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |
+					   IEC958_AES1_CON_CATEGORY;
+
+	ucontrol->value.iec958.status[2] = 0;
+
+	ucontrol->value.iec958.status[3] = 0;
+	return 0;
+}
+
+
+static int snd_iec60958_maskp_get(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO     |
+					   IEC958_AES0_PROFESSIONAL |
+					   IEC958_AES0_PRO_EMPHASIS;
+
+	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
+					   IEC958_AES1_PRO_USERBITS;
+
+	return 0;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_maskc __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskc_get,
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_mask __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskc_get,
+};
+
+
+static snd_kcontrol_new_t snd_iec60958_maskp __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
+	.info =		snd_iec60958_info,
+	.get =		snd_iec60958_maskp_get,
+};
+
+
+static int snd_iec60958_raw_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+
+static int snd_iec60958_raw_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->iec60958_rawmode;
+	return 0;
+}
+
+
+static int snd_iec60958_raw_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned char old, val;
+
+	spin_lock_irq(&chip->lock);
+	old = chip->iec60958_rawmode;
+	val = ucontrol->value.integer.value[0];
+	chip->iec60958_rawmode = val;
+	spin_unlock_irq(&chip->lock);
+	return old != val;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_raw __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "RAW",
+	.info =		snd_iec60958_raw_info,
+	.get =		snd_iec60958_raw_get,
+	.put =		snd_iec60958_raw_put
+};
+
+
+static int snd_iec60958_sync_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.integer.value[0] = global_spdif_sync_status;
+	return 0;
+}
+
+
+static int snd_iec60958_sync_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+
+	unsigned char old, val;
+
+	old = get_spdif_syncing_status();
+	val = ucontrol->value.integer.value[0];
+	set_spdif_syncing_status(val);
+	return old != val;
+}
+
+
+static snd_kcontrol_new_t snd_iec60958_sync __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "PCM Sync",
+	.info =		snd_iec60958_raw_info, /* Reuse from the RAW switch */
+	.get =		snd_iec60958_sync_get,
+	.put =		snd_iec60958_sync_put
+};
+
+
+/*IEC61937 encoding mode status -  when transmitting a surround encoded data
+ * stream the repitition period of iec61937 pause bursts and external decode latency
+ *  are dependant on stream type*/
+
+
+typedef struct iec_encoding_mode_tbl {
+	char name[30];
+	iec_encodings_t id_flag;
+}iec_encoding_mode_tbl_t;
+
+static iec_encoding_mode_tbl_t iec_xfer_modes[12]=
+	{
+		{"IEC60958"	,ENCODING_IEC60958},
+		{"IEC61937_AC3"	,ENCODING_IEC61937_AC3},
+		{"IEC61937_DTS1",ENCODING_IEC61937_DTS_1},
+		{"IEC61937_DTS2",ENCODING_IEC61937_DTS_2},
+		{"IEC61937_DTS3",ENCODING_IEC61937_DTS_3},
+		{"IEC61937_MPEG_384",ENCODING_IEC61937_MPEG_384_FRAME},
+		{"IEC61937_MPEG_1152",ENCODING_IEC61937_MPEG_1152_FRAME},
+		{"IEC61937_MPEG_1024",ENCODING_IEC61937_MPEG_1024_FRAME},
+		{"IEC61937_MPEG_2304",ENCODING_IEC61937_MPEG_2304_FRAME},
+		{"IEC61937_MPEG_768",ENCODING_IEC61937_MPEG_768_FRAME},
+		{"IEC61937_MPEG_2304_LSF",ENCODING_IEC61937_MPEG_2304_FRAME_LSF},
+		{"IEC61937_MPEG_768_LSF",ENCODING_IEC61937_MPEG_768_FRAME_LSF},
+	};
+
+
+
+static int snd_iec_encoding_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = ENCODED_STREAM_TYPES;
+	if (uinfo->value.enumerated.item > (ENCODED_STREAM_TYPES-1))
+		uinfo->value.enumerated.item = (ENCODED_STREAM_TYPES);
+	strcpy(uinfo->value.enumerated.name,iec_xfer_modes[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int snd_iec_encoding_get(snd_kcontrol_t* kcontrol,snd_ctl_elem_value_t* ucontrol)
+{
+	int i;
+
+	for(i=0; i< ENCODED_STREAM_TYPES; i++)
+		ucontrol->value.integer.value[i] = iec_xfer_modes[i].id_flag;
+
+	return 0;
+}
+
+static int snd_iec_encoding_put(	 snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+	spin_lock_irq(&chip->lock);
+	chip->iec_encoding_mode = ucontrol->value.integer.value[0];
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_iec_encoding __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE)"Encoding",
+	.info =		snd_iec_encoding_info,
+	.get =		snd_iec_encoding_get,
+	.put =		snd_iec_encoding_put,
+};
+
+static int snd_clock_put(snd_kcontrol_t * kcontrol,snd_ctl_elem_value_t * ucontrol)
+{
+
+	pcm_hw_t *chip = snd_kcontrol_chip(kcontrol);
+
+	int direction = (((int)ucontrol->value.integer.value[1]) > 0) ? 1:0;
+	int adjusts=ucontrol->value.integer.value[0];
+
+	spin_lock_irq(&chip->lock);
+	adjust_audio_clock(chip->current_substream,adjusts,direction);
+
+	spin_unlock_irq(&chip->lock);
+
+	return 0;
+}
+
+
+
+static int snd_clock_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.min = -10000;
+	uinfo->value.integer.max = 10000;
+
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_clock_adjust  __devinitdata = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		"PLAYBACK Clock Adjust",
+	.info =		snd_clock_info,
+	.put =		snd_clock_put,
+};
+
+/*now three controls to specify the available encoding modes */
+
+static int __devinit snd_generic_create_controls(pcm_hw_t *chip)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_clock_adjust,chip));
+	if(err < 0)
+		return err;
+
+	return 0;
+}
+
+
+static int __devinit snd_iec60958_create_controls(pcm_hw_t *chip)
+{
+	int err;
+	snd_kcontrol_t *kctl;
+
+	if(chip->card_data->input_type == STM_DATA_TYPE_IEC60958)
+	{
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_iec60958_raw, chip));
+		if (err < 0)
+			return err;
+
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_iec60958_sync, chip));
+		if (err < 0)
+			return err;
+	}
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_default, chip));
+	if (err < 0)
+		return err;
+
+	/*
+	 * stream is a copy of default for the moment for application
+	 * compatibility, more investigation required
+	 */
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_stream, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_maskc, chip));
+	if (err < 0)
+		return err;
+
+	/*
+	 * Mask is a copy of the consumer mask.
+	 */
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_mask, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec60958_maskp, chip));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_iec_encoding,chip));
+	if(err < 0)
+		return err;
+
+	return 0;
+}
+
+
+static void format_iec60958_frame(snd_pcm_substream_t *substream,
+				  u32                 *left_subframe,
+				  u32                 *right_subframe)
+{
+	/*
+	 * Format for the SPDIF player. Note that the ordering of CUV is
+	 * the reverse of that specified in the SPDIF player specification,
+	 * but is correct with regards to the ST reference driver documentation.
+	 *
+     	 * 31 ..16 bit data16| 15 ext data 8 | 7 zero  4 | 3 ctrl bits 0
+    	 * |xxxxxxxxxxxxxxxx | ????????        0000      | VUC0
+    	 */
+	static const u32 channel_status_bit = (1 << 1);
+	static const u32 user_bit           = (1 << 2);
+	static const u32 validity_bit       = (1 << 3);
+
+        pcm_hw_t   *chip       = snd_pcm_substream_chip(substream);
+
+        u8 *channel_status = &chip->current_spdif_control.channel.status[0];
+	u8 *user           = &chip->current_spdif_control.user[0];
+        u8 *validity_l     = &chip->current_spdif_control.validity_l[0];
+        u8 *validity_r     = &chip->current_spdif_control.validity_r[0];
+	/*
+	 * Index and test bit for channel status and validity
+	 */
+        int word_index      = chip->iec60958_output_count/8;
+        u32 test_bit        = 1 << (chip->iec60958_output_count%8);
+        /*
+         * Index and test bits for the user bits, which are contiguous across
+         * L/R subframes.
+         */
+        int user_word_index = (chip->iec60958_output_count*2)/8;
+	u32 u_test_bit_l    = 1 << (chip->iec60958_output_count*2)%8;
+	u32 u_test_bit_r    = u_test_bit_l << 1;
+	u32 format_word_l   = 0;
+	u32 format_word_r   = 0;
+
+	if(chip->iec60958_output_count == 0) {
+		/*
+		 * Start of a new burst, so update the control bits
+		 */
+		chip->current_spdif_control = chip->pending_spdif_control;
+	}
+
+#if defined(CONFIG_STB7100_IEC_DEBUG)
+	static int print_debug;
+	if(chip->iec60958_output_count == 0){
+		if(*left_subframe == 0xf8720000 && *right_subframe == 0x4e1f0000)
+			print_debug = 1;
+	}
+
+	if(chip->iec60958_output_count == 8) {
+		print_debug = 0;
+	}
+
+	if(print_debug) {
+	  	printk("%03d: in(0x%08x,0x%08x) ",chip->iec60958_output_count,*left_subframe,*right_subframe);
+	}
+#endif
+    	/*
+    	 * channel status is only ever 35 bits long , so we can ingnore the
+	 * remaining 157 frames
+	 */
+    	if((word_index <5) && (channel_status[word_index] & test_bit))
+    	{
+    		format_word_l |= channel_status_bit;
+    		format_word_r |= channel_status_bit;
+    	}
+
+	if(user[user_word_index] & u_test_bit_l)
+		format_word_l |= user_bit;
+
+	if(user[user_word_index] & u_test_bit_r)
+		format_word_r |= user_bit;
+
+	if(validity_l[word_index] & test_bit)
+		format_word_l |= validity_bit;
+
+	if(validity_r[word_index] & test_bit)
+		format_word_r |= validity_bit;
+
+	*left_subframe  = (*left_subframe  & 0xffffff00) | format_word_l;
+	*right_subframe = (*right_subframe & 0xffffff00) | format_word_r;
+
+#if defined(CONFIG_STB7100_IEC_DEBUG)
+	if(print_debug) {
+		printk("%03d: out(0x%08x,0x%08x)\n",chip->iec60958_output_count,*left_subframe,*right_subframe);
+	}
+#endif
+	chip->iec60958_output_count = (chip->iec60958_output_count+1)%192;
+}
+
+/*
+ * Internal function which can be called independently by other modules
+ * to get IEC60958 formatting. Note the interface is slightly manipulated
+ * to allow channels to be skipped in the buffer.
+ */
+int snd_pcm_format_iec60958_copy(snd_pcm_substream_t	*substream,
+				 int			data_channels,
+			 	 snd_pcm_uframes_t	pos,
+			 	 void	__user		*buffer,
+			 	 snd_pcm_uframes_t	count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	u32 __user        *buf32   = (u32 __user *) buffer;
+	int i;
+
+	/*
+	 * Note that runtime->channels must be 2 for an SPDIF device
+	 * which maps to the two subframes in an SPDIF frame. Each subframe
+	 * is 32bits, so each "output frame" is 8 bytes (2x4).
+	 */
+	int dstwidth  = sizeof(u32)*2;
+	int srcwidth  = samples_to_bytes(runtime, data_channels);
+	int bit_width = snd_pcm_format_physical_width(substream->runtime->format);
+
+        u32 *hwbuf    = (u32*)(runtime->dma_area + (pos*dstwidth));
+
+	if(!access_ok(VERIFY_READ, buffer, (count * srcwidth)))
+		return -EFAULT;
+
+
+	for(i=0;i<count;i++)
+	{
+		u32 left_subframe;
+		u32 right_subframe;
+
+		__get_user(left_subframe, buf32);
+		__get_user(right_subframe, buf32+1);
+
+		if(bit_width == 24)
+		{
+		  /*
+		   * We can support S24_LE (24bits in the bottom 3bytes of
+		   * a 32bit word) by shifting the audio bits into position
+		   */
+		  left_subframe  <<= 8;
+		  right_subframe <<= 8;
+		}
+
+		format_iec60958_frame(substream, &left_subframe, &right_subframe);
+
+		*hwbuf     = left_subframe;
+		*(hwbuf+1) = right_subframe;
+
+		buf32  += data_channels;
+	    	hwbuf  += 2;
+	}
+
+	dma_cache_wback((void*)(runtime->dma_area + (pos*dstwidth)), (count*dstwidth));
+
+	return 0;
+}
+
+
+/*
+ * This is the ALSA interface for the card "ops" structure
+ */
+static int snd_iec60958_silence(snd_pcm_substream_t *substream,
+				int                  channel,
+				snd_pcm_uframes_t    pos,
+				snd_pcm_uframes_t    count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	u32               *hwbuf;
+	static const int dstwidth  = sizeof(u32)*2;
+	int i;
+
+        if(channel != -1)
+                return -EINVAL;
+
+        hwbuf = (u32*)(runtime->dma_area + (pos*dstwidth));
+
+	for(i=0;i<count;i++)
+	{
+		u32 left_subframe  = 0;
+		u32 right_subframe = 0;
+
+		format_iec60958_frame(substream, &left_subframe, &right_subframe);
+
+		*hwbuf     = left_subframe;
+		*(hwbuf+1) = right_subframe;
+
+	    	hwbuf += 2;
+	}
+
+	dma_cache_wback((void*)(runtime->dma_area + (pos*dstwidth)), (count*dstwidth));
+
+        return 0;
+}
+
+
+static int snd_iec60958_copy(snd_pcm_substream_t  *substream,
+			     int                   channel,
+			     snd_pcm_uframes_t     pos,
+			     void __user          *buf,
+			     snd_pcm_uframes_t     count)
+{
+        pcm_hw_t *chip = snd_pcm_substream_chip(substream);
+
+	if(channel != -1)
+		return -EINVAL;
+
+	if(chip->iec60958_rawmode)
+		return snd_pcm_copy(substream,channel,pos,buf,count);
+	else
+		return snd_pcm_format_iec60958_copy(substream,substream->runtime->channels,pos,buf,count);
+}
+
+
+static void snd_card_pcm_free(snd_pcm_t *pcm)
+{
+	DEBUG_PRINT(("snd_card_pcm_free(pcm = 0x%08lx)\n",pcm));
+
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+
+static snd_pcm_ops_t  snd_card_playback_ops_pcm = {
+	.open      =            snd_pcm_playback_open,
+        .close     =            snd_pcm_playback_close,
+        .mmap      =            snd_pcm_mmap,
+        .silence   =            snd_pcm_silence,
+	.copy      =            snd_pcm_copy,
+        .ioctl     =            snd_pcm_lib_ioctl,
+        .hw_params =            snd_pcm_playback_hwparams,
+        .hw_free   =            snd_pcm_playback_hwfree,
+        .prepare   =            snd_pcm_playback_prepare,
+        .trigger   =            snd_playback_trigger,
+        .pointer   =            snd_pcm_playback_pointer,
+};
+
+
+static snd_pcm_ops_t  snd_card_playback_ops_iec60958 = {
+	.open      =            snd_pcm_playback_open,
+        .close     =            snd_pcm_playback_close,
+        .mmap      =            snd_pcm_mmap,
+        .silence   =            snd_iec60958_silence,
+	.copy      =            snd_iec60958_copy,
+        .ioctl     =            snd_pcm_lib_ioctl,
+        .hw_params =            snd_pcm_playback_hwparams,
+        .hw_free   =            snd_pcm_playback_hwfree,
+        .prepare   =            snd_pcm_playback_prepare,
+        .trigger   =            snd_playback_trigger,
+        .pointer   =            snd_pcm_playback_pointer,
+};
+
+
+static int __devinit snd_card_pcm_allocate(pcm_hw_t *snd_card, int device,char* name)
+{
+	int err;
+	snd_pcm_t *pcm;
+
+	err = snd_pcm_new(snd_card->card,name,device, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+
+	if(snd_card->card_data->input_type == STM_DATA_TYPE_IEC60958)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_playback_ops_iec60958);
+	else
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_playback_ops_pcm);
+
+
+	pcm->private_data = snd_card;
+	pcm->private_free = snd_card_pcm_free;
+	pcm->info_flags   = 0;
+	strcpy(pcm->name, name);
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm,
+					SNDRV_DMA_TYPE_CONTINUOUS,
+					snd_dma_continuous_data(GFP_KERNEL),
+					PCM_PREALLOC_SIZE,
+					PCM_PREALLOC_MAX);
+	return 0;
+}
+
+
+static int __init alsa_card_init(void)
+{
+	int i=0;
+
+	for(i=0;i<SND_DRV_CARDS;i++){
+		if (snd_pcm_card_probe(i) < 0){
+			DEBUG_PRINT(("STm PCM Player not found or device busy\n"));
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+
+static void __exit alsa_card_exit(void)
+{
+	int i=0;
+
+	for(i=0;i<SND_DRV_CARDS;i++){
+		if(card_list[i].device)
+			snd_card_free(card_list[i].device);
+	}
+}
+
+EXPORT_SYMBOL(format_iec60958_frame);
+EXPORT_SYMBOL(snd_pcm_format_iec60958_copy);
+
+module_init(alsa_card_init)
+module_exit(alsa_card_exit)
diff -Naur linux-2.6.17.8/sound/stm/st_pcm.h linux-2.6.17.8-sh/sound/stm/st_pcm.h
--- linux-2.6.17.8/sound/stm/st_pcm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17.8-sh/sound/stm/st_pcm.h	2006-08-23 13:29:50.367875000 +0100
@@ -0,0 +1,296 @@
+/*
+ *  Definitions for ST PCM Player Sound Driver
+ *  Copyright (c) 2005 STMicroelectronics Limited
+ *  Authors: Stephen Gallimore <Stephen.Gallimore@st.com> and
+ *  Mark Glaisher <Mark.Glaisher@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef _PCM_PLAYER_HW_H
+#define _PCM_PLAYER_HW_H
+
+#include <sound/asound.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define INCR_FSYNTH    0x1
+#define DECR_FSYNTH    0x2
+#define SDIV_SHIFT_VAL 0x4000
+#define MD_SHIFT_VAL   0x8000
+
+/*make some named definitions to refer to each output device so we dont need to rely on the card number*/
+/*card majors*/
+#define PCM0_DEVICE			0
+#define PCM1_DEVICE			1
+#define SPDIF_DEVICE			2
+#define PROTOCOL_CONVERTER_DEVICE	3
+/*card minors*/
+#define MAIN_DEVICE			0
+
+struct pcm_hw_t;
+
+
+typedef enum {
+	STM_DATA_TYPE_LPCM,
+	STM_DATA_TYPE_IEC60958
+} stm_snd_data_type_t;
+
+
+typedef struct {
+        int                  major;
+        int                  minor;
+        stm_snd_data_type_t  input_type;
+        stm_snd_data_type_t  output_type;
+        snd_card_t          *device;
+        int                  in_use;
+} stm_snd_output_device_t;
+
+#define PCM_SAMPLE_SIZE_BYTES		4
+
+#if (STM_USE_BIGPHYS_AREA == 0)
+#define PCM_MAX_FRAMES			3276  /* <128k, max slab allocation */
+#define PCM_PREALLOC_SIZE		(128*1024)
+#define PCM_PREALLOC_MAX		(128*1024)
+#else
+#define PCM_MAX_FRAMES			48000 /* 1s @ 48KHz */
+/* Note: we cannot preallocate a buffer from ALSA if we want to
+ * use bigphysmem for large buffers and the standard page
+ * alocation for small buffers. The preallocation is spotted by
+ * the generic ALSA driver layer and the size is used to limit
+ * the buffer size requests before they even get to this driver.
+ * This overrides the buffer_bytes_max value in the hardware
+ * capabilities structure we set up.
+ */
+#define PCM_PREALLOC_SIZE		0
+#define PCM_PREALLOC_MAX		0
+#endif
+
+/*
+ * Buffers larger than 128k should come from bigphysmem to avoid
+ * page fragmentation and random resource starvation in the rest of
+ * the system. Buffers <=128k come from the ALSA dma memory allocation
+ * system, which uses get_free_pages directly, not a slab memory cache.
+ */
+#define PCM_BIGALLOC_SIZE		(128*1024)
+
+#define FRAMES_TO_BYTES(x,channels) (( (x) * (channels) ) * PCM_SAMPLE_SIZE_BYTES)
+#define BYTES_TO_FRAMES(x,channels) (( (x) / (channels) ) / PCM_SAMPLE_SIZE_BYTES)
+
+/*
+ * Common PCM Player Control register definitions
+ */
+#define PCMP_OPERATION_MASK		0x3
+#define PCMP_OFF			0x0
+#define PCMP_MUTE			0x1
+#define PCMP_ON				0x2
+
+#define PCMP_MEM_FMT_16_0		0
+#define PCMP_MEM_FMT_16_16		(1L<<2)
+#define PCMP_NO_ROUNDING		0
+#define PCMP_ROUNDING			(1L<<3)
+
+#define PCMP_DIV_MASK			0x00000ff0
+#define PCMP_FSYNTH_DIVIDE32_1		(0L<<4)
+#define PCMP_FSYNTH_DIVIDE32_128	(1L<<4)
+#define PCMP_FSYNTH_DIVIDE32_192	(6L<<4)
+#define PCMP_FSYNTH_DIVIDE32_256	(2L<<4)
+#define PCMP_FSYNTH_DIVIDE32_384	(3L<<4)
+#define PCMP_FSYNTH_DIVIDE32_512	(4L<<4)
+#define PCMP_FSYNTH_DIVIDE32_784	(6L<<4)
+
+#define PCMP_IGNORE_SPDIF_LATENCY	0
+#define PCMP_WAIT_SPDIF_LATENCY		(1L<<12)
+
+#define PCMP_SAMPLES_SHIFT		13
+/*
+ * The sample count field is 19bits wide, so the maximum size
+ * is 2^20-1 = 104,857. However becuase we count a sample for every
+ * channel and we usually have 10 channel PCM Players it is helpful
+ * to make this a nice round number that is a multiple of 10.
+ */
+#define PCMP_MAX_SAMPLES		(104000)
+
+/*
+ * PCM Player Format register definitions
+ */
+#define PCMP_FORMAT_16			1
+#define PCMP_FORMAT_32			0
+#define PCMP_LENGTH_24			0
+#define PCMP_LENGTH_20			(1L<<1)
+#define PCMP_LENGTH_18			(2L<<1)
+#define PCMP_LENGTH_16			(3L<<1)
+
+#define PCMP_LRLEVEL_LEFT_LOW		0
+#define PCMP_LRLEVEL_LEFT_HIGH		(1L<<3)
+#define PCMP_CLK_RISING			0
+#define PCMP_CLK_FALLING		(1L<<4)
+
+/* Danger Will Robinson Danger Danger!!!
+ * the data delay by one bit logic is inverted
+ */
+#define PCMP_PADDING_ON			0
+#define PCMP_PADDING_OFF		(1L<<5)
+
+#define PCMP_ALIGN_START		0
+#define PCMP_ALIGN_END			(1L<<6)
+#define PCMP_LSB_FIRST			0
+#define PCMP_MSB_FIRST			(1L<<7)
+
+#define PCMP_STATUS_RUNNING		(1L<<0)
+#define PCMP_STATUS_UNDERFLOW		(1L<<1)
+#define PCMP_STATUS_ALLREAD		(1L<<2)
+
+/*
+ * DVD category code definition for convenience.
+ */
+#define IEC958_AES1_CON_NON_IEC908_DVD (IEC958_AES1_CON_LASEROPT_ID|0x018)
+
+/*
+ * Extension to the ALSA channel status definitions for consumer mode 24bit
+ * wordlength.
+ */
+#define IEC958_AES4_CON_WORDLEN_MAX_24 (1<<0)
+#define IEC958_AES4_CON_WORDLEN_24_20  (5<<1)
+
+typedef enum iec_encodings {
+	ENCODING_IEC60958 = 0,
+	ENCODING_IEC61937_AC3,
+	ENCODING_IEC61937_DTS_1,
+	ENCODING_IEC61937_DTS_2,
+	ENCODING_IEC61937_DTS_3,
+	ENCODING_IEC61937_MPEG_384_FRAME,
+	ENCODING_IEC61937_MPEG_1152_FRAME,
+	ENCODING_IEC61937_MPEG_1024_FRAME,
+	ENCODING_IEC61937_MPEG_2304_FRAME,
+	ENCODING_IEC61937_MPEG_768_FRAME,
+	ENCODING_IEC61937_MPEG_2304_FRAME_LSF,
+	ENCODING_IEC61937_MPEG_768_FRAME_LSF,
+}iec_encodings_t;
+
+#define ENCODED_STREAM_TYPES  12
+
+typedef struct IEC60958 {
+	/* Channel status bits are the same for L/R subframes */
+       	snd_aes_iec958_t  channel;
+
+        /* Validity bits can be different on L and R e.g. in
+         * professional applications
+         */
+        u8                validity_l[24];
+        u8                validity_r[24];
+        /* User bits are considered contiguous across L/R subframes */
+        u8                user[48];
+}IEC60958_t;
+
+
+typedef struct {
+	int			(*free_device)     (struct pcm_hw_t *card);
+	int			(*open_device)     (snd_pcm_substream_t *substream);
+	int			(*program_hw)      (snd_pcm_substream_t *substream);
+	snd_pcm_uframes_t	(*playback_pointer)(snd_pcm_substream_t *substream);
+
+	void			(*start_playback)  (snd_pcm_substream_t *substream);
+	void			(*stop_playback)   (snd_pcm_substream_t *substream);
+	void			(*pause_playback)  (snd_pcm_substream_t *substream);
+	void			(*unpause_playback)(snd_pcm_substream_t *substream);
+} stm_playback_ops_t;
+
+typedef struct _IEC61937 {
+	int pause_mode; /*do we attmept a pause burst of mute with null ? */
+	int mute_rep;	/**/
+	int pause_count;
+	int frame_size;/*frames per burst*/
+	int latency;/*61937 defined maximum decode latency*/
+	int unpause_flag;
+}IEC61937_t;
+
+typedef struct pcm_hw_t {
+	snd_card_t		*card;
+
+	spinlock_t		lock;
+	int			irq;
+        stm_snd_output_device_t *card_data;
+	unsigned long		buffer_start_addr;
+	unsigned long		pcmplayer_control;
+	unsigned long		irq_mask;
+	snd_pcm_hardware_t      hw;
+
+	snd_pcm_uframes_t    	hwbuf_current_addr;
+	snd_pcm_substream_t 	*current_substream;
+	char		   	*out_pipe;
+	char		    	*pcm_clock_reg;
+	char 			*pcm_player;
+	char                    *pcm_converter;
+	int		     	are_clocks_active;
+	int                     oversampling_frequency;
+
+	stm_playback_ops_t	*playback_ops;
+
+        IEC60958_t              current_spdif_control;
+        IEC60958_t              pending_spdif_control;
+        IEC60958_t              default_spdif_control;
+
+	int                     iec60958_output_count;
+	char			iec60958_rawmode;
+	char 			iec_encoding_mode;
+
+	IEC61937_t 		iec61937;
+
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+        int 			spdif_player_mode;
+	int			fdma_channel;
+#endif
+} pcm_hw_t;
+
+struct stm_freq_s {
+	u32 freq;
+	u32 sdiv_val;
+	u32 pe_val;
+	u32 md_val;
+	u32 pe_quantum;
+};
+
+#define NUM_CLOCK_SETTINGS	5
+
+#define PCM0_SYNC_ID		2
+#define PCM1_SYNC_ID		4
+#define SPDIF_SYNC_MODE_ON	1
+
+#define chip_t pcm_hw_t
+
+static int snd_pcm_dev_free(snd_device_t *dev);
+
+static int __devinit snd_card_pcm_allocate(pcm_hw_t *stm8000, int device,char* name);
+static int __devinit snd_iec60958_create_controls(pcm_hw_t *chip);
+static int __devinit snd_generic_create_controls(pcm_hw_t *chip);
+
+
+void set_spdif_syncing_status(int enable);
+
+extern void iec60958_default_channel_status(pcm_hw_t *chip);
+extern void iec60958_set_runtime_status(snd_pcm_substream_t *substream);
+
+
+#define DEBUG_PRINT(_x)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _ST_PCM_H */
