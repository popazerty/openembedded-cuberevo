From 99750f045f9747761225165221f0572d4e7d399d Mon Sep 17 00:00:00 2001
From: Angus CLARK <angus.clark@st.com>
Date: Wed, 22 Apr 2009 09:41:24 +0100
Subject: [PATCH] stm_nand_flex: First release of STM_NAND_FLEX driver

This is the first release of the STM_NAND_FLEX driver which provides support for
the STMicroelectronics H/W NAND controller operating in FLEX mode.  This driver
is required for NAND access on systems with boot-from-nand enabled.

Notes:

1) Uses S/W ECC generation/correction
2) FDMA support unavailable at present
3) Provides support for boot partition ECC format.
4) Updates platform device template such that STM_NAND_EMI and STM_NAND_FLEX
   can coexist (must be on different EMI CS#).

Signed-off-by: Angus Clark <angus.clark@st.com>
---
 arch/sh/boards/st/cb101/setup.c   |    6 +-
 arch/sh/boards/st/common/mb588.c  |    4 +-
 drivers/mtd/nand/Kconfig          |   21 +-
 drivers/mtd/nand/Makefile         |    1 +
 drivers/mtd/nand/nand_base.c      |   30 +-
 drivers/mtd/nand/stm_nand_ecc.c   |  359 +++++++++++++
 drivers/mtd/nand/stm_nand_ecc.h   |  149 ++++++
 drivers/mtd/nand/stm_nand_emi.c   |   16 +-
 drivers/mtd/nand/stm_nand_flex.c  | 1047 +++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/stm_nandc_regs.h |   87 +++
 include/linux/stm/soc_init.h      |    7 +-
 11 files changed, 1701 insertions(+), 26 deletions(-)
 create mode 100644 drivers/mtd/nand/stm_nand_ecc.c
 create mode 100644 drivers/mtd/nand/stm_nand_ecc.h
 create mode 100644 drivers/mtd/nand/stm_nand_flex.c
 create mode 100644 drivers/mtd/nand/stm_nandc_regs.h

diff --git a/arch/sh/boards/st/cb101/setup.c b/arch/sh/boards/st/cb101/setup.c
index 6c29038..4411d3a 100644
--- a/arch/sh/boards/st/cb101/setup.c
+++ b/arch/sh/boards/st/cb101/setup.c
@@ -171,8 +171,10 @@ static struct plat_stmnand_data nand_config = {
 };
 
 static struct platform_device nand_devices[] = {
-	STM_NAND_DEVICE(1, &nand_config, nand1_parts, ARRAY_SIZE(nand1_parts)),
-	STM_NAND_DEVICE(2, &nand_config, nand2_parts, ARRAY_SIZE(nand2_parts)),
+	STM_NAND_DEVICE("stm-nand-emi", 1, &nand_config,
+			nand1_parts, ARRAY_SIZE(nand1_parts), 0),
+	STM_NAND_DEVICE("stm-nand-emi", 2, &nand_config, nand2_parts,
+			ARRAY_SIZE(nand2_parts), 0),
 };
 
 #ifdef CONFIG_SND
diff --git a/arch/sh/boards/st/common/mb588.c b/arch/sh/boards/st/common/mb588.c
index da5c3d8..87bc5e8 100644
--- a/arch/sh/boards/st/common/mb588.c
+++ b/arch/sh/boards/st/common/mb588.c
@@ -87,8 +87,8 @@ static struct plat_stmnand_data nand_config = {
  * device structure.  SoC setup will configure SoC specific data.
  */
 static struct platform_device nand_device =
-	STM_NAND_DEVICE(STEM_CS0_BANK, &nand_config,
-			nand_parts, ARRAY_SIZE(nand_parts));
+	STM_NAND_DEVICE("stm-nand-emi", STEM_CS0_BANK, &nand_config,
+			nand_parts, ARRAY_SIZE(nand_parts), 0);
 
 #endif
 
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index f338d2b..810a5c2 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -281,7 +281,7 @@ config MTD_NAND_PLATFORM
 	  via platform_data.
 
 config MTD_NAND_STM_EMI
-       tristate "STMicroelectronics NAND support: EMI 'bit-banging'"
+       tristate "STMicroelectronics: EMI 'bit-banging'"
        depends on MTD_NAND
        depends on (CPU_SUBTYPE_STX7111 || \
        	       	  	CPU_SUBTYPE_STX7200 || \
@@ -323,6 +323,25 @@ config STM_NAND_EMI_CACHED
 
 endchoice
 
+config MTD_NAND_STM_FLEX
+       tristate "STMicroelectronics: H/W FLEX Controller"
+       depends on CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200
+       help
+         Enables the STMicroelectronics NAND Controller operating in FLEX mode.
+         This driver is required to access NAND devices when boot-from-NAND is
+         enabled.
 
+config STM_NAND_FLEX_BOOTMODESUPPORT
+        bool "Enable support for boot mode ECC"
+        depends on MTD_NAND_STM_FLEX
+        help
+          This option enables support for boot partition ECC format.
+
+config STM_NAND_FLEX_BOOTPARTITION
+        string "Name of boot partition" if STM_NAND_FLEX_BOOTMODESUPPORT
+        depends on MTD_NAND_STM_FLEX
+        default "Boot firmware"
+	help	
+	  Name of NAND partition on which to use boot mode ECC format
 
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index e3b220b..b6c8ec4 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -28,5 +28,6 @@ obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_BASLER_EXCITE)	+= excite_nandflash.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
 obj-$(CONFIG_MTD_NAND_STM_EMI)		+= stm_nand_emi.o
+obj-$(CONFIG_MTD_NAND_STM_FLEX)		+= stm_nand_flex.o stm_nand_ecc.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 24ac677..a06b495 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -82,11 +82,11 @@ static struct nand_ecclayout nand_oob_64 = {
 		 .length = 38}}
 };
 
-static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
-			   int new_state);
+int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
+		    int new_state);
 
-static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
-			     struct mtd_oob_ops *ops);
+int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+		      struct mtd_oob_ops *ops);
 
 /*
  * For devices which display every fart in the system on a seperate LED. Is
@@ -100,7 +100,7 @@ DEFINE_LED_TRIGGER(nand_led_trigger);
  *
  * Deselect, release chip lock and wake up anyone waiting on the device
  */
-static void nand_release_device(struct mtd_info *mtd)
+void nand_release_device(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -114,6 +114,7 @@ static void nand_release_device(struct mtd_info *mtd)
 	wake_up(&chip->controller->wq);
 	spin_unlock(&chip->controller->lock);
 }
+EXPORT_SYMBOL_GPL(nand_release_device);
 
 /**
  * nand_read_byte - [DEFAULT] read one byte from the chip
@@ -665,7 +666,7 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
  *
  * Get the device and lock it for exclusive access
  */
-static int
+int
 nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
 {
 	spinlock_t *lock = &chip->controller->lock;
@@ -695,6 +696,7 @@ nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
 	remove_wait_queue(wq, &wait);
 	goto retry;
 }
+EXPORT_SYMBOL_GPL(nand_get_device);
 
 /**
  * nand_wait - [DEFAULT]  wait until the command is done
@@ -952,8 +954,8 @@ static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
  *
  * Internal function. Called with chip held.
  */
-static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
-			    struct mtd_oob_ops *ops)
+int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
+		     struct mtd_oob_ops *ops)
 {
 	int chipnr, page, realpage, col, bytes, aligned;
 	struct nand_chip *chip = mtd->priv;
@@ -1077,6 +1079,7 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 
 	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
 }
+EXPORT_SYMBOL_GPL(nand_do_read_ops);
 
 /**
  * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
@@ -1262,7 +1265,7 @@ static int nand_write_oob_syndrome(struct mtd_info *mtd,
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
+int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
 			    struct mtd_oob_ops *ops)
 {
 	int page, realpage, chipnr, sndcmd = 1;
@@ -1346,6 +1349,7 @@ static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
 	ops->oobretlen = ops->ooblen;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(nand_do_read_oob);
 
 /**
  * nand_read_oob - [MTD Interface] NAND read data and/or out-of-band
@@ -1619,8 +1623,8 @@ static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
  *
  * NAND write with ECC
  */
-static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
-			     struct mtd_oob_ops *ops)
+int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
+		      struct mtd_oob_ops *ops)
 {
 	int chipnr, realpage, page, blockmask, column;
 	struct nand_chip *chip = mtd->priv;
@@ -1711,6 +1715,7 @@ static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
 		ops->oobretlen = ops->ooblen;
 	return ret;
 }
+EXPORT_SYMBOL_GPL(nand_do_write_ops);
 
 /**
  * nand_write - [MTD Interface] NAND write with ECC
@@ -1757,7 +1762,7 @@ static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
  *
  * NAND write out-of-band
  */
-static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 			     struct mtd_oob_ops *ops)
 {
 	int chipnr, page, status, len;
@@ -1828,6 +1833,7 @@ static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(nand_do_write_oob);
 
 /**
  * nand_write_oob - [MTD Interface] NAND write data and/or out-of-band
diff --git a/drivers/mtd/nand/stm_nand_ecc.c b/drivers/mtd/nand/stm_nand_ecc.c
new file mode 100644
index 0000000..072d6ad
--- /dev/null
+++ b/drivers/mtd/nand/stm_nand_ecc.c
@@ -0,0 +1,359 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008 STMicroelectronics Limited.  All right reserved.
+ *
+ * See stm_nand_ecc.h for a description of this module.
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License Version 2.0 only.  See linux/COPYING for more information.
+ *
+ * Changelog:
+ *    2009-02-25 Angus Clark <angus.clark@st.com>
+ *
+ *        - Renamed, formatted, and edited for linux compatibility
+ *
+ *        - Added clause in stm_ecc_correct() to hanlde inconsistency between
+ *          data and expected ecc for freshly erased page.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "stm_nand_ecc.h"
+
+static const uint8_t byte_parity_table[] =   /* Parity look up table */
+{
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00
+};
+
+static const uint8_t  bit_count_table[] =   /* Parity look up table */
+{
+  0, 1, 1, 2, 1, 2, 2, 3,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  5, 6, 6, 7, 6, 7, 7, 8
+};
+
+/******************************************************************************/
+#define COL_LOOP_STEP(c__f, c__e, c__o, c__t)		\
+	do {						\
+		c__o ^= (c__f ? c__t : 1);		\
+		c__e ^= (c__f ? 1 : c__t);		\
+	} while (0)
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the date and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+*/
+void stm_ecc_gen(const uint8_t *p_data, uint8_t *ecc, enum ecc_size size)
+{
+	uint32_t *p_data_long = (uint32_t *)p_data;
+	uint32_t parity_bits[18];  /* maximum number */
+	uint32_t reg32;
+	uint32_t temp;
+	uint32_t int_cnt;
+	uint32_t bit_cnt;
+
+	unsigned int num_parity_bits;
+
+	uint8_t *p_byt;
+	uint8_t byte_reg;
+	uint8_t byte_a;
+	uint8_t byte_b;
+	uint8_t byte_c;
+	uint8_t byte_d;
+
+	ecc[0] = 0;
+	ecc[1] = 0;
+	ecc[2] = 0;
+
+	switch (size) {
+	case ECC_128:
+		num_parity_bits = 14;
+		break;
+	case ECC_256:
+		num_parity_bits = 16;
+		break;
+	case ECC_512:
+		num_parity_bits = 18;
+		break;
+	default:
+		printk(KERN_ERR "Internal error in ecc_gen: unknown format\n");
+		BUG();
+		return;
+	}
+
+	/* Initialize variables */
+	byte_reg = 0;
+	reg32 = 0;
+
+	for (bit_cnt = 0; bit_cnt < num_parity_bits; bit_cnt ++)
+		parity_bits[bit_cnt] = 0;
+
+	/* Build up column parity */
+	for (int_cnt = 0; int_cnt < size/sizeof(uint32_t); int_cnt++) {
+		temp = p_data_long[int_cnt];
+
+		switch (size) {
+		case ECC_512:
+			COL_LOOP_STEP((int_cnt & 0x40), parity_bits[16],
+				      parity_bits[17], temp);
+			/* fall through */
+		case ECC_256:
+			COL_LOOP_STEP((int_cnt & 0x20), parity_bits[14],
+				      parity_bits[15], temp);
+			/* fall through */
+		case ECC_128:
+			COL_LOOP_STEP((int_cnt & 0x01), parity_bits[4],
+				      parity_bits[5], temp);
+			COL_LOOP_STEP((int_cnt & 0x02), parity_bits[6],
+				      parity_bits[7], temp);
+			COL_LOOP_STEP((int_cnt & 0x04), parity_bits[8],
+				      parity_bits[9], temp);
+			COL_LOOP_STEP((int_cnt & 0x08), parity_bits[10],
+				      parity_bits[11], temp);
+			COL_LOOP_STEP((int_cnt & 0x10), parity_bits[12],
+				      parity_bits[13], temp);
+		}
+	}
+
+	reg32 = parity_bits[12] ^ parity_bits[13];
+
+	p_byt = (uint8_t *)&reg32;
+#if __LITTLE_ENDIAN__
+	byte_a = p_byt[3];
+	byte_b = p_byt[2];
+	byte_c = p_byt[1];
+	byte_d = p_byt[0];
+#else
+	byte_a = p_byt[0];
+	byte_b = p_byt[1];
+	byte_c = p_byt[2];
+	byte_d = p_byt[3];
+#endif
+
+	byte_reg = byte_a ^ byte_b ^ byte_c ^ byte_d;
+	byte_reg = byte_parity_table[byte_reg] >> 1;
+
+	/* Create line parity */
+	parity_bits[0] = byte_d ^ byte_b;
+	parity_bits[1] = byte_c ^ byte_a;
+	parity_bits[2] = byte_d ^ byte_c;
+	parity_bits[3] = byte_b ^ byte_a;
+
+	for (bit_cnt = 4; bit_cnt < num_parity_bits; bit_cnt++) {
+		p_byt = (uint8_t *)(parity_bits + bit_cnt);
+		/* NB Only LS Byte of parity_bits used from now on */
+		p_byt[0] ^= (p_byt[1] ^ p_byt[2] ^ p_byt[3]);
+	}
+
+	/* Calculate final ECC code */
+	for (bit_cnt = 0; bit_cnt < 8; bit_cnt++)
+		ecc[0] |=
+			(byte_parity_table[(uint8_t)parity_bits[bit_cnt]] &
+			 0x01) << bit_cnt;
+	for (; bit_cnt < 16 && bit_cnt < num_parity_bits; bit_cnt++)
+		ecc[1] |=
+			(byte_parity_table[(uint8_t)parity_bits[bit_cnt]] &
+			 0x01) << (bit_cnt - 8);
+	for (; bit_cnt < num_parity_bits; bit_cnt++)
+		ecc[2] |=
+			(byte_parity_table[(uint8_t)parity_bits[bit_cnt]] &
+			 0x01) << (bit_cnt - 16);
+
+	ecc[2] = (uint8_t)(byte_reg << 2) | (ecc[2] & 0x03);
+}
+EXPORT_SYMBOL_GPL(stm_ecc_gen);
+
+/******************************************************************************/
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+enum ecc_check stm_ecc_correct(uint8_t *p_data,
+			       uint8_t *old_ecc,
+			       uint8_t *new_ecc,
+			       enum ecc_size size)
+{
+	uint8_t bit_cnt02;
+	uint8_t bit_addr02;
+	unsigned int byte_addr02;
+
+	uint8_t ecc_xor[3];
+
+	uint8_t error_bit_count;
+
+	switch (size) {
+	case ECC_128:
+		error_bit_count = 10;
+		break;
+	case ECC_256:
+		error_bit_count = 11;
+		break;
+	case ECC_512:
+		error_bit_count = 12;
+		break;
+	default:
+		printk(KERN_ERR "Internal error in ecc_gen: unknown format\n");
+		BUG();
+		return E_UN_CHK;
+	}
+
+	/* Basic Error Detection phase */
+	ecc_xor[0] = new_ecc[0] ^ old_ecc[0];
+	ecc_xor[1] = new_ecc[1] ^ old_ecc[1];
+	ecc_xor[2] = new_ecc[2] ^ old_ecc[2];
+
+	if ((ecc_xor[0] | ecc_xor[1] | ecc_xor[2]) == 0) {
+		return E_NO_CHK;  /* No errors */
+	}
+	/* If we get here then there were errors */
+	if (ecc_xor[0] == 0xff &&
+	    ecc_xor[1] == 0xff &&
+	    ecc_xor[2] == 0xff) {
+		/* Probably a freshly erased page: All 0xff's, including OOB,
+		   but expecting 0x00, 0x00, 0x00 for ECC data
+		*/
+		return E_NO_CHK;
+	}
+	if (size == ECC_512) {
+		/* 512-byte error correction requires a little more than 128 or
+		   256.  If there is a correctable error then the xor will have
+		   12 bits set, but there can also be 12 bits set in some
+		   uncorrectable errors.  This can be solved by xoring the odd
+		   and even numbered bits.
+
+		   0xAA = 10101010
+		   0x55 = 01010101
+		*/
+		bit_cnt02  = bit_count_table[((ecc_xor[0] & 0xAA) >> 1) ^
+					      (ecc_xor[0] & 0x55)];
+		bit_cnt02 += bit_count_table[((ecc_xor[1] & 0xAA) >> 1) ^
+					      (ecc_xor[1] & 0x55)];
+		bit_cnt02 += bit_count_table[((ecc_xor[2] & 0xAA) >> 1) ^
+					      (ecc_xor[2] & 0x55)];
+	} else {
+		/* Counts the number of bits set in ecc code */
+		bit_cnt02  = bit_count_table[ecc_xor[0]];
+		bit_cnt02 += bit_count_table[ecc_xor[1]];
+		bit_cnt02 += bit_count_table[ecc_xor[2]];
+	}
+
+	if (bit_cnt02 == error_bit_count) {
+		/* Set the bit address */
+		bit_addr02 = ((ecc_xor[2] >> 3) & 0x01) |
+			((ecc_xor[2] >> 4) & 0x02) |
+			((ecc_xor[2] >> 5) & 0x04);
+
+		/* Evaluate 2 LS bits of address */
+		byte_addr02 = ((ecc_xor[0] >> 1) & 0x01) |
+			((ecc_xor[0] >> 2) & 0x02);
+
+		/* Add in remaining bits of address */
+		switch (size) {
+		case ECC_512:
+			byte_addr02 |= (((unsigned int)ecc_xor[2]) << 7)
+				& 0x100;
+			/* Fall through */
+		case ECC_256:
+			byte_addr02 |= (ecc_xor[1] & 0x80);
+			/* Fall through */
+		case ECC_128:
+			byte_addr02 |= ((ecc_xor[0] >> 3) & 0x04) |
+				((ecc_xor[0] >> 4) & 0x08) |
+				((ecc_xor[1] << 3) & 0x10) |
+				((ecc_xor[1] << 2) & 0x20) |
+				((ecc_xor[1] << 1) & 0x40);
+		}
+		printk(KERN_WARNING "%s: correcting bit "
+		       "(ECC block offset %03d:%d)\n",
+		       __FUNCTION__, byte_addr02, bit_addr02);
+		/* Correct bit error in the data */
+		p_data[byte_addr02] ^= (0x01 << bit_addr02);
+
+		/* NB p_old_code is okay, p_new_code is corrupt */
+		return E_D1_CHK;  /* Data had 1-bit error (now corrected) */
+	} else {
+		if (bit_cnt02 == 1) {
+			printk(KERN_WARNING "%s: error in ECC, data ok\n",
+			       __FUNCTION__);
+			return E_C1_CHK;  /* ECC has 1-bit error, data is ok */
+		} else {
+			printk(KERN_ERR "%s: uncorrectable error\n",
+			       __FUNCTION__);
+			return E_UN_CHK;  /* Uncorrectable Error */
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(stm_ecc_correct);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Angus Clark");
+MODULE_DESCRIPTION("STMicroelectronics NAND ECC support");
+
diff --git a/drivers/mtd/nand/stm_nand_ecc.h b/drivers/mtd/nand/stm_nand_ecc.h
new file mode 100644
index 0000000..e4c99a3
--- /dev/null
+++ b/drivers/mtd/nand/stm_nand_ecc.h
@@ -0,0 +1,149 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008 STMicroelectronics Limited.  All right reserved.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License Version 2.0 only.  See linux/COPYING for more information.
+ *
+ * An ECC is a 3-byte code which can be used to detect and correct 1-bit
+ * errors (perhaps introduced by NAND flash defects) in a 128, 256, or
+ * 512-byte block of data.
+ *
+ * Features:
+ *   - Correction of any 1-bit error in the data.
+ *   - Detection of any 1-bit error in the ECC and whether the data is OK.
+ *   - Detection of any 2-bit error in the data.
+ *
+ * Limitations:
+ *   - CANNOT correct 2-bit errors.
+ *   - Results for 3-bit errors (or worse) are UNDEFINED.
+ *
+ * This algorithm is only intended for use with data corrupted by a NAND
+ * flash - in which anything more than a 1-bit error is highly unlikely.
+ *
+ * DO NOT attempt to use it where the data may be more seriously corrupted.
+ * The algorithm WILL NOT always correct serious defects and may even report
+ * that the data is good.
+ *
+ * Usage
+ * =====
+ *
+ * Writing flash:
+ *
+ *   1) Prepare the data.
+ *   2) Generate an ECC for each 128, 256, or 512 bytes.
+ *        stm_ecc_gen (data, ecc, ECC_256)
+ *   3) Write both to flash.
+ *
+ * Reading flash:
+ *
+ *   1) Read both data and ECC from flash.
+ *   2) Generate a fresh ECC for the read data.
+ *        ecc_gen (read_data, new_ecc, ECC_256)
+ *   3) Compare the two ECCs and correct the data, if necessary.
+ *        ecc_correct (read_data, read_ecc, new_ecc, ECC_256)
+ *   4) Check the return code:
+ *        E_UN_CHK
+ *            Data cannot be used - too badly corrupted.
+ *        E_NO_CHK
+ *            All is well.
+ *        E_D1_CHK
+ *            Data has been corrected, but the flash block contains an error.
+ *        E_C1_CHK
+ *            Data is OK, but the flash block contains an error in the ECC.
+ *
+ * If a read error occurs then you may want to consider moving the data to
+ * another flash block. If the read error is in the ECC then don't forget
+ * to generate a correct ECC before rewriting.
+ *
+ * ECC Format
+ * ==========
+ *
+ * Basic Format:
+ *
+ *      		byte 0		byte 1		byte2
+ *
+ *      bit 0		LP0		LP8		LP16
+ *      bit 1		LP1		LP9		LP17
+ *      bit 2		LP2		LP10	`	CP0
+ *      bit 3		LP3		LP11		CP1
+ *      bit 4		LP4		LP12		CP2
+ *      bit 5		LP5		LP13		CP3
+ *      bit 6		LP6		LP14		CP4
+ *      bit 7		LP7		LP15		CP5
+ *
+ *      CP = Column parity
+ *      LP = Line parity
+ *
+ * ECC_128:
+ *
+ *      LP14-17 are not used. The unused bits are set to zero.
+ *
+ *      This format is designed to match the format used by the error
+ *      correcting EMI NAND Controller. It may NOT be compatible with other
+ *      128 byte ECCs.
+ *
+ * ECC_256:
+ *
+ *      LP16-17 are not used. The unused bits are set to zero.
+ *
+ * ECC_512:
+ *
+ *      All bits are used.
+ *
+ *      This format is NOT compatible with the 512 byte ECC used by OSPlus.
+ *      (At the time of writing, this can be resolved merely by inverting each
+ *      bit in the ECC, but this may not be the case in future.)
+ *
+ * Changelog:
+ *    2009-02-25 Angus Clark <angus.clark@st.com>
+ *        - Renamed, formatted, and edited for linux compatibility
+ *
+ */
+
+#ifndef STM_NAND_ECC_H
+#define STM_NAND_ECC_H
+
+#include <linux/types.h>
+
+/* The ECC algorithms support three different data sizes. */
+enum ecc_size
+{
+  ECC_128 = 128,
+  ECC_256 = 256,
+  ECC_512 = 512
+};
+
+/* Return values from check function */
+enum ecc_check
+{
+  E_UN_CHK = -1, /* uncorrectable error. */
+  E_NO_CHK = 0,  /* No Errors. */
+  E_D1_CHK = 1,  /* 1-bit data error. */
+  E_C1_CHK = 2   /* 1-bit code error. */
+};
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the date and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+void stm_ecc_gen(const uint8_t *p_data, uint8_t *ecc,
+		 enum ecc_size size);
+
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+enum ecc_check stm_ecc_correct(uint8_t *p_data,
+			       uint8_t *old_ecc,
+			       uint8_t *new_ecc,
+			       enum ecc_size size);
+
+#endif /* ifndef STM_NAND_ECC_H */
+
diff --git a/drivers/mtd/nand/stm_nand_emi.c b/drivers/mtd/nand/stm_nand_emi.c
index 8742e92..8c24010 100644
--- a/drivers/mtd/nand/stm_nand_emi.c
+++ b/drivers/mtd/nand/stm_nand_emi.c
@@ -40,7 +40,7 @@
 #include <linux/stm/soc.h>
 #include <linux/stm/nand.h>
 
-#define NAME	"stm-nand"
+#define NAME	"stm-nand-emi"
 
 /*
  * Private data for stm_emi_nand driver.  Concurrency and device locking
@@ -484,7 +484,7 @@ static int nand_config_emi(int bank, struct nand_timing_data *td)
 	uint32_t bus_release;
 	uint32_t wait_active_low;
 
-	printk(KERN_INFO NAME "Configuring EMI Bank %d for NAND access\n",
+	printk(KERN_INFO NAME ": Configuring EMI Bank %d for NAND access\n",
 	       bank);
 
 	if (!td) {
@@ -545,6 +545,8 @@ static int __init stm_nand_emi_probe(struct platform_device *pdev)
 	struct plat_stmnand_data *stmdata = pdata->ctrl.priv;
 
 	struct stm_nand_emi *data;
+	struct nand_timing_data *tm;
+
 	int res = 0;
 
 	/* Allocate memory for the driver structure (and zero it) */
@@ -562,9 +564,6 @@ static int __init stm_nand_emi_probe(struct platform_device *pdev)
 	data->emi_size = (1 << 18) + 1;
 
 	/* Configure EMI Bank */
-	printk(KERN_INFO NAME ": Configuring EMI Bank%d for NAND device\n",
-	       data->emi_bank);
-
 	if (nand_config_emi(data->emi_bank, stmdata->timing_data) != 0) {
 		printk(KERN_ERR NAME ": Failed to configure EMI bank "
 		       "for NAND device\n");
@@ -624,9 +623,11 @@ static int __init stm_nand_emi_probe(struct platform_device *pdev)
 	/* Assign more sensible name (default is string from nand_ids.c!) */
 	data->mtd.name = pdev->dev.bus_id;
 
+	tm = stmdata->timing_data;
+
 	data->chip.IO_ADDR_R = data->io_base;
 	data->chip.IO_ADDR_W = data->io_base;
-	data->chip.chip_delay = stmdata->chip_delay;
+	data->chip.chip_delay = tm->chip_delay;
 	data->chip.cmd_ctrl = nand_cmd_ctrl_emi;
 
 	/* Do we have access to NAND_RBn? */
@@ -702,7 +703,8 @@ static int __init stm_nand_emi_probe(struct platform_device *pdev)
  out6:
 
 	nand_release(&data->mtd);
-	stpio_free_pin(data->rbn);
+	if (data->rbn)
+		stpio_free_pin(data->rbn);
 	platform_set_drvdata(pdev, NULL);
 	iounmap(data->io_addr);
  out5:
diff --git a/drivers/mtd/nand/stm_nand_flex.c b/drivers/mtd/nand/stm_nand_flex.c
new file mode 100644
index 0000000..b8cb125
--- /dev/null
+++ b/drivers/mtd/nand/stm_nand_flex.c
@@ -0,0 +1,1047 @@
+/*
+ *  ---------------------------------------------------------------------------
+ *  stm_nand_flex.c STMicroelectronics NAND Flash driver: H/W FLEX mode
+ *  ---------------------------------------------------------------------------
+ *
+ *  Copyright (c) 2009 STMicroelectronics Limited
+ *  Author: Angus Clark <Angus.Clark@st.com>
+ *
+ *  ---------------------------------------------------------------------------
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License Version 2.0 only.  See linux/COPYING for more information.
+ *  ---------------------------------------------------------------------------
+ *
+ *  Notes:
+ *
+ *   - Basic implementation initialises the NAND controller and overrides the
+ *     MTD control layer (see flex_cmd_ctrl(), flex_read_byte(),
+ *     flex_write_byte(), flex_rbn() and flex_select_chip()).
+ *
+ *   - FDMA and NAND Controller in FLEX mode has not been validated.  FDMA
+ *     support diabled for the moment.
+ *
+ *   - Support for BOOT mode partitions has been added.  We maintain 2 sets of
+ *     ECC-related parameters, and override the MTD read/write functions to
+ *     switch ECC scheme depending on which partition we are in (see
+ *     flex_setup_eccparam(), flex_select_eccparams(), nand_read(),
+ *     nand_read_oob(), nand_write, nand_write_oob()).  Need to force
+ *     chip.options NAND_USE_FLASH_BBT, since BOOT mode ECC layout is
+ *     incompatible with factory-written bad-block markers.
+ *
+ *  TODO:
+ *
+ *    - Test board with multiple NAND devices
+ *
+ *    - Optimise nand_command and nand_command_lp to issue multibyte commands in
+ *      one go.
+ *
+ *    - Add support for x16 devices.  Should just be a matter of configuring
+ *      FLEX data register...
+ *
+ *  Changelog:
+ *	2009-03-12 Angus Clark <angus.clark@st.com>
+ *		- first version
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+#include <linux/clk.h>
+#include <linux/stm/stm-dma.h>
+#include <linux/stm/fdma-reqs.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/nand.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include "stm_nandc_regs.h"
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+
+#define NAME	"stm-nand-flex"
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+#include "stm_nand_ecc.h"
+/* NAND_BOOT uses a different ECC scheme to that of NAND_FLEX/NAND_AFM.  In
+ * order to support the NAND_BOOT partition we need to maintain 2 sets of
+ * ECC-related paramters, and switch depending which partition we wish to
+ * access.
+ */
+struct ecc_params {
+	/* nand_chip params */
+	struct nand_ecc_ctrl	ecc_ctrl;
+	int			subpagesize;
+
+	/* mtd_info params */
+	u_int32_t		subpage_sft;
+};
+#endif /* CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT */
+
+/* NAND device connected to STM NAND Controller operatring in FLEX mode.  (There
+ * may be several NAND device connected to the NAND controller.)
+ */
+struct stm_nand_flex_device {
+
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+	int			csn;
+
+	struct nand_timing_data *timing_data;
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+	unsigned long		boot_start;
+	unsigned long		boot_end;
+	struct ecc_params	ecc_boot;
+	struct ecc_params	ecc_flex;
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Partition Table */
+	int			nr_parts;
+	struct mtd_partition	*parts;
+#endif
+
+};
+
+/* STM NAND Controller operating in FLEX mode */
+struct stm_nand_flex_controller {
+	struct resource		*mem_region;
+	void __iomem		*base_addr;
+
+	int			current_csn;		/* Current chip	      */
+
+	struct nand_hw_control	hwcontrol;		/* Aribitrate access  */
+							/* to FLEX devices    */
+
+	int			initialised;
+
+	uint8_t			*buf;			/* Bounce buffer for  */
+							/* non-aligned xfer   */
+
+	void __iomem		*data_phys;
+	int			dma_chan;		/* FDMA channel	      */
+	unsigned long		init_fdma_jiffies;	/* Rate limit init    */
+	struct stm_dma_params	dma_params[4];		/* FDMA params        */
+} flex;
+
+#define flex_writereg(val, reg)	iowrite32(val, flex.base_addr + (reg))
+#define flex_readreg(reg)	ioread32(flex.base_addr + (reg))
+
+static const char *part_probes[] = { "cmdlinepart", NULL };
+
+/*** FLEX mode control functions (cf nand_base.c) ***/
+
+/* Assumes EMINAND_DATAREAD has been configured for 1-byte reads. */
+static uint8_t flex_read_byte(struct mtd_info *mtd)
+{
+	uint32_t reg;
+
+	reg =  flex_readreg(EMINAND_FLEX_DATA);
+
+	return (uint8_t)(reg & 0xff);
+}
+
+static void flex_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	static unsigned int flex_ctrl;
+	uint32_t reg;
+
+	if (ctrl & NAND_CTRL_CHANGE)
+		flex_ctrl = ctrl;
+
+	if (cmd != NAND_CMD_NONE) {
+		if (flex_ctrl & NAND_CLE) {
+			reg = (cmd & 0xff) | FLX_CMD_REG_BEAT_1;
+			flex_writereg(reg, EMINAND_FLEX_COMMAND_REG);
+		} else if (flex_ctrl & NAND_ALE) {
+			reg = (cmd & 0xff) | FLX_ADDR_REG_ADD8_VALID |
+				FLX_ADDR_REG_BEAT_1;
+			flex_writereg(reg, EMINAND_FLEX_ADDRESS_REG);
+		} else {
+			printk(KERN_ERR NAME "%s: unknown ctrl 0x%02x!\n",
+			       __FUNCTION__, flex_ctrl);
+		}
+	}
+}
+
+static int flex_rbn(struct mtd_info *mtd)
+{
+	/* Apply a small delay before sampling RBn signal */
+	ndelay(500);
+	return (flex_readreg(EMINAND_RBN_STATUS) & (0x4)) ? 1 : 0;
+}
+
+/* FLEX mode ECC requires 4-byte read/writes.  To maintain compatibility with
+ * MTD framework, the FLEX data register is, by default, configured for 1-byte
+ * read/writes.  Therefore, we must switch temporarily to 4-byte read/writes.
+ * In addition, readsl/writesl requires buf to be 4-byte aligned.  If necessary
+ * we use flex.buf as bounce buffer.
+ */
+static void flex_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	uint8_t *p;
+
+	/* Handle non-aligned buffer */
+	p = ((uint32_t)buf & 0x3) ? flex.buf : buf;
+
+	/* Switch to 4-byte reads (required for ECC) */
+	flex_writereg(0x00000000, EMINAND_FLEX_DATAREAD_CONFIG);
+
+	readsl(flex.base_addr + EMINAND_FLEX_DATA, p, len/4);
+
+	if (p != buf)
+		memcpy(buf, p, len);
+
+	/* Switch back to 1-byte reads */
+	flex_writereg(0x10000000, EMINAND_FLEX_DATAREAD_CONFIG);
+}
+
+static void flex_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	uint8_t *p;
+
+	/* Handle non-aligned buffer */
+	if ((uint32_t)buf & 0x3) {
+		p = flex.buf;
+		memcpy(p, buf, len);
+	} else {
+		p = buf;
+	}
+
+	/* Switch to 4-byte reads (required for ECC), and wait RBn */
+	flex_writereg(0x00000000, EMINAND_FLEX_DATAWRITE_CONFIG);
+
+	writesl(flex.base_addr + EMINAND_FLEX_DATA, p, len/4);
+
+	/* Switch back to 1-byte writes  */
+	flex_writereg(0x10000000, EMINAND_FLEX_DATAWRITE_CONFIG);
+}
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+/* OOB Layout for Boot Mode HW ECC (SP and LP devices) */
+static struct nand_ecclayout boot_oob_16 = {
+	.eccbytes = 12,
+	.eccpos = {0, 1, 2,
+		   4, 5, 6,
+		   8, 9, 10,
+		   12, 13, 14},
+	.oobfree = {
+		{3, 1}, { 7, 1}, {11, 1}, {15, 1},
+	},
+};
+
+static struct nand_ecclayout boot_oob_64 = {
+	.eccbytes = 48,
+	.eccpos = {
+		0,  1,  2,	/* ECC for  1st 128-byte record */
+		4,  5,  6,	/* ECC for  2nd 128-byte record */
+		8,  9, 10,	/* ECC for  3rd 128-byte record */
+		12, 13, 14,	/* ECC for  4th 128-byte record */
+		16, 17, 18,	/* ECC for  5th 128-byte record */
+		20, 21, 22,	/* ECC for  6th 128-byte record */
+		24, 25, 26,	/* ECC for  7th 128-byte record */
+		28, 29, 30,	/* ECC for  8th 128-byte record */
+		32, 33, 34,	/* ECC for  9th 128-byte record */
+		36, 37, 38,	/* ECC for 10th 128-byte record */
+		40, 41, 42,	/* ECC for 11th 128-byte record */
+		44, 45, 46,	/* ECC for 12th 128-byte record */
+		48, 49, 50,	/* ECC for 13th 128-byte record */
+		52, 53, 54,	/* ECC for 14th 128-byte record */
+		56, 57, 58,	/* ECC for 15th 128-byte record */
+		60, 61, 62,	/* ECC for 16th 128-byte record */
+	},
+	.oobfree = {
+		{ 3, 1}, { 7, 1}, {11, 1}, {15, 1},
+		{19, 1}, {23, 1}, {27, 1}, {31, 1},
+		/* !!! .oobfree is fixed size of 8 - increasing size would break
+		   userspace abi.  For the moment, just expose 8 free bytes
+		  {35, 1}, {39, 1}, {43, 1}, {47, 1},
+		  {51, 1}, {55, 1}, {59, 1}, {63, 1}
+		*/
+	},
+};
+
+/* Replicated from ../mtdpart.c: required here to get slave MTD offsets and
+ * determine which ECC mode to use.
+ */
+struct mtd_part {
+	struct mtd_info mtd;
+	struct mtd_info *master;
+	u_int32_t offset;
+	int index;
+	struct list_head list;
+	int registered;
+};
+
+#define PART(x)  ((struct mtd_part *)(x))
+
+/* Boot mode ECC calc/correct function */
+int boot_calc_ecc(struct mtd_info *mtd, const unsigned char *buf,
+		  unsigned char *ecc)
+{
+	stm_ecc_gen(buf, ecc, ECC_128);
+
+	return 0;
+}
+
+int boot_correct_ecc(struct mtd_info *mtd, unsigned char *buf,
+		     unsigned char *read_ecc, unsigned char *calc_ecc)
+{
+	int status;
+
+	status = stm_ecc_correct(buf, read_ecc, calc_ecc, ECC_128);
+
+	/* convert to MTD-compatible status */
+	if (status == E_NO_CHK)
+		return 0;
+	if (status == E_D1_CHK || status == E_C1_CHK)
+		return 1;
+
+	return -1;
+}
+
+/* Setup ECC params for NAND_BOOT and NAND_FLEX.  The intial 'nand_scan()' sets
+ * up ECC parameters for NAND_FLEX mode.  Here, we take a copy of the exisiting
+ * NAND_FLEX paramters, and derive a set of NAND_BOOT paramters.
+ */
+static void flex_setup_eccparams(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stm_nand_flex_device *data = chip->priv;
+	int i;
+
+	/* Take a copy of ECC FLEX params, as set up during nand_scan() */
+	data->ecc_flex.ecc_ctrl = chip->ecc;
+	data->ecc_flex.subpagesize = chip->subpagesize;
+	data->ecc_flex.subpage_sft = mtd->subpage_sft;
+
+	/* Set ECC BOOT params */
+	data->ecc_boot.ecc_ctrl = data->ecc_flex.ecc_ctrl;
+	data->ecc_boot.ecc_ctrl.calculate = boot_calc_ecc;
+	data->ecc_boot.ecc_ctrl.correct = boot_correct_ecc;
+	data->ecc_boot.ecc_ctrl.size = 128;
+	data->ecc_boot.ecc_ctrl.bytes = 3;
+
+	if (mtd->oobsize == 16)
+		data->ecc_boot.ecc_ctrl.layout = &boot_oob_16;
+	else
+		data->ecc_boot.ecc_ctrl.layout = &boot_oob_64;
+
+	/* Derive remaing ECC BOOT params - see nand_base.c:nand_scan_tail() */
+	data->ecc_boot.ecc_ctrl.layout->oobavail = 0;
+	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
+		     data->ecc_boot.ecc_ctrl.layout->oobfree[i].length; i++)
+		data->ecc_boot.ecc_ctrl.layout->oobavail +=
+			data->ecc_boot.ecc_ctrl.layout->oobfree[i].length;
+
+	data->ecc_boot.ecc_ctrl.steps = mtd->writesize /
+		data->ecc_boot.ecc_ctrl.size;
+	if (data->ecc_boot.ecc_ctrl.steps * data->ecc_boot.ecc_ctrl.size !=
+	    mtd->writesize) {
+		printk(KERN_WARNING "Invalid ECC parameters\n");
+		BUG();
+	}
+	data->ecc_boot.ecc_ctrl.total = data->ecc_boot.ecc_ctrl.steps *
+		data->ecc_boot.ecc_ctrl.bytes;
+
+	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
+	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
+		switch (data->ecc_boot.ecc_ctrl.steps) {
+		case 2:
+			data->ecc_boot.subpage_sft = 1;
+			break;
+		case 4:
+		case 8:
+		case 16:
+			data->ecc_boot.subpage_sft = 2;
+			break;
+		}
+	}
+	data->ecc_boot.subpagesize = mtd->writesize >>
+		data->ecc_boot.subpage_sft;
+}
+
+/* Set MTD to use ECC params */
+static void flex_set_eccparams(struct mtd_info *mtd, struct ecc_params *params)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->ecc = params->ecc_ctrl;
+	chip->subpagesize = params->subpagesize;
+
+	mtd->oobavail = params->ecc_ctrl.layout->oobavail;
+	mtd->subpage_sft = params->subpage_sft;
+}
+
+static void flex_select_eccparams(struct mtd_info *mtd, loff_t offs)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stm_nand_flex_device *data = chip->priv;
+
+	if (offs >= data->boot_start &&
+	    offs < data->boot_end) {
+		if (chip->ecc.layout != data->ecc_boot.ecc_ctrl.layout) {
+			DEBUG(MTD_DEBUG_LEVEL0, NAME
+			      ": Switching to BOOT mode ECC\n");
+			flex_set_eccparams(mtd, &data->ecc_boot);
+		}
+	} else {
+		if (chip->ecc.layout != data->ecc_flex.ecc_ctrl.layout) {
+			DEBUG(MTD_DEBUG_LEVEL0, NAME
+			      ": Switching to FLEX mode ECC\n");
+			flex_set_eccparams(mtd, &data->ecc_flex);
+		}
+	}
+}
+
+/* nand_base.c functions required by MTD interface functions defined below */
+int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
+		    int new_state);
+void nand_release_device(struct mtd_info *mtd);
+int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
+		     struct mtd_oob_ops *ops);
+int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
+		     struct mtd_oob_ops *ops);
+int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+		      struct mtd_oob_ops *ops);
+int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
+		      struct mtd_oob_ops *ops);
+
+/* Override the following functions (see nand_base.c), so that we can switch ECC
+ * scheme before starting xfer sequence.
+ */
+
+/**
+ * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ *
+ * Get hold of the chip and call nand_do_read
+ */
+static int nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		     size_t *retlen, uint8_t *buf)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_get_device(chip, mtd, FL_READING);
+
+	/** Added to support switching ECC format **/
+	flex_select_eccparams(mtd, from);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = nand_do_read_ops(mtd, from, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * nand_read_oob - [MTD Interface] NAND read data and/or out-of-band
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @ops:	oob operation description structure
+ *
+ * NAND read data and/or out-of-band data
+ */
+static int nand_read_oob(struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if (ops->datbuf && (from + ops->len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		      "Attempt read beyond end of device\n");
+		return -EINVAL;
+	}
+
+	nand_get_device(chip, mtd, FL_READING);
+
+	/** Added to support switching ECC format **/
+	flex_select_eccparams(mtd, from);
+
+	switch (ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = nand_do_read_oob(mtd, from, ops);
+	else
+		ret = nand_do_read_ops(mtd, from, ops);
+
+ out:
+	nand_release_device(mtd);
+	return ret;
+}
+
+/**
+ * nand_write - [MTD Interface] NAND write with ECC
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @len:	number of bytes to write
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @buf:	the data to write
+ *
+ * NAND write with ECC
+ */
+static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const uint8_t *buf)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_get_device(chip, mtd, FL_WRITING);
+
+	/** Added to support switching ECC format **/
+	flex_select_eccparams(mtd, to);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = (uint8_t *)buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = nand_do_write_ops(mtd, to, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * nand_write_oob - [MTD Interface] NAND write data and/or out-of-band
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @ops:	oob operation description structure
+ */
+static int nand_write_oob(struct mtd_info *mtd, loff_t to,
+			  struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow writes past end of device */
+	if (ops->datbuf && (to + ops->len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		      "Attempt read beyond end of device\n");
+		return -EINVAL;
+	}
+
+	nand_get_device(chip, mtd, FL_WRITING);
+
+	flex_select_eccparams(mtd, to);
+
+	switch (ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = nand_do_write_oob(mtd, to, ops);
+	else
+		ret = nand_do_write_ops(mtd, to, ops);
+
+ out:
+	nand_release_device(mtd);
+	return ret;
+}
+
+#endif /* CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT */
+
+
+/* Configure NAND controller timing registers */
+static void flex_set_timings(struct nand_timing_data *tm)
+{
+	uint32_t n;
+	uint32_t reg;
+	uint32_t emi_clk;
+	uint32_t emi_t_ns;
+
+	/* Timings set in terms of EMI clock cycles */
+	emi_clk = clk_get_rate(clk_get(NULL, "emi_master"));
+	emi_t_ns = 1000000000UL / emi_clk;
+
+	/* CONTROL_TIMING */
+	n = (tm->sig_setup + emi_t_ns - 1)/emi_t_ns;
+	reg = (n & 0xff) << 0;
+
+	n = (tm->sig_hold + emi_t_ns - 1)/emi_t_ns;
+	reg |= (n & 0xff) << 8;
+
+	n = (tm->CE_deassert + emi_t_ns - 1)/emi_t_ns;
+	reg |= (n & 0xff) << 16;
+
+	n = (tm->WE_to_RBn + emi_t_ns - 1)/emi_t_ns;
+	reg |= (n & 0xff) << 24;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "%s: CONTROL_TIMING = 0x%08x\n", NAME, reg);
+	flex_writereg(reg, EMINAND_CONTROL_TIMING);
+
+	/* WEN_TIMING */
+	n = (tm->wr_on + emi_t_ns - 1)/emi_t_ns;
+	reg = (n & 0xff) << 0;
+
+	n = (tm->wr_off + emi_t_ns - 1)/emi_t_ns;
+	reg |= (n & 0xff) << 8;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "%s: WEN_TIMING = 0x%08x\n", NAME, reg);
+	flex_writereg(reg, EMINAND_WEN_TIMING);
+
+	/* REN_TIMING */
+	n = (tm->rd_on + emi_t_ns - 1)/emi_t_ns;
+	reg = (n & 0xff) << 0;
+
+	n = (tm->rd_off + emi_t_ns - 1)/emi_t_ns;
+	reg |= (n & 0xff) << 8;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "%s: REN_TIMING = 0x%08x\n", NAME, reg);
+	flex_writereg(reg, EMINAND_REN_TIMING);
+}
+
+/* FLEX mode chip select: For now we only support 1 chip per
+ * 'stm_nand_flex_device' so chipnr will be 0 for select, -1 for deselect.
+ *
+ * So, if we change device:
+ *   - Set bank in mux_control_reg to data->csn
+ *   - Update read/write timings
+ */
+static void flex_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct stm_nand_flex_device *data = chip->priv;
+
+	/* Deselect, do nothing */
+	if (chipnr == -1) {
+		return;
+
+	} else if (chipnr == 0) {
+		/* If same chip as last time, no need to change anything */
+		if (data->csn == flex.current_csn)
+			return;
+
+		/* Set CSn on FLEX controller */
+		flex.current_csn = data->csn;
+		flex_writereg(0x1 << data->csn, EMINAND_MUXCONTROL_REG);
+
+		/* Set up timing parameters */
+		flex_set_timings(data->timing_data);
+
+	} else {
+		printk(KERN_ERR NAME ": attempt to select chipnr = %d\n",
+		       chipnr);
+	}
+
+	return;
+}
+
+#ifdef CONFIG_MTD_DEBUG
+static void flex_print_regs(void)
+{
+	printk(NAME ": FLEX Registers:\n");
+	printk(KERN_INFO "\tbootbank_config = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_BOOTBANK_CONFIG));
+	printk(KERN_INFO "\trbn_status = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_RBN_STATUS));
+	printk(KERN_INFO "\tinterrupt_enable = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_ENABLE));
+	printk(KERN_INFO "\tinterrupt_status = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_STATUS));
+	printk(KERN_INFO "\tinterrupt_clear = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_CLEAR));
+	printk(KERN_INFO "\tinterrupt_edgeconfig = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_EDGECONFIG));
+	printk(KERN_INFO "\tcontrol_timing = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_CONTROL_TIMING));
+	printk(KERN_INFO "\twen_timing = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_WEN_TIMING));
+	printk(KERN_INFO "\tren_timing = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_REN_TIMING));
+	printk(KERN_INFO "\tflexmode_config = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_FLEXMODE_CONFIG));
+	printk(KERN_INFO "\tmuxcontrol_reg = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_MUXCONTROL_REG));
+	printk(KERN_INFO "\tcsn_alternate_reg = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_CSN_ALTERNATE));
+	printk(KERN_INFO "\tmulti_cs_config_reg = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_MULTI_CS_CONFIG_REG));
+	printk(KERN_INFO "\tversion_reg = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_VERSION_REG));
+}
+#endif /* CONFIG_MTD_DEBUG */
+
+static int __init flex_init_controller(struct platform_device *pdev)
+{
+	struct resource *resource;
+	int res;
+
+	if (flex.initialised) {
+		flex.initialised++;
+		return 0;
+	}
+
+	/* Request IO Memory */
+	resource = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						"flex_mem");
+	if (!resource) {
+		printk(KERN_ERR NAME ": Failed to get FLEX IORESOURCE_MEM.\n");
+		res = -ENODEV;
+		goto out1;
+	}
+	flex.mem_region = request_mem_region(resource->start,
+					     resource->end -
+					     resource->start + 1,
+					     pdev->name);
+	if (!flex.mem_region) {
+		printk(KERN_ERR NAME ": Failed request memory region 0x%08x.\n",
+		       pdev->resource[0].start);
+		res = -EBUSY;
+		goto out1;
+	}
+
+	/* Map base address */
+	flex.base_addr = ioremap_nocache(resource->start,
+					 resource->end - resource->start + 1);
+	if (!flex.base_addr) {
+		printk(KERN_ERR NAME " Failed tp map base address  0x%08x\n",
+		       resource->start);
+		res = -EINVAL;
+		goto out2;
+	}
+
+	flex.buf = kmalloc(NAND_MAX_PAGESIZE +  NAND_MAX_OOBSIZE,
+			   GFP_KERNEL | __GFP_DMA);
+	if (!flex.buf) {
+		printk(KERN_ERR NAME " Failed allocate bounce buffer\n");
+		res = -ENOMEM;
+		goto out3;
+	}
+
+	flex.current_csn = -1;
+
+	/* Initialise 'controller' structure */
+	spin_lock_init(&flex.hwcontrol.lock);
+	init_waitqueue_head(&flex.hwcontrol.wq);
+
+	/* Reset FLEX Controller */
+	flex_writereg((0x1 << 3), EMINAND_FLEXMODE_CONFIG);
+	udelay(1);
+	flex_writereg(0x00, EMINAND_FLEXMODE_CONFIG);
+
+	/* Disable boot_not_flex */
+	flex_writereg(0x00000000, EMINAND_BOOTBANK_CONFIG);
+
+	/* Set Controller to FLEX mode */
+	flex_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
+
+	/* Not using interrupts in FLEX mode */
+	flex_writereg(0x00, EMINAND_INTERRUPT_ENABLE);
+
+	/* To fit with MTD framework, configure FLEX_DATA reg for 1-byte
+	 * read/writes
+	 */
+	flex_writereg(0x10000000, EMINAND_FLEX_DATAWRITE_CONFIG);
+	flex_writereg(0x10000000, EMINAND_FLEX_DATAREAD_CONFIG);
+
+#ifdef CONFIG_MTD_DEBUG
+	flex_print_regs();
+#endif
+	flex.initialised++;
+
+	return 0;
+ out3:
+	iounmap(flex.base_addr);
+ out2:
+	release_resource(flex.mem_region);
+ out1:
+	return res;
+}
+
+static void __devexit flex_exit_controller(struct platform_device *pdev)
+{
+	if (--flex.initialised)
+		return;
+
+	kfree(flex.buf);
+	iounmap(flex.base_addr);
+	release_resource(flex.mem_region);
+}
+
+static int __init stm_nand_flex_probe(struct platform_device *pdev)
+{
+	/* Platform data */
+	struct platform_nand_data *pdata = pdev->dev.platform_data;
+	struct plat_stmnand_data *stmdata = pdata->ctrl.priv;
+
+	struct stm_nand_flex_device *data;
+	int res;
+	int i;
+
+	uint32_t reg;
+	uint32_t prog[8] = {0};
+
+	/* Initialise AFM NAND controller */
+	res = flex_init_controller(pdev);
+	if (res != 0) {
+		printk(KERN_ERR NAME
+		       ": Failed to initialise AFM NAND Controller.\n");
+		return res;
+	}
+
+	/* Allocate memory for the device structure (and zero it) */
+	data = kzalloc(sizeof(struct stm_nand_flex_device), GFP_KERNEL);
+	if (!data) {
+		printk(KERN_ERR NAME
+		       ": Failed to allocate device structure.\n");
+		res = -ENOMEM;
+		goto out1;
+	}
+
+	/* House keeping :-) */
+	data->chip.priv = data;
+	data->mtd.priv = &data->chip;
+	data->mtd.owner = THIS_MODULE;
+	platform_set_drvdata(pdev, data);
+
+	/* Assign more sensible name (default is string from nand_ids.c!) */
+	data->mtd.name = pdev->dev.bus_id;
+	data->csn = pdev->id;
+
+	/* Use hwcontrol structure to manage access to FLEX Controller */
+	data->chip.controller = &flex.hwcontrol;
+	data->chip.state = FL_READY;
+
+	/* Get chip's timing data */
+	data->timing_data = stmdata->timing_data;;
+
+	/* Copy over chip specific platform data */
+	data->chip.chip_delay = data->timing_data->chip_delay;
+	data->chip.options = pdata->chip.options;
+	data->chip.options |= NAND_NO_SUBPAGE_WRITE; /* Not tested, disable */
+	data->chip.options |= NAND_NO_AUTOINCR;      /* Not tested, disable */
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+	/* Force use of BBT when BOOTMODESUPPORT enabled */
+	data->chip.options |= NAND_USE_FLASH_BBT;
+#endif
+	/* Callbacks for FLEX mode operation */
+	data->chip.cmd_ctrl = flex_cmd_ctrl;
+	data->chip.select_chip = flex_select_chip;
+	data->chip.read_byte = flex_read_byte;
+	data->chip.read_buf = flex_read_buf;
+	data->chip.write_buf = flex_write_buf;
+	if (stmdata->flex_rbn_connected)
+		data->chip.dev_ready = flex_rbn;
+
+	/* For now, use NAND_ECC_SOFT. Callbacks filled in during scan() */
+	data->chip.ecc.mode = NAND_ECC_SOFT;
+
+	/* Data IO */
+	data->chip.IO_ADDR_R = flex.base_addr + EMINAND_FLEX_DATA;
+	data->chip.IO_ADDR_W = flex.base_addr + EMINAND_FLEX_DATA;
+
+	/* Reset AFM program. Is this really necessary? */
+	memset(prog, 0, 32);
+	reg = flex_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
+	memcpy_toio(flex.base_addr + EMINAND_AFM_SEQUENCE_REG_1,
+		    prog, 32);
+
+	/* Scan to find existance of the device */
+	if (nand_scan(&data->mtd, 1)) {
+		printk(KERN_ERR NAME ":nand_scan failed\n");
+		res = -ENXIO;
+		goto out2;
+	}
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+	/* Setup ECC params, for NORMAL and BOOT operation */
+	flex_setup_eccparams(&data->mtd);
+	/* Override MTD NAND interface, to allow us to provide BOOT SUPPORT */
+	data->mtd.read = nand_read;
+	data->mtd.write = nand_write;
+	data->mtd.read_oob = nand_read_oob;
+	data->mtd.write_oob = nand_write_oob;
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* The way paritions are setup needed to changed to allow for the
+	   possibility of BOOT SUPPORT... */
+
+	/* Try probing for MTD partitions */
+	res = parse_mtd_partitions(&data->mtd,
+				   part_probes,
+				   &data->parts, 0);
+	if (res > 0)
+		data->nr_parts = res;
+
+	/* If that didn't work, try using partitions from platform data */
+	if (!data->nr_parts && pdata->chip.partitions) {
+		data->parts = pdata->chip.partitions;
+		data->nr_parts = pdata->chip.nr_partitions;
+	}
+
+	/* If we found some partitions, perform setup */
+	if (data->nr_parts) {
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+		struct mtd_part *part;
+		struct mtd_info *slave;
+
+		/* Allocate mtdp, so we can get hold of slave MTD devices
+		   (required for boot partition identification) */
+		for (i = 0; i < data->nr_parts; i++) {
+			data->parts[i].mtdp =
+				kzalloc(sizeof(struct mtd_partition *),
+					GFP_KERNEL);
+			if (!data->parts[i].mtdp) {
+				res = -ENOMEM;
+				goto out3;
+			}
+		}
+#endif /* CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT */
+
+		/* Setup slave MTD devices */
+		res = add_mtd_partitions(&data->mtd, data->parts,
+					 data->nr_parts);
+
+		if (res)
+			goto out3;
+
+#ifdef CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT
+		/* Regiter slave devices with MTD, and look for BOOT partition
+		 (only necessary if mtdp was allocated!) */
+		for (i = 0; i < data->nr_parts; i++) {
+			slave = *data->parts[i].mtdp;
+			part = PART(slave);
+
+			if (strcmp(slave->name,
+				   CONFIG_STM_NAND_FLEX_BOOTPARTITION) == 0) {
+				printk(KERN_INFO NAME ": Found BOOT parition"
+				       "[%s], updating ECC paramters\n",
+				       slave->name);
+
+				data->boot_start = part->offset;
+				data->boot_end = part->offset + slave->size;
+
+				slave->oobavail =
+				data->ecc_boot.ecc_ctrl.layout->oobavail;
+				slave->subpage_sft =
+					data->ecc_boot.subpage_sft;
+				slave->ecclayout =
+					data->ecc_boot.ecc_ctrl.layout;
+			}
+
+			add_mtd_device(slave);
+			part->registered = 1;
+		}
+#endif /* CONFIG_STM_NAND_FLEX_BOOTMODESUPPORT */
+	} else
+#endif
+		res = add_mtd_device(&data->mtd);
+
+	if (!res)
+		return res;
+
+ out3:
+	if (data->nr_parts) {
+		for (i = 0; i < data->nr_parts; i++)
+			kfree(data->parts[i].mtdp);
+	}
+ out2:
+	kfree(data);
+ out1:
+	flex_exit_controller(pdev);
+
+	return res;
+}
+
+
+static int __devexit stm_nand_flex_remove(struct platform_device *pdev)
+{
+	struct stm_nand_flex_device *data = platform_get_drvdata(pdev);
+	int i;
+
+	nand_release(&data->mtd);
+	platform_set_drvdata(pdev, NULL);
+	flex_exit_controller(pdev);
+
+	if (data->nr_parts)
+		for (i = 0; i < data->nr_parts; i++)
+			kfree(data->parts[i].mtdp);
+	kfree(data);
+
+	return 0;
+}
+
+static struct platform_driver stm_nand_flex_driver = {
+	.probe		= stm_nand_flex_probe,
+	.remove		= stm_nand_flex_remove,
+	.driver		= {
+		.name	= NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init stm_nand_flex_init(void)
+{
+	return platform_driver_register(&stm_nand_flex_driver);
+}
+
+static void __exit stm_nand_flex_exit(void)
+{
+	platform_driver_unregister(&stm_nand_flex_driver);
+}
+
+module_init(stm_nand_flex_init);
+module_exit(stm_nand_flex_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Angus Clark");
+MODULE_DESCRIPTION("STMicroelectronics NAND driver: H/W FLEX mode");
diff --git a/drivers/mtd/nand/stm_nandc_regs.h b/drivers/mtd/nand/stm_nandc_regs.h
new file mode 100644
index 0000000..ec86edb
--- /dev/null
+++ b/drivers/mtd/nand/stm_nandc_regs.h
@@ -0,0 +1,87 @@
+/*
+ *   STMicroelectronics NAND Controller
+ *
+ *   See ADCS #7864584: "NAND Flash support upgrades for FMI Functional
+ *   Secification".
+ *
+ *   Copyright (c) 2008 STMicroelectronics Limited
+ *   Author: Angus Clark <angus.clark@st.com>
+ *
+ *   May be copied or modified under the terms of the GNU General Public
+ *   License.  See linux/COPYING for more information.
+ *
+ */
+
+#ifndef STM_NANDC_REGS_H
+#define STM_NANDC_REGS_H
+
+#define EMINAND_CONFIG_SIZE			0x1000
+
+/* Register Addresses (OFFSET from EMINAND_CONFIG_BASE) */
+#define EMINAND_BOOTBANK_CONFIG			0x000
+#define EMINAND_RBN_STATUS			0x004
+#define EMINAND_INTERRUPT_ENABLE		0x010
+#define EMINAND_INTERRUPT_STATUS		0x014
+#define EMINAND_INTERRUPT_CLEAR			0x018
+#define EMINAND_INTERRUPT_EDGECONFIG		0x01C
+#define EMINAND_CONTROL_TIMING			0x040
+#define EMINAND_WEN_TIMING			0x044
+#define EMINAND_REN_TIMING			0x048
+#define EMINAND_FLEXMODE_CONFIG			0x100
+#define EMINAND_MUXCONTROL_REG			0x104
+#define EMINAND_CSN_ALTERNATE			0x108
+#define EMINAND_FLEX_DATAWRITE_CONFIG		0x10C
+#define EMINAND_FLEX_DATAREAD_CONFIG		0x110
+#define EMINAND_FLEX_COMMAND_REG		0x114
+#define EMINAND_FLEX_ADDRESS_REG		0x118
+#define EMINAND_FLEX_DATA			0x120
+#define EMINAND_VERSION_REG			0x144
+#define EMINAND_MULTI_CS_CONFIG_REG		0x1EC
+
+
+/* Advanced Flex Mode registers (OFFSET from EMINAND_CONFIG_BASE) */
+#define EMINAND_AFM_SEQUENCE_REG_1		0x200
+#define EMINAND_AFM_SEQUENCE_REG_2		0x204
+#define EMINAND_AFM_SEQUENCE_REG_3		0x208
+#define EMINAND_AFM_SEQUENCE_REG_4		0x20C
+#define EMINAND_AFM_ADDRESS_REG			0x210
+#define EMINAND_AFM_EXTRA_REG			0x214
+#define EMINAND_AFM_COMMAND_REG			0x218
+#define EMINAND_AFM_SEQUENCE_CONFIG_REG		0x21C
+#define EMINAND_AFM_GENERIC_CONFIG_REG		0x220
+#define EMINAND_AFM_SEQUENCE_STATUS_REG		0x240
+#define EMINAND_AFM_ECC_CHECKCODE_REG_0		0x280
+#define EMINAND_AFM_ECC_CHECKCODE_REG_1		0x284
+#define EMINAND_AFM_ECC_CHECKCODE_REG_2		0x288
+#define EMINAND_AFM_ECC_CHECKCODE_REG_3		0x28C
+#define EMINAND_AFM_DATA_FIFO			0x300
+
+/* AFM Commands */
+#define AFM_STOP				0x0
+#define AFM_CMD					0x1
+#define AFM_INC					0x2
+#define AFM_DEC_JUMP				0x3
+#define AFM_DATA				0x4
+#define AFM_SPARE				0x5
+#define AFM_CHECK				0x6
+#define AFM_ADDR				0x7
+#define AFM_WRBN				0xA
+
+/* FLEX: Address Register Fields */
+#define FLX_ADDR_REG_RBN			(0x1 << 27)
+#define FLX_ADDR_REG_BEAT_1			(0x1 << 28)
+#define FLX_ADDR_REG_BEAT_2			(0x2 << 28)
+#define FLX_ADDR_REG_BEAT_3			(0x3 << 28)
+#define FLX_ADDR_REG_BEAT_4			(0x0 << 28)
+#define FLX_ADDR_REG_ADD8_VALID			(0x1 << 30)
+#define FLX_ADDR_REG_CSN_STATUS			(0x1 << 31)
+
+/* FLEX: Commad Register fields */
+#define FLX_CMD_REG_RBN				(0x1 << 27)
+#define FLX_CMD_REG_BEAT_1			(0x1 << 28)
+#define FLX_CMD_REG_BEAT_2			(0x2 << 28)
+#define FLX_CMD_REG_BEAT_3			(0x3 << 28)
+#define FLX_CMD_REG_BEAT_4			(0x0 << 28)
+#define FLX_CMD_REG_CSN_STATUS			(0x1 << 31)
+
+#endif /* STM_NANDC_REGS_H */
diff --git a/include/linux/stm/soc_init.h b/include/linux/stm/soc_init.h
index 47869c1..e1c7f4d 100644
--- a/include/linux/stm/soc_init.h
+++ b/include/linux/stm/soc_init.h
@@ -187,9 +187,10 @@
 	}									\
 }
 
-#define STM_NAND_DEVICE(_id, _nand_config, _parts, _nr_parts)		\
+#define STM_NAND_DEVICE(_driver, _id, _nand_config,			\
+			_parts, _nr_parts, _chip_options)		\
 {									\
-	.name		= "stm-nand",					\
+	.name		= _driver,					\
 	.id		= _id,						\
 	.num_resources	= 2,  /* Note: EMI mem configured by driver */	\
 	.resource	= (struct resource[]) {				\
@@ -208,6 +209,8 @@
 			{						\
 				.partitions	= _parts,		\
 				.nr_partitions	= _nr_parts,		\
+				.options	= NAND_NO_AUTOINCR |	\
+						_chip_options,		\
 			},						\
 			.ctrl =						\
 			{						\
-- 
1.6.0.6

