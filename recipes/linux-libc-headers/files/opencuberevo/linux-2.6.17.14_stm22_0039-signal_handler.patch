This patch fixes two problems with the SH4 signal handler code:

1.  -ERESTART_RESTARTBLOCK is now caught correctly and translated into -EINTR.  
    This error is generated by the posix timer code amongst others.  The kernel
    should not return anything other than -EINTR to user space.
2.  The saved r0 is passed through to the handle_signal() function.  It is used
    in the case where the syscall is restarted.  As R0 is potentially used for
    passing a parameter, restarting without restoring this was not good!

Fix 1 fixes the LTP nanosleep03 test case
Fix 2 fixes the glibc tst-eintr1 failure.

Signed-off-by: Carl Shaw <carl.shaw@st.com>
Index: linux/arch/sh/kernel/signal.c
===================================================================
--- linux.orig/arch/sh/kernel/signal.c	2007-06-13 11:14:49.940820000 +0100
+++ linux/arch/sh/kernel/signal.c	2007-06-13 11:17:19.713116000 +0100
@@ -504,12 +504,13 @@
 
 static void
 handle_signal(unsigned long sig, struct k_sigaction *ka, siginfo_t *info,
-	      sigset_t *oldset, struct pt_regs *regs)
+	      sigset_t *oldset, struct pt_regs *regs, unsigned int save_r0)
 {
 	/* Are we from a system call? */
 	if (regs->tra >= 0) {
 		/* If so, check system call restarting.. */
 		switch (regs->regs[0]) {
+			case -ERESTART_RESTARTBLOCK:
 			case -ERESTARTNOHAND:
 				regs->regs[0] = -EINTR;
 				break;
@@ -521,6 +522,7 @@
 				}
 			/* fallthrough */
 			case -ERESTARTNOINTR:
+				regs->regs[0] = save_r0;
 				regs->pc -= 2;
 		}
 	}
@@ -575,7 +577,7 @@
 	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
 	if (signr > 0) {
 		/* Whee!  Actually deliver the signal.  */
-		handle_signal(signr, &ka, &info, oldset, regs);
+		handle_signal(signr, &ka, &info, oldset, regs, save_r0);
 		return 1;
 	}
 
