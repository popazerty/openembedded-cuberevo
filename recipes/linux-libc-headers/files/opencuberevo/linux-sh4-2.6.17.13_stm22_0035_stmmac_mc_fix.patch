This patch fixes multicast support in the 7109 ethernet driver.
It also fixes the RX csum calculation.

Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Signed-off-by: Carl Shaw <carl.shaw@st.com>

--- linux/drivers/net/stmmac.c.orig	2006-11-22 09:08:07.426280000 +0000
+++ linux/drivers/net/stmmac.c	2006-11-22 08:27:26.149890000 +0000
@@ -72,6 +72,10 @@
  *	  - <min_rx_pkt_size>: copy only tiny-frames.
  * ----------------------------------------------------------------------------
  * Changelog:
+ *   November 2006:
+ *	- Reviewed the Multicast support.
+ *	- Fixed the rx csum.
+ *	- Reviewed the driver function comments.
  *   September 2006:
  *	- Reviewed the transmit function.
  *      - Added the TCP Segmentation Offload (TSO) support.
@@ -150,7 +154,7 @@
 		printk(KERN_##klevel fmt, ## args))
 #else
 #define ETHPRINTK(nlevel, klevel, fmt, args...)  do { } while(0)
-#endif /*CONFIG_STMMAC_DEBUG */
+#endif				/*CONFIG_STMMAC_DEBUG */
 
 /* It only enables the debug information, in the transmit function,
  * for the TSO support. */
@@ -162,14 +166,14 @@
 		printk(KERN_##klevel fmt, ## args)
 #else
 #define TSOPRINTK(mss, klevel, fmt, args...)  do { } while(0)
-#endif /* STMMAC_TSO_DEBUG */
+#endif				/* STMMAC_TSO_DEBUG */
 
 #ifdef CONFIG_CPU_SUBTYPE_STB7100
 #define SYSCONF_BASE 		0xb9001000
 #define SYSCONF_DEVICEID        (SYSCONF_BASE + 0x000)
 #define SYSCONF_SYS_CFG(n)      (SYSCONF_BASE + 0x100 + ((n) * 4))
 #endif
-#define MAC_SPEED_SEL		0x00100000 /* MAC is running at 100 Mbps */
+#define MAC_SPEED_SEL		0x00100000	/* MAC is running at 100 Mbps */
 
 #define DMA_BUFFER_SIZE	0x800
 #define TDES1_MAX_BUF1_SIZE ((0x7fff << DES1_RBS1_SIZE_SHIFT) & \
@@ -181,13 +185,14 @@
 #define MIN_MTU 46
 #define MAX_MTU 9000
 
+#define HASH_TABLE_SIZE 64
 /* This structure is common for both receive and transmit DMA descriptors.
  * A descriptor should not be used for storing more than one frame. */
 struct dma_desc_t {
-	unsigned int des0; /* Status */
-	unsigned int des1; /* Ctrl bits, Buffer 2 length, Buffer 1 length */
-	unsigned int des2; /* Buffer 1 */
-	unsigned int des3; /* Buffer 2 */
+	unsigned int des0;	/* Status */
+	unsigned int des1;	/* Ctrl bits, Buffer 2 length, Buffer 1 length */
+	unsigned int des2;	/* Buffer 1 */
+	unsigned int des3;	/* Buffer 2 */
 };
 
 typedef struct dma_desc_t dma_desc;
@@ -204,23 +209,22 @@ struct eth_driver_local {
 	int pbl;
 	unsigned int ip_header_len;
 	struct mii_bus *mii;
-	struct dev_mc_list *dmi;
 	struct net_device_stats stats;
 	u32 msg_enable;
 	spinlock_t lock;
 
-	dma_desc *dma_tx; /* virtual DMA TX addr */
-	dma_addr_t dma_tx_phy;	   /* bus DMA TX addr */
-	unsigned int cur_tx, dirty_tx; /* Producer/consumer ring indices */
+	dma_desc *dma_tx;	/* virtual DMA TX addr */
+	dma_addr_t dma_tx_phy;	/* bus DMA TX addr */
+	unsigned int cur_tx, dirty_tx;	/* Producer/consumer ring indices */
 	struct sk_buff *tx_skbuff[CONFIG_DMA_TX_SIZE];
 
-  	dma_desc *dma_rx; 	  /* virtual DMA RX addr */
-	dma_addr_t dma_rx_phy;	  /* bus DMA RX addr */
-	unsigned int rx_buf_sz;   /* Based on MTU+slack. */
-	unsigned int rx_buff; 	  /* it contains the last rx buf owned by
-				     the DMA */
+	dma_desc *dma_rx;	/* virtual DMA RX addr */
+	dma_addr_t dma_rx_phy;	/* bus DMA RX addr */
+	unsigned int rx_buf_sz;	/* Based on MTU+slack. */
+	unsigned int rx_buff;	/* it contains the last rx buf owned by
+				   the DMA */
 	int rx_csum;
-	unsigned int cur_rx, dirty_rx;  /* Producer/consumer ring indices */
+	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indices */
 	/* The addresses of receive-in-place skbuffs. */
 	struct sk_buff *rx_skbuff[CONFIG_DMA_RX_SIZE];
 	dma_addr_t rx_skbuff_dma[CONFIG_DMA_RX_SIZE];
@@ -235,10 +239,10 @@ struct eth_driver_local {
 /* Module Arguments */
 #define TX_TIMEO (4*HZ)
 static int watchdog = TX_TIMEO;
-module_param(watchdog, int, S_IRUGO|S_IWUGO);
+module_param(watchdog, int, S_IRUGO | S_IWUGO);
 MODULE_PARM_DESC(watchdog, "Transmit Timeout (in milliseconds)");
 
-static int debug = -1; /* -1: default, 0: no output, 16:  all */
+static int debug = -1;		/* -1: default, 0: no output, 16:  all */
 module_param(debug, int, S_IRUGO);
 MODULE_PARM_DESC(debug, "Message Level (0: no output, 16: all)");
 
@@ -248,7 +252,7 @@ module_param(pause_time, int, S_IRUGO);
 MODULE_PARM_DESC(pause_time, "Pause Time");
 
 static int min_rx_pkt_size = 512;
-module_param(min_rx_pkt_size, int, S_IRUGO|S_IWUGO);
+module_param(min_rx_pkt_size, int, S_IRUGO | S_IWUGO);
 MODULE_PARM_DESC(min_rx_pkt_size, "Copy only tiny-frames");
 
 static int phy_n = -1;
@@ -257,14 +261,14 @@ MODULE_PARM_DESC(phy_n, "Physical device
 
 static const char version[] = "stmmaceth - (C) STM 2006\n";
 
-static const u32 default_msg_level = (NETIF_MSG_DRV |NETIF_MSG_PROBE|
-				      NETIF_MSG_LINK |NETIF_MSG_IFUP|
-				      NETIF_MSG_IFDOWN|NETIF_MSG_TIMER);
+static const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
+				      NETIF_MSG_LINK | NETIF_MSG_IFUP |
+				      NETIF_MSG_IFDOWN | NETIF_MSG_TIMER);
 
 static irqreturn_t stmmaceth_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs);
+				       struct pt_regs *regs);
 #ifndef CONFIG_STMMAC_NAPI
-static int stmmaceth_rx (struct net_device *dev);
+static int stmmaceth_rx(struct net_device *dev);
 #else
 static int stmmaceth_poll(struct net_device *dev, int *budget);
 #endif
@@ -273,8 +277,8 @@ static void stmmaceth_check_mod_params(s
 {
 	if (watchdog < 0) {
 		watchdog = TX_TIMEO;
-		printk (KERN_WARNING "\tWARNING: invalid tx timeout "
-				     "(default is %d)\n", watchdog);
+		printk(KERN_WARNING "\tWARNING: invalid tx timeout "
+		       "(default is %d)\n", watchdog);
 	}
 
 	if ((pause_time <= 0) || (pause_time >= MAX_PAUSE_TIME))
@@ -297,8 +301,8 @@ static void print_pkt(unsigned char *buf
 {
 	int j;
 	printk("len = %d byte, buf addr: 0x%p", len, buf);
-	for (j=0; j<len; j++) {
-		if ((j%16) == 0)
+	for (j = 0; j < len; j++) {
+		if ((j % 16) == 0)
 			printk("\n %03x:", j);
 		printk(" %02x", buf[j]);
 	}
@@ -317,9 +321,6 @@ void fix_mac_speed(unsigned int speed)
 	else if (speed == SPEED_10)
 		sysconf &= ~MAC_SPEED_SEL;
 
-	printk (KERN_DEBUG  "fix_mac_speed: speed = %d, sysconf7 = 0x%x\n",
-				           speed, (unsigned int) sysconf);
-
 	ctrl_outl(sysconf, SYSCONF_SYS_CFG(7));
 #endif
 	return;
@@ -332,30 +333,35 @@ static void stmmac_adjust_link(struct ne
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 	struct phy_device *phydev = lp->phydev;
-	unsigned long ioaddr=dev->base_addr;
+	unsigned long ioaddr = dev->base_addr;
 	unsigned long flags;
 	int new_state = 0;
 
-	ETHPRINTK(probe, DEBUG, "stmmac_adjust_link: called.  address %d link %d\n",
-			  phydev->addr, phydev->link);
+	ETHPRINTK(probe, DEBUG,
+		  "stmmac_adjust_link: called.  address %d link %d\n",
+		  phydev->addr, phydev->link);
 
 	spin_lock_irqsave(&lp->lock, flags);
 	if (phydev->link) {
-		unsigned int flow=(unsigned int) readl(ioaddr+MAC_FLOW_CONTROL);
-		unsigned int ctrl=(unsigned int) readl(ioaddr+MAC_CONTROL);
+		unsigned int flow =
+		    (unsigned int)readl(ioaddr + MAC_FLOW_CONTROL);
+		unsigned int ctrl = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 		/* Now we make sure that we can be in full duplex mode.
 		 * If not, we operate in half-duplex mode. */
 		if (phydev->duplex != lp->oldduplex) {
 			new_state = 1;
-			if (!(phydev->duplex)){
-				flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
-			  		MAC_FLOW_CONTROL_PCF);
+			if (!(phydev->duplex)) {
+				flow &=
+				    ~(MAC_FLOW_CONTROL_FCE |
+				      MAC_FLOW_CONTROL_PT_MASK |
+				      MAC_FLOW_CONTROL_PCF);
 				ctrl &= ~MAC_CONTROL_F;
 				ctrl |= MAC_CONTROL_DRO;
 			} else {
-				flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
-					(pause_time << MAC_FLOW_CONTROL_PT_SHIFT);
+				flow |=
+				    MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF
+				    | (pause_time << MAC_FLOW_CONTROL_PT_SHIFT);
 				ctrl |= MAC_CONTROL_F;
 				ctrl &= ~MAC_CONTROL_DRO;
 			}
@@ -369,22 +375,22 @@ static void stmmac_adjust_link(struct ne
 			case 100:
 			case 10:
 				fix_mac_speed(phydev->speed);
-			        break;
+				break;
 			default:
-			        if (netif_msg_link(lp))
-			                printk(KERN_WARNING
-			                       "%s: Ack!  Speed (%d) is not 10 or 100!\n",
-			                        dev->name, phydev->speed);
-			        break;
+				if (netif_msg_link(lp))
+					printk(KERN_WARNING
+					       "%s: Ack!  Speed (%d) is not 10 or 100!\n",
+					       dev->name, phydev->speed);
+				break;
 			}
 
 			lp->speed = phydev->speed;
-	       }
+		}
 
-		writel(flow, ioaddr+MAC_FLOW_CONTROL);
-		writel(ctrl, ioaddr+MAC_CONTROL);
+		writel(flow, ioaddr + MAC_FLOW_CONTROL);
+		writel(ctrl, ioaddr + MAC_CONTROL);
 
-	       if (!lp->oldlink) {
+		if (!lp->oldlink) {
 			new_state = 1;
 			lp->oldlink = 1;
 			netif_schedule(dev);
@@ -401,11 +407,15 @@ static void stmmac_adjust_link(struct ne
 
 	spin_unlock_irqrestore(&lp->lock, flags);
 
-	ETHPRINTK(probe, DEBUG,"stmmac_adjust_link: exiting\n");
+	ETHPRINTK(probe, DEBUG, "stmmac_adjust_link: exiting\n");
 }
 
-/* Initializes driver's PHY state, and attaches to the PHY.
- * Returns 0 on success.
+/**
+ * stmmac_init_phy - PHY initialization
+ * @dev: net device structure
+ * Description: it initializes driver's PHY state, and attaches to the PHY.
+ *  Return value:
+ *  0 on success
  */
 static int stmmac_init_phy(struct net_device *dev)
 {
@@ -418,7 +428,8 @@ static int stmmac_init_phy(struct net_de
 	lp->oldduplex = -1;
 
 	snprintf(phy_id, BUS_ID_SIZE, PHY_ID_FMT, lp->bus_id, lp->phy_addr);
-	ETHPRINTK(probe, DEBUG,"stmmac_init_phy:  trying to attach to %s\n", phy_id);
+	ETHPRINTK(probe, DEBUG, "stmmac_init_phy:  trying to attach to %s\n",
+		  phy_id);
 
 	phydev = phy_connect(dev, phy_id, &stmmac_adjust_link, 0);
 
@@ -427,8 +438,9 @@ static int stmmac_init_phy(struct net_de
 		return PTR_ERR(phydev);
 	}
 
-	ETHPRINTK(probe, DEBUG, "stmmac_init_phy:  %s: attached to PHY. Link = %d\n",
-		 dev->name, phydev->link);
+	ETHPRINTK(probe, DEBUG,
+		  "stmmac_init_phy:  %s: attached to PHY. Link = %d\n",
+		  dev->name, phydev->link);
 
 	lp->phydev = phydev;
 
@@ -439,55 +451,65 @@ static int stmmac_init_phy(struct net_de
 				MDIO Bus Support
    ---------------------------------------------------------------------------*/
 
-/*  Read data from the MII register from within the specified phy device,
- *  arguments:
- *	phyaddr: MII addr reg bits 15-11
- *	phyreg: MII addr reg bits 10-6
+/**
+ * stmmac_mdio_read
+ * @bus: points to the mii_bus structure
+ * @phyaddr: MII addr reg bits 15-11
+ * @phyreg: MII addr reg bits 10-6
+ * Description: it reads data from the MII register from within the 
+ * 		specified phy device,
  */
 int stmmac_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)
 {
-	unsigned long ioaddr=(unsigned long)bus->priv;
+	unsigned long ioaddr = (unsigned long)bus->priv;
 	int data;
-	u16 regValue=(((phyaddr << 11)&(0x0000F800))|
-		      ((phyreg<<6)&(0x000007C0)));
+	u16 regValue = (((phyaddr << 11) & (0x0000F800)) |
+			((phyreg << 6) & (0x000007C0)));
 
-	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
 
-	writel(regValue, ioaddr+MAC_MII_ADDR);
+	writel(regValue, ioaddr + MAC_MII_ADDR);
 
-	while (((readl(ioaddr+MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1 ) {}
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
 
 	/* Read the data from the MII data register */
-	data = (int)readl(ioaddr+MAC_MII_DATA);
-/*	printk(KERN_DEBUG "stmmac_mdio_read : phyaddr = %d  phyreg = %d data = %08x\n",
-			phyaddr, phyreg, data); */
+	data = (int)readl(ioaddr + MAC_MII_DATA);
 	return data;
 }
 
-/* Writes the data intto the MII register from within the specified device */
-int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg,
-		       u16 phydata)
-{
-	unsigned long ioaddr=(unsigned long)bus->priv;
-	u16 value=(((phyaddr<<11)&(0x0000F800))|((phyreg<<6)&(0x000007C0)))|
-			MAC_MII_ADDR_WRITE;
-
-/*	printk(KERN_DEBUG "stmmac_mdio_write : phyaddr = %d  phyreg = %d data = %04x\n",
-			phyaddr, phyreg, phydata); */
+/**
+ * stmmac_mdio_write
+ * @bus: points to the mii_bus structure
+ * @phyaddr: MII addr reg bits 15-11
+ * @phyreg: MII addr reg bits 10-6
+ * @phydata: phy data
+ * Description: it writes the data intto the MII register from within 
+ *		the specified device
+ */
+int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg, u16 phydata)
+{
+	unsigned long ioaddr = (unsigned long)bus->priv;
+	u16 value =
+	    (((phyaddr << 11) & (0x0000F800)) | ((phyreg << 6) & (0x000007C0)))
+	    | MAC_MII_ADDR_WRITE;
 
 	/* Wait until any existing MII operation is complete */
-	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
 
 	/* Set the MII address register to write */
-	writel(phydata, ioaddr+MAC_MII_DATA);
-	writel(value, ioaddr+MAC_MII_ADDR);
+	writel(phydata, ioaddr + MAC_MII_DATA);
+	writel(value, ioaddr + MAC_MII_ADDR);
 
 	/* Wait until any existing MII operation is complete */
-	while (((readl(ioaddr+MAC_MII_ADDR)) &  MAC_MII_ADDR_BUSY) == 1 ) {}
+	while (((readl(ioaddr + MAC_MII_ADDR)) & MAC_MII_ADDR_BUSY) == 1) {
+	}
 
 	/* NOTE: we need to perform this "extra" read in order to fix an error
 	 * during the write operation */
-	stmmac_mdio_read (bus, phyaddr, phyreg);
+	stmmac_mdio_read(bus, phyaddr, phyreg);
 	return 0;
 }
 
@@ -497,197 +519,243 @@ int stmmac_mdio_reset(struct mii_bus *bu
 	return 0;
 }
 
-/* Register the MII bus */
+/**
+ * stmmac_mdio_register
+ * @lp: local driver structure
+ * @ndev : device pointer
+ * @ioaddr: device I/O address
+ * Description: it register the MII bus
+ */
 int stmmac_mdio_register(struct eth_driver_local *lp, struct net_device *ndev,
-			  unsigned long ioaddr)
+			 unsigned long ioaddr)
 {
 	int err = 0;
 	struct mii_bus *new_bus = kzalloc(sizeof(struct mii_bus), GFP_KERNEL);
-	int *irqlist = kzalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
+	int *irqlist = kzalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
 
-        if (new_bus == NULL)
-                return -ENOMEM;
+	if (new_bus == NULL)
+		return -ENOMEM;
 
 	/* Assign IRQ to phy at address phy_addr */
 	irqlist[lp->phy_addr] = lp->phy_irq;
 
-        new_bus->name = "STMMAC MII Bus",
-        new_bus->read = &stmmac_mdio_read,
-        new_bus->write = &stmmac_mdio_write,
-        new_bus->reset = &stmmac_mdio_reset,
-        new_bus->id = (int)lp->bus_id;
+	new_bus->name = "STMMAC MII Bus",
+	    new_bus->read = &stmmac_mdio_read,
+	    new_bus->write = &stmmac_mdio_write,
+	    new_bus->reset = &stmmac_mdio_reset, new_bus->id = (int)lp->bus_id;
 	new_bus->priv = (void *)ioaddr;
 	new_bus->irq = irqlist;
 
 	err = mdiobus_register(new_bus, lp->phy_ignorezero);
 
-        if (err != 0) {
-                printk (KERN_ERR "%s: Cannot register as MDIO bus\n",
-                                new_bus->name);
-                goto bus_register_fail;
-        }
+	if (err != 0) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+		       new_bus->name);
+		goto bus_register_fail;
+	}
 
 	lp->mii = new_bus;
-        return 0;
+	return 0;
 
-bus_register_fail:
-        kfree(new_bus);
-        return err;
+      bus_register_fail:
+	kfree(new_bus);
+	return err;
 }
 
+/**
+ * stmmac_mdio_unregister
+ * @lp: local driver structure
+ * Description: it unregister the MII bus
+ */
 int stmmac_mdio_unregister(struct eth_driver_local *lp)
 {
 	mdiobus_unregister(lp->mii);
 	lp->mii->priv = NULL;
-        kfree(lp->mii);
+	kfree(lp->mii);
 
 	return 0;
 }
 
-
 /* ----------------------------------------------------------------------------
 				 MAC CORE Interface
    ---------------------------------------------------------------------------*/
-/* Print the MAC CSR registers */
+/**
+ * dump_stm_mac_csr
+ * @ioaddr: device I/O address
+ * Description: the function prints the MAC CSR registers
+ */
 static inline void dump_stm_mac_csr(unsigned long ioaddr)
 {
-	printk ("\t----------------------------------------------\n"
-		"\t  MAC CSR (base addr = 0x%8x)\n"
-		"\t----------------------------------------------\n",
-		(unsigned int)ioaddr);
-	printk ("\tcontrol reg (offset 0x%x): 0x%lx\n", MAC_CONTROL,
-			readl(ioaddr+MAC_CONTROL));
-	printk ("\taddr HI (offset 0x%x): 0x%lx\n ", MAC_ADDR_HIGH,
-			readl(ioaddr+MAC_ADDR_HIGH));
-	printk ("\taddr LO (offset 0x%x): 0x%lx\n", MAC_ADDR_LOW,
-			readl(ioaddr+MAC_ADDR_LOW));
-	printk ("\tmulticast hash HI (offset 0x%x): 0x%lx\n", MAC_HASH_HIGH,
-			readl(ioaddr+MAC_HASH_HIGH));
-	printk ("\tmulticast hash LO (offset 0x%x): 0x%lx\n", MAC_HASH_LOW,
-			readl(ioaddr+MAC_HASH_LOW));
-	printk ("\tflow control (offset 0x%x): 0x%lx\n", MAC_FLOW_CONTROL,
-			readl(ioaddr+MAC_FLOW_CONTROL));
+	printk("\t----------------------------------------------\n"
+	       "\t  MAC CSR (base addr = 0x%8x)\n"
+	       "\t----------------------------------------------\n",
+	       (unsigned int)ioaddr);
+	printk("\tcontrol reg (offset 0x%x): 0x%lx\n", MAC_CONTROL,
+	       readl(ioaddr + MAC_CONTROL));
+	printk("\taddr HI (offset 0x%x): 0x%lx\n ", MAC_ADDR_HIGH,
+	       readl(ioaddr + MAC_ADDR_HIGH));
+	printk("\taddr LO (offset 0x%x): 0x%lx\n", MAC_ADDR_LOW,
+	       readl(ioaddr + MAC_ADDR_LOW));
+	printk("\tmulticast hash HI (offset 0x%x): 0x%lx\n", MAC_HASH_HIGH,
+	       readl(ioaddr + MAC_HASH_HIGH));
+	printk("\tmulticast hash LO (offset 0x%x): 0x%lx\n", MAC_HASH_LOW,
+	       readl(ioaddr + MAC_HASH_LOW));
+	printk("\tflow control (offset 0x%x): 0x%lx\n", MAC_FLOW_CONTROL,
+	       readl(ioaddr + MAC_FLOW_CONTROL));
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	printk ("\tVLAN1 tag (offset 0x%x): 0x%lx\n", MAC_VLAN1,
-			readl(ioaddr+MAC_VLAN1));
-	printk ("\tVLAN2 tag (offset 0x%x): 0x%lx\n", MAC_VLAN2,
-			readl(ioaddr+MAC_VLAN2));
-#endif
-	printk ("\tmac wakeup frame (offset 0x%x): 0x%lx\n", MAC_WAKEUP_FILTER,
-			readl(ioaddr+MAC_WAKEUP_FILTER));
-	printk ("\tmac wakeup crtl (offset 0x%x): 0x%lx\n",
-			MAC_WAKEUP_CONTROL_STATUS,
-			readl(ioaddr+MAC_WAKEUP_CONTROL_STATUS));
-
-	printk ("\n\tMAC management counter registers\n");
-	printk ("\t MMC crtl (offset 0x%x): 0x%lx\n",
-			MMC_CONTROL, readl(ioaddr+MMC_CONTROL));
-	printk ("\t MMC High Interrupt (offset 0x%x): 0x%lx\n",
-			MMC_HIGH_INTR, readl(ioaddr+MMC_HIGH_INTR));
-	printk ("\t MMC Low Interrupt (offset 0x%x): 0x%lx\n",
-			MMC_LOW_INTR, readl(ioaddr+MMC_LOW_INTR));
-	printk ("\t MMC High Interrupt Mask (offset 0x%x): 0x%lx\n",
-			MMC_HIGH_INTR_MASK, readl(ioaddr+MMC_HIGH_INTR_MASK));
-	printk ("\t MMC Low Interrupt Mask (offset 0x%x): 0x%lx\n",
-			MMC_LOW_INTR_MASK, readl(ioaddr+MMC_LOW_INTR_MASK));
+	printk("\tVLAN1 tag (offset 0x%x): 0x%lx\n", MAC_VLAN1,
+	       readl(ioaddr + MAC_VLAN1));
+	printk("\tVLAN2 tag (offset 0x%x): 0x%lx\n", MAC_VLAN2,
+	       readl(ioaddr + MAC_VLAN2));
+#endif
+	printk("\tmac wakeup frame (offset 0x%x): 0x%lx\n", MAC_WAKEUP_FILTER,
+	       readl(ioaddr + MAC_WAKEUP_FILTER));
+	printk("\tmac wakeup crtl (offset 0x%x): 0x%lx\n",
+	       MAC_WAKEUP_CONTROL_STATUS,
+	       readl(ioaddr + MAC_WAKEUP_CONTROL_STATUS));
+
+	printk("\n\tMAC management counter registers\n");
+	printk("\t MMC crtl (offset 0x%x): 0x%lx\n",
+	       MMC_CONTROL, readl(ioaddr + MMC_CONTROL));
+	printk("\t MMC High Interrupt (offset 0x%x): 0x%lx\n",
+	       MMC_HIGH_INTR, readl(ioaddr + MMC_HIGH_INTR));
+	printk("\t MMC Low Interrupt (offset 0x%x): 0x%lx\n",
+	       MMC_LOW_INTR, readl(ioaddr + MMC_LOW_INTR));
+	printk("\t MMC High Interrupt Mask (offset 0x%x): 0x%lx\n",
+	       MMC_HIGH_INTR_MASK, readl(ioaddr + MMC_HIGH_INTR_MASK));
+	printk("\t MMC Low Interrupt Mask (offset 0x%x): 0x%lx\n",
+	       MMC_LOW_INTR_MASK, readl(ioaddr + MMC_LOW_INTR_MASK));
 	return;
 }
 
-/* Set the hardware MAC address */
+/**
+ * set_mac_addr
+ * @ioaddr: device I/O address
+ * @Addr: new MAC address
+ * Description: the function sets the hardware MAC address
+ */
 static void set_mac_addr(unsigned long ioaddr, u8 Addr[6])
 {
 	unsigned long data;
 
-	data = (Addr[5]<<8) | Addr[4];
-	writel(data, ioaddr+MAC_ADDR_HIGH );
-	data = (Addr[3]<<24) | (Addr[2]<<16) | (Addr[1]<<8) | Addr[0];
-	writel(data, ioaddr+MAC_ADDR_LOW);
+	data = (Addr[5] << 8) | Addr[4];
+	writel(data, ioaddr + MAC_ADDR_HIGH);
+	data = (Addr[3] << 24) | (Addr[2] << 16) | (Addr[1] << 8) | Addr[0];
+	writel(data, ioaddr + MAC_ADDR_LOW);
 
 	return;
 }
 
-/* Get the hardware MAC address  */
+/**
+ * get_mac_addr
+ * @ioaddr: device I/O address
+ * @addr: mac address
+ * Description: the function gets the hardware MAC address
+ */
 static void get_mac_address(unsigned long ioaddr, unsigned char *addr)
 {
 	unsigned int hi_addr, lo_addr;
 
 	/* Read the MAC address from the hardware */
-	hi_addr = (unsigned int) readl(ioaddr+MAC_ADDR_HIGH);
-	lo_addr = (unsigned int) readl(ioaddr+MAC_ADDR_LOW);
+	hi_addr = (unsigned int)readl(ioaddr + MAC_ADDR_HIGH);
+	lo_addr = (unsigned int)readl(ioaddr + MAC_ADDR_LOW);
 
 	/* Extract the MAC address from the high and low words */
 	addr[0] = lo_addr & 0xff;
-	addr[1] = (lo_addr >>  8) & 0xff;
+	addr[1] = (lo_addr >> 8) & 0xff;
 	addr[2] = (lo_addr >> 16) & 0xff;
 	addr[3] = (lo_addr >> 24) & 0xff;
 	addr[4] = hi_addr & 0xff;
-	addr[5] = (hi_addr >>  8) & 0xff;
+	addr[5] = (hi_addr >> 8) & 0xff;
 
 	return;
 }
 
-/* Enable/Disable RX/TX MAC process*/
+/**
+ * stmmaceth_mac_enable_rx
+ * @dev: net device structure
+ * Description: the function enables the RX MAC process
+ */
 static void stmmaceth_mac_enable_rx(struct net_device *dev)
 {
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 	/* set the RE (receive enable, bit 2) */
 	value |= (MAC_CONTROL_RE);
-	writel(value, ioaddr+MAC_CONTROL);
+	writel(value, ioaddr + MAC_CONTROL);
 	return;
 }
 
+/**
+ * stmmaceth_mac_enable_rx
+ * @dev: net device structure
+ * Description: the function enables the TX MAC process
+ */
 static void stmmaceth_mac_enable_tx(struct net_device *dev)
 {
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 	/* set: TE (transmitter enable, bit 3) */
 	value |= (MAC_CONTROL_TE);
-	writel(value, ioaddr+MAC_CONTROL);
+	writel(value, ioaddr + MAC_CONTROL);
 	return;
 }
 
+/**
+ * stmmaceth_mac_disable_rx
+ * @dev: net device structure
+ * Description: the function disables the RX MAC process
+ */
 static void stmmaceth_mac_disable_rx(struct net_device *dev)
 {
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 	value &= ~MAC_CONTROL_RE;
-	writel(value, ioaddr+MAC_CONTROL);
+	writel(value, ioaddr + MAC_CONTROL);
 	return;
 }
 
+/**
+ * stmmaceth_mac_disable_tx
+ * @dev: net device structure
+ * Description: the function disables the TX MAC process
+ */
 static void stmmaceth_mac_disable_tx(struct net_device *dev)
 {
-	unsigned long ioaddr=dev->base_addr;
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 	value &= ~(MAC_CONTROL_TE);
-	writel(value, ioaddr+MAC_CONTROL);
+	writel(value, ioaddr + MAC_CONTROL);
 	return;
 }
 
-/* This function provides the initial setup of the MAC controller */
+/**
+ * stmmaceth_mac_core_init
+ * @dev: net device structure
+ * Description:  This function provides the initial setup of the MAC controller
+ */
 static void stmmaceth_mac_core_init(struct net_device *dev)
 {
 	unsigned int value = 0;
-	unsigned long ioaddr=dev->base_addr;
+	unsigned long ioaddr = dev->base_addr;
 
 	/* Set the MAC control register with our default value */
-	value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-	value |= MAC_CONTROL_HBD | MAC_CONTROL_PM | MAC_CONTROL_ASTP;
-	writel(value, ioaddr+MAC_CONTROL);
+	value = (unsigned int)readl(ioaddr + MAC_CONTROL);
+	value |= MAC_CONTROL_HBD | MAC_CONTROL_ASTP;
+	writel(value, ioaddr + MAC_CONTROL);
 
 	/* Change the MAX_FRAME bits in the MMC control register. */
 	value = 0x7ff;
-	/*value = dev->mtu + lp->ip_header_len + 4;*/
+	/*value = dev->mtu + lp->ip_header_len + 4; */
 	writel(((value << MMC_CONTROL_MAX_FRM_SHIFT) &
-		MMC_CONTROL_MAX_FRM_MASK), dev->base_addr+MMC_CONTROL);
+		MMC_CONTROL_MAX_FRM_MASK), dev->base_addr + MMC_CONTROL);
 
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-	writel(ETH_P_8021Q, dev->base_addr+MAC_VLAN1);
+	writel(ETH_P_8021Q, dev->base_addr + MAC_VLAN1);
 #endif
 	return;
 }
@@ -695,31 +763,32 @@ static void stmmaceth_mac_core_init(stru
 /* ----------------------------------------------------------------------------
  *  			DESCRIPTORS functions
  * ---------------------------------------------------------------------------*/
-static void display_dma_desc_ring(dma_desc *p, int size)
+static void display_dma_desc_ring(dma_desc * p, int size)
 {
 	int i;
-	for (i=0; i<size; i++) {
-		printk ("\t%d [0x%x]: "
-			"desc0=0x%x desc1=0x%x buffer1=0x%x", i,
-			(unsigned int) virt_to_bus(&p[i].des0), p[i].des0,
-			p[i].des1, (unsigned int)p[i].des2);
+	for (i = 0; i < size; i++) {
+		printk("\t%d [0x%x]: "
+		       "desc0=0x%x desc1=0x%x buffer1=0x%x", i,
+		       (unsigned int)virt_to_bus(&p[i].des0), p[i].des0,
+		       p[i].des1, (unsigned int)p[i].des2);
 		if (p[i].des3 != 0)
 			printk(" buffer2=0x%x", (unsigned int)p[i].des3);
 		printk("\n");
 	}
 }
 
-static void clear_dma_descs(dma_desc *p, unsigned int ring_size,
-		    	  unsigned int own_bit)
+static void clear_dma_descs(dma_desc * p, unsigned int ring_size,
+			    unsigned int own_bit)
 {
 	int i;
-	for (i=0; i<ring_size; i++) {
+	for (i = 0; i < ring_size; i++) {
 		p->des0 = own_bit;
 		if (!(own_bit))
 			p->des1 = 0;
 		else
-			p->des1 = ((DMA_BUFFER_SIZE-1)<<DES1_RBS1_SIZE_SHIFT);
-		if (i == ring_size-1) {
+			p->des1 =
+			    ((DMA_BUFFER_SIZE - 1) << DES1_RBS1_SIZE_SHIFT);
+		if (i == ring_size - 1) {
 			p->des1 |= DES1_CONTROL_TER;
 		}
 		/* The driver uses the 'implicit' scheme for implementing
@@ -730,36 +799,44 @@ static void clear_dma_descs(dma_desc *p,
 	return;
 }
 
+/**
+ * init_dma_desc_rings - init RX/TX descriptor rings
+ * @dev: net device structure
+ * Description:  this function initializes the DMA RX/TX descriptors
+ */
 static void init_dma_desc_rings(struct net_device *dev)
 {
 	int i;
 	struct eth_driver_local *lp = netdev_priv(dev);
 	lp->rx_buf_sz = DMA_BUFFER_SIZE;
 
-	ETHPRINTK(probe, DEBUG,"%s: allocate and init the DMA RX/TX lists\n",
-			    RESOURCE_NAME);
+	ETHPRINTK(probe, DEBUG, "%s: allocate and init the DMA RX/TX lists\n",
+		  RESOURCE_NAME);
 
-	/* ---- DMA RX/TX descriptors initializaion */
 	lp->dma_rx = (dma_desc *) dma_alloc_coherent(lp->device,
-		 CONFIG_DMA_RX_SIZE*sizeof(struct dma_desc_t),
-		 &lp->dma_rx_phy, GFP_KERNEL);
-	lp->dma_tx = (dma_desc *) dma_alloc_coherent(lp->device,
-		 CONFIG_DMA_TX_SIZE*sizeof(struct dma_desc_t),
-		 &lp->dma_tx_phy, GFP_KERNEL);
+						     CONFIG_DMA_RX_SIZE *
+						     sizeof(struct dma_desc_t),
+						     &lp->dma_rx_phy,
+						     GFP_KERNEL);
+	lp->dma_tx =
+	    (dma_desc *) dma_alloc_coherent(lp->device,
+					    CONFIG_DMA_TX_SIZE *
+					    sizeof(struct dma_desc_t),
+					    &lp->dma_tx_phy, GFP_KERNEL);
 
-	if ((lp->dma_rx == NULL)||(lp->dma_tx == NULL)) {
+	if ((lp->dma_rx == NULL) || (lp->dma_tx == NULL)) {
 		printk(KERN_ERR "%s:ERROR allocating the DMA Tx/Rx desc\n",
-			__FUNCTION__);
+		       __FUNCTION__);
 		return;
 	}
 	ETHPRINTK(probe, DEBUG, "%s: DMA desc rings: virt addr (Rx 0x%08x, "
-		"Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
-		dev->name, (unsigned int)lp->dma_rx ,(unsigned int)lp->dma_tx,
-		(unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
+		  "Tx 0x%08x) DMA phy addr (Rx 0x%08x,Tx 0x%08x)\n",
+		  dev->name, (unsigned int)lp->dma_rx, (unsigned int)lp->dma_tx,
+		  (unsigned int)lp->dma_rx_phy, (unsigned int)lp->dma_tx_phy);
 
 	/* ---- RX INITIALIZATION */
-	ETHPRINTK(probe,DEBUG,"[RX skb data]   [DMA RX skb data] "
-			      "(buff size: %d)\n", lp->rx_buf_sz);
+	ETHPRINTK(probe, DEBUG, "[RX skb data]   [DMA RX skb data] "
+		  "(buff size: %d)\n", lp->rx_buf_sz);
 	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
 		dma_desc *p = lp->dma_rx + i;
 		struct sk_buff *skb = dev_alloc_skb(lp->rx_buf_sz);
@@ -769,17 +846,18 @@ static void init_dma_desc_rings(struct n
 		if (skb == NULL)
 			break;
 		lp->rx_skbuff_dma[i] = dma_map_single(lp->device, skb->tail,
-					lp->rx_buf_sz, DMA_FROM_DEVICE);
+						      lp->rx_buf_sz,
+						      DMA_FROM_DEVICE);
 		p->des2 = lp->rx_skbuff_dma[i];
 		ETHPRINTK(probe, DEBUG, "[0x%08x]\t[0x%08x]\n",
-				(unsigned int)lp->rx_skbuff[i]->data,
-				(unsigned int)lp->rx_skbuff_dma[i]);
+			  (unsigned int)lp->rx_skbuff[i]->data,
+			  (unsigned int)lp->rx_skbuff_dma[i]);
 	}
 	lp->cur_rx = 0;
 	lp->dirty_rx = (unsigned int)(i - CONFIG_DMA_RX_SIZE);
 
 	/* ---- TX INITIALIZATION */
-	for (i=0;i < CONFIG_DMA_TX_SIZE;i++) {
+	for (i = 0; i < CONFIG_DMA_TX_SIZE; i++) {
 		lp->tx_skbuff[i] = NULL;
 		lp->dma_tx[i].des2 = 0;
 		lp->dma_tx[i].des3 = 0;
@@ -791,16 +869,20 @@ static void init_dma_desc_rings(struct n
 	clear_dma_descs(lp->dma_tx, CONFIG_DMA_TX_SIZE, 0);
 
 	if (netif_msg_hw(lp)) {
-		printk ("RX descriptor ring:\n");
+		printk("RX descriptor ring:\n");
 		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
-		printk ("TX descriptor ring:\n");
+		printk("TX descriptor ring:\n");
 		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
 	}
-    return;
+	return;
 }
 
-/* Free all the skbuffs in the Rx queue. */
-static void dma_free_rx_bufs(struct net_device* dev)
+/**
+ * dma_free_rx_bufs
+ * @dev: net device structure
+ * Description:  this function frees all the skbuffs in the Rx queue
+ */
+static void dma_free_rx_bufs(struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 	int i;
@@ -808,7 +890,7 @@ static void dma_free_rx_bufs(struct net_
 	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
 		if (lp->rx_skbuff[i]) {
 			dma_unmap_single(lp->device, lp->rx_skbuff_dma[i],
-			      	         lp->rx_buf_sz, DMA_FROM_DEVICE);
+					 lp->rx_buf_sz, DMA_FROM_DEVICE);
 			dev_kfree_skb(lp->rx_skbuff[i]);
 		}
 		lp->rx_skbuff[i] = NULL;
@@ -816,32 +898,44 @@ static void dma_free_rx_bufs(struct net_
 	return;
 }
 
-/* Free all the skbuffs in the Tx queue. */
-static void dma_free_tx_bufs(struct net_device* dev)
+/**
+ * dma_free_tx_bufs
+ * @dev: net device structure
+ * Description:  this function frees all the skbuffs in the Tx queue
+ */
+static void dma_free_tx_bufs(struct net_device *dev)
 {
-        struct eth_driver_local *lp = netdev_priv(dev);
-        int i;
+	struct eth_driver_local *lp = netdev_priv(dev);
+	int i;
 
-        for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
+	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++) {
 		if (lp->tx_skbuff[i] != NULL) {
-                        if ((lp->dma_tx+i)->des2) {
-                                dma_unmap_single(lp->device, p->des2,
-                                   (p->des1 & DES1_RBS1_SIZE_MASK)>>
-				    DES1_RBS1_SIZE_SHIFT, DMA_TO_DEVICE);
-                        }
-                        if ((lp->dma_tx+i)->des3) {
-                                dma_unmap_single(lp->device, p->des3,
-                                   (p->des1 & DES1_RBS2_SIZE_MASK)>>
-				   DES1_RBS2_SIZE_SHIFT, DMA_TO_DEVICE);
-                        }
-                        dev_kfree_skb_any(lp->tx_skbuff[i]);
-                	lp->tx_skbuff[i] = NULL;
-                }
-        }
+			if ((lp->dma_tx + i)->des2) {
+				dma_unmap_single(lp->device, p->des2,
+						 (p->
+						  des1 & DES1_RBS1_SIZE_MASK) >>
+						 DES1_RBS1_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
+			}
+			if ((lp->dma_tx + i)->des3) {
+				dma_unmap_single(lp->device, p->des3,
+						 (p->
+						  des1 & DES1_RBS2_SIZE_MASK) >>
+						 DES1_RBS2_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
+			}
+			dev_kfree_skb_any(lp->tx_skbuff[i]);
+			lp->tx_skbuff[i] = NULL;
+		}
+	}
 	return;
 }
 
-/* Release and free the DMA descriptor resources. */
+/**
+ * free_dma_desc_resources
+ * @dev: net device structure
+ * Description:  this function releases and free the DMA descriptor resources
+ */
 static void free_dma_desc_resources(struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
@@ -852,79 +946,98 @@ static void free_dma_desc_resources(stru
 
 	/* Release the TX/RX rings */
 	dma_free_coherent(lp->device,
-		CONFIG_DMA_TX_SIZE*sizeof(struct dma_desc_t),
-		lp->dma_tx, lp->dma_tx_phy);
+			  CONFIG_DMA_TX_SIZE * sizeof(struct dma_desc_t),
+			  lp->dma_tx, lp->dma_tx_phy);
 	dma_free_coherent(lp->device,
-		CONFIG_DMA_RX_SIZE*sizeof(struct dma_desc_t),
-		lp->dma_rx, lp->dma_rx_phy);
+			  CONFIG_DMA_RX_SIZE * sizeof(struct dma_desc_t),
+			  lp->dma_rx, lp->dma_rx_phy);
 	return;
 }
 
 /* ----------------------------------------------------------------------------
 				DMA FUNCTIONS
  * ---------------------------------------------------------------------------*/
+/**
+ * dump_dma_csr
+ * @ioaddr: device I/O address
+ * Description:  this function dumps the STMAC DMA registers 
+ */
 static inline void dump_dma_csr(unsigned long ioaddr)
 {
 	int i;
-	printk ("\t--------------------\n"
-		"\t   STMMAC DMA CSR \n"
-		"\t--------------------\n");
-	for (i = 0; i<9; i++) {
-		printk ("\t CSR%d (offset 0x%x): 0x%lx\n", i,
-			(DMA_BUS_MODE + i*4), readl(ioaddr+DMA_BUS_MODE + i*4));
-	}
-	printk ("\t CSR20 (offset 0x%x): 0x%lx\n",
-		DMA_CUR_TX_BUF_ADDR, readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
-	printk ("\t CSR21 (offset 0x%x): 0x%lx\n",
-		DMA_CUR_RX_BUF_ADDR, readl(ioaddr+DMA_CUR_RX_BUF_ADDR));
+	printk("\t--------------------\n"
+	       "\t   STMMAC DMA CSR \n" "\t--------------------\n");
+	for (i = 0; i < 9; i++) {
+		printk("\t CSR%d (offset 0x%x): 0x%lx\n", i,
+		       (DMA_BUS_MODE + i * 4),
+		       readl(ioaddr + DMA_BUS_MODE + i * 4));
+	}
+	printk("\t CSR20 (offset 0x%x): 0x%lx\n",
+	       DMA_CUR_TX_BUF_ADDR, readl(ioaddr + DMA_CUR_TX_BUF_ADDR));
+	printk("\t CSR21 (offset 0x%x): 0x%lx\n",
+	       DMA_CUR_RX_BUF_ADDR, readl(ioaddr + DMA_CUR_RX_BUF_ADDR));
 	return;
 }
 
-/* DMA SW reset.
+/**
+ * stmmaceth_dma_reset - STMAC DMA SW reset
+ * @ioaddr: device I/O address
+ * Description:  this function performs the DMA SW reset.
  *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
  *	   SW reset otherwise the MAC core won't exit the reset state.
- *  NOTE2: after a SW reset all interrupts are disabled */
+ *  NOTE2: after a SW reset all interrupts are disabled 
+ */
 static void stmmaceth_dma_reset(unsigned long ioaddr)
 {
 	unsigned int value;
 
-	value=(unsigned int)readl(ioaddr+DMA_BUS_MODE);
-	value|= DMA_BUS_MODE_SFT_RESET;
-	writel(value, ioaddr+DMA_BUS_MODE);
-	while ((readl(ioaddr+DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {}
+	value = (unsigned int)readl(ioaddr + DMA_BUS_MODE);
+	value |= DMA_BUS_MODE_SFT_RESET;
+	writel(value, ioaddr + DMA_BUS_MODE);
+	while ((readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {
+	}
 	return;
 }
 
-/* START/STOP the DMA TX/RX processes */
+/**
+ * stmmaceth_dma_start_tx
+ * @ioaddr: device I/O address
+ * Description:  this function starts the DMA tx process
+ */
 static void stmmaceth_dma_start_tx(unsigned long ioaddr)
 {
 	unsigned int value;
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |= DMA_CONTROL_ST ;
-	writel(value, ioaddr+DMA_CONTROL);
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value |= DMA_CONTROL_ST;
+	writel(value, ioaddr + DMA_CONTROL);
 	return;
 }
 
 static void stmmaceth_dma_stop_tx(unsigned long ioaddr)
 {
 	unsigned int value;
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value &=  ~DMA_CONTROL_ST;
-	writel(value, ioaddr+DMA_CONTROL);
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value &= ~DMA_CONTROL_ST;
+	writel(value, ioaddr + DMA_CONTROL);
 	return;
 }
 
+/**
+ * stmmaceth_dma_start_rx
+ * @ioaddr: device I/O address
+ * Description:  this function starts the DMA rx process
+ * If NAPI is configured it also enables the RX IRQ.
+ */
 static void stmmaceth_dma_start_rx(unsigned long ioaddr)
 {
 	unsigned int value;
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
-	value |= DMA_CONTROL_SR ;
-	writel(value, ioaddr+DMA_CONTROL);
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
+	value |= DMA_CONTROL_SR;
+	writel(value, ioaddr + DMA_CONTROL);
 
 #ifdef CONFIG_STMMAC_NAPI
-	/* Enable the RX irq */
-	value =(unsigned int)readl(ioaddr+DMA_INTR_ENA);
-	writel((value | DMA_INTR_ENA_RIE), ioaddr+DMA_INTR_ENA);
+	value = (unsigned int)readl(ioaddr + DMA_INTR_ENA);
+	writel((value | DMA_INTR_ENA_RIE), ioaddr + DMA_INTR_ENA);
 #endif
 	return;
 }
@@ -932,22 +1045,26 @@ static void stmmaceth_dma_start_rx(unsig
 static void stmmaceth_dma_stop_rx(unsigned long ioaddr)
 {
 	unsigned int value;
-	value = (unsigned int)readl(ioaddr+DMA_CONTROL);
+	value = (unsigned int)readl(ioaddr + DMA_CONTROL);
 	value &= ~DMA_CONTROL_SR;
-	writel(value, ioaddr+DMA_CONTROL);
+	writel(value, ioaddr + DMA_CONTROL);
 
 #ifdef CONFIG_STMMAC_NAPI
 	/* Disable the RX irq */
-	value =(unsigned int)readl(ioaddr+DMA_INTR_ENA);
-	writel((value & ~DMA_INTR_ENA_RIE), ioaddr+DMA_INTR_ENA);
+	value = (unsigned int)readl(ioaddr + DMA_INTR_ENA);
+	writel((value & ~DMA_INTR_ENA_RIE), ioaddr + DMA_INTR_ENA);
 #endif
 	return;
 }
 
-/* The DMA init function performs:
+/**
+ * stmmaceth_dma_init - DMA init function
+ * @dev: net device structure
+ * Description: the DMA init function performs:
  * - the DMA RX/TX SW descriptors initialization
  * - the DMA HW controller initialization
- * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method. 
+ */
 static int stmmaceth_dma_init(struct net_device *dev)
 {
 	unsigned long ioaddr = dev->base_addr;
@@ -960,16 +1077,16 @@ static int stmmaceth_dma_init(struct net
 
 	/* Enable Application Access by writing to DMA CSR0 */
 	ETHPRINTK(probe, DEBUG, "\t(PBL: %d)\n", lp->pbl);
-	writel(DMA_BUS_MODE_DEFAULT | ((lp->pbl) << DMA_BUS_MODE_PBL_SHIFT) ,
-	       ioaddr+DMA_BUS_MODE);
+	writel(DMA_BUS_MODE_DEFAULT | ((lp->pbl) << DMA_BUS_MODE_PBL_SHIFT),
+	       ioaddr + DMA_BUS_MODE);
 
 	/* Mask interrupts by writing to CSR7 */
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr+DMA_INTR_ENA);
+	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
 
 	/* The base address of the RX/TX descriptor lists must be written into
 	 * DMA CSR3 and CSR4, respectively. */
-	writel((unsigned long)lp->dma_tx_phy,ioaddr+DMA_TX_BASE_ADDR);
-	writel((unsigned long)lp->dma_rx_phy,ioaddr+DMA_RCV_BASE_ADDR);
+	writel((unsigned long)lp->dma_tx_phy, ioaddr + DMA_TX_BASE_ADDR);
+	writel((unsigned long)lp->dma_rx_phy, ioaddr + DMA_RCV_BASE_ADDR);
 
 	if (netif_msg_hw(lp))
 		dump_dma_csr(ioaddr);
@@ -978,96 +1095,123 @@ static int stmmaceth_dma_init(struct net
 }
 
 #ifdef CONFIG_STMMAC_DEBUG
-/* Transmit Process State for CSR5[22:20] */
+/**
+ * show_tx_process_state
+ * @status: tx descriptor status field
+ * Description: it shows the Transmit Process State for CSR5[22:20]
+ */
 static void show_tx_process_state(unsigned int status)
 {
 	unsigned int state;
 	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
 
 	switch (state) {
-	   case 0: printk("- TX (Stopped): Reset or Stop command\n");
-	   	   break;
-	   case 1: printk("- TX (Running):Fetching the Tx desc\n");
-	   	   break;
-	   case 2: printk("- TX (Running): Waiting for end of tx\n");
-	   	   break;
-	   case 3: printk("- TX (Running): Reading the data "
-				    "and queuing the data into the Tx buf\n");
-	   	   break;
-	   case 6: printk("- TX (Suspended): Tx Buff Underflow "
-				    "or an unavailable Transmit descriptor\n");
-	   	   break;
-	   case 7: printk("- TX (Running): Closing Tx descriptor\n");
-	   	   break;
-	   default:
-	   	   break;
-	   }
+	case 0:
+		printk("- TX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		printk("- TX (Running):Fetching the Tx desc\n");
+		break;
+	case 2:
+		printk("- TX (Running): Waiting for end of tx\n");
+		break;
+	case 3:
+		printk("- TX (Running): Reading the data "
+		       "and queuing the data into the Tx buf\n");
+		break;
+	case 6:
+		printk("- TX (Suspended): Tx Buff Underflow "
+		       "or an unavailable Transmit descriptor\n");
+		break;
+	case 7:
+		printk("- TX (Running): Closing Tx descriptor\n");
+		break;
+	default:
+		break;
+	}
 	return;
 }
 
-/* Receive Process State for CSR5[19:17] */
+/**
+ * show_rx_process_state
+ * @status: rx descriptor status field
+ * Description: it shows the  Receive Process State for CSR5[19:17]
+ */
 static void show_rx_process_state(unsigned int status)
 {
 	unsigned int state;
 	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
 
 	switch (state) {
-	   case 0: printk("- RX (Stopped): Reset or Stop command\n");
-	   	   break;
-	   case 1: printk("- RX (Running): Fetching the Rx desc\n");
-	   	   break;
-	   case 2: printk("- RX (Running):Checking for end of pkt\n");
-	   	   break;
-	   case 3: printk("- RX (Running): Waiting for Rx pkt\n");
-	   	   break;
-	   case 4: printk("- RX (Suspended): Unavailable Rx buf\n");
-	   	   break;
-	   case 5: printk("- RX (Running): Closing Rx descriptor\n");
-	   	   break;
-	   case 6: printk("- RX(Running): Flushing the current frame"
-			  " from the Rx buf\n");
-	   	   break;
-	   case 7: printk("- RX (Running): Queuing the Rx frame"
-			  " from the Rx buf into memory\n");
-	   	   break;
-	   default:
-	   	   break;
+	case 0:
+		printk("- RX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		printk("- RX (Running): Fetching the Rx desc\n");
+		break;
+	case 2:
+		printk("- RX (Running):Checking for end of pkt\n");
+		break;
+	case 3:
+		printk("- RX (Running): Waiting for Rx pkt\n");
+		break;
+	case 4:
+		printk("- RX (Suspended): Unavailable Rx buf\n");
+		break;
+	case 5:
+		printk("- RX (Running): Closing Rx descriptor\n");
+		break;
+	case 6:
+		printk("- RX(Running): Flushing the current frame"
+		       " from the Rx buf\n");
+		break;
+	case 7:
+		printk("- RX (Running): Queuing the Rx frame"
+		       " from the Rx buf into memory\n");
+		break;
+	default:
+		break;
 	}
 	return;
 }
 #endif
 
-/* When the transmission is completed the frame status is written into
+/**
+ * check_tx_error_summary
+ * @lp: local network structure
+ * @entry: current ring entry point
+ * Description: when the transmission is completed the frame status is written into
  * TDESC0 of the descriptor having the LS bit set.
- * This function returns zero if no error is happened during the transmission.*/
+ * This function returns zero if no error is happened during the transmission.
+ */
 static int check_tx_error_summary(struct eth_driver_local *lp, int entry)
 {
 	dma_desc *p = lp->dma_tx + entry;
 	int status = p->des0;
 
-	ETHPRINTK(intr, INFO,"%s: [0x%x] - status %s\n", __FUNCTION__,
-			     (unsigned int)p, (!status)?"done":"with error");
+	ETHPRINTK(intr, INFO, "%s: [0x%x] - status %s\n", __FUNCTION__,
+		  (unsigned int)p, (!status) ? "done" : "with error");
 
 	if (status & TDES0_STATUS_DF) {
-		ETHPRINTK(tx_err, WARNING,"%s: DMA tx: deferred error\n",
-				RESOURCE_NAME);
+		ETHPRINTK(tx_err, WARNING, "%s: DMA tx: deferred error\n",
+			  RESOURCE_NAME);
 		goto out_error;
 	}
 	if (status & TDES0_STATUS_HRTBT_FAIL) {
 		ETHPRINTK(tx_err, WARNING, "%s: DMA tx: Heartbeat Fail\n",
-					RESOURCE_NAME);
+			  RESOURCE_NAME);
 		lp->stats.tx_heartbeat_errors++;
 		goto out_error;
 	}
 
 	if (status & TDES0_STATUS_ES) {
-		ETHPRINTK(tx_err, ERR,  "%s: DMA tx ERROR: ", RESOURCE_NAME);
+		ETHPRINTK(tx_err, ERR, "%s: DMA tx ERROR: ", RESOURCE_NAME);
 
 		if (status & TDES0_STATUS_UF) {
 			ETHPRINTK(tx_err, ERR, "Underflow Error\n");
 			goto out_error;
 		}
-		if (status & TDES0_STATUS_EX_DEF){
+		if (status & TDES0_STATUS_EX_DEF) {
 			ETHPRINTK(tx_err, ERR, "Ex Deferrals\n");
 			goto set_collision;
 		}
@@ -1079,7 +1223,7 @@ static int check_tx_error_summary(struct
 			ETHPRINTK(tx_err, ERR, "Late Collision\n");
 			goto set_collision;
 		}
-		if (status & TDES0_STATUS_NO_CARRIER){
+		if (status & TDES0_STATUS_NO_CARRIER) {
 			ETHPRINTK(tx_err, ERR, "No Carrier\n");
 			goto out_error;
 		}
@@ -1091,21 +1235,25 @@ static int check_tx_error_summary(struct
 
 	return (0);
 
-set_collision:
-	lp->stats.collisions +=((status & TDES0_STATUS_COLCNT_MASK)>>
-		TDES0_STATUS_COLCNT_SHIFT);
-out_error:
+      set_collision:
+	lp->stats.collisions += ((status & TDES0_STATUS_COLCNT_MASK) >>
+				 TDES0_STATUS_COLCNT_SHIFT);
+      out_error:
 	lp->stats.tx_errors++;
 
 	return (-1);
 }
 
-/* This is the tasklet or the bottom half of the IRQ handler.
- * The tasklet is used for freeing the TX resources.  */
+/**
+ * stmmaceth_clean_tx_irq
+ * @data:  address of the private member of the device structure
+ * Description: this is the tasklet or the bottom half of the IRQ handler.
+ * The tasklet is used for freeing the TX resources.  
+ */
 static void stmmaceth_clean_tx_irq(unsigned long data)
 {
 	struct net_device *dev = (struct net_device *)data;
-	struct  eth_driver_local *lp = netdev_priv(dev);
+	struct eth_driver_local *lp = netdev_priv(dev);
 	int entry = lp->dirty_tx % CONFIG_DMA_TX_SIZE;
 
 	while (lp->dirty_tx != lp->cur_tx) {
@@ -1117,20 +1265,24 @@ static void stmmaceth_clean_tx_irq(unsig
 					lp->stats.tx_packets++;
 
 			ETHPRINTK(tx_done, INFO, "%s: (entry %d)\n",
-						__FUNCTION__, entry);
-                        if (p->des2) {
+				  __FUNCTION__, entry);
+			if (p->des2) {
 				dma_unmap_single(lp->device, p->des2,
-				  (p->des1 & DES1_RBS1_SIZE_MASK)>>
-				   DES1_RBS1_SIZE_SHIFT, DMA_TO_DEVICE);
+						 (p->
+						  des1 & DES1_RBS1_SIZE_MASK) >>
+						 DES1_RBS1_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
 				p->des2 = 0;
 			}
 
-                        if (p->des3) {
-                                dma_unmap_single(lp->device, p->des3,
-                                   (p->des1 & DES1_RBS2_SIZE_MASK)>>
-				   DES1_RBS2_SIZE_SHIFT, DMA_TO_DEVICE);
+			if (p->des3) {
+				dma_unmap_single(lp->device, p->des3,
+						 (p->
+						  des1 & DES1_RBS2_SIZE_MASK) >>
+						 DES1_RBS2_SIZE_SHIFT,
+						 DMA_TO_DEVICE);
 				p->des3 = 0;
-                        }
+			}
 
 			if (lp->tx_skbuff[entry] != NULL) {
 				dev_kfree_skb_irq(lp->tx_skbuff[entry]);
@@ -1145,24 +1297,25 @@ static void stmmaceth_clean_tx_irq(unsig
 	return;
 }
 
-/*
- *  --- Interrupt handler for the MAC110 DMA
- *
- * It determines if we have to call either the Rx or the Tx interrupt handler.
+/**
+ * stmmaceth_dma_interrupt - Interrupt handler for the STMMAC DMA
+ * @dev: net device structure
+ * Description: It determines if we have to call either the Rx or the Tx 
+ * interrupt handler.
  * Numerous events can cause an interrupt: a new packet has arrived
  * or transmission is completed or an error occurred).  */
 static void stmmaceth_dma_interrupt(struct net_device *dev)
 {
 	unsigned int status;
 	unsigned int ioaddr = dev->base_addr;
-	struct  eth_driver_local *lp = netdev_priv(dev);
-	lp->rx_buff = readl(ioaddr+DMA_CUR_RX_BUF_ADDR);
+	struct eth_driver_local *lp = netdev_priv(dev);
+	lp->rx_buff = readl(ioaddr + DMA_CUR_RX_BUF_ADDR);
 
 	/* read the status register (CSR5) */
-	status = (unsigned int)readl(ioaddr+DMA_STATUS);
+	status = (unsigned int)readl(ioaddr + DMA_STATUS);
 
 	ETHPRINTK(intr, INFO, "%s: (%s) [CSR5: 0x%08x]\n", RESOURCE_NAME,
-			      "DMA IRQ", status);
+		  "DMA IRQ", status);
 #ifdef CONFIG_STMMAC_DEBUG
 	/* It displays the DMA transmit process state (CSR5 register) */
 	if (netif_msg_tx_done(lp))
@@ -1175,8 +1328,8 @@ static void stmmaceth_dma_interrupt(stru
 	if (status & DMA_STATUS_NIS) {
 		ETHPRINTK(intr, INFO, " CSR5[16]: DMA NORMAL IRQ: ");
 		if (status & DMA_STATUS_RI) {
-			ETHPRINTK (intr, INFO, "Receive irq [buf: 0x%08x]\n",
-						lp->rx_buff);
+			ETHPRINTK(intr, INFO, "Receive irq [buf: 0x%08x]\n",
+				  lp->rx_buff);
 #ifndef CONFIG_STMMAC_NAPI
 			stmmaceth_rx(dev);
 #else
@@ -1184,93 +1337,114 @@ static void stmmaceth_dma_interrupt(stru
 			if (netif_rx_schedule_prep(dev)) {
 				__netif_rx_schedule(dev);
 			} else {
-				ETHPRINTK (intr, ERR,"%s: bug!!! "
-				  "interrupt while in poll.\n", __FUNCTION__);
+				ETHPRINTK(intr, ERR, "%s: bug!!! "
+					  "interrupt while in poll.\n",
+					  __FUNCTION__);
 			}
 #endif
 		}
 		if (unlikely(status & DMA_STATUS_ERI)) {
-			ETHPRINTK(intr,INFO,"Early Receive Interrupt\n");
+			ETHPRINTK(intr, INFO, "Early Receive Interrupt\n");
 		}
 		if (status & DMA_STATUS_TI) {
-			ETHPRINTK(intr, INFO," Transmit irq [buf: 0x%lx]\n",
-		  	 	 readl(ioaddr+DMA_CUR_TX_BUF_ADDR));
+			ETHPRINTK(intr, INFO, " Transmit irq [buf: 0x%lx]\n",
+				  readl(ioaddr + DMA_CUR_TX_BUF_ADDR));
 			tasklet_hi_schedule(&lp->tx_task);
 		}
 		if (unlikely(status & DMA_STATUS_TU)) {
-			ETHPRINTK (intr, INFO, "Transmit Buffer Unavailable\n");
+			ETHPRINTK(intr, INFO, "Transmit Buffer Unavailable\n");
 		}
 	}
 	/* ABNORMAL interrupts */
 	if (unlikely(status & DMA_STATUS_AIS)) {
-		ETHPRINTK (intr, INFO,"CSR5[15] DMA ABNORMAL IRQ: ");
+		ETHPRINTK(intr, INFO, "CSR5[15] DMA ABNORMAL IRQ: ");
 		if (status & DMA_STATUS_TPS) {
-			ETHPRINTK (intr, INFO,"Transmit Process Stopped \n");
+			ETHPRINTK(intr, INFO, "Transmit Process Stopped \n");
 		}
-		if (status & DMA_STATUS_TJT){
-			ETHPRINTK (intr, INFO,"Transmit Jabber Timeout\n");
+		if (status & DMA_STATUS_TJT) {
+			ETHPRINTK(intr, INFO, "Transmit Jabber Timeout\n");
 		}
 		if (status & DMA_STATUS_OVF) {
-			ETHPRINTK (intr, INFO,"Receive Overflow\n");
+			ETHPRINTK(intr, INFO, "Receive Overflow\n");
 		}
 		if (status & DMA_STATUS_UNF) {
-			ETHPRINTK (intr, INFO,"Transmit Underflow\n");
+			ETHPRINTK(intr, INFO, "Transmit Underflow\n");
 		}
-		if (status & DMA_STATUS_RU){
-			ETHPRINTK (intr, INFO,"Rx Buffer Unavailable\n");
+		if (status & DMA_STATUS_RU) {
+			ETHPRINTK(intr, INFO, "Rx Buffer Unavailable\n");
 		}
-		if (status & DMA_STATUS_RPS){
-			ETHPRINTK (intr, INFO,"Receive Process Stopped\n");
+		if (status & DMA_STATUS_RPS) {
+			ETHPRINTK(intr, INFO, "Receive Process Stopped\n");
 		}
-		if (status & DMA_STATUS_RWT){
-			ETHPRINTK (intr, INFO,"Rx Watchdog Timeout\n");
+		if (status & DMA_STATUS_RWT) {
+			ETHPRINTK(intr, INFO, "Rx Watchdog Timeout\n");
 		}
-		if (status & DMA_STATUS_ETI){
-			ETHPRINTK (intr, INFO,"Early Tx Interrupt\n");
+		if (status & DMA_STATUS_ETI) {
+			ETHPRINTK(intr, INFO, "Early Tx Interrupt\n");
 		}
-		if (status & DMA_STATUS_FBI){
-			ETHPRINTK (intr, INFO,"Fatal Bus Error Interrupt\n");
+		if (status & DMA_STATUS_FBI) {
+			ETHPRINTK(intr, INFO, "Fatal Bus Error Interrupt\n");
 		}
 	}
-	ETHPRINTK (intr, INFO,"\n\n");
+	ETHPRINTK(intr, INFO, "\n\n");
 
 	/* Clear the interrupt by writing a logic 1 to the relative bits */
-	writel(status, ioaddr+DMA_STATUS);
+	writel(status, ioaddr + DMA_STATUS);
 	return;
 }
 
 /* ----------------------------------------------------------------------------
 			      DEVICE METHODS
    ---------------------------------------------------------------------------*/
+/**
+ *  stmmaceth_open - open entry point of the driver
+ *  @dev : pointer to the device structure.
+ *  Description:
+ *  This function is the open entry point of the driver.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
 int stmmaceth_open(struct net_device *dev)
 {
-	struct  eth_driver_local *lp = netdev_priv(dev);
+	struct eth_driver_local *lp = netdev_priv(dev);
 	int ret;
 
-       /* Request the IRQ lines */
-	if ( (ret = request_irq(dev->irq, &stmmaceth_interrupt,
-				SA_SHIRQ, dev->name, dev)) < 0 ) {
+	printk(KERN_DEBUG "stmmaceth_open: called...\n");
+
+	/* Request the IRQ lines */
+	if ((ret = request_irq(dev->irq, &stmmaceth_interrupt,
+			       SA_SHIRQ, dev->name, dev)) < 0) {
 		printk(KERN_ERR "%s: ERROR:allocating the IRQ %d (error: %d)\n",
-				__FUNCTION__, dev->irq, ret);
+		       __FUNCTION__, dev->irq, ret);
 		return (ret);
 	}
 
 	/* Check that the MAC address is valid.  If its not, refuse
 	 * to bring the device up. The user must specify an
 	 * address using the following linux command:
-	 * 	ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+	 *      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
+
+	printk(KERN_DEBUG "stmmaceth_open: checking MAC address\n");
 
 	if (!is_valid_ether_addr(dev->dev_addr)) {
-		ETHPRINTK(probe,ERR,"%s: no valid eth hw addr\n", __FUNCTION__);
+		ETHPRINTK(probe, ERR, "%s: no valid eth hw addr\n",
+			  __FUNCTION__);
 		return (-EINVAL);
 	}
 
+	printk(KERN_DEBUG "stmmaceth_open: setting MAC address\n");
+
 	/* Copy the MAC addr into the HW in case we have set it with nwhw */
 	set_mac_addr(dev->base_addr, dev->dev_addr);
 
+	printk(KERN_DEBUG "stmmaceth_open: initialising MAC core\n");
+
 	/* Initialize the MAC110 Core */
 	stmmaceth_mac_core_init(dev);
 
+	printk(KERN_DEBUG "stmmaceth_open: enabling MAC/DMA\n");
+
 	/* Enable the MAC/DMA */
 	stmmaceth_mac_enable_rx(dev);
 	stmmaceth_mac_enable_tx(dev);
@@ -1280,26 +1454,38 @@ int stmmaceth_open(struct net_device *de
 
 	/* Attach the PHY */
 	ret = stmmac_init_phy(dev);
-	if (ret)
-	{
+	if (ret) {
 		printk(KERN_ERR "%s: Cannot attach to PHY (error: %d)\n",
-				__FUNCTION__, ret);
+		       __FUNCTION__, ret);
 		return (-ENODEV);
 	}
 
 	phy_start(lp->phydev);
+	printk(KERN_DEBUG "stmmaceth_open: started PHY\n");
+	printk(KERN_DEBUG "stmmaceth_open: PHY link = %d\n",
+	       (lp->phydev)->link);
 
 	/* Start the ball rolling... */
 	ETHPRINTK(probe, DEBUG, "%s: DMA RX/TX processes started...\n",
-				RESOURCE_NAME);
+		  RESOURCE_NAME);
 
 	stmmaceth_dma_start_rx(dev->base_addr);
 	stmmaceth_dma_start_tx(dev->base_addr);
 
 	netif_start_queue(dev);
+	printk(KERN_DEBUG "stmmaceth_open: complete\n");
 	return (0);
 }
 
+/**
+ *  stmmaceth_release - close entry point of the driver
+ *  @dev : device pointer.
+ *  Description:
+ *  This is the stop entry point of the driver.
+ *  Return value:
+ *  0 on success and an appropriate (-)ve integer as defined in errno.h
+ *  file on failure.
+ */
 int stmmaceth_release(struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
@@ -1329,12 +1515,24 @@ int stmmaceth_release(struct net_device 
 	return (0);
 }
 
-/* It is used for filling the DMA tx ring with the frame to be transmitted.
- * Note that the algorithm works both for the non-paged data and for the paged
- * fragment (SG).
- * It also supports the segmentation offloading for super-sized skb's
- * (skb_shinfo(skb)->tso_size != 0). */
-static int stmmaceth_fill_tx_buffer(void *data, unsigned int size, unsigned int mss,
+/**
+ *  stmmaceth_fill_tx_buffer
+ *  @data : data buffer
+ *  @size : fragment size
+ *  @mss : Maximum  Segment Size
+ *  @lp : driver local structure
+ *  @first : first element in the ring
+ *  Description: it is used for filling the DMA tx ring with the frame to be 
+ *  transmitted.
+ *  Note that the algorithm works both for the non-paged data and for the paged
+ *  fragment (SG).
+ *  It also supports the segmentation offloading for super-sized skb's
+ *  (skb_shinfo(skb)->tso_size != 0). 
+ *  Return value:
+ *    current entry point in the tx ring
+ */
+static int stmmaceth_fill_tx_buffer(void *data, unsigned int size,
+				    unsigned int mss,
 				    struct eth_driver_local *lp, int first)
 {
 	int new_des = 0;
@@ -1342,8 +1540,8 @@ static int stmmaceth_fill_tx_buffer(void
 	dma_desc *p = lp->dma_tx;
 	unsigned int entry;
 
-	TSOPRINTK(mss, INFO,"  %s (size=%d, addr=0x%x)\n", s,
-		size, (unsigned int) addr);
+	TSOPRINTK(mss, INFO, "  %s (size=%d, addr=0x%x)\n", s,
+		  size, (unsigned int)addr);
 	do {
 		if (new_des) {
 			lp->cur_tx++;
@@ -1360,105 +1558,118 @@ static int stmmaceth_fill_tx_buffer(void
 			lp->tx_skbuff[entry] = NULL;
 
 		TSOPRINTK(mss, INFO, "\t[entry =%d] buf1 len=%d\n",
-				entry, min((int)size, DMA_BUFFER_SIZE));
+			  entry, min((int)size, DMA_BUFFER_SIZE));
 		/* If the data size is too big we need to use the buffer 2
 		 * (in the same descriptor) or, if necessary, another descriptor
 		 * in the ring. */
 		if (size < DMA_BUFFER_SIZE) {
 			p[entry].des1 |= ((size << DES1_RBS1_SIZE_SHIFT) &
-			  	DES1_RBS1_SIZE_MASK);
+					  DES1_RBS1_SIZE_MASK);
 			p[entry].des2 = dma_map_single(lp->device, addr,
-				size, DMA_TO_DEVICE);
+						       size, DMA_TO_DEVICE);
 		} else {
 			int b2_size = (size - DMA_BUFFER_SIZE);
 
 			p[entry].des1 |= TDES1_MAX_BUF1_SIZE;
 			p[entry].des2 = dma_map_single(lp->device, addr,
-				DMA_BUFFER_SIZE, DMA_TO_DEVICE);
+						       DMA_BUFFER_SIZE,
+						       DMA_TO_DEVICE);
 
 			/* Check if we need to use the buffer 2 */
 			if (b2_size > 0) {
 				void *buffer2 = addr;
 
-				TSOPRINTK(mss,INFO,"\t[entry=%d] buf2 len=%d\n",
-					entry, min(b2_size, DMA_BUFFER_SIZE));
+				TSOPRINTK(mss, INFO,
+					  "\t[entry=%d] buf2 len=%d\n", entry,
+					  min(b2_size, DMA_BUFFER_SIZE));
 
-				/* Check if we need another descriptor.*/
+				/* Check if we need another descriptor. */
 				if (b2_size > DMA_BUFFER_SIZE) {
 					b2_size = DMA_BUFFER_SIZE;
-					size -= (2*DMA_BUFFER_SIZE);
-					addr += ((2*DMA_BUFFER_SIZE)+1);
+					size -= (2 * DMA_BUFFER_SIZE);
+					addr += ((2 * DMA_BUFFER_SIZE) + 1);
 					new_des = 1;
-					TSOPRINTK(mss,INFO,"\tnew descriptor - "
-					       "%s (len = %d)\n",
-						(first)?"skb->data":"Frag",size);
+					TSOPRINTK(mss, INFO,
+						  "\tnew descriptor - "
+						  "%s (len = %d)\n",
+						  (first) ? "skb->data" :
+						  "Frag", size);
 				}
 				p[entry].des3 = dma_map_single(lp->device,
-						 (buffer2+DMA_BUFFER_SIZE+1),
-						  b2_size,DMA_TO_DEVICE);
+							       (buffer2 +
+								DMA_BUFFER_SIZE
+								+ 1), b2_size,
+							       DMA_TO_DEVICE);
 				if (b2_size == DMA_BUFFER_SIZE) {
 					p[entry].des1 |= TDES1_MAX_BUF2_SIZE;
-				}else{
-					p[entry].des1 |=((b2_size<<DES1_RBS2_SIZE_SHIFT)
-					      & DES1_RBS2_SIZE_MASK);
+				} else {
+					p[entry].des1 |=
+					    ((b2_size << DES1_RBS2_SIZE_SHIFT)
+					     & DES1_RBS2_SIZE_MASK);
 				}
 			}
 		}
-	} while(new_des);
+	} while (new_des);
 	return (entry);
 }
 
+/**
+ *  stmmaceth_xmit - Tx entry point of the driver
+ *  @skb : the socket buffer
+ *  @dev : device pointer
+ *  Description :
+ *  This function is the Tx entry point of the driver.
+ */
 int stmmaceth_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 	dma_desc *p = lp->dma_tx;
-        unsigned int nfrags = skb_shinfo(skb)->nr_frags,
-	    entry = lp->cur_tx % CONFIG_DMA_TX_SIZE,
-	    i, mss = 0, nopaged_len;
+	unsigned int nfrags = skb_shinfo(skb)->nr_frags,
+	    entry = lp->cur_tx % CONFIG_DMA_TX_SIZE, i, mss = 0, nopaged_len;
 
 	if (skb->len < ETH_ZLEN) {
 		skb = skb_padto(skb, ETH_ZLEN);
 		skb->len = ETH_ZLEN;
-        }
+	}
 
 	/* Reporting an error if either the frame, to be transmitted, is too
 	 * long or we haven't enough space in the DMA ring. If the following
 	 * error is reported, probably, you ought to increase the ring size.*/
-	if (nfrags >= CONFIG_DMA_TX_SIZE){
-		printk (KERN_ERR "%s: ERROR too many fragments (%d)...\n",
-			__FUNCTION__, nfrags);
+	if (nfrags >= CONFIG_DMA_TX_SIZE) {
+		printk(KERN_ERR "%s: ERROR too many fragments (%d)...\n",
+		       __FUNCTION__, nfrags);
 		goto xmit_error;
 	}
-	if (dev->features & NETIF_F_TSO){
-		/*Maximum  Segment Size*/
+	if (dev->features & NETIF_F_TSO) {
 		mss = skb_shinfo(skb)->tso_size;
 
-		if ((skb->len > ((2*(DMA_BUFFER_SIZE))*CONFIG_DMA_TX_SIZE))
-		    && (mss != 0)){
-			printk (KERN_ERR"%s: (TSO) frame too long (%d)...\n",
-				__FUNCTION__, skb->len);
+		if ((skb->len > ((2 * (DMA_BUFFER_SIZE)) * CONFIG_DMA_TX_SIZE))
+		    && (mss != 0)) {
+			printk(KERN_ERR "%s: (TSO) frame too long (%d)...\n",
+			       __FUNCTION__, skb->len);
 			goto xmit_error;
 		}
 	}
 	/* Verify the csum via software... it' necessary, because the
 	 * hardware doesn't support a complete csum calculation. */
-	if (skb->ip_summed == CHECKSUM_HW){
+	if (skb->ip_summed == CHECKSUM_HW) {
 		if (skb_checksum_help(skb, 0))
 			goto xmit_error;
 	}
 	/* Get the amount of non-paged data (skb->data). */
 	nopaged_len = skb_headlen(skb);
 	lp->tx_skbuff[entry] = skb;
-	TSOPRINTK(mss, INFO,"\n%s:\n(skb->len=%d, nfrags=%d, "
-			"nopaged_len=%d, mss=%d)\n", __FUNCTION__, skb->len,
-						  nfrags, nopaged_len, mss);
+	TSOPRINTK(mss, INFO, "\n%s:\n(skb->len=%d, nfrags=%d, "
+		  "nopaged_len=%d, mss=%d)\n", __FUNCTION__, skb->len,
+		  nfrags, nopaged_len, mss);
 	/* Handle the non-paged data (skb->data) */
 	stmmaceth_fill_tx_buffer(skb->data, nopaged_len, mss, lp, 1);
 
 	/* Handle the paged fragments */
-	for (i=0; i < nfrags; i++) {
+	for (i = 0; i < nfrags; i++) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-		void *addr=((void *)page_address(frag->page)+frag->page_offset);
+		void *addr =
+		    ((void *)page_address(frag->page) + frag->page_offset);
 		int len = frag->size;
 
 		lp->cur_tx++;
@@ -1471,36 +1682,37 @@ int stmmaceth_xmit(struct sk_buff *skb, 
 		netif_stop_queue(dev);
 
 	lp->stats.tx_bytes += skb->len;
-        dev->trans_start = jiffies;
+	dev->trans_start = jiffies;
 
 #ifdef CONFIG_STMMAC_DEBUG
 	if (netif_msg_pktdata(lp)) {
 		printk(">>> (current=%d, dirty=%d; entry=%d)\n",
-			(lp->cur_tx % CONFIG_DMA_TX_SIZE),
-			(lp->dirty_tx % CONFIG_DMA_TX_SIZE), entry);
+		       (lp->cur_tx % CONFIG_DMA_TX_SIZE),
+		       (lp->dirty_tx % CONFIG_DMA_TX_SIZE), entry);
 		display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
-		printk (">>> frame to be transmitted: ");
+		printk(">>> frame to be transmitted: ");
 		print_pkt(skb->data, skb->len);
 	}
 #endif
 	/* CSR1 enables the transmit DMA to check for new descriptor */
-	writel(1, dev->base_addr+DMA_XMT_POLL_DEMAND);
+	writel(1, dev->base_addr + DMA_XMT_POLL_DEMAND);
 	return (0);
 
-xmit_error:
+      xmit_error:
 	dev_kfree_skb(skb);
 	lp->stats.tx_dropped++;
 	return (0);
 }
 
-/* If the NAPI support is enable the stmmaceth_poll method will be
- * scheduled at interrupt time.
- * Otherwise, the stmmaceth_rx(...) is the receive function processed
- * by the regular interrupt handle. */
+/*   If the NAPI support is enable the stmmaceth_poll method will be
+ *   scheduled at interrupt time.
+ *   Otherwise, the stmmaceth_rx(...) is the receive function processed
+ *   by the regular interrupt handle. 
+ */
 #ifdef CONFIG_STMMAC_NAPI
 static int stmmaceth_poll(struct net_device *dev, int *budget)
 #else
-static int  stmmaceth_rx (struct net_device *dev)
+static int stmmaceth_rx(struct net_device *dev)
 #endif
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
@@ -1512,7 +1724,7 @@ static int  stmmaceth_rx (struct net_dev
 
 #ifdef CONFIG_STMMAC_DEBUG
 	if (netif_msg_rx_status(lp)) {
-		printk ("%s: RX descriptor ring:\n", __FUNCTION__);
+		printk("%s: RX descriptor ring:\n", __FUNCTION__);
 		display_dma_desc_ring(lp->dma_rx, CONFIG_DMA_RX_SIZE);
 	}
 #endif
@@ -1520,9 +1732,9 @@ static int  stmmaceth_rx (struct net_dev
 		struct sk_buff *skb;
 		unsigned int status = drx->des0;
 #ifdef CONFIG_STMMAC_NAPI
-		if (npackets > quota){
+		if (npackets > quota) {
 			printk("%s: ERROR: out of quota (%d); npackets %d\n",
-					dev->name, quota, npackets);
+			       dev->name, quota, npackets);
 			drx->des0 = OWN_BIT;
 			break;
 		}
@@ -1530,7 +1742,7 @@ static int  stmmaceth_rx (struct net_dev
 		/* Check if the frame was not successfully received */
 		if (status & RDES0_STATUS_ES) {
 			ETHPRINTK(rx_err, ERR, "%s: DMA rx ERROR: ",
-					RESOURCE_NAME);
+				  RESOURCE_NAME);
 			if (status & RDES0_STATUS_DE)
 				ETHPRINTK(rx_err, ERR, "descriptor error\n");
 			if (status & RDES0_STATUS_PFE)
@@ -1543,6 +1755,10 @@ static int  stmmaceth_rx (struct net_dev
 				ETHPRINTK(rx_err, ERR, "collision seen\n");
 				lp->stats.collisions++;
 			}
+			if (status & RDES0_STATUS_CE) {
+				ETHPRINTK(rx_err, ERR, "CRC Error\n");
+				lp->stats.rx_crc_errors++;
+			}
 			lp->stats.rx_errors++;
 			goto next_frame;
 		}
@@ -1551,10 +1767,12 @@ static int  stmmaceth_rx (struct net_dev
 			lp->stats.multicast++;
 		/* FL (frame length) indicates the length in byte including
 		 * the CRC */
-		frame_len=(status&RDES0_STATUS_FL_MASK)>>RDES0_STATUS_FL_SHIFT;
-		ETHPRINTK(rx_status, INFO,">>> desc addr: 0x%0x [entry: %d]\n"
+		frame_len =
+		    (status & RDES0_STATUS_FL_MASK) >> RDES0_STATUS_FL_SHIFT;
+		ETHPRINTK(rx_status, INFO,
+			  ">>> desc addr: 0x%0x [entry: %d]\n"
 			  "\tdesc0=0x%x desc1=0x%x buffer1=0x%x\n",
-			  (unsigned int )drx, entry, drx->des0, drx->des1,
+			  (unsigned int)drx, entry, drx->des0, drx->des1,
 			  drx->des2);
 		/* Check if the packet is long enough to accept without
 		   copying to a minimally-sized skbuff. */
@@ -1563,7 +1781,7 @@ static int  stmmaceth_rx (struct net_dev
 			if (!skb) {
 				if (printk_ratelimit())
 					printk(KERN_NOTICE "%s: low memory, "
-						"packet dropped.\n", dev->name);
+					       "packet dropped.\n", dev->name);
 				lp->stats.rx_dropped++;
 				goto next_frame;
 			}
@@ -1571,41 +1789,29 @@ static int  stmmaceth_rx (struct net_dev
 			skb_reserve(skb, NET_IP_ALIGN);
 			dma_sync_single_for_cpu(lp->device,
 						lp->rx_skbuff_dma[entry],
-			       			lp->rx_buf_sz, DMA_FROM_DEVICE);
+						lp->rx_buf_sz, DMA_FROM_DEVICE);
 			eth_copy_and_sum(skb, lp->rx_skbuff[entry]->tail,
-					frame_len, 0);
+					 frame_len, 0);
 			skb_put(skb, frame_len);
 			dma_sync_single_for_device(lp->device,
 						   lp->rx_skbuff_dma[entry],
-			                           lp->rx_buf_sz,
+						   lp->rx_buf_sz,
 						   DMA_FROM_DEVICE);
-		} else { /* zero-copy */
+		} else {	/* zero-copy */
 			skb = lp->rx_skbuff[entry];
 			dma_unmap_single(lp->device, lp->rx_skbuff_dma[entry],
-					lp->rx_buf_sz, DMA_FROM_DEVICE);
+					 lp->rx_buf_sz, DMA_FROM_DEVICE);
 			lp->rx_skbuff[entry] = NULL;
 			skb_put(skb, frame_len);
 		}
 #ifdef CONFIG_STMMAC_DEBUG
-		if (netif_msg_pktdata(lp)){
-			printk (">>> frame received: ");
+		if (netif_msg_pktdata(lp)) {
+			printk(">>> frame received: ");
 			print_pkt(skb->data, frame_len);
 		}
 #endif
 		skb->protocol = eth_type_trans(skb, dev);
-
-		if (lp->rx_csum) {
-			/* The device can "opaquely" calculate and verify any
-			 * csum in the incoming frames and report
-			 * success-or-failure to the driver.*/
-			if (status & RDES0_STATUS_CE) {
-				ETHPRINTK(rx_err, ERR, "CRC Error\n");
-				skb->ip_summed = CHECKSUM_NONE;
-			} else /* The network stack will calculate and
-				  verify the csum.*/
-				skb->ip_summed = CHECKSUM_UNNECESSARY;
-		} else
-			skb->ip_summed = CHECKSUM_NONE;
+		skb->ip_summed = CHECKSUM_NONE;
 
 #ifdef CONFIG_STMMAC_NAPI
 		npackets++;
@@ -1617,60 +1823,63 @@ static int  stmmaceth_rx (struct net_dev
 		lp->stats.rx_bytes += frame_len;
 		dev->last_rx = jiffies;
 
-next_frame:
+	      next_frame:
 		drx->des0 = OWN_BIT;
 		entry = (++lp->cur_rx) % CONFIG_DMA_RX_SIZE;
 		drx = lp->dma_rx + entry;
 	}
 
-       /* Refill the Rx ring buffers (zero-copy) */
-       for (; lp->cur_rx - lp->dirty_rx > 0; lp->dirty_rx++) {
+	/* Refill the Rx ring buffers (zero-copy) */
+	for (; lp->cur_rx - lp->dirty_rx > 0; lp->dirty_rx++) {
 		struct sk_buff *skb;
 		entry = lp->dirty_rx % CONFIG_DMA_RX_SIZE;
 		if (lp->rx_skbuff[entry] == NULL) {
 			skb = dev_alloc_skb(lp->rx_buf_sz);
 			lp->rx_skbuff[entry] = skb;
 			if (skb == NULL)
-			        break;
+				break;
 			skb->dev = dev;
 			lp->rx_skbuff_dma[entry] =
-			        dma_map_single(lp->device, skb->tail,
-			                       lp->rx_buf_sz,
-			                       DMA_FROM_DEVICE);
-			(lp->dma_rx+entry)->des2=lp->rx_skbuff_dma[entry];
-			ETHPRINTK(rx_status, INFO,">>> refill entry #%d\n",
-						  entry);
+			    dma_map_single(lp->device, skb->tail,
+					   lp->rx_buf_sz, DMA_FROM_DEVICE);
+			(lp->dma_rx + entry)->des2 = lp->rx_skbuff_dma[entry];
+			ETHPRINTK(rx_status, INFO, ">>> refill entry #%d\n",
+				  entry);
 		}
 	}
 
 #ifdef CONFIG_STMMAC_NAPI
-	 /* All the packets in the DMA have been processed so we can
-	  * reenable the RX interrupt. */
+	/* All the packets in the DMA have been processed so we can
+	 * reenable the RX interrupt. */
 	*budget -= npackets;
 	dev->quota -= npackets;
 	netif_rx_complete(dev);
 	stmmaceth_dma_start_rx(dev->base_addr);
 #else
-	writel(1, dev->base_addr+DMA_RCV_POLL_DEMAND);
+	writel(1, dev->base_addr + DMA_RCV_POLL_DEMAND);
 #endif
 	return 0;
 }
 
-/* This function is called when a packet transmission fails to complete
- * within a reasonable period. The driver will mark the error in the
- * netdev structure and arrange for the device to be reset to a sane state
- * in order to transmit a new packet. */
-void stmmaceth_tx_timeout (struct net_device *dev)
+/**
+ *  stmmaceth_tx_timeout
+ *  @dev : Pointer to net device structure
+ *  Description: this function is called when a packet transmission fails to 
+ *   complete within a reasonable period. The driver will mark the error in the
+ *   netdev structure and arrange for the device to be reset to a sane state
+ *   in order to transmit a new packet. 
+ */
+void stmmaceth_tx_timeout(struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 
 	printk("%s: Tx timeout at %ld, latency %ld\n",
-		dev->name, jiffies, (jiffies - dev->trans_start));
+	       dev->name, jiffies, (jiffies - dev->trans_start));
 
 #ifdef CONFIG_STMMAC_DEBUG
-	printk("(current=%d, dirty=%d)\n",(lp->cur_tx % CONFIG_DMA_TX_SIZE),
-		    (lp->dirty_tx % CONFIG_DMA_TX_SIZE));
-	printk ("DMA tx ring status: \n");
+	printk("(current=%d, dirty=%d)\n", (lp->cur_tx % CONFIG_DMA_TX_SIZE),
+	       (lp->dirty_tx % CONFIG_DMA_TX_SIZE));
+	printk("DMA tx ring status: \n");
 	display_dma_desc_ring(lp->dma_tx, CONFIG_DMA_TX_SIZE);
 #endif
 	netif_stop_queue(dev);
@@ -1687,7 +1896,11 @@ void stmmaceth_tx_timeout (struct net_de
 	return;
 }
 
-/* Return statistics to the caller application */
+/**
+ *  stmmaceth_stats
+ *  @dev : Pointer to net device structure
+ *  Description: this function returns statistics to the caller application 
+ */
 struct net_device_stats *stmmaceth_stats(struct net_device *dev)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
@@ -1697,19 +1910,20 @@ struct net_device_stats *stmmaceth_stats
 /* Configuration changes (passed on by ifconfig) */
 int stmmaceth_config(struct net_device *dev, struct ifmap *map)
 {
-	if (dev->flags & IFF_UP) /* can't act on a running interface */
+	if (dev->flags & IFF_UP)	/* can't act on a running interface */
 		return -EBUSY;
 
 	/* Don't allow changing the I/O address */
 	if (map->base_addr != dev->base_addr) {
-		printk(KERN_WARNING "%s: can't change I/O address\n",dev->name);
+		printk(KERN_WARNING "%s: can't change I/O address\n",
+		       dev->name);
 		return -EOPNOTSUPP;
 	}
 
 	/* Don't allow changing the IRQ */
 	if (map->irq != dev->irq) {
 		printk(KERN_WARNING "%s: can't change IRQ number %d\n",
-					 dev->name, dev->irq);
+		       dev->name, dev->irq);
 		return -EOPNOTSUPP;
 	}
 
@@ -1720,74 +1934,89 @@ int stmmaceth_config(struct net_device *
 /* ---------------------------------------------------------------------------
 			Address Filtering Method
    ---------------------------------------------------------------------------*/
+/**
+ *  stmmaceth_set_rx_mode - entry point for multicast addressing
+ *  @dev : pointer to the device structure
+ *  Description:
+ *  This function is a driver entry point which gets called by the kernel
+ *  whenever multicast addresses must be enabled/disabled.
+ *  Return value:
+ *  void.
+ */
 static void stmmaceth_set_rx_mode(struct net_device *dev)
 {
-	unsigned long ioaddr=dev->base_addr;
+	unsigned long ioaddr = dev->base_addr;
 	struct eth_driver_local *lp = netdev_priv(dev);
-	unsigned int value = (unsigned int) readl(ioaddr+MAC_CONTROL);
-	u32 mc_filter[2]; /* Multicast hash filter */
-
-	ETHPRINTK(probe, DEBUG,"%s: mc_list = 0x%x, mc_count = 0x%x\n",
-			      __FUNCTION__, (unsigned int)dev->mc_list,
-			      dev->mc_count);
+	unsigned int value = (unsigned int)readl(ioaddr + MAC_CONTROL);
 
 	if (dev->flags & IFF_PROMISC) {
-		ETHPRINTK(probe, DEBUG,"\tpromiscuous mode enabled.\n");
-		/* Promiscuous mode: set th PR bit in order to indicate
-		 * that all incoming frame are valid regardless of the
-		 * destination address.  */
 		value |= MAC_CONTROL_PR;
-		value &= ~(MAC_CONTROL_IF|MAC_CONTROL_HO);
-	} else if (dev->flags & IFF_ALLMULTI) {
-		ETHPRINTK(probe, DEBUG,"\tpass all multicast mode enabled.\n");
+		value &=
+		    ~(MAC_CONTROL_PM | MAC_CONTROL_IF | MAC_CONTROL_HO |
+		      MAC_CONTROL_HP);
+	} else if ((dev->mc_count > HASH_TABLE_SIZE)
+		   || (dev->flags & IFF_ALLMULTI)) {
 		value |= MAC_CONTROL_PM;
-		value &= ~(MAC_CONTROL_PR|MAC_CONTROL_IF|MAC_CONTROL_HO);
-	} else {
-		if (dev->mc_count == 0) {
-			ETHPRINTK(probe, DEBUG,"\tperfect filtering mode.\n");
-			value &= ~(MAC_CONTROL_PM|MAC_CONTROL_PR|MAC_CONTROL_IF|
-				   MAC_CONTROL_HO|MAC_CONTROL_HP);
-			writel(0x0, ioaddr+MAC_HASH_HIGH);
-			writel(0x0, ioaddr+MAC_HASH_LOW);
-		} else {
-			/* MAC Addr Perfect Filtering for physical addresses
-			 * and Hash Filtering for Multicast addresses;
-			 * Pass Multicast frames if enabled. */
-			int i;
-			ETHPRINTK(probe, DEBUG,"\tset Hash table for multicast "
-					  "addresses\n");
-			mc_filter[1] = mc_filter[0] = 0;
-			for (i = 0, lp->dmi = dev->mc_list;
-			     lp->dmi && i < dev->mc_count;
-			     i++, lp->dmi = lp->dmi->next) {
-				int bit_nr = ether_crc(ETH_ALEN,
-						lp->dmi->dmi_addr) >> 26;
-				mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
-			}
-			writel(mc_filter[0], ioaddr+MAC_HASH_HIGH);
-			writel(mc_filter[1], ioaddr+MAC_HASH_LOW);
-
-			value |= MAC_CONTROL_HP;
-			value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |
-				   MAC_CONTROL_IF| MAC_CONTROL_HO);
+		value &= ~(MAC_CONTROL_PR | MAC_CONTROL_IF | MAC_CONTROL_HO);
+		writel(0xffffffff, ioaddr + MAC_HASH_HIGH);
+		writel(0xffffffff, ioaddr + MAC_HASH_LOW);
+	} else if (dev->mc_count == 0) {	/* Just get our own stuff .. no multicast?? */
+		value &=
+		    ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |
+		      MAC_CONTROL_HO | MAC_CONTROL_HP);
+	} else {		/* Store the addresses in the multicast HW filter */
+		int i;
+		u32 mc_filter[2];
+		struct dev_mc_list *mclist;
+
+		/* Perfect filter mode for physical address and Hash
+		   filter for multicast */
+		value |= MAC_CONTROL_PM | MAC_CONTROL_HP;
+		value &= ~(MAC_CONTROL_PR | MAC_CONTROL_IF | MAC_CONTROL_HO);
+
+		memset(mc_filter, 0, sizeof(mc_filter));
+		for (i = 0, mclist = dev->mc_list;
+		     mclist && i < dev->mc_count; i++, mclist = mclist->next) {
+			/* The upper 6 bits of the calculated CRC are used to index
+			   the contens of the hash table */
+			int bit_nr =
+			    ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			/* The most significant bit determines the register to use
+			   (H/L) while the other 5 bits determine the bit within
+			   the register. */
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
 		}
+		writel(mc_filter[0], ioaddr + MAC_HASH_HIGH);
+		writel(mc_filter[1], ioaddr + MAC_HASH_LOW);
 	}
 
-	writel(value, ioaddr+MAC_CONTROL);
+	writel(value, ioaddr + MAC_CONTROL);
 
-	if (netif_msg_hw(lp))
-		dump_stm_mac_csr((unsigned int)dev->base_addr);
+	if (netif_msg_hw(lp)) {
+		printk("%s: CTRL reg: 0x%lx - Hash regs: HI 0x%lx, LO 0x%lx\n",
+		       __FUNCTION__, readl(ioaddr + MAC_CONTROL),
+		       readl(ioaddr + MAC_HASH_HIGH),
+		       readl(ioaddr + MAC_HASH_LOW));
+	}
 	return;
 }
 
-/* The Maximum Transfer Unit (MTU) is used by the network layer to
- * drive packet transmission. Ethernet has an MTU of 1500 octets (ETH_DATA_LEN).
- * This value can be changed with ifconfig.  */
+/**
+ *  stmmaceth_change_mtu - entry point to change MTU size for the device.
+ *   @dev : device pointer.
+ *   @new_mtu : the new MTU size for the device.
+ *   Description: the Maximum Transfer Unit (MTU) is used by the network layer to
+ *     drive packet transmission. Ethernet has an MTU of 1500 octets (ETH_DATA_LEN).
+ *     This value can be changed with ifconfig.
+ *  Return value:
+ *   0 on success and an appropriate (-)ve integer as defined in errno.h
+ *   file on failure.
+ */
 static int stmmaceth_change_mtu(struct net_device *dev, int new_mtu)
 {
 	if (netif_running(dev)) {
-		printk (KERN_ERR "%s: must be stopped to change its MTU\n",
-				 dev->name);
+		printk(KERN_ERR "%s: must be stopped to change its MTU\n",
+		       dev->name);
 		return -EBUSY;
 	}
 
@@ -1803,13 +2032,13 @@ static int stmmaceth_change_mtu(struct n
 			REGULAR INTERRUPT FUNCTION
    ---------------------------------------------------------------------------*/
 static irqreturn_t stmmaceth_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs)
+				       struct pt_regs *regs)
 {
 	struct eth_driver_local *lp;
 	struct net_device *dev = (struct net_device *)dev_id;
 
 	if (!dev) {
-		printk (KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
+		printk(KERN_ERR "%s: invalid dev pointer\n", __FUNCTION__);
 		return IRQ_NONE;
 	}
 	lp = netdev_priv(dev);
@@ -1837,7 +2066,7 @@ static void stmmaceth_poll_controller(st
 		  		ETHTOOL SUPPORT
    ---------------------------------------------------------------------------*/
 static void stmmaceth_ethtool_getdrvinfo(struct net_device *dev,
-				   struct ethtool_drvinfo*info)
+					 struct ethtool_drvinfo *info)
 {
 	strcpy(info->driver, RESOURCE_NAME);
 	strncpy(info->version, version, sizeof(version));
@@ -1847,20 +2076,21 @@ static void stmmaceth_ethtool_getdrvinfo
 }
 
 static int stmmaceth_ethtool_getsettings(struct net_device *dev,
-					  struct ethtool_cmd *cmd)
+					 struct ethtool_cmd *cmd)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 	struct phy_device *phy = lp->phydev;
 
-	if (phy == NULL)
-	{
-		printk(KERN_ERR "%s: ethtool_getsettings PHY is not registered\n", dev->name);
+	if (phy == NULL) {
+		printk(KERN_ERR
+		       "%s: ethtool_getsettings PHY is not registered\n",
+		       dev->name);
 		return -ENODEV;
 	}
 
 	if (!netif_running(dev)) {
 		printk(KERN_ERR "%s: interface is disabled: we cannot track "
-				   "link speed / duplex setting\n", dev->name);
+		       "link speed / duplex setting\n", dev->name);
 		return -EBUSY;
 	}
 
@@ -1869,7 +2099,7 @@ static int stmmaceth_ethtool_getsettings
 }
 
 static int stmmaceth_ethtool_setsettings(struct net_device *dev,
-					  struct ethtool_cmd *cmd)
+					 struct ethtool_cmd *cmd)
 {
 	struct eth_driver_local *lp = dev->priv;
 	struct phy_device *phy = lp->phydev;
@@ -1904,7 +2134,7 @@ int stmmaceth_ethtool_get_regs_len(struc
 }
 
 static void stmmaceth_ethtool_gregs(struct net_device *dev,
-			       	     struct ethtool_regs *regs, void *space)
+				    struct ethtool_regs *regs, void *space)
 {
 	int i;
 	u32 reg;
@@ -1914,25 +2144,23 @@ static void stmmaceth_ethtool_gregs(stru
 
 	/* MAC registers */
 	for (i = 0; i < 11; i++) {
-		reg = readl(dev->base_addr + i*4);
-		memcpy((reg_space + i*4), &reg, sizeof(u32));
+		reg = readl(dev->base_addr + i * 4);
+		memcpy((reg_space + i * 4), &reg, sizeof(u32));
 	}
 
 	/* DMA registers */
-	for (i = 0; i<9; i++) {
-		reg = readl(dev->base_addr+(DMA_BUS_MODE+i*4));
-		memcpy((reg_space + (DMA_BUS_MODE+i*4)), &reg,
-			sizeof(u32));
+	for (i = 0; i < 9; i++) {
+		reg = readl(dev->base_addr + (DMA_BUS_MODE + i * 4));
+		memcpy((reg_space + (DMA_BUS_MODE + i * 4)), &reg, sizeof(u32));
 	}
-	reg = readl(dev->base_addr+DMA_CUR_TX_BUF_ADDR);
+	reg = readl(dev->base_addr + DMA_CUR_TX_BUF_ADDR);
 	memcpy((reg_space + DMA_CUR_TX_BUF_ADDR), &reg, sizeof(u32));
-	reg = readl(dev->base_addr+DMA_CUR_RX_BUF_ADDR);
+	reg = readl(dev->base_addr + DMA_CUR_RX_BUF_ADDR);
 	memcpy((reg_space + DMA_CUR_RX_BUF_ADDR), &reg, sizeof(u32));
 
 	return;
 }
 
-
 int stmmaceth_ethtool_set_tx_csum(struct net_device *dev, u32 data)
 {
 	if (data)
@@ -1963,86 +2191,89 @@ int stmmaceth_ethtool_set_rx_csum(struct
 }
 
 static struct ethtool_ops stmmaceth_ethtool_ops = {
-	.begin 		= stmmaceth_check_if_running,
-	.get_drvinfo    = stmmaceth_ethtool_getdrvinfo,
-	.get_settings   = stmmaceth_ethtool_getsettings,
-	.set_settings   = stmmaceth_ethtool_setsettings,
-	.get_msglevel   = stmmaceth_ethtool_getmsglevel,
-	.set_msglevel   = stmmaceth_ethtool_setmsglevel,
-	.get_regs 	= stmmaceth_ethtool_gregs,
-	.get_regs_len 	= stmmaceth_ethtool_get_regs_len,
-	.get_link       = ethtool_op_get_link,
-	.get_rx_csum 	= stmmaceth_ethtool_get_rx_csum,
-	.set_rx_csum 	= stmmaceth_ethtool_set_rx_csum,
-	.get_tx_csum 	= ethtool_op_get_tx_csum,
-	.set_tx_csum 	= stmmaceth_ethtool_set_tx_csum,
-	.get_sg 	= ethtool_op_get_sg,
-	.set_sg 	= ethtool_op_set_sg,
+	.begin = stmmaceth_check_if_running,
+	.get_drvinfo = stmmaceth_ethtool_getdrvinfo,
+	.get_settings = stmmaceth_ethtool_getsettings,
+	.set_settings = stmmaceth_ethtool_setsettings,
+	.get_msglevel = stmmaceth_ethtool_getmsglevel,
+	.set_msglevel = stmmaceth_ethtool_setmsglevel,
+	.get_regs = stmmaceth_ethtool_gregs,
+	.get_regs_len = stmmaceth_ethtool_get_regs_len,
+	.get_link = ethtool_op_get_link,
+	.get_rx_csum = stmmaceth_ethtool_get_rx_csum,
+	.set_rx_csum = stmmaceth_ethtool_set_rx_csum,
+	.get_tx_csum = ethtool_op_get_tx_csum,
+	.set_tx_csum = stmmaceth_ethtool_set_tx_csum,
+	.get_sg = ethtool_op_get_sg,
+	.set_sg = ethtool_op_set_sg,
 #ifdef NETIF_F_TSO
-        .get_tso        = ethtool_op_get_tso,
-        .set_tso        = ethtool_op_set_tso,
+	.get_tso = ethtool_op_get_tso,
+	.set_tso = ethtool_op_set_tso,
 #endif
-        .get_ufo 	= ethtool_op_get_ufo,
-        .set_ufo 	= ethtool_op_set_ufo,
+	.get_ufo = ethtool_op_get_ufo,
+	.set_ufo = ethtool_op_set_ufo,
 
 };
 
-
 /* ----------------------------------------------------------------------------
 		    		IOCTL SUPPORT
    ---------------------------------------------------------------------------*/
-
+/**
+ *  stmmaceth_ioctl - Entry point for the Ioctl
+ *  @dev :  Device pointer.
+ *  @rq :  An IOCTL specefic structure, that can contain a pointer to
+ *  a proprietary structure used to pass information to the driver.
+ *  @cmd :  IOCTL command
+ *  Description:
+ *  Currently there are no special functionality supported in IOCTL, just the 
+ *  phy_mii_ioctl is invoked (it changes the PHY registers without regard to
+ *  current state).
+ */
 static int stmmaceth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-    struct eth_driver_local *lp = dev->priv;
-    int rc;
-    unsigned long flags;
-
-    /* SIOC[GS]MIIxxx ioctls */
-    spin_lock_irqsave(&lp->lock, flags);
-    rc = phy_mii_ioctl(lp->phydev, if_mii(rq), cmd);
-    spin_unlock_irqrestore(&lp->lock, flags);
+	struct eth_driver_local *lp = dev->priv;
+	int rc;
+	unsigned long flags;
 
-    return rc;
-}
+	/* SIOC[GS]MIIxxx ioctls */
+	spin_lock_irqsave(&lp->lock, flags);
+	rc = phy_mii_ioctl(lp->phydev, if_mii(rq), cmd);
+	spin_unlock_irqrestore(&lp->lock, flags);
 
+	return rc;
+}
 
 /* ----------------------------------------------------------------------------
 		    		VLAN SUPPORT
    ---------------------------------------------------------------------------*/
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 static void stmmaceth_vlan_rx_register(struct net_device *dev,
-				    struct vlan_group *grp)
+				       struct vlan_group *grp)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 
 	spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: setting vlgrp to %p\n", dev->name, grp);
 	lp->vlgrp = grp;
 	stmmaceth_set_rx_mode(dev);
 	spin_unlock(&lp->lock);
 }
 
 static void stmmaceth_vlan_rx_add_vid(struct net_device *dev,
-				       unsigned short vid)
+				      unsigned short vid)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 
 	spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: adding VLAN ID %d to VLAN filter\n",
-			  dev->name, vid);
 	stmmaceth_set_rx_mode(dev);
 	spin_unlock(&lp->lock);
 }
 
 static void stmmaceth_vlan_rx_kill_vid(struct net_device *dev,
-					unsigned short vid)
+				       unsigned short vid)
 {
 	struct eth_driver_local *lp = netdev_priv(dev);
 
 	spin_lock(&lp->lock);
-	printk(KERN_DEBUG "%s: removing VLAN ID %d from VLAN filter\n",
-			  dev->name, vid);
 	if (lp->vlgrp)
 		lp->vlgrp->vlan_devices[vid] = NULL;
 	stmmaceth_set_rx_mode(dev);
@@ -2053,6 +2284,14 @@ static void stmmaceth_vlan_rx_kill_vid(s
 /* ----------------------------------------------------------------------------
 		   DEVICE REGISTRATION, INITIALIZATION AND UNLOADING
    ---------------------------------------------------------------------------*/
+/**
+ *  stmmaceth_probe - Initialization of the adapter .
+ *  @dev : device pointer
+ *  @ioaddr: device I/O address
+ *  Description: The function initializes the network device structure for
+ *	         the STMMAC driver. It also calls the low level routines 
+ *		 in order to init the HW (i.e. the DMA engine)
+ */
 static int stmmaceth_probe(struct net_device *dev, unsigned long ioaddr)
 {
 	int ret = 0;
@@ -2062,18 +2301,18 @@ static int stmmaceth_probe(struct net_de
 
 	dev->open = stmmaceth_open;
 	dev->stop = stmmaceth_release;
-	dev->set_config	= stmmaceth_config;
+	dev->set_config = stmmaceth_config;
 
 	dev->hard_start_xmit = stmmaceth_xmit;
-	dev->features |= (NETIF_F_SG|NETIF_F_HW_CSUM|NETIF_F_HIGHDMA);
+	dev->features |= (NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA);
 
-	/*dev->features |= NETIF_F_TSO;*/
+	/*dev->features |= NETIF_F_TSO; */
 
 	dev->get_stats = stmmaceth_stats;
-	dev->tx_timeout	= stmmaceth_tx_timeout;
+	dev->tx_timeout = stmmaceth_tx_timeout;
 	dev->watchdog_timeo = msecs_to_jiffies(watchdog);;
-	dev->set_multicast_list	= stmmaceth_set_rx_mode,
-	dev->change_mtu	= stmmaceth_change_mtu;
+	dev->set_multicast_list = stmmaceth_set_rx_mode,
+	    dev->change_mtu = stmmaceth_change_mtu;
 	dev->ethtool_ops = &stmmaceth_ethtool_ops;
 	dev->do_ioctl = &stmmaceth_ioctl;
 #ifdef CONFIG_NET_POLL_CONTROLLER
@@ -2087,7 +2326,7 @@ static int stmmaceth_probe(struct net_de
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 	dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
 	dev->vlan_rx_register = stmmaceth_vlan_rx_register;
-	dev->vlan_rx_add_vid  = stmmaceth_vlan_rx_add_vid;
+	dev->vlan_rx_add_vid = stmmaceth_vlan_rx_add_vid;
 	dev->vlan_rx_kill_vid = stmmaceth_vlan_rx_kill_vid;
 #endif
 
@@ -2097,7 +2336,7 @@ static int stmmaceth_probe(struct net_de
 #else
 	lp->ip_header_len = ETH_HLEN;
 #endif
-	lp->rx_csum = 1;
+	lp->rx_csum = 0;
 	tasklet_init(&lp->tx_task, stmmaceth_clean_tx_irq, (unsigned long)dev);
 	/* Check the module arguments */
 	stmmaceth_check_mod_params(dev);
@@ -2106,34 +2345,29 @@ static int stmmaceth_probe(struct net_de
 	dev->base_addr = ioaddr;
 	printk(KERN_INFO "\tI/O base addr: 0x%lx\n", dev->base_addr);
 
-	/* Get the MAC address*/
+	/* Get the MAC address */
 	printk(KERN_INFO "\tHW MAC address: ");
 	get_mac_address(ioaddr, dev->dev_addr);
 	print_mac_addr(dev->dev_addr);
 
 	if (!is_valid_ether_addr(dev->dev_addr)) {
-		printk (KERN_WARNING "\tno valid MAC address; "
-				    "please, set using ifconfig or nwhwconfig!\n");
+		printk(KERN_WARNING "\tno valid MAC address; "
+		       "please, set using ifconfig or nwhwconfig!\n");
 	}
 
 	if ((ret = register_netdev(dev))) {
 		printk(KERN_ERR "%s: ERROR %i registering the device\n",
-				__FUNCTION__, ret);
+		       __FUNCTION__, ret);
 		return (-ENODEV);
 	}
 
-	printk(KERN_DEBUG "Registered netdev %s ret = %d\n", dev->name, ret);
-	if (dev->reg_state == NETREG_REGISTERED){
-		printk(KERN_DEBUG "Netdev %s IS registered\n", dev->name);
-	}
-
 	/* Create and initialize the TX/RX descriptors rings */
 	init_dma_desc_rings(dev);
 
 	/* Intialize the DMA controller and send the SW reset */
-	if (stmmaceth_dma_init(dev) < 0 ) {
+	if (stmmaceth_dma_init(dev) < 0) {
 		ETHPRINTK(probe, ERR, "%s: DMA initialization failed\n",
-				__FUNCTION__);
+			  __FUNCTION__);
 		return (-1);
 	}
 
@@ -2142,6 +2376,13 @@ static int stmmaceth_probe(struct net_de
 	return (ret);
 }
 
+/**
+ * stmmaceth_dvr_remove
+ * @pdev: platform device pointer
+ * Description: The driver is initialized through platform_device.  
+ * 		Structures which define the configuration needed by the board 
+ *		are defined in a board structure in arch/sh/boards/st/ .
+ */
 static int stmmaceth_dvr_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -2163,37 +2404,36 @@ static int stmmaceth_dvr_probe(struct pl
 	if (!request_mem_region(res->start, (res->end - res->start),
 				RESOURCE_NAME)) {
 		printk(KERN_ERR "%s: ERROR: memory allocation failed"
-				"cannot get the I/O addr 0x%x\n",
-				__FUNCTION__, (unsigned int)res->start);
+		       "cannot get the I/O addr 0x%x\n",
+		       __FUNCTION__, (unsigned int)res->start);
 		ret = -EBUSY;
 		goto out;
 	}
 
 	printk(KERN_INFO "\tmapping the I/O space (start=0x%x, size=0x%x)\n",
-			 (unsigned int)res->start,
-			 (unsigned int)(res->end - res->start));
+	       (unsigned int)res->start, (unsigned int)(res->end - res->start));
 	addr = ioremap(res->start, (res->end - res->start));
 	if (!addr) {
 		printk(KERN_ERR "%s: ERROR: memory mapping failed \n",
-					__FUNCTION__);
+		       __FUNCTION__);
 		ret = -ENOMEM;
 		goto out;
 	}
 
 	printk(KERN_INFO "\tnetwork device initialization... ");
 	ndev = alloc_etherdev(sizeof(struct eth_driver_local));
-	if (!ndev ) {
+	if (!ndev) {
 		printk(KERN_ERR "%s: ERROR: allocating the device\n",
-					__FUNCTION__);
+		       __FUNCTION__);
 		ret = -ENOMEM;
 		goto out;
 	}
 	printk(KERN_INFO "done!\n");
 
 	/* Get the MAC information */
-	if ((ndev->irq = platform_get_irq_byname(pdev, "macirq")) == 0){
+	if ((ndev->irq = platform_get_irq_byname(pdev, "macirq")) == 0) {
 		printk(KERN_ERR "%s: ERROR: MAC IRQ configuration "
-				"information not found\n",__FUNCTION__);
+		       "information not found\n", __FUNCTION__);
 		ret = -ENODEV;
 		goto out;
 	}
@@ -2215,30 +2455,27 @@ static int stmmaceth_dvr_probe(struct pl
 	printk(KERN_INFO "\tnetwork device registration done (%d)\n", ret);
 
 	/* Get the PHY information */
-	if ((phy_irq = platform_get_irq_byname(pdev, "phyirq")) == 0){
+	if ((phy_irq = platform_get_irq_byname(pdev, "phyirq")) == 0) {
 		printk(KERN_ERR "%s: ERROR: PHY IRQ configuration "
-				"information not found\n",__FUNCTION__);
+		       "information not found\n", __FUNCTION__);
 		ret = -ENODEV;
 		goto out;
 	}
 	printk(KERN_INFO "\tPHY IRQ number: %d\n", phy_irq);
 
 	lp->phy_irq = phy_irq;
-        if ((phy_n >=0) && (phy_n <= 31)) {
+	if ((phy_n >= 0) && (phy_n <= 31)) {
 		plat_dat->phy_addr = phy_n;
-        }
+	}
 	lp->phy_addr = plat_dat->phy_addr;
 	lp->phy_ignorezero = plat_dat->phy_ignorezero;
 
 	/* MDIO bus Registration */
-	printk(KERN_DEBUG "\tMDIO bus registration... ");
 	ret = stmmac_mdio_register(lp, ndev, (unsigned long)addr);
-	printk(KERN_DEBUG "done (returned %d)!\n", ret);
 
 	ndev = __dev_get_by_name("eth0");
-	printk(KERN_DEBUG "\tnetwork device name = %s\n", ndev->name);
 
-out:
+      out:
 	if (ret < 0) {
 		platform_set_drvdata(pdev, NULL);
 		release_mem_region(res->start, (res->end - res->start));
@@ -2246,10 +2483,20 @@ out:
 			iounmap(addr);
 	}
 
-	printk(KERN_DEBUG "\tplatform registration complete\n");
 	return (ret);
 }
 
+/**
+ * stmmaceth_dvr_remove
+ * @pdev: platform device pointer
+ * Description: This function performs the following:
+ *   		- Reset the TX/RX processes
+ *   		- Disable the MAC RX/TX
+ *   		- Change the link status
+ *   		- Free the DMA descriptor rings
+ *   		- Unregister the MDIO bus
+ *   		- unmap the memory resources
+ */
 static int stmmaceth_dvr_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
@@ -2258,21 +2505,16 @@ static int stmmaceth_dvr_remove(struct p
 
 	printk(KERN_INFO "%s:\n\tremoving driver", __FUNCTION__);
 
-	/* Reset the TX/RX processes */
 	stmmaceth_dma_stop_rx(ndev->base_addr);
 	stmmaceth_dma_stop_tx(ndev->base_addr);
 
-	/* Disable the MAC RX/TX */
 	stmmaceth_mac_disable_rx(ndev);
 	stmmaceth_mac_disable_tx(ndev);
 
-	/* Change the link status */
 	netif_carrier_off(ndev);
 
-	/* Free the DMA descriptor rings */
 	free_dma_desc_resources(ndev);
 
-	/* Unregister the MDIO bus */
 	stmmac_mdio_unregister(lp);
 
 	platform_set_drvdata(pdev, NULL);
@@ -2289,21 +2531,27 @@ static int stmmaceth_dvr_remove(struct p
 
 static struct platform_driver stmmaceth_driver = {
 	.driver = {
-		.name           = RESOURCE_NAME,
-	},
-	.probe          = stmmaceth_dvr_probe,
-	.remove         = stmmaceth_dvr_remove,
+		   .name = RESOURCE_NAME,
+		   },
+	.probe = stmmaceth_dvr_probe,
+	.remove = stmmaceth_dvr_remove,
 };
 
+/**
+ * stmmaceth_init_module - Entry point for the driver
+ * Description: This function is the entry point for the driver.
+ */
 static int __init stmmaceth_init_module(void)
 {
-	printk(KERN_DEBUG "%s: register the device driver\n", __FUNCTION__);
 	return platform_driver_register(&stmmaceth_driver);
 }
 
+/**
+ * stmmaceth_cleanup_module - Cleanup routine for the driver
+ * Description: This function is the cleanup routine for the driver.
+ */
 static void __exit stmmaceth_cleanup_module(void)
 {
-	printk(KERN_DEBUG "%s: unregister the device driver\n", __FUNCTION__);
 	platform_driver_unregister(&stmmaceth_driver);
 }
 
@@ -2312,35 +2560,27 @@ static void __exit stmmaceth_cleanup_mod
  * --------------------------------------------------------------------------*/
 static int __init stmmaceth_cmdline_opt(char *str)
 {
-	char* opt;
+	char *opt;
 
-	printk(KERN_DEBUG "stmmaceth_cmdline_opt: \n");
 	if (!str || !*str)
 		return -EINVAL;
 
-	while ((opt=strsep(&str, ",")) != NULL) {
-		if (! strncmp(opt, "msglvl:", 7)) {
-			debug = simple_strtoul(opt+7, NULL, 0);
-		}
-		else if (! strncmp(opt, "phyaddr:", 8)) {
-			phy_n = simple_strtoul(opt+8, NULL, 0);
-		}
-		else if (! strncmp(opt, "watchdog:", 9)) {
-			 watchdog = simple_strtoul(opt+9, NULL, 0);
-		}
-		else if (! strncmp(opt, "pause:", 6)) {
-			 pause_time = simple_strtoul(opt+6, NULL, 0);
-		}
-		else if (! strncmp(opt, "rxsize:", 7)) {
-			 min_rx_pkt_size = simple_strtoul(opt+7, NULL, 0);
+	while ((opt = strsep(&str, ",")) != NULL) {
+		if (!strncmp(opt, "msglvl:", 7)) {
+			debug = simple_strtoul(opt + 7, NULL, 0);
+		} else if (!strncmp(opt, "phyaddr:", 8)) {
+			phy_n = simple_strtoul(opt + 8, NULL, 0);
+		} else if (!strncmp(opt, "watchdog:", 9)) {
+			watchdog = simple_strtoul(opt + 9, NULL, 0);
+		} else if (!strncmp(opt, "pause:", 6)) {
+			pause_time = simple_strtoul(opt + 6, NULL, 0);
+		} else if (!strncmp(opt, "rxsize:", 7)) {
+			min_rx_pkt_size = simple_strtoul(opt + 7, NULL, 0);
 		}
 	}
-	printk(KERN_DEBUG "\tdebug msg level = %d, phy_addr = %d\n"
-			  "\twatchdog = %d, pause_time = %d\n"
-			  "\trxsize = %d\n",
-			   debug, phy_n, watchdog, pause_time, min_rx_pkt_size);
 	return (0);
 }
+
 __setup("stmmaceth=", stmmaceth_cmdline_opt);
 
 module_init(stmmaceth_init_module);
