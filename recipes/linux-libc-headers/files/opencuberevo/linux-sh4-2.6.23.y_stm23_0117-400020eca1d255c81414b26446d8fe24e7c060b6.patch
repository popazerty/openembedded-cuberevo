From 400020eca1d255c81414b26446d8fe24e7c060b6 Mon Sep 17 00:00:00 2001
From: Carl SHAW <carl.shaw@st.com>
Date: Mon, 1 Dec 2008 17:12:40 +0000
Subject: [PATCH] i2c-stm: Major I2C driver update

This patch provides a major update to the SSC-based I2C driver.
Changelog:

* Version 2.5 (24th Oct 2008)  Carl Shaw <carl.shaw@st.com>
*   + Rewrite START state - in case of write it now preloads TX FIFO
*                           and it is also shared for REPSTART address
*   + Change RX prepare - checks for NACK, reads address and then falls
*                         through to read state
*   + Change RX state - Use TEEN interrupt to reduce unnecessary interrupt
*                       loading.  Previously, RIR was used which generated
*                       an interrupt per byte
*   + Change TX state - correctly unload RX FIFO (using both FIFO status
*                       AND RIR bit)
*                     - use TEEN interrupt rather than TIR to avoid an
*                       interrupt per byte
*   + Change repstart address - just call START state but suppress STARTG
*   + Only use PIO recovery as last-ditch effort
*   + Fix retry method
*   + Add auto retry in case of arbitration problem
*   + Allow a PIO mode for clock of push-pull rather than BIDIR.  This
*     can help with spurious noise glitches on the SCK line and in the
*     case where SCK rise times are marginal due to capacitance on the
*     bus.

The push-pull mode for a bus can be selected by specifying SSC_I2C_CLK_UNIDIR
with the capability in the board-specific setup.c file

e.g. ssc0_has(SSC_I2C_CAPABILITY | SSC_I2C_CLK_UNIDIR)

This version should reduce interrupt loading considerably.

Signed-off-by: Carl Shaw <carl.shaw@st.com>
Reviewd-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
---
 arch/sh/kernel/cpu/sh4/setup-stb7100.c |    2 +
 arch/sh/kernel/cpu/sh4/setup-stx5197.c |    3 +
 arch/sh/kernel/cpu/sh4/setup-stx7105.c |    3 +
 arch/sh/kernel/cpu/sh4/setup-stx7111.c |    3 +
 arch/sh/kernel/cpu/sh4/setup-stx7141.c |    2 +
 arch/sh/kernel/cpu/sh4/setup-stx7200.c |    2 +
 drivers/i2c/busses/i2c-stm.c           | 1069 +++++++++++++++++++-------------
 include/linux/stm/soc.h                |   15 +-
 8 files changed, 671 insertions(+), 428 deletions(-)

diff --git a/arch/sh/kernel/cpu/sh4/setup-stb7100.c b/arch/sh/kernel/cpu/sh4/setup-stb7100.c
index 81da12b..9384433 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stb7100.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stb7100.c
@@ -324,6 +324,8 @@ void __init stx7100_configure_ssc(struct plat_ssc_data *data)
 			stssc_devices[i].name = i2c_st;
 			sysconf_write(ssc_sc, 0);
 			stssc_devices[i].id = num_i2c++;
+			if (capability & SSC_I2C_CLK_UNIDIR)
+				ssc_pio->clk_unidir = 1;
 		}
 		platform_device_register(&stssc_devices[i]);
 	}
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx5197.c b/arch/sh/kernel/cpu/sh4/setup-stx5197.c
index eeea457..e51e060 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx5197.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx5197.c
@@ -251,6 +251,9 @@ void __init stx5197_configure_ssc(struct plat_ssc_data *data)
 		if (capability & SSC_UNCONFIGURED)
 			continue;
 
+		if (capability & SSC_I2C_CLK_UNIDIR)
+			ssc_pio->clk_unidir = 1;
+
 		switch (i) {
 		case 0:
 			/* SSC0 can either drive the SPI pins (in which
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx7105.c b/arch/sh/kernel/cpu/sh4/setup-stx7105.c
index db61b6e..ed487d3 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx7105.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx7105.c
@@ -337,6 +337,9 @@ void __init stx7105_configure_ssc(struct plat_ssc_data *data)
 		if(capability & SSC_UNCONFIGURED)
 			continue;
 
+		if (capability & SSC_I2C_CLK_UNIDIR)
+			ssc_pio->clk_unidir = 1;
+
 		switch (i) {
 		case 0:
 		case 1:
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx7111.c b/arch/sh/kernel/cpu/sh4/setup-stx7111.c
index 51a385d..0095a35 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx7111.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx7111.c
@@ -224,6 +224,9 @@ void __init stx7111_configure_ssc(struct plat_ssc_data *data)
 		if(capability & SSC_UNCONFIGURED)
 			continue;
 
+		if (capability & SSC_I2C_CLK_UNIDIR)
+			ssc_pio->clk_unidir = 1;
+
 		switch (i) {
 		case 0:
 			/* spi_boot_not_comm = 0 */
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx7141.c b/arch/sh/kernel/cpu/sh4/setup-stx7141.c
index efab94d..90c1a13 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx7141.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx7141.c
@@ -472,6 +472,8 @@ void __init stx7141_configure_ssc(struct plat_ssc_data *data)
 		} else {
 			stssc_devices[i].name = i2c_st;
 			stssc_devices[i].id = num_i2c++;
+			if (capability & SSC_I2C_CLK_UNIDIR)
+				ssc_pio->clk_unidir = 1;
 		}
 
 		platform_device_register(&stssc_devices[i]);
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx7200.c b/arch/sh/kernel/cpu/sh4/setup-stx7200.c
index 4ea8b1e..e90cc4a 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx7200.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx7200.c
@@ -573,6 +573,8 @@ void __init stx7200_configure_ssc(struct plat_ssc_data *data)
 			stssc_devices[i].name = i2c_st;
 			sysconf_write(ssc_sc, 0);
 			stssc_devices[i].id = num_i2c++;
+			if (capability & SSC_I2C_CLK_UNIDIR)
+				ssc_pio->clk_unidir = 1;
 		}
 		platform_device_register(&stssc_devices[i]);
         }
diff --git a/drivers/i2c/busses/i2c-stm.c b/drivers/i2c/busses/i2c-stm.c
index 4b4a9f6..1d2c1ca 100644
--- a/drivers/i2c/busses/i2c-stm.c
+++ b/drivers/i2c/busses/i2c-stm.c
@@ -29,10 +29,29 @@
  *   + Add delay after stop to ensure I2C tBUF satisfied
  *   + Clear SSC status after reset
  *   + Reorder TX & I2C config register pokes in prepare to read phase
+ * Version 2.5 (24th Oct 2008)  Carl Shaw <carl.shaw@st.com>
+ *   + Rewrite START state - in case of write it now preloads TX FIFO
+ *                           and it is also shared for REPSTART address
+ *   + Change RX prepare - checks for NACK, reads address and then falls
+ *                         through to read state
+ *   + Change RX state - Use TEEN interrupt to reduce unnecessary interrupt
+ *                       loading.  Previously, RIR was used which generated
+ *                       an interrupt per byte
+ *   + Change TX state - correctly unload RX FIFO (using both FIFO status
+ *                       AND RIR bit)
+ *                     - use TEEN interrupt rather than TIR
+ *   + Change repstart address - just call START state but suppress STARTG
+ *   + Only use PIO recovery as last-ditch effort
+ *   + Fix retry method
+ *   + Add auto retry in case of arbitration problem
+ *   + Allow a PIO mode for clock of push-pull rather than BIDIR.  This
+ *     can help with spurious noise glitches on the SCK line and in the
+ *     case where SCK rise times are marginal due to capacitance on the
+ *     bus.
  *
  * --------------------------------------------------------------------
  *
- *  Copyright (C) 2006, 2007, 2008 : STMicroelectronics
+ *  Copyright (C) 2006 - 2008 STMicroelectronics
  *  Author: Francesco Virlinzi     <francesco.virlinzi@st.com>
  *
  * May be copied or modified under the terms of the GNU General Public
@@ -56,86 +75,69 @@
 #include "./i2c-stm.h"
 #include <linux/stm/stssc.h>
 
-#undef dgb_print
+#undef dbg_print
 
 #ifdef  CONFIG_I2C_DEBUG_BUS
-#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#define dbg_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
 #else
-#define dgb_print(fmt, args...)
+#define dbg_print(fmt, args...)
 #endif
 
-#undef dgb_print2
+#undef dbg_print2
 #ifdef  CONFIG_I2C_DEBUG_ALGO
-#define dgb_print2(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
+#define dbg_print2(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)
 #else
-#define dgb_print2(fmt, args...)
+#define dbg_print2(fmt, args...)
 #endif
 
 /* --- Defines for I2C --- */
 /* These values WILL produce physical clocks which are slower */
-/* Especially if hardware glith suppression is enabled        */
+/* Especially if hardware glitch suppression is enabled       */
 /* They should probably be made board dependent?              */
-#define I2C_RATE_NORMAL                 100000
+#define I2C_RATE_NORMAL			100000
 #define I2C_RATE_FASTMODE		400000
 
-
 #define NANOSEC_PER_SEC			1000000000
 
 /* Standard I2C timings */
 #define REP_START_HOLD_TIME_NORMAL	4000
-#define REP_START_HOLD_TIME_FAST	 600
 #define START_HOLD_TIME_NORMAL		4000
-#define START_HOLD_TIME_FAST		 600
 #define REP_START_SETUP_TIME_NORMAL	4700
-#define REP_START_SETUP_TIME_FAST	 600
 #define DATA_SETUP_TIME_NORMAL		 250
-#define DATA_SETUP_TIME_FAST		 100
 #define STOP_SETUP_TIME_NORMAL		4000
-#define STOP_SETUP_TIME_FAST		 600
 #define BUS_FREE_TIME_NORMAL		4700
-#define BUS_FREE_TIME_FAST		1300
 
-/* These values come from hw boys... */
-/*
-#define REP_START_HOLD_TIME_NORMAL	4000
-#define REP_START_HOLD_TIME_FAST	6500
-#define START_HOLD_TIME_NORMAL		4500
-#define START_HOLD_TIME_FAST		800
-#define REP_START_SETUP_TIME_NORMAL	4700
-#define REP_START_SETUP_TIME_FAST	800
-#define DATA_SETUP_TIME_NORMAL		300
-#define DATA_SETUP_TIME_FAST		300
-#define STOP_SETUP_TIME_NORMAL		4200
-#define STOP_SETUP_TIME_FAST		800
-#define BUS_FREE_TIME_NORMAL		5700
-#define BUS_FREE_TIME_FAST		1500
-*/
+#define REP_START_HOLD_TIME_FAST	 600
+#define START_HOLD_TIME_FAST		 600
+#define REP_START_SETUP_TIME_FAST	 600
+#define DATA_SETUP_TIME_FAST		 100
+#define STOP_SETUP_TIME_FAST		 600
+#define BUS_FREE_TIME_FAST		1300
 
 /* Define for glitch suppression support */
 #ifdef CONFIG_I2C_STM_GLITCH_SUPPORT
-  #if CONFIG_GLITCH_CLK_WIDTH > 0
-    #define GLITCH_WIDTH_CLOCK			CONFIG_GLITCH_CLK_WIDTH
-  #else
-    #define GLITCH_WIDTH_CLOCK			500 /* in nanosecs */
-  #endif
-  #if CONFIG_GLITCH_DATA_WIDTH > 0
-    #define GLITCH_WIDTH_DATA			CONFIG_GLITCH_DATA_WIDTH
-  #else
-    #define GLITCH_WIDTH_DATA			500 /* in nanosecs */
-  #endif
+#if CONFIG_GLITCH_CLK_WIDTH > 0
+#define GLITCH_WIDTH_CLOCK			CONFIG_GLITCH_CLK_WIDTH
+#else
+#define GLITCH_WIDTH_CLOCK			500	/* in nanosecs */
+#endif
+#if CONFIG_GLITCH_DATA_WIDTH > 0
+#define GLITCH_WIDTH_DATA			CONFIG_GLITCH_DATA_WIDTH
+#else
+#define GLITCH_WIDTH_DATA			500	/* in nanosecs */
+#endif
 #else
-    #define GLITCH_WIDTH_DATA			0
-    #define GLITCH_WIDTH_CLOCK			0
+#define GLITCH_WIDTH_DATA			0
+#define GLITCH_WIDTH_CLOCK			0
 #endif
 
 #ifdef CONFIG_I2C_STM_HW_GLITCH
-  #if CONFIG_HW_GLITCH_WIDTH > 0
-    #define HW_GLITCH_WIDTH			CONFIG_HW_GLITCH_WIDTH
-  #else
-    #define HW_GLITCH_WIDTH			1 /* in microseconds */
-  #endif
+#if CONFIG_HW_GLITCH_WIDTH > 0
+#define HW_GLITCH_WIDTH			CONFIG_HW_GLITCH_WIDTH
+#else
+#define HW_GLITCH_WIDTH			1	/* in microseconds */
+#endif
 #endif
-
 
 /* To manage normal vs fast mode */
 #define IIC_STM_CONFIG_SPEED_MASK          0x1
@@ -157,11 +159,19 @@ typedef enum _iic_state_machine_e {
 	IIC_FSM_ABORT
 } iic_state_machine_e;
 
+#ifdef CONFIG_I2C_DEBUG_ALGO
+char *statename[] =
+    { "VOID", "PREPARE", "START", "DATA_WRITE", "PREPARE_2_READ",
+	"DATA_READ", "STOP", "COMPLETE", "REPSTART", "REPSTART_ADDR", "ABORT"
+};
+#endif
+
 typedef enum _iic_fsm_error_e {
 	IIC_E_NO_ERROR = 0x0,
 	IIC_E_RUNNING = 0x1,
 	IIC_E_NOTACK = 0x2,
-	IIC_E_ARBL = 0x4
+	IIC_E_ARBL = 0x4,
+	IIC_E_BUSY = 0x8
 } iic_fsm_error_e;
 
 /*
@@ -176,8 +186,8 @@ struct iic_transaction {
 	struct i2c_msg *msgs_queue;
 	int attempt;
 	int queue_length;
-	int current_msg;		/* the message on going */
-	int idx_current_msg;		/* the byte in the message */
+	int current_msg;	/* the message on going */
+	int idx_current_msg;	/* the byte in the message */
 	iic_fsm_error_e status_error;
 	int waitcondition;
 };
@@ -194,14 +204,8 @@ struct iic_ssc {
 #define jump_on_fsm_start(x)	{ (x)->state = IIC_FSM_START;	\
 				goto be_fsm_start;	}
 
-#define jump_on_fsm_repstart(x)	{ (x)->state = IIC_FSM_REPSTART; \
-                                goto be_fsm_repstart;	}
-
-#define jump_on_fsm_complete(x)	{ (x)->state = IIC_FSM_COMPLETE; \
-				goto be_fsm_complete;	}
-
-#define jump_on_fsm_stop(x)	{ (x)->state = IIC_FSM_STOP;	\
-                                  goto be_fsm_stop;	}
+#define jump_on_fsm_stop(x)	do { (x)->state = IIC_FSM_STOP;    \
+				goto be_fsm_stop; } while (0)
 
 #define jump_on_fsm_abort(x)	{ (x)->state = IIC_FSM_ABORT;    \
                                   goto be_fsm_abort;	}
@@ -216,25 +220,26 @@ struct iic_ssc {
 
 #define clear_ready_fastmode(adap) ((adap)->config &= ~IIC_STM_READY_SPEED_FAST)
 
-static void iic_stm_setup_timing(struct iic_ssc *adap,unsigned long rate);
+static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long rate);
 
 static irqreturn_t iic_state_machine(int this_irq, void *data)
 {
 	struct iic_ssc *adap = (struct iic_ssc *)data;
 	struct iic_transaction *trsc = adap->trns;
-	unsigned short status;
-	short tx_fifo_status;
-	unsigned int idx, previntmask;
+	unsigned int status;
+	unsigned int idx, previntmask, lim, intflags, conflags = 0;
+#ifdef CONFIG_I2C_DEBUG_ALGO
+	unsigned int cw;
+#endif
 	unsigned short address;
 	struct i2c_msg *pmsg;
 	char fast_mode;
 	union {
 		char bytes[2];
-		short word;
+		unsigned short word;
 	} tmp;
-	int tmp2=0;
-
-	dgb_print2("\n");
+	unsigned short txbuff[SSC_TXFIFO_SIZE];
+	unsigned int txbuffcount;
 
 	fast_mode = check_fastmode(adap);
 	pmsg = trsc->msgs_queue + trsc->current_msg;
@@ -244,256 +249,311 @@ static irqreturn_t iic_state_machine(int this_irq, void *data)
 	ssc_store32(adap, SSC_IEN, 0);
 
 	status = ssc_load32(adap, SSC_STA);
-
-	trsc->state = trsc->next_state;
+	dbg_print2("ISR status = 0x%08x\n", status);
 
 	/* Slave mode detection - this should never happen as we don't support multi-master */
-	if ( trsc->state > IIC_FSM_START &&
-	     ((status & SSC_STA_ARBL) || !(ssc_load32(adap, SSC_CTL) & SSC_CTL_MS)) ){
-		dgb_print2("In SLAVE mode (state %d, status %08x)!\n", trsc->state, status);
+	if (trsc->state > IIC_FSM_START && ((status & SSC_STA_ARBL)
+					    || !(ssc_load32(adap, SSC_CTL) &
+						 SSC_CTL_MS))) {
+		dbg_print2("SLAVE mode (state %d, status %08x)\n",
+			   trsc->state, status);
+		dbg_print2(" Message [%d of %d] is %s address 0x%02x bus %d\n",
+			   trsc->current_msg + 1, trsc->queue_length,
+			   (pmsg->flags & I2C_M_RD) ? "READ from" : "WRITE to",
+			   pmsg->addr, adap->adapter.nr);
+		dbg_print2
+		    ("   data is %d bytes, currently at %d, last 0x%02x\n",
+		     pmsg->len, trsc->idx_current_msg,
+		     (trsc->idx_current_msg >
+		      0) ? pmsg->buf[trsc->idx_current_msg - 1] : 0);
+		dbg_print2("Prev State: %s Changing to state: %s \n",
+			   statename[trsc->state], statename[trsc->next_state]);
+
+		dbg_print2
+		    ("Status: 0x%08x SSC_IEN 0x%08x "
+			"SSC_CTL 0x%08x SSC_I2C 0x%08x\n",
+		     status, previntmask, ssc_load32(adap, SSC_CTL),
+		     ssc_load32(adap, SSC_I2C));
+
 		trsc->status_error = IIC_E_ARBL;
-		ssc_store32(adap, SSC_TBUF, 0x1ff);
 		ssc_store32(adap, SSC_CLR, 0xdc0);
 		trsc->waitcondition = 0;
 		wake_up(&(adap->wait_queue));
 		return IRQ_HANDLED;
 	}
 
+	trsc->state = trsc->next_state;
+
 	switch (trsc->state) {
 	case IIC_FSM_PREPARE:
-		dgb_print2("-Prepare\n");
+		dbg_print2("-Prepare\n");
 		/*
 		 * check if the i2c timing register
 		 * of ssc are ready to use
 		 */
 		if ((check_fastmode(adap) && !check_ready_fastmode(adap)) ||
-		    (!check_fastmode(adap) && check_ready_fastmode(adap)) )
+		    (!check_fastmode(adap) && check_ready_fastmode(adap)))
 			iic_stm_setup_timing(adap,
-				clk_get_rate(clk_get(NULL,"comms_clk")));
-		jump_on_fsm_start(trsc);
-		break;
+					     clk_get_rate(clk_get
+							  (NULL, "comms_clk")));
+
+		trsc->state = IIC_FSM_START;
+		conflags = SSC_I2C_STRTG;
 
-	case IIC_FSM_START:
-	      be_fsm_start:
-		dgb_print2("-Start address 0x%x\n", pmsg->addr);
-		/* Reset SSC */
-		ssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |
-			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
 		ssc_store32(adap, SSC_CLR, 0xdc0);
+		trsc->start_state = IIC_FSM_START;
 
-		/* enable RX, TX FIFOs */
-		ssc_store32(adap, SSC_CTL,
-			    SSC_CTL_EN | SSC_CTL_MS |
+		/* Enable RX FIFO, enable clock stretch on TX empty */
+		ssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
 			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |
-			    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);
+			    SSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO);
 
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-			    (SSC_I2C_I2CFSMODE * fast_mode));
+		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);
 
-		trsc->start_state = IIC_FSM_START;
-		trsc->next_state  = IIC_FSM_DATA_WRITE;
+		/* NO break! */
+
+	case IIC_FSM_START:
+be_fsm_start:
+		dbg_print2("-Start address 0x%x\n", pmsg->addr);
+
+		trsc->idx_current_msg = 0;
 
 		address = (pmsg->addr << 2) | 0x1;
-		if (pmsg->flags & I2C_M_RD){
+		if (pmsg->flags & I2C_M_RD) {
+			dbg_print2(" Reading %d bytes\n", pmsg->len);
+
 			address |= 0x2;
 			trsc->next_state = IIC_FSM_PREPARE_2_READ;
-		}
-		trsc->idx_current_msg = 0;
+			intflags =
+			    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;
 
-		status = ssc_load32(adap, SSC_STA);
-		if (status & SSC_STA_BUSY){
-			dgb_print2("    bus BUSY!\n");
-			trsc->waitcondition = 0; /* to not sleep */
-			trsc->status_error = IIC_E_RUNNING;	/* to raise the error */
-			return -1;
+			txbuff[0] = address;
+			txbuffcount = 1;
+		} else {
+			trsc->next_state = IIC_FSM_DATA_WRITE;
+			intflags =
+			    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;
+
+			dbg_print2("-Writing %d bytes\n", pmsg->len);
+			txbuff[0] = address;
+			txbuffcount = 1;
+			idx = SSC_TXFIFO_SIZE - 1;
+			dbg_print2(" TX FIFO %d empty slots\n", idx);
+
+			/* In the write case, we also preload the TX buffer
+			 * with some data to reduce the interrupt loading
+			 */
+			while (idx && trsc->idx_current_msg < pmsg->len) {
+				tmp.bytes[0] =
+				    pmsg->buf[trsc->idx_current_msg++];
+				txbuff[txbuffcount] = tmp.word << 1 | 0x1;
+				dbg_print2(" write 0x%02x\n", tmp.bytes[0]);
+				txbuffcount++;
+				idx--;
+			}
 		}
 
-		ssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);
-		ssc_store32(adap, SSC_TBUF, address);
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-			    SSC_I2C_STRTG | SSC_I2C_TXENB |
-			    (SSC_I2C_I2CFSMODE * fast_mode));
-		break;
+		/* drive SDA... */
+		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB);
+		for (idx = 0; idx < txbuffcount; idx++)
+			ssc_store32(adap, SSC_TBUF, txbuff[idx]);
+		ssc_store32(adap, SSC_IEN, intflags);
 
-	case IIC_FSM_PREPARE_2_READ:
-		/* Clear the RBUF */
-		while (ssc_load32(adap, SSC_RX_FSTAT)){
-			dgb_print2(".");
-			ssc_load32(adap, SSC_RBUF);
+		/* Check for bus busy.  This shouldn't happen but if the RX
+		 * FIFOs are not empty in the last transaction BEFORE the SSC
+		 * reset occurs, then we get a BUSY error here...
+		 */
+		if (trsc->start_state != IIC_FSM_REPSTART) {
+			if (ssc_load32(adap, SSC_STA) & SSC_STA_BUSY) {
+				dbg_print2(" bus BUSY!\n");
+				trsc->waitcondition = 0;
+				trsc->status_error = IIC_E_BUSY;
+			} else {
+				/* START! */
+				ssc_store32(adap, SSC_I2C,
+					    SSC_I2C_I2CM | SSC_I2C_TXENB |
+					    conflags);
+			}
 		}
 
-		if (ssc_load32(adap, SSC_TX_FSTAT)){
-			printk(KERN_ERR "i2c-stm: IIC_FSM_PREPARE_2_READ:TX FIFO NOT empty!\n");
-		}
+		break;
 
-		status = ssc_load32(adap, SSC_STA);
-		dgb_print2(" Prepare to Read... Status=0x%x\n", status);
+	case IIC_FSM_REPSTART_ADDR:
+		dbg_print2("-Rep Start addr 0x%x\n", pmsg->addr);
 
-		if (status & SSC_STA_NACK)
-			jump_on_fsm_abort(trsc);
+		/* Clear NACK */
+		ssc_store32(adap, SSC_CLR, 0xdc0);
 
-		trsc->next_state = IIC_FSM_DATA_READ;
+		trsc->start_state = IIC_FSM_REPSTART;
+		conflags = 0;
 
-		switch (pmsg->len) {
-		case 0: dgb_print2("Zero Read\n");
-			jump_on_fsm_stop(trsc);
+		jump_on_fsm_start(trsc);
 
-		case 1:
-			ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-				(SSC_I2C_I2CFSMODE * fast_mode));
-			ssc_store32(adap, SSC_CLR, 0xdc0);
-			ssc_store32(adap, SSC_TBUF, 0x1ff);
-			ssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);
-		   break;
-		default:
-			ssc_store32(adap, SSC_CLR, 0xdc0);
-			ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG |
-				(SSC_I2C_I2CFSMODE * fast_mode));
-			/* P.S.: in any case the last byte has to be
-			 *       managed in a different manner
-			 */
-			for ( idx = 0;  idx < SSC_TXFIFO_SIZE &&
-					idx < pmsg->len-1 ;  ++idx )
-				ssc_store32(adap, SSC_TBUF, 0x1ff);
-			ssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);
-		}
-		break;
+	case IIC_FSM_PREPARE_2_READ:
+		dbg_print2("-Prepare to Read...\n");
 
-	case IIC_FSM_DATA_READ:
-		/* Check for transmit problem */
-		if (!(status & SSC_STA_TE)){
-			ssc_store32(adap, SSC_IEN, previntmask);
-			break;
-		}
+		/* Read address */
+		ssc_load32(adap, SSC_RBUF);
 
-		/* Check for unexpected bus STOP condition */
-		if (status & SSC_STA_STOP){
-			ssc_store32(adap, SSC_CLR, 0xdc0);
+		/* Check for NACK */
+		if (status & SSC_STA_NACK) {
+			dbg_print2(" read: NACK detected\n");
 			jump_on_fsm_abort(trsc);
 		}
 
-		dgb_print2(" Data Read...Status=0x%x\n",status);
-		/* 1.0 Is it the last byte */
-		if (trsc->idx_current_msg == pmsg->len-1) {
+		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG);
+
+		trsc->next_state = IIC_FSM_DATA_READ;
+
+		/* NO break */
+
+	case IIC_FSM_DATA_READ:
+		dbg_print2("-Read\n");
+		/* Clear the RX buffer */
+		idx = (ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS);
+		if (!idx && (ssc_load32(adap, SSC_STA) & SSC_STA_RIR))
+			idx = SSC_RXFIFO_SIZE;
+
+		dbg_print2(" Rx %d bytes in FIFO...\n", idx);
+		while (idx && trsc->idx_current_msg < pmsg->len) {
 			tmp.word = ssc_load32(adap, SSC_RBUF);
 			tmp.word = tmp.word >> 1;
 			pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];
-			dgb_print2(" Rx Data %d-%c\n",tmp.bytes[0], tmp.bytes[0]);
-		} else {
-			/* 1.1 take the bytes from Rx fifo */
-			for (idx = 0 ;  idx < SSC_RXFIFO_SIZE &&
-				trsc->idx_current_msg < pmsg->len-1; ++idx ) {
-					tmp.word = ssc_load32(adap, SSC_RBUF);
-					tmp.word = tmp.word >> 1;
-					pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];
-					dgb_print2(" Rx Data %d-%c\n",tmp.bytes[0], tmp.bytes[0]);
-			}
+			dbg_print2(" Rx Data 0x%02x\n", tmp.bytes[0] & 0xff);
+			idx--;
 		}
 
-		/* 2. Do we finish? */
+		/* If end of RX, issue STOP or REPSTART */
 		if (trsc->idx_current_msg == pmsg->len) {
-			status &= ~SSC_STA_NACK;
 			jump_on_fsm_stop(trsc);
 		}
 
-		/* 3. Ask other 'idx' bytes in fifo mode
-		 *    but we want save the latest [pmsg->len-1]
-		 *    in any case...
-		 *    This will also clear any pending clockstretch
+		/*    Generate clock for another set of bytes.
+		 *    We have to process the last byte separately as we need to
+		 *    NOT generate an ACK
 		 */
-		for (idx=0; idx<SSC_TXFIFO_SIZE &&
-			   (trsc->idx_current_msg+idx)<pmsg->len-1; ++idx)
+		if (trsc->idx_current_msg == (pmsg->len - 1)) {
+			/* last byte - disable ACKG */
+			dbg_print2(" Rx last byte\n");
+			ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);
+			ssc_store32(adap, SSC_IEN,
+				    SSC_IEN_NACKEN | SSC_IEN_ARBLEN);
 			ssc_store32(adap, SSC_TBUF, 0x1ff);
+		} else {
+#ifdef CONFIG_I2C_DEBUG_ALGO
+			cw = 0;
+#endif
+			idx = SSC_TXFIFO_SIZE;
+			dbg_print2(" idx=%d status=0x%08x\n", idx,
+				   ssc_load32(adap, SSC_STA));
 
-		dgb_print2(" Asked %x bytes in fifo mode\n",idx);
-
-		ssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);
+			while (idx
+			       && (trsc->idx_current_msg +
+				   (SSC_TXFIFO_SIZE - idx)) < (pmsg->len - 1)) {
+				ssc_store32(adap, SSC_TBUF, 0x1ff);
+#ifdef CONFIG_I2C_DEBUG_ALGO
+				cw++;
+#endif
+				idx--;
+			}
+			dbg_print2("Clock writes: %d\n", cw);
 
-		/*Is the next byte the last byte? */
-		if (trsc->idx_current_msg == (pmsg->len - 1)) {
-			dgb_print2(" Asked the last byte\n");
-			ssc_store32(adap, SSC_CLR, 0xdc0);
-			ssc_store32(adap, SSC_TBUF, 0x1ff);
-			ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-					    (SSC_I2C_I2CFSMODE * fast_mode) );
-			ssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);
+			/* only take one interrupt when transmit FIFO empty! */
+			ssc_store32(adap, SSC_IEN,
+				    SSC_IEN_ARBLEN | SSC_IEN_TEEN);
 		}
+
 		break;
 
 	case IIC_FSM_DATA_WRITE:
-		/* Check for unexpected bus STOP condition */
-		if (status & SSC_STA_STOP){
-			ssc_store32(adap, SSC_CLR, 0xdc0);
-			jump_on_fsm_abort(trsc);
-		}
+		dbg_print2("-Write\n");
+		/* Clear RX data from FIFO */
+
+		/* It is not clear from the SSC4 datasheet, but the RX_FSTAT
+		 * register does not tell the whole story...  if RIR is set in
+		 * the STATUS reg then we need to read 8 words.  RX_FSTAT only
+		 * notifies us of at most 7 words - hence the extra check below
+		 */
+
+		lim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;
+		if (!lim && (status & SSC_STA_RIR))
+			lim = 8;
 
-		/* just to clear some bits in the STATUS register */
-		while (ssc_load32(adap, SSC_RX_FSTAT))
+		dbg_print2(" clearing %d RX words\n", lim);
+		for (idx = 0; idx < lim; idx++)
 			ssc_load32(adap, SSC_RBUF);
-/*
- * Be careful!!!!
- * Here I don't have to use 0xdc0 for
- * the SSC_CLR register
- */
+
+		/* Clear status bits EXCEPT NACK */
 		ssc_store32(adap, SSC_CLR, 0x9c0);
 
+		/* Check for NACK */
 		status = ssc_load32(adap, SSC_STA);
-		if (status & SSC_STA_NACK)
+		dbg_print2("write: status = 0x%08x\n", status);
+		if (status & SSC_STA_NACK) {
+			dbg_print2(" NACK detected\n");
 			jump_on_fsm_abort(trsc);
-
-		tx_fifo_status = ssc_load32(adap,SSC_TX_FSTAT);
-		if ( tx_fifo_status ) {
-			dgb_print2(" Fifo not empty\n");
-			ssc_store32(adap, SSC_IEN, previntmask);
-			break;
 		}
 
-		if (trsc->idx_current_msg == pmsg->len || !(pmsg->len))
+		/* If end of TX, issue STOP or REPSTART */
+		if (trsc->idx_current_msg == pmsg->len)
 			jump_on_fsm_stop(trsc);
 
-		dgb_print2(" Data Write...Status=0x%x 0x%x-%c\n", status,
-			  pmsg->buf[trsc->idx_current_msg],
-			  pmsg->buf[trsc->idx_current_msg]);
-
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |
-			    (SSC_I2C_I2CFSMODE * fast_mode));
-
 		trsc->next_state = IIC_FSM_DATA_WRITE;
-		ssc_store32(adap, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);
 
-		for (; tx_fifo_status < SSC_TXFIFO_SIZE &&
-			trsc->idx_current_msg < pmsg->len ;++tx_fifo_status )
-		{
+		/* Interrupt when TX buffer empty */
+		ssc_store32(adap, SSC_IEN,
+			    SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);
+
+		idx = SSC_TXFIFO_SIZE;
+		while (idx && trsc->idx_current_msg < pmsg->len) {
 			tmp.bytes[0] = pmsg->buf[trsc->idx_current_msg++];
 			ssc_store32(adap, SSC_TBUF, tmp.word << 1 | 0x1);
+			dbg_print2(" Write 0x%02x\n", tmp.bytes[0]);
+			idx--;
 		}
+
 		break;
 
 	case IIC_FSM_ABORT:
 	      be_fsm_abort:
-		dgb_print2(" Abort\n");
+		dbg_print2("Abort - issuing STOP\n");
 		trsc->status_error |= IIC_E_NOTACK;
-		/* Don't ADD the break */
 
-	case IIC_FSM_STOP:
-	      be_fsm_stop:
-		if (!(status & SSC_STA_NACK) &&
-		    (++trsc->current_msg < trsc->queue_length)) {
-			jump_on_fsm_repstart(trsc);
-		}
-		dgb_print2(" Stop\n");
 		ssc_store32(adap, SSC_CLR, 0xdc0);
 		trsc->next_state = IIC_FSM_COMPLETE;
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-			    SSC_I2C_TXENB | SSC_I2C_STOPG |
-			    (SSC_I2C_I2CFSMODE * fast_mode));
+
 		ssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);
+		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_STOPG);
+		break;
+
+	case IIC_FSM_STOP:
+be_fsm_stop:
+		dbg_print2("-Stop\n");
+
+		if (++trsc->current_msg < trsc->queue_length) {
+			/* repstart */
+			dbg_print2(" STOP - REPSTART\n");
+			trsc->next_state = IIC_FSM_REPSTART_ADDR;
+			ssc_store32(adap, SSC_I2C,
+				    SSC_I2C_I2CM | SSC_I2C_TXENB |
+				    SSC_I2C_REPSTRTG);
+			ssc_store32(adap, SSC_IEN,
+				    SSC_IEN_REPSTRTEN | SSC_IEN_ARBLEN);
+		} else {
+			/* stop */
+			dbg_print2(" STOP - STOP\n");
+			trsc->next_state = IIC_FSM_COMPLETE;
+			ssc_store32(adap, SSC_I2C,
+				    SSC_I2C_I2CM | SSC_I2C_TXENB |
+				    SSC_I2C_STOPG);
+			ssc_store32(adap, SSC_IEN,
+				    SSC_IEN_STOPEN | SSC_IEN_ARBLEN);
+		}
+
 		break;
 
 	case IIC_FSM_COMPLETE:
-		/* be_fsm_complete: */
-		dgb_print2(" Complete\n");
-		udelay(5);
+		dbg_print2("-Complete\n");
 
 		if (!(trsc->status_error & IIC_E_NOTACK))
 			trsc->status_error = IIC_E_NO_ERROR;
@@ -502,40 +562,6 @@ static irqreturn_t iic_state_machine(int this_irq, void *data)
 		wake_up(&(adap->wait_queue));
 		break;
 
-	case IIC_FSM_REPSTART:
-	      be_fsm_repstart:
-		pmsg = trsc->msgs_queue + trsc->current_msg;
-		dgb_print2("-Rep Start (0x%x)\n",pmsg->addr);
-		trsc->start_state = IIC_FSM_REPSTART;
-		trsc->idx_current_msg = 0;
-		trsc->next_state = IIC_FSM_REPSTART_ADDR;
-		ssc_store32(adap, SSC_CLR, 0xdc0);
-		if(ssc_load32(adap,SSC_STA) & SSC_STA_REPSTRT)
-			tmp2=1;
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB
-			    | SSC_I2C_REPSTRTG | (SSC_I2C_I2CFSMODE *
-						  fast_mode));
-		if(tmp2) /* we was not able to clear the status bit */
-			udelay(5);
-		ssc_store32(adap, SSC_IEN, SSC_IEN_REPSTRTEN | SSC_IEN_ARBLEN);
-		break;
-
-	case IIC_FSM_REPSTART_ADDR:
-		dgb_print2("-Rep Start addr 0x%x\n", pmsg->addr);
-		/* Clear repstart bit */
-		ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB
-				  | (SSC_I2C_I2CFSMODE * fast_mode));
-
-		ssc_store32(adap, SSC_CLR, 0xdc0);
-		address = (pmsg->addr << 2) | 0x1;
-		trsc->next_state = IIC_FSM_DATA_WRITE;
-		if (pmsg->flags & I2C_M_RD) {
-			address |= 0x2;
-			trsc->next_state = IIC_FSM_PREPARE_2_READ;
-		}
-		ssc_store32(adap, SSC_TBUF, address);
-		ssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);
-		break;
 	default:
 		printk(KERN_ERR "i2c-stm: Error in the FSM\n");
 		;
@@ -544,7 +570,6 @@ static irqreturn_t iic_state_machine(int this_irq, void *data)
 	return IRQ_HANDLED;
 }
 
-
 /*
  * Wait for stop to be detected on bus
  */
@@ -552,30 +577,65 @@ static int iic_wait_stop_condition(struct iic_ssc *adap)
 {
 	unsigned int idx;
 
-	dgb_print("\n");
-	for ( idx = 0; idx < 5 ; ++idx ){
-		if (ssc_load32(adap,SSC_STA) & SSC_STA_STOP)
+	dbg_print("\n");
+	for (idx = 0; idx < 5; ++idx) {
+		if (ssc_load32(adap, SSC_STA) & SSC_STA_STOP)
 			return 1;
 		mdelay(2);
 	}
 
+	printk(KERN_ERR "*** iic_wait_stop_condition: TIMED OUT ***\n");
 	return 0;
 }
 
 /*
+ * Reset SSC bus
+ */
+static void iic_ssc_reset(struct iic_ssc *adap)
+{
+	unsigned int lim, status, idx;
+
+	/* Ensure RX buffer empty */
+	status = ssc_load32(adap, SSC_STA);
+	lim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;
+	if (!lim && (status & SSC_STA_RIR))
+		lim = 8;
+
+	for (idx = 0; idx < lim; idx++)
+		ssc_load32(adap, SSC_RBUF);
+
+	/* Reset SSC */
+	ssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |
+		    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
+
+	/* enable RX, TX FIFOs - clear SR bit */
+	ssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |
+		    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |
+		    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);
+}
+
+/*
  * Wait for bus to become free
  */
 static int iic_wait_free_bus(struct iic_ssc *adap)
 {
+	unsigned int reg = 0;
 	unsigned int idx;
 
-	dgb_print("\n");
-	for ( idx = 0; idx < 5 ; ++idx ) {
-		if (!(ssc_load32(adap,SSC_STA) & SSC_STA_BUSY) )
+	dbg_print("\n");
+
+	iic_ssc_reset(adap);
+
+	for (idx = 0; idx < 10; ++idx) {
+		reg = ssc_load32(adap, SSC_STA);
+		dbg_print("iic_wait_free_bus: status = 0x%08x\n", reg);
+		if (!(reg & SSC_STA_BUSY))
 			return 1;
 		mdelay(2);
 	}
 
+	printk(KERN_ERR "*** iic_wait_free_bus: TIMED OUT ***\n");
+
 	return 0;
 }
 
@@ -586,168 +646,267 @@ static void iic_pio_stop(struct iic_ssc *adap)
 {
 	int cnt = 0;
 
-	if(!(adap->pio_info)->clk)
-		return; /* ssc hard wired */
+	if (!(adap->pio_info)->clk)
+		return;		/* ssc hard wired */
 	printk(KERN_WARNING "i2c-stm: doing PIO stop!\n");
 
 	/* Send STOP */
 	stpio_set_pin((adap->pio_info)->clk, 0);
 	stpio_set_pin((adap->pio_info)->sdout, 0);
-	stpio_configure_pin((adap->pio_info)->clk, STPIO_BIDIR);
+	stpio_configure_pin((adap->pio_info)->clk, STPIO_OUT);
 	stpio_configure_pin((adap->pio_info)->sdout, STPIO_BIDIR);
 	udelay(20);
 	stpio_set_pin((adap->pio_info)->clk, 1);
 	udelay(20);
 	stpio_set_pin((adap->pio_info)->sdout, 1);
 	udelay(30);
-	stpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);
+	if ((adap->pio_info)->clk_unidir)
+		stpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_OUT);
+	else
+		stpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);
 	stpio_configure_pin((adap->pio_info)->sdout, STPIO_ALT_BIDIR);
 
 	/* Reset SSC */
 	ssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |
-			    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
+		    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);
 	ssc_store32(adap, SSC_CLR, 0xdc0);
 
 	/* Make sure SSC thinks the bus is free before continuing */
-	while (cnt < 10 && (ssc_load32(adap,SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))){
+	while (cnt < 10
+	       && (ssc_load32(adap, SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))) {
 		mdelay(2);
-		cnt ++;
+		cnt++;
 	}
 
 	if (cnt == 10)
-		printk(KERN_ERR "i2c-stm:  Cannot recover bus.  Status: 0x%08x\n", ssc_load32(adap,SSC_STA));
+		printk(KERN_ERR
+		       "i2c-stm:  Cannot recover bus.  Status: 0x%08x\n",
+		       ssc_load32(adap, SSC_STA));
 }
 
 /*
  * Description: Prepares the controller for a transaction
  */
 static int iic_stm_xfer(struct i2c_adapter *i2c_adap,
-			     struct i2c_msg msgs[], int num)
+			struct i2c_msg msgs[], int num)
 {
 	unsigned int flag;
 	int result;
 	int timeout;
+#ifdef CONFIG_I2C_DEBUG_BUS
+	int i;
+#endif
 	struct iic_ssc *adap =
-			(struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);
+	    (struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);
 	struct iic_transaction transaction = {
-			.msgs_queue   = msgs,
-			.queue_length = num,
-			.current_msg  = 0x0,
-			.attempt      = 0x0,
-			.status_error = IIC_E_RUNNING,
-			.next_state   = IIC_FSM_PREPARE,
-			.waitcondition = 1,
-		};
+		.msgs_queue = msgs,
+		.queue_length = num,
+		.current_msg = 0x0,
+		.attempt = 0x0,
+		.status_error = IIC_E_RUNNING,
+		.next_state = IIC_FSM_PREPARE,
+		.waitcondition = 1,
+	};
 
-	dgb_print("\n");
+	dbg_print("\n");
 
 	adap->trns = &transaction;
 
+#ifdef CONFIG_I2C_DEBUG_BUS
+	for (i = 0; i < num; ++i) {
+		if (msgs[i].len == 0)
+			printk(KERN_INFO
+			       "[%d of %d] ZERO LENGTH TRANSACTION : "
+			       "%s addr 0x%02x len %d\n",
+			       i + 1, num,
+			       (msgs[i].
+				flags & I2C_M_RD) ? "read from " :
+				"write to ",
+				msgs[i].addr, msgs[i].len);
+		else
+			printk(KERN_INFO
+			       "[%d of %d] TRANSACTION : "
+			       "%s addr 0x%02x len %d\n",
+			       i + 1, num,
+			       (msgs[i].
+				flags & I2C_M_RD) ? "read from " :
+				"write to ",
+			       msgs[i].addr, msgs[i].len);
+	}
+#endif /* CONFIG_I2C_DEBUG_BUS */
+
 iic_xfer_retry:
 
-	/* Wait for bus to become free - do a forced PIO reset if necessary to */
-	/* recover the bus */
+	/* Wait for bus to become free - do a forced PIO reset if necessary to
+	 * recover the bus
+	 */
 	if (!iic_wait_free_bus(adap))
 		iic_pio_stop(adap);
 
 	iic_state_machine(0, adap);
 
 	timeout = wait_event_interruptible_timeout(adap->wait_queue,
-					(transaction.waitcondition==0),
-					i2c_adap->timeout *HZ );
+						   (transaction.waitcondition ==
+						    0), i2c_adap->timeout * HZ);
 
 	local_irq_save(flag);
 
 	result = transaction.current_msg;
 
-	if (unlikely(transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {
-		if ((transaction.status_error & IIC_E_NOTACK) &&
-			transaction.start_state == IIC_FSM_START &&
-			++transaction.attempt <= adap->adapter.retries){
+	if (unlikely
+	    (transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {
+		dbg_print2(KERN_ERR
+			   "xfer: ERROR status %d, timeout %d, attempt %d\n",
+			   transaction.status_error, timeout,
+			   transaction.attempt);
+
+		dbg_print2(KERN_ERR
+			   "Status: 0x%08x SSC_IEN 0x%08x "
+			   "SSC_CTL 0x%08x SSC_I2C 0x%08x\n",
+			   ssc_load32(adap, SSC_STA), ssc_load32(adap, SSC_IEN),
+			   ssc_load32(adap, SSC_CTL), ssc_load32(adap,
+								 SSC_I2C));
+
+		if (((transaction.status_error & IIC_E_NOTACK)
+		     && transaction.start_state == IIC_FSM_START)
+		    || (transaction.status_error & IIC_E_BUSY)) {
+			if (++transaction.attempt <= adap->adapter.retries) {
+				dbg_print2("RETRYING operation\n");
 				/* error on the address - automatically retry */
 				/* this used to be done in the FSM complete but it was not safe */
 				/* there as we need to wait for the bus to not be busy before */
 				/* doing another transaction */
-				printk(KERN_ERR "i2c-stm: error on address.  auto retry %d\n", transaction.attempt);
 				transaction.status_error = 0;
+				transaction.next_state = IIC_FSM_START;
+				transaction.waitcondition = 1;
 				local_irq_restore(flag);
 				goto iic_xfer_retry;
-		} else if (transaction.status_error == IIC_E_ARBL){
+			} else {
+				local_irq_restore(flag);
+				if (transaction.status_error & IIC_E_NOTACK) {
+					dbg_print("Error: Slave NACK\n");
+					result = -EREMOTEIO;
+				} else {
+					dbg_print("Error: Bus BUSY\n");
+					result = -EBUSY;
+				}
+			}
+		} else if (transaction.status_error == IIC_E_ARBL
+			   || (ssc_load32(adap, SSC_CTL) & SSC_CTL_MS) == 0) {
 			/* Arbitration error */
 			printk(KERN_ERR "i2c-stm: arbitration error\n");
+
 			ssc_store32(adap, SSC_CLR, SSC_CLR_SSCARBL);
-			ssc_store32(adap, SSC_CTL, ssc_load32(adap, SSC_CTL) | SSC_CTL_MS);
+			ssc_store32(adap, SSC_CTL,
+				    ssc_load32(adap, SSC_CTL) | SSC_CTL_MS);
+			transaction.status_error = 0;
+			transaction.next_state = IIC_FSM_START;
+			transaction.waitcondition = 1;
 			local_irq_restore(flag);
 
-			/* Manually issue stop condition on the bus */
-			iic_pio_stop(adap);
+			if (!iic_wait_free_bus(adap)) {
+				/* Last ditch effort */
+				iic_pio_stop(adap);
+			}
+
+			if (++transaction.attempt <= adap->adapter.retries) {
+				dbg_print2("RETRYING operation\n");
+				goto iic_xfer_retry;
+			}
 		} else {
 			/* There was another problem */
-			if(timeout<=0){
+			if (timeout <= 0) {
 				/* There was a timeout or signal.
 				   - disable the interrupt
 				   - generate a stop condition on the bus
 				   all this task are done without interrupt....
 				 */
+				dbg_print
+				    ("xfer: Wait cnd err %d, status error %d\n",
+				     timeout, transaction.status_error);
 				ssc_store32(adap, SSC_IEN, 0x0);
-				ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |
-					    SSC_I2C_STOPG | SSC_I2C_TXENB |
-					    (SSC_I2C_I2CFSMODE * check_fastmode(adap)));
-				/* wait until the ssc detects a Stop condition on the bus */
-				/* but before we do that we enable all the interrupts     */
-				local_irq_restore(flag);
 
-				if (!iic_wait_stop_condition(adap)){
-					printk(KERN_ERR "i2c-stm: Error.  Manually stopping transaction.\n");
-					iic_pio_stop(adap);
+				/* Check if bus free */
+				if (!iic_wait_free_bus(adap)) {
+					/* No - generate stop condition */
+					ssc_store32(adap, SSC_I2C,
+						    SSC_I2C_I2CM | SSC_I2C_STOPG
+						    | SSC_I2C_TXENB);
+
+					local_irq_restore(flag);
+
+					if (!iic_wait_stop_condition(adap)) {
+						/* Reset SSC */
+						ssc_store32(adap, SSC_CTL,
+							    SSC_CTL_SR |
+							    SSC_CTL_EN |
+							    SSC_CTL_MS |
+							    SSC_CTL_PO |
+							    SSC_CTL_PH |
+							    SSC_CTL_HB | 0x8);
+						ssc_store32(adap, SSC_CLR,
+							    0xdc0);
+
+						if (!iic_wait_free_bus(adap)) {
+							/* Last ditch effort */
+							iic_pio_stop(adap);
+						}
+					}
+				} else {
+					local_irq_restore(flag);
 				}
 			} else
 				local_irq_restore(flag);
 
-			if (!timeout){
-				printk(KERN_ERR
-				       "i2c-stm: Error timeout in the finite state machine\n");
+			if (!timeout) {
+				dbg_print
+				    ("i2c-stm: Error timeout in the FSM\n");
 				result = -ETIMEDOUT;
 			} else if (timeout < 0) {
-				dgb_print("i2c-stm: interrupt or error in wait event\n");
+				dbg_print
+				    ("i2c-stm: wait event interrupt/error\n");
 				result = timeout;
-			} else
+			} else {
+				dbg_print("i2c-stm: slave failed to respond\n");
 				result = -EREMOTEIO;
+			}
 		}
 	} else
 		local_irq_restore(flag);
 
+#ifdef CONFIG_I2C_DEBUG_BUS
+	printk(KERN_INFO "i2c-stm: i2c_stm_xfer returned %d\n", result);
+#endif
 	return result;
 }
 
 #ifdef  CONFIG_I2C_DEBUG_BUS
 static void iic_stm_timing_trace(struct iic_ssc *adap)
 {
-	dgb_print("SSC_BRG  %d\n",ssc_load32(adap, SSC_BRG));
-	dgb_print("SSC_REP_START_HOLD %d\n",
+	dbg_print("SSC_BRG  %d\n", ssc_load32(adap, SSC_BRG));
+	dbg_print("SSC_REP_START_HOLD %d\n",
 		  ssc_load32(adap, SSC_REP_START_HOLD));
-	dgb_print("SSC_REP_START_SETUP %d\n",
+	dbg_print("SSC_REP_START_SETUP %d\n",
 		  ssc_load32(adap, SSC_REP_START_SETUP));
-	dgb_print("SSC_START_HOLD %d\n", ssc_load32(adap, SSC_START_HOLD));
-	dgb_print("SSC_DATA_SETUP %d\n", ssc_load32(adap, SSC_DATA_SETUP));
-	dgb_print("SSC_STOP_SETUP %d\n", ssc_load32(adap, SSC_STOP_SETUP));
-	dgb_print("SSC_BUS_FREE %d\n", ssc_load32(adap, SSC_BUS_FREE));
-	dgb_print("SSC_PRE_SCALER_BRG %d\n",
+	dbg_print("SSC_START_HOLD %d\n", ssc_load32(adap, SSC_START_HOLD));
+	dbg_print("SSC_DATA_SETUP %d\n", ssc_load32(adap, SSC_DATA_SETUP));
+	dbg_print("SSC_STOP_SETUP %d\n", ssc_load32(adap, SSC_STOP_SETUP));
+	dbg_print("SSC_BUS_FREE %d\n", ssc_load32(adap, SSC_BUS_FREE));
+	dbg_print("SSC_PRE_SCALER_BRG %d\n",
 		  ssc_load32(adap, SSC_PRE_SCALER_BRG));
-	dgb_print("SSC_NOISE_SUPP_WIDTH %d\n",
-			ssc_load32(adap, SSC_NOISE_SUPP_WIDTH));
-	dgb_print("SSC_PRSCALER %d\n",
-			ssc_load32(adap, SSC_PRSCALER));
-	dgb_print("SSC_NOISE_SUPP_WIDTH_DATAOUT %d\n",
-			ssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));
-	dgb_print("SSC_PRSCALER_DATAOUT %d\n",
-			ssc_load32(adap, SSC_PRSCALER_DATAOUT));
+	dbg_print("SSC_NOISE_SUPP_WIDTH %d\n",
+		  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH));
+	dbg_print("SSC_PRSCALER %d\n", ssc_load32(adap, SSC_PRSCALER));
+	dbg_print("SSC_NOISE_SUPP_WIDTH_DATAOUT %d\n",
+		  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));
+	dbg_print("SSC_PRSCALER_DATAOUT %d\n",
+		  ssc_load32(adap, SSC_PRSCALER_DATAOUT));
 }
 #endif
 
 static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)
 {
-	unsigned long  iic_baudrate;
+	unsigned long iic_baudrate;
 	unsigned short iic_rep_start_hold;
 	unsigned short iic_start_hold;
 	unsigned short iic_rep_start_setup;
@@ -758,67 +917,99 @@ static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)
 #ifdef CONFIG_I2C_STM_HW_GLITCH
 	unsigned short iic_glitch_width;
 	unsigned short iic_glitch_width_dataout;
-	unsigned char  iic_prescaler;
+	unsigned char iic_prescaler;
 	unsigned short iic_prescaler_dataout;
 #endif
-	unsigned long  ns_per_clk;
+	unsigned long ns_per_clk;
 
-	dgb_print("Assuming %d MHz for the Timing Setup\n",
-		  clock / 1000000);
+	dbg_print("Assuming %lu MHz for the Timing Setup\n", clock / 1000000);
 
-	clock += 500000; /* +0.5 Mhz for rounding */
+	clock += 500000;	/* +0.5 Mhz for rounding */
 	ns_per_clk = NANOSEC_PER_SEC / clock;
 
 	if (check_fastmode(adap)) {
 		set_ready_fastmode(adap);
 		iic_baudrate = clock / (2 * I2C_RATE_FASTMODE);
-		iic_rep_start_hold  =(REP_START_HOLD_TIME_FAST +GLITCH_WIDTH_DATA) /ns_per_clk;
-		iic_rep_start_setup =(REP_START_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;
-		if(GLITCH_WIDTH_DATA<200)
-			iic_start_hold =(START_HOLD_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;
+		iic_rep_start_hold =
+		    (REP_START_HOLD_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_rep_start_setup =
+		    (REP_START_SETUP_TIME_FAST +
+		     GLITCH_WIDTH_CLOCK) / ns_per_clk;
+		if (GLITCH_WIDTH_DATA < 200)
+			iic_start_hold =
+			    (START_HOLD_TIME_FAST +
+			     GLITCH_WIDTH_DATA) / ns_per_clk;
 		else
-			iic_start_hold =(5*GLITCH_WIDTH_DATA) /ns_per_clk;
-		iic_data_setup =(DATA_SETUP_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;
-		iic_stop_setup =(STOP_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;
-		iic_bus_free =(BUS_FREE_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;
+			iic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_data_setup =
+		    (DATA_SETUP_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_stop_setup =
+		    (STOP_SETUP_TIME_FAST + GLITCH_WIDTH_CLOCK) / ns_per_clk;
+		iic_bus_free =
+		    (BUS_FREE_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;
 	} else {
 		clear_ready_fastmode(adap);
-		iic_baudrate = clock  / (2 * I2C_RATE_NORMAL);
-		iic_rep_start_hold =( REP_START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;
-		iic_rep_start_setup =( REP_START_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;
-		if(GLITCH_WIDTH_DATA<1200)
-			iic_start_hold =( START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_baudrate = clock / (2 * I2C_RATE_NORMAL);
+		iic_rep_start_hold =
+		    (REP_START_HOLD_TIME_NORMAL +
+		     GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_rep_start_setup =
+		    (REP_START_SETUP_TIME_NORMAL +
+		     GLITCH_WIDTH_CLOCK) / ns_per_clk;
+		if (GLITCH_WIDTH_DATA < 1200)
+			iic_start_hold =
+			    (START_HOLD_TIME_NORMAL +
+			     GLITCH_WIDTH_DATA) / ns_per_clk;
 		else
-			iic_start_hold =( 5*GLITCH_WIDTH_DATA) / ns_per_clk;
-		iic_data_setup =( DATA_SETUP_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;
-		iic_stop_setup =( STOP_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;
-		iic_bus_free =( BUS_FREE_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;
+			iic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_data_setup =
+		    (DATA_SETUP_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;
+		iic_stop_setup =
+		    (STOP_SETUP_TIME_NORMAL + GLITCH_WIDTH_CLOCK) / ns_per_clk;
+		iic_bus_free =
+		    (BUS_FREE_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;
 	}
 
+	/* set baudrate */
+	ssc_store32(adap, SSC_BRG, iic_baudrate);
+	ssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);
+
+	/* enable I2C mode */
+	ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);
+
+	/* set other timings */
 	ssc_store32(adap, SSC_REP_START_HOLD, iic_rep_start_hold);
 	ssc_store32(adap, SSC_START_HOLD, iic_start_hold);
 	ssc_store32(adap, SSC_REP_START_SETUP, iic_rep_start_setup);
 	ssc_store32(adap, SSC_DATA_SETUP, iic_data_setup);
 	ssc_store32(adap, SSC_STOP_SETUP, iic_stop_setup);
 	ssc_store32(adap, SSC_BUS_FREE, iic_bus_free);
-	ssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);
 
 #ifdef CONFIG_I2C_STM_HW_GLITCH
 	/* See DDTS GNBvd40668 */
 	iic_prescaler = 1;
-	iic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000; /* width in uS */
+	iic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000;	/* in uS */
 	iic_glitch_width_dataout = 1;
 	iic_prescaler_dataout = clock / 10000000;
 
+/*  This should work, but causes lock-up after repstart
+    iic_prescaler = clock / 10000000;
+    iic_glitch_width = HW_GLITCH_WIDTH;
+    iic_glitch_width_dataout = 1;
+    iic_prescaler_dataout = clock / 10000000;
+    printk("*** iic_prescaler = %d *** \n", iic_prescaler);
+*/
+
 	ssc_store32(adap, SSC_PRSCALER, iic_prescaler);
 	ssc_store32(adap, SSC_NOISE_SUPP_WIDTH, iic_glitch_width);
-	ssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT, iic_glitch_width_dataout);
+	ssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT,
+		    iic_glitch_width_dataout);
 	ssc_store32(adap, SSC_PRSCALER_DATAOUT, iic_prescaler_dataout);
+#else
+	/* disable SSC glitch filter */
+	ssc_store32(adap, SSC_NOISE_SUPP_WIDTH, 0);
 #endif
 
-	ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);
-	ssc_store32(adap, SSC_BRG, iic_baudrate);
-
 #ifdef  CONFIG_I2C_DEBUG_BUS
 	iic_stm_timing_trace(adap);
 #endif
@@ -826,20 +1017,20 @@ static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)
 }
 
 static int iic_stm_control(struct i2c_adapter *adapter,
-				unsigned int cmd, unsigned long arg)
+			   unsigned int cmd, unsigned long arg)
 {
 	struct iic_ssc *iic_adap =
 	    container_of(adapter, struct iic_ssc, adapter);
 	switch (cmd) {
 	case I2C_STM_IOCTL_FAST:
-		dgb_print("ioctl fast 0x%x\n",arg);
+		dbg_print("ioctl fast 0x%lx\n", arg);
 		iic_adap->config &= ~IIC_STM_CONFIG_SPEED_MASK;
 		if (arg)
-			iic_adap->config |=
-			    IIC_STM_CONFIG_SPEED_FAST;
+			iic_adap->config |= IIC_STM_CONFIG_SPEED_FAST;
 		break;
 	default:
-		printk(KERN_WARNING" %s: i2c-ioctl not managed\n",__FUNCTION__);
+		printk(KERN_WARNING " %s: i2c-ioctl not managed\n",
+		       __FUNCTION__);
 	}
 	return 0;
 }
@@ -850,83 +1041,112 @@ static u32 iic_stm_func(struct i2c_adapter *adap)
 }
 
 static struct i2c_algorithm iic_stm_algo = {
-	.master_xfer   = iic_stm_xfer,
+	.master_xfer = iic_stm_xfer,
 	.functionality = iic_stm_func,
-	.algo_control  = iic_stm_control
+	.algo_control = iic_stm_control
 };
 
 static ssize_t iic_bus_show_fastmode(struct device *dev,
-				      struct device_attribute *attr, char *buf)
+				     struct device_attribute *attr, char *buf)
 {
-	struct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);
-	struct iic_ssc     *iic_stm = container_of(adapter,struct iic_ssc,adapter);
-	return sprintf(buf, "%u\n",check_fastmode(iic_stm));
+	struct i2c_adapter *adapter =
+	    container_of(dev, struct i2c_adapter, dev);
+	struct iic_ssc *iic_stm =
+	    container_of(adapter, struct iic_ssc, adapter);
+	return sprintf(buf, "%u\n", check_fastmode(iic_stm));
 }
 
-static ssize_t iic_bus_store_fastmode(struct device *dev,struct device_attribute *attr,
-			 const char *buf,size_t count)
+static ssize_t iic_bus_store_fastmode(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
 {
-	struct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);
+	struct i2c_adapter *adapter =
+	    container_of(dev, struct i2c_adapter, dev);
 	unsigned long val = simple_strtoul(buf, NULL, 10);
 
-	iic_stm_control(adapter,I2C_STM_IOCTL_FAST,val);
+	iic_stm_control(adapter, I2C_STM_IOCTL_FAST, val);
 
 	return count;
 }
 
 static DEVICE_ATTR(fastmode, S_IRUGO | S_IWUSR, iic_bus_show_fastmode,
-			iic_bus_store_fastmode);
+		   iic_bus_store_fastmode);
 
 static int __init iic_stm_probe(struct platform_device *pdev)
 {
 	struct ssc_pio_t *pio_info =
-			(struct ssc_pio_t *)pdev->dev.platform_data;
+	    (struct ssc_pio_t *)pdev->dev.platform_data;
 	struct iic_ssc *i2c_stm;
 	struct resource *res;
 
-	i2c_stm = devm_kzalloc(&pdev->dev,sizeof(struct iic_ssc), GFP_KERNEL);
+	i2c_stm = devm_kzalloc(&pdev->dev, sizeof(struct iic_ssc), GFP_KERNEL);
 
 	if (!i2c_stm)
 		return -ENOMEM;
 
-	if (!(res=platform_get_resource(pdev, IORESOURCE_MEM, 0)))
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
 		return -ENODEV;
-	if (!devm_request_mem_region(&pdev->dev, res->start, res->end - res->start, "i2c")){
-		printk(KERN_ERR "%s: Request mem 0x%x region not done\n",__FUNCTION__,res->start);
+
+	if (!devm_request_mem_region
+	    (&pdev->dev, res->start, res->end - res->start, "i2c")) {
+		printk(KERN_ERR "%s: Request mem 0x%x region not done\n",
+		       __FUNCTION__, res->start);
 		return -ENOMEM;
 	}
 	if (!(i2c_stm->base =
-		devm_ioremap_nocache(&pdev->dev, res->start, res->end - res->start))){
-		printk(KERN_ERR "%s: Request iomem 0x%x region not done\n",__FUNCTION__,
-			(unsigned int)res->start);
+	      devm_ioremap_nocache(&pdev->dev, res->start,
+				   res->end - res->start))) {
+		printk(KERN_ERR "%s: Request iomem 0x%x region not done\n",
+		       __FUNCTION__, (unsigned int)res->start);
 		return -ENOMEM;
 	}
-	if (!(res=platform_get_resource(pdev, IORESOURCE_IRQ, 0))){
-		printk(KERN_ERR "%s Request irq %d not done\n",__FUNCTION__,res->start);
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		printk(KERN_ERR "%s Request irq %d not done\n", __FUNCTION__,
+		       res->start);
 		return -ENODEV;
 	}
-	if(devm_request_irq(&pdev->dev, res->start, iic_state_machine,
-		IRQF_DISABLED, "i2c", i2c_stm)<0){
-		printk(KERN_ERR "%s: Request irq not done\n",__FUNCTION__);
+	if (devm_request_irq(&pdev->dev, res->start, iic_state_machine,
+			     IRQF_DISABLED, "i2c", i2c_stm) < 0) {
+		printk(KERN_ERR "%s: Request irq not done\n", __FUNCTION__);
 		return -ENODEV;
 	}
 
-	if(pio_info->pio[0].pio_port==0xff) /* this means it doesn't use GPIO */
+	/* Check if we use GPIO... */
+	if (pio_info->pio[0].pio_port == SSC_NO_PIO)
 		goto i2c_hard_wired;
 
-	pio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,
-					  pio_info->pio[0].pio_pin,
-				"I2C Clock", STPIO_ALT_BIDIR, 1);
-	if(!pio_info->clk){
-		printk(KERN_ERR "i2c-stm: %s: Failed to get clk pin allocation\n",__FUNCTION__);
+	if (pio_info->clk_unidir) {
+		/* Drive clock rather than using open collector.  Setting to
+		 * BIDIR can help if there are problems with SCK rise times.
+		 * It does mean, however, that slaves cannot clock stretch.
+		 */
+		pio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,
+						      pio_info->pio[0].pio_pin,
+						      "I2C Clock",
+						      STPIO_ALT_OUT, 1);
+	} else {
+		pio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,
+						      pio_info->pio[0].pio_pin,
+						      "I2C Clock",
+						      STPIO_ALT_BIDIR, 1);
+	}
+
+	if (!pio_info->clk) {
+		printk(KERN_ERR
+		       "i2c-stm: %s: Failed to get clk pin allocation\n",
+		       __FUNCTION__);
 		return -ENODEV;
 	}
 
 	pio_info->sdout = stpio_request_set_pin(pio_info->pio[1].pio_port,
-					    pio_info->pio[1].pio_pin,
-				"I2C Data", STPIO_ALT_BIDIR, 1);
-	if(!pio_info->sdout){
-		printk(KERN_ERR "%s: Faild to sda pin allocation\n",__FUNCTION__);
+						pio_info->pio[1].pio_pin,
+						"I2C Data", STPIO_ALT_BIDIR, 1);
+	if (!pio_info->sdout) {
+		printk(KERN_ERR "%s: Faild to sda pin allocation\n",
+		       __FUNCTION__);
 		return -ENODEV;
 	}
 
@@ -934,21 +1154,25 @@ i2c_hard_wired:
 	pdev->dev.driver_data = i2c_stm;
 	i2c_stm->adapter.id = I2C_HW_STM_SSC;
 	i2c_stm->adapter.timeout = 2;
-	i2c_stm->adapter.class   = I2C_CLASS_ALL;
-	sprintf(i2c_stm->adapter.name,"i2c-hw-%d",pdev->id);
+	i2c_stm->adapter.retries = 0;
+	i2c_stm->adapter.class = I2C_CLASS_ALL;
+	sprintf(i2c_stm->adapter.name, "i2c-hw-%d", pdev->id);
 	i2c_stm->adapter.nr = pdev->id;
 	i2c_stm->adapter.algo = &iic_stm_algo;
 	i2c_stm->adapter.dev.parent = &(pdev->dev);
-	iic_stm_setup_timing(i2c_stm,clk_get_rate(clk_get(NULL,"comms_clk")));
+	iic_stm_setup_timing(i2c_stm, clk_get_rate(clk_get(NULL, "comms_clk")));
 	init_waitqueue_head(&(i2c_stm->wait_queue));
 	i2c_stm->pio_info = pio_info;
 	if (i2c_add_numbered_adapter(&(i2c_stm->adapter)) < 0) {
 		printk(KERN_ERR
-		       "%s: The I2C Core refuses the i2c/stm adapter\n",__FUNCTION__);
+		       "%s: The I2C Core refuses the i2c/stm adapter\n",
+		       __FUNCTION__);
 		return -ENODEV;
 	} else {
-		if (device_create_file(&(i2c_stm->adapter.dev), &dev_attr_fastmode))
-			printk(KERN_ERR "i2c-stm: cannot create fastmode sysfs entry\n");
+		if (device_create_file
+		    (&(i2c_stm->adapter.dev), &dev_attr_fastmode))
+			printk(KERN_ERR
+			       "i2c-stm: cannot create fastmode sysfs entry\n");
 	}
 	return 0;
 
@@ -957,18 +1181,18 @@ i2c_hard_wired:
 static int iic_stm_remove(struct platform_device *pdev)
 {
 	struct resource *res;
-	struct iic_ssc *iic_stm = pdev->dev.driver_data ;
+	struct iic_ssc *iic_stm = pdev->dev.driver_data;
 	struct ssc_pio_t *pio_info =
-			(struct ssc_pio_t *)pdev->dev.platform_data;
+	    (struct ssc_pio_t *)pdev->dev.platform_data;
 
 	i2c_del_adapter(&iic_stm->adapter);
 	/* irq */
-	res=platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	devm_free_irq(&pdev->dev, res->start, iic_stm);
 	/* mem */
 	devm_iounmap(&pdev->dev, iic_stm->base);
 	/* pio */
-	if(pio_info->clk){
+	if (pio_info->clk) {
 		stpio_free_pin(pio_info->clk);
 		stpio_free_pin(pio_info->sdout);
 	}
@@ -978,17 +1202,17 @@ static int iic_stm_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int iic_stm_suspend(struct platform_device *pdev,pm_message_t state)
+static int iic_stm_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct iic_ssc *i2c_bus = pdev->dev.driver_data;
-	ssc_store32(i2c_bus, SSC_IEN,0);
-	ssc_store32(i2c_bus, SSC_CTL,0);
+	ssc_store32(i2c_bus, SSC_IEN, 0);
+	ssc_store32(i2c_bus, SSC_CTL, 0);
 	return 0;
 }
 static int iic_stm_resume(struct platform_device *pdev)
 {
-	struct iic_ssc *i2c_bus =pdev->dev.driver_data;
-	iic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL,"comms_clk")));
+	struct iic_ssc *i2c_bus = pdev->dev.driver_data;
+	iic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL, "comms_clk")));
 	return 0;
 }
 #else
@@ -997,15 +1221,14 @@ static int iic_stm_resume(struct platform_device *pdev)
 #endif
 
 static struct platform_driver i2c_stm_driver = {
-        .driver.name = "i2c_st",
-        .driver.owner = THIS_MODULE,
-        .probe = iic_stm_probe,
+	.driver.name = "i2c_st",
+	.driver.owner = THIS_MODULE,
+	.probe = iic_stm_probe,
 	.remove = iic_stm_remove,
 	.suspend = iic_stm_suspend,
-	.resume  = iic_stm_resume,
+	.resume = iic_stm_resume,
 };
 
-
 static int __init iic_stm_init(void)
 {
 	platform_driver_register(&i2c_stm_driver);
diff --git a/include/linux/stm/soc.h b/include/linux/stm/soc.h
index 51172e2..452544c 100644
--- a/include/linux/stm/soc.h
+++ b/include/linux/stm/soc.h
@@ -9,6 +9,7 @@ struct ssc_pio_t {
 		unsigned char pio_port;
 		unsigned char pio_pin;
 	} pio[3]; /* clk, in, out */
+	int clk_unidir;
 	struct stpio_pin* clk;
 	struct stpio_pin* sdout;
 	struct stpio_pin* sdin;
@@ -16,17 +17,21 @@ struct ssc_pio_t {
 	void (*chipselect)(void *spi, int is_on);
 };
 
-#define SSC_I2C_CAPABILITY  0x0
-#define SSC_SPI_CAPABILITY  0x1
-#define SSC_UNCONFIGURED    0x2
+#define SSC_I2C_CAPABILITY  0x00
+#define SSC_SPI_CAPABILITY  0x01
+#define SSC_UNCONFIGURED    0x02
+#define SSC_I2C_CLK_UNIDIR  0x04
 
-#define SSC_BITS_SIZE       0x2
+#define SSC_BITS_SIZE       0x03
 /*
  *   This macro could be used to build the capability field
  *   of struct plat_ssc_data for each SoC
  */
 #define ssc_capability(idx_ssc, cap)  \
-         ( (cap) & (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY | SSC_UNCONFIGURED) ) << ((idx_ssc)*SSC_BITS_SIZE)
+	(((cap) & \
+	 (SSC_I2C_CAPABILITY | SSC_SPI_CAPABILITY |\
+	  SSC_UNCONFIGURED | SSC_I2C_CLK_UNIDIR)) \
+	  << ((idx_ssc)*SSC_BITS_SIZE))
 
 #define ssc0_has(cap)  ssc_capability(0,cap)
 #define ssc1_has(cap)  ssc_capability(1,cap)
-- 
1.5.3.6

