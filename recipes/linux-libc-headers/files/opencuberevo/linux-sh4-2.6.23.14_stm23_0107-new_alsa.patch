ALSA drivers update for 0107 kernel, version 2.

- converters model & infrastructure introduced
- I2S to SPDIF converter implementation for STx710x
- FDMA transfer are longer than 1 word now, basing
  on request trigger value.
- basic support for STx7111 implemented (PCM & SPDIF
  player, no PCM reader)
- IEC60958 controls implemented in SPDIF player and
  I2S to SPDIF converter drivers
- IEC61937 controls implemented in SPDIF player driver
- added mute controls for internal DACs
- number of bug fixes

Signed-off-by: Pawel MOLL <pawel.moll@st.com>
---
diff --git a/arch/sh/boards/st/cb101/setup.c b/arch/sh/boards/st/cb101/setup.c
index 6b4e889..426b3ba 100644
--- a/arch/sh/boards/st/cb101/setup.c
+++ b/arch/sh/boards/st/cb101/setup.c
@@ -188,18 +188,10 @@ static struct platform_device *cb101_devices[] __initdata = {
 	&cb101_phy_device,
 };
 
-struct plat_audio_config left_justified_format = {
-	.pcm_format = PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED |
-			PLAT_STM_AUDIO__DATA_SIZE_24_BITS,
-	.oversampling = 256,
-};
-
 static int __init device_init(void)
 {
 	stx7200_configure_ssc(&ssc_private_info);
 	stx7200_configure_usb();
-	stx7200_configure_audio(&left_justified_format, NULL, NULL,
-			NULL, NULL, NULL);
 	stx7200_configure_ethernet(0, 0, 0, 0);
 	stx7200_configure_lirc();
 	stx7200_configure_nand(&cb101_nand_config[0]);
diff --git a/arch/sh/boards/st/hms1/setup.c b/arch/sh/boards/st/hms1/setup.c
index 6de1b5e..ffe7e87 100644
--- a/arch/sh/boards/st/hms1/setup.c
+++ b/arch/sh/boards/st/hms1/setup.c
@@ -98,7 +98,6 @@ static int __init hms1_device_init(void)
 	stx7100_configure_ssc(&ssc_private_info);
 	stx7100_configure_usb();
 	stx7100_configure_pata(3, IRL1_IRQ);
-	stx7100_configure_audio(NULL, NULL, NULL);
 
 	vpp_pio = stpio_request_pin(2,5, "VPP", STPIO_OUT);
 
diff --git a/arch/sh/boards/st/mb442/setup.c b/arch/sh/boards/st/mb442/setup.c
index 4116294..9303fe9 100644
--- a/arch/sh/boards/st/mb442/setup.c
+++ b/arch/sh/boards/st/mb442/setup.c
@@ -155,7 +155,6 @@ static int __init device_init(void)
 	stx7100_configure_usb();
 	stx7100_configure_lirc();
 	stx7100_configure_pata(3, IRL1_IRQ);
-	stx7100_configure_audio(NULL, NULL, NULL);
 
 	phy_reset_pin = stpio_request_set_pin(2, 4, "ste100p_reset",
 					      STPIO_OUT, 1);
diff --git a/arch/sh/boards/st/mb448/setup.c b/arch/sh/boards/st/mb448/setup.c
index 9003c22..06c4e14 100644
--- a/arch/sh/boards/st/mb448/setup.c
+++ b/arch/sh/boards/st/mb448/setup.c
@@ -143,7 +143,6 @@ static int __init device_init(void)
 	stx7100_configure_ssc(&ssc_private_info);
 	stx7100_configure_usb();
 	stx7100_configure_ethernet(0, 0, 0);
-	stx7100_configure_audio(NULL, NULL, NULL);
 
 	vpp_pio = stpio_request_pin(2,7, "VPP", STPIO_OUT);
 
diff --git a/arch/sh/boards/st/mb519/setup.c b/arch/sh/boards/st/mb519/setup.c
index ec113c8..cc5d2fe 100644
--- a/arch/sh/boards/st/mb519/setup.c
+++ b/arch/sh/boards/st/mb519/setup.c
@@ -153,7 +153,7 @@ static struct platform_device mb519_phy_devices[2] = {
 	},
 	.dev = {
 		.platform_data = &phy_private_data[1],
-	 }
+	}
 } };
 
 static struct platform_device epld_device = {
@@ -216,13 +216,6 @@ static struct platform_device *mb519_devices[] __initdata = {
 	&mb519_phy_devices[1],
 };
 
-struct plat_audio_config i2s_format = {
-	/* Actually this is a default value, but let's treat it as an example */
-	.pcm_format = PLAT_STM_AUDIO__FORMAT_I2S |
-			PLAT_STM_AUDIO__DATA_SIZE_24_BITS,
-	.oversampling = 256,
-};
-
 static int __init device_init(void)
 {
 	unsigned int epld_rev;
@@ -237,12 +230,6 @@ static int __init device_init(void)
 	stx7200_configure_pwm(&pwm_private_info);
 	stx7200_configure_ssc(&ssc_private_info);
 	stx7200_configure_usb();
-	stx7200_configure_audio(&i2s_format, /* PCM reader data */
-				NULL, /* PCM player 0 */
-				NULL, /* PCM player 1 */
-				&i2s_format, /* PCM player 2 */
-				&i2s_format, /* PCM player 3 */
-				NULL); /* HDMI PCM player */
 	stx7200_configure_ethernet(0, 0, 1, 0);
 	// stx7200_configure_ethernet(1, 0, 1, 1);
 	stx7200_configure_lirc();
diff --git a/arch/sh/kernel/cpu/sh4/setup-stb7100.c b/arch/sh/kernel/cpu/sh4/setup-stb7100.c
index 4d7bab7..325827f 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stb7100.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stb7100.c
@@ -761,256 +761,6 @@ static int __init stb7100_add_asc(void)
 }
 arch_initcall(stb7100_add_asc);
 
-/* Audio subsystem resources ----------------------------------------------- */
-
-/* Audio IO controls */
-
-static struct platform_device audio_outputs = {
-	.name          = "audio_outputs", /* sound/stm/audio_outputs.c */
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210200,
-			.end   = 0x19210203,
-		},
-	},
-};
-
-/* Frequency synthesizer */
-
-static struct platform_device fsynth = {
-	.name          = "fsynth", /* sound/stm/fsynth.c */
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210000,
-			.end   = 0x1921003f,
-		},
-	},
-};
-
-/* Internal DAC */
-
-static struct platform_device dac_internal = {
-	.name          = "dac_internal", /* sound/stm/dac_internal.c */
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x19210100,
-			.end   = 0x19210103,
-		},
-	},
-};
-
-/* PCM reader */
-
-static struct platform_device pcm_reader = {
-	.name          = "pcm_reader", /* sound/stm/pcm_reader.c */
-	.id            = -1,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18102000,
-			.end   = 0x18102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 146,
-			.end   = 146,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 1,
-			.end = 1,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			/* SOC version dependant,
-			 * see stx7100_configure_audio() function */
-		},
-	},
-};
-
-/* PCM players */
-
-static struct platform_device pcm_player_0 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 0,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18101000,
-			.end   = 0x18101027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 144,
-			.end   = 144,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 1,
-			.end = 1,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			/* SOC version dependant,
-			 * see stx7100_configure_audio() function */
-		},
-	},
-};
-
-static struct platform_device pcm_player_1 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 1,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18101800,
-			.end   = 0x18101827,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 145,
-			.end   = 145,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 1,
-			.end = 1,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			/* SOC version dependant,
-			 * see stx7100_configure_audio() function */
-		},
-	},
-};
-
-/* SPDIF player */
-
-static struct platform_device spdif_player = {
-	.name          = "spdif_player", /* sound/stm/spdif_player.c */
-	.id            = -1,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18103000,
-			.end   = 0x1810303f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 147,
-			.end   = 147,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 1,
-			.end = 1,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			/* SOC version dependant,
-			 * see stx7100_configure_audio() function */
-		},
-	},
-};
-
-/* Additional output devices */
-
-static struct platform_device i2s_spdif_converter = {
-	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18103000,
-			.end   = 0x18103223,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 142,
-			.end   = 142,
-		},
-	},
-};
-
-/* Audio subsystem runtime setup */
-
-static void __init set_resource(struct platform_device *device,
-	 unsigned int type, const char *name, unsigned int value)
-{
-	int i;
-
-	for (i = 0; i < device->num_resources; i++) {
-		struct resource *resource = &device->resource[i];
-
-		if (resource->flags == type &&
-				strcmp(resource->name, name) == 0) {
-			resource->start = value;
-			resource->end = value;
-		}
-	}
-}
-
-static struct platform_device *audio_devices[] __initdata = {
-	&audio_outputs,
-	&fsynth,
-	&pcm_reader,
-	&pcm_player_0,
-	&pcm_player_1,
-	&dac_internal,
-	&spdif_player,
-	&i2s_spdif_converter,
-};
-
-void __init stx7100_configure_audio(struct plat_audio_config *pcm_reader_config,
-		struct plat_audio_config *pcm_player_0_config,
-		struct plat_audio_config *pcm_player_1_config)
-{
-	pcm_reader.dev.platform_data = pcm_reader_config;
-	pcm_player_0.dev.platform_data = pcm_player_0_config;
-	pcm_player_1.dev.platform_data = pcm_player_1_config;
-	if (chip_7109) {
-		set_resource(&pcm_player_0, IORESOURCE_DMA, "request_line",
-				STB7109_FDMA_REQ_PCM_0);
-		set_resource(&pcm_player_1, IORESOURCE_DMA, "request_line",
-				STB7109_FDMA_REQ_PCM_1);
-		set_resource(&spdif_player, IORESOURCE_DMA, "request_line",
-				STB7109_FDMA_REQ_SPDIF);
-		set_resource(&pcm_reader, IORESOURCE_DMA, "request_line",
-				STB7109_FDMA_REQ_PCM_READ);
-	} else {
-		set_resource(&pcm_player_0, IORESOURCE_DMA, "request_line",
-				STB7100_FDMA_REQ_PCM_0);
-		set_resource(&pcm_player_1, IORESOURCE_DMA, "request_line",
-				STB7100_FDMA_REQ_PCM_1);
-		set_resource(&spdif_player, IORESOURCE_DMA, "request_line",
-				STB7100_FDMA_REQ_SPDIF);
-		set_resource(&pcm_reader, IORESOURCE_DMA, "request_line",
-				STB7100_FDMA_REQ_PCM_READ);
-	}
-	platform_add_devices(audio_devices, ARRAY_SIZE(audio_devices));
-}
 
 
 /* Early resources (sysconf and PIO) --------------------------------------- */
diff --git a/arch/sh/kernel/cpu/sh4/setup-stx7200.c b/arch/sh/kernel/cpu/sh4/setup-stx7200.c
index 107a901..b22739b 100644
--- a/arch/sh/kernel/cpu/sh4/setup-stx7200.c
+++ b/arch/sh/kernel/cpu/sh4/setup-stx7200.c
@@ -1052,446 +1052,6 @@ static int __init stb7200_add_asc(void)
 }
 arch_initcall(stb7200_add_asc);
 
-/* Audio subsystem resources ----------------------------------------------- */
-
-/* Audio outputs control */
-
-static struct platform_device audio_outputs = {
-	.name          = "audio_outputs", /* sound/stm/audio_outputs.c */
-	.id            = -1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601200,
-			.end   = 0xfd60120b,
-		},
-	}
-};
-
-/* Frequency synthesizers */
-
-static struct platform_device fsynth_0 = {
-	.name          = "fsynth", /* sound/stm/fsynth.c */
-	.id            = 0,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601000,
-			.end   = 0xfd60104f,
-		},
-	},
-};
-
-static struct platform_device fsynth_1 = {
-	.name          = "fsynth", /* sound/stm/fsynth.c */
-	.id            = 1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601100,
-			.end   = 0xfd60114f,
-		},
-	},
-};
-
-/* PCM reader */
-
-static struct platform_device pcm_reader = {
-	.name          = "pcm_reader", /* sound/stm/pcm_reader.c */
-	.id            = -1,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd100000,
-			.end   = 0xfd100027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(38),
-			.end   = ILC_IRQ(38),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_PCMIN,
-			.end   = STB7200_FDMA_REQ_PCMIN,
-		},
-	},
-};
-
-/* Internal DACs */
-
-static struct platform_device dac_internal_0 = {
-	.name          = "dac_internal", /* sound/stm/dac_internal.c */
-	.id            = 0,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601400,
-			.end   = 0xfd601403,
-		},
-	},
-};
-
-static struct platform_device dac_internal_1 = {
-	.name          = "dac_internal", /* sound/stm/dac_internal.c */
-	.id            = 1,
-	.num_resources = 1,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd601500,
-			.end   = 0xfd601503,
-		},
-	},
-};
-
-/* PCM players connected to internal DACs */
-
-static struct platform_device pcm_player_0 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 0,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd101000,
-			.end   = 0xfd101027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(39),
-			.end   = ILC_IRQ(39),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_PCM0,
-			.end   = STB7200_FDMA_REQ_PCM0,
-		},
-	},
-};
-
-static struct platform_device pcm_player_1 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 1,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd102000,
-			.end   = 0xfd102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(40),
-			.end   = ILC_IRQ(40),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_PCM1,
-			.end   = STB7200_FDMA_REQ_PCM1,
-		},
-	},
-};
-
-/* PCM players with digital outputs */
-
-static struct platform_device pcm_player_2 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 2,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd103000,
-			.end   = 0xfd103027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(41),
-			.end   = ILC_IRQ(41),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_PCM2,
-			.end   = STB7200_FDMA_REQ_PCM2,
-		},
-	},
-};
-
-static struct platform_device pcm_player_3 = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 3,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd104000,
-			.end   = 0xfd104027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(42),
-			.end   = ILC_IRQ(42),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_PCM3,
-			.end   = STB7200_FDMA_REQ_PCM3,
-		},
-	},
-};
-
-/* SPDIF player */
-
-static struct platform_device spdif_player = {
-	.name          = "spdif_player", /* sound/stm/spdif_player.c */
-	.id            = 0,
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd105000,
-			.end   = 0xfd10503f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(37),
-			.end   = ILC_IRQ(37),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_SPDIF,
-			.end   = STB7200_FDMA_REQ_SPDIF,
-		}
-	},
-};
-
-/* HDMI output devices
- * Please note that "HDTVOutBaseAddress" (0xFD10C000) from page 54 of
- * "7200 Programming Manual, Volume 2" is wrong. The correct HDMI players
- * subsystem base address is "HDMIPlayerBaseAddress" (0xFD106000) from
- * page 488 of the manual. */
-
-static struct platform_device hdmi_pcm_player = {
-	.name          = "pcm_player", /* sound/stm/pcm_player.c */
-	.id            = 4, /* HDMI PCM player is no. 4 */
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd106d00,
-			.end   = 0xfd106d27,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(62),
-			.end   = ILC_IRQ(62),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_HDMI_PCM,
-			.end   = STB7200_FDMA_REQ_HDMI_PCM,
-		},
-	},
-};
-
-static struct platform_device hdmi_spdif_player = {
-	.name          = "spdif_player", /* sound/stm/spdif_player.c */
-	.id            = 1, /* HDMI SPDIF player is no. 1 */
-	.num_resources = 4,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd106c00,
-			.end   = 0xfd106c3f,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(63),
-			.end   = ILC_IRQ(63),
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "initiator",
-			.start = 0,
-			.end = 0,
-		},
-		{
-			.flags = IORESOURCE_DMA,
-			.name = "request_line",
-			.start = STB7200_FDMA_REQ_HDMI_SPDIF,
-			.end   = STB7200_FDMA_REQ_HDMI_SPDIF,
-		}
-	},
-};
-
-static struct platform_device hdmi_i2s_spdif_converter_0 = {
-	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
-	.id            = 0,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107000,
-			.end   = 0xfd107223,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(64),
-			.end   = ILC_IRQ(64),
-		}
-	},
-};
-
-static struct platform_device hdmi_i2s_spdif_converter_1 = {
-	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
-	.id            = 1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107400,
-			.end   = 0xfd107623,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(65),
-			.end   = ILC_IRQ(65),
-		}
-	},
-};
-
-static struct platform_device hdmi_i2s_spdif_converter_2 = {
-	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
-	.id            = 2,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107800,
-			.end   = 0xfd107a23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(66),
-			.end   = ILC_IRQ(66),
-		}
-	},
-};
-
-static struct platform_device hdmi_i2s_spdif_converter_3 = {
-	.name          = "i2s-spdif_conv", /* sound/stm/i2s-spdif_converter.c */
-	.id            = 3,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0xfd107c00,
-			.end   = 0xfd107e23,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = ILC_IRQ(67),
-			.end   = ILC_IRQ(67),
-		}
-	},
-};
-
-static struct platform_device *audio_devices[] __initdata = {
-	&audio_outputs,
-	&fsynth_0,
-	&fsynth_1,
-	&pcm_reader,
-	&dac_internal_0,
-	&dac_internal_1,
-	&pcm_player_0,
-	&pcm_player_1,
-	&pcm_player_2,
-	&pcm_player_3,
-	&spdif_player,
-	&hdmi_pcm_player,
-	&hdmi_spdif_player,
-	&hdmi_i2s_spdif_converter_0,
-	&hdmi_i2s_spdif_converter_1,
-	&hdmi_i2s_spdif_converter_2,
-	&hdmi_i2s_spdif_converter_3,
-};
-
-void __init stx7200_configure_audio(struct plat_audio_config *pcm_reader_config,
-		struct plat_audio_config *pcm_player_0_config,
-		struct plat_audio_config *pcm_player_1_config,
-		struct plat_audio_config *pcm_player_2_config,
-		struct plat_audio_config *pcm_player_3_config,
-		struct plat_audio_config *hdmi_pcm_player_config)
-{
-	/* Cut 2.0 presumably will bring something new into the matter,
-	 * so above configuration must be checked! */
-	WARN_ON(chip_revision > 1);
-
-	pcm_reader.dev.platform_data = pcm_reader_config;
-	pcm_player_0.dev.platform_data = pcm_player_0_config;
-	pcm_player_1.dev.platform_data = pcm_player_1_config;
-	pcm_player_2.dev.platform_data = pcm_player_2_config;
-	pcm_player_3.dev.platform_data = pcm_player_3_config;
-	hdmi_pcm_player.dev.platform_data = hdmi_pcm_player_config;
-
-	platform_add_devices(audio_devices, ARRAY_SIZE(audio_devices));
-}
-
 /* Early resources (sysconf and PIO) --------------------------------------- */
 
 static struct platform_device sysconf_device = {
diff --git a/include/linux/stm/registers.h b/include/linux/stm/registers.h
index ef31547..e036900 100644
--- a/include/linux/stm/registers.h
+++ b/include/linux/stm/registers.h
@@ -90,6 +90,7 @@ static inline void regfield_poke(void *base, unsigned long offset,
 #include <linux/stm/registers/aud_pcmin.h>
 #include <linux/stm/registers/aud_pcmout.h>
 #include <linux/stm/registers/aud_spdif.h>
+#include <linux/stm/registers/aud_spdifpc.h>
 #include <linux/stm/registers/audcfg.h>
 #include <linux/stm/registers/audcfg_adac.h>
 #include <linux/stm/registers/audcfg_fsyn.h>
diff --git a/include/linux/stm/registers/aud_pcmout.h b/include/linux/stm/registers/aud_pcmout.h
index 91beb4c..f2d5008 100644
--- a/include/linux/stm/registers/aud_pcmout.h
+++ b/include/linux/stm/registers/aud_pcmout.h
@@ -37,9 +37,9 @@
 #define AUD_PCMOUT_ITS_CLR__UNF__MASK         0x1
 #define AUD_PCMOUT_ITS_CLR__UNF__VALUE__CLEAR 0x1
 
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__SHIFT       1
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__MASK        0x1
-#define AUD_PCMOUT_ITS_CLR__NSAMPLE__VALUE_CLEAR 0x1
+#define AUD_PCMOUT_ITS_CLR__NSAMPLE__SHIFT        1
+#define AUD_PCMOUT_ITS_CLR__NSAMPLE__MASK         0x1
+#define AUD_PCMOUT_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
 
 
 
@@ -132,6 +132,67 @@
 
 #define AUD_PCMOUT_FMT 0x24
 
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+
+#define AUD_PCMOUT_FMT__NBIT__SHIFT          0
+#define AUD_PCMOUT_FMT__NBIT__MASK           0x1
+#define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
+#define AUD_PCMOUT_FMT__NBIT__VALUE__16_BITS 0x1
+
+#define AUD_PCMOUT_FMT__DATA_SIZE__SHIFT          1
+#define AUD_PCMOUT_FMT__DATA_SIZE__MASK           0x7
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__16_BITS 0x0
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__18_BITS 0x1
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__20_BITS 0x2
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__24_BITS 0x3
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__28_BITS 0x4
+#define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__32_BITS 0x5
+
+#define AUD_PCMOUT_FMT__LR_POL__SHIFT            4
+#define AUD_PCMOUT_FMT__LR_POL__MASK             0x1
+#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW  0x0
+#define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
+
+#define AUD_PCMOUT_FMT__SCLK_EDGE__SHIFT          5
+#define AUD_PCMOUT_FMT__SCLK_EDGE__MASK           0x1
+#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__RISING  0x0
+#define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING 0x1
+
+#define AUD_PCMOUT_FMT__PADDING__SHIFT                6
+#define AUD_PCMOUT_FMT__PADDING__MASK                 0x1
+#define AUD_PCMOUT_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
+#define AUD_PCMOUT_FMT__PADDING__VALUE__NO_DELAY      0x1
+
+#define AUD_PCMOUT_FMT__ALIGN__SHIFT        7
+#define AUD_PCMOUT_FMT__ALIGN__MASK         0x1
+#define AUD_PCMOUT_FMT__ALIGN__VALUE__LEFT  0x0
+#define AUD_PCMOUT_FMT__ALIGN__VALUE__RIGHT 0x1
+
+#define AUD_PCMOUT_FMT__ORDER__SHIFT            8
+#define AUD_PCMOUT_FMT__ORDER__MASK             0x1
+#define AUD_PCMOUT_FMT__ORDER__VALUE__LSB_FIRST 0x0
+#define AUD_PCMOUT_FMT__ORDER__VALUE__MSB_FIRST 0x1
+
+#define AUD_PCMOUT_FMT__NUM_CH__SHIFT             9
+#define AUD_PCMOUT_FMT__NUM_CH__MASK              0x7
+/* "1 channel" means 1 PCM player channel so
+ * 2 audio channels (stereo) */
+#define AUD_PCMOUT_FMT__NUM_CH__VALUE__1_CHANNEL  0x1
+#define AUD_PCMOUT_FMT__NUM_CH__VALUE__2_CHANNELS 0x2
+#define AUD_PCMOUT_FMT__NUM_CH__VALUE__3_CHANNELS 0x3
+#define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
+#define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
+
+#define AUD_PCMOUT_FMT__BACK_STALLING__SHIFT            12
+#define AUD_PCMOUT_FMT__BACK_STALLING__MASK             0x1
+#define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__DISABLED  0x0
+#define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__ENABLED   0x1
+
+#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 13
+#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x3f
+
+#else /* STx710x, STx7200 cut 1.0 */
+
 #define AUD_PCMOUT_FMT__NBIT__SHIFT          0
 #define AUD_PCMOUT_FMT__NBIT__MASK           0x1
 #define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
@@ -182,15 +243,9 @@
 #define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
 #define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
 
-/* According to 7200 Programming Manual vol. 2: */
-#if 0
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 12
-#define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0xf
-#endif
-/* According to GPFIFO based PCM Player Functional Spec: */
-#if 1
 #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 11
 #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x1f
+
 #endif
 
 #endif
diff --git a/include/linux/stm/registers/aud_spdif.h b/include/linux/stm/registers/aud_spdif.h
index f10ce00..82725f0 100644
--- a/include/linux/stm/registers/aud_spdif.h
+++ b/include/linux/stm/registers/aud_spdif.h
@@ -232,10 +232,15 @@
 #define AUD_SPDIF_STA__PABIT__SHIFT       7
 #define AUD_SPDIF_STA__PABIT__MASK        0xff
 
-#define AUD_SPDIF_STA__PDPAUSE__SHIFT       5
+#define AUD_SPDIF_STA__PDPAUSE__SHIFT       15
 #define AUD_SPDIF_STA__PDPAUSE__MASK        0x1
 #define AUD_SPDIF_STA__PDPAUSE__VALUE__SENT 0x1
 
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+#define AUD_SPDIF_STA__SAMPLES_IN_FIFO__SHIFT 16
+#define AUD_SPDIF_STA__SAMPLES_IN_FIFO__MASK  0x1f
+#endif
+
 
 
 #define AUD_SPDIF_PA_PB 0x24
@@ -272,7 +277,7 @@
 #define AUD_SPDIF_CR1__CR1__MASK  0xffffffff
 
 
-
+/* LU, RU, LV & RV bits are described wrong in datasheet... */
 #define AUD_SPDIF_CL2_CR2_UV 0x34
 
 #define AUD_SPDIF_CL2_CR2_UV__CL2__SHIFT 0
@@ -281,8 +286,8 @@
 #define AUD_SPDIF_CL2_CR2_UV__CR2__SHIFT 8
 #define AUD_SPDIF_CL2_CR2_UV__CR2__MASK  0xf
 
-#define AUD_SPDIF_CL2_CR2_UV__RV__SHIFT  16
-#define AUD_SPDIF_CL2_CR2_UV__RV__MASK   0x1
+#define AUD_SPDIF_CL2_CR2_UV__LU__SHIFT  16
+#define AUD_SPDIF_CL2_CR2_UV__LU__MASK   0x1
 
 #define AUD_SPDIF_CL2_CR2_UV__RU__SHIFT  17
 #define AUD_SPDIF_CL2_CR2_UV__RU__MASK   0x1
@@ -290,8 +295,8 @@
 #define AUD_SPDIF_CL2_CR2_UV__LV__SHIFT  18
 #define AUD_SPDIF_CL2_CR2_UV__LV__MASK   0x1
 
-#define AUD_SPDIF_CL2_CR2_UV__LU__SHIFT  19
-#define AUD_SPDIF_CL2_CR2_UV__LU__MASK   0x1
+#define AUD_SPDIF_CL2_CR2_UV__RV__SHIFT  19
+#define AUD_SPDIF_CL2_CR2_UV__RV__MASK   0x1
 
 
 
@@ -307,10 +312,60 @@
 
 #define AUD_SPDIF_BST_FL 0x3c
 
-#define AUD_SPDIF_BST_FL__DBURST__SHIFT 0
+#define AUD_SPDIF_BST_FL__PDBURST__SHIFT 0
+#define AUD_SPDIF_BST_FL__PDBURST__MASK  0xffff
+
+#define AUD_SPDIF_BST_FL__DBURST__SHIFT 16
 #define AUD_SPDIF_BST_FL__DBURST__MASK  0xffff
 
-#define AUD_SPDIF_BST_FL__PDBURST__SHIFT 16
-#define AUD_SPDIF_BST_FL__PDBURST__MASK  0xffff
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+
+#define AUD_SPDIF_CONFIG 0x40
+
+#define AUD_SPDIF_CONFIG__P_BIT__SHIFT       0
+#define AUD_SPDIF_CONFIG__P_BIT__SHIFT__MASK 0x1
+#define AUD_SPDIF_CONFIG__P_BIT__VALUE__HW   0x0
+#define AUD_SPDIF_CONFIG__P_BIT__VALUE__FDMA 0x1
+
+#define AUD_SPDIF_CONFIG__C_BIT__SHIFT       1
+#define AUD_SPDIF_CONFIG__C_BIT__SHIFT__MASK 0x1
+#define AUD_SPDIF_CONFIG__C_BIT__VALUE__FDMA 0x0
+#define AUD_SPDIF_CONFIG__C_BIT__VALUE__HW   0x1
+
+#define AUD_SPDIF_CONFIG__U_BIT__SHIFT       2
+#define AUD_SPDIF_CONFIG__U_BIT__SHIFT__MASK 0x1
+#define AUD_SPDIF_CONFIG__U_BIT__VALUE__FDMA 0x0
+#define AUD_SPDIF_CONFIG__U_BIT__VALUE__HW   0x1
+
+#define AUD_SPDIF_CONFIG__V_BIT__SHIFT       2
+#define AUD_SPDIF_CONFIG__V_BIT__SHIFT__MASK 0x1
+#define AUD_SPDIF_CONFIG__V_BIT__VALUE__FDMA 0x0
+#define AUD_SPDIF_CONFIG__V_BIT__VALUE__HW   0x1
+
+#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__SHIFT           4
+#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__MASK            0x1
+#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__DISABLED 0x0
+#define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_CONFIG__MEM_FMT__SHIFT                  5
+#define AUD_SPDIF_CONFIG__MEM_FMT__MASK                   0x1
+#define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
+#define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
+
+#define AUD_SPDIF_CONFIG__DTS_HD__SHIFT           6
+#define AUD_SPDIF_CONFIG__DTS_HD__MASK            0x1
+#define AUD_SPDIF_CONFIG__DTS_HD__VALUE__DISABLED 0x0
+#define AUD_SPDIF_CONFIG__DTS_HD__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_CONFIG__BACK_STALLING__SHIFT           7
+#define AUD_SPDIF_CONFIG__BACK_STALLING__MASK            0x1
+#define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__DISABLED 0x0
+#define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__ENABLED  0x1
+
+#define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__SHIFT 8
+#define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK  0x1f
+
+
+#endif
 
 #endif
diff --git a/include/linux/stm/registers/aud_spdifpc.h b/include/linux/stm/registers/aud_spdifpc.h
new file mode 100644
index 0000000..2d4aacb
--- /dev/null
+++ b/include/linux/stm/registers/aud_spdifpc.h
@@ -0,0 +1,483 @@
+#ifndef __STM_REGISTERS_AUD_SPDIFPC_H
+#define __STM_REGISTERS_AUD_SPDIFPC_H
+
+
+
+#define AUD_SPDIFPC_CFG 0x000
+
+#define AUD_SPDIFPC_CFG__DEVICE_EN__SHIFT           0
+#define AUD_SPDIFPC_CFG__DEVICE_EN__MASK            0x1
+#define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_CFG__SW_RESET__SHIFT          1
+#define AUD_SPDIFPC_CFG__SW_RESET__MASK           0x1
+#define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RUNNING 0x0
+#define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RESET   0x1
+
+#define AUD_SPDIFPC_CFG__FIFO_EN__SHIFT           2
+#define AUD_SPDIFPC_CFG__FIFO_EN__MASK            0x1
+#define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__SHIFT          3
+#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__MASK           0x3
+#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__16_BITS 0x0
+#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__20_BITS 0x1
+#define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__24_BITS 0x2
+
+#define AUD_SPDIFPC_CFG__REQ_ACK_EN__SHIFT           5
+#define AUD_SPDIFPC_CFG__REQ_ACK_EN__MASK            0x1
+#define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__ENABLED  0x1
+
+/* Undocumented configuration bit, which exists in some hardware... */
+#define AUD_SPDIFPC_CFG__CHA_STA_BITS__SHIFT           6
+#define AUD_SPDIFPC_CFG__CHA_STA_BITS__MASK            0x1
+#define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__SUBFRAME 0x0
+#define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__FRAME    0x1
+
+
+
+#define AUD_SPDIFPC_STA 0x004
+
+#define AUD_SPDIFPC_STA__SOFT_RESET__SHIFT         1
+#define AUD_SPDIFPC_STA__SOFT_RESET__MASK          0x1
+#define AUD_SPDIFPC_STA__SOFT_RESET__VALUE__ACTIVE 0x1
+
+#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__SHIFT        2
+#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__MASK         0x1
+#define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__VALUE__EMPTY 0x1
+
+#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__SHIFT           3
+#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__MASK            0x1
+#define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__VALUE__DETECTED 0x1
+
+#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__SHIFT        4
+#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__MASK         0x1
+#define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__VALUE__EMPTY 0x1
+
+#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__SHIFT           5
+#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__MASK            0x1
+#define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__VALUE__DETECTED 0x1
+
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__SHIFT        6
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__MASK         0x1
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__VALUE__EMPTY 0x1
+
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__SHIFT           7
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__MASK            0x1
+#define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__VALUE__DETECTED 0x1
+
+#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__SHIFT           8
+#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__MASK            0x1
+#define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__VALUE__DETECTED 0x1
+
+#define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT       16
+#define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT__MASK 0x7
+
+
+
+#define AUD_SPDIFPC_IT_EN 0x008
+
+#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__SHIFT           0
+#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__SHIFT           1
+#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__SHIFT           2
+#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__SHIFT           3
+#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__SHIFT           4
+#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__SHIFT           5
+#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__SHIFT           6
+#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__SHIFT           7
+#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__SHIFT           8
+#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__SHIFT           16
+#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__SHIFT           17
+#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__SHIFT           18
+#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__SHIFT           19
+#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__SHIFT           20
+#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__SHIFT           21
+#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__SHIFT           22
+#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__ENABLED  0x1
+
+#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__SHIFT           31
+#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__MASK            0x1
+#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__DISABLED 0x0
+#define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__ENABLED  0x1
+
+
+
+#define AUD_SPDIFPC_ITS 0x00c
+
+#define AUD_SPDIFPC_ITS__INTERRUPT__SHIFT          0
+#define AUD_SPDIFPC_ITS__INTERRUPT__MASK           0x1
+#define AUD_SPDIFPC_ITS__INTERRUPT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__SHIFT          1
+#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__SOFT_RESET_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__SHIFT          2
+#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__SHIFT          3
+#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__SHIFT          4
+#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__SHIFT          5
+#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__SHIFT          6
+#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__SHIFT          7
+#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__SHIFT          8
+#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__RUN_STOP_INT__SHIFT          16
+#define AUD_SPDIFPC_ITS__RUN_STOP_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__RUN_STOP_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__SHIFT          17
+#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__UNDERFLOW_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__EODATABURST_INT__SHIFT          18
+#define AUD_SPDIFPC_ITS__EODATABURST_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__EODATABURST_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__EOBLOCK_INT__SHIFT          19
+#define AUD_SPDIFPC_ITS__EOBLOCK_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__EOBLOCK_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__LATENCY_INT__SHIFT          20
+#define AUD_SPDIFPC_ITS__LATENCY_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__LATENCY_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__PD_DATA_BURST__SHIFT          21
+#define AUD_SPDIFPC_ITS__PD_DATA_BURST__MASK           0x1
+#define AUD_SPDIFPC_ITS__PD_DATA_BURST__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__SHIFT          22
+#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__VALUE__PENDING 0x1
+
+#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__SHIFT          31
+#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__MASK           0x1
+#define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__VALUE__PENDING 0x1
+
+
+
+#define AUD_SPDIFPC_IT_CLR 0x010
+
+#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__SHIFT        0
+#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__SHIFT        1
+#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__SHIFT        2
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__SHIFT        3
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__SHIFT        4
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__SHIFT        5
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__SHIFT        6
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__SHIFT        7
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__SHIFT        8
+#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__SHIFT        16
+#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__SHIFT        17
+#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__SHIFT        18
+#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__SHIFT        19
+#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__SHIFT        20
+#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__SHIFT        21
+#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__SHIFT        22
+#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__VALUE__CLEAR 0x1
+
+#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__SHIFT        31
+#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__MASK         0x1
+#define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__VALUE__CLEAR 0x1
+
+
+
+#define AUD_SPDIFPC_VAL 0x100
+
+#define AUD_SPDIFPC_VAL__VALIDITY_BITS__SHIFT 0
+#define AUD_SPDIFPC_VAL__VALIDITY_BITS__MASK  0xffffffff
+
+
+
+#define AUD_SPDIFPC_DATA 0x104
+
+#define AUD_SPDIFPC_DATA__USER_DATA_BITS__SHIFT 0
+#define AUD_SPDIFPC_DATA__USER_DATA_BITS__MASK  0xffffffff
+
+
+
+#define AUD_SPDIFPC_CHA_STA(n) (0x108 + (n) * 4)
+
+#define AUD_SPDIFPC_CHA_STA__CHA_STA__SHIFT 0
+#define AUD_SPDIFPC_CHA_STA__CHA_STA__MASK  0xffffffff
+
+
+
+#define AUD_SPDIFPC_CTRL 0x200
+
+#define AUD_SPDIFPC_CTRL__OPERATION__SHIFT                    0
+#define AUD_SPDIFPC_CTRL__OPERATION__MASK                     0x7
+#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__OFF               0x0
+#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PCM_NULL     0x1
+#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PAUSE_BURSTS 0x2
+#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__PCM               0x3
+#define AUD_SPDIFPC_CTRL__OPERATION__VALUE__ENCODED           0x4
+
+#define AUD_SPDIFPC_CTRL__IDLE_STATE__SHIFT         3
+#define AUD_SPDIFPC_CTRL__IDLE_STATE__MASK          0x1
+#define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__NORMAL 0x0
+#define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__IDLE   0x1
+
+#define AUD_SPDIFPC_CTRL__ROUNDING__SHIFT                   4
+#define AUD_SPDIFPC_CTRL__ROUNDING__MASK                    0x1
+#define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__NO_ROUNDING      0x0
+#define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__16_BITS_ROUNDING 0x1
+
+#define AUD_SPDIFPC_CTRL__DIVIDER__SHIFT 5
+#define AUD_SPDIFPC_CTRL__DIVIDER__MASK  0xff
+
+#define AUD_SPDIFPC_CTRL__STUFFING__SHIFT           14
+#define AUD_SPDIFPC_CTRL__STUFFING__MASK            0x1
+#define AUD_SPDIFPC_CTRL__STUFFING__VALUE__SOFTWARE 0x0
+#define AUD_SPDIFPC_CTRL__STUFFING__VALUE__HARDWARE 0x1
+
+#define AUD_SPDIFPC_CTRL__NO_SAMPLES__SHIFT 15
+#define AUD_SPDIFPC_CTRL__NO_SAMPLES__MASK  0x1ffff
+
+
+
+#define AUD_SPDIFPC_SPDIFSTA 0x204
+
+#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__SHIFT          0
+#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__MASK           0x1
+#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__STOPPED 0x0
+#define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__RUNNING 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__SHIFT           1
+#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__MASK            0x1
+#define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__VALUE__DETECTED 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__SHIFT      2
+#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__MASK       0x1
+#define AUD_SPDIFPC_SPDIFSTA__EODATABURST__VALUE__END 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__SHIFT      3
+#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__MASK       0x1
+#define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__VALUE__END 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__LATENCY__SHIFT                         4
+#define AUD_SPDIFPC_SPDIFSTA__LATENCY__MASK                          0x1
+#define AUD_SPDIFPC_SPDIFSTA__LATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SHIFT       5
+#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__MASK        0x1
+#define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__VALUE__SENT 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__SHIFT       6
+#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__MASK        0x1
+#define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__VALUE__DONE 0x1
+
+#define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__SHIFT       7
+#define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__MASK        0xff
+
+#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SHIFT       5
+#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__MASK        0x1
+#define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__VALUE__SENT 0x1
+
+
+
+#define AUD_SPDIFPC_PAUSE 0x208
+
+#define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__SHIFT 0
+#define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__MASK  0xffff
+
+#define AUD_SPDIFPC_PAUSE__PAUSE_LAT__SHIFT 16
+#define AUD_SPDIFPC_PAUSE__PAUSE_LAT__MASK  0xffff
+
+
+
+#define AUD_SPDIFPC_DATA_BURST 0x20c
+
+#define AUD_SPDIFPC_DATA_BURST__DATA_BURST__SHIFT 0
+#define AUD_SPDIFPC_DATA_BURST__DATA_BURST__MASK  0xffff
+
+#define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__SHIFT 16
+#define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__MASK  0xffff
+
+
+
+#define AUD_SPDIFPC_PA_PB 0x210
+
+#define AUD_SPDIFPC_PA_PB__PB__SHIFT 0
+#define AUD_SPDIFPC_PA_PB__PB__MASK  0xffff
+
+#define AUD_SPDIFPC_PA_PB__PA__SHIFT 16
+#define AUD_SPDIFPC_PA_PB__PA__MASK  0xffff
+
+
+
+#define AUD_SPDIFPC_PC_PD 0x214
+
+#define AUD_SPDIFPC_PC_PD__PD__SHIFT 0
+#define AUD_SPDIFPC_PC_PD__PD__MASK  0xffff
+
+#define AUD_SPDIFPC_PC_PD__PC__SHIFT 16
+#define AUD_SPDIFPC_PC_PD__PC__MASK  0xffff
+
+
+
+
+#define AUD_SPDIFPC_CL1 0x218
+
+#define AUD_SPDIFPC_CL1__CHANNEL_STATUS__SHIFT 0
+#define AUD_SPDIFPC_CL1__CHANNEL_STATUS__MASK  0xffffffff
+
+
+
+#define AUD_SPDIFPC_CR1 0x21c
+
+#define AUD_SPDIFPC_CR1__CH_STA__SHIFT 0
+#define AUD_SPDIFPC_CR1__CH_STA__MASK  0xffffffff
+
+
+
+#define AUD_SPDIFPC_SUV 0x220
+
+#define AUD_SPDIFPC_SUV__CH_STA_LEFT__SHIFT 0
+#define AUD_SPDIFPC_SUV__CH_STA_LEFT__MASK  0xf
+
+#define AUD_SPDIFPC_SUV__CH_STA_RIGHT__SHIFT 8
+#define AUD_SPDIFPC_SUV__CH_STA_RIGHT__MASK  0xf
+
+#define AUD_SPDIFPC_SUV__DATA_LEFT__SHIFT  16
+#define AUD_SPDIFPC_SUV__DATA_LEFT__MASK   0x1
+
+#define AUD_SPDIFPC_SUV__DATA_RIGHT__SHIFT  17
+#define AUD_SPDIFPC_SUV__DATA_RIGHT__MASK   0x1
+
+#define AUD_SPDIFPC_SUV__VAL_LEFT__SHIFT  18
+#define AUD_SPDIFPC_SUV__VAL_LEFT__MASK   0x1
+
+#define AUD_SPDIFPC_SUV__VAL_RIGHT__SHIFT  19
+#define AUD_SPDIFPC_SUV__VAL_RIGHT__MASK   0x1
+
+#endif
diff --git a/include/linux/stm/registers/audcfg.h b/include/linux/stm/registers/audcfg.h
index 6e6dafa..ccd5df2 100644
--- a/include/linux/stm/registers/audcfg.h
+++ b/include/linux/stm/registers/audcfg.h
@@ -7,6 +7,10 @@
 #include <linux/stm/registers/stx710x/audcfg.h>
 #endif
 
+#ifdef CONFIG_CPU_SUBTYPE_STX7111
+#include <linux/stm/registers/stx7111/audcfg.h>
+#endif
+
 #ifdef CONFIG_CPU_SUBTYPE_STX7200
 #include <linux/stm/registers/stx7200/audcfg.h>
 #endif
diff --git a/include/linux/stm/registers/audcfg_fsyn.h b/include/linux/stm/registers/audcfg_fsyn.h
index 572ad05..1934159 100644
--- a/include/linux/stm/registers/audcfg_fsyn.h
+++ b/include/linux/stm/registers/audcfg_fsyn.h
@@ -12,23 +12,28 @@
 
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__SHIFT 2
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__MASK  0xf
-/* Inverted in 7200 vs 710x - madness, isn't it? :-O */
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (0 << n)
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (1 << n)
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (0 << n)
 #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (1 << n)
 #endif
 
-/* Doesn't exist in 7200 - again, veeery strange... */
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 #define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
 #define AUDCFG_FSYN_CFG__FS_EN__MASK               0x7
 #define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
 #define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
 #endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+#define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
+#define AUDCFG_FSYN_CFG__FS_EN__MASK               0xf
+#define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
+#define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
+#endif
+/* Doesn't exist in 7200 - again, veeery strange... */
 
 #define AUDCFG_FSYN_CFG__NSB__SHIFT             10
 #define AUDCFG_FSYN_CFG__NSB__MASK              0xf
@@ -52,25 +57,25 @@
 #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__BAD_REFERENCE       0x2
 #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_BAD_REFERENCE  0x3
 
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
-#define AUDCFG_FSYN_CFG__TST_CLK_SEL__SHIFT 18
-#define AUDCFG_FSYN_CFG__TST_CLK_SEL__MASK  0x3
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
-#define AUDCFG_FSYN_CFG__TST_PCMDAT__SHIFT 20
-#define AUDCFG_FSYN_CFG__TST_PCMDAT__MASK  0xf
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               24
-#endif
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
 #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x3
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__FE900_CLOCK  0x0
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x1
+#define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSCLKINALT  0x2
+#endif
 
 
 
diff --git a/include/linux/stm/registers/stx710x/audcfg.h b/include/linux/stm/registers/stx710x/audcfg.h
index 09323b2..4e33612 100644
--- a/include/linux/stm/registers/stx710x/audcfg.h
+++ b/include/linux/stm/registers/stx710x/audcfg.h
@@ -29,6 +29,7 @@
 #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__MASK                0x1
 #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__PCM_PLAYER   0x0
 #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__SPDIF_PLAYER 0x1
+/* Actually, in 7109 it seems to be a separate register (offset 0x04...) */
 
 
 
diff --git a/include/linux/stm/registers/stx7111/audcfg.h b/include/linux/stm/registers/stx7111/audcfg.h
new file mode 100644
index 0000000..929ec9b
--- /dev/null
+++ b/include/linux/stm/registers/stx7111/audcfg.h
@@ -0,0 +1,29 @@
+#ifndef __STM_REGISTERS_STX7111_AUDCFG_H
+#define __STM_REGISTERS_STX7111_AUDCFG_H
+
+
+
+#define AUDCFG_IO_CTRL 0x00
+
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__SHIFT         3
+#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__SHIFT         5
+#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__MASK          0x1
+#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__INPUT  0x0
+#define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__OUTPUT 0x1
+
+#define AUDCFG_IO_CTRL__CLKREC_SEL__SHIFT            9
+#define AUDCFG_IO_CTRL__CLKREC_SEL__MASK             0x3
+#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPLHDMI 0x0
+#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__SPDIFHDMI 0x1
+#define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPL1    0x2
+
+#endif
diff --git a/include/linux/stm/soc.h b/include/linux/stm/soc.h
index b1dbf6c..b74c5cd 100644
--- a/include/linux/stm/soc.h
+++ b/include/linux/stm/soc.h
@@ -139,40 +139,6 @@ struct nand_config_data {
 
 
 
-/* Audio subsystem board level configuration -
- * PCM formats & additional ALSA controls */
-struct plat_audio_config {
-	/* PCM format configuration - logical sum of PLAT_STM_AUDIO__*
-	 * flags listed below */
-	unsigned long pcm_format;
-
-	/* Required oversampling value (leave 0 to get default 256 ;-) */
-	unsigned int oversampling;
-};
-
-/* If CUSTOM bit is defined the rest of pcm_format will be treated
- * as a AUD_PCMOUT_FMT register content and mirrored there; this
- * is not recommended - be aware of chips differences (eg. hardware
- * bug of inverted SCLK_EDGE on 7100 and _some_ cuts of 7109...) */
-#define PLAT_STM_AUDIO__CUSTOM          0x80000000
-/* Select data size & digital serial audio format; note that 0 describes
- * I2S 24 bits mode, which is actually default :-) */
-#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS 0x00000000
-#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS 0x00000001
-#define PLAT_STM_AUDIO__DATA_SIZE_24_BITS       0x00000000
-#define PLAT_STM_AUDIO__DATA_SIZE_20_BITS       0x00000010
-#define PLAT_STM_AUDIO__DATA_SIZE_18_BITS       0x00000020
-#define PLAT_STM_AUDIO__DATA_SIZE_16_BITS       0x00000030
-#define PLAT_STM_AUDIO__FORMAT_I2S              0x00000000
-#define PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED   0x00000100
-#define PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED  0x00000200
-/* Bit masks for above settings */
-#define PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK    0x0000000f
-#define PLAT_STM_AUDIO__DATA_SIZE_MASK          0x000000f0
-#define PLAT_STM_AUDIO__FORMAT_MASK             0x00000f00
-
-
-
 void stx7100_early_device_init(void);
 void stb7100_configure_asc(const int *ascs, int num_ascs, int console);
 void sysconf_early_init(struct platform_device *pdev);
@@ -185,9 +151,6 @@ void stx7100_configure_usb(void);
 void stx7100_configure_ethernet(int rmii_mode, int ext_clk, int phy_bus);
 void stx7100_configure_lirc(void);
 void stx7100_configure_pata(int bank, int irq);
-void stx7100_configure_audio(struct plat_audio_config *pcm_reader_config,
-		struct plat_audio_config *pcm_player_0_config,
-		struct plat_audio_config *pcm_player_1_config);
 
 void stx7111_early_device_init(void);
 void stx7111_configure_asc(const int *ascs, int num_ascs, int console);
@@ -207,11 +170,5 @@ void stx7200_configure_ethernet(int mac, int rmii_mode, int ext_clk,
 				int phy_bus);
 void stx7200_configure_lirc(void);
 void stx7200_configure_nand(struct nand_config_data *data);
-void stx7200_configure_audio(struct plat_audio_config *pcm_reader_config,
-		struct plat_audio_config *pcm_player_0_config,
-		struct plat_audio_config *pcm_player_1_config,
-		struct plat_audio_config *pcm_player_2_config,
-		struct plat_audio_config *pcm_player_3_config,
-		struct plat_audio_config *hdmi_pcm_player_config);
 
 #endif /* __LINUX_ST_SOC_H */
diff --git a/include/sound/asoundef.h b/include/sound/asoundef.h
index 58c9ef3..a7d03bf 100644
--- a/include/sound/asoundef.h
+++ b/include/sound/asoundef.h
@@ -112,6 +112,14 @@
 #define IEC958_AES3_CON_CLOCK_1000PPM	(0<<4)	/* 1000 ppm */
 #define IEC958_AES3_CON_CLOCK_50PPM	(1<<4)	/* 50 ppm */
 #define IEC958_AES3_CON_CLOCK_VARIABLE	(2<<4)	/* variable pitch */
+#define IEC958_AES4_CON_MAX_WORDLEN_24  (1<<0)  /* 0 = 20-bit, 1 = 24-bit */
+#define IEC958_AES4_CON_WORDLEN         (7<<1)  /* mask - sample word length */
+#define IEC958_AES4_CON_WORDLEN_NOTID   (0<<1)  /* not indicated */
+#define IEC958_AES4_CON_WORDLEN_20_16   (1<<1)  /* 20-bit or 16-bit */
+#define IEC958_AES4_CON_WORDLEN_22_18   (2<<1)  /* 22-bit or 18-bit */
+#define IEC958_AES4_CON_WORDLEN_23_19   (4<<1)  /* 23-bit or 19-bit */
+#define IEC958_AES4_CON_WORDLEN_24_20   (5<<1)  /* 24-bit or 20-bit */
+#define IEC958_AES4_CON_WORDLEN_21_17   (6<<1)  /* 21-bit or 17-bit */
 
 /*****************************************************************************
  *                                                                           *
diff --git a/include/sound/stm.h b/include/sound/stm.h
new file mode 100644
index 0000000..c6ae539
--- /dev/null
+++ b/include/sound/stm.h
@@ -0,0 +1,131 @@
+/*
+ *   STMicrolectronics SoCs audio driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __SOUND_STM_H
+#define __SOUND_STM_H
+
+#include <sound/driver.h>
+#include <sound/core.h>
+
+
+
+/*
+ * Converters (DAC, ADC, I2S to SPDIF, SPDIF to I2S, etc.)
+ */
+
+/* Link type (format) description
+ * Please note, that 0 value means I2S with 32 bits per
+ * subframe (channel) and is a default setting. */
+#define SND_STM_FORMAT__I2S              0x00000000
+#define SND_STM_FORMAT__LEFT_JUSTIFIED   0x00000001
+#define SND_STM_FORMAT__RIGHT_JUSTIFIED  0x00000002
+#define SND_STM_FORMAT__SPDIF            0x00000003
+#define SND_STM_FORMAT__MASK             0x0000000f
+
+/* Following values are valid only for I2S, Left Justified and
+ * Right justified formats and can be bit-added to format;
+ * they define size of one subframe (channel) transmitted.
+ * For SPDIF the frame size is fixed and defined by standard. */
+#define SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS 0x00000000
+#define SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS 0x00000010
+#define SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK    0x000000f0
+
+/* Converter handle */
+struct snd_stm_conv {
+	const char *name;
+
+	/* Configuration */
+	unsigned int (*get_format)(struct snd_stm_conv *conv);
+	int (*get_oversampling)(struct snd_stm_conv *conv);
+
+	/* Operations */
+	int (*enable)(struct snd_stm_conv *conv);
+	int (*disable)(struct snd_stm_conv *conv);
+	int (*mute)(struct snd_stm_conv *conv);
+	int (*unmute)(struct snd_stm_conv *conv);
+
+	/* Master (must be enabled prior to this one) */
+	struct snd_stm_conv *master;
+};
+
+int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source);
+
+
+
+/*
+ * Generic conv implementations
+ */
+
+/* I2C-controlled DAC/ADC generic implementation
+ *
+ * Define a "struct i2c_board_info" with "struct snd_stm_conv_i2c_info"
+ * as a platform data:
+ *
+ * static struct i2c_board_info external_dac __initdata = {
+ * 	.driver_name = "snd_conv_i2c",
+ * 	.type = "<i.e. chip model>",
+ * 	.addr = <I2C address>
+ * 	.platform_data = &(struct snd_stm_conv_i2c_info) {
+ * 		<see below>
+ * 	},
+ * };
+ *
+ * and add it using:
+ *
+ * i2c_new_device(i2c_get_adapter(<i2c adapter (bus) id>), &external_dac);
+ */
+
+struct snd_stm_conv_i2c_info {
+	const char *name;
+	const char *card_id;
+
+	const char *enable_cmd;
+	int enable_cmd_len;
+	const char *disable_cmd;
+	int disable_cmd_len;
+	const char *mute_cmd;
+	int mute_cmd_len;
+	const char *unmute_cmd;
+	int unmute_cmd_len;
+};
+
+/* GPIO-controlled (STPIO interface) DAC/ADC generic implementation
+ *
+ * Define platform device named "snd_conv_stpio", pass
+ * following structure as platform_data and add it in normal way :-) */
+
+struct snd_stm_conv_stpio_info {
+	const char *name;
+	const char *card_id;
+
+	struct stpio_pin *enable_pin;
+	unsigned int enable_value;
+	struct stpio_pin *disable_pin;
+	unsigned int disable_value;
+	struct stpio_pin *mute_pin;
+	unsigned int mute_value;
+	struct stpio_pin *unmute_pin;
+	unsigned int unmute_value;
+};
+
+#endif
diff --git a/sound/soc/stm/Kconfig b/sound/soc/stm/Kconfig
index b6e43a4..3c5bdfb 100644
--- a/sound/soc/stm/Kconfig
+++ b/sound/soc/stm/Kconfig
@@ -1,11 +1,12 @@
 config SND_STM
 	tristate "STMicroelectronics SoCs support"
 	depends on SND
-	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7200
+	depends on CPU_SUBTYPE_STB7100 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7200
 	select SND_PCM
 	select STM_DMA
+	select BPA2
 	help
-	  Say Y here for ALSA support on the STx710x & STx7200 families.
+	  Say Y here for ALSA support on the STx710x, STx7111 & STx7200 families.
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-stm.o
\ No newline at end of file
diff --git a/sound/soc/stm/Makefile b/sound/soc/stm/Makefile
index 08b9a96..3bf2230 100644
--- a/sound/soc/stm/Makefile
+++ b/sound/soc/stm/Makefile
@@ -1,6 +1,7 @@
 obj-$(CONFIG_SND_STM) += snd-stm.o
 snd-stm-y := init.o common.o synchro.o
 snd-stm-$(CONFIG_CPU_SUBTYPE_STB7100) += stx710x.o
+snd-stm-$(CONFIG_CPU_SUBTYPE_STX7111) += stx7111.o
 snd-stm-$(CONFIG_CPU_SUBTYPE_STX7200) += stx7200.o
-snd-stm-y += audio_outputs.o dac.o dac_internal.o fsynth.o
-snd-stm-y += i2s-spdif_converter.o pcm_player.o pcm_reader.o spdif_player.o
+snd-stm-y += audio_outputs.o conv.o conv_dummy.o conv_i2s-spdif.o conv_internal_dac.o
+snd-stm-y += fsynth.o pcm_player.o pcm_reader.o spdif_player.o
diff --git a/sound/soc/stm/audio_outputs.c b/sound/soc/stm/audio_outputs.c
index 53c2034..30d9722 100644
--- a/sound/soc/stm/audio_outputs.c
+++ b/sound/soc/stm/audio_outputs.c
@@ -64,11 +64,11 @@ static void snd_stm_audio_outputs_dump_registers(struct snd_info_entry *entry,
 	snd_assert(audio_outputs, return);
 	snd_stm_magic_assert(audio_outputs, return);
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
 	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
 			REGISTER_PEEK(audio_outputs->base, AUDCFG_IO_CTRL));
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 	snd_iprintf(buffer, "AUDCFG_IOMUX_CTRL (offset 0x00) = 0x%08x\n",
 			REGISTER_PEEK(audio_outputs->base, AUDCFG_IOMUX_CTRL));
 	snd_iprintf(buffer, "AUDCFG_HDMI_CTRL (offset 0x04) = 0x%08x\n",
@@ -88,14 +88,20 @@ static int snd_stm_audio_outputs_register(struct snd_device *snd_device)
 
 	/* Enable audio outputs */
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, ENABLE) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, OUTPUT) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, OUTPUT) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, OUTPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, ENABLE) |
 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, OUTPUT) |
@@ -125,14 +131,20 @@ static int snd_stm_audio_outputs_disconnect(struct snd_device *snd_device)
 
 	/* Disable audio outputs */
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, DISABLE) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, INPUT) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, INPUT) |
 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, INPUT) |
+			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, DISABLE) |
 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, INPUT) |
@@ -144,7 +156,7 @@ static int snd_stm_audio_outputs_disconnect(struct snd_device *snd_device)
 	return 0;
 }
 
-static struct snd_device_ops snd_stm_audio_outputs_ops = {
+static struct snd_device_ops snd_stm_audio_outputs_snd_device_ops = {
 	.dev_register = snd_stm_audio_outputs_register,
 	.dev_disconnect = snd_stm_audio_outputs_disconnect,
 };
@@ -158,16 +170,11 @@ static struct snd_device_ops snd_stm_audio_outputs_ops = {
 static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
 {
 	int result = 0;
-	struct snd_stm_component *component;
 	struct snd_stm_audio_outputs *audio_outputs;
-	const char *card_id;
 	struct snd_card *card;
 
 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
-
 	audio_outputs = kzalloc(sizeof(*audio_outputs), GFP_KERNEL);
 	if (!audio_outputs) {
 		snd_stm_printe("Can't allocate memory "
@@ -184,14 +191,10 @@ static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
 		goto error_memory_request;
 	}
 
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	if (result == 0)
-		card = snd_stm_cards_get(card_id);
-	else
-		card = snd_stm_cards_default(&card_id);
+	card = snd_stm_cards_default();
 	snd_assert(card, return -EINVAL);
 	snd_printd("Audio output controls will be a member of a card '%s'\n",
-		card_id);
+		card->id);
 
 	/* Register HDMI route control */
 
@@ -201,7 +204,7 @@ static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
 	/* ALSA component */
 
 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, audio_outputs,
-			&snd_stm_audio_outputs_ops);
+			&snd_stm_audio_outputs_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
 		goto error_device;
diff --git a/sound/soc/stm/common.c b/sound/soc/stm/common.c
index 5283ba5..96d9bee 100644
--- a/sound/soc/stm/common.c
+++ b/sound/soc/stm/common.c
@@ -24,11 +24,14 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/mm.h>
+#include <linux/platform_device.h>
 #include <linux/stm/soc.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/info.h>
+#include <sound/pcm_params.h>
+#include <sound/asoundef.h>
 
 #undef TRACE
 #include "common.h"
@@ -123,133 +126,62 @@ struct snd_card __init *snd_stm_cards_get(const char *id)
 	return NULL;
 }
 
-struct snd_card __init *snd_stm_cards_default(const char **id)
+struct snd_card __init *snd_stm_cards_default(void)
 {
-	if (snd_stm_default && id)
-		*id = snd_stm_default->id;
-
 	return snd_stm_default;
 }
 
 
 
 /*
- * Components management
+ * Device management
  */
 
-static struct snd_stm_component *snd_stm_components;
-static int snd_stm_num_components;
-
-int __init snd_stm_components_init(struct snd_stm_component *components,
-		int num_components)
+static void dummy_release(struct device *dev)
 {
-	snd_stm_components = components;
-	snd_stm_num_components = num_components;
-
-	return 0;
 }
 
-struct snd_stm_component __init *snd_stm_components_get(const char *bus_id)
+int __init snd_stm_add_plaform_devices(struct platform_device **devices,
+		int cnt)
 {
+	int result = 0;
 	int i;
 
-	for (i = 0; i < snd_stm_num_components; i++)
-		if (strcmp(snd_stm_components[i].bus_id, bus_id) == 0)
-			return &snd_stm_components[i];
-
-	return NULL;
-}
-
-static int snd_stm_bus_id_match(struct device *device, void *bus_id)
-{
-	return strcmp(device->bus_id, bus_id) == 0;
-}
-
-struct device __init *snd_stm_device_get(const char *bus_id)
-{
-	return bus_find_device(&platform_bus_type, NULL,
-			(void *)bus_id, snd_stm_bus_id_match);
-}
-
-
-
-/*
- * Component capabilities access
- */
-
-int __init snd_stm_cap_set(struct snd_stm_component *component,
-		const char *name, union snd_stm_value value)
-{
-	int result = -1;
-	int i;
-
-	for (i = 0; i < component->num_caps; i++)
-		if (strcmp(name, component->caps[i].name) == 0) {
-			component->caps[i].value = value;
-			result = 0;
+	for (i = 0; i < cnt; i++) {
+		devices[i]->dev.release = dummy_release;
+		result = platform_device_register(devices[i]);
+		if (result != 0) {
+			while (--i >= 0)
+				platform_device_unregister(devices[i]);
 			break;
 		}
+	}
 
 	return result;
 }
 
-int __init snd_stm_cap_get(struct snd_stm_component *component,
-		const char *name, union snd_stm_value *value)
+void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
+		int cnt)
 {
-	int result = -1;
 	int i;
 
-	for (i = 0; i < component->num_caps; i++)
-		if (strcmp(name, component->caps[i].name) == 0) {
-			*value = component->caps[i].value;
-			result = 0;
-			break;
-		}
-
-	return result;
-}
-
-int __init snd_stm_cap_get_number(struct snd_stm_component *component,
-		const char *name, int *number)
-{
-	union snd_stm_value value;
-	int result = snd_stm_cap_get(component, name, &value);
-
-	*number = value.number;
-	return result;
+	for (i = 0; i < cnt; i++)
+		platform_device_unregister(devices[i]);
 }
 
-int __init snd_stm_cap_get_string(struct snd_stm_component *component,
-		const char *name, const char **string)
+static int snd_stm_bus_id_match(struct device *device, void *bus_id)
 {
-	union snd_stm_value value;
-	int result = snd_stm_cap_get(component, name, &value);
-
-	*string = value.string;
-	return result;
+	return strcmp(device->bus_id, bus_id) == 0;
 }
 
-int __init snd_stm_cap_get_range(struct snd_stm_component *component,
-		const char *name, int *from, int *to)
+struct device *snd_stm_find_device(struct bus_type *bus,
+		const char *bus_id)
 {
-	union snd_stm_value value;
-	int result = snd_stm_cap_get(component, name, &value);
-
-	*from = value.range.from;
-	*to = value.range.to;
-	return result;
+	if (bus == NULL)
+		bus = &platform_bus_type;
+	return bus_find_device(bus, NULL, (void *)bus_id, snd_stm_bus_id_match);
 }
 
-int __init snd_stm_cap_get_list(struct snd_stm_component *component,
-		const char *name, int **numbers, int *len)
-{
-	union snd_stm_value value;
-	int result = snd_stm_cap_get(component, name, &value);
-
-	*numbers = value.list.numbers;
-	*len = value.list.len;
-	return result;
-}
 
 
 
@@ -327,13 +259,11 @@ int  __init snd_stm_irq_request(struct platform_device *pdev,
 }
 
 int __init snd_stm_fdma_request(struct platform_device *pdev,
-		int *channel, struct stm_dma_req **request,
-		struct stm_dma_req_config *config)
+		unsigned int *channel)
 {
 	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
 	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
 	static const char *fdma_cap_hb[] = { STM_DMA_CAP_HIGH_BW, NULL };
-	struct resource *resource;
 
 	*channel = request_dma_bycap(fdmac_id, fdma_cap_lb, pdev->name);
 	if (*channel < 0) {
@@ -346,41 +276,9 @@ int __init snd_stm_fdma_request(struct platform_device *pdev,
 	}
 	snd_printd("FDMA channel: %d\n", *channel);
 
-	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
-			"initiator");
-	if (!resource) {
-		snd_stm_printe("Failed to platform_get_resource"
-				"(IORESOURCE_DMA, initiator)!\n");
-		return -ENODEV;
-	}
-	snd_printd("FDMA initiator: %u\n", resource->start);
-	config->initiator = resource->start;
-
-	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
-			"request_line");
-	if (!resource) {
-		snd_stm_printe("Failed to platform_get_resource"
-				"(IORESOURCE_DMA, request_line)!\n");
-		return -ENODEV;
-	}
-	snd_printd("FDMA request line: %u\n", resource->start);
-
-	*request = dma_req_config(*channel, resource->start, config);
-	if (!*request) {
-		snd_stm_printe("Failed to dma_req_config!\n");
-		return -EINVAL;
-	}
-
 	return 0;
 }
 
-void snd_stm_fdma_release(unsigned int channel,
-		struct stm_dma_req *request)
-{
-	dma_req_free(channel, request);
-	free_dma(channel);
-}
-
 
 
 /*
@@ -445,7 +343,7 @@ void snd_stm_info_unregister(struct snd_info_entry *entry)
 
 
 /*
- * PCM buffer memory mapping
+ * ALSA PCM buffer memory mapping
  */
 
 static struct page *snd_stm_mmap_nopage(struct vm_area_struct *area,
@@ -505,6 +403,105 @@ int snd_stm_mmap(struct snd_pcm_substream *substream,
 
 
 /*
+ * Common ALSA parameters constraints
+ */
+
+/*
+#define FIXED_TRANSFER_BYTES max_transfer_bytes > 16 ? 16 : max_transfer_bytes
+#define FIXED_TRANSFER_BYTES max_transfer_bytes
+*/
+
+#ifdef FIXED_TRANSFER_BYTES
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	int transfer_bytes = FIXED_TRANSFER_BYTES;
+
+	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u (FIXED)\n",
+			bytes_per_frame, max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_constraint_step(runtime, 0,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_transfer_bytes(0, max_transfer_bytes));
+}
+
+#else
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	unsigned int transfer_bytes;
+
+	for (transfer_bytes = bytes_per_frame;
+			transfer_bytes * 2 < max_transfer_bytes;
+			transfer_bytes *= 2)
+		;
+
+	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
+			max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+static int snd_stm_pcm_hw_rule_transfer_bytes(struct snd_pcm_hw_params *params,
+		struct snd_pcm_hw_rule *rule)
+{
+	int changed = 0;
+	unsigned int max_transfer_bytes = (unsigned int)rule->private;
+	struct snd_interval *period_bytes = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES);
+	struct snd_interval *frame_bits = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS);
+	unsigned int transfer_bytes, n;
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->min / 8,
+			max_transfer_bytes);
+	n = period_bytes->min % transfer_bytes;
+	if (n != 0 || period_bytes->openmin) {
+		period_bytes->min += transfer_bytes - n;
+		changed = 1;
+	}
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->max / 8,
+			max_transfer_bytes);
+	n = period_bytes->max % transfer_bytes;
+	if (n != 0 || period_bytes->openmax) {
+		period_bytes->max -= n;
+		changed = 1;
+	}
+
+	if (snd_interval_checkempty(period_bytes)) {
+		period_bytes->empty = 1;
+		return -EINVAL;
+	}
+
+	return changed;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_hw_rule_transfer_bytes,
+			(void *)max_transfer_bytes,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);
+}
+
+#endif
+
+
+
+/*
  * Common ALSA controls routines
  */
 
@@ -519,6 +516,69 @@ int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+
+int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_CON_NOT_COPYRIGHT |
+			IEC958_AES0_CON_EMPHASIS |
+			IEC958_AES0_CON_MODE;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |
+			IEC958_AES1_CON_ORIGINAL;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_CON_SOURCE |
+			IEC958_AES2_CON_CHANNEL;
+	ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS |
+			IEC958_AES3_CON_CLOCK;
+	ucontrol->value.iec958.status[4] = IEC958_AES4_CON_MAX_WORDLEN_24 |
+			IEC958_AES4_CON_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PRO_EMPHASIS |
+			IEC958_AES0_PRO_FREQ_UNLOCKED |
+			IEC958_AES0_PRO_FS;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
+			IEC958_AES1_PRO_USERBITS;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_PRO_SBITS |
+			IEC958_AES2_PRO_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
+		const struct snd_aes_iec958 *b)
+{
+	int result;
+
+	snd_assert(a != NULL, return -EINVAL);
+	snd_assert(b != NULL, return -EINVAL);
+
+	result = memcmp(a->status, b->status, sizeof(a->status));
+	if (result == 0)
+		result = memcmp(a->subcode, b->subcode, sizeof(a->subcode));
+	if (result == 0)
+		result = memcmp(a->dig_subframe, b->dig_subframe,
+				sizeof(a->dig_subframe));
+
+	return result;
+}
 
 
 /*
@@ -541,3 +601,41 @@ void snd_stm_hex_dump(void *data, int size)
 			printk(KERN_DEBUG "%s\n", line);
 	}
 }
+
+/* IEC958 structure dump */
+void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc)
+{
+	int i;
+	char line[54];
+	const unsigned char *data;
+
+	printk(KERN_DEBUG "                        "
+			"0  1  2  3  4  5  6  7  8  9\n");
+	data = vuc->status;
+	for (i = 0; i < 24; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p status    %02d:",
+					(unsigned char *)vuc + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 23)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	data = vuc->subcode;
+	for (i = 0; i < 147; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p subcode  %03d:",
+					(unsigned char *)vuc +
+					offsetof(struct snd_aes_iec958,
+					dig_subframe) + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 146)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	printk(KERN_DEBUG "%p dig_subframe: %02x %02x %02x %02x\n",
+			(unsigned char *)vuc +
+			offsetof(struct snd_aes_iec958, dig_subframe),
+			vuc->dig_subframe[0], vuc->dig_subframe[1],
+			vuc->dig_subframe[2], vuc->dig_subframe[3]);
+}
diff --git a/sound/soc/stm/common.h b/sound/soc/stm/common.h
index 5226457..71dba20 100644
--- a/sound/soc/stm/common.h
+++ b/sound/soc/stm/common.h
@@ -15,25 +15,19 @@
 #include <sound/pcm.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/stm.h>
 
 
 
 /*
- * Audio DAC control interface
+ * Audio frequency synthesizer description (platform data)
  */
 
-int snd_stm_dac_get_config(struct device *device,
-		unsigned long *pcm_format, unsigned int *oversampling);
-int snd_stm_dac_shut_down(struct device *device);
-int snd_stm_dac_wake_up(struct device *device);
-int snd_stm_dac_mute(struct device *device);
-int snd_stm_dac_unmute(struct device *device);
+struct snd_stm_fsynth_info {
+	const char *card_id;
 
-
-
-/*
- * Audio frequency synthesizer interface
- */
+	int channels_from, channels_to;
+};
 
 int snd_stm_fsynth_set_frequency(struct device *device, int channel,
 		int frequency);
@@ -44,112 +38,200 @@ int snd_stm_fsynth_add_adjustement_ctl(struct device *device, int channel,
 
 
 /*
- * Buffer memory mapping operation
+ * Converters (DAC, ADC, I2S-SPDIF etc.) control interface
  */
 
-int snd_stm_mmap(struct snd_pcm_substream *substream,
-		struct vm_area_struct *area);
+struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source);
+int snd_stm_conv_add_route_ctl(struct device *source,
+		struct snd_card *card, int card_device);
+
+unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv);
+int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv);
+
+int snd_stm_conv_enable(struct snd_stm_conv *conv);
+int snd_stm_conv_disable(struct snd_stm_conv *conv);
+int snd_stm_conv_mute(struct snd_stm_conv *conv);
+int snd_stm_conv_unmute(struct snd_stm_conv *conv);
 
 
 
 /*
- * Common ALSA controls routines
+ * Internal audio DAC description (platform data)
  */
 
-int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_info *uinfo);
+struct snd_stm_conv_internal_dac_info {
+	const char *name;
+
+	const char *card_id;
+	int card_device;
 
+	const char *source_bus_id;
+};
 
 
 /*
- * Cards management
+ * I2S to SPDIF converter description (platform data)
  */
 
-/* Card description */
+struct snd_stm_conv_i2s_spdif_info {
+	const char *name;
 
-struct snd_stm_card {
-	int index;              /* card number */
-	const char *id;         /* unique, 15 chars max (plus '\0' as 16th) */
-	const char *short_name; /* 31 chars max (plus '\0' as 32nd) */
-	const char *long_name;  /* 79 chars max (plus '\0' as 80th) */
+	const char *card_id;
+	int card_device;
+
+	const char *source_bus_id;
+
+	int full_channel_status;
 };
 
-/* Card list initialization/cleanup */
 
-int __init snd_stm_cards_init(const char *device, struct snd_stm_card *cards,
-		int num_cards);
-int __init snd_stm_cards_register(void);
-void snd_stm_cards_free(void);
 
-/* Card list access */
+/*
+ * PCM Player description (platform data)
+ */
 
-struct snd_card __init *snd_stm_cards_get(const char *id);
-struct snd_card __init *snd_stm_cards_default(const char **id);
+struct snd_stm_pcm_player_info {
+	const char *name;
+
+	const char *card_id;
+	int card_device;
+
+	const char *fsynth_bus_id;
+	int fsynth_output;
+
+	unsigned int channels_num;
+	unsigned int *channels;
+
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
+
+	int invert_sclk_edge_falling;
+};
 
 
 
 /*
- * Components
- *
- * Note that all component data and functions are marked
- * as a __init/__datainit, so are automatically cleaned
- * after initialization. THEY ARE NOT STATIC DATA!
+ * PCM Reader description (platform data)
  */
 
-/* Component description */
+struct snd_stm_pcm_reader_info {
+	const char *name;
+
+	const char *card_id;
+	int card_device;
 
-struct snd_stm_component {
-	const char *bus_id;
-	const char *short_name;
-	int num_caps;
-	struct snd_stm_cap *caps;
+	int channels_num;
+	int *channels;
+
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
 };
 
-/* Components list initialization */
 
-int __init snd_stm_components_init(struct snd_stm_component *components,
-		int num_components);
 
-/* Component & device access */
+/*
+ * SPDIF Player description (platform data)
+ */
+
+struct snd_stm_spdif_player_info {
+	const char *name;
 
-struct snd_stm_component __init *snd_stm_components_get(const char *bus_id);
-struct device __init *snd_stm_device_get(const char *bus_id);
+	const char *card_id;
+	int card_device;
 
-/* Component capabilities description */
+	const char *fsynth_bus_id;
+	int fsynth_output;
 
-union snd_stm_value {
-	int number;
-	const char *string;
-	struct {
-		int from;
-		int to;
-	} range;
-	struct {
-		int *numbers;
-		int len;
-	} list;
+	unsigned char fdma_initiator;
+	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
 };
 
-struct snd_stm_cap {
-	const char *name;
-	union snd_stm_value value;
+
+
+/*
+ * Buffer memory mapping operation
+ */
+
+int snd_stm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area);
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+
+int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+
+int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol);
+
+int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol);
+
+int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
+		const struct snd_aes_iec958 *b);
+
+
+
+/*
+ * Common ALSA parameters constraints
+ */
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes);
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes);
+
+
+
+/*
+ * Device management
+ */
+
+/* Add/remove a list of platform devices */
+int __init snd_stm_add_plaform_devices(struct platform_device **devices,
+		int cnt);
+void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
+		int cnt);
+
+/* Leave bus NULL to use default (platform) bus */
+struct device *snd_stm_find_device(struct bus_type *bus,
+		const char *bus_id);
+
+
+
+/*
+ * Components management
+ */
+
+/* Card description */
+
+struct snd_stm_card {
+	int index;              /* card number */
+	const char *id;         /* unique, 15 chars max (plus '\0' as 16th) */
+	const char *short_name; /* 31 chars max (plus '\0' as 32nd) */
+	const char *long_name;  /* 79 chars max (plus '\0' as 80th) */
 };
 
-/* Capabilities access */
+/* Card list initialization/cleanup */
 
-int __init snd_stm_cap_set(struct snd_stm_component *component,
-		const char *name, union snd_stm_value value);
-int __init snd_stm_cap_get(struct snd_stm_component *component,
-		const char *name, union snd_stm_value *value);
+int __init snd_stm_cards_init(const char *device, struct snd_stm_card *cards,
+		int num_cards);
+int __init snd_stm_cards_register(void);
+void snd_stm_cards_free(void);
 
-int __init snd_stm_cap_get_number(struct snd_stm_component *component,
-		const char *name, int *number);
-int __init snd_stm_cap_get_string(struct snd_stm_component *component,
-		const char *name, const char **string);
-int __init snd_stm_cap_get_range(struct snd_stm_component *component,
-		const char *name, int *from, int *to);
-int __init snd_stm_cap_get_list(struct snd_stm_component *component,
-		const char *name, int **numbers, int *len);
+/* Card list access */
+
+struct snd_card __init *snd_stm_cards_get(const char *id);
+struct snd_card __init *snd_stm_cards_default(void);
 
 
 
@@ -182,10 +264,8 @@ int __init snd_stm_irq_request(struct platform_device *pdev,
 #define snd_stm_irq_release(irq, dev_id) free_irq(irq, dev_id)
 
 int __init snd_stm_fdma_request(struct platform_device *pdev,
-		int *channel, struct stm_dma_req **request,
-		struct stm_dma_req_config *config);
-void snd_stm_fdma_release(unsigned int channel,
-		struct stm_dma_req *request);
+		unsigned int *channel);
+#define snd_stm_fdma_release(channel) free_dma(channel)
 
 
 
@@ -193,11 +273,17 @@ void snd_stm_fdma_release(unsigned int channel,
  * Drivers initialization/cleanup
  */
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 int __init snd_stm_stx710x_init(void);
+void __exit snd_stm_stx710x_cleanup(void);
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+int __init snd_stm_stx7111_init(void);
+void __exit snd_stm_stx7111_cleanup(void);
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 int __init snd_stm_stx7200_init(void);
+void __exit snd_stm_stx7200_cleanup(void);
 #endif
 
 int __init snd_stm_audio_outputs_init(void);
@@ -206,11 +292,17 @@ void snd_stm_audio_outputs_cleanup(void);
 int __init snd_stm_fsynth_init(void);
 void snd_stm_fsynth_cleanup(void);
 
-int __init snd_stm_dac_internal_init(void);
-void snd_stm_dac_internal_cleanup(void);
+int __init snd_stm_conv_init(void);
+void snd_stm_conv_cleanup(void);
+
+int __init snd_stm_conv_dummy_init(void);
+void snd_stm_conv_dummy_cleanup(void);
+
+int __init snd_stm_conv_internal_dac_init(void);
+void snd_stm_conv_internal_dac_cleanup(void);
 
-int __init snd_stm_i2s_spdif_converter_init(void);
-void snd_stm_i2s_spdif_converter_cleanup(void);
+int __init snd_stm_conv_i2s_spdif_init(void);
+void snd_stm_conv_i2s_spdif_cleanup(void);
 
 int __init snd_stm_pcm_player_init(void);
 void snd_stm_pcm_player_cleanup(void);
@@ -230,9 +322,10 @@ void snd_stm_synchro_cleanup(void);
  * Debug features
  */
 
-/* Memory dump function */
+/* Data dump functions */
 
 void snd_stm_hex_dump(void *data, int size);
+void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc);
 
 
 
diff --git a/sound/soc/stm/conv.c b/sound/soc/stm/conv.c
new file mode 100644
index 0000000..2ef0ba8
--- /dev/null
+++ b/sound/soc/stm/conv.c
@@ -0,0 +1,305 @@
+/*
+ *   STMicroelectronics System-on-Chips' generic converters infrastructure
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 2 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Converters infrastructure interface implementation
+ */
+
+#define CONVS_MAX 5 /* TODO: dynamic structure (really necessary???) */
+
+struct snd_stm_conv_links_list {
+	struct list_head list;
+
+	struct device *device;
+
+	int convs_num;
+	struct snd_stm_conv *convs[CONVS_MAX];
+
+	int conv_attached;
+
+	snd_stm_magic_field;
+};
+
+LIST_HEAD(snd_stm_conv_links); /* "Device->Converter" links list */
+DEFINE_SPINLOCK(snd_stm_conv_links_lock); /* Synchronises the links list */
+
+static inline struct snd_stm_conv_links_list *snd_stm_conv_find_link(
+		struct device *source) {
+	struct snd_stm_conv_links_list *entry;
+
+	list_for_each_entry(entry, &snd_stm_conv_links, list)
+		if (source == entry->device)
+			return entry;
+
+	return NULL;
+}
+
+int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source)
+{
+	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
+
+	snd_stm_printt("snd_stm_conv_attach(conv=%p, source=%p)\n",
+			conv, source);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	if (link) { /* Known device */
+		snd_stm_magic_assert(link, return -EINVAL);
+		snd_assert(link->convs_num < CONVS_MAX,
+				return -ENOMEM);
+		link->convs[link->convs_num++] = conv;
+	} else { /* New device */
+		link = kzalloc(sizeof(*link), GFP_KERNEL);
+		if (link == NULL)
+			return -ENOMEM;
+		snd_stm_magic_set(link);
+
+		link->device = source;
+		link->convs_num = 1;
+		link->convs[0] = conv;
+
+		list_add_tail(&link->list, &snd_stm_conv_links);
+	}
+
+	return 0;
+}
+
+struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source)
+{
+	struct snd_stm_conv_links_list *link;
+	struct snd_stm_conv *conv = NULL;
+
+	snd_stm_printt("snd_stm_conv_attach(source=%p)\n", source);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	link = snd_stm_conv_find_link(source);
+	conv = link ? link->convs[link->conv_attached] : NULL;
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return conv;
+}
+
+static int snd_stm_conv_route_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+	struct snd_stm_conv *conv;
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = link->convs_num;
+
+	if (uinfo->value.enumerated.item >= link->convs_num)
+		uinfo->value.enumerated.item = link->convs_num - 1;
+
+	conv = link->convs[uinfo->value.enumerated.item];
+	snprintf(uinfo->value.enumerated.name, 64, "%s", conv->name);
+
+	return 0;
+}
+
+static int snd_stm_conv_route_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_conv_route_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	ucontrol->value.enumerated.item[0] = link->conv_attached;
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_route_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	int changed;
+	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_conv_route_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_stm_magic_assert(link, return -EINVAL);
+
+	spin_lock(&snd_stm_conv_links_lock);
+
+	changed = (ucontrol->value.enumerated.item[0] != link->conv_attached);
+	link->conv_attached = ucontrol->value.enumerated.item[0];
+
+	spin_unlock(&snd_stm_conv_links_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new snd_stm_conv_route_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Playback Route",
+	.info = snd_stm_conv_route_info,
+	.get = snd_stm_conv_route_get,
+	.put = snd_stm_conv_route_put,
+};
+
+int snd_stm_conv_add_route_ctl(struct device *source,
+		struct snd_card *card, int card_device)
+{
+	int result = 0;
+	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
+
+	snd_stm_printt("snd_stm_conv_add_route_ctl(source=%p, card=%p, "
+			"cards_device=%d)\n", source, card, card_device);
+
+	/* Not synchronised intentionally (doesn't have to be...) */
+
+	if (link != NULL) {
+		snd_stm_magic_assert(link, return -EINVAL);
+
+		if (link->convs_num > 1) {
+			snd_stm_conv_route_ctl.device = card_device;
+			result = snd_ctl_add(card,
+					snd_ctl_new1(&snd_stm_conv_route_ctl,
+					link));
+
+			/* TODO: index per card */
+			snd_stm_conv_route_ctl.index++;
+		}
+	} else {
+		snd_stm_printt("Source device '%s' not found...\n",
+				source->bus_id);
+	}
+
+	return result;
+}
+
+
+
+/*
+ * Converter control interface implementation
+ */
+
+unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv)
+{
+	snd_stm_printt("snd_stm_conv_get_format(conv=%p)\n", conv);
+
+	snd_assert(conv->get_format != NULL, return -EINVAL);
+
+	return conv->get_format(conv);
+}
+
+int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv)
+{
+	snd_stm_printt("snd_stm_conv_get_oversampling(conv=%p)\n", conv);
+
+	snd_assert(conv->get_oversampling != NULL, return -EINVAL);
+
+	return conv->get_oversampling(conv);
+}
+
+int snd_stm_conv_enable(struct snd_stm_conv *conv)
+{
+	int result = 0;
+
+	snd_stm_printt("snd_stm_conv_enable(conv=%p)\n", conv);
+
+	snd_assert(conv->enable != NULL, return -EINVAL);
+
+	if (conv->master)
+		result = snd_stm_conv_enable(conv->master);
+
+	return result ? result : conv->enable(conv);
+}
+
+int snd_stm_conv_disable(struct snd_stm_conv *conv)
+{
+	int result = 0;
+
+	snd_stm_printt("snd_stm_conv_disable(conv=%p)\n", conv);
+
+	snd_assert(conv->disable != NULL, return -EINVAL);
+
+	if (conv->master)
+		result = snd_stm_conv_disable(conv->master);
+
+	return result ? result : conv->disable(conv);
+}
+
+int snd_stm_conv_mute(struct snd_stm_conv *conv)
+{
+	snd_stm_printt("snd_stm_conv_mute(conv=%p)\n", conv);
+
+	snd_assert(conv->mute != NULL, return -EINVAL);
+
+	return conv->mute(conv);
+}
+
+int snd_stm_conv_unmute(struct snd_stm_conv *conv)
+{
+	snd_stm_printt("snd_stm_conv_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv->unmute != NULL, return -EINVAL);
+
+	return conv->unmute(conv);
+}
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_init(void)
+{
+	return 0;
+}
+
+void snd_stm_conv_cleanup(void)
+{
+	struct snd_stm_conv_links_list *entry, *next;
+
+	list_for_each_entry_safe(entry, next, &snd_stm_conv_links, list) {
+		snd_stm_magic_clear(entry);
+		list_del(&entry->list);
+		kfree(entry);
+	};
+}
diff --git a/sound/soc/stm/conv_dummy.c b/sound/soc/stm/conv_dummy.c
new file mode 100644
index 0000000..0773e51
--- /dev/null
+++ b/sound/soc/stm/conv_dummy.c
@@ -0,0 +1,160 @@
+/*
+ *   STMicroelectronics System-on-Chips' internal audio DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <sound/stm.h>
+
+#include "common.h"
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_dummy_get_format(struct snd_stm_conv
+		*conv)
+{
+	return (SND_STM_FORMAT__RIGHT_JUSTIFIED |
+			SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS);
+}
+
+static int snd_stm_conv_dummy_get_oversampling(struct snd_stm_conv *conv)
+{
+	return 64;
+}
+
+static int snd_stm_conv_dummy_enable(struct snd_stm_conv *conv)
+{
+	snd_printk("Waking up dummy DAC '%s'.\n", conv->name);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_disable(struct snd_stm_conv *conv)
+{
+	snd_printk("Setting dummy DAC '%s' into reset mode.\n", conv->name);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_mute(struct snd_stm_conv *conv)
+{
+	snd_printk("Muting dummy DAC '%s'.\n", conv->name);
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_unmute(struct snd_stm_conv *conv)
+{
+	snd_printk("Unmuting dummy DAC '%s'.\n", conv->name);
+
+	return 0;
+}
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_conv_dummy_probe(struct platform_device *pdev)
+{
+	int result;
+	struct snd_stm_conv *conv;
+	const char *source_bus_id = pdev->dev.platform_data;
+	struct device *player_device;
+	static int index;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	conv = kzalloc(sizeof(*conv) + 25, GFP_KERNEL);
+	if (!conv) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		return -ENOMEM;
+	}
+
+	conv->name = (char *)conv + sizeof(*conv);
+	sprintf((char *)conv->name, "Dummy converter %x", index++);
+
+	conv->get_format =
+		snd_stm_conv_dummy_get_format;
+	conv->get_oversampling =
+		snd_stm_conv_dummy_get_oversampling;
+	conv->enable = snd_stm_conv_dummy_enable;
+	conv->disable = snd_stm_conv_dummy_disable;
+	conv->mute = snd_stm_conv_dummy_mute;
+	conv->unmute = snd_stm_conv_dummy_unmute;
+
+	snd_printd("This dummy DAC is attached to PCM player '%s'.\n",
+			source_bus_id);
+	player_device = snd_stm_find_device(NULL, source_bus_id);
+	snd_assert(player_device != NULL, return -EINVAL);
+	result = snd_stm_conv_attach(conv, player_device);
+	if (result < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		return -EINVAL;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, conv);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_conv_dummy_remove(struct platform_device *pdev)
+{
+	kfree(platform_get_drvdata(pdev));
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_dummy_driver = {
+	.driver = {
+		.name = "conv_dummy",
+	},
+	.probe = snd_stm_conv_dummy_probe,
+	.remove = snd_stm_conv_dummy_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_dummy_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_dummy_driver);
+}
+
+void snd_stm_conv_dummy_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_conv_dummy_driver);
+}
diff --git a/sound/soc/stm/conv_i2s-spdif.c b/sound/soc/stm/conv_i2s-spdif.c
new file mode 100644
index 0000000..98cc071
--- /dev/null
+++ b/sound/soc/stm/conv_i2s-spdif.c
@@ -0,0 +1,749 @@
+/*
+ *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#undef TRACE /* See common.h debug features */
+#define MAGIC 3 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define DEFAULT_OVERSAMPLING 128
+
+
+
+/*
+ * Converter instance structure
+ */
+
+struct snd_stm_conv_i2s_spdif {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	/* System informations */
+	struct snd_stm_conv_i2s_spdif_info *info;
+	struct device *device;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Default configuration */
+	struct snd_aes_iec958 iec958_default;
+	spinlock_t iec958_default_lock; /* Protects iec958_default */
+
+	/* Runtime data */
+	int enabled;
+	struct snd_stm_conv *attached_conv;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Internal routines
+ */
+
+/* Such a empty (zeroed) structure is pretty useful later... ;-) */
+static struct snd_aes_iec958 snd_stm_conv_i2s_spdif_iec958_zeroed;
+
+
+
+#define CHA_STA_TRIES 50000
+
+static int snd_stm_conv_i2s_spdif_iec958_set(struct snd_stm_conv_i2s_spdif
+		*conv_i2s_spdif, struct snd_aes_iec958 *iec958)
+{
+	int i, j, ok;
+	unsigned long status[6];
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif=%p, "
+			"iec958=%p)\n", conv_i2s_spdif, iec958);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+
+	/* I2S to SPDIF converter should be used only for playing
+	 * PCM (non compressed) data, so validity bit should be always
+	 * zero... (it means "valid linear PCM data") */
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_VAL, VALIDITY_BITS, 0);
+
+	/* Well... User data bit... Frankly speaking there is no way
+	 * of correctly setting them with a mechanism provided by
+	 * converter hardware, so it is better not to do this at all... */
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_DATA,
+			USER_DATA_BITS, 0);
+	snd_assert(memcmp(snd_stm_conv_i2s_spdif_iec958_zeroed.subcode,
+			iec958->subcode, sizeof(iec958->subcode)) == 0);
+
+	if (conv_i2s_spdif->info->full_channel_status == 0) {
+		/* Converter hardware by default puts every single bit of
+		 * status to separate SPDIF subframe (instead of putting
+		 * the same bit to both left and right subframes).
+		 * So we have to prepare a "duplicated" version of
+		 * status bits... Note that in such way status will be
+		 * transmitted twice in every block! This is definitely
+		 * out of spec, but fortunately most of receivers pay
+		 * attention only to first 36 bits... */
+
+		for (i = 0; i < 6; i++) {
+			unsigned long word = 0;
+
+			for (j = 1; j >= 0; j--) {
+				unsigned char byte = iec958->status[i * 2 + j];
+				int k;
+
+				for (k = 0; k < 8; k++) {
+					word |= ((byte & 0x80) != 0);
+					if (!(j == 0 && k == 7)) {
+						word <<= 2;
+						byte <<= 1;
+					}
+				}
+			}
+
+			status[i] = word | (word << 1);
+		}
+	} else {
+		/* Fortunately in some hardware there is a "sane" mode
+		 * of channel status registers operation... :-) */
+
+		for (i = 0; i < 6; i++)
+			status[i] = iec958->status[i * 4] |
+					iec958->status[i * 4 + 1] << 8 |
+					iec958->status[i * 4 + 2] << 16 |
+					iec958->status[i * 4 + 3] << 24;
+	}
+
+	/* Set converter's channel status registers - they are realised
+	 * in such a ridiculous way that write to them is enabled only
+	 * in (about) 300us time window after CHL_STS_BUFF_EMPTY bit
+	 * is asserted... And this happens once every 2ms (only when
+	 * converter is enabled and gets data...) */
+
+	ok = 0;
+	for (i = 0; i < CHA_STA_TRIES; i++) {
+		if (REGFIELD_PEEK(conv_i2s_spdif->base,
+				AUD_SPDIFPC_STA, CHL_STS_BUFF_EMPTY)) {
+			for (j = 0; j < 6; j++)
+				REGISTER_POKE_N(conv_i2s_spdif->base,
+						AUD_SPDIFPC_CHA_STA,
+						j, status[j]);
+			ok = 1;
+			for (j = 0; j < 6; j++)
+				if (REGISTER_PEEK_N(conv_i2s_spdif->base,
+						AUD_SPDIFPC_CHA_STA,
+						j) != status[j]) {
+					ok = 0;
+					break;
+				}
+			if (ok)
+				break;
+		}
+	}
+	if (!ok) {
+		snd_stm_printe("WARNING! Failed to set channel status registers"
+				" for converter %s! (tried %d times)\n",
+				conv_i2s_spdif->device->bus_id, i);
+		return -EINVAL;
+	}
+
+	snd_stm_printt("Channel status registers set successfully "
+			"in %i tries.", i);
+
+	/* Set SPDIF player's VUC registers (these are used only
+	 * for mute data formatting, and it should never happen ;-) */
+
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			VAL_LEFT, 0);
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			VAL_RIGHT, 0);
+
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			DATA_LEFT, 0);
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			DATA_RIGHT, 0);
+
+	/* And this time the problem is that SPDIF player lets
+	 * to set only first 36 bits of channel status bits...
+	 * Hopefully no one needs more ever ;-) And well - at least
+	 * it puts channel status bits to both subframes :-) */
+	status[0] = iec958->status[0] | iec958->status[1] << 8 |
+		iec958->status[2] << 16 | iec958->status[3] << 24;
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CL1,
+			CHANNEL_STATUS, status[0]);
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			CH_STA_LEFT, iec958->status[4] & 0xf);
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CR1,
+			CH_STA, status[0]);
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
+			CH_STA_RIGHT, iec958->status[4] & 0xf);
+
+	return 0;
+}
+
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_i2s_spdif_get_format(struct snd_stm_conv
+		*conv)
+{
+	snd_stm_printt("snd_stm_conv_i2s_spdif_get_format(conv=%p)\n", conv);
+
+	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS);
+}
+
+static int snd_stm_conv_i2s_spdif_get_oversampling(struct snd_stm_conv *conv)
+{
+	int oversampling = 0;
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+			struct snd_stm_conv_i2s_spdif, conv);
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_get_oversampling(conv=%p)\n",
+			conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+
+	if (conv_i2s_spdif->attached_conv)
+		oversampling = snd_stm_conv_get_oversampling(
+				conv_i2s_spdif->attached_conv);
+
+	if (oversampling == 0)
+		oversampling = DEFAULT_OVERSAMPLING;
+
+	return oversampling;
+}
+
+static int snd_stm_conv_i2s_spdif_enable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+			struct snd_stm_conv_i2s_spdif, conv);
+	int oversampling;
+	struct snd_aes_iec958 iec958;
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_enable(conv=%p)\n", conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
+
+	snd_stm_printt("Enabling I2S to SPDIF converter '%s'.\n",
+			conv_i2s_spdif->device->bus_id);
+
+	conv_i2s_spdif->attached_conv =
+			snd_stm_conv_get_attached(conv_i2s_spdif->device);
+	if (conv_i2s_spdif->attached_conv) {
+		int result = snd_stm_conv_enable(conv_i2s_spdif->attached_conv);
+		if (result != 0) {
+			snd_stm_printe("Can't enable attached converter!\n");
+			return result;
+		}
+	}
+
+	oversampling = snd_stm_conv_i2s_spdif_get_oversampling(conv);
+	snd_assert(oversampling > 0, return -EINVAL);
+	snd_assert((oversampling % 128) == 0, return -EINVAL);
+
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, ENABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RUNNING) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, ENABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, AUDIO_WORD_SIZE,
+					24_BITS) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, ENABLED));
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
+			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, PCM) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, ROUNDING,
+					NO_ROUNDING));
+	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL, DIVIDER,
+			oversampling / 128);
+
+	/* Full channel status processing - an undocumented feature that
+	 * exists in some hardware... Normally channel status registers
+	 * provides bits for each subframe, so only for 96 frames (a half
+	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
+	 * enables a mode in which channel status bits in L/R subframes
+	 * are identical, and whole block is served... */
+	if (conv_i2s_spdif->info->full_channel_status)
+		REGFIELD_SET(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
+				CHA_STA_BITS, FRAME);
+
+	spin_lock(&conv_i2s_spdif->iec958_default_lock);
+	iec958 = conv_i2s_spdif->iec958_default;
+	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
+	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif, &iec958) != 0)
+		snd_stm_printe("WARNING! Can't set channel status "
+				"registers!\n");
+
+	conv_i2s_spdif->enabled = 1;
+
+	return 0;
+}
+
+static int snd_stm_conv_i2s_spdif_disable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+			struct snd_stm_conv_i2s_spdif, conv);
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_disable(conv=%p)\n", conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
+
+	snd_stm_printt("Disabling I2S to SPDIF converter '%s'\n",
+			conv_i2s_spdif->device->bus_id);
+
+	if (conv_i2s_spdif->attached_conv) {
+		int result = snd_stm_conv_disable(
+				conv_i2s_spdif->attached_conv);
+
+		if (result != 0) {
+			snd_stm_printe("Can't disable attached converter!\n");
+			return result;
+		}
+	}
+
+	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif,
+			&snd_stm_conv_i2s_spdif_iec958_zeroed) != 0)
+		snd_stm_printe("WARNING! Failed to clear channel status "
+				"registers!\n");
+
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
+			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
+
+	conv_i2s_spdif->enabled = 0;
+
+	return 0;
+}
+
+static int snd_stm_conv_i2s_spdif_mute(struct snd_stm_conv *conv)
+{
+	int result = 0;
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+			struct snd_stm_conv_i2s_spdif, conv);
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_mute(conv=%p)\n", conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
+
+	if (conv_i2s_spdif->attached_conv)
+		result = snd_stm_conv_mute(conv_i2s_spdif->attached_conv);
+
+	return result;
+}
+
+static int snd_stm_conv_i2s_spdif_unmute(struct snd_stm_conv *conv)
+{
+	int result = 0;
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+			struct snd_stm_conv_i2s_spdif, conv);
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
+
+	if (conv_i2s_spdif->attached_conv)
+		result = snd_stm_conv_unmute(conv_i2s_spdif->attached_conv);
+
+	return result;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_conv_i2s_spdif_ctl_default_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
+			snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+
+	spin_lock(&conv_i2s_spdif->iec958_default_lock);
+	ucontrol->value.iec958 = conv_i2s_spdif->iec958_default;
+	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_i2s_spdif_ctl_default_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
+			snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+
+	spin_lock(&conv_i2s_spdif->iec958_default_lock);
+	if (snd_stm_iec958_cmp(&conv_i2s_spdif->iec958_default,
+				&ucontrol->value.iec958) != 0) {
+		conv_i2s_spdif->iec958_default = ucontrol->value.iec958;
+		changed = 1;
+	}
+	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new __initdata snd_stm_conv_i2s_spdif_ctls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_iec958_info,
+		.get = snd_stm_conv_i2s_spdif_ctl_default_get,
+		.put = snd_stm_conv_i2s_spdif_ctl_default_put,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_con,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_pro,
+	},
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r) \
+		snd_iprintf(buffer, "AUD_SPDIFPC_%s (offset 0x%03x) =" \
+				" 0x%08x\n", __stringify(r), \
+				AUD_SPDIFPC_##r, \
+				REGISTER_PEEK(conv_i2s_spdif->base, \
+				AUD_SPDIFPC_##r))
+
+static void snd_stm_conv_i2s_spdif_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
+		entry->private_data;
+	int i;
+
+	snd_assert(conv_i2s_spdif, return);
+	snd_stm_magic_assert(conv_i2s_spdif, return);
+
+	DUMP_REGISTER(CFG);
+	DUMP_REGISTER(STA);
+	DUMP_REGISTER(IT_EN);
+	DUMP_REGISTER(ITS);
+	DUMP_REGISTER(IT_CLR);
+	DUMP_REGISTER(VAL);
+	DUMP_REGISTER(DATA);
+	for (i = 0; i <= 5; i++)
+		snd_iprintf(buffer, "AUD_SPDIFPC_CHA_STA%d_CHANNEL_STATUS_BITS"
+				" (offset 0x%03x) = 0x%08x\n",
+				i, AUD_SPDIFPC_CHA_STA(i),
+				REGISTER_PEEK_N(conv_i2s_spdif->base,
+				AUD_SPDIFPC_CHA_STA, i));
+	DUMP_REGISTER(CTRL);
+	DUMP_REGISTER(SPDIFSTA);
+	DUMP_REGISTER(PAUSE);
+	DUMP_REGISTER(DATA_BURST);
+	DUMP_REGISTER(PA_PB);
+	DUMP_REGISTER(PC_PD);
+	DUMP_REGISTER(CL1);
+	DUMP_REGISTER(CR1);
+	DUMP_REGISTER(SUV);
+}
+
+static int snd_stm_conv_i2s_spdif_register(struct snd_device *snd_device)
+{
+	int result;
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
+
+	/* Initialize converter's input & SPDIF player as disabled */
+
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
+			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_i2s_spdif->proc_entry,
+			conv_i2s_spdif->device->bus_id,
+			snd_stm_conv_i2s_spdif_dump_registers,
+			conv_i2s_spdif);
+
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(conv_i2s_spdif->device,
+			snd_device->card, conv_i2s_spdif->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	return 0;
+}
+
+static int snd_stm_conv_i2s_spdif_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_i2s_spdif->proc_entry);
+
+	/* Power done mode, just to be sure :-) */
+
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
+			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
+	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
+			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_i2s_spdif_snd_device_ops = {
+	.dev_register = snd_stm_conv_i2s_spdif_register,
+	.dev_disconnect = snd_stm_conv_i2s_spdif_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_conv_i2s_spdif_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_i2s_spdif_info *conv_i2s_spdif_info =
+			pdev->dev.platform_data;
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif;
+	struct snd_card *card;
+	struct device *player_device;
+	int i;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(conv_i2s_spdif_info != NULL, return -EINVAL);
+
+	conv_i2s_spdif = kzalloc(sizeof(*conv_i2s_spdif), GFP_KERNEL);
+	if (!conv_i2s_spdif) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_i2s_spdif);
+	conv_i2s_spdif->info = conv_i2s_spdif_info;
+	conv_i2s_spdif->device = &pdev->dev;
+	spin_lock_init(&conv_i2s_spdif->iec958_default_lock);
+
+	/* Converter interface initialization */
+
+	conv_i2s_spdif->conv.name = conv_i2s_spdif_info->name;
+	conv_i2s_spdif->conv.get_format = snd_stm_conv_i2s_spdif_get_format;
+	conv_i2s_spdif->conv.get_oversampling =
+			snd_stm_conv_i2s_spdif_get_oversampling;
+	conv_i2s_spdif->conv.enable = snd_stm_conv_i2s_spdif_enable;
+	conv_i2s_spdif->conv.disable = snd_stm_conv_i2s_spdif_disable;
+	conv_i2s_spdif->conv.mute = snd_stm_conv_i2s_spdif_mute;
+	conv_i2s_spdif->conv.unmute = snd_stm_conv_i2s_spdif_unmute;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &conv_i2s_spdif->mem_region,
+			&conv_i2s_spdif->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* Get connections */
+
+	snd_assert(conv_i2s_spdif_info->card_id, return -EINVAL);
+	card = snd_stm_cards_get(conv_i2s_spdif_info->card_id);
+	snd_assert(card, return -EINVAL);
+	snd_printd("This I2S-SPDIF converter will be a member of a card "
+			"'%s'.\n", card->id);
+
+	snd_assert(conv_i2s_spdif_info->source_bus_id != NULL,
+			return -EINVAL);
+	snd_printd("This I2S-SPDIF converter is attached to PCM player '%s'.\n",
+			conv_i2s_spdif_info->source_bus_id);
+	player_device = snd_stm_find_device(NULL,
+			conv_i2s_spdif_info->source_bus_id);
+	snd_assert(player_device != NULL, return -EINVAL);
+	result = snd_stm_conv_attach(&conv_i2s_spdif->conv, player_device);
+	if (result < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_i2s_spdif,
+			&snd_stm_conv_i2s_spdif_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA controls */
+
+	result = 0;
+	for (i = 0; i < ARRAY_SIZE(snd_stm_conv_i2s_spdif_ctls); i++) {
+		snd_stm_conv_i2s_spdif_ctls[i].device =
+				conv_i2s_spdif->info->card_device;
+		result |= snd_ctl_add(card,
+				snd_ctl_new1(&snd_stm_conv_i2s_spdif_ctls[i],
+				conv_i2s_spdif));
+		/* TODO: index per card */
+		snd_stm_conv_i2s_spdif_ctls[i].index++;
+	}
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA controls!\n");
+		goto error_controls;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, &conv_i2s_spdif->conv);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return result;
+
+error_controls:
+error_device:
+error_attach:
+	snd_stm_memory_release(conv_i2s_spdif->mem_region,
+			conv_i2s_spdif->base);
+error_memory_request:
+	snd_stm_magic_clear(conv_i2s_spdif);
+	kfree(conv_i2s_spdif);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_i2s_spdif_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
+			container_of(platform_get_drvdata(pdev),
+			struct snd_stm_conv_i2s_spdif, conv);
+
+	snd_assert(conv_i2s_spdif, return -EINVAL);
+	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
+
+	snd_stm_memory_release(conv_i2s_spdif->mem_region,
+			conv_i2s_spdif->base);
+
+	snd_stm_magic_clear(conv_i2s_spdif);
+	kfree(conv_i2s_spdif);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_i2s_spdif_driver = {
+	.driver = {
+		.name = "conv_i2s-spdif",
+	},
+	.probe = snd_stm_conv_i2s_spdif_probe,
+	.remove = snd_stm_conv_i2s_spdif_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_i2s_spdif_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_i2s_spdif_driver);
+}
+
+void snd_stm_conv_i2s_spdif_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_conv_i2s_spdif_driver);
+}
diff --git a/sound/soc/stm/conv_internal_dac.c b/sound/soc/stm/conv_internal_dac.c
new file mode 100644
index 0000000..42dad93
--- /dev/null
+++ b/sound/soc/stm/conv_internal_dac.c
@@ -0,0 +1,509 @@
+/*
+ *   STMicroelectronics System-on-Chips' internal audio DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#undef TRACE   /* See common.h debug features */
+#define MAGIC 3 /* See common.h debug features */
+#include "common.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
+#define OVERSAMPLING 256
+
+
+
+/*
+ * Internal DAC instance structure
+ */
+
+struct snd_stm_conv_internal_dac {
+	/* Generic converter interface */
+	struct snd_stm_conv conv;
+
+	/* System informations */
+	const char *bus_id;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Runtime data */
+	int enabled;
+	int muted_by_source;
+	int muted_by_user;
+	spinlock_t status_lock; /* Protects enabled & muted_by_* */
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_internal_dac_get_format(struct snd_stm_conv
+		*conv)
+{
+	snd_stm_printt("snd_stm_conv_internal_dac_get_format(conv=%p)\n", conv);
+
+	return FORMAT;
+}
+
+static int snd_stm_conv_internal_dac_get_oversampling(struct snd_stm_conv *conv)
+{
+	snd_stm_printt("snd_stm_conv_internal_dac_get_oversampling(conv=%p)\n",
+			conv);
+
+	return OVERSAMPLING;
+}
+
+static int snd_stm_conv_internal_dac_enable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
+			struct snd_stm_conv_internal_dac, conv);
+
+	snd_stm_printt("snd_stm_conv_internal_dac_enable(conv=%p)\n", conv);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
+
+	snd_stm_printt("Enabling DAC %s's digital part. (still muted)\n",
+			conv_internal_dac->bus_id);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NSB, NORMAL);
+	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, NORMAL);
+
+	conv_internal_dac->enabled = 1;
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_internal_dac_disable(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
+			struct snd_stm_conv_internal_dac, conv);
+
+	snd_stm_printt("snd_stm_conv_internal_dac_disable(conv=%p)\n", conv);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(conv_internal_dac->enabled, return -EINVAL);
+
+	snd_stm_printt("Disabling DAC %s's digital part.\n",
+			conv_internal_dac->bus_id);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, RESET);
+	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+			NSB, POWER_DOWN);
+
+	conv_internal_dac->enabled = 0;
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_internal_dac_mute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
+			struct snd_stm_conv_internal_dac, conv);
+
+	snd_stm_printt("snd_stm_conv_internal_dac_mute(conv=%p)\n", conv);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(conv_internal_dac->enabled, return -EINVAL);
+
+	snd_stm_printt("Muting DAC %s.\n", conv_internal_dac->bus_id);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	conv_internal_dac->muted_by_source = 1;
+	if (!conv_internal_dac->muted_by_user)
+		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+				SOFTMUTE, MUTE);
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_internal_dac_unmute(struct snd_stm_conv *conv)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
+			struct snd_stm_conv_internal_dac, conv);
+
+	snd_stm_printt("snd_stm_conv_internal_dac_unmute(conv=%p)\n", conv);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(conv_internal_dac->enabled, return -EINVAL);
+
+	snd_stm_printt("Unmuting DAC %s.\n", conv_internal_dac->bus_id);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	conv_internal_dac->muted_by_source = 0;
+	if (!conv_internal_dac->muted_by_user)
+		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+				SOFTMUTE, NORMAL);
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_conv_internal_dac_ctl_mute_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+			snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_get(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	ucontrol->value.integer.value[0] = !conv_internal_dac->muted_by_user;
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return 0;
+}
+
+static int snd_stm_conv_internal_dac_ctl_mute_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+			snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+
+	spin_lock(&conv_internal_dac->status_lock);
+
+	if (ucontrol->value.integer.value[0] !=
+			!conv_internal_dac->muted_by_user) {
+		changed = 1;
+
+		conv_internal_dac->muted_by_user =
+				!ucontrol->value.integer.value[0];
+
+		if (conv_internal_dac->enabled &&
+				conv_internal_dac->muted_by_user &&
+				!conv_internal_dac->muted_by_source)
+			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+					SOFTMUTE, MUTE);
+		else if (conv_internal_dac->enabled &&
+				!conv_internal_dac->muted_by_user &&
+				!conv_internal_dac->muted_by_source)
+			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+					SOFTMUTE, NORMAL);
+	}
+
+	spin_unlock(&conv_internal_dac->status_lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new __initdata snd_stm_conv_dac_internal_ctl_mute = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master Playback Switch",
+	.info = snd_stm_ctl_boolean_info,
+	.get = snd_stm_conv_internal_dac_ctl_mute_get,
+	.put = snd_stm_conv_internal_dac_ctl_mute_put,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_conv_internal_dac_dump_registers(
+		struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+		entry->private_data;
+
+	snd_assert(conv_internal_dac, return);
+	snd_stm_magic_assert(conv_internal_dac, return);
+
+	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
+			REGISTER_PEEK(conv_internal_dac->base,
+			AUDCFG_ADAC_CTRL));
+}
+
+static int snd_stm_conv_internal_dac_register(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+			snd_device->device_data;
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
+
+	/* Initialize DAC with digital part down, analog up and muted */
+
+	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, NORMAL) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, NORMAL));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_internal_dac->proc_entry,
+			conv_internal_dac->bus_id,
+			snd_stm_conv_internal_dac_dump_registers,
+			conv_internal_dac);
+
+	return 0;
+}
+
+static int snd_stm_conv_internal_dac_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+			snd_device->device_data;
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_internal_dac->proc_entry);
+
+	/* Global power done & mute mode */
+
+	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
+			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_internal_dac_snd_device_ops = {
+	.dev_register = snd_stm_conv_internal_dac_register,
+	.dev_disconnect = snd_stm_conv_internal_dac_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int __init snd_stm_conv_internal_dac_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_internal_dac_info *conv_internal_dac_info =
+			pdev->dev.platform_data;
+	struct snd_stm_conv_internal_dac *conv_internal_dac;
+	struct snd_card *card;
+	struct device *player_device;
+
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(conv_internal_dac_info != NULL, return -EINVAL);
+
+	conv_internal_dac = kzalloc(sizeof(*conv_internal_dac), GFP_KERNEL);
+	if (!conv_internal_dac) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_internal_dac);
+	conv_internal_dac->bus_id = pdev->dev.bus_id;
+	spin_lock_init(&conv_internal_dac->status_lock);
+
+	/* Converter interface initialization */
+
+	conv_internal_dac->conv.name = conv_internal_dac_info->name;
+	conv_internal_dac->conv.get_format =
+			snd_stm_conv_internal_dac_get_format;
+	conv_internal_dac->conv.get_oversampling =
+			snd_stm_conv_internal_dac_get_oversampling;
+	conv_internal_dac->conv.enable = snd_stm_conv_internal_dac_enable;
+	conv_internal_dac->conv.disable = snd_stm_conv_internal_dac_disable;
+	conv_internal_dac->conv.mute = snd_stm_conv_internal_dac_mute;
+	conv_internal_dac->conv.unmute = snd_stm_conv_internal_dac_unmute;
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &conv_internal_dac->mem_region,
+			&conv_internal_dac->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* Get connections */
+
+	snd_assert(conv_internal_dac_info->card_id, return -EINVAL);
+	card = snd_stm_cards_get(conv_internal_dac_info->card_id);
+	snd_assert(card, return -EINVAL);
+	snd_printd("This DAC will be a member of a card '%s'.\n", card->id);
+
+	snd_assert(conv_internal_dac_info->source_bus_id != NULL,
+			return -EINVAL);
+	snd_printd("This DAC is attached to PCM player '%s'.\n",
+			conv_internal_dac_info->source_bus_id);
+	player_device = snd_stm_find_device(NULL,
+			conv_internal_dac_info->source_bus_id);
+	snd_assert(player_device != NULL, return -EINVAL);
+	result = snd_stm_conv_attach(&conv_internal_dac->conv, player_device);
+	if (result < 0) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_internal_dac,
+			&snd_stm_conv_internal_dac_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Create ALSA control */
+
+	snd_stm_conv_dac_internal_ctl_mute.device =
+			conv_internal_dac_info->card_device;
+	result = snd_ctl_add(card,
+			snd_ctl_new1(&snd_stm_conv_dac_internal_ctl_mute,
+			conv_internal_dac));
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA control!\n");
+		goto error_control;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, &conv_internal_dac->conv);
+
+	snd_printd("--- Probed successfully!\n");
+
+	return 0;
+
+error_control:
+error_device:
+error_attach:
+	snd_stm_memory_release(conv_internal_dac->mem_region,
+			conv_internal_dac->base);
+error_memory_request:
+	snd_stm_magic_clear(conv_internal_dac);
+	kfree(conv_internal_dac);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_internal_dac_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_internal_dac *conv_internal_dac =
+			container_of(platform_get_drvdata(pdev),
+			struct snd_stm_conv_internal_dac, conv);
+
+	snd_assert(conv_internal_dac, return -EINVAL);
+	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
+
+	snd_stm_memory_release(conv_internal_dac->mem_region,
+			conv_internal_dac->base);
+
+	snd_stm_magic_clear(conv_internal_dac);
+	kfree(conv_internal_dac);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_internal_dac_driver = {
+	.driver = {
+		.name = "conv_internal_dac",
+	},
+	.probe = snd_stm_conv_internal_dac_probe,
+	.remove = snd_stm_conv_internal_dac_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int __init snd_stm_conv_internal_dac_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_internal_dac_driver);
+}
+
+void snd_stm_conv_internal_dac_cleanup(void)
+{
+	platform_driver_unregister(&snd_stm_conv_internal_dac_driver);
+}
diff --git a/sound/soc/stm/dac.c b/sound/soc/stm/dac.c
deleted file mode 100644
index 4da746b..0000000
--- a/sound/soc/stm/dac.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' DAC abstraction layer
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 2 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Audio DAC public interface implementation
- */
-
-int snd_stm_dac_internal_get_config(struct device *device,
-		unsigned long *pcm_format, unsigned int *oversampling);
-int snd_stm_dac_internal_shut_down(struct device *device);
-int snd_stm_dac_internal_wake_up(struct device *device);
-int snd_stm_dac_internal_mute(struct device *device);
-int snd_stm_dac_internal_unmute(struct device *device);
-
-
-
-/* Gets PCM format required by DAC as described in <linux/stm/soc.h> */
-int snd_stm_dac_get_config(struct device *device,
-		unsigned long *pcm_format, unsigned int *oversampling)
-{
-	/* TODO */
-	return snd_stm_dac_internal_get_config(device, pcm_format,
-			oversampling);
-}
-
-int snd_stm_dac_shut_down(struct device *device)
-{
-	/* TODO */
-	return snd_stm_dac_internal_shut_down(device);;
-}
-
-int snd_stm_dac_wake_up(struct device *device)
-{
-	/* TODO */
-	return snd_stm_dac_internal_wake_up(device);
-}
-
-int snd_stm_dac_mute(struct device *device)
-{
-	/* TODO */
-	return snd_stm_dac_internal_mute(device);
-}
-
-int snd_stm_dac_unmute(struct device *device)
-{
-	return snd_stm_dac_internal_unmute(device);
-}
diff --git a/sound/soc/stm/dac_internal.c b/sound/soc/stm/dac_internal.c
deleted file mode 100644
index 963a62a..0000000
--- a/sound/soc/stm/dac_internal.c
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' internal audio DAC driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/list.h>
-#include <linux/stm/soc.h>
-#include <linux/stm/registers.h>
-#include <sound/driver.h>
-#include <sound/core.h>
-#include <sound/info.h>
-
-#undef TRACE   /* See common.h debug features */
-#define MAGIC 3 /* See common.h debug features */
-#include "common.h"
-
-
-
-/*
- * Hardware-related definitions
- */
-
-#define PCM_FORMAT \
-		(PLAT_STM_AUDIO__FORMAT_I2S | \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
-		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
-
-#define OVERSAMPLING 256
-
-
-
-/*
- * Audio DAC instance structure
- */
-
-struct snd_stm_dac_internal {
-	const char *bus_id;
-
-	struct resource *mem_region;
-
-	void *base;
-
-	/* Master DAC - must be waked up before the slave is etc. */
-	struct device *master;
-
-	/* TODO: add "waked up" counter */
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
-};
-
-
-
-
-
-
-/*
- * Audio DAC public interface implementation
- */
-
-/* Gets PCM format required by DAC as described in <linux/stm/soc.h> */
-int snd_stm_dac_internal_get_config(struct device *device,
-		unsigned long *pcm_format, unsigned int *oversampling)
-{
-	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	*pcm_format = PCM_FORMAT;
-	*oversampling = OVERSAMPLING;
-
-	return 0;
-}
-
-int snd_stm_dac_internal_wake_up(struct device *device)
-{
-	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	if (dac_internal->master)
-		snd_stm_dac_wake_up(dac_internal->master);
-
-	snd_stm_printt("Waking up DAC '%s' (still muted)\n",
-			dac_internal->bus_id);
-	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, NORMAL) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, NORMAL) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, NORMAL) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, NORMAL));
-
-	return 0;
-}
-
-int snd_stm_dac_internal_shut_down(struct device *device)
-{
-	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	if (dac_internal->master)
-		snd_stm_dac_shut_down(dac_internal->master);
-
-	snd_stm_printt("Setting DAC '%s' into reset mode.\n",
-			dac_internal->bus_id);
-	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
-
-	return 0;
-}
-
-int snd_stm_dac_internal_mute(struct device *device)
-{
-	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	snd_stm_printt("Muting DAC '%s'.\n", dac_internal->bus_id);
-
-	REGFIELD_SET(dac_internal->base, AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE);
-
-	return 0;
-}
-
-int snd_stm_dac_internal_unmute(struct device *device)
-{
-	struct snd_stm_dac_internal *dac_internal = dev_get_drvdata(device);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	snd_stm_printt("Unmuting DAC '%s'.\n", dac_internal->bus_id);
-
-	REGFIELD_SET(dac_internal->base, AUDCFG_ADAC_CTRL, SOFTMUTE, NORMAL);
-
-	return 0;
-}
-
-
-
-/*
- * ALSA lowlevel device implementation
- */
-
-static void snd_stm_dac_internal_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_dac_internal *dac_internal = entry->private_data;
-
-	snd_assert(dac_internal, return);
-	snd_stm_magic_assert(dac_internal, return);
-
-	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
-			REGISTER_PEEK(dac_internal->base, AUDCFG_ADAC_CTRL));
-}
-
-static int snd_stm_dac_internal_register(struct snd_device *snd_device)
-{
-	struct snd_stm_dac_internal *dac_internal = snd_device->device_data;
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	/* Initialize DAC as muted and shut down */
-
-	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&dac_internal->proc_entry, dac_internal->bus_id,
-			snd_stm_dac_internal_dump_registers, dac_internal);
-
-	return 0;
-}
-
-static int snd_stm_dac_internal_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_dac_internal *dac_internal = snd_device->device_data;
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(dac_internal->proc_entry);
-
-	/* Power done & mute mode, just to be sure :-) */
-
-	REGISTER_POKE(dac_internal->base, AUDCFG_ADAC_CTRL,
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
-			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_dac_internal_ops = {
-	.dev_register = snd_stm_dac_internal_register,
-	.dev_disconnect = snd_stm_dac_internal_disconnect,
-};
-
-
-
-/*
- * Platform driver routines
- */
-
-static int __init snd_stm_dac_internal_probe(struct platform_device *pdev)
-{
-	int result = 0;
-	struct snd_stm_component *component;
-	struct snd_stm_dac_internal *dac_internal;
-	const char *card_id;
-	struct snd_card *card;
-	const char *master_bus_id = NULL;
-
-	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
-
-	dac_internal = kzalloc(sizeof(*dac_internal), GFP_KERNEL);
-	if (!dac_internal) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(dac_internal);
-	dac_internal->bus_id = pdev->dev.bus_id;
-
-	result = snd_stm_memory_request(pdev, &dac_internal->mem_region,
-			&dac_internal->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	if (result == 0)
-		card = snd_stm_cards_get(card_id);
-	else
-		card = snd_stm_cards_default(&card_id);
-	snd_assert(card, return -EINVAL);
-	snd_printd("DAC will be a member of a card '%s'\n", card_id);
-
-	result = snd_stm_cap_get_string(component, "master_bus_id",
-			&master_bus_id);
-	if (result == 0) {
-		dac_internal->master = snd_stm_device_get(master_bus_id);
-
-		snd_assert(dac_internal->master, return -EINVAL);
-		snd_printd("This DAC is %s's slave.\n", master_bus_id);
-	}
-
-	/* ALSA component */
-
-	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, dac_internal,
-			&snd_stm_dac_internal_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, dac_internal);
-
-	snd_printd("--- Probed successfully!\n");
-
-	return result;
-
-error_device:
-	snd_stm_memory_release(dac_internal->mem_region, dac_internal->base);
-error_memory_request:
-	snd_stm_magic_clear(dac_internal);
-	kfree(dac_internal);
-error_alloc:
-	return result;
-}
-
-static int snd_stm_dac_internal_remove(struct platform_device *pdev)
-{
-	struct snd_stm_dac_internal *dac_internal = platform_get_drvdata(pdev);
-
-	snd_assert(dac_internal, return -EINVAL);
-	snd_stm_magic_assert(dac_internal, return -EINVAL);
-
-	snd_stm_memory_release(dac_internal->mem_region, dac_internal->base);
-
-	snd_stm_magic_clear(dac_internal);
-	kfree(dac_internal);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_dac_internal_driver = {
-	.driver = {
-		.name = "dac_internal",
-	},
-	.probe = snd_stm_dac_internal_probe,
-	.remove = snd_stm_dac_internal_remove,
-};
-
-
-
-/*
- * Initialization
- */
-
-int __init snd_stm_dac_internal_init(void)
-{
-	return platform_driver_register(&snd_stm_dac_internal_driver);
-}
-
-void snd_stm_dac_internal_cleanup(void)
-{
-	platform_driver_unregister(&snd_stm_dac_internal_driver);
-}
diff --git a/sound/soc/stm/fsynth.c b/sound/soc/stm/fsynth.c
index 81f826c..7a1abb5 100644
--- a/sound/soc/stm/fsynth.c
+++ b/sound/soc/stm/fsynth.c
@@ -34,7 +34,7 @@
 #include <sound/info.h>
 
 #undef TRACE /* See common.h debug features */
-#define MAGIC 4 /* See common.h debug features */
+#define MAGIC 5 /* See common.h debug features */
 #include "common.h"
 
 
@@ -43,10 +43,10 @@
  * Hardware constants
  */
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 #	define CHANNELS 3
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7200) || defined(CONFIG_CPU_SUBTYPE_STX7111)
 #	define CHANNELS 4
 #endif
 
@@ -294,6 +294,13 @@ static int snd_stm_fsynth_channel_configure(struct snd_stm_fsynth *fsynth,
 	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
 	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
 
+	/* All specs say, that maximum frequency generated by the fsynth
+	 * is 12.288MHz... */
+	if (frequency > 12288000)
+		snd_stm_printe("WARNING! %s should not generate frequency %d!"
+				" (12.288MHz is maximum)\n",
+				fsynth->bus_id, frequency);
+
 	/*             a
 	 * F = f + --------- * f = f + d
 	 *          1000000
@@ -458,7 +465,7 @@ static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
 	return old_adjustement != fsynth_channel->adjustment;
 }
 
-static struct snd_kcontrol_new __initdata snd_stm_fsynth_adjustment_ctl = {
+static struct snd_kcontrol_new snd_stm_fsynth_adjustment_ctl = {
 	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 	.name = "PCM Playback Oversampling Freq. Adjustment",
 	.info = snd_stm_fsynth_adjustment_info,
@@ -488,7 +495,7 @@ int snd_stm_fsynth_set_frequency(struct device *device, int channel,
 	return snd_stm_fsynth_channel_configure(fsynth, channel, frequency, 0);
 }
 
-int __init snd_stm_fsynth_add_adjustement_ctl(struct device *device,
+int snd_stm_fsynth_add_adjustement_ctl(struct device *device,
 		int channel, struct snd_card *card, int card_device)
 {
 	int result;
@@ -562,7 +569,7 @@ static int snd_stm_fsynth_register(struct snd_device *snd_device)
 				fsynth->bus_id, i);
 		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, PCM_CLK_SEL,
 				FSYNTH(i));
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
 		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, ENABLED(i));
 #endif
 		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, ACTIVE(i));
@@ -604,7 +611,7 @@ static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
 
 	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RUNNING);
 	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
 		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, DISABLED(i));
 #endif
 		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, STANDBY(i));
@@ -616,7 +623,7 @@ static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
 	return 0;
 }
 
-static struct snd_device_ops snd_stm_fsynth_ops = {
+static struct snd_device_ops snd_stm_fsynth_snd_device_ops = {
 	.dev_register = snd_stm_fsynth_register,
 	.dev_disconnect = snd_stm_fsynth_disconnect,
 };
@@ -630,16 +637,14 @@ static struct snd_device_ops snd_stm_fsynth_ops = {
 static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
 {
 	int result = 0;
-	struct snd_stm_component *component;
+	struct snd_stm_fsynth_info *fsynth_info = pdev->dev.platform_data;
 	struct snd_stm_fsynth *fsynth;
-	const char *card_id;
 	struct snd_card *card;
 	int i;
 
 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
+	snd_assert(fsynth_info != NULL, return -EINVAL);
 
 	fsynth = kzalloc(sizeof(*fsynth), GFP_KERNEL);
 	if (!fsynth) {
@@ -660,18 +665,16 @@ static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
 		goto error_memory_request;
 	}
 
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	if (result == 0)
-		card = snd_stm_cards_get(card_id);
+	if (fsynth_info->card_id)
+		card = snd_stm_cards_get(fsynth_info->card_id);
 	else
-		card = snd_stm_cards_default(&card_id);
+		card = snd_stm_cards_default();
 	snd_assert(card, return -EINVAL);
 	snd_printd("This frequency synthesizer will be a member "
-			"of a card '%s'\n", card_id);
+			"of a card '%s'\n", card->id);
 
-	result = snd_stm_cap_get_range(component, "channels",
-			&fsynth->channels_from, &fsynth->channels_to);
-	snd_assert(result == 0, return -EINVAL);
+	fsynth->channels_from = fsynth_info->channels_from;
+	fsynth->channels_to = fsynth_info->channels_to;
 	snd_assert(fsynth->channels_from < fsynth->channels_to,
 			return -EINVAL);
 	snd_assert(fsynth->channels_from >= 0, return -EINVAL);
@@ -683,7 +686,7 @@ static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
 	/* ALSA component */
 
 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, fsynth,
-			&snd_stm_fsynth_ops);
+			&snd_stm_fsynth_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
 		goto error_device;
diff --git a/sound/soc/stm/i2s-spdif_converter.c b/sound/soc/stm/i2s-spdif_converter.c
deleted file mode 100644
index 0eba3d4..0000000
--- a/sound/soc/stm/i2s-spdif_converter.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
- *
- *   Copyright (c) 2005-2007 STMicroelectronics Limited
- *
- *   Author: Pawel MOLL <pawel.moll@st.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#include <linux/init.h>
-
-#undef TRACE /* See common.h debug features */
-#define MAGIC 5 /* See common.h debug features */
-#include "common.h"
-
-/*
- * Initialization
- */
-
-int __init snd_stm_i2s_spdif_converter_init(void)
-{
-	return 0;
-}
-
-void snd_stm_i2s_spdif_converter_cleanup(void)
-{
-}
diff --git a/sound/soc/stm/init.c b/sound/soc/stm/init.c
index 1f2e5cc..ddb4e7d 100644
--- a/sound/soc/stm/init.c
+++ b/sound/soc/stm/init.c
@@ -39,14 +39,19 @@ static int __init alsa_card_stm_init(void)
 
 	snd_printd("=== STM ALSA driver is initializing...\n");
 
-#ifdef CONFIG_CPU_SUBTYPE_STB7100
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
 	result = snd_stm_stx710x_init();
 #endif
-#ifdef CONFIG_CPU_SUBTYPE_STX7200
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	result = snd_stm_stx7111_init();
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
 	result = snd_stm_stx7200_init();
 #endif
-	if (result != 0)
+	if (result != 0) {
+		snd_stm_printe("Can't initialize SOC platform!\n");
 		goto error_soc;
+	}
 
 	result = snd_stm_info_init();
 	if (result != 0) {
@@ -63,21 +68,31 @@ static int __init alsa_card_stm_init(void)
 		snd_stm_printe("Can't initialize frequency synthesizer!\n");
 		goto error_fsynth;
 	}
-	result = snd_stm_dac_internal_init();
+	result = snd_stm_conv_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize converters infrastructure!\n");
+		goto error_conv;
+	}
+	result = snd_stm_conv_dummy_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize dummy converter!\n");
+		goto error_conv_dummy;
+	}
+	result = snd_stm_conv_internal_dac_init();
 	if (result != 0) {
 		snd_stm_printe("Can't initialize internal DACs!\n");
-		goto error_dac_internal;
+		goto error_conv_internal_dac;
+	}
+	result = snd_stm_conv_i2s_spdif_init();
+	if (result != 0) {
+		snd_stm_printe("Can't initialize I2S to SPDIF converter!\n");
+		goto error_conv_i2s_spdif;
 	}
 	result = snd_stm_synchro_init();
 	if (result != 0) {
 		snd_stm_printe("Can't initialize synchronisation routines!\n");
 		goto error_synchro;
 	}
-	result = snd_stm_i2s_spdif_converter_init();
-	if (result != 0) {
-		snd_stm_printe("Can't initialize I2S to SPDIF converter!\n");
-		goto error_i2s_spdif_converter;
-	}
 	result = snd_stm_pcm_player_init();
 	if (result != 0) {
 		snd_stm_printe("Can't initialize PCM player!\n");
@@ -113,12 +128,16 @@ error_spdif_player:
 error_pcm_reader:
 	snd_stm_pcm_player_cleanup();
 error_pcm_player:
-	snd_stm_i2s_spdif_converter_cleanup();
-error_i2s_spdif_converter:
 	snd_stm_synchro_cleanup();
 error_synchro:
-	snd_stm_dac_internal_cleanup();
-error_dac_internal:
+	snd_stm_conv_i2s_spdif_cleanup();
+error_conv_i2s_spdif:
+	snd_stm_conv_internal_dac_cleanup();
+error_conv_internal_dac:
+	snd_stm_conv_dummy_cleanup();
+error_conv_dummy:
+	snd_stm_conv_cleanup();
+error_conv:
 	snd_stm_fsynth_cleanup();
 error_fsynth:
 	snd_stm_audio_outputs_cleanup();
@@ -139,12 +158,24 @@ static void __exit alsa_card_stm_exit(void)
 	snd_stm_spdif_player_cleanup();
 	snd_stm_pcm_reader_cleanup();
 	snd_stm_pcm_player_cleanup();
-	snd_stm_i2s_spdif_converter_cleanup();
 	snd_stm_synchro_cleanup();
-	snd_stm_dac_internal_cleanup();
+	snd_stm_conv_i2s_spdif_cleanup();
+	snd_stm_conv_internal_dac_cleanup();
+	snd_stm_conv_dummy_cleanup();
+	snd_stm_conv_cleanup();
 	snd_stm_fsynth_cleanup();
 	snd_stm_audio_outputs_cleanup();
 	snd_stm_info_cleanup();
+
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+	snd_stm_stx710x_cleanup();
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	snd_stm_stx7111_cleanup();
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
+	snd_stm_stx7200_cleanup();
+#endif
 }
 
 module_init(alsa_card_stm_init)
diff --git a/sound/soc/stm/pcm_player.c b/sound/soc/stm/pcm_player.c
index baf8e3b..3981f7d 100644
--- a/sound/soc/stm/pcm_player.c
+++ b/sound/soc/stm/pcm_player.c
@@ -36,9 +36,10 @@
 #include <sound/pcm.h>
 #include <sound/control.h>
 #include <sound/info.h>
+#include <sound/pcm_params.h>
 
 #undef TRACE /* See common.h debug features */
-#define MAGIC 5 /* See common.h debug features */
+#define MAGIC 6 /* See common.h debug features */
 #include "common.h"
 
 
@@ -47,13 +48,9 @@
  * Some hardware-related definitions
  */
 
-#define INIT_SAMPLING_RATE 32000
-
+#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
+		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
 #define DEFAULT_OVERSAMPLING 256
-#define DEFAULT_FORMAT \
-		(PLAT_STM_AUDIO__FORMAT_I2S | \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
-		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
 
 /* The sample count field (NSAMPLES in CTRL register) is 19 bits wide */
 #define MAX_SAMPLES_PER_PERIOD ((1 << 19) - 1)
@@ -68,8 +65,8 @@
 
 struct snd_stm_pcm_player {
 	/* System informations */
-	const char *name;
-	const char *bus_id;
+	struct snd_stm_pcm_player_info *info;
+	struct device *device;
 	struct snd_pcm *pcm;
 
 	/* Resources */
@@ -77,34 +74,20 @@ struct snd_stm_pcm_player {
 	void *base;
 	unsigned long fifo_phys_address;
 	unsigned int irq;
-	int fdma_channel;
-	struct stm_dma_req *fdma_request;
+	unsigned int fdma_channel;
 
 	/* Environment settings */
-	struct device *fsynth;
+	struct device *fsynth_device;
 	int fsynth_channel;
-	struct device *dac;
+	struct snd_stm_conv *conv;
 	struct snd_pcm_hw_constraint_list channels_constraint;
-	unsigned int channels_constraint_list[MAX_CHANNELS / 2];
-
-	/* Board-specific settings */
-	unsigned long format;
-	unsigned int oversampling;
-
-	/* Value of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
-	 * actually means "data clocking on the falling edge" -
-	 * STx7100 and _some_ cuts of STx7109 have this value
-	 * inverted than datasheets claim... (specs say 1) */
-	int sclk_edge_falling;
-
-	/* Workaround for L/R swap problem (see further) */
-	int lr_pol;
 
 	/* Runtime data */
 	void *buffer;
 	struct snd_info_entry *proc_entry;
 	struct snd_pcm_substream *substream;
 	struct stm_dma_params fdma_params;
+	struct stm_dma_req *fdma_request;
 
 	snd_stm_magic_field;
 };
@@ -136,7 +119,7 @@ static irqreturn_t snd_stm_pcm_player_irq_handler(int irq, void *dev_id)
 	/* Underflow? */
 	if (unlikely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, UNF, PENDING))) {
 		snd_stm_printe("Underflow detected in PCM player '%s'!\n",
-				pcm_player->bus_id);
+				pcm_player->device->bus_id);
 		result = IRQ_HANDLED;
 	}
 
@@ -146,7 +129,7 @@ static irqreturn_t snd_stm_pcm_player_irq_handler(int irq, void *dev_id)
 			snd_assert(pcm_player->substream, break);
 
 			snd_stm_printt("Period elapsed ('%s')\n",
-					pcm_player->bus_id);
+					pcm_player->device->bus_id);
 			snd_pcm_period_elapsed(pcm_player->substream);
 
 			result = IRQ_HANDLED;
@@ -170,7 +153,10 @@ static struct snd_pcm_hardware snd_stm_pcm_player_hw = {
 	.rates		= (SNDRV_PCM_RATE_32000 |
 				SNDRV_PCM_RATE_44100 |
 				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
 				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
 				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
 	.rate_max	= 192000,
@@ -178,7 +164,7 @@ static struct snd_pcm_hardware snd_stm_pcm_player_hw = {
 	.channels_min	= 2,
 	.channels_max	= 10,
 
-	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_min	= 2,
 	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
 
 	/* Values below were worked out mostly basing on ST media player
@@ -210,6 +196,17 @@ static int snd_stm_pcm_player_open(struct snd_pcm_substream *substream)
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
+	/* Get attached converter handle */
+
+	pcm_player->conv = snd_stm_conv_get_attached(pcm_player->device);
+	if (pcm_player->conv)
+		snd_stm_printt("Converter '%s' attached to '%s'...\n",
+				pcm_player->conv->name,
+				pcm_player->device->bus_id);
+	else
+		snd_stm_printt("Warning! No converter attached to '%s'!\n",
+				pcm_player->device->bus_id);
+
 	/* Set up constraints & pass hardware capabilities info to ALSA */
 
 	result = snd_pcm_hw_constraint_list(runtime, 0,
@@ -229,6 +226,16 @@ static int snd_stm_pcm_player_open(struct snd_pcm_substream *substream)
 		return result;
 	}
 
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			pcm_player->info->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
 	runtime->hw = snd_stm_pcm_player_hw;
 
 	return 0;
@@ -248,6 +255,50 @@ static int snd_stm_pcm_player_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+static int snd_stm_pcm_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_player *pcm_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_player, return -EINVAL);
+	snd_stm_magic_assert(pcm_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (pcm_player->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_player->device->bus_id,
+				pcm_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
+
+		pcm_player->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* Dispose FDMA parameters & configuration */
+
+		dma_params_free(&pcm_player->fdma_params);
+		dma_req_free(pcm_player->fdma_channel,
+				pcm_player->fdma_request);
+	}
+
+	return 0;
+}
+
 static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *hw_params)
 {
@@ -255,7 +306,15 @@ static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes;
+	int buffer_bytes, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_WRITE,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = pcm_player->info->fdma_initiator,
+	};
 
 	snd_stm_printt("snd_stm_pcm_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
@@ -264,6 +323,10 @@ static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 
+	/* This function may be called many times, so let's be prepared... */
+	if (pcm_player->buffer)
+		snd_stm_pcm_player_hw_free(substream);
+
 	/* Allocate buffer */
 
 	buffer_bytes = params_buffer_bytes(hw_params);
@@ -271,8 +334,9 @@ static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 	/* TODO: move to BPA2, use pcm lib as fallback... */
 	if (!pcm_player->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, pcm_player->bus_id);
-		return -ENOMEM;
+				buffer_bytes, pcm_player->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
 	}
 
 	runtime->dma_addr = virt_to_phys(pcm_player->buffer);
@@ -281,12 +345,44 @@ static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 
 	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
 			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", pcm_player->bus_id,
+			"dma_bytes=%u\n", pcm_player->device->bus_id,
 			pcm_player->buffer, runtime->dma_addr,
 			runtime->dma_area, runtime->dma_bytes);
 
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			pcm_player->info->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+	snd_stm_printt("FDMA request trigger limit and transfer size set to "
+			"%d.\n", transfer_size);
+
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_player->info->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+			return -EINVAL);
+	snd_assert(transfer_size <= AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK,
+			return -EINVAL);
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+			DMA_REQ_TRIG_LMT, transfer_size);
+
 	/* Configure FDMA transfer */
 
+	pcm_player->fdma_request = dma_req_config(pcm_player->fdma_channel,
+			pcm_player->info->fdma_request_line, &fdma_req_config);
+	if (!pcm_player->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", pcm_player->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
+
 	dma_params_init(&pcm_player->fdma_params, MODE_PACED,
 			STM_DMA_LIST_CIRC);
 
@@ -301,79 +397,162 @@ static int snd_stm_pcm_player_hw_params(struct snd_pcm_substream *substream,
 				&pcm_player->fdma_params, GFP_KERNEL);
 	if (result < 0) {
 		snd_stm_printe("Can't compile FDMA parameters for player"
-				" '%s'!\n", pcm_player->bus_id);
-		return -EINVAL;
+				" '%s'!\n", pcm_player->device->bus_id);
+		goto error_compile_list;
 	}
 
 	return 0;
+
+error_compile_list:
+	dma_req_free(pcm_player->fdma_channel,
+			pcm_player->fdma_request);
+error_req_config:
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
+	pcm_player->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
+error_buf_alloc:
+	return result;
 }
 
-static int snd_stm_pcm_player_hw_free(struct snd_pcm_substream *substream)
+static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int format, lr_pol;
+	int oversampling, bits_in_output_frame;
 
-	snd_stm_printt("snd_stm_pcm_player_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_prepare(substream=0x%p)\n",
 			substream);
 
 	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
 
-	/* This callback may be called more than once... */
+	/* Configure SPDIF synchronisation */
 
-	if (pcm_player->buffer) {
-		/* Dispose buffer */
+	/* TODO */
 
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", pcm_player->bus_id,
-				pcm_player->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
+	/* Get format & oversampling value from connected converter */
 
-		iounmap(runtime->dma_area);
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
+	if (pcm_player->conv) {
+		format = snd_stm_conv_get_format(pcm_player->conv);
+		oversampling = snd_stm_conv_get_oversampling(pcm_player->conv);
+		if (oversampling == 0)
+			oversampling = DEFAULT_OVERSAMPLING;
+	} else {
+		format = DEFAULT_FORMAT;
+		oversampling = DEFAULT_OVERSAMPLING;
+	}
 
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
-		pcm_player->buffer = NULL;
+	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
+			pcm_player->device->bus_id, runtime->rate,
+			oversampling);
 
-		/* Dispose FDMA parameters */
+	snd_assert(oversampling > 0, return -EINVAL);
 
-		dma_params_free(&pcm_player->fdma_params);
-	}
+	/* For 32 bits subframe oversampling must be a multiple of 128,
+	 * for 16 bits - of 64 */
+	snd_assert(((format & SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS) &&
+				(oversampling % 128 == 0)) ||
+				(oversampling % 64 == 0), return -EINVAL);
 
-	return 0;
-}
+	/* Set up frequency synthesizer */
 
-static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_player *pcm_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int bits_in_output_frame;
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth_device,
+			pcm_player->fsynth_channel,
+			runtime->rate * oversampling);
 
-	snd_stm_printt("snd_stm_pcm_player_prepare(substream=0x%p)\n",
-			substream);
+	/* Set up player hardware */
 
-	snd_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(runtime->period_size * runtime->channels <
-			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+	snd_stm_printt("Player %s format configuration:\n",
+			pcm_player->device->bus_id);
 
-	/* Configure SPDIF synchronisation */
+	/* Number of bits per subframe (which is one channel sample)
+	 * on output - it determines serial clock frequency, which is
+	 * 64 times sampling rate for 32 bits subframe (2 channels 32
+	 * bits each means 64 bits per frame) and 32 times sampling
+	 * rate for 16 bits subframe
+	 * (you know why, don't you? :-) */
 
-	/* TODO */
+	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
+		snd_stm_printt("- 32 bits per subframe\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 32_BITS);
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				DATA_SIZE, 32_BITS);
+#else
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				DATA_SIZE, 24_BITS);
+#endif
+		bits_in_output_frame = 64; /* frame = 2 * subframe */
+		break;
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
+		snd_stm_printt("- 16 bits per subframe\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 16_BITS);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 16_BITS);
+			bits_in_output_frame = 32; /* frame = 2 * subframe */
+			break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
 
-	/* Set up frequency synthesizer */
+	/* Serial audio interface format - for detailed explanation
+	 * see ie.:
+	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
 
-	snd_stm_fsynth_set_frequency(pcm_player->fsynth,
-			pcm_player->fsynth_channel,
-			runtime->rate * pcm_player->oversampling);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+			ORDER, MSB_FIRST);
+
+	/* Value of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
+	 * actually means "data clocking on the falling edge" -
+	 * STx7100 and _some_ cuts of STx7109 have this value
+	 * inverted than datasheets claim... (specs say 1) */
+
+	if (pcm_player->info->invert_sclk_edge_falling) {
+		snd_stm_printt("Inverted SCLK_EDGE!\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				SCLK_EDGE, RISING);
+	} else {
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				SCLK_EDGE, FALLING);
+	}
+
+	switch (format & SND_STM_FORMAT__MASK) {
+	case SND_STM_FORMAT__I2S:
+		snd_stm_printt("- I2S\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, 1_CYCLE_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
+		break;
+	case SND_STM_FORMAT__LEFT_JUSTIFIED:
+		snd_stm_printt("- left justified\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
+		break;
+	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
+		snd_stm_printt("- right justified\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, RIGHT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
 
 	/* Configure PCM player frequency divider
 	 *
@@ -393,21 +572,8 @@ static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
 	 *                (32 or 64, depending on NBIT field of FMT register)
 	 */
 
-	switch (pcm_player->format & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
-	case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
-		bits_in_output_frame = 64;
-		break;
-	case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
-		bits_in_output_frame = 32;
-		break;
-	default:
-		bits_in_output_frame = 0; /* Avoid a -Os compilation warning */
-		snd_assert(0, return -EINVAL);
-		break;
-	}
-
 	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, CLK_DIV,
-			pcm_player->oversampling / (2 * bits_in_output_frame));
+			oversampling / (2 * bits_in_output_frame));
 
 	/* Configure data memory format & NSAMPLE interrupt */
 
@@ -426,36 +592,34 @@ static int snd_stm_pcm_player_prepare(struct snd_pcm_substream *substream)
 		 * by one sample...
 		 * (ask me for more details if above is not clear ;-)
 		 * TODO this somehow better... */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
-				!pcm_player->lr_pol);
-
-		/* One word if fifo is two samples (two channels...) */
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+				LR_POL, !lr_pol);
 
+		/* One word of data is two samples (two channels...) */
 		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
 				runtime->period_size * runtime->channels / 2);
 		break;
 
 	case SNDRV_PCM_FORMAT_S32_LE:
-		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
-		 * left than zeros"... ;-) */
+		/* Actually "16 bits/0 bits" means "32/28/24/20/18/16 bits
+		 * on the left than zeros (if less than 32 bites)"... ;-) */
 		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
 				MEM_FMT, 16_BITS_0_BITS);
 
 		/* In x/0 bits memory mode there is no problem with
 		 * L/R polarity */
 		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
-				pcm_player->lr_pol);
+				lr_pol);
 
 		/* One word of data is one sample, so period size
 		 * times channels */
-
 		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
 				runtime->period_size * runtime->channels);
 		break;
 
 	default:
-		snd_assert(0, return -EINVAL);
-		break;
+		snd_BUG();
+		return -EINVAL;
 	}
 
 	/* Number of channels... */
@@ -492,7 +656,7 @@ static inline int snd_stm_pcm_player_start(struct snd_pcm_substream *substream)
 			&pcm_player->fdma_params);
 	if (result != 0) {
 		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
-				pcm_player->bus_id);
+				pcm_player->device->bus_id);
 		return -EINVAL;
 	}
 
@@ -508,9 +672,9 @@ static inline int snd_stm_pcm_player_start(struct snd_pcm_substream *substream)
 
 	/* Wake up & unmute DAC */
 
-	if (pcm_player->dac) {
-		snd_stm_dac_wake_up(pcm_player->dac);
-		snd_stm_dac_unmute(pcm_player->dac);
+	if (pcm_player->conv) {
+		snd_stm_conv_enable(pcm_player->conv);
+		snd_stm_conv_unmute(pcm_player->conv);
 	}
 
 	return 0;
@@ -529,9 +693,9 @@ static inline int snd_stm_pcm_player_stop(struct snd_pcm_substream *substream)
 
 	/* Mute & shutdown DAC */
 
-	if (pcm_player->dac) {
-		snd_stm_dac_mute(pcm_player->dac);
-		snd_stm_dac_shut_down(pcm_player->dac);
+	if (pcm_player->conv) {
+		snd_stm_conv_mute(pcm_player->conv);
+		snd_stm_conv_disable(pcm_player->conv);
 	}
 
 	/* Disable interrupts */
@@ -688,6 +852,7 @@ static void snd_stm_pcm_player_dump_registers(struct snd_info_entry *entry,
 
 static int snd_stm_pcm_player_register(struct snd_device *snd_device)
 {
+	int result;
 	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
 
 	snd_stm_printt("snd_stm_pcm_player_register(snd_device=0x%p)\n",
@@ -696,138 +861,40 @@ static int snd_stm_pcm_player_register(struct snd_device *snd_device)
 	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
-	/* Set a default clock frequency running for each device.
-	 * Not doing this can lead to clocks not starting correctly later,
-	 * for reasons that cannot be explained at this time. */
-	/* TODO: Check it, maybe obsolete now */
-	snd_stm_fsynth_set_frequency(pcm_player->fsynth,
-			pcm_player->fsynth_channel,
-			INIT_SAMPLING_RATE * pcm_player->oversampling);
-
-	/* Initialize hardware (format etc.) */
+	/* Set reset mode */
 
 	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
 
 	/* TODO: well, hardcoded - shall anyone use it?
 	 * And what it actually means? */
-	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, RND, NO_ROUNDING);
 
-	if (pcm_player->format & PLAT_STM_AUDIO__CUSTOM) {
-		/* Custom format settings... Well, you asked for it! ;-) */
-		REGISTER_POKE(pcm_player->base, AUD_PCMOUT_CTRL,
-				pcm_player->format & !PLAT_STM_AUDIO__CUSTOM);
-	} else {
-		/* Number of bits per subframe (which is one channel sample)
-		 * on output - it determines serial clock frequency, which is
-		 * 64 times sampling rate for 32 bits subframe (2 channels 32
-		 * bits each means 64 bits per frame) and 32 times sampling
-		 * rate for 16 bits subframe
-		 * (you know why now, don't you? :-) */
-
-		switch (pcm_player->format &
-				PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
-		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					NBIT, 32_BITS);
-			break;
-		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					NBIT, 16_BITS);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
-
-		/* Datasheet says: "The recommended configuration is to set
-		 * the PCM player fifo threshold that triggers the FDMA
-		 * request to 40 bytes (at least 80 bytes available) and
-		 * to configured the FDMA to perform a 80 bytes store
-		 * operation when servicing a dma request." My understanding
-		 * of "FIFO cell" is "4 bytes" ;-), so the value should be 20.
-		 * Surprisingly experiments suggest using something
-		 * like 10... */
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
-				DMA_REQ_TRIG_LMT, 10);
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, BACK_STALLING, DISABLED);
+#endif
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, RND, NO_ROUNDING);
 
-		/* Number of meaningful bits in subframe -
-		 * the rest are just zeros */
+	/* Registers view in ALSA's procfs */
 
-		switch (pcm_player->format & PLAT_STM_AUDIO__DATA_SIZE_MASK) {
-		case PLAT_STM_AUDIO__DATA_SIZE_24_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					DATA_SIZE, 24_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_20_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					DATA_SIZE, 20_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_18_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					DATA_SIZE, 18_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_16_BITS:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					DATA_SIZE, 16_BITS);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
+	snd_stm_info_register(&pcm_player->proc_entry,
+			pcm_player->device->bus_id,
+			snd_stm_pcm_player_dump_registers, pcm_player);
 
-		/* Serial audio interface format - for detailed explanation
-		 * see ie.:
-		 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+	/* Create ALSA controls */
 
-		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-				ORDER, MSB_FIRST);
-		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
-				SCLK_EDGE, pcm_player->sclk_edge_falling);
-		switch (pcm_player->format & PLAT_STM_AUDIO__FORMAT_MASK) {
-		case PLAT_STM_AUDIO__FORMAT_I2S:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					ALIGN, LEFT);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					PADDING, 1_CYCLE_DELAY);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					LR_POL, LEFT_LOW);
-			break;
-		case PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					ALIGN, LEFT);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					PADDING, NO_DELAY);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					LR_POL, LEFT_HIGH);
-			break;
-		case PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED:
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					ALIGN, RIGHT);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					PADDING, NO_DELAY);
-			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
-					LR_POL, LEFT_HIGH);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
+	result = snd_stm_conv_add_route_ctl(pcm_player->device,
+			snd_device->card, pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
 	}
 
-	/* Workaround for 16/16 memory format L/R channels swap (see above) */
-	pcm_player->lr_pol = REGFIELD_PEEK(pcm_player->base, AUD_PCMOUT_FMT,
-			LR_POL);
-
-	/* This combination is forbidden - please use 384 * Fs oversampling
-	 * frequency instead */
-	snd_assert(!(pcm_player->oversampling == 192 && (pcm_player->format &
-			PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS)),
-			return -EINVAL);
-
-	/* Registers view in ALSA's procfs */
-
-	snd_stm_info_register(&pcm_player->proc_entry, pcm_player->bus_id,
-			snd_stm_pcm_player_dump_registers, pcm_player);
+	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_device,
+			pcm_player->fsynth_channel,
+			snd_device->card, pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
 
 	return 0;
 }
@@ -844,7 +911,7 @@ static int snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
 	return 0;
 }
 
-static struct snd_device_ops snd_stm_pcm_player_ops = {
+static struct snd_device_ops snd_stm_pcm_player_snd_device_ops = {
 	.dev_register = snd_stm_pcm_player_register,
 	.dev_disconnect = snd_stm_pcm_player_disconnect,
 };
@@ -855,76 +922,15 @@ static struct snd_device_ops snd_stm_pcm_player_ops = {
  * Platform driver routines
  */
 
-#define FORMAT_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "custom" : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_I2S ? "I2S, " : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED ? \
-		"left justified, " : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED ? \
-		"right justified, " : \
-	"")
-
-#define DATA_SIZE_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "" : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_24_BITS ? \
-		"24 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_20_BITS ? \
-		"20 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_18_BITS ? \
-		"18 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_16_BITS ? \
-		"16 bits data, " : \
-	"")
-
-#define OUTPUT_SUBFRAME_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "" : \
-	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS ? \
-		"32 bits output subframe" : \
-	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS ? \
-		"16 bits output subframe" : \
-	"")
-
-static struct stm_dma_req_config snd_stm_pcm_player_fdma_request_config = {
-	.rw        = REQ_CONFIG_WRITE,
-	.opcode    = REQ_CONFIG_OPCODE_4,
-	.count     = 1,
-	.increment = 0,
-	.hold_off  = 0,
-	/* .initiator value is defined in platform device resources */
-};
-
 static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 {
 	int result = 0;
-	struct plat_audio_config *config = pdev->dev.platform_data;
-	struct snd_stm_component *component;
 	struct snd_stm_pcm_player *pcm_player;
 	struct snd_card *card;
-	int card_device;
-	int *channels_list;
-	int channels_list_len;
-	const char *card_id;
-	const char *fsynth_bus_id;
-	const char *dac_bus_id;
 	int i;
 
 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
-
 	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
 	if (!pcm_player) {
 		snd_stm_printe("Can't allocate memory "
@@ -933,7 +939,9 @@ static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 		goto error_alloc;
 	}
 	snd_stm_magic_set(pcm_player);
-	pcm_player->bus_id = pdev->dev.bus_id;
+	pcm_player->info = pdev->dev.platform_data;
+	snd_assert(pcm_player->info != NULL, return -EINVAL);
+	pcm_player->device = &pdev->dev;
 
 	/* Get resources */
 
@@ -955,114 +963,40 @@ static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 		goto error_irq_request;
 	}
 
-	result = snd_stm_fdma_request(pdev, &pcm_player->fdma_channel,
-			&pcm_player->fdma_request,
-			&snd_stm_pcm_player_fdma_request_config);
+	result = snd_stm_fdma_request(pdev, &pcm_player->fdma_channel);
 	if (result < 0) {
 		snd_stm_printe("FDMA request failed!\n");
 		goto error_fdma_request;
 	}
 
-	/* Get component caps */
+	/* Get player capabilities */
 
-	snd_printd("Player's name is '%s'\n", component->short_name);
+	snd_printd("Player's name is '%s'\n", pcm_player->info->name);
 
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	snd_assert(result == 0, return -EINVAL);
-	card = snd_stm_cards_get(card_id);
+	card = snd_stm_cards_get(pcm_player->info->card_id);
 	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Player will be a member of a card '%s'...\n", card_id);
-
-	result = snd_stm_cap_get_number(component, "card_device",
-			&card_device);
-	snd_assert(result == 0, return -EINVAL);
-	snd_printd("... as a PCM device no %d.\n", card_device);
-
-	result = snd_stm_cap_get_list(component, "channels", &channels_list,
-			&channels_list_len);
-	snd_assert(result == 0, return -EINVAL);
-	memcpy(pcm_player->channels_constraint_list, channels_list,
-			sizeof(*channels_list) * channels_list_len);
-	pcm_player->channels_constraint.list =
-		pcm_player->channels_constraint_list;
-	pcm_player->channels_constraint.count =
-		(unsigned int)channels_list_len;
+	snd_printd("Player will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, pcm_player->info->card_device);
+
+	snd_assert(pcm_player->info->channels != NULL, return -EINVAL);
+	snd_assert(pcm_player->info->channels_num > 0, return -EINVAL);
+	pcm_player->channels_constraint.list = pcm_player->info->channels;
+	pcm_player->channels_constraint.count = pcm_player->info->channels_num;
 	pcm_player->channels_constraint.mask = 0;
-	for (i = 0; i < channels_list_len; i++)
-		snd_printd("Player capable of playing %d-channels PCM.\n",
-				channels_list[i]);
-
-	result = snd_stm_cap_get_string(component, "fsynth_bus_id",
-			&fsynth_bus_id);
-	snd_assert(result == 0, return -EINVAL);
-	pcm_player->fsynth = snd_stm_device_get(fsynth_bus_id);
-	snd_assert(pcm_player->fsynth, return -EINVAL);
-	result = snd_stm_cap_get_number(component, "fsynth_channel",
-			&pcm_player->fsynth_channel);
-	snd_assert(result == 0, return -EINVAL);
-	snd_printd("Player clocked by channel %d of synthesizer %s.\n",
-			pcm_player->fsynth_channel, fsynth_bus_id);
-
-	if (snd_stm_cap_get_string(component, "dac_bus_id", &dac_bus_id) == 0) {
-		pcm_player->dac = snd_stm_device_get(dac_bus_id);
-		snd_assert(pcm_player->dac, return -EINVAL);
-		snd_printd("Player connected to DAC %s.\n", dac_bus_id);
-	} else {
-		pcm_player->dac = NULL;
-	}
+	for (i = 0; i < pcm_player->info->channels_num; i++)
+		snd_printd("Player capable of playing %u-channels PCM.\n",
+				pcm_player->info->channels[i]);
 
-	if (snd_stm_cap_get_number(component, "sclk_edge_falling",
-				&pcm_player->sclk_edge_falling) < 0)
-		pcm_player->sclk_edge_falling =
-			AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING;
-
-	snd_printd("Player's SCLK_EDGE == %d means falling edge...\n",
-			pcm_player->sclk_edge_falling);
-
-	/* Board-specific configuration */
-
-	if (pcm_player->dac) {
-		/* If player is connected to an internal DAC just
-		 * ask it about required format instead of looking
-		 * for user-specified one */
-		result = snd_stm_dac_get_config(pcm_player->dac,
-				&pcm_player->format,
-				&pcm_player->oversampling);
-		snd_assert(result == 0, return -EINVAL);
-		snd_printd("Using DAC-defined PCM format (%s%s%s)"
-				" and oversampling (%u).\n",
-				FORMAT_STRING(pcm_player->format),
-				DATA_SIZE_STRING(pcm_player->format),
-				OUTPUT_SUBFRAME_STRING(pcm_player->format),
-				pcm_player->oversampling);
-	} else if (config) {
-		pcm_player->format = config->pcm_format;
-		pcm_player->oversampling = config->oversampling;
-		snd_printd("Using board specific PCM format (%s%s%s, 0x%08lx)"
-				" and oversampling (%u).\n",
-				FORMAT_STRING(pcm_player->format),
-				DATA_SIZE_STRING(pcm_player->format),
-				OUTPUT_SUBFRAME_STRING(pcm_player->format),
-				pcm_player->format,
-				pcm_player->oversampling);
-	} else {
-		pcm_player->format = DEFAULT_FORMAT;
-		pcm_player->oversampling = DEFAULT_OVERSAMPLING;
-		snd_printd("Using default PCM format (%s%s%s)"
-				" and oversampling (%u).\n",
-				FORMAT_STRING(pcm_player->format),
-				DATA_SIZE_STRING(pcm_player->format),
-				OUTPUT_SUBFRAME_STRING(pcm_player->format),
-				pcm_player->oversampling);
-	}
-	/* Allowed oversampling values */
-	snd_assert(pcm_player->oversampling == 128 ||
-			pcm_player->oversampling == 192 ||
-			pcm_player->oversampling == 256 ||
-			pcm_player->oversampling == 384 ||
-			pcm_player->oversampling == 512 ||
-			pcm_player->oversampling == 768,
-			return -EINVAL);
+	/* Get fsynth device */
+
+	snd_assert(pcm_player->info->fsynth_bus_id != NULL, return -EINVAL);
+	snd_printd("Player connected to %s's output %d.\n",
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+	pcm_player->fsynth_device = snd_stm_find_device(NULL,
+			pcm_player->info->fsynth_bus_id);
+	snd_assert(pcm_player->fsynth_device != NULL, return -EINVAL);
+	pcm_player->fsynth_channel = pcm_player->info->fsynth_output;
 
 	/* Preallocate buffer */
 
@@ -1071,7 +1005,7 @@ static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 	/* Create ALSA lowlevel device */
 
 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_player,
-			&snd_stm_pcm_player_ops);
+			&snd_stm_pcm_player_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
 		goto error_device;
@@ -1079,40 +1013,30 @@ static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 
 	/* Create ALSA PCM device */
 
-	result = snd_pcm_new(card, NULL, card_device, 1, 0, &pcm_player->pcm);
+	result = snd_pcm_new(card, NULL, pcm_player->info->card_device, 1, 0,
+			&pcm_player->pcm);
 	if (result < 0) {
 		snd_stm_printe("ALSA PCM instance creation failed!\n");
 		goto error_pcm;
 	}
 	pcm_player->pcm->private_data = pcm_player;
-	strcpy(pcm_player->pcm->name, component->short_name);
+	strcpy(pcm_player->pcm->name, pcm_player->info->name);
 
 	snd_pcm_set_ops(pcm_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
 			&snd_stm_pcm_player_pcm_ops);
 
-	/* Create ALSA controls */
-
-	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth,
-			pcm_player->fsynth_channel, card, card_device);
-	if (result < 0) {
-		snd_stm_printe("Failed to add ALSA control!\n");
-		goto error_controls;
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, pcm_player);
 
 	snd_printd("--- Probed successfully!\n");
 
-	return result;
+	return 0;
 
-error_controls:
 error_pcm:
 	snd_device_free(card, pcm_player);
 error_device:
-	snd_stm_fdma_release(pcm_player->fdma_channel,
-			pcm_player->fdma_request);
+	snd_stm_fdma_release(pcm_player->fdma_channel);
 error_fdma_request:
 	snd_stm_irq_release(pcm_player->irq, pcm_player);
 error_irq_request:
@@ -1131,8 +1055,7 @@ static int snd_stm_pcm_player_remove(struct platform_device *pdev)
 	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
-	snd_stm_fdma_release(pcm_player->fdma_channel,
-			pcm_player->fdma_request);
+	snd_stm_fdma_release(pcm_player->fdma_channel);
 	snd_stm_irq_release(pcm_player->irq, pcm_player);
 	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
 
diff --git a/sound/soc/stm/pcm_reader.c b/sound/soc/stm/pcm_reader.c
index c84dfc7..9562158 100644
--- a/sound/soc/stm/pcm_reader.c
+++ b/sound/soc/stm/pcm_reader.c
@@ -35,9 +35,10 @@
 #include <sound/pcm.h>
 #include <sound/control.h>
 #include <sound/info.h>
+#include <sound/pcm_params.h>
 
 #undef TRACE /* See common.h debug features */
-#define MAGIC 6 /* See common.h debug features */
+#define MAGIC 7 /* See common.h debug features */
 #include "common.h"
 
 
@@ -46,10 +47,8 @@
  * Some hardware-related definitions
  */
 
-#define DEFAULT_FORMAT \
-		(PLAT_STM_AUDIO__FORMAT_I2S | \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS | \
-		PLAT_STM_AUDIO__DATA_SIZE_24_BITS)
+#define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
+		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
 
 #define MAX_CHANNELS 10
 
@@ -61,8 +60,8 @@
 
 struct snd_stm_pcm_reader {
 	/* System informations */
-	const char *name;
-	const char *bus_id;
+	struct snd_stm_pcm_reader_info *info;
+	struct device *device;
 	struct snd_pcm *pcm;
 
 	/* Resources */
@@ -74,15 +73,8 @@ struct snd_stm_pcm_reader {
 	struct stm_dma_req *fdma_request;
 
 	/* Environment settings */
+	struct snd_stm_conv *conv;
 	struct snd_pcm_hw_constraint_list channels_constraint;
-	unsigned int channels_constraint_list[MAX_CHANNELS / 2];
-
-	/* Board-specific settings */
-	unsigned long format;
-	unsigned int oversampling;
-
-	/* Workaround for L/R swap problem (see further) */
-	int lr_pol;
 
 	/* Runtime data */
 	void *buffer;
@@ -120,15 +112,15 @@ static irqreturn_t snd_stm_pcm_reader_irq_handler(int irq, void *dev_id)
 	/* Overflow? */
 	if (unlikely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, OVF, PENDING))) {
 		snd_stm_printe("Overflow detected in PCM reader '%s'!\n",
-				pcm_reader->bus_id);
-		get_dma_residue(pcm_reader->fdma_channel);
+				pcm_reader->device->bus_id);
 		result = IRQ_HANDLED;
+		snd_pcm_stop(pcm_reader->substream, SNDRV_PCM_STATE_XRUN);
 	}
 
 	/* Period successfully played */
 	if (likely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, VSYNC, PENDING))) {
 		snd_stm_printt("Vsync interrupt detected by '%s'!\n",
-				pcm_reader->bus_id);
+				pcm_reader->device->bus_id);
 		/* TODO: Calculate sampling frequency */
 		result = IRQ_HANDLED;
 	}
@@ -153,7 +145,8 @@ static void snd_stm_pcm_reader_callback_node_done(unsigned long param)
 	/* This function will be called after stopping FDMA as well
 	 * and in this moment ALSA is already shut down... */
 	if (pcm_reader->substream) {
-		snd_stm_printt("Period elapsed ('%s')\n", pcm_reader->bus_id);
+		snd_stm_printt("Period elapsed ('%s')\n",
+				pcm_reader->device->bus_id);
 		snd_pcm_period_elapsed(pcm_reader->substream);
 	}
 }
@@ -170,7 +163,7 @@ static void snd_stm_pcm_reader_callback_node_error(unsigned long param)
 	snd_stm_magic_assert(pcm_reader, return);
 
 	snd_stm_printe("Error during FDMA transfer in reader '%s'!\n",
-			pcm_reader->bus_id);
+			pcm_reader->device->bus_id);
 }
 
 static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
@@ -194,7 +187,7 @@ static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
 	.channels_min	= 2,
 	.channels_max	= 10,
 
-	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_min	= 2,
 	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
 
 	/* Values below were worked out mostly basing on ST media player
@@ -220,6 +213,19 @@ static int snd_stm_pcm_reader_open(struct snd_pcm_substream *substream)
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 
+	snd_pcm_set_sync(substream);  /* TODO: ??? */
+
+	/* Get attached converter handle */
+
+	pcm_reader->conv = snd_stm_conv_get_attached(pcm_reader->device);
+	if (pcm_reader->conv)
+		snd_printd("Converter '%s' attached to '%s'...\n",
+				pcm_reader->conv->name,
+				pcm_reader->device->bus_id);
+	else
+		snd_printd("Warning! No converter attached to '%s'!\n",
+				pcm_reader->device->bus_id);
+
 	/* Set up constraints & pass hardware capabilities info to ALSA */
 
 	result = snd_pcm_hw_constraint_list(runtime, 0,
@@ -239,6 +245,16 @@ static int snd_stm_pcm_reader_open(struct snd_pcm_substream *substream)
 		return result;
 	}
 
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			pcm_reader->info->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
 	runtime->hw = snd_stm_pcm_reader_hw;
 
 	return 0;
@@ -258,6 +274,50 @@ static int snd_stm_pcm_reader_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+static int snd_stm_pcm_reader_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_pcm_reader *pcm_reader =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(pcm_reader, return -EINVAL);
+	snd_stm_magic_assert(pcm_reader, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (pcm_reader->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_reader->device->bus_id,
+				pcm_reader->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
+
+		pcm_reader->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* Dispose FDMA parameters (whole list) */
+		dma_params_free(pcm_reader->fdma_params_list);
+		dma_req_free(pcm_reader->fdma_channel,
+				pcm_reader->fdma_request);
+		kfree(pcm_reader->fdma_params_list);
+	}
+
+	return 0;
+}
+
 static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *hw_params)
 {
@@ -265,7 +325,15 @@ static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 	struct snd_stm_pcm_reader *pcm_reader =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes, period_bytes, periods;
+	int buffer_bytes, period_bytes, periods, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_READ,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = pcm_reader->info->fdma_initiator,
+	};
 	int i;
 
 	snd_stm_printt("snd_stm_pcm_reader_hw_params(substream=0x%p,"
@@ -275,6 +343,10 @@ static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 
+	/* This function may be called many times, so let's be prepared... */
+	if (pcm_reader->buffer)
+		snd_stm_pcm_reader_hw_free(substream);
+
 	/* Get the numbers... */
 
 	buffer_bytes = params_buffer_bytes(hw_params);
@@ -288,8 +360,9 @@ static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 	/* TODO: move to BPA2, use pcm lib as fallback... */
 	if (!pcm_reader->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, pcm_reader->bus_id);
-		return -ENOMEM;
+				buffer_bytes, pcm_reader->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
 	}
 
 	runtime->dma_addr = virt_to_phys(pcm_reader->buffer);
@@ -298,22 +371,47 @@ static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 
 	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
 			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", pcm_reader->bus_id,
+			"dma_bytes=%u\n", pcm_reader->device->bus_id,
 			pcm_reader->buffer, runtime->dma_addr,
 			runtime->dma_area, runtime->dma_bytes);
 
-	/* Configure FDMA transfer (one node per period) */
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			pcm_reader->info->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+
+	snd_stm_printt("FDMA request trigger limit set to %d.\n",
+			transfer_size);
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_reader->info->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+	/* Configure FDMA transfer */
+
+	pcm_reader->fdma_request = dma_req_config(pcm_reader->fdma_channel,
+			pcm_reader->info->fdma_request_line, &fdma_req_config);
+	if (!pcm_reader->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", pcm_reader->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
 
 	pcm_reader->fdma_params_list =
 			kmalloc(sizeof(*pcm_reader->fdma_params_list) *
-					periods, GFP_KERNEL);
+			periods, GFP_KERNEL);
 	if (!pcm_reader->fdma_params_list) {
 		/* TODO: move to BPA2 (see above) */
 		snd_stm_printe("Can't allocate %d bytes for FDMA parameters "
 				"list!\n", sizeof(*pcm_reader->fdma_params_list)
 				* periods);
-		bigphysarea_free(runtime->dma_area, runtime->dma_bytes);
-		return -ENOMEM;
+		result = -ENOMEM;
+		goto error_params_alloc;
 	}
 
 	snd_stm_printt("Configuring FDMA transfer nodes:\n");
@@ -358,72 +456,106 @@ static int snd_stm_pcm_reader_hw_params(struct snd_pcm_substream *substream,
 				pcm_reader->fdma_params_list, GFP_KERNEL);
 	if (result < 0) {
 		snd_stm_printe("Can't compile FDMA parameters for"
-				" reader '%s'!\n", pcm_reader->bus_id);
-		bigphysarea_free(runtime->dma_area, runtime->dma_bytes);
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
-		kfree(pcm_reader->fdma_params_list);
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		return -EINVAL;
+				" reader '%s'!\n", pcm_reader->device->bus_id);
+		goto error_compile_list;
 	}
 
 	return 0;
+
+error_compile_list:
+	dma_req_free(pcm_reader->fdma_channel,
+			pcm_reader->fdma_request);
+error_req_config:
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
+	pcm_reader->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
+error_params_alloc:
+	kfree(pcm_reader->fdma_params_list);
+error_buf_alloc:
+	return result;
 }
 
-static int snd_stm_pcm_reader_hw_free(struct snd_pcm_substream *substream)
+static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_stm_pcm_reader *pcm_reader =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int format, lr_pol;
 
-	snd_stm_printt("snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_prepare(substream=0x%p)\n",
 			substream);
 
 	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 
-	/* This callback may be called more than once... */
+	/* Get format value from connected converter */
 
-	if (pcm_reader->buffer) {
-		/* Dispose buffer */
+	if (pcm_reader->conv)
+		format = snd_stm_conv_get_format(pcm_reader->conv);
+	else
+		format = DEFAULT_FORMAT;
 
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", pcm_reader->bus_id,
-				pcm_reader->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
-
-		iounmap(runtime->dma_area);
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
+	/* Number of bits per subframe (which is one channel sample)
+	 * on input. */
 
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
-		pcm_reader->buffer = NULL;
-
-		/* Dispose FDMA parameters (whole list) */
-		dma_params_free(pcm_reader->fdma_params_list);
-		kfree(pcm_reader->fdma_params_list);
+	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
+		snd_stm_printt("- 32 bits per subframe\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 32_BITS);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				DATA_SIZE, 24_BITS);
+		break;
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
+		snd_stm_printt("- 16 bits per subframe\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 16_BITS);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				DATA_SIZE, 16_BITS);
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
 	}
 
-	return 0;
-}
-
-static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_pcm_reader *pcm_reader =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_pcm_reader_prepare(substream=0x%p)\n",
-			substream);
-
-	snd_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
+	/* Serial audio interface format -
+	 * for detailed explanation see ie.
+	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
+
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+			ORDER, MSB_FIRST);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+			SCLK_EDGE, RISING);
+	switch (format & SND_STM_FORMAT__MASK) {
+	case SND_STM_FORMAT__I2S:
+		snd_stm_printt("- I2S\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, 1_CYCLE_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
+		break;
+	case SND_STM_FORMAT__LEFT_JUSTIFIED:
+		snd_stm_printt("- left justified\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
+		break;
+	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
+		snd_stm_printt("- right justified\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				ALIGN, RIGHT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
 
 	/* Configure data memory format */
 
@@ -441,8 +573,7 @@ static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
 		 * phases are shifted by one sample...
 		 * (ask me for more details if above is not clear ;-)
 		 * TODO this somehow better... */
-		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL,
-				!pcm_reader->lr_pol);
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, !lr_pol);
 		break;
 
 	case SNDRV_PCM_FORMAT_S32_LE:
@@ -453,13 +584,12 @@ static int snd_stm_pcm_reader_prepare(struct snd_pcm_substream *substream)
 
 		/* In x/0 bits memory mode there is no problem with
 		 * L/R polarity */
-		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL,
-				pcm_reader->lr_pol);
-			break;
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, lr_pol);
+		break;
 
 	default:
-		snd_assert(0, return -EINVAL);
-		break;
+		snd_BUG();
+		return -EINVAL;
 	}
 
 	/* Number of channels... */
@@ -499,7 +629,7 @@ static inline int snd_stm_pcm_reader_start(struct snd_pcm_substream *substream)
 			pcm_reader->fdma_params_list);
 	if (result != 0) {
 		snd_stm_printe("Can't launch FDMA transfer for reader '%s'!\n",
-				pcm_reader->bus_id);
+				pcm_reader->device->bus_id);
 		return -EINVAL;
 	}
 
@@ -513,6 +643,13 @@ static inline int snd_stm_pcm_reader_start(struct snd_pcm_substream *substream)
 	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, VSYNC, SET);
 	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, OVF, SET);
 
+	/* Wake up & unmute ADC */
+
+	if (pcm_reader->conv) {
+		snd_stm_conv_enable(pcm_reader->conv);
+		snd_stm_conv_unmute(pcm_reader->conv);
+	}
+
 	return 0;
 }
 
@@ -527,6 +664,13 @@ static inline int snd_stm_pcm_reader_stop(struct snd_pcm_substream *substream)
 	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
+	/* Mute & shutdown DAC */
+
+	if (pcm_reader->conv) {
+		snd_stm_conv_mute(pcm_reader->conv);
+		snd_stm_conv_disable(pcm_reader->conv);
+	}
+
 	/* Disable interrupts */
 
 	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, VSYNC, CLEAR);
@@ -636,6 +780,7 @@ static void snd_stm_pcm_reader_dump_registers(struct snd_info_entry *entry,
 
 static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
 {
+	int result;
 	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
 
 	snd_stm_printt("snd_stm_pcm_reader_register(snd_device=0x%p)\n",
@@ -644,7 +789,7 @@ static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
 	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	/* Initialize hardware (format etc.) */
+	/* Set reset mode */
 
 	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
 
@@ -652,102 +797,21 @@ static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
 	 * And what it actually means? */
 	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, RND, NO_ROUNDING);
 
-	if (pcm_reader->format & PLAT_STM_AUDIO__CUSTOM) {
-		/* Custom format settings... Well, you asked for it! ;-) */
-		REGISTER_POKE(pcm_reader->base, AUD_PCMIN_CTRL,
-				pcm_reader->format & !PLAT_STM_AUDIO__CUSTOM);
-	} else {
-		/* Number of bits per subframe (which is one channel sample)
-		 * on input. */
-
-		switch (pcm_reader->format &
-				PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) {
-		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					NBIT, 32_BITS);
-			break;
-		case PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					NBIT, 16_BITS);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
-
-		/* Number of meaningful bits in subframe -
-		 * the rest are ignored */
-
-		switch (pcm_reader->format & PLAT_STM_AUDIO__DATA_SIZE_MASK) {
-		case PLAT_STM_AUDIO__DATA_SIZE_24_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					DATA_SIZE, 24_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_20_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					DATA_SIZE, 20_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_18_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					DATA_SIZE, 18_BITS);
-			break;
-		case PLAT_STM_AUDIO__DATA_SIZE_16_BITS:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					DATA_SIZE, 16_BITS);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
-
-		/* Serial audio interface format -
-		 * for detailed explanation see ie.
-		 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
-
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				ORDER, MSB_FIRST);
-		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-				SCLK_EDGE, RISING);
-		switch (pcm_reader->format & PLAT_STM_AUDIO__FORMAT_MASK) {
-		case PLAT_STM_AUDIO__FORMAT_I2S:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					ALIGN, LEFT);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					PADDING, 1_CYCLE_DELAY);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					LR_POL, LEFT_LOW);
-			break;
-		case PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					ALIGN, LEFT);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					PADDING, NO_DELAY);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					LR_POL, LEFT_HIGH);
-			break;
-		case PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED:
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					ALIGN, RIGHT);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					PADDING, NO_DELAY);
-			REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
-					LR_POL, LEFT_HIGH);
-			break;
-		default:
-			snd_assert(0, return -EINVAL);
-			break;
-		}
-	}
-
-	/* Workaround for 16/16 memory format L/R channels swap (see above) */
-	pcm_reader->lr_pol = REGFIELD_PEEK(pcm_reader->base,
-			AUD_PCMIN_FMT, LR_POL);
-
 	/* Registers view in ALSA's procfs */
 
-	snd_stm_info_register(&pcm_reader->proc_entry, pcm_reader->bus_id,
+	snd_stm_info_register(&pcm_reader->proc_entry,
+			pcm_reader->device->bus_id,
 			snd_stm_pcm_reader_dump_registers, pcm_reader);
 
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(pcm_reader->device,
+			snd_device->card, pcm_reader->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
 	return 0;
 }
 
@@ -763,7 +827,7 @@ static int snd_stm_pcm_reader_disconnect(struct snd_device *snd_device)
 	return 0;
 }
 
-static struct snd_device_ops snd_stm_pcm_reader_ops = {
+static struct snd_device_ops snd_stm_pcm_reader_snd_device_ops = {
 	.dev_register = snd_stm_pcm_reader_register,
 	.dev_disconnect = snd_stm_pcm_reader_disconnect,
 };
@@ -771,77 +835,18 @@ static struct snd_device_ops snd_stm_pcm_reader_ops = {
 
 
 /*
- * Driver initialization
+ * Platform driver routines
  */
 
-#define FORMAT_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "custom" : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_I2S ? "I2S, " : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_LEFT_JUSTIFIED ? \
-		"left justified, " : \
-	(f & PLAT_STM_AUDIO__FORMAT_MASK) == \
-		PLAT_STM_AUDIO__FORMAT_RIGHT_JUSTIFIED ? \
-		"right justified, " : \
-	"")
-
-#define DATA_SIZE_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "" : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_24_BITS ? \
-		"24 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_20_BITS ? \
-		"20 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_18_BITS ? \
-		"18 bits data, " : \
-	(f & PLAT_STM_AUDIO__DATA_SIZE_MASK) == \
-		PLAT_STM_AUDIO__DATA_SIZE_16_BITS ? \
-		"16 bits data, " : \
-	"")
-
-#define OUTPUT_SUBFRAME_STRING(f) \
-	((f & PLAT_STM_AUDIO__CUSTOM) == \
-		PLAT_STM_AUDIO__CUSTOM ? "" : \
-	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_32_BITS ? \
-		"32 bits output subframe" : \
-	(f & PLAT_STM_AUDIO__OUTPUT_SUBFRAME_MASK) == \
-		PLAT_STM_AUDIO__OUTPUT_SUBFRAME_16_BITS ? \
-		"16 bits output subframe" : \
-	"")
-
-static struct stm_dma_req_config snd_stm_pcm_reader_fdma_request_config = {
-	.rw        = REQ_CONFIG_READ,
-	.opcode    = REQ_CONFIG_OPCODE_4,
-	.count     = 1,
-	.increment = 0,
-	.hold_off  = 0,
-	/* .initiator value is defined in platform device resources */
-};
-
 static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 {
 	int result = 0;
-	struct plat_audio_config *config = pdev->dev.platform_data;
-	struct snd_stm_component *component;
 	struct snd_stm_pcm_reader *pcm_reader;
 	struct snd_card *card;
-	int card_device;
-	int *channels_list;
-	int channels_list_len;
-	const char *card_id;
 	int i;
 
 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
-
 	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
 	if (!pcm_reader) {
 		snd_stm_printe("Can't allocate memory "
@@ -850,7 +855,9 @@ static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 		goto error_alloc;
 	}
 	snd_stm_magic_set(pcm_reader);
-	pcm_reader->bus_id = pdev->dev.bus_id;
+	pcm_reader->info = pdev->dev.platform_data;
+	snd_assert(pcm_reader->info != NULL, return -EINVAL);
+	pcm_reader->device = &pdev->dev;
 
 	/* Get resources */
 
@@ -872,60 +879,29 @@ static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 		goto error_irq_request;
 	}
 
-	result = snd_stm_fdma_request(pdev, &pcm_reader->fdma_channel,
-			&pcm_reader->fdma_request,
-			&snd_stm_pcm_reader_fdma_request_config);
+	result = snd_stm_fdma_request(pdev, &pcm_reader->fdma_channel);
 	if (result < 0) {
 		snd_stm_printe("FDMA request failed!\n");
 		goto error_fdma_request;
 	}
 
-	/* Get component caps */
+	/* Get component capabilities */
 
-	snd_printd("Reader's name is '%s'\n", component->short_name);
+	snd_printd("Reader's name is '%s'\n", pcm_reader->info->name);
 
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	snd_assert(result == 0, return -EINVAL);
-	card = snd_stm_cards_get(card_id);
+	card = snd_stm_cards_get(pcm_reader->info->card_id);
 	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Reader will be a member of a card '%s'...\n", card_id);
-
-	result = snd_stm_cap_get_number(component, "card_device",
-			&card_device);
-	snd_assert(result == 0, return -EINVAL);
-	snd_printd("... as a PCM device no %d.\n", card_device);
-
-	result = snd_stm_cap_get_list(component, "channels", &channels_list,
-			&channels_list_len);
-	snd_assert(result == 0, return -EINVAL);
-	memcpy(pcm_reader->channels_constraint_list, channels_list,
-			sizeof(*channels_list) * channels_list_len);
-	pcm_reader->channels_constraint.list =
-			pcm_reader->channels_constraint_list;
-	pcm_reader->channels_constraint.count =
-		(unsigned int)channels_list_len;
+	snd_printd("Reader will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, pcm_reader->info->card_device);
+
+	snd_assert(pcm_reader->info->channels != NULL, return -EINVAL);
+	snd_assert(pcm_reader->info->channels_num > 0, return -EINVAL);
+	pcm_reader->channels_constraint.list = pcm_reader->info->channels;
+	pcm_reader->channels_constraint.count = pcm_reader->info->channels_num;
 	pcm_reader->channels_constraint.mask = 0;
-	for (i = 0; i < channels_list_len; i++)
-		snd_printd("Reader capable of capturing %d-channels PCM.\n",
-				channels_list[i]);
-
-	/* Board-specific configuration */
-
-	if (config) {
-		pcm_reader->format = config->pcm_format;
-		snd_printd("Using board specific PCM format"
-				" (%s%s%s, 0x%08lx).\n",
-				FORMAT_STRING(pcm_reader->format),
-				DATA_SIZE_STRING(pcm_reader->format),
-				OUTPUT_SUBFRAME_STRING(pcm_reader->format),
-				pcm_reader->format);
-	} else {
-		pcm_reader->format = DEFAULT_FORMAT;
-		snd_printd("Using default PCM format (%s%s%s).\n",
-				FORMAT_STRING(pcm_reader->format),
-				DATA_SIZE_STRING(pcm_reader->format),
-				OUTPUT_SUBFRAME_STRING(pcm_reader->format));
-	}
+	for (i = 0; i < pcm_reader->info->channels_num; i++)
+		snd_printd("Player capable of playing %u-channels PCM.\n",
+				pcm_reader->info->channels[i]);
 
 	/* Preallocate buffer */
 
@@ -934,7 +910,7 @@ static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 	/* Create ALSA lowlevel device */
 
 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcm_reader,
-			&snd_stm_pcm_reader_ops);
+			&snd_stm_pcm_reader_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
 		goto error_device;
@@ -942,13 +918,14 @@ static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 
 	/* Create ALSA PCM device */
 
-	result = snd_pcm_new(card, NULL, card_device, 0, 1, &pcm_reader->pcm);
+	result = snd_pcm_new(card, NULL, pcm_reader->info->card_device, 0, 1,
+		       &pcm_reader->pcm);
 	if (result < 0) {
 		snd_stm_printe("ALSA PCM instance creation failed!\n");
 		goto error_pcm;
 	}
 	pcm_reader->pcm->private_data = pcm_reader;
-	strcpy(pcm_reader->pcm->name, component->short_name);
+	strcpy(pcm_reader->pcm->name, pcm_reader->info->name);
 
 	snd_pcm_set_ops(pcm_reader->pcm, SNDRV_PCM_STREAM_CAPTURE,
 			&snd_stm_pcm_reader_pcm_ops);
@@ -959,13 +936,12 @@ static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 
 	snd_printd("--- Probed successfully!\n");
 
-	return result;
+	return 0;
 
 error_pcm:
 	snd_device_free(card, pcm_reader);
 error_device:
-	snd_stm_fdma_release(pcm_reader->fdma_channel,
-			pcm_reader->fdma_request);
+	snd_stm_fdma_release(pcm_reader->fdma_channel);
 error_fdma_request:
 	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
 error_irq_request:
@@ -984,8 +960,7 @@ static int snd_stm_pcm_reader_remove(struct platform_device *pdev)
 	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	snd_stm_fdma_release(pcm_reader->fdma_channel,
-			pcm_reader->fdma_request);
+	snd_stm_fdma_release(pcm_reader->fdma_channel);
 	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
 	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
 
diff --git a/sound/soc/stm/spdif_player.c b/sound/soc/stm/spdif_player.c
index e8e1508..0dcee51 100644
--- a/sound/soc/stm/spdif_player.c
+++ b/sound/soc/stm/spdif_player.c
@@ -48,13 +48,12 @@
  * Some hardware-related definitions
  */
 
-#define INIT_SAMPLING_RATE 32000
-
 #define DEFAULT_OVERSAMPLING 128
 
 /* The sample count field (MEMREAD in CTRL register) is 17 bits wide */
 #define MAX_SAMPLES_PER_PERIOD ((1 << 17) - 1)
 
+#define PREAMBLE_BYTES 8
 
 
 /*
@@ -71,10 +70,19 @@ enum snd_stm_spdif_player_encoding_mode {
 	SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED
 };
 
+struct snd_stm_spdif_player_settings {
+	enum snd_stm_spdif_player_input_mode input_mode;
+	enum snd_stm_spdif_player_encoding_mode encoding_mode;
+	struct snd_aes_iec958 iec958;
+	unsigned char iec61937_preamble[PREAMBLE_BYTES]; /* Used in */
+	unsigned int iec61937_audio_repetition;          /* encoded */
+	unsigned int iec61937_pause_repetition;          /* mode */
+};
+
 struct snd_stm_spdif_player {
 	/* System informations */
-	const char *name;
-	const char *bus_id;
+	struct snd_stm_spdif_player_info *info;
+	struct device *device;
 	struct snd_pcm *pcm;
 
 	/* Resources */
@@ -82,33 +90,26 @@ struct snd_stm_spdif_player {
 	void *base;
 	unsigned long fifo_phys_address;
 	unsigned int irq;
-	int fdma_channel;
-	struct stm_dma_req *fdma_request;
+	unsigned int fdma_channel;
 
 	/* Environment settings */
-	struct device *fsynth;
+	struct device *fsynth_device;
 	int fsynth_channel;
+	struct snd_stm_conv *conv;
 
-	/* Board-specific settings */
-	unsigned int oversampling;
-
-	/* Default configuration */
-	enum snd_stm_spdif_player_input_mode input_mode_default;
-	enum snd_stm_spdif_player_encoding_mode encoding_mode_default;
-	spinlock_t modes_default_lock; /* Protects above two enums */
-	struct snd_aes_iec958 vuc_default;
-	spinlock_t vuc_default_lock; /* Protects vuc_default */
+	/* Default settings (controlled by controls ;-) */
+	struct snd_stm_spdif_player_settings default_settings;
+	spinlock_t default_settings_lock; /* Protects default_settings */
 
 	/* Runtime data */
 	void *buffer;
 	struct snd_info_entry *proc_entry;
 	struct snd_pcm_substream *substream;
 	struct stm_dma_params fdma_params;
-	struct snd_aes_iec958 vuc_stream;
-	spinlock_t vuc_stream_lock; /* Protects vuc_stream */
-	enum snd_stm_spdif_player_input_mode input_mode;
-	enum snd_stm_spdif_player_encoding_mode encoding_mode;
-	struct snd_aes_iec958 vuc;
+	struct stm_dma_req *fdma_request;
+	struct snd_stm_spdif_player_settings stream_settings;
+	int stream_iec958_status_cnt;
+	int stream_iec958_subcode_cnt;
 
 	snd_stm_magic_field;
 };
@@ -140,7 +141,7 @@ static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
 	/* Underflow? */
 	if (unlikely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, UNF, PENDING))) {
 		snd_stm_printe("Underflow detected in SPDIF player '%s'!\n",
-				spdif_player->bus_id);
+				spdif_player->device->bus_id);
 		result = IRQ_HANDLED;
 	}
 
@@ -150,7 +151,7 @@ static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
 			snd_assert(spdif_player->substream, break);
 
 			snd_stm_printt("Period elapsed ('%s')\n",
-					spdif_player->bus_id);
+					spdif_player->device->bus_id);
 			snd_pcm_period_elapsed(spdif_player->substream);
 
 			result = IRQ_HANDLED;
@@ -166,8 +167,7 @@ static irqreturn_t snd_stm_spdif_player_irq_handler(int irq, void *dev_id)
  * It means:
  * 1. A lot of parsing...
  * 2. MMAPing is impossible...
- * 3. We can handle different formats and use ALSA standard
- *    structure for channel status & user data: snd_aes_iec958 */
+ * 3. We can handle some other formats! */
 static struct snd_pcm_hardware snd_stm_spdif_player_hw_normal = {
 	.info		= (SNDRV_PCM_INFO_INTERLEAVED |
 				SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -177,14 +177,19 @@ static struct snd_pcm_hardware snd_stm_spdif_player_hw_normal = {
 
 	.rates		= (SNDRV_PCM_RATE_32000 |
 				SNDRV_PCM_RATE_44100 |
-				SNDRV_PCM_RATE_48000),
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
-	.rate_max	= 48000,
+	.rate_max	= 192000,
 
 	.channels_min	= 2,
 	.channels_max	= 2,
 
-	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_min	= 2,
 	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
 
 	/* Values below were worked out mostly basing on ST media player
@@ -228,14 +233,19 @@ static struct snd_pcm_hardware snd_stm_spdif_player_hw_raw = {
 
 	.rates		= (SNDRV_PCM_RATE_32000 |
 				SNDRV_PCM_RATE_44100 |
-				SNDRV_PCM_RATE_48000),
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
-	.rate_max	= 48000,
+	.rate_max	= 192000,
 
 	.channels_min	= 2,
 	.channels_max	= 2,
 
-	.periods_min	= 1,     /* TODO: I would say 2... */
+	.periods_min	= 2,
 	.periods_max	= 1024,  /* TODO: sample, work out this somehow... */
 
 	/* See above... */
@@ -260,16 +270,22 @@ static int snd_stm_spdif_player_open(struct snd_pcm_substream *substream)
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
-	/* Get default data */
+	/* Get attached converter handle */
 
-	spin_lock(&spdif_player->vuc_default_lock);
-	spdif_player->vuc_stream = spdif_player->vuc_default;
-	spin_unlock(&spdif_player->vuc_default_lock);
+	spdif_player->conv = snd_stm_conv_get_attached(spdif_player->device);
+	if (spdif_player->conv)
+		snd_printd("Converter '%s' attached to '%s'...\n",
+				spdif_player->conv->name,
+				spdif_player->device->bus_id);
+	else
+		snd_printd("Warning! No converter attached to '%s'!\n",
+				spdif_player->device->bus_id);
+
+	/* Get default data */
 
-	spin_lock(&spdif_player->modes_default_lock);
-	spdif_player->encoding_mode = spdif_player->encoding_mode_default;
-	spdif_player->input_mode = spdif_player->input_mode_default;
-	spin_unlock(&spdif_player->modes_default_lock);
+	spin_lock(&spdif_player->default_settings_lock);
+	spdif_player->stream_settings = spdif_player->default_settings;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	/* Set up constraints & pass hardware capabilities info to ALSA */
 
@@ -282,7 +298,18 @@ static int snd_stm_spdif_player_open(struct snd_pcm_substream *substream)
 		return result;
 	}
 
-	if (spdif_player->input_mode == SNDRV_STM_SPDIF_INPUT_MODE_NORMAL)
+	/* Make the period (so buffer as well) length (in bytes) a multiply
+	 * of a FDMA transfer bytes (which varies depending on channels
+	 * number and sample bytes) */
+	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
+			spdif_player->info->fdma_max_transfer_size * 4);
+	if (result < 0) {
+		snd_stm_printe("Can't set buffer bytes constraint!\n");
+		return result;
+	}
+
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL)
 		runtime->hw = snd_stm_spdif_player_hw_normal;
 	else
 		runtime->hw = snd_stm_spdif_player_hw_raw;
@@ -304,6 +331,50 @@ static int snd_stm_spdif_player_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+static int snd_stm_spdif_player_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_stm_spdif_player *spdif_player =
+			snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	snd_stm_printt("snd_stm_spdif_player_hw_free(substream=0x%p)\n",
+			substream);
+
+	snd_assert(spdif_player, return -EINVAL);
+	snd_stm_magic_assert(spdif_player, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
+
+	/* This callback may be called more than once... */
+
+	if (spdif_player->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", spdif_player->device->bus_id,
+				spdif_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
+
+		spdif_player->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+
+		/* Dispose FDMA parameters */
+
+		dma_params_free(&spdif_player->fdma_params);
+		dma_req_free(spdif_player->fdma_channel,
+				spdif_player->fdma_request);
+	}
+
+	return 0;
+}
+
 static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *hw_params)
 {
@@ -311,7 +382,15 @@ static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int buffer_bytes;
+	int buffer_bytes, frame_bytes, transfer_bytes;
+	unsigned int transfer_size;
+	struct stm_dma_req_config fdma_req_config = {
+		.rw        = REQ_CONFIG_WRITE,
+		.opcode    = REQ_CONFIG_OPCODE_4,
+		.increment = 0,
+		.hold_off  = 0,
+		.initiator = spdif_player->info->fdma_initiator,
+	};
 
 	snd_stm_printt("snd_stm_spdif_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
@@ -320,6 +399,10 @@ static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 
+	/* This function may be called many times, so let's be prepared... */
+	if (spdif_player->buffer)
+		snd_stm_spdif_player_hw_free(substream);
+
 	/* Allocate buffer */
 
 	buffer_bytes = params_buffer_bytes(hw_params);
@@ -327,8 +410,9 @@ static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 	/* TODO: move to BPA2, use pcm lib as fallback... */
 	if (!spdif_player->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
-				buffer_bytes, spdif_player->bus_id);
-		return -ENOMEM;
+				buffer_bytes, spdif_player->device->bus_id);
+		result = -ENOMEM;
+		goto error_buf_alloc;
 	}
 
 	runtime->dma_addr = virt_to_phys(spdif_player->buffer);
@@ -337,14 +421,49 @@ static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 
 	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
 			"dma_addr=0x%08x, dma_area=0x%p, "
-			"dma_bytes=%u\n", spdif_player->bus_id,
+			"dma_bytes=%u\n", spdif_player->device->bus_id,
 			spdif_player->buffer, runtime->dma_addr,
 			runtime->dma_area, runtime->dma_bytes);
 
+	/* Set FDMA transfer size (number of opcodes generated
+	 * after request line assertion) */
+
+	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
+			params_channels(hw_params) / 8;
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
+			spdif_player->info->fdma_max_transfer_size * 4);
+	transfer_size = transfer_bytes / 4;
+	snd_stm_printt("FDMA request trigger limit and transfer size set to "
+			"%d.\n", transfer_size);
+
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= spdif_player->info->fdma_max_transfer_size,
+			return -EINVAL);
+	fdma_req_config.count = transfer_size;
+
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+			return -EINVAL);
+	snd_assert(transfer_size <= AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK,
+			return -EINVAL);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CONFIG,
+			DMA_REQ_TRIG_LMT, transfer_size);
+#endif
+
 	/* Configure FDMA transfer */
 
 	/* TODO: try to use SPDIF FMDA channel */
 
+	spdif_player->fdma_request = dma_req_config(spdif_player->fdma_channel,
+			spdif_player->info->fdma_request_line,
+			&fdma_req_config);
+	if (!spdif_player->fdma_request) {
+		snd_stm_printe("Can't configure FDMA pacing channel for player"
+				" '%s'!\n", spdif_player->device->bus_id);
+		result = -EINVAL;
+		goto error_req_config;
+	}
+
 	dma_params_init(&spdif_player->fdma_params, MODE_PACED,
 			STM_DMA_LIST_CIRC);
 
@@ -359,78 +478,81 @@ static int snd_stm_spdif_player_hw_params(struct snd_pcm_substream *substream,
 				&spdif_player->fdma_params, GFP_KERNEL);
 	if (result < 0) {
 		snd_stm_printe("Can't compile FDMA parameters for player"
-				" '%s'!\n", spdif_player->bus_id);
-		return -EINVAL;
+				" '%s'!\n", spdif_player->device->bus_id);
+		goto error_compile_list;
 	}
 
 	return 0;
+
+error_compile_list:
+	dma_req_free(spdif_player->fdma_channel,
+			spdif_player->fdma_request);
+error_req_config:
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
+	spdif_player->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
+error_buf_alloc:
+	return result;
 }
 
-static int snd_stm_spdif_player_hw_free(struct snd_pcm_substream *substream)
+static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	int oversampling;
+	unsigned long status;
+	struct snd_aes_iec958 *iec958;
 
-	snd_stm_printt("snd_stm_spdif_player_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_prepare(substream=0x%p)\n",
 			substream);
 
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
+			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
 
-	/* This callback may be called more than once... */
-
-	if (spdif_player->buffer) {
-		/* Dispose buffer */
+	/* Configure SPDIF-PCM synchronisation */
 
-		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
-				"dma_addr=0x%08x, dma_area=0x%p, "
-				"dma_bytes=%u\n", spdif_player->bus_id,
-				spdif_player->buffer, runtime->dma_addr,
-				runtime->dma_area, runtime->dma_bytes);
+	/* TODO */
 
-		iounmap(runtime->dma_area);
-		runtime->dma_area = NULL;
-		runtime->dma_addr = 0;
-		runtime->dma_bytes = 0;
+	/* Get oversampling value from connected converter */
 
-		/* TODO: symmetrical to the above (BPA2 etc.) */
-		bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
-		spdif_player->buffer = NULL;
+	if (spdif_player->conv) {
+		unsigned int format =
+				snd_stm_conv_get_format(spdif_player->conv);
 
-		/* Dispose FDMA parameters */
+		snd_assert((format & SND_STM_FORMAT__MASK) ==
+				SND_STM_FORMAT__SPDIF, return -EINVAL);
 
-		dma_params_free(&spdif_player->fdma_params);
+		oversampling = snd_stm_conv_get_oversampling(
+				spdif_player->conv);
+		if (oversampling == 0)
+			oversampling = DEFAULT_OVERSAMPLING;
+	} else {
+		oversampling = DEFAULT_OVERSAMPLING;
 	}
 
-	return 0;
-}
+	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
+			spdif_player->device->bus_id, runtime->rate,
+			oversampling);
 
-static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_stm_spdif_player *spdif_player =
-			snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	snd_stm_printt("snd_stm_spdif_player_prepare(substream=0x%p)\n",
-			substream);
-
-	snd_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_assert(runtime, return -EINVAL);
-	snd_assert(runtime->period_size * runtime->channels <
-			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
+	snd_assert(oversampling > 0, return -EINVAL);
 
-	/* Configure SPDIF-PCM synchronisation */
-
-	/* TODO */
+	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
+	 * so oversampling must be multiple of 128... */
+	snd_assert(oversampling % 128 == 0, return -EINVAL);
 
 	/* Set up frequency synthesizer */
 
-	snd_stm_fsynth_set_frequency(spdif_player->fsynth,
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth_device,
 			spdif_player->fsynth_channel,
-			runtime->rate * spdif_player->oversampling);
+			runtime->rate * oversampling);
 
 	/* Configure SPDIF player frequency divider
 	 *
@@ -448,7 +570,7 @@ static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
 	 */
 
 	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, CLK_DIV,
-			spdif_player->oversampling / 128);
+			oversampling / 128);
 
 	/* Configure NSAMPLE interrupt (in samples,
 	 * so period size times channels) */
@@ -456,6 +578,66 @@ static int snd_stm_spdif_player_prepare(struct snd_pcm_substream *substream)
 	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, MEMREAD,
 			runtime->period_size * 2);
 
+	/* Reset IEC958 software formatting counters */
+
+	spdif_player->stream_iec958_status_cnt = 0;
+	spdif_player->stream_iec958_subcode_cnt = 0;
+
+	/* Set VUC register settings */
+
+	/* Channel status */
+	iec958 = &spdif_player->stream_settings.iec958;
+	status = iec958->status[0] | iec958->status[1] << 8 |
+		iec958->status[2] << 16 | iec958->status[3] << 24;
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL1,
+			CL1, status);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
+			CL2, iec958->status[4] & 0xf);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CR1,
+			CR1, status);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
+			CR2, iec958->status[4] & 0xf);
+
+	/* User data - well, can't do too much here... */
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LU, 0);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RU, 0);
+
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM) {
+		/* Linear PCM: validity bit are zeroed */
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 0);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 0);
+	} else {
+		struct snd_stm_spdif_player_settings *settings =
+				&spdif_player->stream_settings;
+
+		/* Encoded mode: validity bits are one */
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 1);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 1);
+
+		/* Number of frames is data/pause bursts */
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, DBURST,
+				settings->iec61937_audio_repetition);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, PDBURST,
+				settings->iec61937_pause_repetition);
+
+		/* IEC61937 Preamble */
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PA,
+				settings->iec61937_preamble[0] |
+				settings->iec61937_preamble[1] << 8);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PB,
+				settings->iec61937_preamble[2] |
+				settings->iec61937_preamble[3] << 8);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PC,
+				settings->iec61937_preamble[4] |
+				settings->iec61937_preamble[5] << 8);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PD,
+				settings->iec61937_preamble[6] |
+				settings->iec61937_preamble[7] << 8);
+
+		/* TODO: set AUD_SPDIF_PAU_LAT NPD_BURST somehow... */
+	}
+
 	return 0;
 }
 
@@ -482,7 +664,7 @@ static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
 			&spdif_player->fdma_params);
 	if (result != 0) {
 		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
-				spdif_player->bus_id);
+				spdif_player->device->bus_id);
 		return -EINVAL;
 	}
 
@@ -490,7 +672,8 @@ static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
 
 	spdif_player->substream = substream;
 
-	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
 		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
 	else
 		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
@@ -500,6 +683,13 @@ static inline int snd_stm_spdif_player_start(struct snd_pcm_substream
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, NSAMPLE, SET);
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, UNF, SET);
 
+	/* Wake up & unmute converter */
+
+	if (spdif_player->conv) {
+		snd_stm_conv_enable(spdif_player->conv);
+		snd_stm_conv_unmute(spdif_player->conv);
+	}
+
 	return 0;
 }
 
@@ -514,6 +704,13 @@ static inline int snd_stm_spdif_player_stop(struct snd_pcm_substream *substream)
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
+	/* Mute & shutdown converter */
+
+	if (spdif_player->conv) {
+		snd_stm_conv_mute(spdif_player->conv);
+		snd_stm_conv_disable(spdif_player->conv);
+	}
+
 	/* Disable interrupts */
 
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, NSAMPLE, CLEAR);
@@ -529,6 +726,7 @@ static inline int snd_stm_spdif_player_stop(struct snd_pcm_substream *substream)
 	dma_stop_channel(spdif_player->fdma_channel);
 
 	/* Reset SPDIF player */
+
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
 
 	return 0;
@@ -550,7 +748,8 @@ static inline int snd_stm_spdif_player_pause(struct snd_pcm_substream
 	 * Documentation describes this mode in a wrong way - data is _not_
 	 * consumed in the "mute" mode, so it is actually a "pause" mode */
 
-	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
 		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
 				MUTE_PCM_NULL);
 	else
@@ -574,7 +773,8 @@ static inline int snd_stm_spdif_player_release(struct snd_pcm_substream
 
 	/* "Unmute" player */
 
-	if (spdif_player->encoding_mode == SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
+	if (spdif_player->stream_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
 		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
 	else
 		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
@@ -629,15 +829,63 @@ static snd_pcm_uframes_t snd_stm_spdif_player_pointer(struct snd_pcm_substream
 	return pointer;
 }
 
+#define VUC_MASK 0xf
+#define V_BIT (1 << 3)
+#define U_BIT (1 << 2)
+#define C_BIT (1 << 1)
+
 #define GET_SAMPLE(kernel_var, user_ptr, memory_format) \
 	do { \
 		__get_user(kernel_var, (memory_format __user *)user_ptr); \
 		(*((memory_format __user **)&user_ptr))++; \
 	} while (0);
 
+static void snd_stm_spdif_player_format_frame(struct snd_stm_spdif_player
+		*spdif_player, unsigned long *left_subframe,
+		unsigned long *right_subframe)
+{
+	unsigned char data;
+
+	snd_assert(spdif_player, return);
+	snd_stm_magic_assert(spdif_player, return);
+
+	/* Clean VUC bits */
+	*left_subframe &= ~VUC_MASK;
+	*right_subframe &= ~VUC_MASK;
+
+	/* Validity bit should be set to one when non-PCM data are
+	 * transmitted... */
+	if (spdif_player->stream_settings.encoding_mode) {
+		*left_subframe |= V_BIT;
+		*right_subframe |= V_BIT;
+	}
+
+	/* User data consists of both subframe U-bits */
+	data = spdif_player->stream_settings.iec958.subcode[
+			spdif_player->stream_iec958_subcode_cnt / 8];
+	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
+		*left_subframe |= U_BIT;
+	spdif_player->stream_iec958_subcode_cnt++;
+	if (data & (1 << (spdif_player->stream_iec958_subcode_cnt % 8)))
+		*right_subframe |= U_BIT;
+	spdif_player->stream_iec958_subcode_cnt =
+			(spdif_player->stream_iec958_subcode_cnt + 1) % 1176;
+
+	/* Channel status bit shall be the same for both subframes
+	 * (except channel number field, which we ignore.) */
+	data = spdif_player->stream_settings.iec958.status[
+			spdif_player->stream_iec958_status_cnt / 8];
+	if (data & (1 << (spdif_player->stream_iec958_status_cnt % 8))) {
+		*left_subframe |= C_BIT;
+		*right_subframe |= C_BIT;
+	}
+	spdif_player->stream_iec958_status_cnt =
+			(spdif_player->stream_iec958_status_cnt + 1) % 192;
+}
+
 static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 		int channel, snd_pcm_uframes_t pos,
-		void __user *buf, snd_pcm_uframes_t count)
+		void __user *src, snd_pcm_uframes_t count)
 {
 	struct snd_stm_spdif_player *spdif_player =
 		snd_pcm_substream_chip(substream);
@@ -645,19 +893,20 @@ static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 
 	snd_stm_printt("snd_stm_spdif_player_copy(substream=0x%p, channel=%d,"
 			" pos=%lu, buf=0x%p, count=%lu)\n", substream,
-			channel, pos, buf, count);
+			channel, pos, src, count);
 
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 	snd_assert(runtime, return -EINVAL);
 	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
 
-	if (spdif_player->input_mode == SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
-		unsigned long *hwbuf = (unsigned long *)(runtime->dma_area +
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
+		unsigned long *dest = (unsigned long *)(runtime->dma_area +
 				frames_to_bytes(runtime, pos));
 		int i;
 
-		if (!access_ok(VERIFY_READ, buf, frames_to_bytes(runtime,
+		if (!access_ok(VERIFY_READ, src, frames_to_bytes(runtime,
 						count)))
 			return -EFAULT;
 
@@ -668,7 +917,7 @@ static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 		{
 			unsigned char data[64];
 
-			copy_from_user(data, buf, 64);
+			copy_from_user(data, src, 64);
 
 			snd_stm_printt("Input:\n");
 			snd_stm_hex_dump(data, 64);
@@ -680,30 +929,27 @@ static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 
 			switch (runtime->format) {
 			case SNDRV_PCM_FORMAT_S32_LE:
-				GET_SAMPLE(left_subframe, buf, u32);
-				GET_SAMPLE(right_subframe, buf, u32);
+				GET_SAMPLE(left_subframe, src, u32);
+				GET_SAMPLE(right_subframe, src, u32);
 				break;
 			case SNDRV_PCM_FORMAT_S24_LE:
 				/* 24-bits sample are in lower 3 bytes,
 				 * while we want them in upper 3... ;-) */
-				GET_SAMPLE(left_subframe, buf, u32);
+				GET_SAMPLE(left_subframe, src, u32);
 				left_subframe <<= 8;
-				GET_SAMPLE(right_subframe, buf, u32);
+				GET_SAMPLE(right_subframe, src, u32);
 				right_subframe <<= 8;
 				break;
 			default:
-				left_subframe = 0;  /* To avoid -Os */
-				right_subframe = 0; /* compilation warnings */
-				snd_assert(0, return -EINVAL);
-				break;
+				snd_BUG();
+				return -EINVAL;
 			}
 
-			/* TODO: VUC bits, now just 000... */
-			left_subframe &= ~0x03;
-			right_subframe &= ~0x03;
+			snd_stm_spdif_player_format_frame(spdif_player,
+					&left_subframe, &right_subframe);
 
-			*(hwbuf++) = left_subframe;
-			*(hwbuf++) = right_subframe;
+			*(dest++) = left_subframe;
+			*(dest++) = right_subframe;
 		}
 
 #if 0
@@ -711,13 +957,10 @@ static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 		snd_stm_hex_dump(runtime->dma_area +
 				frames_to_bytes(runtime, pos), 64);
 #endif
-		dma_cache_wback(runtime->dma_area +
-				frames_to_bytes(runtime, pos),
-				frames_to_bytes(runtime, count));
 	} else {
 		/* RAW mode */
 		if (copy_from_user(runtime->dma_area +
-				frames_to_bytes(runtime, pos), buf,
+				frames_to_bytes(runtime, pos), src,
 				frames_to_bytes(runtime, count)) != 0)
 			return -EFAULT;
 	}
@@ -728,6 +971,7 @@ static int snd_stm_spdif_player_copy(struct snd_pcm_substream *substream,
 static int snd_stm_spdif_player_silence(struct snd_pcm_substream *substream,
 		int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
+	int result = 0;
 	struct snd_stm_spdif_player *spdif_player =
 		snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -741,10 +985,29 @@ static int snd_stm_spdif_player_silence(struct snd_pcm_substream *substream,
 	snd_assert(runtime, return -EINVAL);
 	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
 
-	snd_assert(0, return -EINVAL); /* Not implemented yet */
-	/* TODO	*/
+	if (spdif_player->stream_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
+		unsigned long *buffer = (unsigned long *)(runtime->dma_area +
+				frames_to_bytes(runtime, pos));
+		unsigned long left_subframe = 0;
+		unsigned long right_subframe = 0;
+		int i;
 
-	return 0;
+		for (i = 0; i < count; i++) {
+			snd_stm_spdif_player_format_frame(spdif_player,
+					&left_subframe, &right_subframe);
+			*(buffer++) = left_subframe;
+			*(buffer++) = right_subframe;
+		}
+	} else {
+		/* RAW mode */
+		result = snd_pcm_format_set_silence(runtime->format,
+				runtime->dma_area +
+				frames_to_bytes(runtime, pos),
+				runtime->channels * count);
+	}
+
+	return result;
 }
 
 static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
@@ -767,42 +1030,43 @@ static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
  * ALSA controls
  */
 
-/* "Main switch" - controls IDLE mode of SPDIF player */
-
-static int snd_stm_spdif_player_ctl_switch_get(struct snd_kcontrol *kcontrol,
+static int snd_stm_spdif_player_ctl_default_get(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printt("snd_stm_spdif_player_ctl_switch_get(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_default_get("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	ucontrol->value.integer.value[0] =
-			(REGFIELD_PEEK(spdif_player->base, AUD_SPDIF_CTRL,
-			IDLE) == AUD_SPDIF_CTRL__IDLE__VALUE__NORMAL);
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.iec958 = spdif_player->default_settings.iec958;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
 
-static int snd_stm_spdif_player_ctl_switch_put(struct snd_kcontrol *kcontrol,
+static int snd_stm_spdif_player_ctl_default_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 
-	snd_stm_printt("snd_stm_spdif_player_ctl_switch_put(kcontrol=0x%p, "
-			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_default_put("
+			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	if (ucontrol->value.integer.value[0])
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
-	else
-		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, IDLE);
+	spin_lock(&spdif_player->default_settings_lock);
+	if (snd_stm_iec958_cmp(&spdif_player->default_settings.iec958,
+				&ucontrol->value.iec958) != 0) {
+		spdif_player->default_settings.iec958 = ucontrol->value.iec958;
+		changed = 1;
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
@@ -823,10 +1087,11 @@ static int snd_stm_spdif_player_ctl_raw_get(struct snd_kcontrol *kcontrol,
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	spin_lock(&spdif_player->modes_default_lock);
-	ucontrol->value.integer.value[0] = (spdif_player->input_mode_default
-			== SNDRV_STM_SPDIF_INPUT_MODE_RAW);
-	spin_unlock(&spdif_player->modes_default_lock);
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+			(spdif_player->default_settings.input_mode ==
+			SNDRV_STM_SPDIF_INPUT_MODE_RAW);
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
@@ -849,10 +1114,10 @@ static int snd_stm_spdif_player_ctl_raw_put(struct snd_kcontrol *kcontrol,
 	else
 		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_NORMAL;
 
-	spin_lock(&spdif_player->modes_default_lock);
-	changed = (input_mode != spdif_player->input_mode_default);
-	spdif_player->input_mode_default = input_mode;
-	spin_unlock(&spdif_player->modes_default_lock);
+	spin_lock(&spdif_player->default_settings_lock);
+	changed = (input_mode != spdif_player->default_settings.input_mode);
+	spdif_player->default_settings.input_mode = input_mode;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
@@ -872,10 +1137,11 @@ static int snd_stm_spdif_player_ctl_encoded_get(struct snd_kcontrol *kcontrol,
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	spin_lock(&spdif_player->modes_default_lock);
-	ucontrol->value.integer.value[0] = (spdif_player->encoding_mode_default
-			== SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED);
-	spin_unlock(&spdif_player->modes_default_lock);
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+			(spdif_player->default_settings.encoding_mode ==
+			SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED);
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
@@ -898,10 +1164,11 @@ static int snd_stm_spdif_player_ctl_encoded_put(struct snd_kcontrol *kcontrol,
 	else
 		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_PCM;
 
-	spin_lock(&spdif_player->modes_default_lock);
-	changed = (encoding_mode != spdif_player->encoding_mode_default);
-	spdif_player->encoding_mode_default = encoding_mode;
-	spin_unlock(&spdif_player->modes_default_lock);
+	spin_lock(&spdif_player->default_settings_lock);
+	changed = (encoding_mode !=
+			spdif_player->default_settings.encoding_mode);
+	spdif_player->default_settings.encoding_mode = encoding_mode;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
@@ -914,7 +1181,7 @@ static int snd_stm_spdif_player_ctl_preamble_info(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = 16;
+	uinfo->count = PREAMBLE_BYTES;
 	return 0;
 }
 
@@ -929,7 +1196,11 @@ static int snd_stm_spdif_player_ctl_preamble_get(struct snd_kcontrol *kcontrol,
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	memcpy(ucontrol->value.bytes.data,
+			spdif_player->default_settings.iec61937_preamble,
+			PREAMBLE_BYTES);
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
@@ -946,7 +1217,14 @@ static int snd_stm_spdif_player_ctl_preamble_put(struct snd_kcontrol *kcontrol,
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	if (memcmp(spdif_player->default_settings.iec61937_preamble,
+			ucontrol->value.bytes.data, PREAMBLE_BYTES) != 0) {
+		changed = 1;
+		memcpy(spdif_player->default_settings.iec61937_preamble,
+				ucontrol->value.bytes.data, PREAMBLE_BYTES);
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
@@ -972,7 +1250,10 @@ static int snd_stm_spdif_player_ctl_audio_repetition_get(struct snd_kcontrol
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+		spdif_player->default_settings.iec61937_audio_repetition;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
@@ -989,7 +1270,14 @@ static int snd_stm_spdif_player_ctl_audio_repetition_put(struct snd_kcontrol
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	if (spdif_player->default_settings.iec61937_audio_repetition !=
+			ucontrol->value.integer.value[0]) {
+		changed = 1;
+		spdif_player->default_settings.iec61937_audio_repetition =
+				ucontrol->value.integer.value[0];
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
@@ -1005,7 +1293,10 @@ static int snd_stm_spdif_player_ctl_pause_repetition_get(struct snd_kcontrol
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	ucontrol->value.integer.value[0] =
+		spdif_player->default_settings.iec61937_pause_repetition;
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return 0;
 }
@@ -1022,18 +1313,37 @@ static int snd_stm_spdif_player_ctl_pause_repetition_put(struct snd_kcontrol
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* TODO */
+	spin_lock(&spdif_player->default_settings_lock);
+	if (spdif_player->default_settings.iec61937_pause_repetition !=
+			ucontrol->value.integer.value[0]) {
+		changed = 1;
+		spdif_player->default_settings.iec61937_pause_repetition =
+				ucontrol->value.integer.value[0];
+	}
+	spin_unlock(&spdif_player->default_settings_lock);
 
 	return changed;
 }
 
 static struct snd_kcontrol_new __initdata snd_stm_spdif_player_ctls[] = {
 	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = snd_stm_ctl_iec958_info,
+		.get = snd_stm_spdif_player_ctl_default_get,
+		.put = snd_stm_spdif_player_ctl_default_put,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, SWITCH),
-		.info = snd_stm_ctl_boolean_info,
-		.get = snd_stm_spdif_player_ctl_switch_get,
-		.put = snd_stm_spdif_player_ctl_switch_put,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_con,
+	}, {
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
+		.info =	snd_stm_ctl_iec958_info,
+		.get = snd_stm_ctl_iec958_mask_get_pro,
 	}, {
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name = SNDRV_CTL_NAME_IEC958("Raw Data ", PLAYBACK, DEFAULT),
@@ -1107,10 +1417,14 @@ static void snd_stm_spdif_player_dump_registers(struct snd_info_entry *entry,
 	DUMP_REGISTER(CL2_CR2_UV);
 	DUMP_REGISTER(PAU_LAT);
 	DUMP_REGISTER(BST_FL);
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	DUMP_REGISTER(CONFIG);
+#endif
 }
 
 static int snd_stm_spdif_player_register(struct snd_device *snd_device)
 {
+	int result;
 	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
 
 	snd_stm_printt("snd_stm_spdif_player_register(snd_device=0x%p)\n",
@@ -1119,14 +1433,6 @@ static int snd_stm_spdif_player_register(struct snd_device *snd_device)
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	/* Set a default clock frequency running for each device.
-	 * Not doing this can lead to clocks not starting correctly later,
-	 * for reasons that cannot be explained at this time. */
-	/* TODO: Check it, maybe obsolete now */
-	snd_stm_fsynth_set_frequency(spdif_player->fsynth,
-			spdif_player->fsynth_channel,
-			INIT_SAMPLING_RATE * spdif_player->oversampling);
-
 	/* Initialize hardware (format etc.) */
 
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
@@ -1138,13 +1444,32 @@ static int snd_stm_spdif_player_register(struct snd_device *snd_device)
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
 
 	/* Hardware stuffing is not implemented yet... */
+	/* TODO: oh, is that so? */
 	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, STUFFING, SOFTWARE);
 
 	/* Registers view in ALSA's procfs */
 
-	snd_stm_info_register(&spdif_player->proc_entry, spdif_player->bus_id,
+	snd_stm_info_register(&spdif_player->proc_entry,
+			spdif_player->device->bus_id,
 			snd_stm_spdif_player_dump_registers, spdif_player);
 
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(spdif_player->device,
+			snd_device->card, spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
+
+	result = snd_stm_fsynth_add_adjustement_ctl(spdif_player->fsynth_device,
+			spdif_player->fsynth_channel,
+			snd_device->card, spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
+
 	return 0;
 }
 
@@ -1160,7 +1485,7 @@ static int snd_stm_spdif_player_disconnect(struct snd_device *snd_device)
 	return 0;
 }
 
-static struct snd_device_ops snd_stm_spdif_player_ops = {
+static struct snd_device_ops snd_stm_spdif_player_snd_device_ops = {
 	.dev_register = snd_stm_spdif_player_register,
 	.dev_disconnect = snd_stm_spdif_player_disconnect,
 };
@@ -1171,32 +1496,15 @@ static struct snd_device_ops snd_stm_spdif_player_ops = {
  * Platform driver routines
  */
 
-static struct stm_dma_req_config snd_stm_spdif_player_fdma_request_config = {
-	.rw        = REQ_CONFIG_WRITE,
-	.opcode    = REQ_CONFIG_OPCODE_4,
-	.count     = 1,
-	.increment = 0,
-	.hold_off  = 0,
-	/* .initiator value is defined in platform device resources */
-};
-
 static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 {
 	int result = 0;
-	struct plat_audio_config *config = pdev->dev.platform_data;
-	struct snd_stm_component *component;
 	struct snd_stm_spdif_player *spdif_player;
 	struct snd_card *card;
-	int card_device;
-	const char *card_id;
-	const char *fsynth_bus_id;
 	int i;
 
 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
-	component = snd_stm_components_get(pdev->dev.bus_id);
-	snd_assert(component, return -EINVAL);
-
 	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
 	if (!spdif_player) {
 		snd_stm_printe("Can't allocate memory "
@@ -1205,11 +1513,11 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 		goto error_alloc;
 	}
 	snd_stm_magic_set(spdif_player);
-	spdif_player->bus_id = pdev->dev.bus_id;
+	spdif_player->info = pdev->dev.platform_data;
+	snd_assert(spdif_player->info != NULL, return -EINVAL);
+	spdif_player->device = &pdev->dev;
 
-	spin_lock_init(&spdif_player->modes_default_lock);
-	spin_lock_init(&spdif_player->vuc_default_lock);
-	spin_lock_init(&spdif_player->vuc_stream_lock);
+	spin_lock_init(&spdif_player->default_settings_lock);
 
 	/* Get resources */
 
@@ -1231,9 +1539,7 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 		goto error_irq_request;
 	}
 
-	result = snd_stm_fdma_request(pdev, &spdif_player->fdma_channel,
-			&spdif_player->fdma_request,
-			&snd_stm_spdif_player_fdma_request_config);
+	result = snd_stm_fdma_request(pdev, &spdif_player->fdma_channel);
 	if (result < 0) {
 		snd_stm_printe("FDMA request failed!\n");
 		goto error_fdma_request;
@@ -1241,50 +1547,22 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 
 	/* Get component caps */
 
-	snd_printd("Player's name is '%s'\n", component->short_name);
+	snd_printd("Player's name is '%s'\n", spdif_player->info->name);
 
-	result = snd_stm_cap_get_string(component, "card_id", &card_id);
-	snd_assert(result == 0, return -EINVAL);
-	card = snd_stm_cards_get(card_id);
+	card = snd_stm_cards_get(spdif_player->info->card_id);
 	snd_assert(card != NULL, return -EINVAL);
-	snd_printd("Player will be a member of a card '%s'...\n", card_id);
-
-	result = snd_stm_cap_get_number(component, "card_device",
-			&card_device);
-	snd_assert(result == 0, return -EINVAL);
-	snd_printd("... as a PCM device no %d.\n", card_device);
-
-	result = snd_stm_cap_get_string(component, "fsynth_bus_id",
-			&fsynth_bus_id);
-	snd_assert(result == 0, return -EINVAL);
-	spdif_player->fsynth = snd_stm_device_get(fsynth_bus_id);
-	snd_assert(spdif_player->fsynth, return -EINVAL);
-	result = snd_stm_cap_get_number(component, "fsynth_channel",
-			&spdif_player->fsynth_channel);
-	snd_assert(result == 0, return -EINVAL);
-	snd_printd("Player clocked by channel %d of synthesizer %s.\n",
-			spdif_player->fsynth_channel, fsynth_bus_id);
-
-	/* Board-specific configuration */
-
-	if (config) {
-		spdif_player->oversampling = config->oversampling;
-	} else {
-		spdif_player->oversampling = DEFAULT_OVERSAMPLING;
-	}
-	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
-	 * so oversampling 192x is forbidden, use ie. 384x instead) */
-	snd_assert(spdif_player->oversampling == 128 ||
-			spdif_player->oversampling == 256 ||
-			spdif_player->oversampling == 384 ||
-			spdif_player->oversampling == 512 ||
-			spdif_player->oversampling == 768,
-			return -EINVAL);
+	snd_printd("Player will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, spdif_player->info->card_device);
+
+	/* Get fsynth device */
 
-	/* Default VUC data - consumer, PCM linear, no copyright */
-	/* TODO: make it configurable per board */
-	spdif_player->vuc_default.status[0] = IEC958_AES0_CON_NOT_COPYRIGHT;
-	/* All the rest is zeros, which is fine for us :-) */
+	snd_printd("Player connected to %s's output %d.\n",
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+	spdif_player->fsynth_device = snd_stm_find_device(NULL,
+			spdif_player->info->fsynth_bus_id);
+	snd_assert(spdif_player->fsynth_device != NULL, return -EINVAL);
+	spdif_player->fsynth_channel = spdif_player->info->fsynth_output;
 
 	/* Preallocate buffer */
 
@@ -1293,7 +1571,7 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 	/* Create ALSA lowlevel device */
 
 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, spdif_player,
-			&snd_stm_spdif_player_ops);
+			&snd_stm_spdif_player_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
 		goto error_device;
@@ -1301,14 +1579,14 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 
 	/* Create ALSA PCM device */
 
-	result = snd_pcm_new(card, NULL, card_device, 1, 0,
+	result = snd_pcm_new(card, NULL, spdif_player->info->card_device, 1, 0,
 			&spdif_player->pcm);
 	if (result < 0) {
 		snd_stm_printe("ALSA PCM instance creation failed!\n");
 		goto error_pcm;
 	}
 	spdif_player->pcm->private_data = spdif_player;
-	strcpy(spdif_player->pcm->name, component->short_name);
+	strcpy(spdif_player->pcm->name, spdif_player->info->name);
 
 	snd_pcm_set_ops(spdif_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
 			&snd_stm_spdif_player_spdif_ops);
@@ -1317,15 +1595,18 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 
 	result = 0;
 	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
-		snd_stm_spdif_player_ctls[i].device = card_device;
+		snd_stm_spdif_player_ctls[i].device =
+				spdif_player->info->card_device;
 		result |= snd_ctl_add(card,
 				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
 				spdif_player));
 		/* TODO: index per card */
 		snd_stm_spdif_player_ctls[i].index++;
 	}
-	result |= snd_stm_fsynth_add_adjustement_ctl(spdif_player->fsynth,
-			spdif_player->fsynth_channel, card, card_device);
+	result |= snd_stm_fsynth_add_adjustement_ctl(
+			spdif_player->fsynth_device,
+			spdif_player->fsynth_channel, card,
+			spdif_player->info->card_device);
 	if (result < 0) {
 		snd_stm_printe("Failed to add all ALSA controls!\n");
 		goto error_controls;
@@ -1337,14 +1618,13 @@ static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 
 	snd_printd("--- Probed successfully!\n");
 
-	return result;
+	return 0;
 
 error_controls:
 error_pcm:
 	snd_device_free(card, spdif_player);
 error_device:
-	snd_stm_fdma_release(spdif_player->fdma_channel,
-			spdif_player->fdma_request);
+	snd_stm_fdma_release(spdif_player->fdma_channel);
 error_fdma_request:
 	snd_stm_irq_release(spdif_player->irq, spdif_player);
 error_irq_request:
@@ -1363,8 +1643,7 @@ static int snd_stm_spdif_player_remove(struct platform_device *pdev)
 	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	snd_stm_fdma_release(spdif_player->fdma_channel,
-			spdif_player->fdma_request);
+	snd_stm_fdma_release(spdif_player->fdma_channel);
 	snd_stm_irq_release(spdif_player->irq, spdif_player);
 	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
 
diff --git a/sound/soc/stm/stx710x.c b/sound/soc/stm/stx710x.c
index 9b95769..d574cad 100644
--- a/sound/soc/stm/stx710x.c
+++ b/sound/soc/stm/stx710x.c
@@ -23,6 +23,7 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/stm/fdma-reqs.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 
@@ -65,168 +66,219 @@ static struct snd_stm_card __initdata snd_stm_stx710x_cards[] = {
 
 
 /*
- * SoC audio components description
+ * Audio subsystem components & platform devices
  */
 
-enum { audio_outputs, fsynth, pcm_reader, dac_internal,
-	pcm_player_0, pcm_player_1,
-	spdif_player, i2s_spdif_converter };
-
-static struct snd_stm_component __initdata snd_stm_stx710x_components[] = {
-
-	/* Audio outputs control */
-
-	[audio_outputs] = {
-		.bus_id = "audio_outputs",
-		.short_name = "Audio outputs control",
-		.num_caps = 0,
+/* Audio IO controls */
+
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210200,
+			.end   = 0x19210203,
+		},
 	},
+};
 
-	/* Frequency synthesizer */
-
-	[fsynth] = {
-		.bus_id = "fsynth",
-		.short_name = "Frequency synthesizer",
-		.num_caps = 1,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.range.from = 0,
-				.value.range.to = 2,
-			},
+/* Frequency synthesizer */
+
+static struct platform_device fsynth = {
+	.name          = "fsynth",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210000,
+			.end   = 0x1921003f,
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.channels_from = 0,
+		.channels_to = 2,
+	},
+};
 
-	/* PCM reader */
-
-	[pcm_reader] = {
-		.bus_id = "pcm_reader",
-		.short_name = "PCM reader",
-		.num_caps = 3,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int []) { 2 },
-				.value.list.len     = 1,
-			},
-			{
-				.name = "card_id",
-				.value.string = "INPUT",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
+/* Internal DAC */
+
+static struct platform_device conv_internal_dac = {
+	.name          = "conv_internal_dac",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x19210100,
+			.end   = 0x19210103,
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
+		.name = "Internal audio DAC",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.1",
+	},
+};
 
-	/* Internal audio DACs */
+/* PCM reader */
+
+struct snd_stm_pcm_reader_info pcm_reader_info = {
+	.name = "PCM reader",
+	.card_id = "INPUT",
+	.card_device = 0,
+	.channels_num = 1,
+	.channels = (int []) { 2 },
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+	.fdma_max_transfer_size = 2,
+};
 
-	[dac_internal] = {
-		.bus_id = "dac_internal",
-		.short_name = "Internal DAC",
-		.num_caps = 0,
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18102000,
+			.end   = 0x18102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 146,
+			.end   = 146,
+		},
 	},
+	.dev.platform_data = &pcm_reader_info,
+};
+
+/* PCM players */
+
+struct snd_stm_pcm_player_info pcm_player_0_info = {
+	.name = "PCM player #0",
+	.card_id = "PCM",
+	.card_device = 0,
+	.fsynth_bus_id = "fsynth",
+	.fsynth_output = 0,
+	/* .channels_num = see snd_stm_stx710x_init() */
+	/* .channels = see snd_stm_stx710x_init() */
+	/* .invert_sclk_edge_falling = see snd_stm_stx710x_init() */
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+	.fdma_max_transfer_size = 2,
+};
 
-	/* PCM players */
-
-	[pcm_player_0] = {
-		.bus_id = "pcm_player.0",
-		.short_name = "PCM player #0",
-		.num_caps = 6,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				/* SOC version dependant, see function below */
-			},
-			{
-				.name = "card_id",
-				.value.string = "PCM",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 0,
-			},
-			{
-				.name = "sclk_edge_falling",
-				/* SOC version dependant, see function below */
-			},
+static struct platform_device pcm_player_0 = {
+	.name          = "pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101000,
+			.end   = 0x18101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 144,
+			.end   = 144,
 		},
 	},
+	.dev.platform_data = &pcm_player_0_info,
+};
 
-	[pcm_player_1] = {
-		.bus_id = "pcm_player.1",
-		.short_name = "PCM player #1",
-		.num_caps = 6,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int []) { 2 },
-				.value.list.len = 1,
-			},
-			{
-				.name = "card_id",
-				.value.string = "ANALOG",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 1,
-			},
-			{
-				.name = "dac_bus_id",
-				.value.string = "dac_internal",
-			},
+struct snd_stm_pcm_player_info pcm_player_1_info = {
+	.name = "PCM player #1",
+	.card_id = "ANALOG",
+	.card_device = 0,
+	.fsynth_bus_id = "fsynth",
+	.fsynth_output = 1,
+	/* .channels_num = see snd_stm_stx710x_init() */
+	/* .channels = see snd_stm_stx710x_init() */
+	/* .invert_sclk_edge_falling = see snd_stm_stx710x_init() */
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+	.fdma_max_transfer_size = 2,
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18101800,
+			.end   = 0x18101827,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 145,
+			.end   = 145,
 		},
 	},
+	.dev.platform_data = &pcm_player_1_info,
+};
+
+/* SPDIF player */
+
+struct snd_stm_spdif_player_info spdif_player_info = {
+	.name = "SPDIF player",
+	.card_id = "SPDIF",
+	.card_device = 0,
+	.fsynth_bus_id = "fsynth",
+	.fsynth_output = 2,
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx710x_init() */
+	.fdma_max_transfer_size = 2,
+};
 
-	/* SPDIF player */
-
-	[spdif_player] = {
-		.bus_id = "spdif_player",
-		.short_name = "SPDIF player",
-		.num_caps = 4,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "card_id",
-				.value.string = "SPDIF",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name         = "fsynth_bus_id",
-				.value.string = "fsynth",
-			},
-			{
-				.name         = "fsynth_channel",
-				.value.number = 2,
-			},
+static struct platform_device spdif_player = {
+	.name          = "spdif_player",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103000,
+			.end   = 0x1810303f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 147,
+			.end   = 147,
 		},
 	},
+	.dev.platform_data = &spdif_player_info,
+};
 
-	/* HDMI output */
-
-	[i2s_spdif_converter] = {
-		.bus_id = "i2s-spdif_conv",
-		.short_name = "I2S to SPDIF converter",
-		.num_caps = 0,
+/* HDMI-connected I2S to SPDIF converter */
+
+static struct platform_device conv_i2s_spdif = {
+	.name          = "conv_i2s-spdif",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18103800,
+			.end   = 0x18103a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 142,
+			.end   = 142,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
 	},
 };
 
@@ -236,111 +288,116 @@ static struct snd_stm_component __initdata snd_stm_stx710x_components[] = {
  * Initialization and runtime configuration
  */
 
-static union snd_stm_value __initdata number_0 = { .number = 0 };
-static union snd_stm_value __initdata number_1 = { .number = 1 };
-static union snd_stm_value __initdata list_2  = {
-	.list.len = 1,
-	.list.numbers = (int []) { 2 }
-};
-static union snd_stm_value __initdata list_2_10 = {
-	.list.len = 5,
-	.list.numbers = (int []) { 2, 4, 6, 8, 10 }
+static struct platform_device *snd_stm_stx710x_devices[] = {
+	&audio_outputs,
+	&fsynth,
+	&pcm_reader,
+	&pcm_player_0,
+	&pcm_player_1,
+	&conv_internal_dac,
+	&spdif_player,
+	&conv_i2s_spdif,
 };
 
+static int channels_2[] = { 2 };
+static int channels_10[] = { 10 };
+static int channels_2_10[] = { 2, 4, 6, 8, 10 };
+
 int __init snd_stm_stx710x_init(void)
 {
-	int result;
+	int result = 0;
 	const char *soc_type;
-	/* To have lines shorter than 80 chars... */
-	struct snd_stm_component *components = snd_stm_stx710x_components;
 
 	switch (cpu_data->type) {
 	case CPU_STB7100:
 		soc_type = "STx7100";
 
+		/* FDMA request line configuration */
+		pcm_player_0_info.fdma_request_line = STB7100_FDMA_REQ_PCM_0;
+		pcm_player_1_info.fdma_request_line = STB7100_FDMA_REQ_PCM_1;
+		spdif_player_info.fdma_request_line = STB7100_FDMA_REQ_SPDIF;
+		pcm_reader_info.fdma_request_line = STB7100_FDMA_REQ_PCM_READ;
+
 		/* STx7100 PCM players have small hardware bug - bit SCLK_EDGE
 		 * in AUD_PCMOUT_FMT register has opposite meaning than stated
 		 * in datasheet - 0 means that PCM serial output is clocked
 		 * (changed) during falling SCLK edge (which is usually what
 		 * we want ;-) */
-		snd_stm_cap_set(&components[pcm_player_0],
-				"sclk_edge_falling", number_0);
-		snd_stm_cap_set(&components[pcm_player_1],
-				"sclk_edge_falling", number_0);
+		pcm_player_0_info.invert_sclk_edge_falling = 1;
+		pcm_player_1_info.invert_sclk_edge_falling = 1;
 
 		if (cpu_data->cut_major < 3) {
-
 			/* STx7100 cut < 3.0 */
-
 			/* Hardware bug again - in early 7100s player ignored
 			 * NUM_CH setting in AUD_PCMOUT_FMT register */
-			snd_stm_cap_set(&components[pcm_player_0],
-					"channels", list_2_10);
-			snd_stm_cap_set(&components[pcm_player_1],
-					"channels", list_2_10);
+			pcm_player_0_info.channels_num =
+				ARRAY_SIZE(channels_10);
+			pcm_player_0_info.channels = channels_10;
+			pcm_player_1_info.channels_num =
+				ARRAY_SIZE(channels_10);
+			pcm_player_1_info.channels = channels_10;
 		} else {
-
 			/* STx7100 cut >= 3.0 */
-
-			snd_stm_cap_set(&components[pcm_player_0],
-					"channels", list_2_10);
-			snd_stm_cap_set(&components[pcm_player_1],
-					"channels", list_2);
+			pcm_player_0_info.channels_num =
+				ARRAY_SIZE(channels_2_10);
+			pcm_player_0_info.channels = channels_2_10;
+			pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
+			pcm_player_1_info.channels = channels_2;
 		}
 		break;
 
 	case CPU_STB7109:
 		soc_type = "STx7109";
 
-		snd_stm_cap_set(&components[pcm_player_0],
-				"channels", list_2_10);
-		snd_stm_cap_set(&components[pcm_player_1],
-				"channels", list_2);
+		/* FDMA request line configuration */
+		pcm_player_0_info.fdma_request_line = STB7109_FDMA_REQ_PCM_0;
+		pcm_player_1_info.fdma_request_line = STB7109_FDMA_REQ_PCM_1;
+		spdif_player_info.fdma_request_line = STB7109_FDMA_REQ_SPDIF;
+		pcm_reader_info.fdma_request_line = STB7109_FDMA_REQ_PCM_READ;
 
-		if (cpu_data->cut_major < 3) {
+		pcm_player_0_info.channels_num = ARRAY_SIZE(channels_2_10);
+		pcm_player_0_info.channels = channels_2_10;
+		pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
+		pcm_player_1_info.channels = channels_2;
 
+		if (cpu_data->cut_major < 3) {
 			/* STx7109 cut < 3.0 */
-
-			/* PCM players of early 7109s have small hardware bug -
-			 * bit SCLK_EDGE in AUD_PCMOUT_FMT register has
+			/* PCM players of early 7109s have small hardware
+			 * bug - bit SCLK_EDGE in AUD_PCMOUT_FMT register has
 			 * opposite meaning than stated in datasheet - 0 means
 			 * that PCM serial output is clocked (changed) during
 			 * falling SCLK edge (which is usually what we
 			 * want ;-) */
-			snd_stm_cap_set(&components[pcm_player_0],
-					"sclk_edge_falling", number_0);
-			snd_stm_cap_set(&components[pcm_player_1],
-					"sclk_edge_falling", number_0);
-		} else {
-
-			/* STx7109 cut >= 3.0 */
-
-			snd_stm_cap_set(&components[pcm_player_0],
-					"sclk_edge_falling", number_1);
-			snd_stm_cap_set(&components[pcm_player_1],
-					"sclk_edge_falling", number_1);
+			pcm_player_0_info.invert_sclk_edge_falling = 1;
+			pcm_player_1_info.invert_sclk_edge_falling = 1;
 		}
-
 		break;
 
 	default:
 		/* Unknown CPU! */
-		soc_type = NULL; /* To avoid a -Os compilation warning */
-		snd_assert(0, return -EINVAL);
+		snd_stm_printe("Not supported CPU detected!\n");
+		result = -EINVAL;
 		break;
 	}
 
-	result = snd_stm_cards_init(soc_type,
-			snd_stm_stx710x_cards,
-			ARRAY_SIZE(snd_stm_stx710x_cards));
+	if (result == 0)
+		result = snd_stm_cards_init(soc_type,
+				snd_stm_stx710x_cards,
+				ARRAY_SIZE(snd_stm_stx710x_cards));
 
 	if (result == 0) {
-		result = snd_stm_components_init(snd_stm_stx710x_components,
-				ARRAY_SIZE(snd_stm_stx710x_components));
+		result = snd_stm_add_plaform_devices(snd_stm_stx710x_devices,
+				ARRAY_SIZE(snd_stm_stx710x_devices));
 
-		if (result < 0)
+		if (result != 0)
 			snd_stm_cards_free();
 	}
 
 	return result;
 }
+
+void __exit snd_stm_stx710x_cleanup(void)
+{
+	snd_stm_remove_plaform_devices(snd_stm_stx710x_devices,
+			ARRAY_SIZE(snd_stm_stx710x_devices));
+}
diff --git a/sound/soc/stm/stx7111.c b/sound/soc/stm/stx7111.c
new file mode 100644
index 0000000..cacffaa
--- /dev/null
+++ b/sound/soc/stm/stx7111.c
@@ -0,0 +1,424 @@
+/*
+ *   STMicrolectronics STx7111 SoC description
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel MOLL <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+
+#undef TRACE
+#include "common.h"
+
+
+
+/*
+ * ALSA cards list and descriptions
+ */
+
+struct snd_stm_card __initdata snd_stm_stx7111_cards[] = {
+	{
+		.index = 0,
+		.id = "PCM",
+		.short_name = "PCM outputs",
+		.long_name = "Digital audio outputs (PCM player 0)",
+	},
+	{
+		.index = 1,
+		.id = "ANALOG",
+		.short_name = "Analog outputs",
+		.long_name = "Analog audio outputs (PCM player 1)",
+	},
+	{
+		.index = 2,
+		.id = "SPDIF",
+		.short_name = "SPDIF output",
+		.long_name = "SPDIF audio output",
+	},
+	{
+		.index = 3,
+		.id = "INPUT",
+		.short_name = "PCM input",
+		.long_name = "Digital audio input (PCM reader)",
+	}
+};
+
+
+
+/*
+ * Audio subsystem components & platform devices
+ */
+
+/* Audio outputs control */
+
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210200,
+			.end   = 0xfe21020b,
+		},
+	}
+};
+
+/* Frequency synthesizers */
+
+static struct platform_device fsynth = {
+	.name          = "fsynth",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210000,
+			.end   = 0xfe21004f,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.channels_from = 0,
+		.channels_to = 2,
+	},
+};
+
+/* PCM reader */
+
+#if 0 /* MB618 has no audio input, so there is no way to test it... */
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd102000,
+			.end   = 0xfd102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1440),
+			.end   = evt2irq(0x1440),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
+		.name = "PCM reader",
+		.card_id = "INPUT",
+		.card_device = 0,
+		.channels_num = 5,
+		.channels = (int []) { 2, 4, 6, 8, 10 },
+		.fdma_initiator = 0,
+		.fdma_request_line = 29,
+		.fdma_max_transfer_size = 30,
+	},
+};
+#endif
+
+/* Internal DACs */
+
+static struct platform_device conv_internal_dac = {
+	.name          = "conv_internal_dac",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfe210100,
+			.end   = 0xfe210103,
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
+		.name = "Internal audio DAC",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.1",
+	},
+};
+
+/* PCM players  */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104d00,
+			.end   = 0xfd104d27,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1400),
+			.end   = evt2irq(0x1400),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #0",
+		.card_id = "PCM",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth",
+		.fsynth_output = 0,
+		.channels_num = 4,
+		.channels = (int []) { 2, 4, 6, 8 },
+		.fdma_initiator = 0,
+		.fdma_request_line = 27,
+		.fdma_max_transfer_size = 30,
+	},
+};
+
+static struct platform_device pcm_player_1 = {
+	.name          = "pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd101800,
+			.end   = 0xfd101827,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1420),
+			.end   = evt2irq(0x1420),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #1",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth",
+		.fsynth_output = 1,
+		.channels_num = 1,
+		.channels = (int []) { 2 },
+		.fdma_initiator = 0,
+		.fdma_request_line = 28,
+		.fdma_max_transfer_size = 30,
+	},
+};
+
+/*
+ * SPDIF player
+ */
+
+static struct platform_device spdif_player = {
+	.name          = "spdif_player",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104c00,
+			.end   = 0xfd104c43,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x1460),
+			.end   = evt2irq(0x1460),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player",
+		.card_id = "SPDIF",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth",
+		.fsynth_output = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = 30,
+		.fdma_max_transfer_size = 20,
+	},
+};
+
+/* I2S to SPDIF converters */
+
+static struct platform_device conv_i2s_spdif_0 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105000,
+			.end   = 0xfd105223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x13c0),
+			.end   = evt2irq(0x13c0),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter #0",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
+		.full_channel_status = 1,
+	},
+};
+
+static struct platform_device conv_i2s_spdif_1 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105400,
+			.end   = 0xfd105623,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0a80),
+			.end   = evt2irq(0x0a80),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter #1",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
+		.full_channel_status = 1,
+	},
+};
+
+static struct platform_device conv_i2s_spdif_2 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105800,
+			.end   = 0xfd105a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0b00),
+			.end   = evt2irq(0x0b00),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter #2",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
+		.full_channel_status = 1,
+	},
+};
+
+static struct platform_device conv_i2s_spdif_3 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105c00,
+			.end   = 0xfd105e23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = evt2irq(0x0b20),
+			.end   = evt2irq(0x0b20),
+		}
+	},
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter #3",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
+		.full_channel_status = 1,
+	},
+};
+
+
+
+/*
+ * Initialization and runtime configuration
+ */
+
+static struct platform_device *snd_stm_stx7111_devices[] = {
+	&audio_outputs,
+	&fsynth,
+#if 0 /* MB618 has no audio input, so there is no way to test it... */
+	&pcm_reader,
+#endif
+	&conv_internal_dac,
+	&pcm_player_0,
+	&pcm_player_1,
+	&spdif_player,
+	&conv_i2s_spdif_0,
+	&conv_i2s_spdif_1,
+	&conv_i2s_spdif_2,
+	&conv_i2s_spdif_3,
+};
+
+int __init snd_stm_stx7111_init(void)
+{
+	int result = 0;
+
+	/* TODO: 7111 is identified now as ST40-300... */
+	if (cpu_data->type != CPU_ST40_300) {
+		/* Unknown CPU! */
+		snd_stm_printe("Not supported CPU detected!\n");
+		result = -EINVAL;
+	}
+
+	/* Ugly but quick hack to have SPDIF player & I2S to SPDIF
+	 * converters enabled without loading STMFB...
+	 * TODO: do this in some sane way! */
+	{
+		void *hdmi_gpout = ioremap(0xfd104020, 4);
+		writel(readl(hdmi_gpout) | 0x3, hdmi_gpout);
+		iounmap(hdmi_gpout);
+	}
+
+	if (result == 0) {
+		/* Cut 2.0 presumably will bring something new into the
+		 * matter, so above configuration must be checked!
+		 * - transfer_sizes (FIFO sizes has changed) */
+		WARN_ON(cpu_data->cut_major > 1);
+
+		result = snd_stm_cards_init("STx7111",
+				snd_stm_stx7111_cards,
+				ARRAY_SIZE(snd_stm_stx7111_cards));
+	}
+
+	if (result == 0) {
+		result = snd_stm_add_plaform_devices(snd_stm_stx7111_devices,
+				ARRAY_SIZE(snd_stm_stx7111_devices));
+
+		if (result != 0)
+			snd_stm_cards_free();
+	}
+
+	return result;
+}
+
+void __exit snd_stm_stx7111_cleanup(void)
+{
+	snd_stm_remove_plaform_devices(snd_stm_stx7111_devices,
+			ARRAY_SIZE(snd_stm_stx7111_devices));
+}
diff --git a/sound/soc/stm/stx7200.c b/sound/soc/stm/stx7200.c
index 40c5e1c..cd2e37f 100644
--- a/sound/soc/stm/stx7200.c
+++ b/sound/soc/stm/stx7200.c
@@ -23,6 +23,9 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/stm/fdma-reqs.h>
+#include <asm/irq-ilc.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 
@@ -72,332 +75,421 @@ struct snd_stm_card __initdata snd_stm_stx7200_cards[] = {
 
 
 /*
- * SoC audio components description
+ * Audio subsystem components & platform devices
  */
 
-enum { audio_outputs, fsynth_0, fsynth_1, pcm_reader,
-	dac_internal_0, dac_internal_1, pcm_player_0,
-	pcm_player_1, pcm_player_2, pcm_player_3, spdif_player,
-	hdmi_pcm_player, hdmi_spdif_player, hdmi_i2s_spdif_converter_0,
-	hdmi_i2s_spdif_converter_1, hdmi_i2s_spdif_converter_2,
-	hdmi_i2s_spdif_converter_3 };
-
-struct snd_stm_component __initdata snd_stm_stx7200_components[] = {
-
-	/* Audio outputs control */
+/* Audio outputs control */
+
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601200,
+			.end   = 0xfd60120b,
+		},
+	}
+};
 
-	[audio_outputs] = {
-		.bus_id = "audio_outputs",
-		.short_name = "Audio outputs control",
-		.num_caps = 0,
+/* Frequency synthesizers */
+
+static struct platform_device fsynth_0 = {
+	.name          = "fsynth",
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601000,
+			.end   = 0xfd60104f,
+		},
 	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.channels_from = 0,
+		.channels_to = 3,
+	},
+};
 
-	/* Frequency synthesizers */
-
-	[fsynth_0] = {
-		.bus_id = "fsynth.0",
-		.short_name = "Frequency synthesizer #0",
-		.num_caps = 1,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.range.from = 0,
-				.value.range.to = 3,
-			},
+static struct platform_device fsynth_1 = {
+	.name          = "fsynth",
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601100,
+			.end   = 0xfd60114f,
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.channels_from = 2,
+		.channels_to = 3,
+	},
+};
 
-	[fsynth_1] = {
-		.bus_id = "fsynth.1",
-		.short_name = "Frequency synthesizer #1",
-		.num_caps = 1,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.range.from = 2,
-				.value.range.to = 3,
-			},
+/* PCM reader */
+
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd100000,
+			.end   = 0xfd100027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(38),
+			.end   = ILC_IRQ(38),
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_pcm_reader_info) {
+		.name = "PCM reader",
+		.card_id = "INPUT",
+		.card_device = 0,
+		.channels_num = 1,
+		.channels = (int []) { 2 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_PCMIN,
+		.fdma_max_transfer_size = 2,
+	},
+};
 
-	/* PCM reader */
-
-	[pcm_reader] = {
-		.bus_id = "pcm_reader",
-		.short_name = "PCM reader",
-		.num_caps = 3,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int []) { 2 },
-				.value.list.len     = 1,
-			},
-			{
-				.name = "card_id",
-				.value.string = "INPUT",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
+/* Internal DACs */
+
+static struct platform_device conv_internal_dac_0 = {
+	.name          = "conv_internal_dac",
+	.id            = 0,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601400,
+			.end   = 0xfd601403,
 		},
 	},
-
-	/* Internal audio DACs */
-
-	[dac_internal_0] = {
-		.bus_id = "dac_internal.0",
-		.short_name = "Internal DAC (master)",
-		.num_caps = 0,
+	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
+		.name = "Internal audio DAC #0",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
 	},
+};
 
-	[dac_internal_1] = {
-		.bus_id = "dac_internal.1",
-		.short_name = "Internal DAC (slave)",
-		.num_caps = 1,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "master_bus_id",
-				.value.string = "dac_internal.0",
-			},
+static struct platform_device conv_internal_dac_1 = {
+	.name          = "conv_internal_dac",
+	.id            = 1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd601500,
+			.end   = 0xfd601503,
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
+		.name = "Internal audio DAC #1 (slave)",
+		.card_id = "ANALOG",
+		.card_device = 1,
+		.source_bus_id = "pcm_player.1",
+	},
+};
 
-	/* PCM players */
-
-	[pcm_player_0] = {
-		.bus_id = "pcm_player.0",
-		.short_name = "PCM player #0",
-		.num_caps = 6,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int []) { 2 },
-				.value.list.len     = 1,
-			},
-			{
-				.name = "card_id",
-				.value.string = "ANALOG",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.0",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 0,
-			},
-			{
-				.name = "dac_bus_id",
-				.value.string = "dac_internal.0",
-			},
+/* PCM players connected to internal DACs */
+
+static struct platform_device pcm_player_0 = {
+	.name          = "pcm_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd101000,
+			.end   = 0xfd101027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(39),
+			.end   = ILC_IRQ(39),
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #0",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth.0",
+		.fsynth_output = 0,
+		.channels_num = 1,
+		.channels = (int []) { 2 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_PCM0,
+		.fdma_max_transfer_size = 20,
+	},
+};
 
-	[pcm_player_1] = {
-		.bus_id = "pcm_player.1",
-		.short_name = "PCM player #1",
-		.num_caps = 6,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int[]) { 2, 4, 6 },
-				.value.list.len = 3,
-			},
-			{
-				.name = "card_id",
-				.value.string = "ANALOG",
-			},
-			{
-				.name = "card_device",
-				.value.number = 1,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.0",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 1,
-			},
-			{
-				.name = "dac_bus_id",
-				.value.string = "dac_internal.1",
-			},
+static struct platform_device pcm_player_1 = {
+	.name          = "pcm_player",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd102000,
+			.end   = 0xfd102027,
 		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(40),
+			.end   = ILC_IRQ(40),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #1",
+		.card_id = "ANALOG",
+		.card_device = 1,
+		.fsynth_bus_id = "fsynth.0",
+		.fsynth_output = 1,
+		.channels_num = 3,
+		.channels = (int []) { 2, 4, 6 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_PCM1,
+		.fdma_max_transfer_size = 20,
 	},
+};
 
-	[pcm_player_2] = {
-		.bus_id = "pcm_player.2",
-		.short_name = "PCM player #2",
-		.num_caps = 5,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int[]) { 2, 4, 6, 8 },
-				.value.list.len     = 4,
-			},
-			{
-				.name = "card_id",
-				.value.string = "PCM",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.0",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 2,
-			},
+/* PCM players with digital outputs */
+
+static struct platform_device pcm_player_2 = {
+	.name          = "pcm_player",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd103000,
+			.end   = 0xfd103027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(41),
+			.end   = ILC_IRQ(41),
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #2",
+		.card_id = "PCM",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth.0",
+		.fsynth_output = 2,
+		.channels_num = 4,
+		.channels = (int []) { 2, 4, 6, 8 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_PCM2,
+		.fdma_max_transfer_size = 20,
+	},
+};
 
-	[pcm_player_3] = {
-		.bus_id = "pcm_player.3",
-		.short_name = "PCM player #3",
-		.num_caps = 5,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int[]){ 2, 4, 6, 8, 10 },
-				.value.list.len = 5,
-			},
-			{
-				.name = "card_id",
-				.value.string = "PCM",
-			},
-			{
-				.name = "card_device",
-				.value.number = 1,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.0",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 3,
-			},
+static struct platform_device pcm_player_3 = {
+	.name          = "pcm_player",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd104000,
+			.end   = 0xfd104027,
 		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(42),
+			.end   = ILC_IRQ(42),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player #3",
+		.card_id = "PCM",
+		.card_device = 1,
+		.fsynth_bus_id = "fsynth.0",
+		.fsynth_output = 3,
+		.channels_num = 5,
+		.channels = (int []) { 2, 4, 6, 8, 10 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_PCM3,
+		.fdma_max_transfer_size = 20,
 	},
+};
 
-	/* SPDIF player */
-
-	[spdif_player] = {
-		.bus_id = "spdif_player.0",
-		.short_name = "SPDIF player",
-		.num_caps = 4,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "card_id",
-				.value.string = "SPDIF",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.1",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 3,
-			},
+/* SPDIF player */
+
+static struct platform_device spdif_player = {
+	.name          = "spdif_player",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd105000,
+			.end   = 0xfd10503f,
 		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(37),
+			.end   = ILC_IRQ(37),
+		},
+	},
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player",
+		.card_id = "SPDIF",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth.1",
+		.fsynth_output = 3,
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_SPDIF,
+		.fdma_max_transfer_size = 4,
 	},
+};
 
-	/* HDMI players */
-
-	[hdmi_pcm_player] = {
-		.bus_id = "pcm_player.4",
-		.short_name = "PCM player HDMI",
-		.num_caps = 5,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "channels",
-				.value.list.numbers = (int[]) { 2, 4, 6, 8 },
-				.value.list.len     = 4,
-			},
-			{
-				.name = "card_id",
-				.value.string = "HDMI",
-			},
-			{
-				.name = "card_device",
-				.value.number = 0,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.1",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 2,
-			},
+/* HDMI output devices
+ * Please note that "HDTVOutBaseAddress" (0xFD10C000) from page 54 of
+ * "7200 Programming Manual, Volume 2" is wrong. The correct HDMI players
+ * subsystem base address is "HDMIPlayerBaseAddress" (0xFD106000) from
+ * page 488 of the manual. */
+
+static struct platform_device hdmi_pcm_player = {
+	.name          = "pcm_player",
+	.id            = 4, /* HDMI PCM player is no. 4 */
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd106d00,
+			.end   = 0xfd106d27,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(62),
+			.end   = ILC_IRQ(62),
 		},
 	},
+	.dev.platform_data = &(struct snd_stm_pcm_player_info) {
+		.name = "PCM player HDMI",
+		.card_id = "HDMI",
+		.card_device = 0,
+		.fsynth_bus_id = "fsynth.1",
+		.fsynth_output = 2,
+		.channels_num = 4,
+		.channels = (int []) { 2, 4, 6, 8 },
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_HDMI_PCM,
+		.fdma_max_transfer_size = 20,
+	},
+};
 
-	[hdmi_spdif_player] = {
-		.bus_id = "spdif_player.1",
-		.short_name = "SPDIF player HDMI",
-		.num_caps = 4,
-		.caps = (struct snd_stm_cap[]) {
-			{
-				.name = "card_id",
-				.value.string = "HDMI",
-			},
-			{
-				.name = "card_device",
-				.value.number = 1,
-			},
-			{
-				.name = "fsynth_bus_id",
-				.value.string = "fsynth.1",
-			},
-			{
-				.name = "fsynth_channel",
-				.value.number = 2,
-			},
+static struct platform_device hdmi_spdif_player = {
+	.name          = "spdif_player",
+	.id            = 1, /* HDMI SPDIF player is no. 1 */
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd106c00,
+			.end   = 0xfd106c3f,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(63),
+			.end   = ILC_IRQ(63),
 		},
 	},
-
-	/* I2S to SPDIF converters (HDMI output) */
+	.dev.platform_data = &(struct snd_stm_spdif_player_info) {
+		.name = "SPDIF player HDMI",
+		.card_id = "HDMI",
+		.card_device = 1,
+		.fsynth_bus_id = "fsynth.1",
+		.fsynth_output = 2,
+		.fdma_initiator = 0,
+		.fdma_request_line = STB7200_FDMA_REQ_HDMI_SPDIF,
+		.fdma_max_transfer_size = 4,
+	},
+};
 
 #if 0 /* Disabled till cut 2.0 */
-	[hdmi_i2s_spdif_converter_0] = {
-		.bus_id = "i2s-spdif_conv.0",
-		.short_name = "I2S to SPDIF converter",
-		.num_caps = 0,
+static struct platform_device hdmi_conv_i2s_spdif_0 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 0,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107000,
+			.end   = 0xfd107223,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(64),
+			.end   = ILC_IRQ(64),
+		}
 	},
+};
 
-	[hdmi_i2s_spdif_converter_1] = {
-		.bus_id = "i2s-spdif_conv.1",
-		.short_name = "I2S to SPDIF converter",
-		.num_caps = 0,
+static struct platform_device hdmi_conv_i2s_spdif_1 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 1,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107400,
+			.end   = 0xfd107623,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(65),
+			.end   = ILC_IRQ(65),
+		}
 	},
+};
 
-	[hdmi_i2s_spdif_converter_2] = {
-		.bus_id = "i2s-spdif_conv.2",
-		.short_name = "I2S to SPDIF converter",
-		.num_caps = 0,
+static struct platform_device hdmi_conv_i2s_spdif_2 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 2,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107800,
+			.end   = 0xfd107a23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(66),
+			.end   = ILC_IRQ(66),
+		}
 	},
+};
 
-	[hdmi_i2s_spdif_converter_3] = {
-		.bus_id = "i2s-spdif_conv.3",
-		.short_name = "I2S to SPDIF converter",
-		.num_caps = 0,
+static struct platform_device hdmi_conv_i2s_spdif_3 = {
+	.name          = "conv_i2s-spdif",
+	.id            = 3,
+	.num_resources = 2,
+	.resource      = (struct resource []) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0xfd107c00,
+			.end   = 0xfd107e23,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = ILC_IRQ(67),
+			.end   = ILC_IRQ(67),
+		}
 	},
-#endif
 };
+#endif
 
 
 
@@ -405,21 +497,63 @@ struct snd_stm_component __initdata snd_stm_stx7200_components[] = {
  * Initialization and runtime configuration
  */
 
+static struct platform_device *snd_stm_stx7200_devices[] = {
+	&audio_outputs,
+	&fsynth_0,
+	&fsynth_1,
+	&pcm_reader,
+	&conv_internal_dac_0,
+	&conv_internal_dac_1,
+	&pcm_player_0,
+	&pcm_player_1,
+	&pcm_player_2,
+	&pcm_player_3,
+	&spdif_player,
+	&hdmi_pcm_player,
+	&hdmi_spdif_player,
+#if 0 /* Disabled till cut 2.0 */
+	&hdmi_conv_i2s_spdif_0,
+	&hdmi_conv_i2s_spdif_1,
+	&hdmi_conv_i2s_spdif_2,
+	&hdmi_conv_i2s_spdif_3,
+#endif
+};
+
 int __init snd_stm_stx7200_init(void)
 {
 	int result = 0;
 
-	result = snd_stm_cards_init("STx7200",
-			snd_stm_stx7200_cards,
-			ARRAY_SIZE(snd_stm_stx7200_cards));
+	if (cpu_data->type != CPU_STX7200) {
+		/* Unknown CPU! */
+		snd_stm_printe("Not supported CPU detected!\n");
+		result = -EINVAL;
+	}
 
 	if (result == 0) {
-		result = snd_stm_components_init(snd_stm_stx7200_components,
-				ARRAY_SIZE(snd_stm_stx7200_components));
+		/* Cut 2.0 presumably will bring something new into the
+		 * matter, so above configuration must be checked!
+		 * - transfer_sizes (FIFO sizes has changed) */
+		WARN_ON(cpu_data->cut_major > 1);
+
+		result = snd_stm_cards_init("STx7200",
+				snd_stm_stx7200_cards,
+				ARRAY_SIZE(snd_stm_stx7200_cards));
+	}
+
+	if (result == 0) {
+		result = snd_stm_add_plaform_devices(snd_stm_stx7200_devices,
+				ARRAY_SIZE(snd_stm_stx7200_devices));
 
-		if (result < 0)
+		if (result != 0)
 			snd_stm_cards_free();
 	}
 
+
 	return result;
 }
+
+void __exit snd_stm_stx7200_cleanup(void)
+{
+	snd_stm_remove_plaform_devices(snd_stm_stx7200_devices,
+			ARRAY_SIZE(snd_stm_stx7200_devices));
+}
