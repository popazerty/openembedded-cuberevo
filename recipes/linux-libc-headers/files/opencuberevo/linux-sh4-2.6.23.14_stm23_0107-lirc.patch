This patch introduces the following topics :
- tidy up and optimise code
- stm platform dependencies totally managed only by the plugin.
- device resource management support.
- STx7111/mb618 support
Signed-off-by: Angelo Castello <angelo.castello@st.com>
Signed-off-by: Carl Shaw <carl.shaw@st.com>

Index: linux-2.6.23/drivers/char/lirc/Kconfig
===================================================================
--- linux-2.6.23.orig/drivers/char/lirc/Kconfig	2008-03-14 15:16:11.000000000 +0000
+++ linux-2.6.23/drivers/char/lirc/Kconfig	2008-03-14 15:16:28.000000000 +0000
@@ -259,27 +259,20 @@
 				default "4" if LIRC_SIR_COM1 || LIRC_SIR_COM3
 				default "3" if LIRC_SIR_COM2 || LIRC_SIR_COM4
 			depends on LIRC_SIR
-        config ST_LIRC
+        config LIRC_STM
                 tristate "STM Lirc support"
-                depends on LIRC_SUPPORT && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB448 || SH_HMS1 || SH_ST_MB519)
-
-                choice
-                        prompt "Receiver type"
-                        depends on ST_LIRC
-			help
-			  The IRB and UHF are identical and indipendent, except
-			  that the IRB receiver does not use the noise filter.
-			  Not all the ST platforms support both type of receivers.
-
-                        config IRB_RECEIVER
-                        bool "IRB Receiver"
-			depends on ST_LIRC && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB448 || SH_HMS1 || SH_ST_MB519)
-
-                        config UHF_RECEIVER
-                        bool "UHF Receiver"
-			depends on ST_LIRC && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB519)
-
-                endchoice
+                depends on LIRC_SUPPORT && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB448 || SH_HMS1 || SH_ST_MB519 || SH_ST_MB618)
+		help
+		  The IR and UHF are identical and independent, except
+		  that the IRB receiver does not use the noise filter.
+		  Not all ST platforms support both type of receivers.
+		  IR RX is the default mode.
+
+        config LIRC_STM_UHF_RX
+	        bool "UHF Receiver mode"
+		depends on LIRC_STM && (SH_ST_MB411 || SH_ST_MB442 || SH_ST_MB519 || SH_ST_MB618)
+		help
+		  This causes the driver to use UHF RX mode.
 
 endmenu
 
Index: linux-2.6.23/drivers/char/lirc/lirc_dev.c
===================================================================
--- linux-2.6.23.orig/drivers/char/lirc/lirc_dev.c	2008-03-14 15:16:11.000000000 +0000
+++ linux-2.6.23/drivers/char/lirc/lirc_dev.c	2008-03-14 15:16:14.000000000 +0000
@@ -73,11 +73,6 @@
 #define NOPLUG            -1
 #define LOGHEAD           "lirc_dev (%s[%d]): "
 
-#if defined(CONFIG_ST_LIRC) || defined(MODULE)
-#include <linux/platform_device.h>
-static struct platform_device *lirc_platform_device;
-#endif
-
 struct irctl
 {
 	struct lirc_plugin p;
@@ -865,34 +860,6 @@
 EXPORT_SYMBOL(lirc_register_plugin);
 EXPORT_SYMBOL(lirc_unregister_plugin);
 
-#if defined(CONFIG_ST_LIRC) || defined(MODULE)
-static int __init lirc_probe(struct platform_device *dev)
-{
-	lirc_platform_device=dev;
-
-	if (lirc_platform_device->name != NULL)
-		printk(KERN_INFO "lirc_dev: Device probe found data for platform device %s\n", 
-                       lirc_platform_device->name);
-	else
-		printk(KERN_ERR "lirc_dev: Device probe failed.  Check your kernel SoC config!!\n");
-
-        return 0;
-}
-
-static struct platform_driver lirc_device_driver = {
-        .driver.name  = IRCTL_DEV_NAME,
-        .probe        = lirc_probe,
-};
-
-void* lirc_get_config()
-{
-	return (void*)lirc_platform_device;
-}
-
-EXPORT_SYMBOL(lirc_get_config);
-
-#endif
-
 /*
  *
  */
@@ -904,12 +871,6 @@
 		init_irctl(&irctls[i]);	
 	}
 
-#if defined(CONFIG_ST_LIRC) || defined(MODULE)
-	if(platform_driver_register(&lirc_device_driver)) {
-		printk(KERN_ERR "lirc_dev: driver_register failed\n");
-		goto out;
-        }
-#endif
 	if(register_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME, &fops)) {
 		printk(KERN_ERR "lirc_dev: register_chrdev failed\n");
 		goto out;
@@ -938,9 +899,6 @@
  */
 void __exit lirc_dev_exit(void)
 {
-#if defined(CONFIG_ST_LIRC) || defined(MODULE)
-	platform_driver_unregister(&lirc_device_driver);
-#endif
 	unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
 	class_destroy(lirc_class);
         dprintk("lirc_dev: module successfully unloaded\n");
Index: linux-2.6.23/drivers/char/lirc/lirc_stm.c
===================================================================
--- linux-2.6.23.orig/drivers/char/lirc/lirc_stm.c	2008-03-14 15:16:11.000000000 +0000
+++ linux-2.6.23/drivers/char/lirc/lirc_stm.c	2008-03-14 16:02:57.000000000 +0000
@@ -35,7 +35,18 @@
  *             intq needed to identify one button. Fix TX transmission loop setting up 
  *             correctly the irq clean register.
  * 	       Angelo Castello <angelo.castello@st.com>
- *
+ * Nov  2007:  Moved here all the platform
+ *             dependences leaving clear of this task the common interface. (lirc_dev.c)
+ *	       Code cleaning and optimization.
+ * 	       Angelo Castello <angelo.castello@st.com>
+ * Dec  2007:  Added device resource management support.
+ * 	       Angelo Castello <angelo.castello@st.com>
+ * Mar  2008:  Fix UHF support and general tidy up
+ *             Carl Shaw <carl.shaw@st.com>
+ * Mar  2008:  Fix insmod/rmmod actions. Added new PIO allocate mechanism
+ *	       based on platform PIOs dependencies values (LIRC_PIO_ON,
+ *	       LIRC_IR_RX, LIRC_UHF_RX so on )
+ * 	       Angelo Castello <angelo.castello@st.com>
  *
  */
 #include <linux/kernel.h>
@@ -55,14 +66,12 @@
 #include <linux/lirc.h>
 #include "lirc_dev.h"
 
+#define LIRC_STM_NAME "lirc_stm"
+
 /* General debugging */
 #undef LIRC_STM_DEBUG
-
-/* TX wait queue */
-static DECLARE_WAIT_QUEUE_HEAD(tx_waitq);
-
 #ifdef  LIRC_STM_DEBUG
-#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#define DPRINTK(fmt, args...) printk(KERN_INFO LIRC_STM_NAME ": %s: " fmt, __FUNCTION__ , ## args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -70,39 +79,27 @@
 /*
  * Infra Red: hardware register map
  */
-#if defined(CONFIG_IRB_RECEIVER) || defined(MODULE)
-static int ir_uhf_switch = 0;
+#if defined(CONFIG_LIRC_STM_UHF_RX)
+static int uhf_switch = 1;
 #else
-static int ir_uhf_switch = 1;
+static int uhf_switch = 0;
 #endif
-
-static int ir_or_uhf_offset = 0;	/* = 0 for IR mode */
+static int ir_or_uhf_offset;
 static int irb_irq = 0;		/* IR block irq */
 static void *irb_base_address;	/* IR block register base address */
 
-/* RX timing fine control */
-static int rx_symbol_mult;
-static int rx_symbol_div;
-static int rx_pulse_mult;
-static int rx_pulse_div;
-
-/* TX timing fine control */
-static unsigned int tx_mult;
-static unsigned int tx_div;
-static unsigned int tx_carrier_freq = 38000;	// in Hz
-
-
 /* IR transmitter registers */
-#define IRB_TX_PRESCALAR		(irb_base_address + 0x00)	/* clock prescalar */
-#define IRB_TX_SUBCARRIER		(irb_base_address + 0x04)	/* subcarrier frequency */
-#define IRB_TX_SYMPERIOD		(irb_base_address + 0x08)	/* symbol period (space + pulse) */
-#define IRB_TX_ONTIME			(irb_base_address + 0x0c)	/* symbol pulse time */
-#define IRB_TX_INT_ENABLE		(irb_base_address + 0x10)	/* TX irq enable */
-#define IRB_TX_INT_STATUS		(irb_base_address + 0x14)	/* TX irq status */
-#define IRB_TX_ENABLE			(irb_base_address + 0x18)	/* TX enable */
-#define IRB_TX_INT_CLEAR		(irb_base_address + 0x1c)	/* TX interrupt clear */
-#define IRB_TX_SUBCARRIER_WIDTH		(irb_base_address + 0x20)	/* subcarrier frequency width */
-#define IRB_TX_STATUS			(irb_base_address + 0x24)	/* TX status */
+#define IRB_TX_REG(x)		(irb_base_address + x)
+#define IRB_TX_PRESCALAR	IRB_TX_REG(0x00)	/* clock prescalar       */
+#define IRB_TX_SUBCARRIER	IRB_TX_REG(0x04)	/* subcarrier frequency  */
+#define IRB_TX_SYMPERIOD	IRB_TX_REG(0x08)	/* symbol period         */
+#define IRB_TX_ONTIME		IRB_TX_REG(0x0c)	/* symbol pulse time     */
+#define IRB_TX_INT_ENABLE	IRB_TX_REG(0x10)	/* TX irq enable         */
+#define IRB_TX_INT_STATUS	IRB_TX_REG(0x14)	/* TX irq status         */
+#define IRB_TX_ENABLE		IRB_TX_REG(0x18)	/* TX enable             */
+#define IRB_TX_INT_CLEAR	IRB_TX_REG(0x1c)	/* TX interrupt clear    */
+#define IRB_TX_SUBCARRIER_WIDTH	IRB_TX_REG(0x20)	/* subcarrier freq width */
+#define IRB_TX_STATUS		IRB_TX_REG(0x24)	/* TX status */
 
 #define TX_INT_PENDING			0x01
 #define TX_INT_UNDERRUN			0x02
@@ -111,410 +108,397 @@
 #define TX_FIFO_USED			((readl(IRB_TX_STATUS) >> 8) & 0x07)
 
 /* IR receiver registers */
-#define IRB_RX_ON	    		(irb_base_address + 0x40 + ir_or_uhf_offset)	/* RX pulse time capture */
-#define IRB_RX_SYS          		(irb_base_address + 0x44 + ir_or_uhf_offset)	/* RX sym period capture */
-#define IRB_RX_INT_EN	    		(irb_base_address + 0x48 + ir_or_uhf_offset)	/* RX IRQ enable (R/W)   */
-#define IRB_RX_INT_STATUS      		(irb_base_address + 0x4C + ir_or_uhf_offset)	/* RX IRQ status (R/W)   */
-#define IRB_RX_EN	    		(irb_base_address + 0x50 + ir_or_uhf_offset)	/* Receive enable (R/W)  */
-#define IRB_MAX_SYM_PERIOD  		(irb_base_address + 0x54 + ir_or_uhf_offset)	/* end of sym. max value */
-#define IRB_RX_INT_CLEAR 		(irb_base_address + 0x58 + ir_or_uhf_offset)	/* overrun status (W)    */
-#define IRB_RX_STATUS	    		(irb_base_address + 0x6C + ir_or_uhf_offset)	/* receive status        */
-#define IRB_RX_NOISE_SUPPR  		(irb_base_address + 0x5C + ir_or_uhf_offset)	/* noise suppression     */
-#define IRB_RX_POLARITY_INV 		(irb_base_address + 0x68 + ir_or_uhf_offset)	/* polarity inverter     */
+#define IRB_RX_REG(x)		(irb_base_address + x + ir_or_uhf_offset)
+#define IRB_RX_ON	    	IRB_RX_REG(0x40)	/* RX pulse time capture */
+#define IRB_RX_SYS          	IRB_RX_REG(0X44)	/* RX sym period capture */
+#define IRB_RX_INT_EN	    	IRB_RX_REG(0x48)	/* RX IRQ enable (R/W)   */
+#define IRB_RX_INT_STATUS      	IRB_RX_REG(0x4C)	/* RX IRQ status (R/W)   */
+#define IRB_RX_EN	    	IRB_RX_REG(0x50)	/* Receive enable (R/W)  */
+#define IRB_MAX_SYM_PERIOD  	IRB_RX_REG(0x54)	/* end of sym. max value */
+#define IRB_RX_INT_CLEAR 	IRB_RX_REG(0x58)	/* overrun status (W)    */
+#define IRB_RX_STATUS	    	IRB_RX_REG(0x6C)	/* receive status        */
+#define IRB_RX_NOISE_SUPPR  	IRB_RX_REG(0x5C)	/* noise suppression     */
+#define IRB_RX_POLARITY_INV 	IRB_RX_REG(0x68)	/* polarity inverter     */
 
 /* IRB and UHF common registers */
-#define IRB_RX_RATE_COMMON   		(irb_base_address + 0x64)	/* sampling frequency divisor */
-#define IRB_RX_CLOCK_SELECT  		(irb_base_address + 0x70)	/* clock selection (for low-power mode) */
-#define IRB_RX_CLOCK_SELECT_STATUS 	(irb_base_address + 0x74)	/* clock selection status */
-#define IRB_RX_NOISE_SUPP_WIDTH 	(irb_base_address + 0x9C)
+#define IRB_CM_REG(x)		(irb_base_address + x)
+#define IRB_RX_RATE_COMMON   	IRB_CM_REG(0x64)	/* sample frequency divisor */
+#define IRB_RX_CLOCK_SEL  	IRB_CM_REG(0x70)	/* clock select (LP mode)   */
+#define IRB_RX_CLOCK_SEL_STATUS IRB_CM_REG(0x74)	/* clock selection status   */
+#define IRB_RX_NOISE_SUPP_WIDTH IRB_CM_REG(0x9C)
+
+#define RX_CLEAR_IRQ(x) 		writel((x), IRB_RX_INT_CLEAR)
+#define RX_WORDS_IN_FIFO() 		(readl(IRB_RX_STATUS) & 0x0700)
+
+#define LIRC_STM_MINOR			0
+#define LIRC_STM_MAX_SYMBOLS		100
+#define LIRC_STM_BUFSIZE		(LIRC_STM_MAX_SYMBOLS*sizeof(lirc_t))
+
+/* Bit settings */
+#define LIRC_STM_IS_OVERRUN	 	0x04
+#define LIRC_STM_CLEAR_IRQ	 	0x38
+#define LIRC_STM_CLEAR_OVERRUN	 	0x04
+/* IRQ set: Enable full FIFO                 1  -> bit  3;
+ *          Enable overrun IRQ               1  -> bit  2;
+ *          Enable last symbol IRQ           1  -> bit  1:
+ *          Enable RX interrupt              1  -> bit  0;
+ */
+#define LIRC_STM_ENABLE_IRQ		0x0f
 
-#define LIRC_STM_NAME	"lirc_stm"
-#define LIRC_STM_MINOR		0
+/* RX graphical example to better understand the difference between ST IR block
+ * output and standard definition used by LIRC (and most of the world!)
+ *
+ *           mark                                     mark
+ *      |-IRB_RX_ON-|                            |-IRB_RX_ON-|
+ *      ___  ___  ___                            ___  ___  ___             _
+ *      | |  | |  | |                            | |  | |  | |             |
+ *      | |  | |  | |         space 0            | |  | |  | |   space 1   |
+ * _____| |__| |__| |____________________________| |__| |__| |_____________|
+ *
+ *      |--------------- IRB_RX_SYS -------------|------ IRB_RX_SYS -------|
+ *
+ *      |------------- encoding bit 0 -----------|---- encoding bit 1 -----|
+ *
+ * ST hardware returns mark (IRB_RX_ON) and total symbol time (IRB_RX_SYS), so
+ * convert to standard mark/space we have to calculate space=(IRB_RX_SYS - mark)
+ * The mark time represents the amount of time the carrier (usually 36-40kHz)
+ * is detected.
+ *
+ * TX is the same but with opposite calculation.
+ *
+ * The above examples shows Pulse Width Modulation encoding where bit 0 is
+ * represented by space>mark.
+ */
 
 /* SOC dependent section - these values are set in the appropriate 
  * arch/sh/kernel/cpu/sh4/setup-* files and
  * transfered when the lirc device is opened
  */
 
-static unsigned int rx_fifo_has_data = 0;
-static unsigned int rx_clear_overrun = 0;
-static unsigned int rx_overrun_err = 0;
-static unsigned int rx_sampling_freq_div = 0;
-static unsigned int rx_enable_irq = 0;
-#define RX_CLEAR_IRQ(x) writel((x), IRB_RX_INT_CLEAR)
-#define HOW_MANY_WORDS_IN_FIFO() (readl(IRB_RX_STATUS) & 0x0700 )
-
-/* Definition of a single RC symbol */
-typedef struct symbol_s {
-	unsigned int PulseUs;
-	unsigned int SpaceUs;
-} symbol_t;
-
-/* InfraRed receive control structure */
-#define MAX_SYMBOLS	100
-struct st_plugin_data_t {
-	int open_count;		/* INC at any open                      */
-	int error;		/* true if receive error.. skip symbols */
-	int symbols;		/* how many symbols in buf..            */
-	symbol_t buf[MAX_SYMBOLS];
-	struct timeval sync;	/* start of sync space */
-	unsigned int sumUs;	/* sum of symbols */
-} pd;
-
-/* IR transmit buffer */
-static lirc_t wbuf[MAX_SYMBOLS];
-static volatile int off_wbuf = 0;
-
-/* LIRC subsytem symbol buffer */
-struct lirc_buffer stlirc_buffer;	/* managed only via common lirc routines */
-/* user process read symbols from here  */
-
-static inline void reset_irq_data(struct st_plugin_data_t *pd)
-{
-	pd->error = 0;
-	pd->symbols = 0;
-	memset((unsigned char *)pd->buf, 0, sizeof(pd->buf));
-	pd->sumUs = 0;
-}
-
-#ifdef LIRC_STM_DEBUG
-/* For debug only: in memory structure to trace interrupt
- * status registers and symbols timing received.
- */
-#define MAX_IRD		200
-typedef struct ird_t {
-	unsigned int a_intsta;
-	unsigned int b_intsta;
-	unsigned int c_intsta;
-	unsigned int a_status;
-	unsigned int b_status;
-	unsigned int sym;
-	unsigned int mark;
-	unsigned int sr;
-} ird_t;
-static int ird_valid = -1;
-static ird_t ird[MAX_IRD];
+typedef struct lirc_stm_tx_data_s {
+	wait_queue_head_t waitq;
+	/* timing fine control */
+	unsigned int mult;
+	unsigned int div;
+	unsigned int carrier_freq;
+	/* transmit buffer */
+	lirc_t *wbuf;
+	volatile int off_wbuf;
+} lirc_stm_tx_data_t;
+
+typedef struct lirc_stm_rx_data_s {
+	/* timing fine control */
+	int symbol_mult;
+	int symbol_div;
+	int pulse_mult;
+	int pulse_div;
+	/* data configuration */
+	unsigned int sampling_freq_div;
+	lirc_t *rbuf;
+	volatile int off_rbuf;
+	unsigned int sumUs;
+	int error;
+	struct timeval sync;
+} lirc_stm_rx_data_t;
+
+typedef struct lirc_stm_plugin_data_s {
+	int open_count;
+	struct plat_lirc_data *p_lirc_d;
+} lirc_stm_plugin_data_t;
+
+static lirc_stm_plugin_data_t pd;	/* IR data config */
+static lirc_stm_rx_data_t rx;	/* RX data config */
+static lirc_stm_tx_data_t tx;	/* TX data config */
+
+/* LIRC subsytem symbol buffer. managed only via common lirc routines
+ * user process read symbols from here  */
+struct lirc_buffer lirc_stm_rbuf;
 
-static void trace_prt(void)
+static inline void lirc_stm_reset_rx_data(void)
 {
-	int i;
-
-	if (ird_valid == -1)
-		return;
-
-	DPRINTK
-	    ("  #   IRQst  stats      S      M   IRQst  stats  IRQst   s.r\n");
-	for (i = 0; i < ird_valid; i++)
-		DPRINTK
-		    ("%3d    %04x  %04x   %5d  %5d    %04x   %04x   %04x   %3d\n",
-		     i, ird[i].a_intsta, ird[i].a_status, ird[i].sym,
-		     ird[i].mark, ird[i].b_intsta, ird[i].b_status,
-		     ird[i].c_intsta, ird[i].sr);
-	memset(ird, 0, sizeof(ird));
-	ird_valid = -1;
-}
-
-#define TRACEA(a,b)   { if (ird_valid >= MAX_IRD) \
-				ird_valid = -1; \
-			ird_valid++; \
-			ird[ird_valid].a_intsta = (a); \
-			ird[ird_valid].a_status = (b); }
-#define TRACES(a,b,c) { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
-			{\
-				ird[ird_valid].sym  = (a); \
-				ird[ird_valid].mark = (b); \
-				ird[ird_valid].sr   = (c); \
-			}\
-		      }
-#define TRACEC(a,b)   { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
-	                {\
-				ird[ird_valid].b_intsta = (a); \
-				ird[ird_valid].b_status = (b); \
-			}\
-		      }
-#define TRACEE(a)     { if (ird_valid >= 0 && ird_valid <= MAX_IRD) \
-				ird[ird_valid].c_intsta = (a); }
-#define TRACE_PRT()     trace_prt();
-#else
-#define TRACEA(a,b)
-#define TRACES(a,b,c)
-#define TRACEC(a,b)
-#define TRACEE(a)
-#define TRACE_PRT()
-
-#endif
+	rx.error = 0;
+	rx.off_rbuf = 0;
+	rx.sumUs = 0;
+	memset(rx.rbuf, 0, LIRC_STM_BUFSIZE);
+}
 
 static inline unsigned int lirc_stm_time_to_cycles(unsigned int microsecondtime)
 {
 	/* convert a microsecond time to the nearest number of subcarrier clock
 	 * cycles
 	 */
-	microsecondtime *= tx_mult;
-	microsecondtime /= tx_div;
-	return (microsecondtime * tx_carrier_freq / 1000000);
+	microsecondtime *= tx.mult;
+	microsecondtime /= tx.div;
+	return (microsecondtime * tx.carrier_freq / 1000000);
 }
 
 static void lirc_stm_tx_interrupt(int irq, void *dev_id)
 {
 	unsigned int symbol, mark, done = 0;
 	unsigned int tx_irq_status = readl(IRB_TX_INT_STATUS);
-        
-	if ((tx_irq_status & TX_INT_PENDING) != TX_INT_PENDING) 
-            return;
-
-        while (done == 0) {
-            if ((readl(IRB_TX_INT_STATUS) & TX_INT_UNDERRUN) ==
-                TX_INT_UNDERRUN) {
-                /* There has been an underrun - clear flag, switch
-                 * off transmitter and signal possible exit
-                 */
-                printk(KERN_ERR "lirc_stm: transmit underrun!\n");
-                writel(0x02, IRB_TX_INT_CLEAR);
-                writel(0x00, IRB_TX_INT_ENABLE);
-                writel(0x00, IRB_TX_ENABLE);
-                done = 1;
-                DPRINTK("disabled TX\n");
-                wake_up_interruptible(&tx_waitq);
-            } else {
-                int fifoslots = TX_FIFO_USED;
-
-                while (fifoslots < TX_FIFO_DEPTH) {
-                    mark = wbuf[(off_wbuf * 2)];
-                    symbol = mark + wbuf[(off_wbuf * 2) + 1];
-                    DPRINTK("TX raw m %d s %d ", mark, symbol);
-
-                    mark =lirc_stm_time_to_cycles(mark) + 1;
-                    symbol =lirc_stm_time_to_cycles(symbol) + 2;
-                    DPRINTK("cal m %d s %d\n", mark, symbol);
-
-                    if ((wbuf[(off_wbuf * 2)] == 0xFFFF) || 
-                        (wbuf[(off_wbuf * 2) + 1] == 0xFFFF)) 
-                    {
-                        /* Dump out last symbol */
-                        writel(mark * 2, IRB_TX_SYMPERIOD);
-                        writel(mark, IRB_TX_ONTIME);
-
-                        DPRINTK("TX end m %d s %d\n", mark, mark * 2);
-
-                        /* flush transmit fifo */
-                        while (TX_FIFO_USED != 0) {
-                        };
-                        writel(0, IRB_TX_SYMPERIOD);
-                        writel(0, IRB_TX_ONTIME);
-                        /* spin until TX fifo empty */
-                        while (TX_FIFO_USED != 0) {
-                        };
-                        /* disable tx interrupts and transmitter */
-                        writel(0x07, IRB_TX_INT_CLEAR);
-                        writel(0x00, IRB_TX_INT_ENABLE);
-                        writel(0x00, IRB_TX_ENABLE);
-                        DPRINTK("TX disabled\n");
-                        off_wbuf = 0;
-                        fifoslots = 999;
-                        done = 1;
-                    } else {
-                        writel(symbol,IRB_TX_SYMPERIOD);
-                        writel(mark, IRB_TX_ONTIME);
-
-                        DPRINTK("Nm %d s %d\n", mark, symbol);
-
-                        off_wbuf++;
-                        fifoslots = TX_FIFO_USED;
-                    }
-                }
-            }
-        }
+
+	if ((tx_irq_status & TX_INT_PENDING) != TX_INT_PENDING)
+		return;
+
+	while (done == 0) {
+		if (unlikely((readl(IRB_TX_INT_STATUS) & TX_INT_UNDERRUN) ==
+			     TX_INT_UNDERRUN)) {
+			/* There has been an underrun - clear flag, switch
+			 * off transmitter and signal possible exit
+			 */
+			printk(KERN_ERR "lirc_stm: transmit underrun!\n");
+			writel(0x02, IRB_TX_INT_CLEAR);
+			writel(0x00, IRB_TX_INT_ENABLE);
+			writel(0x00, IRB_TX_ENABLE);
+			done = 1;
+			DPRINTK("disabled TX\n");
+			wake_up_interruptible(&tx.waitq);
+		} else {
+			int fifoslots = TX_FIFO_USED;
+
+			while (fifoslots < TX_FIFO_DEPTH) {
+				mark = tx.wbuf[(tx.off_wbuf * 2)];
+				symbol = mark + tx.wbuf[(tx.off_wbuf * 2) + 1];
+				DPRINTK("TX raw m %d s %d ", mark, symbol);
+
+				mark = lirc_stm_time_to_cycles(mark) + 1;
+				symbol = lirc_stm_time_to_cycles(symbol) + 2;
+				DPRINTK("cal m %d s %d\n", mark, symbol);
+
+				if ((tx.wbuf[(tx.off_wbuf * 2)] == 0xFFFF) ||
+				    (tx.wbuf[(tx.off_wbuf * 2) + 1] == 0xFFFF))
+				{
+					/* Dump out last symbol */
+					writel(mark * 2, IRB_TX_SYMPERIOD);
+					writel(mark, IRB_TX_ONTIME);
+
+					DPRINTK("TX end m %d s %d\n",
+						mark, mark * 2);
+
+					/* flush transmit fifo */
+					while (TX_FIFO_USED != 0) {
+					};
+					writel(0, IRB_TX_SYMPERIOD);
+					writel(0, IRB_TX_ONTIME);
+					/* spin until TX fifo empty */
+					while (TX_FIFO_USED != 0) {
+					};
+					/* disable tx interrupts and
+					 * transmitter */
+					writel(0x07, IRB_TX_INT_CLEAR);
+					writel(0x00, IRB_TX_INT_ENABLE);
+					writel(0x00, IRB_TX_ENABLE);
+					DPRINTK("TX disabled\n");
+					tx.off_wbuf = 0;
+					fifoslots = 999;
+					done = 1;
+				} else {
+					writel(symbol, IRB_TX_SYMPERIOD);
+					writel(mark, IRB_TX_ONTIME);
+
+					DPRINTK("Nm %d s %d\n", mark, symbol);
+
+					tx.off_wbuf++;
+					fifoslots = TX_FIFO_USED;
+				}
+			}
+		}
+	}
 }
 
 static void lirc_stm_rx_interrupt(int irq, void *dev_id)
 {
-	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)dev_id;
 	unsigned int symbol, mark = 0;
 	int lastSymbol, clear_irq = 1;
 
-	for (;;) {
-		/* if received FIFO is empty exit from loop */
-		/* also deal with fifo underrun interrupt */
-		if (HOW_MANY_WORDS_IN_FIFO() == 0) {
-			RX_CLEAR_IRQ(rx_fifo_has_data | 0x02);
-                        writel(rx_enable_irq, IRB_RX_INT_EN);
-                        clear_irq = 1;
-			break;
-		} else {
-			unsigned int rx_irq_status = readl(IRB_RX_INT_STATUS);
+	while (RX_WORDS_IN_FIFO()) {
+		/* discard the entire collection in case of errors!  */
+		if (unlikely(readl(IRB_RX_INT_STATUS) & LIRC_STM_IS_OVERRUN)) {
+			printk(KERN_INFO "lirc_stm: IR RX overrun\n");
+			writel(LIRC_STM_CLEAR_OVERRUN, IRB_RX_INT_CLEAR);
+			rx.error = 1;
+		}
 
-			/* discard the entire collection in case of errors!  */
-			if (rx_irq_status & rx_overrun_err) {
-				printk(KERN_INFO "IR overrun\n");
-				writel(rx_clear_overrun, IRB_RX_INT_CLEAR);
-				pd->error = 1;
-			}
+		/* get the symbol times from FIFO */
+		symbol = (readl(IRB_RX_SYS));
+		mark = (readl(IRB_RX_ON));
+
+		if (clear_irq) {
+			/*  Clear the interrupt
+			 * and leave only the overrun irq enabled */
+			RX_CLEAR_IRQ(LIRC_STM_CLEAR_IRQ);
+			writel(0x07, IRB_RX_INT_EN);
+			clear_irq = 0;
+		}
 
-			TRACEA(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
+		if (rx.off_rbuf >= LIRC_STM_MAX_SYMBOLS) {
+			printk
+			    ("lirc_stm: IR too many symbols (max %d)\n",
+			     LIRC_STM_MAX_SYMBOLS);
+			rx.error = 1;
+		}
 
-			/* get the symbol times from FIFO */
-			symbol = (readl(IRB_RX_SYS));
-			mark = (readl(IRB_RX_ON));
-
-                        if (clear_irq) {
-                            /*  Clear the interrupt (not required for some boards) 
-                             * and take only the underrun irq enabled */
-                            RX_CLEAR_IRQ(rx_fifo_has_data);
-                            writel(0x04, IRB_RX_INT_EN);
-                            clear_irq = 0;
-                        }
-
-			if (pd->symbols >= MAX_SYMBOLS) {
-				printk("IR too many symbols (max %d)\n",
-				       MAX_SYMBOLS);
-				pd->error = 1;
-			}
+		/* now handle the data depending on error condition */
+		if (rx.error) {
+			/*  Try again */
+			lirc_stm_reset_rx_data();
+			continue;
+		}
 
-			/* now handle the data depending on error condition */
-			if (pd->error) {
-				/*  Try again */
-				reset_irq_data(pd);
-				continue;
-			}
-                        if (symbol == 0xFFFF)
-                             lastSymbol = 1;
-                        else lastSymbol = 0;
+		if (symbol == 0xFFFF)
+			lastSymbol = 1;
+		else
+			lastSymbol = 0;
 
-			/* A sequence seems to start with a constant time symbol (1us)
-			 * pulse and symbol time length, both of 1us. We ignore this.
+		/* A sequence seems to start with a constant time symbol (1us)
+		 * pulse and symbol time length, both of 1us. We ignore this.
+		 */
+		if ((mark > 2) && (symbol > 1)) {
+			/* Make fine adjustments to timings */
+			symbol -= mark;	/* to get space timing */
+			symbol *= rx.symbol_mult;
+			symbol /= rx.symbol_div;
+			mark *= rx.pulse_mult;
+			mark /= rx.pulse_div;
+
+			/* The ST hardware returns the pulse time and the
+			 * period, which is the pulse time + space time, so
+			 * we need to subtract the pulse time from the period
+			 * to get the space time.
+			 * For a pulse in LIRC MODE2, we need to set the
+			 * PULSE_BIT ON
 			 */
-			if ((mark > 2) && (symbol > 1)) {
-				TRACES(symbol, mark, pd->symbols);
-
-				/* Make fine adjustments to timings */
-				symbol -= mark;	/* to get space timing */
-				symbol *= rx_symbol_mult;
-				symbol /= rx_symbol_div;
-				mark *= rx_pulse_mult;
-				mark /= rx_pulse_div;
-
-				/* The ST hardware returns the pulse time and the period, which is
-				 * the pulse time + space time, so we need to subtract the pulse time from
-				 * the period to get the space time.
-				 * For a pulse in LIRC MODE2, we need to set the PULSE_BIT ON
+			rx.rbuf[(rx.off_rbuf * 2)] = mark | PULSE_BIT;
+			rx.rbuf[(rx.off_rbuf * 2) + 1] = symbol;
+			rx.sumUs += mark + symbol;
+			rx.off_rbuf++;
+
+			if (lastSymbol) {
+				/* move the entire collection into user
+				 * buffer if enough space, drop otherwise
+				 * (perhaps too crude a recovery?)
 				 */
-				pd->buf[pd->symbols].PulseUs = mark | PULSE_BIT;
-				pd->buf[pd->symbols].SpaceUs = symbol;
-				pd->sumUs += mark + symbol;
-				pd->symbols++;
-
-				if (lastSymbol) {
-                                    /* move the entire collection into user buffer if enough
-                                     * space, drop it otherwise (perhaps too crude a recovery?)
-                                     */
-                                    if (lirc_buffer_available(&stlirc_buffer) >=
-                                        (2 * pd->symbols)) {
-                                        struct timeval now;
-                                        lirc_t syncSpace;
-
-                                        DPRINTK("W symbols = %d\n", pd->symbols);
-
-                                        /*  Calculate and write the leading space
-                                         *  All spaces and pulses together sum up to the microseconds
-                                         *  elapsed since we sent the previous block of data
-                                         */
-                                        do_gettimeofday(&now);
-                                        if (now.tv_sec - pd->sync.tv_sec < 0)
-                                            syncSpace = 0;
-                                        else if (now.tv_sec - pd->sync.tv_sec
-							 > PULSE_MASK / 1000000)
-                                            syncSpace = PULSE_MASK;
-                                        else {
-                                            syncSpace = (now.tv_sec - pd->sync.tv_sec) * 
-                                                1000000	+ (now.tv_usec -pd->sync.tv_usec);
-                                            syncSpace-= (pd->sumUs - pd->buf[pd->symbols - 1].SpaceUs);
-                                            if (syncSpace < 0)
-                                                syncSpace = 0;
-                                            else if (syncSpace > PULSE_MASK)
-                                                syncSpace = PULSE_MASK;
-                                        }
-                                        lirc_buffer_write_1(&stlirc_buffer,
-                                                            (unsigned char *)&syncSpace);
-                                        pd->sync = now;
-
-                                        /*  Now write the pulse / space pairs EXCEPT FOR THE LAST SPACE
-                                         *  The last space value should be 0xFFFF to denote a timeout
-                                         */
-                                        lirc_buffer_write_n(&stlirc_buffer,
-                                                            (unsigned char *)pd->buf,
-                                                            (2 * pd->symbols) - 1);
-						wake_up(&stlirc_buffer.wait_poll);
-					} else
-						printk(KERN_ERR
-						       "Not enough space in user buffer\n");
-
-					TRACE_PRT();
-					reset_irq_data(pd);
-				}
+				if (likely(lirc_buffer_available
+					   (&lirc_stm_rbuf) >=
+					   (2 * rx.off_rbuf))) {
+					struct timeval now;
+					lirc_t syncSpace;
+
+					DPRINTK("W symbols = %d\n",
+						rx.off_rbuf);
+
+					/*  Calculate and write the leading
+					 *  space. All spaces and pulses
+					 *  together sum up to the
+					 *  microseconds elapsed since we
+					 *  sent the previous block of data
+					 */
+
+					do_gettimeofday(&now);
+					if (now.tv_sec - rx.sync.tv_sec < 0)
+						syncSpace = 0;
+					else if (now.tv_sec -
+						 rx.sync.tv_sec >
+						 PULSE_MASK / 1000000)
+						syncSpace = PULSE_MASK;
+					else {
+						syncSpace =
+						    (now.tv_sec -
+						     rx.sync.tv_sec) *
+						    1000000 +
+						    (now.tv_usec -
+						     rx.sync.tv_usec);
+						syncSpace -=
+						    (rx.sumUs -
+						     rx.
+						     rbuf[((rx.
+							    off_rbuf -
+							    1) * 2) + 1]);
+						if (syncSpace < 0)
+							syncSpace = 0;
+						else if (syncSpace > PULSE_MASK)
+							syncSpace = PULSE_MASK;
+					}
+
+					lirc_buffer_write_1
+					    (&lirc_stm_rbuf, (unsigned char *)
+					     &syncSpace);
+					rx.sync = now;
+
+					/*  Now write the pulse / space pairs
+					 *  EXCEPT FOR THE LAST SPACE
+					 *  The last space value should be
+					 *  0xFFFF to denote a timeout
+					 */
+					lirc_buffer_write_n
+					    (&lirc_stm_rbuf,
+					     (unsigned char *)rx.rbuf,
+					     (2 * rx.off_rbuf) - 1);
+					wake_up_interruptible
+					    (&lirc_stm_rbuf.wait_poll);
+				} else
+					printk(KERN_ERR
+					       "lirc_stm: not enough space "
+					       "in user buffer\n");
+				lirc_stm_reset_rx_data();
 			}
-			TRACEC(readl(IRB_RX_INT_STATUS), readl(IRB_RX_STATUS));
-		} /* receive handler */
-	}
+		}
+	}			/* while */
 
-	TRACEE(readl(IRB_RX_INT_STATUS));
+	RX_CLEAR_IRQ(LIRC_STM_CLEAR_IRQ | 0x02);
+	writel(LIRC_STM_ENABLE_IRQ, IRB_RX_INT_EN);
 }
 
 static irqreturn_t lirc_stm_interrupt(int irq, void *dev_id)
 {
 	lirc_stm_tx_interrupt(irq, dev_id);
-
 	lirc_stm_rx_interrupt(irq, dev_id);
 
 	return IRQ_HANDLED;
 }
 
-static int stm_set_use_inc(void *data)
+static int lirc_stm_open_inc(void *data)
 {
-	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
-
-	DPRINTK("entering (open N. %d)\n", pd->open_count);
+	lirc_stm_plugin_data_t *lpd = (lirc_stm_plugin_data_t *) data;
+	DPRINTK("entering open\n");
 
-	/* enable the device only at the first open */
-	if (pd->open_count++ == 0) {
+	if (lpd->open_count++ == 0) {
 		unsigned long flags;
-		DPRINTK("Enabled\n");
+		DPRINTK("plugin enabled\n");
 		local_irq_save(flags);
 
 		/* enable interrupts and receiver */
-		writel(rx_enable_irq, IRB_RX_INT_EN);
+		writel(LIRC_STM_ENABLE_IRQ, IRB_RX_INT_EN);
 		writel(0x01, IRB_RX_EN);
-		reset_irq_data(pd);
-		pd->sync.tv_sec = 0;
-		pd->sync.tv_usec = 0;
+		lirc_stm_reset_rx_data();
 		local_irq_restore(flags);
 	} else
-		DPRINTK("Already open\n");
+		DPRINTK("plugin already open\n");
 
 	return 0;
 }
 
-static void flush_stm_lirc(struct st_plugin_data_t *pd)
+static void lirc_stm_flush_rx(void)
 {
-        /* Disable receiver */ 
+	/* Disable receiver */
 	writel(0x00, IRB_RX_EN);
-        /* TBD: set one word in FIFO ??? and disable interrupt */
-        writel(0x20, IRB_RX_INT_EN);
-        /* clean the buffer */
-	reset_irq_data(pd);
+	/* Disable interrupt */
+	writel(0x20, IRB_RX_INT_EN);
+	/* clean the buffer */
+	lirc_stm_reset_rx_data();
 }
 
 /*
 ** Called by lirc_dev as a last action on a real close
 */
-static void stm_set_use_dec(void *data)
+static void lirc_stm_close_dec(void *data)
 {
-	struct st_plugin_data_t *pd = (struct st_plugin_data_t *)data;
-	DPRINTK("entering (close N. %d)\n", pd->open_count);
+	lirc_stm_plugin_data_t *lpd = (lirc_stm_plugin_data_t *) data;
+	DPRINTK("entering close\n");
 
 	/* The last close disable the receiver */
-	if (--pd->open_count == 0)
-		flush_stm_lirc(pd);
-	TRACE_PRT();
+	if (--lpd->open_count == 0)
+		lirc_stm_flush_rx();
 }
 
 static int lirc_stm_ioctl(struct inode *node, struct file *filep,
@@ -528,12 +512,15 @@
 	case LIRC_GET_FEATURES:
 		/*
 		 * Our driver can receive in mode2 and send in pulse mode.
-		 * TODO: We can generate our own carrier freq (LIRC_CAN_SET_SEND_CARRIER)
-		 *       and also change duty cycle (LIRC_CAN_SET_SEND_DUTY_CYCLE)
+		 * TODO: We can generate our own carrier freq
+		 *      (LIRC_CAN_SET_SEND_CARRIER) and also change duty
+		 *      cycle (LIRC_CAN_SET_SEND_DUTY_CYCLE)
 		 */
-		DPRINTK("LIRC_GET_FEATURES return REC_MODE2|SEND_PULSE\n");
-		retval = put_user(LIRC_CAN_REC_MODE2 |
-				  LIRC_CAN_SEND_PULSE, (unsigned long *)arg);
+		DPRINTK
+		    ("LIRC_GET_FEATURES return REC_MODE2|SEND_PULSE\n");
+		retval =
+		    put_user(LIRC_CAN_REC_MODE2 | LIRC_CAN_SEND_PULSE,
+			     (unsigned long *)arg);
 		break;
 
 	case LIRC_GET_REC_MODE:
@@ -549,7 +536,8 @@
 		break;
 
 	case LIRC_GET_SEND_MODE:
-		DPRINTK("LIRC_GET_SEND_MODE return LIRC_MODE_PULSE\n");
+		DPRINTK
+		    ("LIRC_GET_SEND_MODE return LIRC_MODE_PULSE\n");
 		retval = put_user(LIRC_MODE_PULSE, (unsigned long *)arg);
 		break;
 
@@ -617,28 +605,44 @@
 	int i;
 	size_t rdn = n / sizeof(size_t);
 	unsigned int symbol, mark;
-	int fifosyms;
+	int fifosyms, num_pio_pins;
+	struct lirc_pio *p;
+
+	num_pio_pins = pd.p_lirc_d->num_pio_pins;
+	while (num_pio_pins > 0) {
+		p = &(pd.p_lirc_d->pio_pin_arr[num_pio_pins - 1]);
+		if (!(p->pinof ^ (LIRC_IR_TX | LIRC_PIO_ON)))
+			break;
+		else
+			num_pio_pins--;
+	}
+	if (!num_pio_pins) {
+		printk(KERN_ERR "lirc_stm: write operation unsupported.\n");
+		return -ENOTSUPP;
+	}
 
 	if (n % sizeof(lirc_t))
 		return -EINVAL;
 
-	if (off_wbuf != 0 && (file->f_flags & O_NONBLOCK))
+	if (tx.off_wbuf != 0 && (file->f_flags & O_NONBLOCK))
 		return -EAGAIN;
 
 	/* Wait for transmit to become free... */
-	if (wait_event_interruptible(tx_waitq, off_wbuf == 0))
+	if (wait_event_interruptible(tx.waitq, tx.off_wbuf == 0))
 		return -ERESTARTSYS;
 
 	/* Prevent against buffer overflow... */
-	if (rdn > MAX_SYMBOLS) rdn = MAX_SYMBOLS;
+	if (rdn > LIRC_STM_MAX_SYMBOLS)
+		rdn = LIRC_STM_MAX_SYMBOLS;
 
 	n -= rdn * sizeof(size_t);
 
-	if (copy_from_user((char *)wbuf, buf, rdn * sizeof(size_t))) {
+	if (copy_from_user((char *)tx.wbuf, buf, rdn * sizeof(size_t))) {
 		return -EFAULT;
 	}
 
-	if (n == 0) wbuf[rdn - 1] = 0xFFFF;
+	if (n == 0)
+		tx.wbuf[rdn - 1] = 0xFFFF;
 
 	/* load the first words into the FIFO */
 	fifosyms = rdn;
@@ -647,23 +651,23 @@
 		fifosyms = TX_FIFO_DEPTH;
 
 	for (i = 0; i < fifosyms; i++) {
-            mark = wbuf[(i * 2)];
-            symbol = mark + wbuf[(i * 2) + 1];
-            DPRINTK("TX raw m %d s %d ", mark, symbol);
-
-            mark = lirc_stm_time_to_cycles(mark) + 1;
-            symbol = lirc_stm_time_to_cycles(symbol) + 2;
-            DPRINTK("cal m %d s %d\n", mark, symbol);
-
-            off_wbuf++;
-            writel(mark, IRB_TX_ONTIME);
-            writel(symbol, IRB_TX_SYMPERIOD);
+		mark = tx.wbuf[(i * 2)];
+		symbol = mark + tx.wbuf[(i * 2) + 1];
+		DPRINTK("TX raw m %d s %d ", mark, symbol);
+
+		mark = lirc_stm_time_to_cycles(mark) + 1;
+		symbol = lirc_stm_time_to_cycles(symbol) + 2;
+		DPRINTK("cal m %d s %d\n", mark, symbol);
+
+		tx.off_wbuf++;
+		writel(mark, IRB_TX_ONTIME);
+		writel(symbol, IRB_TX_SYMPERIOD);
 	}
 
 	/* enable the transmit */
 	writel(0x07, IRB_TX_INT_ENABLE);
 	writel(0x01, IRB_TX_ENABLE);
-        DPRINTK("TX enabled\n");
+	DPRINTK("TX enabled\n");
 
 	return n;
 }
@@ -715,184 +719,52 @@
 	writel(nbest, IRB_TX_SUBCARRIER);
 	writel(nbest * subwidthpercent / 100, IRB_TX_SUBCARRIER_WIDTH);
 
-	/*  Now calculate timing to subcarrier cycles factors which compensate for
-	 *  any remaining difference between our clock ratios and real times in
-	 *  microseconds
+	/*  Now calculate timing to subcarrier cycles factors which compensate
+	 *  for any remaining difference between our clock ratios and real times
+	 *  in microseconds
 	 */
 
 	if (diffbest == 0) {
-		/* no adjustment required - our clock is running at the required speed */
-		tx_mult = 1;
-		tx_div = 1;
+		/* no adjustment required - our clock is running at the required
+		 * speed */
+		tx.mult = 1;
+		tx.div = 1;
 	} else {
 		/* adjustment is required */
 		delta = scalarbest * carrierfreq * nbest;
-		tx_mult = delta / (clockfreq / 10000);
+		tx.mult = delta / (clockfreq / 10000);
 
 		if (delta < clockfreq) {	/* our clock is running too fast */
-			DPRINTK("Clock running slow at %d\n", delta);
-			tx_div = tx_mult;
-			tx_mult = 10000;
+			DPRINTK("clock running slow at %d\n", delta);
+			tx.div = tx.mult;
+			tx.mult = 10000;
 		} else {	/* our clock is running too slow */
 
-			DPRINTK("Clock running fast at %d\n", delta);
-			tx_div = 10000;
+			DPRINTK("clock running fast at %d\n", delta);
+			tx.div = 10000;
 		}
 	}
 
-	DPRINTK("TX fine adjustment mult = %d\n", tx_mult);
-	DPRINTK("TX fine adjustment div  = %d\n", tx_div);
+	DPRINTK("TX fine adjustment mult = %d\n", tx.mult);
+	DPRINTK("TX fine adjustment div  = %d\n", tx.div);
 }
 
-static struct file_operations lirc_stm_fops = {
-      write:lirc_stm_write,
-};
-
-static struct lirc_plugin lirc_stm_plugin = {
-	.name  = LIRC_STM_NAME,
-	.minor = LIRC_STM_MINOR,
-	.code_length = 1,
-	.sample_rate = 0,
-	/* plugin can receive raw pulse and space timings for each symbol */
-	.features = LIRC_CAN_REC_MODE2,
-	/* plugin private data  */
-	.data = (void *)&pd,
-	/* buffer handled by upper layer */
-	.add_to_buf = NULL,
-	.get_queue = NULL,
-	.set_use_inc = stm_set_use_inc,
-	.set_use_dec = stm_set_use_dec,
-	.ioctl = lirc_stm_ioctl,
-	.fops = &lirc_stm_fops,
-	.rbuf = &stlirc_buffer,
-	.owner = THIS_MODULE,
-};
-
-static int __init lirc_stm_init(void)
+static int lirc_stm_hardware_init(struct platform_device *pdev)
 {
-	int ret = -EINVAL;
-	struct platform_device *lirc_plat_dev = NULL;
 	struct plat_lirc_data *lirc_private_data = NULL;
-	struct resource *res;
+	struct clk *clk;
 	int baseclock;
-	int piopins;
 	unsigned int scwidth;
-	struct clk *clk;
-	struct lirc_pio *p;
-
-	DPRINTK("initializing the IR receiver...\n");
-
-	/* inform the top level driver that we use our own user buffer */
-	if (lirc_buffer_init(&stlirc_buffer, sizeof(lirc_t), (2 * MAX_SYMBOLS))) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: buffer init failed\n");
-		goto lirc_out4;
-	}
-
-	request_module("lirc_dev");
-	if ((ret = lirc_register_plugin(&lirc_stm_plugin)) < 0) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: plug-in registration failed\n");
-		goto lirc_out4;
-	}
-
-	/*  At this point, we need to get a pointer to the platform-specific data */
-	if ((lirc_plat_dev = (struct platform_device *)lirc_get_config()) == NULL) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: platform data not found\n");
-		goto lirc_out4;
-	}
-
-	/* Request the IRQ */
-	if ((irb_irq = platform_get_irq(lirc_plat_dev, 0)) == 0) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: IRQ configuration not found\n");
-		ret = -ENODEV;
-		goto lirc_out4;
-	}
-
-	if ((ret = request_irq(irb_irq, lirc_stm_interrupt, IRQF_SHARED,
-			       LIRC_STM_NAME, (void *)&pd)) < 0) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: IRQ register failed\n");
-		ret = -EIO;
-		goto lirc_out4;
-	}
-
-	/* Configure for ir or uhf. ir_uhf_switch==1 is IRB */
-	if (ir_uhf_switch) 
-             ir_or_uhf_offset = 0x40;
-	else ir_or_uhf_offset = 0x00;
-
-	printk(KERN_INFO "lirc_stm: STM LIRC plugin has IRQ %d using %s mode\n", 
-               irb_irq, (ir_or_uhf_offset == 0 ? "IRB" : "UHF"));
-
-	/* Hardware IR block setup - the PIO ports should already be set up
-	 * in the board-dependent configuration.  We need to remap the
-	 * IR registers into kernel space - we do this in one chunk
-	 */
-
-	res = platform_get_resource(lirc_plat_dev, IORESOURCE_MEM, 0);
-	if (!res) {
-		printk(KERN_ERR "lirc_stm: lirc_stm_init: IO MEM not found\n");
-		ret = -ENODEV;
-		goto lirc_out3;
-	}
-
-	if (!request_mem_region(res->start, 
-                                res->end - res->start, 
-                                LIRC_STM_NAME)) {
-		printk(KERN_ERR
-		       "lirc_stm: lirc_stm_init: request_mem_region failed\n");
-		ret = -EBUSY;
-		goto lirc_out3;
-	}
-
-	irb_base_address = ioremap(res->start, res->end - res->start);
-	if (irb_base_address == NULL) {
-		printk(KERN_ERR "lirc_stm: lirc_stm_init: ioremap failed\n");
-		release_mem_region(res->start, res->end - res->start);
-		ret = -ENOMEM;
-		goto lirc_out2;
-	}
-
-	DPRINTK(KERN_INFO "ioremapped register block at 0x%lx\n", res->start);
-	DPRINTK(KERN_INFO "ioremapped to 0x%x\n",
-		(unsigned int)irb_base_address);
+	unsigned int rx_max_symbol_per;
 
 	/*  set up the hardware version dependent setup parameters */
-	lirc_private_data = (struct plat_lirc_data *)lirc_plat_dev->dev.platform_data;
+	lirc_private_data = (struct plat_lirc_data *)pdev->dev.platform_data;
 
-	/* Allocate the PIO pins */
-	piopins = lirc_private_data->num_pio_pins;
-	while (piopins > 0) {
-		p = &(lirc_private_data->pio_pin_arr[piopins - 1]);
-		if (!(p->pinaddr = stpio_request_pin(p->bank, 
-                                                     p->pin,
-						     LIRC_STM_NAME, 
-                                                     p->dir))) {
-			printk(KERN_ERR
-			       "lirc_stm: lirc_stm_init: STPIO[%d,%d] request failed\n",
-			       p->bank, p->pin);
-			ret = -EBUSY;
-			goto lirc_out1;
-		}
-		piopins--;
-	}
+	tx.carrier_freq = 38000;	// in Hz
 
 	/* Set the polarity inversion bit to the correct state */
 	writel(lirc_private_data->rxpolarity, IRB_RX_POLARITY_INV);
 
-	rx_overrun_err   = 0x04;
-        rx_fifo_has_data = 0x38;
-        rx_clear_overrun = 0x04;
-        /* IRQ set: Enable full FIFO                 1  -> bit  3;
-         *          Enable overrun IRQ               1  -> bit  2;
-         *          Enable last symbol IRQ           1  -> bit  1:
-         *          Enable RX interrupt              1  -> bit  0;
-         */
-        rx_enable_irq = 0x0f;
-
 	/*  Get or calculate the clock and timing adjustment values.
 	 *  We can auto-calculate these in some cases
 	 */
@@ -908,77 +780,76 @@
 
 		int freqdiff;
 
-		rx_sampling_freq_div = baseclock / 10000000;
+		rx.sampling_freq_div = baseclock / 10000000;
 
 		/* Work out the timing adjustment factors */
-		freqdiff = baseclock - (rx_sampling_freq_div * 10000000);
+		freqdiff = baseclock - (rx.sampling_freq_div * 10000000);
 
 		/* freqdiff contains the difference between our clock and a
 		 * true 10 MHz clock which the IR block wants
 		 */
 
 		if (freqdiff == 0) {
-			/* no adjustment required - our clock is running at the required speed */
-			rx_symbol_mult = 1;
-			rx_pulse_mult = 1;
-			rx_symbol_div = 1;
-			rx_pulse_div = 1;
+			/* no adjustment required - our clock is running at the
+			 * required speed
+			 */
+			rx.symbol_mult = 1;
+			rx.pulse_mult = 1;
+			rx.symbol_div = 1;
+			rx.pulse_div = 1;
 		} else {
 			/* adjustment is required */
-			rx_symbol_mult =
-			    baseclock / (10000 * rx_sampling_freq_div);
+			rx.symbol_mult =
+			    baseclock / (10000 * rx.sampling_freq_div);
 
 			if (freqdiff > 0) {
 				/* our clock is running too fast */
-				rx_pulse_mult = 1000;
-				rx_pulse_div = rx_symbol_mult;
-				rx_symbol_mult = rx_pulse_mult;
-				rx_symbol_div = rx_pulse_div;
+				rx.pulse_mult = 1000;
+				rx.pulse_div = rx.symbol_mult;
+				rx.symbol_mult = rx.pulse_mult;
+				rx.symbol_div = rx.pulse_div;
 			} else {
 				/* our clock is running too slow */
-				rx_symbol_div = 1000;
-				rx_pulse_mult = rx_symbol_mult;
-				rx_pulse_div = 1000;
+				rx.symbol_div = 1000;
+				rx.pulse_mult = rx.symbol_mult;
+				rx.pulse_div = 1000;
 			}
 
 		}
 
 	} else {
-		rx_sampling_freq_div = (lirc_private_data->irbclkdiv);
-		rx_symbol_mult = (lirc_private_data->irbperiodmult);
-		rx_symbol_div = (lirc_private_data->irbperioddiv);
-		rx_pulse_mult = (lirc_private_data->irbontimemult);
-		rx_pulse_div = (lirc_private_data->irbontimediv);
+		rx.sampling_freq_div = (lirc_private_data->irbclkdiv);
+		rx.symbol_mult = (lirc_private_data->irbperiodmult);
+		rx.symbol_div = (lirc_private_data->irbperioddiv);
+		rx.pulse_mult = (lirc_private_data->irbontimemult);
+		rx.pulse_div = (lirc_private_data->irbontimediv);
 	}
 
-	writel(rx_sampling_freq_div, IRB_RX_RATE_COMMON);
-	DPRINTK(KERN_INFO "IRB clock is %d\n", baseclock);
-	DPRINTK(KERN_INFO "IRB clock divisor is %d\n", rx_sampling_freq_div);
-	DPRINTK(KERN_INFO "IRB clock divisor readlack is %d\n",
+	writel(rx.sampling_freq_div, IRB_RX_RATE_COMMON);
+	DPRINTK("IR clock is %d\n", baseclock);
+	DPRINTK("IR clock divisor is %d\n", rx.sampling_freq_div);
+	DPRINTK("IR clock divisor readlack is %d\n",
 		readl(IRB_RX_RATE_COMMON));
-	DPRINTK(KERN_INFO "IRB period mult factor is %d\n", rx_symbol_mult);
-	DPRINTK(KERN_INFO "IRB period divisor factor is %d\n", rx_symbol_div);
-	DPRINTK(KERN_INFO "IRB pulse mult factor is %d\n", rx_pulse_mult);
-	DPRINTK(KERN_INFO "IRB pulse divisor factor is %d\n", rx_pulse_div);
-
-        {
-            /* maximum symbol period.  
-             * Symbol periods longer than this will generate
-             * an interrupt and terminate a command
-             */
-            unsigned int rx_max_symbol_per;
-            if ((lirc_private_data->irbrxmaxperiod) != 0)
+	DPRINTK("IR period mult factor is %d\n", rx.symbol_mult);
+	DPRINTK("IR period divisor factor is %d\n", rx.symbol_div);
+	DPRINTK("IR pulse mult factor is %d\n", rx.pulse_mult);
+	DPRINTK("IR pulse divisor factor is %d\n", rx.pulse_div);
+
+	/* maximum symbol period.
+	 * Symbol periods longer than this will generate
+	 * an interrupt and terminate a command
+	 */
+	if ((lirc_private_data->irbrxmaxperiod) != 0)
 		rx_max_symbol_per =
-		    (lirc_private_data->irbrxmaxperiod) * rx_symbol_mult /
-		    rx_symbol_div;
-            else
+		    (lirc_private_data->irbrxmaxperiod) *
+		    rx.symbol_mult / rx.symbol_div;
+	else
 		rx_max_symbol_per = 0;
 
-            DPRINTK(KERN_INFO "IRB RX Maximum symbol period register 0x%x\n",
-                    rx_max_symbol_per);
-            writel(rx_max_symbol_per, IRB_MAX_SYM_PERIOD);
-        }
-        
+	DPRINTK("RX Maximum symbol period register 0x%x\n",
+		rx_max_symbol_per);
+	writel(rx_max_symbol_per, IRB_MAX_SYM_PERIOD);
+
 	/*  Set up the transmit timings  */
 	if (lirc_private_data->subcarrwidth != 0)
 		scwidth = lirc_private_data->subcarrwidth;
@@ -988,65 +859,261 @@
 	if (scwidth > 100)
 		scwidth = 50;
 
-	DPRINTK(KERN_INFO "Subcarrier width set to %d %%\n", scwidth);
-	lirc_stm_calc_tx_clocks(baseclock, tx_carrier_freq, scwidth);
-
-	printk(KERN_INFO "STMicroelectronics LIRC driver configured\n");
+	DPRINTK("subcarrier width set to %d %%\n", scwidth);
+	lirc_stm_calc_tx_clocks(baseclock, tx.carrier_freq, scwidth);
+	return 0;
+}
 
+static int lirc_stm_remove(struct platform_device *pdev)
+{
+	DPRINTK("lirc_stm_remove called\n");
 	return 0;
+}
+
+static int lirc_stm_probe(struct platform_device *pdev)
+{
+	int ret = -EINVAL;
+	int num_pio_pins;
+	struct lirc_pio *p;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+
+	if (pdev->name == NULL) {
+		printk(KERN_ERR
+		       "lirc_stm: probe failed. Check kernel SoC config.\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO
+	       "lirc_stm: probe found data for platform device %s\n",
+	       pdev->name);
+	pd.p_lirc_d = (struct plat_lirc_data *)pdev->dev.platform_data;
+
+	if ((irb_irq = platform_get_irq(pdev, 0)) == 0) {
+		printk(KERN_ERR "lirc_stm: IRQ configuration not found\n");
+		return -ENODEV;
+	}
+
+	if (devm_request_irq(dev, irb_irq, lirc_stm_interrupt, IRQF_DISABLED,
+			     LIRC_STM_NAME, (void *)&pd) < 0) {
+		printk(KERN_ERR "lirc_stm: IRQ register failed\n");
+		return -EIO;
+	}
+
+	/* Configure for ir or uhf. uhf_switch==1 is UHF */
+	if (uhf_switch)
+		ir_or_uhf_offset = 0x40;
+	else
+		ir_or_uhf_offset = 0x00;
+
+	/* Hardware IR block setup - the PIO ports should already be set up
+	 * in the board-dependent configuration.  We need to remap the
+	 * IR registers into kernel space - we do this in one chunk
+	 */
+
+	if ((rx.rbuf = (lirc_t *) devm_kzalloc(dev,
+					       LIRC_STM_BUFSIZE,
+					       GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	if ((tx.wbuf = (lirc_t *) devm_kzalloc(dev,
+					       LIRC_STM_BUFSIZE,
+					       GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	memset(rx.rbuf, 0, LIRC_STM_BUFSIZE);
+	memset(tx.wbuf, 0, LIRC_STM_BUFSIZE);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR "lirc_stm: IO MEM not found\n");
+		return -ENODEV;
+	}
+
+	if (!devm_request_mem_region(dev, res->start,
+				     res->end - res->start, LIRC_STM_NAME)) {
+		printk(KERN_ERR "lirc_stm: request_mem_region failed\n");
+		return -EBUSY;
+	}
+
+	irb_base_address =
+	    devm_ioremap_nocache(dev, res->start, res->end - res->start);
+
+	if (irb_base_address == NULL) {
+		printk(KERN_ERR "lirc_stm: ioremap failed\n");
+		ret = -ENOMEM;
+	} else {
+		DPRINTK("ioremapped register block at 0x%x\n",
+			res->start);
+		DPRINTK("ioremapped to 0x%x\n",
+			(unsigned int)irb_base_address);
+
+		printk(KERN_INFO "lirc_stm: STM LIRC plugin has IRQ %d",
+		       irb_irq);
+
+		/* Allocate the PIO pins */
+		num_pio_pins = pd.p_lirc_d->num_pio_pins;
+		while (num_pio_pins > 0) {
+			ret = 0;
+			p = &(pd.p_lirc_d->pio_pin_arr[num_pio_pins - 1]);
+			/* Can I satisfy the IR-RX request ? */
+			if ((ir_or_uhf_offset == 0x00)
+			    && (p->pinof & LIRC_IR_RX)) {
+				if (p->pinof & LIRC_PIO_ON)
+					printk(" using IR-RX mode\n");
+				else {
+					printk
+					    (" with IR-RX mode unsupported\n");
+					ret = -1;
+				}
+			}
+
+			/* Can I satisfy the UHF-RX request ? */
+			if ((ir_or_uhf_offset == 0x40)
+			    && (p->pinof & LIRC_UHF_RX)) {
+				if (p->pinof & LIRC_PIO_ON)
+					printk(" using UHF-RX mode\n");
+				else {
+					printk
+					    (" with UHF-RX mode unsupported\n");
+					ret = -1;
+				}
+			}
+
+			/* Try to satisfy the request */
+			if ((!ret) && (p->pinof & LIRC_PIO_ON))
+				if (!(p->pinaddr = stpio_request_pin(p->bank,
+								     p->pin,
+								     LIRC_STM_NAME,
+								     p->dir))) {
+					printk(KERN_ERR
+					       "\nlirc_stm: PIO[%d,%d] request failed\n",
+					       p->bank, p->pin);
+					ret = -1;
+
+				}
+
+			/* something bad is happened */
+			if (ret) {
+				while (num_pio_pins < pd.p_lirc_d->num_pio_pins) {
+					stpio_free_pin(pd.p_lirc_d->
+						       pio_pin_arr
+						       [num_pio_pins].pinaddr);
+					pd.p_lirc_d->pio_pin_arr[num_pio_pins].
+					    pinaddr = NULL;
+					num_pio_pins++;
+				}
+				return -EIO;
+			}
+
+			num_pio_pins--;
+		}
+
+		/* reset and then harware initialisation */
+		init_waitqueue_head(&tx.waitq);
+		/* enable signal detection */
+		ret = lirc_stm_hardware_init(pdev);
+
+		if (!ret)
+			printk(KERN_INFO
+		       		"STMicroelectronics LIRC driver configured.\n");
+	}
 
-      lirc_out1:
-	while (piopins < lirc_private_data->num_pio_pins)
-		stpio_free_pin(lirc_private_data->pio_pin_arr[piopins++].
-			       pinaddr);
-	iounmap(irb_base_address);
-      lirc_out2:
-	release_mem_region(res->start, res->end - res->start);
-      lirc_out3:
-	free_irq(irb_irq, (void *)&pd);
-      lirc_out4:
 	return ret;
 }
 
+static struct platform_driver lirc_device_driver = {
+	.driver.name = "lirc",
+	.probe = lirc_stm_probe,
+	.remove = lirc_stm_remove,
+};
+
+static struct file_operations lirc_stm_fops = {
+      write:lirc_stm_write,
+};
+
+static struct lirc_plugin lirc_stm_plugin = {
+	.name = LIRC_STM_NAME,
+	.minor = LIRC_STM_MINOR,
+	.code_length = 1,
+	.sample_rate = 0,
+	/* plugin can receive raw pulse and space timings for each symbol */
+	.features = LIRC_CAN_REC_MODE2,
+	/* plugin private data  */
+	.data = (void *)&pd,
+	/* buffer handled by upper layer */
+	.add_to_buf = NULL,
+	.get_queue = NULL,
+	.set_use_inc = lirc_stm_open_inc,
+	.set_use_dec = lirc_stm_close_dec,
+	.ioctl = lirc_stm_ioctl,
+	.fops = &lirc_stm_fops,
+	.rbuf = &lirc_stm_rbuf,
+	.owner = THIS_MODULE,
+};
+
+static int __init lirc_stm_init(void)
+{
+	DPRINTK("initializing the IR receiver...\n");
+
+	/* inform the top level driver that we use our own user buffer */
+	if (lirc_buffer_init(&lirc_stm_rbuf, sizeof(lirc_t),
+			     (2 * LIRC_STM_MAX_SYMBOLS))) {
+		printk(KERN_ERR "lirc_stm: buffer init failed\n");
+		return -EINVAL;
+	}
+
+	request_module("lirc_dev");
+	if (lirc_register_plugin(&lirc_stm_plugin) < 0) {
+		printk(KERN_ERR "lirc_stm: plugin registration failed\n");
+		lirc_buffer_free(&lirc_stm_rbuf);
+		return -EINVAL;
+	}
+
+	if (platform_driver_register(&lirc_device_driver)) {
+		printk(KERN_ERR "lirc_stm: platform driver register failed\n");
+		lirc_buffer_free(&lirc_stm_rbuf);
+		lirc_unregister_plugin(LIRC_STM_MINOR);
+		return -EINVAL;
+	}
+	return 0;
+}
+
 void __exit lirc_stm_release(void)
 {
-	int ret_value, piopins;
-	struct resource *res;
-	struct platform_device *lirc_plat_dev = NULL;
-	struct plat_lirc_data *lirc_private_data = NULL;
+	int num_pio_pins;
 
 	DPRINTK("removing STM lirc plugin\n");
 
-	flush_stm_lirc(&pd);
-
-        /* unplug the lirc stm driver */
-	if ((ret_value = lirc_unregister_plugin(LIRC_STM_MINOR)) < 0)
-		printk(KERN_ERR "STM InfraRed plug-in unregister failed\n");
-
-	iounmap(irb_base_address);
-
-        /* deallocate the STPIO pins */
-	lirc_plat_dev = (struct platform_device *)lirc_get_config();
-	lirc_private_data = (struct plat_lirc_data *)lirc_plat_dev->dev.platform_data;
-	piopins = lirc_private_data->num_pio_pins;
-	while (piopins > 0)
-		stpio_free_pin(lirc_private_data->pio_pin_arr[--piopins].
-			       pinaddr);
-
-        /* release platform resource */
-	res = platform_get_resource(lirc_plat_dev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, res->end - res->start);
+	/* unregister the plugin */
+	lirc_stm_flush_rx();
+	platform_driver_unregister(&lirc_device_driver);
+
+	/* unplug the lirc stm driver */
+	if (lirc_unregister_plugin(LIRC_STM_MINOR) < 0)
+		printk(KERN_ERR "lirc_stm: plugin unregister failed\n");
+	/* free buffer */
+	lirc_buffer_free(&lirc_stm_rbuf);
+
+	/* deallocate the STPIO pins */
+	num_pio_pins = pd.p_lirc_d->num_pio_pins;
+	while (num_pio_pins > 0)
+		if (pd.p_lirc_d->pio_pin_arr[num_pio_pins - 1].pinaddr)
+			stpio_free_pin(pd.p_lirc_d->pio_pin_arr[--num_pio_pins].
+				       pinaddr);
+		else
+			--num_pio_pins;
 
-	free_irq(irb_irq, (void *)&pd);
 	printk(KERN_INFO "STMicroelectronics LIRC driver removed\n");
 }
 
-module_param(ir_uhf_switch, bool, 0644);
-MODULE_PARM_DESC(ir_uhf_switch, "Enable uhf mode");
+module_param(uhf_switch, bool, 0664);
+MODULE_PARM_DESC(ir_or_uhf_offset, "Enable uhf mode");
 
 module_init(lirc_stm_init);
 module_exit(lirc_stm_release);
 MODULE_DESCRIPTION
     ("Linux InfraRed receiver plugin for STMicroelectronics platforms");
 MODULE_AUTHOR("Carl Shaw <carl.shaw@st.com>");
+MODULE_AUTHOR("Angelo Castello <angelo.castello@st.com>");
 MODULE_LICENSE("GPL");
Index: linux-2.6.23/drivers/char/lirc/Makefile
===================================================================
--- linux-2.6.23.orig/drivers/char/lirc/Makefile	2008-03-14 15:16:11.000000000 +0000
+++ linux-2.6.23/drivers/char/lirc/Makefile	2008-03-14 15:16:14.000000000 +0000
@@ -17,5 +17,5 @@
 obj-$(CONFIG_LIRC_SASEM) += lirc_sasem.o
 obj-$(CONFIG_LIRC_SERIAL) += lirc_serial.o
 obj-$(CONFIG_LIRC_SIR) += lirc_sir.o
-obj-$(CONFIG_ST_LIRC) += lirc_stm.o
+obj-$(CONFIG_LIRC_STM) += lirc_stm.o
 obj-$(CONFIG_LIRC_STREAMZAP) += lirc_streamzap.o
Index: linux-2.6.23/arch/sh/boards/st/mb618/setup.c
===================================================================
--- linux-2.6.23.orig/arch/sh/boards/st/mb618/setup.c	2008-03-14 15:09:11.000000000 +0000
+++ linux-2.6.23/arch/sh/boards/st/mb618/setup.c	2008-03-14 15:16:28.000000000 +0000
@@ -200,9 +200,9 @@
 	stx7111_configure_ssc(&ssc_private_info);
 	stx7111_configure_usb();
 	stx7111_configure_ethernet(1, 0, 0, 0);
+        stx7111_configure_lirc();
 #if 0
 	// stx7200_configure_ethernet(1, 0, 1, 1);
-        stx7200_configure_lirc();
 	stx7200_configure_pata(1, ILC_IRQ(6));	/* irq_ilc_ext_in[2] */
 #endif
 
Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c
===================================================================
--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c	2008-03-14 15:09:11.000000000 +0000
+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c	2008-03-14 15:54:54.000000000 +0000
@@ -590,22 +590,26 @@
 	[0] = {
 		.bank = 3,
 		.pin  = 3,
-		.dir  = STPIO_IN
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_IR_RX | LIRC_PIO_ON
 	},
 	[1] = {
 		.bank = 3,
 		.pin  = 4,
-		.dir  = STPIO_IN
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_UHF_RX | LIRC_PIO_ON
 	},
 	[2] = {
 		.bank = 3,
 		.pin  = 5,
-		.dir  = STPIO_ALT_OUT
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX /* | LIRC_PIO_ON not available */
 	},
 	[3] = {
 		.bank = 3,
 		.pin  = 6,
-		.dir  = STPIO_ALT_OUT
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX /* | LIRC_PIO_ON not available */
 	}
 };
 
Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7111.c
===================================================================
--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stx7111.c	2008-03-14 15:09:11.000000000 +0000
+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7111.c	2008-03-14 15:16:28.000000000 +0000
@@ -478,6 +478,79 @@
 }
 arch_initcall(stb7111_add_asc);
 
+/* LiRC resources ---------------------------------------------------------- */
+static struct lirc_pio lirc_pios[] = {
+        [0] = {
+		.bank = 3,
+		.pin  = 3,
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_IR_RX | LIRC_PIO_ON
+	},
+	[1] = {
+		.bank = 3,
+		.pin  = 4,
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_UHF_RX /* | LIRC_PIO_ON not available */
+                },
+	[2] = {
+		.bank = 3,
+		.pin  = 5,
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX | LIRC_PIO_ON
+	},
+	[3] = {
+		.bank = 3,
+		.pin  = 6,
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX | LIRC_PIO_ON
+	},
+};
+
+static struct plat_lirc_data lirc_private_info = {
+	/* For the 7111, the clock settings will be calculated by the driver
+	 * from the system clock
+	 */
+	.irbclock	= 0, /* use current_cpu data */
+	.irbclkdiv      = 0, /* automatically calculate */
+	.irbperiodmult  = 0,
+	.irbperioddiv   = 0,
+	.irbontimemult  = 0,
+	.irbontimediv   = 0,
+	.irbrxmaxperiod = 0x5000,
+	.sysclkdiv	= 1,
+	.rxpolarity	= 1,
+	.pio_pin_arr  = lirc_pios,
+	.num_pio_pins = ARRAY_SIZE(lirc_pios)
+};
+
+static struct resource lirc_resource[]= {
+        [0] = {
+		.start = 0xfd018000,
+		.end   = 0xfd018000 + 0xa0,
+	        .flags = IORESOURCE_MEM
+	},
+	[1] = {
+		.start = evt2irq(0x11a0),
+		.end   = evt2irq(0x11a0),
+	        .flags = IORESOURCE_IRQ
+	},
+};
+
+static struct platform_device lirc_device = {
+	.name           = "lirc",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(lirc_resource),
+	.resource       = lirc_resource,
+	.dev = {
+	           .platform_data = &lirc_private_info
+	}
+};
+
+void __init stx7111_configure_lirc(void)
+{
+	platform_device_register(&lirc_device);
+}
+
 /* NAND Resources ---------------------------------------------------------- */
 
 static void nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7200.c
===================================================================
--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stx7200.c	2008-03-14 15:09:11.000000000 +0000
+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stx7200.c	2008-03-14 15:54:54.000000000 +0000
@@ -729,22 +729,26 @@
 	[0] = {
 		.bank = 3,
 		.pin  = 3,
-		.dir  = STPIO_IN
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_IR_RX | LIRC_PIO_ON
 	},
 	[1] = {
 		.bank = 3,
 		.pin  = 4,
-		.dir  = STPIO_IN
+		.dir  = STPIO_IN,
+                .pinof= 0x00 | LIRC_UHF_RX | LIRC_PIO_ON
 	},
 	[2] = {
 		.bank = 3,
 		.pin  = 5,
-		.dir  = STPIO_ALT_OUT
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX | LIRC_PIO_ON
 	},
 	[3] = {
 		.bank = 3,
 		.pin  = 6,
-		.dir  = STPIO_ALT_OUT
+		.dir  = STPIO_ALT_OUT,
+                .pinof= 0x00 | LIRC_IR_TX | LIRC_PIO_ON
 	}
 };
 
Index: linux-2.6.23/include/linux/stm/soc.h
===================================================================
--- linux-2.6.23.orig/include/linux/stm/soc.h	2008-03-14 15:09:11.000000000 +0000
+++ linux-2.6.23/include/linux/stm/soc.h	2008-03-14 15:54:54.000000000 +0000
@@ -52,10 +52,16 @@
 #define PLAT_STM_PWM_OUT1	(1<<1)
 
 /* This is the private platform data for the lirc driver */
+#define LIRC_PIO_ON		0x08	/* PIO pin available */
+#define LIRC_IR_RX		0x04	/* IR RX PIO line available */
+#define LIRC_IR_TX		0x02	/* IR TX PIOs lines available */
+#define LIRC_UHF_RX		0x01	/* UHF RX PIO line available */
+
 struct lirc_pio {
 	unsigned int bank;
 	unsigned int pin;
 	unsigned int dir;
+	char pinof;
         struct stpio_pin* pinaddr;
 };
 
@@ -159,10 +165,10 @@
 void stx7111_configure_usb(void);
 void stx7111_configure_ethernet(int en_mii, int sel, int ext_clk, int phy_bus);
 void stx7111_configure_nand(struct nand_config_data *data);
+void stx7111_configure_lirc(void);
 
 void stx7200_early_device_init(void);
 void stx7200_configure_asc(const int *ascs, int num_ascs, int console);
-
 void stx7200_configure_pwm(struct plat_stm_pwm_data *data);
 void stx7200_configure_ssc(struct plat_ssc_data *data);
 void stx7200_configure_usb(void);
