Move the M41ST85Y RTC driver from the generic I2C framework to the new RTC
driver framework.

Signed-off-by: Angelo Castello <angelo.castello>

diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/Kconfig linux-2.6.17.13_stm22_0036/drivers/i2c/chips/Kconfig
--- linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/Kconfig	2006-11-17 16:58:10.854208000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/i2c/chips/Kconfig	2006-11-20 07:04:18.119839000 +0000
@@ -140,32 +140,4 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called max6875.
 
-config  SENSORS_M41ST85Y
-        tristate "M41ST85Y RTC Driver (EXPERIMENTAL)"
-        depends on CPU_SUBTYPE_ST40 && (I2C_STM || I2C_ST40_PIO) && EXPERIMENTAL
-        help
-          Enable this entry to support the external M41ST85Y Real Time Clock
-	  device series roundly fitted on some I2C serial bus interface seeng that
-          nothing board have one.
-
-config SENSORS_M41ST85Y_IRQPIO
-        depends on SENSORS_M41ST85Y
-	hex "IRQ PIO value"
-	default "0xff"
-	help
-	  This set the PIO pin to be use as RTC-IRQ line.
-          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
-	  For example, an address of 0x0F represents PIO1[7]. Default is
-          an invalid value.
-
-config SENSORS_M41ST85Y_SQWPIO
-        depends on SENSORS_M41ST85Y
-	hex "SQW PIO value"
-	default "0xff"
-	help
-	  This set the PIO pin to be use as RTC-SQW line.
-          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
-	  For example, an address of 0x07 represents PIO0[7]. Default is
-          an invalid value.
-
 endmenu
diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/m41st85y.c linux-2.6.17.13_stm22_0036/drivers/i2c/chips/m41st85y.c
--- linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/m41st85y.c	2006-11-17 16:58:11.064211000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/i2c/chips/m41st85y.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,733 +0,0 @@
-/* STMicroelectronics
-
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, wrssc to the Free Software
-* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
-#include <linux/interrupt.h>
-#include <linux/rtc.h>
-#include <linux/poll.h>
-#include <linux/i2c.h>
-#include <linux/bcd.h>
-#include <linux/wait.h>
-#include <linux/delay.h>
-#include <linux/irq.h>
-#include <linux/stpio.h>
-#include <asm/io.h>
-
-/* General debugging */
-#undef M41ST85Y_DEBUG
-#ifdef  M41ST85Y_DEBUG
-#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
-#else
-#define DPRINTK(fmt, args...)
-#endif
-
-#define M41ST85Y_NAME		"m41st85y"
-#define M41ST85Y_NREGMAP	0x14	/* no of RTC's registers */
-#define M41ST85Y_ADDR		0x68	/* MY41ST85Y slave address */
-#define M41ST85Y_ISOPEN		0x01	/* means /dev/rtc is in use */
-#define M41ST85Y_RD		0x01	/* read flag for a i2c transfer */
-#define M41ST85Y_WR		0x00	/* write flag for a i2c transfer */
-#define M41ST85Y_INVALID	0xff	/* invalid value */
-#define M41ST85Y_IRQ_LEVEL	0x01	/* default value. 1=High, 0=Low */
-#define M41ST85Y_SQW_LEVEL	0x00	/* default value. 1=High, 0=Low */
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)
-#define M41ST85Y_NOBUS		0x03	/* number of I2C busses */
-#else
-#error platform not supported.
-#endif
-
-/*
- * Addressing compliante to SPI PIO address mechanism
- * Address = [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
- */
-#define m41st85y_get_pioport(address)	((address >> 0x03) & 0x0f)
-#define m41st85y_get_piopin(address)	(address & 0x07)
-
-struct m41st85y_s {
-	struct i2c_adapter *adapter;
-	long data_queue;
-	wait_queue_head_t wait_queue;
-	unsigned long status;
-	unsigned long epoch;
-	unsigned long irqp;
-	spinlock_t lock;
-	spinlock_t task_lock;
-	rtc_task_t *task_callback;
-	unsigned int cmd;
-} m41st85y;
-
-static __u8 rbuf[M41ST85Y_NREGMAP];
-static __u8 wbuf[M41ST85Y_NREGMAP];
-static __u32 busid = M41ST85Y_NOBUS;
-static __u32 irqpio = CONFIG_SENSORS_M41ST85Y_IRQPIO, sqwpio =
-    CONFIG_SENSORS_M41ST85Y_SQWPIO;
-static struct stpio_pin *m41st85y_irqpio, *m41st85y_sqwpio;
-
-static int m41st85y_transfer(struct m41st85y_s *instance,
-			     __u8 * buf, __u8 len, __u8 oper, __u8 at_addr)
-{
-	struct i2c_msg msg[2];
-	__u8 n_msg;
-
-	if (oper == M41ST85Y_WR) {
-		msg[0].addr = M41ST85Y_ADDR;
-		msg[0].flags = oper;
-		msg[0].len = len;
-		msg[0].buf = buf;
-		n_msg = 1;
-	} else {
-		rbuf[0] = at_addr;
-		msg[0].addr = M41ST85Y_ADDR;
-		msg[0].flags = M41ST85Y_WR;
-		msg[0].len = 1;
-		msg[0].buf = rbuf;
-
-		msg[1].addr = M41ST85Y_ADDR;
-		msg[1].flags = M41ST85Y_RD;
-		msg[1].len = len;
-		msg[1].buf = buf;
-		n_msg = 2;
-	}
-	return i2c_transfer(instance->adapter, msg, n_msg);
-}
-
-static int m41st85y_power_up(void)
-{
-	__u8 RegsMap[M41ST85Y_NREGMAP];
-
-	while (1) {
-		m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0F);
-		if ((rbuf[0] & 0x40) == 0x00)
-			break;
-		printk(KERN_INFO
-		       "There was an alarm during the back-up mode AF 0x%x\n",
-		       rbuf[0]);
-	}
-
-	if (m41st85y_transfer(&m41st85y,
-			      RegsMap + 1, M41ST85Y_NREGMAP - 1,
-			      M41ST85Y_RD, 0x01) >= 0) {
-		RegsMap[0x00] = 0x01;	/* address offset */
-		RegsMap[0x01] &= ~0x80;	/* ST bit, wake up the oscillator */
-		RegsMap[0x08] = 0x80;	/* IRQ/FT/OUT line is driven low */
-		RegsMap[0x0A] &= ~0x40;	/* Swq disable */
-		RegsMap[0x0C] &= ~0x40;	/* Update the TIMEKEEPER registers */
-		RegsMap[0x13] &= 0x00;	/* Default Square wave output is 1Hz */
-		m41st85y.irqp = 1;	/* 1Hz */
-		if (m41st85y_transfer(&m41st85y,
-				      RegsMap, M41ST85Y_NREGMAP,
-				      M41ST85Y_WR, M41ST85Y_INVALID) < 0) {
-			printk(KERN_ERR "I2C transfer write failure\n");
-			return -EIO;
-		}
-		/* waiting RTC hardware restart */
-		ssleep(1);
-		return 0;
-	}
-	printk(KERN_ERR "I2C transfer read failure.\n");
-	return -EIO;
-}
-
-static int m41st85y_alarmset(unsigned int ioctl_cmd, struct rtc_time *ltime)
-{
-	if ((ioctl_cmd != RTC_UIE_ON) && (ioctl_cmd != RTC_ALM_SET))
-		return -1;
-
-	if (ioctl_cmd == RTC_UIE_ON) {
-		rtc_get_rtc_time(ltime);
-
-		/* alarm update */
-		wbuf[0] = 0x0A;
-		wbuf[1] = BIN2BCD(ltime->tm_mon);
-		wbuf[2] = 0xC0 | BIN2BCD(ltime->tm_mday);
-		wbuf[3] = 0x80 | BIN2BCD(ltime->tm_hour);
-		wbuf[4] = 0x80 | BIN2BCD(ltime->tm_min);
-		wbuf[5] = 0x80 | BIN2BCD(ltime->tm_sec + 1);
-		if (m41st85y_transfer(&m41st85y,
-				      wbuf, 6, M41ST85Y_WR,
-				      M41ST85Y_INVALID) >= 0) {
-			wbuf[0] = 0x0A;
-			wbuf[1] = (wbuf[1] | 0x80);
-			DPRINTK("enable AFE writing %#x\n", wbuf[1]);
-			if (m41st85y_transfer(&m41st85y,
-					      wbuf, 2, M41ST85Y_WR,
-					      M41ST85Y_INVALID) >= 0)
-				return 0;
-		}
-	} else {
-		if (m41st85y_transfer(&m41st85y,
-				      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0) {
-			/* alarm update */
-			wbuf[0] = 0x0A;
-			wbuf[1] = (rbuf[0] & 0xE0) | BIN2BCD(ltime->tm_mon);
-			wbuf[2] = (rbuf[1] & 0xC0) | BIN2BCD(ltime->tm_mday);
-			wbuf[3] = (rbuf[2] & 0xC0) | BIN2BCD(ltime->tm_hour);
-			wbuf[4] = (rbuf[3] & 0x80) | BIN2BCD(ltime->tm_min);
-			wbuf[5] = (rbuf[4] & 0x80) | BIN2BCD(ltime->tm_sec);
-			DPRINTK("writing alarm date\n");
-			if (m41st85y_transfer(&m41st85y,
-					      wbuf, 6, M41ST85Y_WR,
-					      M41ST85Y_INVALID) >= 0)
-				return 0;
-		}
-	}
-	return -EIO;
-}
-
-void m41st85y_handler(struct stpio_pin *pin, void *dev)
-{
-	struct m41st85y_s *instance = dev;
-	char skip = 0;
-
-	stpio_disable_irq(pin);
-
-	if ((instance->cmd == RTC_PIE_ON) || (instance->cmd == RTC_UIE_ON)) {
-		if (stpio_get_pin(pin) == M41ST85Y_IRQ_LEVEL) {
-			skip = 1;
-			stpio_enable_irq(pin, M41ST85Y_IRQ_LEVEL);
-		} else
-			stpio_enable_irq(pin, !M41ST85Y_IRQ_LEVEL);
-	}
-
-	if (!skip) {
-		/* Now do the rest of the actions */
-		spin_lock(&instance->task_lock);
-		if (instance->task_callback)
-			instance->task_callback->func(instance->task_callback->
-						      private_data);
-		spin_unlock(&instance->task_lock);
-
-		instance->data_queue++;
-		wake_up(&instance->wait_queue);
-	}
-}
-
-static int m41st85y_ioctl(struct inode *inode,
-			  struct file *file,
-			  unsigned int cmd, unsigned long arg)
-{
-	struct rtc_time ltime;
-
-	memset(&ltime, 0, sizeof(struct rtc_time));
-	m41st85y.cmd = cmd;
-
-	switch (cmd) {
-	case RTC_UIE_OFF:	/* Mask ints from RTC updates.  */
-		DPRINTK("RTC_UIE_OFF\n");
-	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit    */
-		DPRINTK("RTC_AIE_OFF\n");
-	case RTC_AIE_ON:	/* Allow alarm interrupts.      */
-		{
-			DPRINTK("RTC_AIE_ON\n");
-
-			/* reading AFE bits */
-			if (m41st85y_transfer(&m41st85y,
-					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
-			{
-				char n_data = 2;
-
-				wbuf[0] = 0x0A;
-				if (cmd == RTC_AIE_ON) {
-					stpio_enable_irq(m41st85y_irqpio,
-							 M41ST85Y_IRQ_LEVEL);
-					wbuf[1] = (rbuf[0] | 0x80);
-				} else {
-					stpio_disable_irq(m41st85y_irqpio);
-					m41st85y.cmd = 0;	/* disable status */
-					n_data = 6;
-					wbuf[1] = (rbuf[0] & ~0xA0);	/* disabling AFE flag bit */
-					wbuf[2] = wbuf[3] = wbuf[4] = wbuf[5] = 0x00;	/* disabling RPT5-RPT1 */
-				}
-
-				DPRINTK(" writing AFE %#x\n", wbuf[1]);
-				if (m41st85y_transfer(&m41st85y,
-						      wbuf, n_data, M41ST85Y_WR,
-						      M41ST85Y_INVALID) >= 0) {
-					return 0;
-				}
-			}
-			return -EIO;
-		}
-	case RTC_PIE_OFF:	/* Mask periodic int. enab. bit */
-		DPRINTK("RTC_PIE_OFF\n");
-	case RTC_PIE_ON:	/* Allow periodic ints          */
-		{
-			DPRINTK("RTC_PIE_ON\n");
-			if (m41st85y_transfer(&m41st85y,
-					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
-			{
-				wbuf[0] = 0x0A;
-				if (cmd == RTC_PIE_OFF) {
-					stpio_disable_irq(m41st85y_sqwpio);
-					wbuf[1] = (rbuf[0] & ~0x40);
-				} else {
-					stpio_enable_irq(m41st85y_sqwpio,
-							 M41ST85Y_SQW_LEVEL);
-					wbuf[1] = (rbuf[0] | 0x40);
-				}
-
-				DPRINTK("writing on SWQE %#x\n", wbuf[1]);
-				if (m41st85y_transfer(&m41st85y,
-						      wbuf, 2, M41ST85Y_WR,
-						      M41ST85Y_INVALID) >= 0)
-					return 0;
-			}
-			return -EIO;
-		}
-	case RTC_UIE_ON:	/* Allow ints for RTC updates. (one per second) */
-		{
-			DPRINTK("RTC_UIE_ON\n");
-			stpio_enable_irq(m41st85y_irqpio, M41ST85Y_IRQ_LEVEL);
-			return m41st85y_alarmset(cmd, &ltime);
-		}
-	case RTC_ALM_READ:	/* Read the present alarm time */
-		{
-			DPRINTK("RTC_ALM_READ\n");
-			if (m41st85y_transfer(&m41st85y,
-					      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0)
-			{
-				ltime.tm_mon = BCD2BIN(rbuf[0] & 0x1f);
-				ltime.tm_mday = BCD2BIN(rbuf[1] & 0x3f);
-				ltime.tm_hour = BCD2BIN(rbuf[2] & 0x3f);
-				ltime.tm_min = BCD2BIN(rbuf[3] & 0x7f);
-				ltime.tm_sec = BCD2BIN(rbuf[4] & 0x7f);
-				return copy_to_user((void __user *)arg,
-						    &ltime,
-						    sizeof ltime) ? -EFAULT : 0;
-			}
-			return -EIO;
-		}
-	case RTC_ALM_SET:	/* Store a time into the alarm */
-		{
-			DPRINTK("RTC_ALM_SET\n");
-			if (copy_from_user
-			    (&ltime, (struct rtc_time __user *)arg,
-			     sizeof ltime))
-				return -EFAULT;
-			return m41st85y_alarmset(cmd, &ltime);
-		}
-	case RTC_RD_TIME:	/* Read the time/date from RTC  */
-		{
-			DPRINTK("RTC_RD_TIME\n");
-			rtc_get_rtc_time(&ltime);
-			return copy_to_user((void __user *)arg,
-					    &ltime, sizeof ltime) ? -EFAULT : 0;
-		}
-	case RTC_SET_TIME:	/* Set the RTC */
-		{
-			DPRINTK("RTC_SET_TIME\n");
-			if (copy_from_user
-			    (&ltime, (struct rtc_time __user *)arg,
-			     sizeof ltime))
-				return -EFAULT;
-
-			if (m41st85y_transfer(&m41st85y,
-					      rbuf, 8, M41ST85Y_RD, 0x00) >= 0)
-			{
-				/* time update */
-				wbuf[0] = 0x00;
-				wbuf[1] = 0x00;
-				wbuf[2] =
-				    (rbuf[1] & 0x80) | BIN2BCD(ltime.tm_sec);
-				wbuf[3] =
-				    (rbuf[2] & 0x80) | BIN2BCD(ltime.tm_min);
-				wbuf[4] =
-				    (rbuf[3] & 0xC0) | BIN2BCD(ltime.tm_hour);
-				memcpy(&wbuf[5], &rbuf[4], sizeof(char));
-				wbuf[6] =
-				    (rbuf[5] & 0xC0) | BIN2BCD(ltime.tm_mday);
-				wbuf[7] =
-				    (rbuf[6] & 0xE0) | BIN2BCD(ltime.tm_mon);
-				wbuf[8] =
-				    BIN2BCD((ltime.tm_year - m41st85y.epoch));
-
-				if (m41st85y_transfer(&m41st85y,
-						      wbuf, 9, M41ST85Y_WR,
-						      M41ST85Y_INVALID) >= 0)
-					return 0;
-			}
-			return -EIO;
-		}
-	case RTC_IRQP_READ:	/* Read the periodic IRQ rate.  */
-		{
-			DPRINTK("RTC_IRQP_READ\n");
-			return put_user(m41st85y.irqp,
-					(unsigned long __user *)arg);
-		}
-	case RTC_IRQP_SET:	/* Set periodic IRQ rate.       */
-		{
-			DPRINTK("RTC_IRQP_SET\n");
-			wbuf[0] = 0x13;
-			switch (arg) {
-			case 0:
-				wbuf[1] = 0x00;
-				break;
-			case 1:
-				wbuf[1] = 0xF0;
-				break;
-			case 2:
-				wbuf[1] = 0xE0;
-				break;
-			case 4:
-				wbuf[1] = 0xD0;
-				break;
-			case 8:
-				wbuf[1] = 0xC0;
-				break;
-			case 16:
-				wbuf[1] = 0xB0;
-				break;
-			case 32:
-				wbuf[1] = 0xA0;
-				break;
-			case 64:
-				wbuf[1] = 0x90;
-				break;
-			case 128:
-				wbuf[1] = 0x80;
-				break;
-			case 256:
-				wbuf[1] = 0x70;
-				break;
-			case 512:
-				wbuf[1] = 0x60;
-				break;
-			case 1024:
-				wbuf[1] = 0x50;
-				break;
-			case 2048:
-				wbuf[1] = 0x40;
-				break;
-			case 4096:
-				wbuf[1] = 0x30;
-				break;
-			case 8192:
-				wbuf[1] = 0x20;
-				break;
-			case 32768:
-				wbuf[1] = 0x10;
-				break;
-			default:
-				return -1;
-			}
-
-			if (m41st85y_transfer(&m41st85y,
-					      wbuf, 2, M41ST85Y_WR,
-					      M41ST85Y_INVALID) >= 0)
-				return 0;
-			return -EIO;
-		}
-	case RTC_EPOCH_READ:	/* Read the epoch.      */
-		{
-			DPRINTK("RTC_EPOCH_READ\n");
-			return put_user(m41st85y.epoch,
-					(unsigned long __user *)arg);
-		}
-	case RTC_EPOCH_SET:	/* Set the epoch.       */
-		{
-			DPRINTK("RTC_EPOCH_SET\n");
-			copy_from_user(&m41st85y.epoch, (void *)arg,
-				       sizeof(long));
-			return 0;
-		}
-	default:
-		return -ENOTTY;
-	}
-}
-
-static int m41st85y_open(struct inode *inode, struct file *file)
-{
-	int lerrno = -EBUSY;
-
-	spin_lock_irq(&m41st85y.lock);
-	if (m41st85y.status & M41ST85Y_ISOPEN) {
-		spin_unlock_irq(&m41st85y.lock);
-		return lerrno;
-	}
-
-	m41st85y.status |= M41ST85Y_ISOPEN;
-	m41st85y.data_queue = 0;
-	spin_unlock_irq(&m41st85y.lock);
-	return 0;
-}
-
-static int m41st85y_close(struct inode *inode, struct file *file)
-{
-	spin_lock_irq(&m41st85y.lock);
-	m41st85y.status &= ~M41ST85Y_ISOPEN;
-	spin_unlock_irq(&m41st85y.lock);
-	return 0;
-}
-
-static ssize_t m41st85y_read(struct file *filp, char __user * buff,
-			     size_t count, loff_t * offp)
-{
-	wait_event(m41st85y.wait_queue, m41st85y.data_queue != 0);
-	m41st85y.data_queue = 0;
-
-	if ((m41st85y.cmd == RTC_AIE_ON) || (m41st85y.cmd == RTC_UIE_ON)) {
-		while (1) {
-			m41st85y_transfer(&m41st85y,
-					  rbuf, 1, M41ST85Y_RD, 0x0F);
-
-			DPRINTK("AF 0x%x\n", rbuf[0]);
-			if ((rbuf[0] & 0x40) == 0x00)
-				break;
-		}
-	}
-	copy_to_user(buff, &m41st85y.data_queue, sizeof(m41st85y.data_queue));
-	return sizeof(m41st85y.data_queue);
-}
-
-/*
- * exported stuffs
- */
-
-EXPORT_SYMBOL(rtc_register);
-EXPORT_SYMBOL(rtc_unregister);
-EXPORT_SYMBOL(rtc_control);
-
-int rtc_register(rtc_task_t * task)
-{
-	if (task == NULL || task->func == NULL)
-		return -EINVAL;
-	spin_lock_irq(&m41st85y.lock);
-	if (m41st85y.status & M41ST85Y_ISOPEN) {
-		spin_unlock_irq(&m41st85y.lock);
-		return -EBUSY;
-	}
-	spin_lock(&m41st85y.task_lock);
-	if (m41st85y.task_callback) {
-		spin_unlock(&m41st85y.task_lock);
-		spin_unlock_irq(&m41st85y.lock);
-		return -EBUSY;
-	}
-
-	m41st85y.status |= M41ST85Y_ISOPEN;
-	m41st85y.task_callback = task;
-	spin_unlock(&m41st85y.task_lock);
-	spin_unlock_irq(&m41st85y.lock);
-	return 0;
-}
-
-int rtc_control(rtc_task_t * task, unsigned int cmd, unsigned long arg)
-{
-	spin_lock_irq(&m41st85y.task_lock);
-	if (m41st85y.task_callback != task) {
-		spin_unlock_irq(&m41st85y.task_lock);
-		return -ENXIO;
-	}
-	spin_unlock_irq(&m41st85y.task_lock);
-	return m41st85y_ioctl(NULL, NULL, cmd, arg);
-}
-
-int rtc_unregister(rtc_task_t * task)
-{
-	spin_lock_irq(&m41st85y.lock);
-	spin_lock(&m41st85y.task_lock);
-
-	if (m41st85y.task_callback != task) {
-		spin_unlock(&m41st85y.task_lock);
-		spin_unlock_irq(&m41st85y.lock);
-		return -ENXIO;
-	}
-	m41st85y.task_callback = NULL;
-
-	/* diasbilng the RTC's AIE, UIE and PIE control */
-	if (m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0A) >= 0) {
-		wbuf[0] = 0x0A;
-		wbuf[1] = rbuf[0] & ~0xC0;
-		if (m41st85y_transfer(&m41st85y,
-				      wbuf, 2, M41ST85Y_WR,
-				      M41ST85Y_INVALID) >= 0) {
-			m41st85y.status &= ~M41ST85Y_ISOPEN;
-			spin_unlock(&m41st85y.task_lock);
-			spin_unlock_irq(&m41st85y.lock);
-			return 0;
-		}
-	}
-
-	spin_unlock(&m41st85y.task_lock);
-	spin_unlock_irq(&m41st85y.lock);
-	return -EIO;
-}
-
-void rtc_get_rtc_time(struct rtc_time *ltime)
-{
-	if (ltime == NULL)
-		return;
-
-	memset(ltime, 0, sizeof(struct rtc_time));
-
-	if (m41st85y_transfer(&m41st85y, rbuf, 9, M41ST85Y_RD, 0x00) >= 0) {
-		ltime->tm_sec = BCD2BIN(rbuf[1] & 0x7f);
-		ltime->tm_min = BCD2BIN(rbuf[2] & 0x7f);
-		ltime->tm_hour = BCD2BIN(rbuf[3] & 0x3f);
-		ltime->tm_wday = BCD2BIN(rbuf[4] & 0x07);
-		ltime->tm_mday = BCD2BIN(rbuf[5] & 0x3f);
-		ltime->tm_mon = BCD2BIN(rbuf[6] & 0x1f);
-		ltime->tm_year = BCD2BIN(rbuf[7]);
-	}
-}
-
-/*
- * The various file operations we support.
- */
-
-static struct file_operations m41st85y_fops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.read = m41st85y_read,
-	.poll = NULL /* ??? m41st85y_poll */ ,
-	.ioctl = m41st85y_ioctl,
-	.open = m41st85y_open,
-	.release = m41st85y_close,
-	.fasync = NULL /* ??? m41st85y_fasync */ ,
-};
-
-static struct miscdevice m41st85y_dev = {
-	RTC_MINOR,
-	M41ST85Y_NAME,
-	&m41st85y_fops
-};
-
-static int __init m41st85y_init(void)
-{
-	int i = M41ST85Y_NOBUS;
-	struct i2c_msg msg[1];
-
-	if ((irqpio != M41ST85Y_INVALID) && (sqwpio != M41ST85Y_INVALID)) {
-		msg[0].addr = M41ST85Y_ADDR;
-		msg[0].flags = M41ST85Y_WR;
-		msg[0].len = 0;
-		msg[0].buf = NULL;
-		if (busid < M41ST85Y_NOBUS) {
-			DPRINTK("busid[%d]\n", busid);
-			m41st85y.adapter = i2c_get_adapter(busid);
-			if (i2c_transfer(m41st85y.adapter, msg, 1) >= 0)
-				i = busid;
-		} else {
-			/* searching in which bus is the RTC */
-			for (i = 0; i < M41ST85Y_NOBUS; i++) {
-				int res;
-
-				m41st85y.adapter = i2c_get_adapter(i);
-				if ((res =
-				     i2c_transfer(m41st85y.adapter, msg,
-						  1)) >= 0)
-					break;
-				DPRINTK("RTC device isn't on I2C-%d=%d\n", i,
-					res);
-			}
-		}
-		if (i != M41ST85Y_NOBUS) {
-			DPRINTK("RTC device is on I2C-%d=yes\n", i);
-
-			if (m41st85y_power_up() >= 0) {
-				if (misc_register(&m41st85y_dev) == 0) {
-					spin_lock_init(&m41st85y.lock);
-					spin_lock_init(&m41st85y.task_lock);
-					init_waitqueue_head(&
-							    (m41st85y.
-							     wait_queue));
-					m41st85y.cmd = 0;	/* none */
-					m41st85y.epoch = 1900;	/* default value on Linux */
-					printk(KERN_INFO
-					       "RTC-IRQ line plugged on PIO[%d,%d]\n",
-					       m41st85y_get_pioport(irqpio),
-					       m41st85y_get_piopin(irqpio));
-					printk(KERN_INFO
-					       "RTC-SQW line plugged on PIO[%d,%d]\n",
-					       m41st85y_get_pioport(sqwpio),
-					       m41st85y_get_piopin(sqwpio));
-
-					if ((m41st85y_irqpio =
-					     stpio_request_pin
-					     (m41st85y_get_pioport(irqpio),
-					      m41st85y_get_piopin(irqpio),
-					      M41ST85Y_NAME,
-					      STPIO_BIDIR_Z1)) != NULL) {
-						if ((m41st85y_sqwpio =
-						     stpio_request_pin
-						     (m41st85y_get_pioport
-						      (sqwpio),
-						      m41st85y_get_piopin
-						      (sqwpio), M41ST85Y_NAME,
-						      STPIO_IN)) != NULL) {
-							stpio_request_irq
-							    (m41st85y_irqpio,
-							     M41ST85Y_IRQ_LEVEL,
-							     m41st85y_handler,
-							     (void *)&m41st85y);
-							stpio_request_irq
-							    (m41st85y_sqwpio,
-							     M41ST85Y_SQW_LEVEL,
-							     m41st85y_handler,
-							     (void *)&m41st85y);
-
-							printk(KERN_INFO
-							       "STMicroelectronics M41ST85Y RTC Driver up I2C-%d initialized\n",
-							       i);
-							return 0;
-						} else
-							stpio_free_pin
-							    (m41st85y_irqpio);
-					}
-					printk(KERN_ERR
-					       "RTC request irq failure.\n");
-					misc_deregister(&m41st85y_dev);
-				} else
-					printk(KERN_ERR
-					       "RTC driver registration failure.\n");
-			}
-		} else
-			printk(KERN_ERR
-			       "I2C adapter layer initialization failure.\n");
-	} else
-		printk(KERN_ERR
-		       "PIOs input values are required. irqpio=0Xxx sqwpio=0Xxx\n");
-
-	printk(KERN_ERR
-	       "STMicroelectronics M41ST85Y RTC initialization failure.\n");
-	return -ENODEV;
-}
-
-static void __exit m41st85y_exit(void)
-{
-	stpio_free_irq(m41st85y_irqpio);
-	stpio_free_pin(m41st85y_irqpio);
-	stpio_free_irq(m41st85y_sqwpio);
-	stpio_free_pin(m41st85y_sqwpio);
-
-	misc_deregister(&m41st85y_dev);
-	printk(KERN_INFO "STMicroelectronics M41ST85Y RTC Driver released.\n");
-}
-
-module_param(busid, uint, 0644);
-module_param(irqpio, uint, 0644);
-module_param(sqwpio, uint, 0644);
-module_init(m41st85y_init);
-module_exit(m41st85y_exit);
-MODULE_PARM_DESC(busid, "I2C bus ID");
-MODULE_PARM_DESC(irqpio, "PIO port/pin for RTC-IRQ line");
-MODULE_PARM_DESC(busid, "PIO port/pin for RTC-SWQ line");
-MODULE_DESCRIPTION("External RTC upon I2C");
-MODULE_LICENSE("GPL");
diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/Makefile linux-2.6.17.13_stm22_0036/drivers/i2c/chips/Makefile
--- linux-2.6.17.13_stm22_0036.orig/drivers/i2c/chips/Makefile	2006-11-17 16:58:10.874209000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/i2c/chips/Makefile	2006-11-20 07:03:47.989752000 +0000
@@ -15,7 +15,6 @@
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
-obj-$(CONFIG_SENSORS_M41ST85Y)	+= m41st85y.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/rtc/Kconfig linux-2.6.17.13_stm22_0036/drivers/rtc/Kconfig
--- linux-2.6.17.13_stm22_0036.orig/drivers/rtc/Kconfig	2006-11-17 16:59:53.054508000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/rtc/Kconfig	2006-11-20 07:07:30.620405000 +0000
@@ -157,6 +157,34 @@
  	  To compile this driver as a module, choose M here: the
 	  module will be called rtc-sh.
 
+config  RTC_DRV_M41ST85Y
+        tristate "M41ST85Y (EXPERIMENTAL)"
+        depends on RTC_CLASS && CPU_SUBTYPE_ST40 && (I2C_STM || I2C_ST40_PIO) && EXPERIMENTAL
+        help
+          Enable this entry to support the external M41ST85Y Real Time Clock
+	  device series roundly fitted on some I2C serial bus interface seeng that
+          nothing board have one.
+
+config RTC_DRV_M41ST85Y_IRQPIO
+        depends on RTC_DRV_M41ST85Y
+	hex "IRQ PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-IRQ line.
+          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x0F represents PIO1[7]. Default is
+          an invalid value.
+
+config RTC_DRV_M41ST85Y_SQWPIO
+        depends on RTC_DRV_M41ST85Y
+	hex "SQW PIO value"
+	default "0xff"
+	help
+	  This set the PIO pin to be use as RTC-SQW line.
+          Addressing syntax is [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+	  For example, an address of 0x07 represents PIO0[7]. Default is
+          an invalid value.
+
 config RTC_DRV_VR41XX
 	tristate "NEC VR41XX"
 	depends on RTC_CLASS && CPU_VR41XX
diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/rtc/Makefile linux-2.6.17.13_stm22_0036/drivers/rtc/Makefile
--- linux-2.6.17.13_stm22_0036.orig/drivers/rtc/Makefile	2006-11-17 16:59:53.104507000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/rtc/Makefile	2006-11-20 07:06:03.500150000 +0000
@@ -21,3 +21,4 @@
 obj-$(CONFIG_RTC_DRV_SA1100)	+= rtc-sa1100.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
 obj-$(CONFIG_RTC_DRV_SH)	+= rtc-sh.o
+obj-$(CONFIG_RTC_DRV_M41ST85Y)	+= rtc-m41st85y.o
diff -Naur linux-2.6.17.13_stm22_0036.orig/drivers/rtc/rtc-m41st85y.c linux-2.6.17.13_stm22_0036/drivers/rtc/rtc-m41st85y.c
--- linux-2.6.17.13_stm22_0036.orig/drivers/rtc/rtc-m41st85y.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.17.13_stm22_0036/drivers/rtc/rtc-m41st85y.c	2006-11-20 07:29:10.374213000 +0000
@@ -0,0 +1,763 @@
+/* STMicroelectronics
+
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, wrssc to the Free Software
+* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/i2c.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/stpio.h>
+#include <linux/delay.h>
+
+/* General debugging */
+#undef M41ST85Y_DEBUG
+#ifdef  M41ST85Y_DEBUG
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define M41ST85Y_NAME		"m41st85y"
+#define M41ST85Y_NREGMAP	0x14	/* no of RTC's registers */
+#define M41ST85Y_ADDR		0x68	/* MY41ST85Y slave address */
+#define M41ST85Y_ISOPEN		0x01	/* means /dev/rtc is in use */
+#define M41ST85Y_RD		0x01	/* read flag for a i2c transfer */
+#define M41ST85Y_WR		0x00	/* write flag for a i2c transfer */
+#define M41ST85Y_INVALID	0xff	/* invalid value */
+#define M41ST85Y_IRQ_LEVEL	0x01	/* default value. 1=High, 0=Low */
+#define M41ST85Y_SQW_LEVEL	0x00	/* default value. 1=High, 0=Low */
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define M41ST85Y_NOBUS		0x03	/* number of I2C busses */
+#else
+#error platform not supported.
+#endif
+
+/*
+ * Addressing compliante to SPI PIO address mechanism
+ * Address = [7:Not used:7][6:PIO-Port:3][2:PIO-Pin:0]
+ * Ex: PIO0[7] = 0x07, PIO2[5] = 0x15
+ */
+#define m41st85y_get_pioport(address)	((address >> 0x03) & 0x0f)
+#define m41st85y_get_piopin(address)	(address & 0x07)
+
+/* Addresses to scan: none. This chip cannot be detected. */
+static unsigned short normal_i2c[] = { M41ST85Y_ADDR, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD;
+
+/* private data */
+struct m41st85y_s {
+	struct rtc_device *rtc;
+	struct i2c_adapter *adapter;
+	unsigned long status;
+	unsigned long epoch;	/* default linux epoch 1900 */
+	struct stpio_pin *irqpio;	/* PIO used as RTC-IRQ line */
+	struct stpio_pin *sqwpio;	/* PIO used as RTC-SWQ line */
+	unsigned int cmd;
+} m41st85y;
+
+static __u8 rbuf[M41ST85Y_NREGMAP];
+static __u8 wbuf[M41ST85Y_NREGMAP];
+static __u32 busid = M41ST85Y_NOBUS;
+static __u32 irqpio = CONFIG_RTC_DRV_M41ST85Y_IRQPIO /* Ex: 0x07 */ ,
+    sqwpio = CONFIG_RTC_DRV_M41ST85Y_SQWPIO /* Ex: 0x0F */ ;
+
+/* I2C driver interface */
+static int m41st85y_attach(struct i2c_adapter *adapter);
+static int m41st85y_detach(struct i2c_client *client);
+static int m41st85y_probe(struct i2c_adapter *adapter, int address, int kind);
+
+static int m41st85y_transfer(struct m41st85y_s *instance,
+			     __u8 * buf, __u8 len, __u8 oper, __u8 at_addr)
+{
+	struct i2c_msg msg[2];
+	__u8 n_msg;
+	int err = 0;
+
+	if (oper == M41ST85Y_WR) {
+		/* perform write request */
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = oper;
+		msg[0].len = len;
+		msg[0].buf = buf;
+		n_msg = 1;
+	} else {
+		/* perform read request */
+		rbuf[0] = at_addr;
+		msg[0].addr = M41ST85Y_ADDR;
+		msg[0].flags = M41ST85Y_WR;
+		msg[0].len = 1;
+		msg[0].buf = rbuf;
+
+		msg[1].addr = M41ST85Y_ADDR;
+		msg[1].flags = M41ST85Y_RD;
+		msg[1].len = len;
+		msg[1].buf = buf;
+		n_msg = 2;
+	}
+
+	if ((err = i2c_transfer(instance->adapter, msg, n_msg)) != n_msg)
+		(oper == M41ST85Y_WR) ?
+		    printk(KERN_ERR "m41st85y: I2C write failed, err %d\n",
+			   err) : printk(KERN_ERR
+					 "m41st85y: I2C read  failed, err %d\n",
+					 err);
+	return err;
+}
+
+static int m41st85y_power_up(void)
+{
+	__u8 RegsMap[M41ST85Y_NREGMAP];
+	int err = 0;
+
+	while (1) {
+		m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0F);
+		if ((rbuf[0] & 0x40) == 0x00)
+			break;
+		printk(KERN_INFO
+		       "m41st85y: There was an alarm during the back-up mode AF 0x%x\n",
+		       rbuf[0]);
+	}
+
+	if ((err = m41st85y_transfer(&m41st85y,
+				     RegsMap + 1, M41ST85Y_NREGMAP - 1,
+				     M41ST85Y_RD, 0x01)) >= 0) {
+		RegsMap[0x00] = 0x01;	/* address offset */
+		RegsMap[0x01] &= ~0x80;	/* ST bit, wake up the oscillator */
+		RegsMap[0x08] = 0x80;	/* IRQ/FT/OUT line is driven low */
+		RegsMap[0x0A] &= ~0x40;	/* Swq disable */
+		RegsMap[0x0C] &= ~0x40;	/* Update the TIMEKEEPER registers */
+		RegsMap[0x13] &= 0x00;	/* Default Square wave output is 1Hz */
+		/* also irq_freq should be setting up 1Hz at init fase */
+		if ((err = m41st85y_transfer(&m41st85y,
+					     RegsMap, M41ST85Y_NREGMAP,
+					     M41ST85Y_WR,
+					     M41ST85Y_INVALID)) >= 0) {
+			/* waiting RTC hardware restart */
+			ssleep(1);
+			return 0;
+		}
+	}
+	return err;
+}
+
+void m41st85y_handler(struct stpio_pin *pin, void *dev)
+{
+	struct m41st85y_s *instance = dev;
+	__u8 skip = 0, events = 0;
+
+	stpio_disable_irq(pin);
+
+	if ((instance->cmd == RTC_PIE_ON) || (instance->cmd == RTC_UIE_ON)) {
+		if (stpio_get_pin(pin) == M41ST85Y_IRQ_LEVEL) {
+			skip = 1;
+			stpio_enable_irq(pin, M41ST85Y_IRQ_LEVEL);
+		} else
+			stpio_enable_irq(pin, !M41ST85Y_IRQ_LEVEL);
+	}
+
+	if (!skip) {
+		events |= RTC_IRQF;
+		rtc_update_irq(&instance->rtc->class_dev, 1, events);
+	}
+}
+
+static int m41st85y_alarmset(unsigned int ioctl_cmd, struct rtc_time *ltime)
+{
+	/* to be sure that incoming ioctl request can be managed
+	   by this */
+	if ((ioctl_cmd != RTC_UIE_ON) && (ioctl_cmd != RTC_ALM_SET))
+		return -1;
+
+	if (ioctl_cmd == RTC_UIE_ON) {
+		rtc_get_rtc_time(ltime);
+
+		/* alarm update */
+		wbuf[0] = 0x0A;
+		wbuf[1] = BIN2BCD(ltime->tm_mon);
+		wbuf[2] = 0xC0 | BIN2BCD(ltime->tm_mday);
+		wbuf[3] = 0x80 | BIN2BCD(ltime->tm_hour);
+		wbuf[4] = 0x80 | BIN2BCD(ltime->tm_min);
+		wbuf[5] = 0x80 | BIN2BCD(ltime->tm_sec + 1);
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 6, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			wbuf[0] = 0x0A;
+			wbuf[1] = (wbuf[1] | 0x80);
+			DPRINTK("enable AFE writing %#x\n", wbuf[1]);
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 2, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	} else {
+		if (m41st85y_transfer(&m41st85y,
+				      rbuf, 6, M41ST85Y_RD, 0x0A) >= 0) {
+			/* alarm update */
+			wbuf[0] = 0x0A;
+			wbuf[1] = (rbuf[0] & 0xE0) | BIN2BCD(ltime->tm_mon);
+			wbuf[2] = (rbuf[1] & 0xC0) | BIN2BCD(ltime->tm_mday);
+			wbuf[3] = (rbuf[2] & 0xC0) | BIN2BCD(ltime->tm_hour);
+			wbuf[4] = (rbuf[3] & 0x80) | BIN2BCD(ltime->tm_min);
+			wbuf[5] = (rbuf[4] & 0x80) | BIN2BCD(ltime->tm_sec);
+			DPRINTK("writing alarm date\n");
+			if (m41st85y_transfer(&m41st85y,
+					      wbuf, 6, M41ST85Y_WR,
+					      M41ST85Y_INVALID) >= 0)
+				return 0;
+		}
+	}
+	return -EIO;
+}
+
+static int m41st85y_open(struct device *dev)
+{
+	/* locked at top level until the device will be 
+	   release */
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		return -EBUSY;
+	}
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	return 0;
+}
+
+static void m41st85y_release(struct device *dev)
+{
+	m41st85y.status &= ~M41ST85Y_ISOPEN;
+	/* unlocked at top level before to be use it again */
+}
+
+static int m41st85y_read_time(struct device *dev, struct rtc_time *time_read)
+{
+	if (time_read == NULL)
+		return -EIO;
+
+	memset(time_read, 0, sizeof(struct rtc_time));
+
+	if (m41st85y_transfer(&m41st85y, rbuf, 9, M41ST85Y_RD, 0x00) >= 0) {
+		time_read->tm_sec = BCD2BIN(rbuf[1] & 0x7f);
+		time_read->tm_min = BCD2BIN(rbuf[2] & 0x7f);
+		time_read->tm_hour = BCD2BIN(rbuf[3] & 0x3f);
+		time_read->tm_wday = BCD2BIN(rbuf[4] & 0x07);
+		time_read->tm_mday = BCD2BIN(rbuf[5] & 0x3f);
+		time_read->tm_mon = BCD2BIN(rbuf[6] & 0x1f);
+		time_read->tm_year = BCD2BIN(rbuf[7]);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int m41st85y_set_time(struct device *dev, struct rtc_time *time_to_write)
+{
+	int err;
+
+	/* this is already part of mutex area performed at top level */
+	if ((err = m41st85y_transfer(&m41st85y,
+				     rbuf, 8, M41ST85Y_RD, 0x00)) >= 0) {
+		/* time update */
+		wbuf[0] = 0x00;
+		wbuf[1] = 0x00;
+		wbuf[2] = (rbuf[1] & 0x80) | BIN2BCD(time_to_write->tm_sec);
+		wbuf[3] = (rbuf[2] & 0x80) | BIN2BCD(time_to_write->tm_min);
+		wbuf[4] = (rbuf[3] & 0xC0) | BIN2BCD(time_to_write->tm_hour);
+		memcpy(&wbuf[5], &rbuf[4], sizeof(char));
+		wbuf[6] = (rbuf[5] & 0xC0) | BIN2BCD(time_to_write->tm_mday);
+		wbuf[7] = (rbuf[6] & 0xE0) | BIN2BCD(time_to_write->tm_mon);
+		wbuf[8] = BIN2BCD((time_to_write->tm_year - m41st85y.epoch));
+
+		err = m41st85y_transfer(&m41st85y,
+					wbuf, 9, M41ST85Y_WR, M41ST85Y_INVALID);
+	}
+	return err;
+}
+
+static int m41st85y_read_alarm(struct device *dev,
+			       struct rtc_wkalrm *alarm_read)
+{
+	int err = 0;
+
+	if (alarm_read != NULL) {
+		if ((err = m41st85y_transfer(&m41st85y,
+					     rbuf, 6, M41ST85Y_RD, 0x0A)) >= 0)
+		{
+			alarm_read->time.tm_mon = BCD2BIN(rbuf[0] & 0x1f);
+			alarm_read->time.tm_mday = BCD2BIN(rbuf[1] & 0x3f);
+			alarm_read->time.tm_hour = BCD2BIN(rbuf[2] & 0x3f);
+			alarm_read->time.tm_min = BCD2BIN(rbuf[3] & 0x7f);
+			alarm_read->time.tm_sec = BCD2BIN(rbuf[4] & 0x7f);
+		}
+	} else
+		err = -EIO;
+
+	return err;
+}
+
+static int m41st85y_set_alarm(struct device *dev,
+			      struct rtc_wkalrm *alarm_to_write)
+{
+	return m41st85y_alarmset(RTC_ALM_SET, &alarm_to_write->time);
+}
+
+static int m41st85y_ioctl(struct device *dev, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct rtc_time ltime;
+	int err = 0;
+
+	memset(&ltime, 0, sizeof(struct rtc_time));
+	m41st85y.cmd = cmd;
+
+	switch (cmd) {
+	case RTC_UIE_OFF:	/* Mask ints from RTC updates.  */
+	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit    */
+	case RTC_AIE_ON:	/* Allow alarm interrupts.      */
+		{
+			/* reading AFE bits */
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				char n_data = 2;
+
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_AIE_ON) {
+					stpio_enable_irq(m41st85y.irqpio,
+							 M41ST85Y_IRQ_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x80);
+				} else {
+					stpio_disable_irq(m41st85y.irqpio);
+					m41st85y.cmd = 0;	/* disable status */
+					n_data = 6;
+					wbuf[1] = (rbuf[0] & ~0xA0);	/* disabling AFE flag bit */
+					wbuf[2] = wbuf[3] = wbuf[4] = wbuf[5] = 0x00;	/* disabling RPT5-RPT1 */
+				}
+
+				DPRINTK("writing AFE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, n_data, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0) {
+					return 0;
+				}
+			}
+			return -EIO;
+		}
+	case RTC_PIE_OFF:	/* Mask periodic int. enab. bit */
+	case RTC_PIE_ON:	/* Allow periodic ints          */
+		{
+			if (m41st85y_transfer(&m41st85y,
+					      rbuf, 1, M41ST85Y_RD, 0x0A) >= 0)
+			{
+				wbuf[0] = 0x0A;
+				if (cmd == RTC_PIE_OFF) {
+					stpio_disable_irq(m41st85y.sqwpio);
+					wbuf[1] = (rbuf[0] & ~0x40);
+				} else {
+					stpio_enable_irq(m41st85y.sqwpio,
+							 M41ST85Y_SQW_LEVEL);
+					wbuf[1] = (rbuf[0] | 0x40);
+				}
+
+				DPRINTK("writing on SWQE %#x\n", wbuf[1]);
+				if (m41st85y_transfer(&m41st85y,
+						      wbuf, 2, M41ST85Y_WR,
+						      M41ST85Y_INVALID) >= 0)
+					return 0;
+			}
+			return -EIO;
+		}
+	case RTC_UIE_ON:	/* Allow ints for RTC updates. (one per second) */
+		{
+			stpio_enable_irq(m41st85y.irqpio, M41ST85Y_IRQ_LEVEL);
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_ALM_READ:	/* Read the present alarm time */
+		{
+			struct rtc_wkalrm alarm_read;
+
+			if ((err = m41st85y_read_alarm(NULL, &alarm_read)) >= 0)
+				return copy_to_user((void __user *)arg,
+						    &alarm_read.time,
+						    sizeof alarm_read.
+						    time) ? -EFAULT : 0;
+			return err;
+		}
+	case RTC_ALM_SET:	/* Store a time into the alarm */
+		{
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+			return m41st85y_alarmset(cmd, &ltime);
+		}
+	case RTC_RD_TIME:	/* Read the time/date from RTC  */
+		{
+			rtc_get_rtc_time(&ltime);
+			return copy_to_user((void __user *)arg,
+					    &ltime, sizeof ltime) ? -EFAULT : 0;
+		}
+	case RTC_SET_TIME:	/* Set the RTC */
+		{
+			if (copy_from_user
+			    (&ltime, (struct rtc_time __user *)arg,
+			     sizeof ltime))
+				return -EFAULT;
+
+			return m41st85y_set_time(dev, &ltime);
+		}
+	case RTC_IRQP_READ:	/* Read the periodic IRQ rate.  */
+		{
+			return put_user(m41st85y.rtc->irq_freq,
+					(unsigned long __user *)arg);
+		}
+	case RTC_IRQP_SET:	/* Set periodic IRQ rate.       */
+		{
+			wbuf[0] = 0x13;
+			switch (arg) {
+			case 0:
+				wbuf[1] = 0x00;
+				break;
+			case 1:
+				wbuf[1] = 0xF0;
+				break;
+			case 2:
+				wbuf[1] = 0xE0;
+				break;
+			case 4:
+				wbuf[1] = 0xD0;
+				break;
+			case 8:
+				wbuf[1] = 0xC0;
+				break;
+			case 16:
+				wbuf[1] = 0xB0;
+				break;
+			case 32:
+				wbuf[1] = 0xA0;
+				break;
+			case 64:
+				wbuf[1] = 0x90;
+				break;
+			case 128:
+				wbuf[1] = 0x80;
+				break;
+			case 256:
+				wbuf[1] = 0x70;
+				break;
+			case 512:
+				wbuf[1] = 0x60;
+				break;
+			case 1024:
+				wbuf[1] = 0x50;
+				break;
+			case 2048:
+				wbuf[1] = 0x40;
+				break;
+			case 4096:
+				wbuf[1] = 0x30;
+				break;
+			case 8192:
+				wbuf[1] = 0x20;
+				break;
+			default:
+				return -ENOTSUPP;
+			}
+
+			if ((err = m41st85y_transfer(&m41st85y,
+						     wbuf, 2, M41ST85Y_WR,
+						     M41ST85Y_INVALID)) >= 0) {
+				m41st85y.rtc->irq_freq = arg;
+				return 0;
+			}
+
+			return err;
+		}
+	case RTC_EPOCH_READ:	/* Read the epoch.      */
+		{
+			return put_user(m41st85y.epoch,
+					(unsigned long __user *)arg);
+		}
+	case RTC_EPOCH_SET:	/* Set the epoch.       */
+		{
+			copy_from_user(&m41st85y.epoch, (void *)arg,
+				       sizeof(long));
+			return 0;
+		}
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int m41st85y_read_callback(struct device *dev, int data)
+{
+	if (data & RTC_IRQF) {
+		if ((m41st85y.cmd == RTC_AIE_ON)
+		    || (m41st85y.cmd == RTC_UIE_ON)) {
+			while (1) {
+				m41st85y_transfer(&m41st85y,
+						  rbuf, 1, M41ST85Y_RD, 0x0F);
+
+				DPRINTK("AF 0x%x\n", rbuf[0]);
+				if ((rbuf[0] & 0x40) == 0x00)
+					break;
+			}
+		}
+	}
+	return data;
+}
+
+static int m41st85y_irq_set_state(struct device *dev, int enabled)
+{
+	if (enabled)
+		return m41st85y_ioctl(dev, RTC_PIE_ON, 0);
+	else
+		return m41st85y_ioctl(dev, RTC_PIE_OFF, 0);
+}
+
+static int m41st85y_irq_set_freq(struct device *dev, int freq)
+{
+	return m41st85y_ioctl(dev, RTC_IRQP_SET, freq);
+}
+
+static struct rtc_class_ops m41st85y_rtc_ops = {
+	.open = m41st85y_open,
+	.release = m41st85y_release,
+	.ioctl = m41st85y_ioctl,
+	.read_time = m41st85y_read_time,
+	.set_time = m41st85y_set_time,
+	.read_alarm = m41st85y_read_alarm,
+	.set_alarm = m41st85y_set_alarm,
+	.irq_set_state = m41st85y_irq_set_state,
+	.irq_set_freq = m41st85y_irq_set_freq,
+	.read_callback = m41st85y_read_callback,
+
+};
+
+static struct i2c_driver m41st85y_driver = {
+	.driver = {
+		   .name = "m41st85y",
+		   },
+	.attach_adapter = &m41st85y_attach,
+	.detach_client = &m41st85y_detach,
+};
+
+static int m41st85y_attach(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, m41st85y_probe);
+}
+
+static int m41st85y_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	int err = 0;
+	struct i2c_client *client;
+	struct rtc_device *rtc_dev;
+
+	m41st85y.adapter = adapter;
+
+	if (m41st85y_power_up() >= 0) {
+
+		if (!(client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL))) {
+			err = -ENOMEM;
+			goto exit_err;
+		}
+
+		/* I2C client */
+		client->addr = address;
+		client->driver = &m41st85y_driver;
+		client->adapter = adapter;
+
+		strlcpy(client->name, m41st85y_driver.driver.name,
+			I2C_NAME_SIZE);
+
+		/* Inform the i2c layer */
+		if ((err = i2c_attach_client(client))) {
+			goto exit_kfree;
+		}
+
+		rtc_dev =
+		    rtc_device_register(m41st85y_driver.driver.name,
+					&client->dev, &m41st85y_rtc_ops,
+					THIS_MODULE);
+		if (IS_ERR(rtc_dev)) {
+			err = PTR_ERR(rtc_dev);
+			goto exit_detach;
+		}
+
+		i2c_set_clientdata(client, rtc_dev);
+
+		m41st85y.rtc = rtc_dev;
+		m41st85y.cmd = 0;	/* none */
+		m41st85y.epoch = 1900;	/* default value on Linux */
+		m41st85y.rtc->irq_freq = 1;	/* default square ware 1Hz */
+		printk(KERN_INFO
+		       "m41st85y: IRQ line plugged on PIO%d[%d]\n",
+		       m41st85y_get_pioport(irqpio),
+		       m41st85y_get_piopin(irqpio));
+		printk(KERN_INFO
+		       "m41st85y: SQW line plugged on PIO%d[%d]\n",
+		       m41st85y_get_pioport(sqwpio),
+		       m41st85y_get_piopin(sqwpio));
+
+		if ((m41st85y.irqpio =
+		     stpio_request_pin(m41st85y_get_pioport(irqpio),
+				       m41st85y_get_piopin(irqpio),
+				       M41ST85Y_NAME,
+				       STPIO_BIDIR_Z1)) != NULL) {
+			if ((m41st85y.sqwpio =
+			     stpio_request_pin(m41st85y_get_pioport(sqwpio),
+					       m41st85y_get_piopin(sqwpio),
+					       M41ST85Y_NAME,
+					       STPIO_IN)) != NULL) {
+				stpio_request_irq(m41st85y.irqpio,
+						  M41ST85Y_IRQ_LEVEL,
+						  m41st85y_handler,
+						  (void *)&m41st85y);
+				stpio_request_irq(m41st85y.sqwpio,
+						  M41ST85Y_SQW_LEVEL,
+						  m41st85y_handler,
+						  (void *)&m41st85y);
+				printk(KERN_INFO
+				       "m41st85y: STMicroelectronics M41ST85Y RTC Driver registered\n");
+				return 0;
+			} else
+				stpio_free_pin(m41st85y.irqpio);
+		}
+		printk(KERN_ERR
+		       "m41st85y: STMicroelectronics M41ST85Y RTC Driver unregistered\n");
+		goto exit_detach;
+	}
+
+	return 0;
+      exit_detach:
+	i2c_detach_client(client);
+      exit_kfree:
+	kfree(client);
+      exit_err:
+	return err;
+}
+
+static int m41st85y_detach(struct i2c_client *client)
+{
+	int err;
+	struct rtc_device *rtc_dev = i2c_get_clientdata(client);
+
+	stpio_free_irq(m41st85y.irqpio);
+	stpio_free_irq(m41st85y.sqwpio);
+
+	if (rtc_dev)
+		rtc_device_unregister(rtc_dev);
+
+	if ((err = i2c_detach_client(client)))
+		return err;
+
+	kfree(client);
+	return 0;
+}
+
+static __init int m41st85y_init(void)
+{
+	return i2c_add_driver(&m41st85y_driver);
+}
+
+static __exit void m41st85y_exit(void)
+{
+	i2c_del_driver(&m41st85y_driver);
+}
+
+EXPORT_SYMBOL(rtc_register);
+EXPORT_SYMBOL(rtc_unregister);
+EXPORT_SYMBOL(rtc_control);
+
+int rtc_register(rtc_task_t * task)
+{
+	if (task == NULL || task->func == NULL)
+		return -EINVAL;
+	spin_lock_irq(&m41st85y.rtc->irq_lock);
+	if (m41st85y.status & M41ST85Y_ISOPEN) {
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -EBUSY;
+	}
+	spin_lock(&m41st85y.rtc->irq_task_lock);
+	if (m41st85y.rtc->irq_task) {
+		spin_unlock(&m41st85y.rtc->irq_task_lock);
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -EBUSY;
+	}
+
+	m41st85y.status |= M41ST85Y_ISOPEN;
+	m41st85y.rtc->irq_task = task;
+	spin_unlock(&m41st85y.rtc->irq_task_lock);
+	spin_unlock_irq(&m41st85y.rtc->irq_lock);
+	return 0;
+}
+
+int rtc_control(rtc_task_t * task, unsigned int cmd, unsigned long arg)
+{
+	spin_lock_irq(&m41st85y.rtc->irq_task_lock);
+	if (m41st85y.rtc->irq_task != task) {
+		spin_unlock_irq(&m41st85y.rtc->irq_task_lock);
+		return -ENXIO;
+	}
+	spin_unlock_irq(&m41st85y.rtc->irq_task_lock);
+	return m41st85y_ioctl(NULL, cmd, arg);
+}
+
+int rtc_unregister(rtc_task_t * task)
+{
+	spin_lock_irq(&m41st85y.rtc->irq_lock);
+	spin_lock(&m41st85y.rtc->irq_task_lock);
+
+	if (m41st85y.rtc->irq_task != task) {
+		spin_unlock(&m41st85y.rtc->irq_task_lock);
+		spin_unlock_irq(&m41st85y.rtc->irq_lock);
+		return -ENXIO;
+	}
+	m41st85y.rtc->irq_task = NULL;
+
+	/* diasbilng the RTC's AIE, UIE and PIE control */
+	if (m41st85y_transfer(&m41st85y, rbuf, 1, M41ST85Y_RD, 0x0A) >= 0) {
+		wbuf[0] = 0x0A;
+		wbuf[1] = rbuf[0] & ~0xC0;
+		if (m41st85y_transfer(&m41st85y,
+				      wbuf, 2, M41ST85Y_WR,
+				      M41ST85Y_INVALID) >= 0) {
+			m41st85y.status &= ~M41ST85Y_ISOPEN;
+			spin_unlock(&m41st85y.rtc->irq_task_lock);
+			spin_unlock_irq(&m41st85y.rtc->irq_lock);
+			return 0;
+		}
+	}
+
+	spin_unlock(&m41st85y.rtc->irq_task_lock);
+	spin_unlock_irq(&m41st85y.rtc->irq_lock);
+	return -EIO;
+}
+
+void rtc_get_rtc_time(struct rtc_time *ltime)
+{
+	m41st85y_read_time(NULL, ltime);
+}
+
+module_param(busid, uint, 0644);
+module_param(irqpio, uint, 0644);
+module_param(sqwpio, uint, 0644);
+module_init(m41st85y_init);
+module_exit(m41st85y_exit);
+MODULE_AUTHOR("angelo castello <angelo.castello@st.com>");
+MODULE_PARM_DESC(busid, "I2C bus ID");
+MODULE_PARM_DESC(irqpio, "PIO port/pin for RTC-IRQ line");
+MODULE_PARM_DESC(busid, "PIO port/pin for RTC-SWQ line");
+MODULE_DESCRIPTION("External RTC upon I2C");
+MODULE_LICENSE("GPL");
